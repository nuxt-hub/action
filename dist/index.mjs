import ft from 'node:http';
import Qa from 'node:https';
import Ye from 'node:zlib';
import ie, { PassThrough, pipeline, Readable, Transform, getDefaultHighWaterMark, Duplex, Writable } from 'node:stream';
import { Buffer as Buffer$1 } from 'node:buffer';
import require$$1$1, { promisify, types as types$3, deprecate, formatWithOptions, debuglog, stripVTControlCharacters, inspect, callbackify, aborted } from 'node:util';
import require$$3$2, { format as format$1, fileURLToPath } from 'node:url';
import { isIP } from 'node:net';
import fs$1, { promises, createReadStream, statSync, existsSync, readFileSync, appendFileSync, writeFileSync, createWriteStream } from 'node:fs';
import path, { basename as basename$1, resolve, join, relative, sep, dirname } from 'node:path';
import require$$0, { type, homedir as homedir$1 } from 'os';
import require$$3 from 'crypto';
import require$$0$1, { unwatchFile, watchFile, watch as watch$2, stat as stat$2 } from 'fs';
import * as sysPath from 'path';
import sysPath__default from 'path';
import require$$2 from 'http';
import require$$1 from 'https';
import require$$0$5 from 'net';
import require$$4$1 from 'tls';
import require$$0$3, { EventEmitter } from 'events';
import require$$0$4 from 'assert';
import require$$0$2 from 'util';
import require$$0$6 from 'stream';
import require$$7 from 'buffer';
import require$$8 from 'querystring';
import require$$14 from 'stream/web';
import require$$0$7, { once, addAbortListener, EventEmitter as EventEmitter$1, on, setMaxListeners } from 'node:events';
import require$$0$8 from 'worker_threads';
import require$$2$1 from 'perf_hooks';
import require$$5 from 'util/types';
import require$$4$2 from 'async_hooks';
import require$$1$2 from 'console';
import require$$7$1 from 'url';
import require$$3$1 from 'zlib';
import require$$6 from 'string_decoder';
import require$$0$9 from 'diagnostics_channel';
import require$$2$2 from 'child_process';
import require$$6$1 from 'timers';
import require$$9, { createHash } from 'node:crypto';
import { lstat, stat, readdir as readdir$1, realpath, access } from 'node:fs/promises';
import { realpath as realpath$1, stat as stat$1, lstat as lstat$1, open, readdir as readdir$2 } from 'fs/promises';
import require$$0$a, { homedir, constants as constants$7 } from 'node:os';
import require$$1$3 from 'node:module';
import require$$4$3 from 'node:assert';
import process$2, { platform as platform$2, hrtime, execPath, execArgv } from 'node:process';
import require$$7$2, { serialize } from 'node:v8';
import * as tty from 'node:tty';
import tty__default from 'node:tty';
import require$$11 from 'node:perf_hooks';
import require$$12 from 'node:vm';
import require$$2$3 from 'module';
import require$$5$1 from 'process';
import require$$6$2 from 'tty';
import require$$9$1 from 'v8';
import 'node:readline';
import { ChildProcess, execFile, spawnSync, spawn } from 'node:child_process';
import require$$0$b from 'dgram';
import { StringDecoder } from 'node:string_decoder';
import { setTimeout as setTimeout$1, scheduler, setImmediate as setImmediate$1 } from 'node:timers/promises';
import { finished } from 'node:stream/promises';

const HASH_RE = /#/g;
const AMPERSAND_RE = /&/g;
const SLASH_RE = /\//g;
const EQUAL_RE = /=/g;
const PLUS_RE = /\+/g;
const ENC_CARET_RE = /%5e/gi;
const ENC_BACKTICK_RE = /%60/gi;
const ENC_PIPE_RE = /%7c/gi;
const ENC_SPACE_RE = /%20/gi;
function encode(text) {
  return encodeURI("" + text).replace(ENC_PIPE_RE, "|");
}
function encodeQueryValue(input) {
  return encode(typeof input === "string" ? input : JSON.stringify(input)).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CARET_RE, "^").replace(SLASH_RE, "%2F");
}
function encodeQueryKey(text) {
  return encodeQueryValue(text).replace(EQUAL_RE, "%3D");
}
function decode(text = "") {
  try {
    return decodeURIComponent("" + text);
  } catch {
    return "" + text;
  }
}
function decodeQueryKey(text) {
  return decode(text.replace(PLUS_RE, " "));
}
function decodeQueryValue(text) {
  return decode(text.replace(PLUS_RE, " "));
}

function parseQuery(parametersString = "") {
  const object = /* @__PURE__ */ Object.create(null);
  if (parametersString[0] === "?") {
    parametersString = parametersString.slice(1);
  }
  for (const parameter of parametersString.split("&")) {
    const s = parameter.match(/([^=]+)=?(.*)/) || [];
    if (s.length < 2) {
      continue;
    }
    const key = decodeQueryKey(s[1]);
    if (key === "__proto__" || key === "constructor") {
      continue;
    }
    const value = decodeQueryValue(s[2] || "");
    if (object[key] === void 0) {
      object[key] = value;
    } else if (Array.isArray(object[key])) {
      object[key].push(value);
    } else {
      object[key] = [object[key], value];
    }
  }
  return object;
}
function encodeQueryItem(key, value) {
  if (typeof value === "number" || typeof value === "boolean") {
    value = String(value);
  }
  if (!value) {
    return encodeQueryKey(key);
  }
  if (Array.isArray(value)) {
    return value.map(
      (_value) => `${encodeQueryKey(key)}=${encodeQueryValue(_value)}`
    ).join("&");
  }
  return `${encodeQueryKey(key)}=${encodeQueryValue(value)}`;
}
function stringifyQuery(query) {
  return Object.keys(query).filter((k) => query[k] !== void 0).map((k) => encodeQueryItem(k, query[k])).filter(Boolean).join("&");
}

const PROTOCOL_STRICT_REGEX = /^[\s\w\0+.-]{2,}:([/\\]{1,2})/;
const PROTOCOL_REGEX = /^[\s\w\0+.-]{2,}:([/\\]{2})?/;
const PROTOCOL_RELATIVE_REGEX = /^([/\\]\s*){2,}[^/\\]/;
const JOIN_LEADING_SLASH_RE = /^\.?\//;
function hasProtocol(inputString, opts = {}) {
  if (typeof opts === "boolean") {
    opts = { acceptRelative: opts };
  }
  if (opts.strict) {
    return PROTOCOL_STRICT_REGEX.test(inputString);
  }
  return PROTOCOL_REGEX.test(inputString) || (opts.acceptRelative ? PROTOCOL_RELATIVE_REGEX.test(inputString) : false);
}
function hasTrailingSlash(input = "", respectQueryAndFragment) {
  {
    return input.endsWith("/");
  }
}
function withoutTrailingSlash(input = "", respectQueryAndFragment) {
  {
    return (hasTrailingSlash(input) ? input.slice(0, -1) : input) || "/";
  }
}
function withTrailingSlash(input = "", respectQueryAndFragment) {
  {
    return input.endsWith("/") ? input : input + "/";
  }
}
function withBase(input, base) {
  if (isEmptyURL(base) || hasProtocol(input)) {
    return input;
  }
  const _base = withoutTrailingSlash(base);
  if (input.startsWith(_base)) {
    return input;
  }
  return joinURL(_base, input);
}
function withQuery(input, query) {
  const parsed = parseURL(input);
  const mergedQuery = { ...parseQuery(parsed.search), ...query };
  parsed.search = stringifyQuery(mergedQuery);
  return stringifyParsedURL(parsed);
}
function isEmptyURL(url) {
  return !url || url === "/";
}
function isNonEmptyURL(url) {
  return url && url !== "/";
}
function joinURL(base, ...input) {
  let url = base || "";
  for (const segment of input.filter((url2) => isNonEmptyURL(url2))) {
    if (url) {
      const _segment = segment.replace(JOIN_LEADING_SLASH_RE, "");
      url = withTrailingSlash(url) + _segment;
    } else {
      url = segment;
    }
  }
  return url;
}

const protocolRelative = Symbol.for("ufo:protocolRelative");
function parseURL(input = "", defaultProto) {
  const _specialProtoMatch = input.match(
    /^[\s\0]*(blob:|data:|javascript:|vbscript:)(.*)/i
  );
  if (_specialProtoMatch) {
    const [, _proto, _pathname = ""] = _specialProtoMatch;
    return {
      protocol: _proto.toLowerCase(),
      pathname: _pathname,
      href: _proto + _pathname,
      auth: "",
      host: "",
      search: "",
      hash: ""
    };
  }
  if (!hasProtocol(input, { acceptRelative: true })) {
    return parsePath(input);
  }
  const [, protocol = "", auth, hostAndPath = ""] = input.replace(/\\/g, "/").match(/^[\s\0]*([\w+.-]{2,}:)?\/\/([^/@]+@)?(.*)/) || [];
  let [, host = "", path = ""] = hostAndPath.match(/([^#/?]*)(.*)?/) || [];
  if (protocol === "file:") {
    path = path.replace(/\/(?=[A-Za-z]:)/, "");
  }
  const { pathname, search, hash } = parsePath(path);
  return {
    protocol: protocol.toLowerCase(),
    auth: auth ? auth.slice(0, Math.max(0, auth.length - 1)) : "",
    host,
    pathname,
    search,
    hash,
    [protocolRelative]: !protocol
  };
}
function parsePath(input = "") {
  const [pathname = "", search = "", hash = ""] = (input.match(/([^#?]*)(\?[^#]*)?(#.*)?/) || []).splice(1);
  return {
    pathname,
    search,
    hash
  };
}
function stringifyParsedURL(parsed) {
  const pathname = parsed.pathname || "";
  const search = parsed.search ? (parsed.search.startsWith("?") ? "" : "?") + parsed.search : "";
  const hash = parsed.hash || "";
  const auth = parsed.auth ? parsed.auth + "@" : "";
  const host = parsed.host || "";
  const proto = parsed.protocol || parsed[protocolRelative] ? (parsed.protocol || "") + "//" : "";
  return proto + auth + host + pathname + search + hash;
}

var t$1=Object.defineProperty;var o$4=(e,l)=>t$1(e,"name",{value:l,configurable:true});var n$4=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function f$1(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}o$4(f$1,"getDefaultExportFromCjs");

var Va=Object.defineProperty;var n$3=(i,o)=>Va(i,"name",{value:o,configurable:true});function ts(i){if(!/^data:/i.test(i))throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');i=i.replace(/\r?\n/g,"");const o=i.indexOf(",");if(o===-1||o<=4)throw new TypeError("malformed data: URI");const a=i.substring(5,o).split(";");let l="",u=false;const m=a[0]||"text/plain";let h=m;for(let A=1;A<a.length;A++)a[A]==="base64"?u=true:a[A]&&(h+=`;${a[A]}`,a[A].indexOf("charset=")===0&&(l=a[A].substring(8)));!a[0]&&!l.length&&(h+=";charset=US-ASCII",l="US-ASCII");const S=u?"base64":"ascii",E=unescape(i.substring(o+1)),w=Buffer.from(E,S);return w.type=m,w.typeFull=h,w.charset=l,w}n$3(ts,"dataUriToBuffer");var Eo={},ct={exports:{}};/**
 * @license
 * web-streams-polyfill v3.3.3
 * Copyright 2024 Mattias Buelens, Diwank Singh Tomer and other contributors.
 * This code is released under the MIT license.
 * SPDX-License-Identifier: MIT
 */var rs=ct.exports,vo;function ns(){return vo||(vo=1,function(i,o){(function(a,l){l(o);})(rs,function(a){function l(){}n$3(l,"noop");function u(e){return typeof e=="object"&&e!==null||typeof e=="function"}n$3(u,"typeIsObject");const m=l;function h(e,t){try{Object.defineProperty(e,"name",{value:t,configurable:!0});}catch{}}n$3(h,"setFunctionName");const S=Promise,E=Promise.prototype.then,w=Promise.reject.bind(S);function A(e){return new S(e)}n$3(A,"newPromise");function T(e){return A(t=>t(e))}n$3(T,"promiseResolvedWith");function b(e){return w(e)}n$3(b,"promiseRejectedWith");function q(e,t,r){return E.call(e,t,r)}n$3(q,"PerformPromiseThen");function g(e,t,r){q(q(e,t,r),void 0,m);}n$3(g,"uponPromise");function V(e,t){g(e,t);}n$3(V,"uponFulfillment");function I(e,t){g(e,void 0,t);}n$3(I,"uponRejection");function F(e,t,r){return q(e,t,r)}n$3(F,"transformPromiseWith");function Q(e){q(e,void 0,m);}n$3(Q,"setPromiseIsHandledToTrue");let se=n$3(e=>{if(typeof queueMicrotask=="function")se=queueMicrotask;else {const t=T(void 0);se=n$3(r=>q(t,r),"_queueMicrotask");}return se(e)},"_queueMicrotask");function O(e,t,r){if(typeof e!="function")throw new TypeError("Argument is not a function");return Function.prototype.apply.call(e,t,r)}n$3(O,"reflectCall");function z(e,t,r){try{return T(O(e,t,r))}catch(s){return b(s)}}n$3(z,"promiseCall");const $=16384;class M{static{n$3(this,"SimpleQueue");}constructor(){this._cursor=0,this._size=0,this._front={_elements:[],_next:void 0},this._back=this._front,this._cursor=0,this._size=0;}get length(){return this._size}push(t){const r=this._back;let s=r;r._elements.length===$-1&&(s={_elements:[],_next:void 0}),r._elements.push(t),s!==r&&(this._back=s,r._next=s),++this._size;}shift(){const t=this._front;let r=t;const s=this._cursor;let f=s+1;const c=t._elements,d=c[s];return f===$&&(r=t._next,f=0),--this._size,this._cursor=f,t!==r&&(this._front=r),c[s]=void 0,d}forEach(t){let r=this._cursor,s=this._front,f=s._elements;for(;(r!==f.length||s._next!==void 0)&&!(r===f.length&&(s=s._next,f=s._elements,r=0,f.length===0));)t(f[r]),++r;}peek(){const t=this._front,r=this._cursor;return t._elements[r]}}const pt=Symbol("[[AbortSteps]]"),an=Symbol("[[ErrorSteps]]"),ar=Symbol("[[CancelSteps]]"),sr=Symbol("[[PullSteps]]"),ur=Symbol("[[ReleaseSteps]]");function sn(e,t){e._ownerReadableStream=t,t._reader=e,t._state==="readable"?fr(e):t._state==="closed"?ri(e):un(e,t._storedError);}n$3(sn,"ReadableStreamReaderGenericInitialize");function lr(e,t){const r=e._ownerReadableStream;return X(r,t)}n$3(lr,"ReadableStreamReaderGenericCancel");function ue(e){const t=e._ownerReadableStream;t._state==="readable"?cr(e,new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")):ni(e,new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")),t._readableStreamController[ur](),t._reader=void 0,e._ownerReadableStream=void 0;}n$3(ue,"ReadableStreamReaderGenericRelease");function yt(e){return new TypeError("Cannot "+e+" a stream using a released reader")}n$3(yt,"readerLockException");function fr(e){e._closedPromise=A((t,r)=>{e._closedPromise_resolve=t,e._closedPromise_reject=r;});}n$3(fr,"defaultReaderClosedPromiseInitialize");function un(e,t){fr(e),cr(e,t);}n$3(un,"defaultReaderClosedPromiseInitializeAsRejected");function ri(e){fr(e),ln(e);}n$3(ri,"defaultReaderClosedPromiseInitializeAsResolved");function cr(e,t){e._closedPromise_reject!==void 0&&(Q(e._closedPromise),e._closedPromise_reject(t),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0);}n$3(cr,"defaultReaderClosedPromiseReject");function ni(e,t){un(e,t);}n$3(ni,"defaultReaderClosedPromiseResetToRejected");function ln(e){e._closedPromise_resolve!==void 0&&(e._closedPromise_resolve(void 0),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0);}n$3(ln,"defaultReaderClosedPromiseResolve");const fn=Number.isFinite||function(e){return typeof e=="number"&&isFinite(e)},oi=Math.trunc||function(e){return e<0?Math.ceil(e):Math.floor(e)};function ii(e){return typeof e=="object"||typeof e=="function"}n$3(ii,"isDictionary");function ne(e,t){if(e!==void 0&&!ii(e))throw new TypeError(`${t} is not an object.`)}n$3(ne,"assertDictionary");function G(e,t){if(typeof e!="function")throw new TypeError(`${t} is not a function.`)}n$3(G,"assertFunction");function ai(e){return typeof e=="object"&&e!==null||typeof e=="function"}n$3(ai,"isObject");function cn(e,t){if(!ai(e))throw new TypeError(`${t} is not an object.`)}n$3(cn,"assertObject");function le(e,t,r){if(e===void 0)throw new TypeError(`Parameter ${t} is required in '${r}'.`)}n$3(le,"assertRequiredArgument");function dr(e,t,r){if(e===void 0)throw new TypeError(`${t} is required in '${r}'.`)}n$3(dr,"assertRequiredField");function hr(e){return Number(e)}n$3(hr,"convertUnrestrictedDouble");function dn(e){return e===0?0:e}n$3(dn,"censorNegativeZero");function si(e){return dn(oi(e))}n$3(si,"integerPart");function mr(e,t){const s=Number.MAX_SAFE_INTEGER;let f=Number(e);if(f=dn(f),!fn(f))throw new TypeError(`${t} is not a finite number`);if(f=si(f),f<0||f>s)throw new TypeError(`${t} is outside the accepted range of 0 to ${s}, inclusive`);return !fn(f)||f===0?0:f}n$3(mr,"convertUnsignedLongLongWithEnforceRange");function br(e,t){if(!Te(e))throw new TypeError(`${t} is not a ReadableStream.`)}n$3(br,"assertReadableStream");function ze(e){return new ye(e)}n$3(ze,"AcquireReadableStreamDefaultReader");function hn(e,t){e._reader._readRequests.push(t);}n$3(hn,"ReadableStreamAddReadRequest");function pr(e,t,r){const f=e._reader._readRequests.shift();r?f._closeSteps():f._chunkSteps(t);}n$3(pr,"ReadableStreamFulfillReadRequest");function gt(e){return e._reader._readRequests.length}n$3(gt,"ReadableStreamGetNumReadRequests");function mn(e){const t=e._reader;return !(t===void 0||!ge(t))}n$3(mn,"ReadableStreamHasDefaultReader");class ye{static{n$3(this,"ReadableStreamDefaultReader");}constructor(t){if(le(t,1,"ReadableStreamDefaultReader"),br(t,"First parameter"),Ce(t))throw new TypeError("This stream has already been locked for exclusive reading by another reader");sn(this,t),this._readRequests=new M;}get closed(){return ge(this)?this._closedPromise:b(_t("closed"))}cancel(t=void 0){return ge(this)?this._ownerReadableStream===void 0?b(yt("cancel")):lr(this,t):b(_t("cancel"))}read(){if(!ge(this))return b(_t("read"));if(this._ownerReadableStream===void 0)return b(yt("read from"));let t,r;const s=A((c,d)=>{t=c,r=d;});return et(this,{_chunkSteps:n$3(c=>t({value:c,done:false}),"_chunkSteps"),_closeSteps:n$3(()=>t({value:void 0,done:true}),"_closeSteps"),_errorSteps:n$3(c=>r(c),"_errorSteps")}),s}releaseLock(){if(!ge(this))throw _t("releaseLock");this._ownerReadableStream!==void 0&&ui(this);}}Object.defineProperties(ye.prototype,{cancel:{enumerable:true},read:{enumerable:true},releaseLock:{enumerable:true},closed:{enumerable:true}}),h(ye.prototype.cancel,"cancel"),h(ye.prototype.read,"read"),h(ye.prototype.releaseLock,"releaseLock"),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(ye.prototype,Symbol.toStringTag,{value:"ReadableStreamDefaultReader",configurable:true});function ge(e){return !u(e)||!Object.prototype.hasOwnProperty.call(e,"_readRequests")?false:e instanceof ye}n$3(ge,"IsReadableStreamDefaultReader");function et(e,t){const r=e._ownerReadableStream;r._disturbed=true,r._state==="closed"?t._closeSteps():r._state==="errored"?t._errorSteps(r._storedError):r._readableStreamController[sr](t);}n$3(et,"ReadableStreamDefaultReaderRead");function ui(e){ue(e);const t=new TypeError("Reader was released");bn(e,t);}n$3(ui,"ReadableStreamDefaultReaderRelease");function bn(e,t){const r=e._readRequests;e._readRequests=new M,r.forEach(s=>{s._errorSteps(t);});}n$3(bn,"ReadableStreamDefaultReaderErrorReadRequests");function _t(e){return new TypeError(`ReadableStreamDefaultReader.prototype.${e} can only be used on a ReadableStreamDefaultReader`)}n$3(_t,"defaultReaderBrandCheckException");const li=Object.getPrototypeOf(Object.getPrototypeOf(async function*(){}).prototype);class pn{static{n$3(this,"ReadableStreamAsyncIteratorImpl");}constructor(t,r){this._ongoingPromise=void 0,this._isFinished=false,this._reader=t,this._preventCancel=r;}next(){const t=n$3(()=>this._nextSteps(),"nextSteps");return this._ongoingPromise=this._ongoingPromise?F(this._ongoingPromise,t,t):t(),this._ongoingPromise}return(t){const r=n$3(()=>this._returnSteps(t),"returnSteps");return this._ongoingPromise?F(this._ongoingPromise,r,r):r()}_nextSteps(){if(this._isFinished)return Promise.resolve({value:void 0,done:true});const t=this._reader;let r,s;const f=A((d,p)=>{r=d,s=p;});return et(t,{_chunkSteps:n$3(d=>{this._ongoingPromise=void 0,se(()=>r({value:d,done:false}));},"_chunkSteps"),_closeSteps:n$3(()=>{this._ongoingPromise=void 0,this._isFinished=true,ue(t),r({value:void 0,done:true});},"_closeSteps"),_errorSteps:n$3(d=>{this._ongoingPromise=void 0,this._isFinished=true,ue(t),s(d);},"_errorSteps")}),f}_returnSteps(t){if(this._isFinished)return Promise.resolve({value:t,done:true});this._isFinished=true;const r=this._reader;if(!this._preventCancel){const s=lr(r,t);return ue(r),F(s,()=>({value:t,done:true}))}return ue(r),T({value:t,done:true})}}const yn={next(){return gn(this)?this._asyncIteratorImpl.next():b(_n("next"))},return(e){return gn(this)?this._asyncIteratorImpl.return(e):b(_n("return"))}};Object.setPrototypeOf(yn,li);function fi(e,t){const r=ze(e),s=new pn(r,t),f=Object.create(yn);return f._asyncIteratorImpl=s,f}n$3(fi,"AcquireReadableStreamAsyncIterator");function gn(e){if(!u(e)||!Object.prototype.hasOwnProperty.call(e,"_asyncIteratorImpl"))return  false;try{return e._asyncIteratorImpl instanceof pn}catch{return  false}}n$3(gn,"IsReadableStreamAsyncIterator");function _n(e){return new TypeError(`ReadableStreamAsyncIterator.${e} can only be used on a ReadableSteamAsyncIterator`)}n$3(_n,"streamAsyncIteratorBrandCheckException");const Sn=Number.isNaN||function(e){return e!==e};var yr,gr,_r;function tt(e){return e.slice()}n$3(tt,"CreateArrayFromList");function wn(e,t,r,s,f){new Uint8Array(e).set(new Uint8Array(r,s,f),t);}n$3(wn,"CopyDataBlockBytes");let fe=n$3(e=>(typeof e.transfer=="function"?fe=n$3(t=>t.transfer(),"TransferArrayBuffer"):typeof structuredClone=="function"?fe=n$3(t=>structuredClone(t,{transfer:[t]}),"TransferArrayBuffer"):fe=n$3(t=>t,"TransferArrayBuffer"),fe(e)),"TransferArrayBuffer"),_e=n$3(e=>(typeof e.detached=="boolean"?_e=n$3(t=>t.detached,"IsDetachedBuffer"):_e=n$3(t=>t.byteLength===0,"IsDetachedBuffer"),_e(e)),"IsDetachedBuffer");function Rn(e,t,r){if(e.slice)return e.slice(t,r);const s=r-t,f=new ArrayBuffer(s);return wn(f,0,e,t,s),f}n$3(Rn,"ArrayBufferSlice");function St(e,t){const r=e[t];if(r!=null){if(typeof r!="function")throw new TypeError(`${String(t)} is not a function`);return r}}n$3(St,"GetMethod");function ci(e){const t={[Symbol.iterator]:()=>e.iterator},r=async function*(){return yield*t}(),s=r.next;return {iterator:r,nextMethod:s,done:false}}n$3(ci,"CreateAsyncFromSyncIterator");const Sr=(_r=(yr=Symbol.asyncIterator)!==null&&yr!==void 0?yr:(gr=Symbol.for)===null||gr===void 0?void 0:gr.call(Symbol,"Symbol.asyncIterator"))!==null&&_r!==void 0?_r:"@@asyncIterator";function Tn(e,t="sync",r){if(r===void 0)if(t==="async"){if(r=St(e,Sr),r===void 0){const c=St(e,Symbol.iterator),d=Tn(e,"sync",c);return ci(d)}}else r=St(e,Symbol.iterator);if(r===void 0)throw new TypeError("The object is not iterable");const s=O(r,e,[]);if(!u(s))throw new TypeError("The iterator method must return an object");const f=s.next;return {iterator:s,nextMethod:f,done:false}}n$3(Tn,"GetIterator");function di(e){const t=O(e.nextMethod,e.iterator,[]);if(!u(t))throw new TypeError("The iterator.next() method must return an object");return t}n$3(di,"IteratorNext");function hi(e){return !!e.done}n$3(hi,"IteratorComplete");function mi(e){return e.value}n$3(mi,"IteratorValue");function bi(e){return !(typeof e!="number"||Sn(e)||e<0)}n$3(bi,"IsNonNegativeNumber");function Cn(e){const t=Rn(e.buffer,e.byteOffset,e.byteOffset+e.byteLength);return new Uint8Array(t)}n$3(Cn,"CloneAsUint8Array");function wr(e){const t=e._queue.shift();return e._queueTotalSize-=t.size,e._queueTotalSize<0&&(e._queueTotalSize=0),t.value}n$3(wr,"DequeueValue");function Rr(e,t,r){if(!bi(r)||r===1/0)throw new RangeError("Size must be a finite, non-NaN, non-negative number.");e._queue.push({value:t,size:r}),e._queueTotalSize+=r;}n$3(Rr,"EnqueueValueWithSize");function pi(e){return e._queue.peek().value}n$3(pi,"PeekQueueValue");function Se(e){e._queue=new M,e._queueTotalSize=0;}n$3(Se,"ResetQueue");function Pn(e){return e===DataView}n$3(Pn,"isDataViewConstructor");function yi(e){return Pn(e.constructor)}n$3(yi,"isDataView");function gi(e){return Pn(e)?1:e.BYTES_PER_ELEMENT}n$3(gi,"arrayBufferViewElementSize");class ve{static{n$3(this,"ReadableStreamBYOBRequest");}constructor(){throw new TypeError("Illegal constructor")}get view(){if(!Tr(this))throw Ar("view");return this._view}respond(t){if(!Tr(this))throw Ar("respond");if(le(t,1,"respond"),t=mr(t,"First parameter"),this._associatedReadableByteStreamController===void 0)throw new TypeError("This BYOB request has been invalidated");if(_e(this._view.buffer))throw new TypeError("The BYOB request's buffer has been detached and so cannot be used as a response");Ct(this._associatedReadableByteStreamController,t);}respondWithNewView(t){if(!Tr(this))throw Ar("respondWithNewView");if(le(t,1,"respondWithNewView"),!ArrayBuffer.isView(t))throw new TypeError("You can only respond with array buffer views");if(this._associatedReadableByteStreamController===void 0)throw new TypeError("This BYOB request has been invalidated");if(_e(t.buffer))throw new TypeError("The given view's buffer has been detached and so cannot be used as a response");Pt(this._associatedReadableByteStreamController,t);}}Object.defineProperties(ve.prototype,{respond:{enumerable:true},respondWithNewView:{enumerable:true},view:{enumerable:true}}),h(ve.prototype.respond,"respond"),h(ve.prototype.respondWithNewView,"respondWithNewView"),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(ve.prototype,Symbol.toStringTag,{value:"ReadableStreamBYOBRequest",configurable:true});class ce{static{n$3(this,"ReadableByteStreamController");}constructor(){throw new TypeError("Illegal constructor")}get byobRequest(){if(!Ae(this))throw nt("byobRequest");return vr(this)}get desiredSize(){if(!Ae(this))throw nt("desiredSize");return Fn(this)}close(){if(!Ae(this))throw nt("close");if(this._closeRequested)throw new TypeError("The stream has already been closed; do not close it again!");const t=this._controlledReadableByteStream._state;if(t!=="readable")throw new TypeError(`The stream (in ${t} state) is not in the readable state and cannot be closed`);rt(this);}enqueue(t){if(!Ae(this))throw nt("enqueue");if(le(t,1,"enqueue"),!ArrayBuffer.isView(t))throw new TypeError("chunk must be an array buffer view");if(t.byteLength===0)throw new TypeError("chunk must have non-zero byteLength");if(t.buffer.byteLength===0)throw new TypeError("chunk's buffer must have non-zero byteLength");if(this._closeRequested)throw new TypeError("stream is closed or draining");const r=this._controlledReadableByteStream._state;if(r!=="readable")throw new TypeError(`The stream (in ${r} state) is not in the readable state and cannot be enqueued to`);Tt(this,t);}error(t=void 0){if(!Ae(this))throw nt("error");Z(this,t);}[ar](t){En(this),Se(this);const r=this._cancelAlgorithm(t);return Rt(this),r}[sr](t){const r=this._controlledReadableByteStream;if(this._queueTotalSize>0){In(this,t);return}const s=this._autoAllocateChunkSize;if(s!==void 0){let f;try{f=new ArrayBuffer(s);}catch(d){t._errorSteps(d);return}const c={buffer:f,bufferByteLength:s,byteOffset:0,byteLength:s,bytesFilled:0,minimumFill:1,elementSize:1,viewConstructor:Uint8Array,readerType:"default"};this._pendingPullIntos.push(c);}hn(r,t),Be(this);}[ur](){if(this._pendingPullIntos.length>0){const t=this._pendingPullIntos.peek();t.readerType="none",this._pendingPullIntos=new M,this._pendingPullIntos.push(t);}}}Object.defineProperties(ce.prototype,{close:{enumerable:true},enqueue:{enumerable:true},error:{enumerable:true},byobRequest:{enumerable:true},desiredSize:{enumerable:true}}),h(ce.prototype.close,"close"),h(ce.prototype.enqueue,"enqueue"),h(ce.prototype.error,"error"),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(ce.prototype,Symbol.toStringTag,{value:"ReadableByteStreamController",configurable:true});function Ae(e){return !u(e)||!Object.prototype.hasOwnProperty.call(e,"_controlledReadableByteStream")?false:e instanceof ce}n$3(Ae,"IsReadableByteStreamController");function Tr(e){return !u(e)||!Object.prototype.hasOwnProperty.call(e,"_associatedReadableByteStreamController")?false:e instanceof ve}n$3(Tr,"IsReadableStreamBYOBRequest");function Be(e){if(!Ti(e))return;if(e._pulling){e._pullAgain=true;return}e._pulling=true;const r=e._pullAlgorithm();g(r,()=>(e._pulling=false,e._pullAgain&&(e._pullAgain=false,Be(e)),null),s=>(Z(e,s),null));}n$3(Be,"ReadableByteStreamControllerCallPullIfNeeded");function En(e){Pr(e),e._pendingPullIntos=new M;}n$3(En,"ReadableByteStreamControllerClearPendingPullIntos");function Cr(e,t){let r=false;e._state==="closed"&&(r=true);const s=vn(t);t.readerType==="default"?pr(e,s,r):Bi(e,s,r);}n$3(Cr,"ReadableByteStreamControllerCommitPullIntoDescriptor");function vn(e){const t=e.bytesFilled,r=e.elementSize;return new e.viewConstructor(e.buffer,e.byteOffset,t/r)}n$3(vn,"ReadableByteStreamControllerConvertPullIntoDescriptor");function wt(e,t,r,s){e._queue.push({buffer:t,byteOffset:r,byteLength:s}),e._queueTotalSize+=s;}n$3(wt,"ReadableByteStreamControllerEnqueueChunkToQueue");function An(e,t,r,s){let f;try{f=Rn(t,r,r+s);}catch(c){throw Z(e,c),c}wt(e,f,0,s);}n$3(An,"ReadableByteStreamControllerEnqueueClonedChunkToQueue");function Bn(e,t){t.bytesFilled>0&&An(e,t.buffer,t.byteOffset,t.bytesFilled),je(e);}n$3(Bn,"ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue");function Wn(e,t){const r=Math.min(e._queueTotalSize,t.byteLength-t.bytesFilled),s=t.bytesFilled+r;let f=r,c=false;const d=s%t.elementSize,p=s-d;p>=t.minimumFill&&(f=p-t.bytesFilled,c=true);const R=e._queue;for(;f>0;){const y=R.peek(),C=Math.min(f,y.byteLength),P=t.byteOffset+t.bytesFilled;wn(t.buffer,P,y.buffer,y.byteOffset,C),y.byteLength===C?R.shift():(y.byteOffset+=C,y.byteLength-=C),e._queueTotalSize-=C,kn(e,C,t),f-=C;}return c}n$3(Wn,"ReadableByteStreamControllerFillPullIntoDescriptorFromQueue");function kn(e,t,r){r.bytesFilled+=t;}n$3(kn,"ReadableByteStreamControllerFillHeadPullIntoDescriptor");function qn(e){e._queueTotalSize===0&&e._closeRequested?(Rt(e),lt(e._controlledReadableByteStream)):Be(e);}n$3(qn,"ReadableByteStreamControllerHandleQueueDrain");function Pr(e){e._byobRequest!==null&&(e._byobRequest._associatedReadableByteStreamController=void 0,e._byobRequest._view=null,e._byobRequest=null);}n$3(Pr,"ReadableByteStreamControllerInvalidateBYOBRequest");function Er(e){for(;e._pendingPullIntos.length>0;){if(e._queueTotalSize===0)return;const t=e._pendingPullIntos.peek();Wn(e,t)&&(je(e),Cr(e._controlledReadableByteStream,t));}}n$3(Er,"ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue");function _i(e){const t=e._controlledReadableByteStream._reader;for(;t._readRequests.length>0;){if(e._queueTotalSize===0)return;const r=t._readRequests.shift();In(e,r);}}n$3(_i,"ReadableByteStreamControllerProcessReadRequestsUsingQueue");function Si(e,t,r,s){const f=e._controlledReadableByteStream,c=t.constructor,d=gi(c),{byteOffset:p,byteLength:R}=t,y=r*d;let C;try{C=fe(t.buffer);}catch(B){s._errorSteps(B);return}const P={buffer:C,bufferByteLength:C.byteLength,byteOffset:p,byteLength:R,bytesFilled:0,minimumFill:y,elementSize:d,viewConstructor:c,readerType:"byob"};if(e._pendingPullIntos.length>0){e._pendingPullIntos.push(P),Ln(f,s);return}if(f._state==="closed"){const B=new c(P.buffer,P.byteOffset,0);s._closeSteps(B);return}if(e._queueTotalSize>0){if(Wn(e,P)){const B=vn(P);qn(e),s._chunkSteps(B);return}if(e._closeRequested){const B=new TypeError("Insufficient bytes to fill elements in the given buffer");Z(e,B),s._errorSteps(B);return}}e._pendingPullIntos.push(P),Ln(f,s),Be(e);}n$3(Si,"ReadableByteStreamControllerPullInto");function wi(e,t){t.readerType==="none"&&je(e);const r=e._controlledReadableByteStream;if(Br(r))for(;Dn(r)>0;){const s=je(e);Cr(r,s);}}n$3(wi,"ReadableByteStreamControllerRespondInClosedState");function Ri(e,t,r){if(kn(e,t,r),r.readerType==="none"){Bn(e,r),Er(e);return}if(r.bytesFilled<r.minimumFill)return;je(e);const s=r.bytesFilled%r.elementSize;if(s>0){const f=r.byteOffset+r.bytesFilled;An(e,r.buffer,f-s,s);}r.bytesFilled-=s,Cr(e._controlledReadableByteStream,r),Er(e);}n$3(Ri,"ReadableByteStreamControllerRespondInReadableState");function On(e,t){const r=e._pendingPullIntos.peek();Pr(e),e._controlledReadableByteStream._state==="closed"?wi(e,r):Ri(e,t,r),Be(e);}n$3(On,"ReadableByteStreamControllerRespondInternal");function je(e){return e._pendingPullIntos.shift()}n$3(je,"ReadableByteStreamControllerShiftPendingPullInto");function Ti(e){const t=e._controlledReadableByteStream;return t._state!=="readable"||e._closeRequested||!e._started?false:!!(mn(t)&&gt(t)>0||Br(t)&&Dn(t)>0||Fn(e)>0)}n$3(Ti,"ReadableByteStreamControllerShouldCallPull");function Rt(e){e._pullAlgorithm=void 0,e._cancelAlgorithm=void 0;}n$3(Rt,"ReadableByteStreamControllerClearAlgorithms");function rt(e){const t=e._controlledReadableByteStream;if(!(e._closeRequested||t._state!=="readable")){if(e._queueTotalSize>0){e._closeRequested=true;return}if(e._pendingPullIntos.length>0){const r=e._pendingPullIntos.peek();if(r.bytesFilled%r.elementSize!==0){const s=new TypeError("Insufficient bytes to fill elements in the given buffer");throw Z(e,s),s}}Rt(e),lt(t);}}n$3(rt,"ReadableByteStreamControllerClose");function Tt(e,t){const r=e._controlledReadableByteStream;if(e._closeRequested||r._state!=="readable")return;const{buffer:s,byteOffset:f,byteLength:c}=t;if(_e(s))throw new TypeError("chunk's buffer is detached and so cannot be enqueued");const d=fe(s);if(e._pendingPullIntos.length>0){const p=e._pendingPullIntos.peek();if(_e(p.buffer))throw new TypeError("The BYOB request's buffer has been detached and so cannot be filled with an enqueued chunk");Pr(e),p.buffer=fe(p.buffer),p.readerType==="none"&&Bn(e,p);}if(mn(r))if(_i(e),gt(r)===0)wt(e,d,f,c);else {e._pendingPullIntos.length>0&&je(e);const p=new Uint8Array(d,f,c);pr(r,p,false);}else Br(r)?(wt(e,d,f,c),Er(e)):wt(e,d,f,c);Be(e);}n$3(Tt,"ReadableByteStreamControllerEnqueue");function Z(e,t){const r=e._controlledReadableByteStream;r._state==="readable"&&(En(e),Se(e),Rt(e),lo(r,t));}n$3(Z,"ReadableByteStreamControllerError");function In(e,t){const r=e._queue.shift();e._queueTotalSize-=r.byteLength,qn(e);const s=new Uint8Array(r.buffer,r.byteOffset,r.byteLength);t._chunkSteps(s);}n$3(In,"ReadableByteStreamControllerFillReadRequestFromQueue");function vr(e){if(e._byobRequest===null&&e._pendingPullIntos.length>0){const t=e._pendingPullIntos.peek(),r=new Uint8Array(t.buffer,t.byteOffset+t.bytesFilled,t.byteLength-t.bytesFilled),s=Object.create(ve.prototype);Pi(s,e,r),e._byobRequest=s;}return e._byobRequest}n$3(vr,"ReadableByteStreamControllerGetBYOBRequest");function Fn(e){const t=e._controlledReadableByteStream._state;return t==="errored"?null:t==="closed"?0:e._strategyHWM-e._queueTotalSize}n$3(Fn,"ReadableByteStreamControllerGetDesiredSize");function Ct(e,t){const r=e._pendingPullIntos.peek();if(e._controlledReadableByteStream._state==="closed"){if(t!==0)throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream")}else {if(t===0)throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");if(r.bytesFilled+t>r.byteLength)throw new RangeError("bytesWritten out of range")}r.buffer=fe(r.buffer),On(e,t);}n$3(Ct,"ReadableByteStreamControllerRespond");function Pt(e,t){const r=e._pendingPullIntos.peek();if(e._controlledReadableByteStream._state==="closed"){if(t.byteLength!==0)throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream")}else if(t.byteLength===0)throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");if(r.byteOffset+r.bytesFilled!==t.byteOffset)throw new RangeError("The region specified by view does not match byobRequest");if(r.bufferByteLength!==t.buffer.byteLength)throw new RangeError("The buffer of view has different capacity than byobRequest");if(r.bytesFilled+t.byteLength>r.byteLength)throw new RangeError("The region specified by view is larger than byobRequest");const f=t.byteLength;r.buffer=fe(t.buffer),On(e,f);}n$3(Pt,"ReadableByteStreamControllerRespondWithNewView");function zn(e,t,r,s,f,c,d){t._controlledReadableByteStream=e,t._pullAgain=false,t._pulling=false,t._byobRequest=null,t._queue=t._queueTotalSize=void 0,Se(t),t._closeRequested=false,t._started=false,t._strategyHWM=c,t._pullAlgorithm=s,t._cancelAlgorithm=f,t._autoAllocateChunkSize=d,t._pendingPullIntos=new M,e._readableStreamController=t;const p=r();g(T(p),()=>(t._started=true,Be(t),null),R=>(Z(t,R),null));}n$3(zn,"SetUpReadableByteStreamController");function Ci(e,t,r){const s=Object.create(ce.prototype);let f,c,d;t.start!==void 0?f=n$3(()=>t.start(s),"startAlgorithm"):f=n$3(()=>{},"startAlgorithm"),t.pull!==void 0?c=n$3(()=>t.pull(s),"pullAlgorithm"):c=n$3(()=>T(void 0),"pullAlgorithm"),t.cancel!==void 0?d=n$3(R=>t.cancel(R),"cancelAlgorithm"):d=n$3(()=>T(void 0),"cancelAlgorithm");const p=t.autoAllocateChunkSize;if(p===0)throw new TypeError("autoAllocateChunkSize must be greater than 0");zn(e,s,f,c,d,r,p);}n$3(Ci,"SetUpReadableByteStreamControllerFromUnderlyingSource");function Pi(e,t,r){e._associatedReadableByteStreamController=t,e._view=r;}n$3(Pi,"SetUpReadableStreamBYOBRequest");function Ar(e){return new TypeError(`ReadableStreamBYOBRequest.prototype.${e} can only be used on a ReadableStreamBYOBRequest`)}n$3(Ar,"byobRequestBrandCheckException");function nt(e){return new TypeError(`ReadableByteStreamController.prototype.${e} can only be used on a ReadableByteStreamController`)}n$3(nt,"byteStreamControllerBrandCheckException");function Ei(e,t){ne(e,t);const r=e?.mode;return {mode:r===void 0?void 0:vi(r,`${t} has member 'mode' that`)}}n$3(Ei,"convertReaderOptions");function vi(e,t){if(e=`${e}`,e!=="byob")throw new TypeError(`${t} '${e}' is not a valid enumeration value for ReadableStreamReaderMode`);return e}n$3(vi,"convertReadableStreamReaderMode");function Ai(e,t){var r;ne(e,t);const s=(r=e?.min)!==null&&r!==void 0?r:1;return {min:mr(s,`${t} has member 'min' that`)}}n$3(Ai,"convertByobReadOptions");function jn(e){return new we(e)}n$3(jn,"AcquireReadableStreamBYOBReader");function Ln(e,t){e._reader._readIntoRequests.push(t);}n$3(Ln,"ReadableStreamAddReadIntoRequest");function Bi(e,t,r){const f=e._reader._readIntoRequests.shift();r?f._closeSteps(t):f._chunkSteps(t);}n$3(Bi,"ReadableStreamFulfillReadIntoRequest");function Dn(e){return e._reader._readIntoRequests.length}n$3(Dn,"ReadableStreamGetNumReadIntoRequests");function Br(e){const t=e._reader;return !(t===void 0||!We(t))}n$3(Br,"ReadableStreamHasBYOBReader");class we{static{n$3(this,"ReadableStreamBYOBReader");}constructor(t){if(le(t,1,"ReadableStreamBYOBReader"),br(t,"First parameter"),Ce(t))throw new TypeError("This stream has already been locked for exclusive reading by another reader");if(!Ae(t._readableStreamController))throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");sn(this,t),this._readIntoRequests=new M;}get closed(){return We(this)?this._closedPromise:b(Et("closed"))}cancel(t=void 0){return We(this)?this._ownerReadableStream===void 0?b(yt("cancel")):lr(this,t):b(Et("cancel"))}read(t,r={}){if(!We(this))return b(Et("read"));if(!ArrayBuffer.isView(t))return b(new TypeError("view must be an array buffer view"));if(t.byteLength===0)return b(new TypeError("view must have non-zero byteLength"));if(t.buffer.byteLength===0)return b(new TypeError("view's buffer must have non-zero byteLength"));if(_e(t.buffer))return b(new TypeError("view's buffer has been detached"));let s;try{s=Ai(r,"options");}catch(y){return b(y)}const f=s.min;if(f===0)return b(new TypeError("options.min must be greater than 0"));if(yi(t)){if(f>t.byteLength)return b(new RangeError("options.min must be less than or equal to view's byteLength"))}else if(f>t.length)return b(new RangeError("options.min must be less than or equal to view's length"));if(this._ownerReadableStream===void 0)return b(yt("read from"));let c,d;const p=A((y,C)=>{c=y,d=C;});return $n(this,t,f,{_chunkSteps:n$3(y=>c({value:y,done:false}),"_chunkSteps"),_closeSteps:n$3(y=>c({value:y,done:true}),"_closeSteps"),_errorSteps:n$3(y=>d(y),"_errorSteps")}),p}releaseLock(){if(!We(this))throw Et("releaseLock");this._ownerReadableStream!==void 0&&Wi(this);}}Object.defineProperties(we.prototype,{cancel:{enumerable:true},read:{enumerable:true},releaseLock:{enumerable:true},closed:{enumerable:true}}),h(we.prototype.cancel,"cancel"),h(we.prototype.read,"read"),h(we.prototype.releaseLock,"releaseLock"),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(we.prototype,Symbol.toStringTag,{value:"ReadableStreamBYOBReader",configurable:true});function We(e){return !u(e)||!Object.prototype.hasOwnProperty.call(e,"_readIntoRequests")?false:e instanceof we}n$3(We,"IsReadableStreamBYOBReader");function $n(e,t,r,s){const f=e._ownerReadableStream;f._disturbed=true,f._state==="errored"?s._errorSteps(f._storedError):Si(f._readableStreamController,t,r,s);}n$3($n,"ReadableStreamBYOBReaderRead");function Wi(e){ue(e);const t=new TypeError("Reader was released");Mn(e,t);}n$3(Wi,"ReadableStreamBYOBReaderRelease");function Mn(e,t){const r=e._readIntoRequests;e._readIntoRequests=new M,r.forEach(s=>{s._errorSteps(t);});}n$3(Mn,"ReadableStreamBYOBReaderErrorReadIntoRequests");function Et(e){return new TypeError(`ReadableStreamBYOBReader.prototype.${e} can only be used on a ReadableStreamBYOBReader`)}n$3(Et,"byobReaderBrandCheckException");function ot(e,t){const{highWaterMark:r}=e;if(r===void 0)return t;if(Sn(r)||r<0)throw new RangeError("Invalid highWaterMark");return r}n$3(ot,"ExtractHighWaterMark");function vt(e){const{size:t}=e;return t||(()=>1)}n$3(vt,"ExtractSizeAlgorithm");function At(e,t){ne(e,t);const r=e?.highWaterMark,s=e?.size;return {highWaterMark:r===void 0?void 0:hr(r),size:s===void 0?void 0:ki(s,`${t} has member 'size' that`)}}n$3(At,"convertQueuingStrategy");function ki(e,t){return G(e,t),r=>hr(e(r))}n$3(ki,"convertQueuingStrategySize");function qi(e,t){ne(e,t);const r=e?.abort,s=e?.close,f=e?.start,c=e?.type,d=e?.write;return {abort:r===void 0?void 0:Oi(r,e,`${t} has member 'abort' that`),close:s===void 0?void 0:Ii(s,e,`${t} has member 'close' that`),start:f===void 0?void 0:Fi(f,e,`${t} has member 'start' that`),write:d===void 0?void 0:zi(d,e,`${t} has member 'write' that`),type:c}}n$3(qi,"convertUnderlyingSink");function Oi(e,t,r){return G(e,r),s=>z(e,t,[s])}n$3(Oi,"convertUnderlyingSinkAbortCallback");function Ii(e,t,r){return G(e,r),()=>z(e,t,[])}n$3(Ii,"convertUnderlyingSinkCloseCallback");function Fi(e,t,r){return G(e,r),s=>O(e,t,[s])}n$3(Fi,"convertUnderlyingSinkStartCallback");function zi(e,t,r){return G(e,r),(s,f)=>z(e,t,[s,f])}n$3(zi,"convertUnderlyingSinkWriteCallback");function Un(e,t){if(!Le(e))throw new TypeError(`${t} is not a WritableStream.`)}n$3(Un,"assertWritableStream");function ji(e){if(typeof e!="object"||e===null)return  false;try{return typeof e.aborted=="boolean"}catch{return  false}}n$3(ji,"isAbortSignal");const Li=typeof AbortController=="function";function Di(){if(Li)return new AbortController}n$3(Di,"createAbortController");class Re{static{n$3(this,"WritableStream");}constructor(t={},r={}){t===void 0?t=null:cn(t,"First parameter");const s=At(r,"Second parameter"),f=qi(t,"First parameter");if(Nn(this),f.type!==void 0)throw new RangeError("Invalid type is specified");const d=vt(s),p=ot(s,1);Xi(this,f,p,d);}get locked(){if(!Le(this))throw Ot("locked");return De(this)}abort(t=void 0){return Le(this)?De(this)?b(new TypeError("Cannot abort a stream that already has a writer")):Bt(this,t):b(Ot("abort"))}close(){return Le(this)?De(this)?b(new TypeError("Cannot close a stream that already has a writer")):oe(this)?b(new TypeError("Cannot close an already-closing stream")):Hn(this):b(Ot("close"))}getWriter(){if(!Le(this))throw Ot("getWriter");return xn(this)}}Object.defineProperties(Re.prototype,{abort:{enumerable:true},close:{enumerable:true},getWriter:{enumerable:true},locked:{enumerable:true}}),h(Re.prototype.abort,"abort"),h(Re.prototype.close,"close"),h(Re.prototype.getWriter,"getWriter"),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(Re.prototype,Symbol.toStringTag,{value:"WritableStream",configurable:true});function xn(e){return new de(e)}n$3(xn,"AcquireWritableStreamDefaultWriter");function $i(e,t,r,s,f=1,c=()=>1){const d=Object.create(Re.prototype);Nn(d);const p=Object.create($e.prototype);return Kn(d,p,e,t,r,s,f,c),d}n$3($i,"CreateWritableStream");function Nn(e){e._state="writable",e._storedError=void 0,e._writer=void 0,e._writableStreamController=void 0,e._writeRequests=new M,e._inFlightWriteRequest=void 0,e._closeRequest=void 0,e._inFlightCloseRequest=void 0,e._pendingAbortRequest=void 0,e._backpressure=false;}n$3(Nn,"InitializeWritableStream");function Le(e){return !u(e)||!Object.prototype.hasOwnProperty.call(e,"_writableStreamController")?false:e instanceof Re}n$3(Le,"IsWritableStream");function De(e){return e._writer!==void 0}n$3(De,"IsWritableStreamLocked");function Bt(e,t){var r;if(e._state==="closed"||e._state==="errored")return T(void 0);e._writableStreamController._abortReason=t,(r=e._writableStreamController._abortController)===null||r===void 0||r.abort(t);const s=e._state;if(s==="closed"||s==="errored")return T(void 0);if(e._pendingAbortRequest!==void 0)return e._pendingAbortRequest._promise;let f=false;s==="erroring"&&(f=true,t=void 0);const c=A((d,p)=>{e._pendingAbortRequest={_promise:void 0,_resolve:d,_reject:p,_reason:t,_wasAlreadyErroring:f};});return e._pendingAbortRequest._promise=c,f||kr(e,t),c}n$3(Bt,"WritableStreamAbort");function Hn(e){const t=e._state;if(t==="closed"||t==="errored")return b(new TypeError(`The stream (in ${t} state) is not in the writable state and cannot be closed`));const r=A((f,c)=>{const d={_resolve:f,_reject:c};e._closeRequest=d;}),s=e._writer;return s!==void 0&&e._backpressure&&t==="writable"&&Dr(s),ea(e._writableStreamController),r}n$3(Hn,"WritableStreamClose");function Mi(e){return A((r,s)=>{const f={_resolve:r,_reject:s};e._writeRequests.push(f);})}n$3(Mi,"WritableStreamAddWriteRequest");function Wr(e,t){if(e._state==="writable"){kr(e,t);return}qr(e);}n$3(Wr,"WritableStreamDealWithRejection");function kr(e,t){const r=e._writableStreamController;e._state="erroring",e._storedError=t;const s=e._writer;s!==void 0&&Qn(s,t),!Vi(e)&&r._started&&qr(e);}n$3(kr,"WritableStreamStartErroring");function qr(e){e._state="errored",e._writableStreamController[an]();const t=e._storedError;if(e._writeRequests.forEach(f=>{f._reject(t);}),e._writeRequests=new M,e._pendingAbortRequest===void 0){Wt(e);return}const r=e._pendingAbortRequest;if(e._pendingAbortRequest=void 0,r._wasAlreadyErroring){r._reject(t),Wt(e);return}const s=e._writableStreamController[pt](r._reason);g(s,()=>(r._resolve(),Wt(e),null),f=>(r._reject(f),Wt(e),null));}n$3(qr,"WritableStreamFinishErroring");function Ui(e){e._inFlightWriteRequest._resolve(void 0),e._inFlightWriteRequest=void 0;}n$3(Ui,"WritableStreamFinishInFlightWrite");function xi(e,t){e._inFlightWriteRequest._reject(t),e._inFlightWriteRequest=void 0,Wr(e,t);}n$3(xi,"WritableStreamFinishInFlightWriteWithError");function Ni(e){e._inFlightCloseRequest._resolve(void 0),e._inFlightCloseRequest=void 0,e._state==="erroring"&&(e._storedError=void 0,e._pendingAbortRequest!==void 0&&(e._pendingAbortRequest._resolve(),e._pendingAbortRequest=void 0)),e._state="closed";const r=e._writer;r!==void 0&&to(r);}n$3(Ni,"WritableStreamFinishInFlightClose");function Hi(e,t){e._inFlightCloseRequest._reject(t),e._inFlightCloseRequest=void 0,e._pendingAbortRequest!==void 0&&(e._pendingAbortRequest._reject(t),e._pendingAbortRequest=void 0),Wr(e,t);}n$3(Hi,"WritableStreamFinishInFlightCloseWithError");function oe(e){return !(e._closeRequest===void 0&&e._inFlightCloseRequest===void 0)}n$3(oe,"WritableStreamCloseQueuedOrInFlight");function Vi(e){return !(e._inFlightWriteRequest===void 0&&e._inFlightCloseRequest===void 0)}n$3(Vi,"WritableStreamHasOperationMarkedInFlight");function Qi(e){e._inFlightCloseRequest=e._closeRequest,e._closeRequest=void 0;}n$3(Qi,"WritableStreamMarkCloseRequestInFlight");function Yi(e){e._inFlightWriteRequest=e._writeRequests.shift();}n$3(Yi,"WritableStreamMarkFirstWriteRequestInFlight");function Wt(e){e._closeRequest!==void 0&&(e._closeRequest._reject(e._storedError),e._closeRequest=void 0);const t=e._writer;t!==void 0&&jr(t,e._storedError);}n$3(Wt,"WritableStreamRejectCloseAndClosedPromiseIfNeeded");function Or(e,t){const r=e._writer;r!==void 0&&t!==e._backpressure&&(t?sa(r):Dr(r)),e._backpressure=t;}n$3(Or,"WritableStreamUpdateBackpressure");class de{static{n$3(this,"WritableStreamDefaultWriter");}constructor(t){if(le(t,1,"WritableStreamDefaultWriter"),Un(t,"First parameter"),De(t))throw new TypeError("This stream has already been locked for exclusive writing by another writer");this._ownerWritableStream=t,t._writer=this;const r=t._state;if(r==="writable")!oe(t)&&t._backpressure?Ft(this):ro(this),It(this);else if(r==="erroring")Lr(this,t._storedError),It(this);else if(r==="closed")ro(this),ia(this);else {const s=t._storedError;Lr(this,s),eo(this,s);}}get closed(){return ke(this)?this._closedPromise:b(qe("closed"))}get desiredSize(){if(!ke(this))throw qe("desiredSize");if(this._ownerWritableStream===void 0)throw at("desiredSize");return Ji(this)}get ready(){return ke(this)?this._readyPromise:b(qe("ready"))}abort(t=void 0){return ke(this)?this._ownerWritableStream===void 0?b(at("abort")):Gi(this,t):b(qe("abort"))}close(){if(!ke(this))return b(qe("close"));const t=this._ownerWritableStream;return t===void 0?b(at("close")):oe(t)?b(new TypeError("Cannot close an already-closing stream")):Vn(this)}releaseLock(){if(!ke(this))throw qe("releaseLock");this._ownerWritableStream!==void 0&&Yn(this);}write(t=void 0){return ke(this)?this._ownerWritableStream===void 0?b(at("write to")):Gn(this,t):b(qe("write"))}}Object.defineProperties(de.prototype,{abort:{enumerable:true},close:{enumerable:true},releaseLock:{enumerable:true},write:{enumerable:true},closed:{enumerable:true},desiredSize:{enumerable:true},ready:{enumerable:true}}),h(de.prototype.abort,"abort"),h(de.prototype.close,"close"),h(de.prototype.releaseLock,"releaseLock"),h(de.prototype.write,"write"),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(de.prototype,Symbol.toStringTag,{value:"WritableStreamDefaultWriter",configurable:true});function ke(e){return !u(e)||!Object.prototype.hasOwnProperty.call(e,"_ownerWritableStream")?false:e instanceof de}n$3(ke,"IsWritableStreamDefaultWriter");function Gi(e,t){const r=e._ownerWritableStream;return Bt(r,t)}n$3(Gi,"WritableStreamDefaultWriterAbort");function Vn(e){const t=e._ownerWritableStream;return Hn(t)}n$3(Vn,"WritableStreamDefaultWriterClose");function Zi(e){const t=e._ownerWritableStream,r=t._state;return oe(t)||r==="closed"?T(void 0):r==="errored"?b(t._storedError):Vn(e)}n$3(Zi,"WritableStreamDefaultWriterCloseWithErrorPropagation");function Ki(e,t){e._closedPromiseState==="pending"?jr(e,t):aa(e,t);}n$3(Ki,"WritableStreamDefaultWriterEnsureClosedPromiseRejected");function Qn(e,t){e._readyPromiseState==="pending"?no(e,t):ua(e,t);}n$3(Qn,"WritableStreamDefaultWriterEnsureReadyPromiseRejected");function Ji(e){const t=e._ownerWritableStream,r=t._state;return r==="errored"||r==="erroring"?null:r==="closed"?0:Jn(t._writableStreamController)}n$3(Ji,"WritableStreamDefaultWriterGetDesiredSize");function Yn(e){const t=e._ownerWritableStream,r=new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");Qn(e,r),Ki(e,r),t._writer=void 0,e._ownerWritableStream=void 0;}n$3(Yn,"WritableStreamDefaultWriterRelease");function Gn(e,t){const r=e._ownerWritableStream,s=r._writableStreamController,f=ta(s,t);if(r!==e._ownerWritableStream)return b(at("write to"));const c=r._state;if(c==="errored")return b(r._storedError);if(oe(r)||c==="closed")return b(new TypeError("The stream is closing or closed and cannot be written to"));if(c==="erroring")return b(r._storedError);const d=Mi(r);return ra(s,t,f),d}n$3(Gn,"WritableStreamDefaultWriterWrite");const Zn={};class $e{static{n$3(this,"WritableStreamDefaultController");}constructor(){throw new TypeError("Illegal constructor")}get abortReason(){if(!Ir(this))throw zr("abortReason");return this._abortReason}get signal(){if(!Ir(this))throw zr("signal");if(this._abortController===void 0)throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");return this._abortController.signal}error(t=void 0){if(!Ir(this))throw zr("error");this._controlledWritableStream._state==="writable"&&Xn(this,t);}[pt](t){const r=this._abortAlgorithm(t);return kt(this),r}[an](){Se(this);}}Object.defineProperties($e.prototype,{abortReason:{enumerable:true},signal:{enumerable:true},error:{enumerable:true}}),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty($e.prototype,Symbol.toStringTag,{value:"WritableStreamDefaultController",configurable:true});function Ir(e){return !u(e)||!Object.prototype.hasOwnProperty.call(e,"_controlledWritableStream")?false:e instanceof $e}n$3(Ir,"IsWritableStreamDefaultController");function Kn(e,t,r,s,f,c,d,p){t._controlledWritableStream=e,e._writableStreamController=t,t._queue=void 0,t._queueTotalSize=void 0,Se(t),t._abortReason=void 0,t._abortController=Di(),t._started=false,t._strategySizeAlgorithm=p,t._strategyHWM=d,t._writeAlgorithm=s,t._closeAlgorithm=f,t._abortAlgorithm=c;const R=Fr(t);Or(e,R);const y=r(),C=T(y);g(C,()=>(t._started=true,qt(t),null),P=>(t._started=true,Wr(e,P),null));}n$3(Kn,"SetUpWritableStreamDefaultController");function Xi(e,t,r,s){const f=Object.create($e.prototype);let c,d,p,R;t.start!==void 0?c=n$3(()=>t.start(f),"startAlgorithm"):c=n$3(()=>{},"startAlgorithm"),t.write!==void 0?d=n$3(y=>t.write(y,f),"writeAlgorithm"):d=n$3(()=>T(void 0),"writeAlgorithm"),t.close!==void 0?p=n$3(()=>t.close(),"closeAlgorithm"):p=n$3(()=>T(void 0),"closeAlgorithm"),t.abort!==void 0?R=n$3(y=>t.abort(y),"abortAlgorithm"):R=n$3(()=>T(void 0),"abortAlgorithm"),Kn(e,f,c,d,p,R,r,s);}n$3(Xi,"SetUpWritableStreamDefaultControllerFromUnderlyingSink");function kt(e){e._writeAlgorithm=void 0,e._closeAlgorithm=void 0,e._abortAlgorithm=void 0,e._strategySizeAlgorithm=void 0;}n$3(kt,"WritableStreamDefaultControllerClearAlgorithms");function ea(e){Rr(e,Zn,0),qt(e);}n$3(ea,"WritableStreamDefaultControllerClose");function ta(e,t){try{return e._strategySizeAlgorithm(t)}catch(r){return it(e,r),1}}n$3(ta,"WritableStreamDefaultControllerGetChunkSize");function Jn(e){return e._strategyHWM-e._queueTotalSize}n$3(Jn,"WritableStreamDefaultControllerGetDesiredSize");function ra(e,t,r){try{Rr(e,t,r);}catch(f){it(e,f);return}const s=e._controlledWritableStream;if(!oe(s)&&s._state==="writable"){const f=Fr(e);Or(s,f);}qt(e);}n$3(ra,"WritableStreamDefaultControllerWrite");function qt(e){const t=e._controlledWritableStream;if(!e._started||t._inFlightWriteRequest!==void 0)return;if(t._state==="erroring"){qr(t);return}if(e._queue.length===0)return;const s=pi(e);s===Zn?na(e):oa(e,s);}n$3(qt,"WritableStreamDefaultControllerAdvanceQueueIfNeeded");function it(e,t){e._controlledWritableStream._state==="writable"&&Xn(e,t);}n$3(it,"WritableStreamDefaultControllerErrorIfNeeded");function na(e){const t=e._controlledWritableStream;Qi(t),wr(e);const r=e._closeAlgorithm();kt(e),g(r,()=>(Ni(t),null),s=>(Hi(t,s),null));}n$3(na,"WritableStreamDefaultControllerProcessClose");function oa(e,t){const r=e._controlledWritableStream;Yi(r);const s=e._writeAlgorithm(t);g(s,()=>{Ui(r);const f=r._state;if(wr(e),!oe(r)&&f==="writable"){const c=Fr(e);Or(r,c);}return qt(e),null},f=>(r._state==="writable"&&kt(e),xi(r,f),null));}n$3(oa,"WritableStreamDefaultControllerProcessWrite");function Fr(e){return Jn(e)<=0}n$3(Fr,"WritableStreamDefaultControllerGetBackpressure");function Xn(e,t){const r=e._controlledWritableStream;kt(e),kr(r,t);}n$3(Xn,"WritableStreamDefaultControllerError");function Ot(e){return new TypeError(`WritableStream.prototype.${e} can only be used on a WritableStream`)}n$3(Ot,"streamBrandCheckException$2");function zr(e){return new TypeError(`WritableStreamDefaultController.prototype.${e} can only be used on a WritableStreamDefaultController`)}n$3(zr,"defaultControllerBrandCheckException$2");function qe(e){return new TypeError(`WritableStreamDefaultWriter.prototype.${e} can only be used on a WritableStreamDefaultWriter`)}n$3(qe,"defaultWriterBrandCheckException");function at(e){return new TypeError("Cannot "+e+" a stream using a released writer")}n$3(at,"defaultWriterLockException");function It(e){e._closedPromise=A((t,r)=>{e._closedPromise_resolve=t,e._closedPromise_reject=r,e._closedPromiseState="pending";});}n$3(It,"defaultWriterClosedPromiseInitialize");function eo(e,t){It(e),jr(e,t);}n$3(eo,"defaultWriterClosedPromiseInitializeAsRejected");function ia(e){It(e),to(e);}n$3(ia,"defaultWriterClosedPromiseInitializeAsResolved");function jr(e,t){e._closedPromise_reject!==void 0&&(Q(e._closedPromise),e._closedPromise_reject(t),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0,e._closedPromiseState="rejected");}n$3(jr,"defaultWriterClosedPromiseReject");function aa(e,t){eo(e,t);}n$3(aa,"defaultWriterClosedPromiseResetToRejected");function to(e){e._closedPromise_resolve!==void 0&&(e._closedPromise_resolve(void 0),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0,e._closedPromiseState="resolved");}n$3(to,"defaultWriterClosedPromiseResolve");function Ft(e){e._readyPromise=A((t,r)=>{e._readyPromise_resolve=t,e._readyPromise_reject=r;}),e._readyPromiseState="pending";}n$3(Ft,"defaultWriterReadyPromiseInitialize");function Lr(e,t){Ft(e),no(e,t);}n$3(Lr,"defaultWriterReadyPromiseInitializeAsRejected");function ro(e){Ft(e),Dr(e);}n$3(ro,"defaultWriterReadyPromiseInitializeAsResolved");function no(e,t){e._readyPromise_reject!==void 0&&(Q(e._readyPromise),e._readyPromise_reject(t),e._readyPromise_resolve=void 0,e._readyPromise_reject=void 0,e._readyPromiseState="rejected");}n$3(no,"defaultWriterReadyPromiseReject");function sa(e){Ft(e);}n$3(sa,"defaultWriterReadyPromiseReset");function ua(e,t){Lr(e,t);}n$3(ua,"defaultWriterReadyPromiseResetToRejected");function Dr(e){e._readyPromise_resolve!==void 0&&(e._readyPromise_resolve(void 0),e._readyPromise_resolve=void 0,e._readyPromise_reject=void 0,e._readyPromiseState="fulfilled");}n$3(Dr,"defaultWriterReadyPromiseResolve");function la(){if(typeof globalThis<"u")return globalThis;if(typeof self<"u")return self;if(typeof n$4<"u")return n$4}n$3(la,"getGlobals");const $r=la();function fa(e){if(!(typeof e=="function"||typeof e=="object")||e.name!=="DOMException")return  false;try{return new e,!0}catch{return  false}}n$3(fa,"isDOMExceptionConstructor");function ca(){const e=$r?.DOMException;return fa(e)?e:void 0}n$3(ca,"getFromGlobal");function da(){const e=n$3(function(r,s){this.message=r||"",this.name=s||"Error",Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor);},"DOMException");return h(e,"DOMException"),e.prototype=Object.create(Error.prototype),Object.defineProperty(e.prototype,"constructor",{value:e,writable:true,configurable:true}),e}n$3(da,"createPolyfill");const ha=ca()||da();function oo(e,t,r,s,f,c){const d=ze(e),p=xn(t);e._disturbed=true;let R=false,y=T(void 0);return A((C,P)=>{let B;if(c!==void 0){if(B=n$3(()=>{const _=c.reason!==void 0?c.reason:new ha("Aborted","AbortError"),v=[];s||v.push(()=>t._state==="writable"?Bt(t,_):T(void 0)),f||v.push(()=>e._state==="readable"?X(e,_):T(void 0)),x(()=>Promise.all(v.map(W=>W())),true,_);},"abortAlgorithm"),c.aborted){B();return}c.addEventListener("abort",B);}function ee(){return A((_,v)=>{function W(Y){Y?_():q(Ne(),W,v);}n$3(W,"next"),W(false);})}n$3(ee,"pipeLoop");function Ne(){return R?T(true):q(p._readyPromise,()=>A((_,v)=>{et(d,{_chunkSteps:n$3(W=>{y=q(Gn(p,W),void 0,l),_(false);},"_chunkSteps"),_closeSteps:n$3(()=>_(true),"_closeSteps"),_errorSteps:v});}))}if(n$3(Ne,"pipeStep"),me(e,d._closedPromise,_=>(s?K(true,_):x(()=>Bt(t,_),true,_),null)),me(t,p._closedPromise,_=>(f?K(true,_):x(()=>X(e,_),true,_),null)),U(e,d._closedPromise,()=>(r?K():x(()=>Zi(p)),null)),oe(t)||t._state==="closed"){const _=new TypeError("the destination writable stream closed before all data could be piped to it");f?K(true,_):x(()=>X(e,_),true,_);}Q(ee());function Ee(){const _=y;return q(y,()=>_!==y?Ee():void 0)}n$3(Ee,"waitForWritesToFinish");function me(_,v,W){_._state==="errored"?W(_._storedError):I(v,W);}n$3(me,"isOrBecomesErrored");function U(_,v,W){_._state==="closed"?W():V(v,W);}n$3(U,"isOrBecomesClosed");function x(_,v,W){if(R)return;R=true,t._state==="writable"&&!oe(t)?V(Ee(),Y):Y();function Y(){return g(_(),()=>be(v,W),He=>be(true,He)),null}n$3(Y,"doTheRest");}n$3(x,"shutdownWithAction");function K(_,v){R||(R=true,t._state==="writable"&&!oe(t)?V(Ee(),()=>be(_,v)):be(_,v));}n$3(K,"shutdown");function be(_,v){return Yn(p),ue(d),c!==void 0&&c.removeEventListener("abort",B),_?P(v):C(void 0),null}n$3(be,"finalize");})}n$3(oo,"ReadableStreamPipeTo");class he{static{n$3(this,"ReadableStreamDefaultController");}constructor(){throw new TypeError("Illegal constructor")}get desiredSize(){if(!zt(this))throw Lt("desiredSize");return Mr(this)}close(){if(!zt(this))throw Lt("close");if(!Ue(this))throw new TypeError("The stream is not in a state that permits close");Oe(this);}enqueue(t=void 0){if(!zt(this))throw Lt("enqueue");if(!Ue(this))throw new TypeError("The stream is not in a state that permits enqueue");return Me(this,t)}error(t=void 0){if(!zt(this))throw Lt("error");J(this,t);}[ar](t){Se(this);const r=this._cancelAlgorithm(t);return jt(this),r}[sr](t){const r=this._controlledReadableStream;if(this._queue.length>0){const s=wr(this);this._closeRequested&&this._queue.length===0?(jt(this),lt(r)):st(this),t._chunkSteps(s);}else hn(r,t),st(this);}[ur](){}}Object.defineProperties(he.prototype,{close:{enumerable:true},enqueue:{enumerable:true},error:{enumerable:true},desiredSize:{enumerable:true}}),h(he.prototype.close,"close"),h(he.prototype.enqueue,"enqueue"),h(he.prototype.error,"error"),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(he.prototype,Symbol.toStringTag,{value:"ReadableStreamDefaultController",configurable:true});function zt(e){return !u(e)||!Object.prototype.hasOwnProperty.call(e,"_controlledReadableStream")?false:e instanceof he}n$3(zt,"IsReadableStreamDefaultController");function st(e){if(!io(e))return;if(e._pulling){e._pullAgain=true;return}e._pulling=true;const r=e._pullAlgorithm();g(r,()=>(e._pulling=false,e._pullAgain&&(e._pullAgain=false,st(e)),null),s=>(J(e,s),null));}n$3(st,"ReadableStreamDefaultControllerCallPullIfNeeded");function io(e){const t=e._controlledReadableStream;return !Ue(e)||!e._started?false:!!(Ce(t)&&gt(t)>0||Mr(e)>0)}n$3(io,"ReadableStreamDefaultControllerShouldCallPull");function jt(e){e._pullAlgorithm=void 0,e._cancelAlgorithm=void 0,e._strategySizeAlgorithm=void 0;}n$3(jt,"ReadableStreamDefaultControllerClearAlgorithms");function Oe(e){if(!Ue(e))return;const t=e._controlledReadableStream;e._closeRequested=true,e._queue.length===0&&(jt(e),lt(t));}n$3(Oe,"ReadableStreamDefaultControllerClose");function Me(e,t){if(!Ue(e))return;const r=e._controlledReadableStream;if(Ce(r)&&gt(r)>0)pr(r,t,false);else {let s;try{s=e._strategySizeAlgorithm(t);}catch(f){throw J(e,f),f}try{Rr(e,t,s);}catch(f){throw J(e,f),f}}st(e);}n$3(Me,"ReadableStreamDefaultControllerEnqueue");function J(e,t){const r=e._controlledReadableStream;r._state==="readable"&&(Se(e),jt(e),lo(r,t));}n$3(J,"ReadableStreamDefaultControllerError");function Mr(e){const t=e._controlledReadableStream._state;return t==="errored"?null:t==="closed"?0:e._strategyHWM-e._queueTotalSize}n$3(Mr,"ReadableStreamDefaultControllerGetDesiredSize");function ma(e){return !io(e)}n$3(ma,"ReadableStreamDefaultControllerHasBackpressure");function Ue(e){const t=e._controlledReadableStream._state;return !e._closeRequested&&t==="readable"}n$3(Ue,"ReadableStreamDefaultControllerCanCloseOrEnqueue");function ao(e,t,r,s,f,c,d){t._controlledReadableStream=e,t._queue=void 0,t._queueTotalSize=void 0,Se(t),t._started=false,t._closeRequested=false,t._pullAgain=false,t._pulling=false,t._strategySizeAlgorithm=d,t._strategyHWM=c,t._pullAlgorithm=s,t._cancelAlgorithm=f,e._readableStreamController=t;const p=r();g(T(p),()=>(t._started=true,st(t),null),R=>(J(t,R),null));}n$3(ao,"SetUpReadableStreamDefaultController");function ba(e,t,r,s){const f=Object.create(he.prototype);let c,d,p;t.start!==void 0?c=n$3(()=>t.start(f),"startAlgorithm"):c=n$3(()=>{},"startAlgorithm"),t.pull!==void 0?d=n$3(()=>t.pull(f),"pullAlgorithm"):d=n$3(()=>T(void 0),"pullAlgorithm"),t.cancel!==void 0?p=n$3(R=>t.cancel(R),"cancelAlgorithm"):p=n$3(()=>T(void 0),"cancelAlgorithm"),ao(e,f,c,d,p,r,s);}n$3(ba,"SetUpReadableStreamDefaultControllerFromUnderlyingSource");function Lt(e){return new TypeError(`ReadableStreamDefaultController.prototype.${e} can only be used on a ReadableStreamDefaultController`)}n$3(Lt,"defaultControllerBrandCheckException$1");function pa(e,t){return Ae(e._readableStreamController)?ga(e):ya(e)}n$3(pa,"ReadableStreamTee");function ya(e,t){const r=ze(e);let s=false,f=false,c=false,d=false,p,R,y,C,P;const B=A(U=>{P=U;});function ee(){return s?(f=true,T(void 0)):(s=true,et(r,{_chunkSteps:n$3(x=>{se(()=>{f=false;const K=x,be=x;c||Me(y._readableStreamController,K),d||Me(C._readableStreamController,be),s=false,f&&ee();});},"_chunkSteps"),_closeSteps:n$3(()=>{s=false,c||Oe(y._readableStreamController),d||Oe(C._readableStreamController),(!c||!d)&&P(void 0);},"_closeSteps"),_errorSteps:n$3(()=>{s=false;},"_errorSteps")}),T(void 0))}n$3(ee,"pullAlgorithm");function Ne(U){if(c=true,p=U,d){const x=tt([p,R]),K=X(e,x);P(K);}return B}n$3(Ne,"cancel1Algorithm");function Ee(U){if(d=true,R=U,c){const x=tt([p,R]),K=X(e,x);P(K);}return B}n$3(Ee,"cancel2Algorithm");function me(){}return n$3(me,"startAlgorithm"),y=ut(me,ee,Ne),C=ut(me,ee,Ee),I(r._closedPromise,U=>(J(y._readableStreamController,U),J(C._readableStreamController,U),(!c||!d)&&P(void 0),null)),[y,C]}n$3(ya,"ReadableStreamDefaultTee");function ga(e){let t=ze(e),r=false,s=false,f=false,c=false,d=false,p,R,y,C,P;const B=A(_=>{P=_;});function ee(_){I(_._closedPromise,v=>(_!==t||(Z(y._readableStreamController,v),Z(C._readableStreamController,v),(!c||!d)&&P(void 0)),null));}n$3(ee,"forwardReaderError");function Ne(){We(t)&&(ue(t),t=ze(e),ee(t)),et(t,{_chunkSteps:n$3(v=>{se(()=>{s=false,f=false;const W=v;let Y=v;if(!c&&!d)try{Y=Cn(v);}catch(He){Z(y._readableStreamController,He),Z(C._readableStreamController,He),P(X(e,He));return}c||Tt(y._readableStreamController,W),d||Tt(C._readableStreamController,Y),r=false,s?me():f&&U();});},"_chunkSteps"),_closeSteps:n$3(()=>{r=false,c||rt(y._readableStreamController),d||rt(C._readableStreamController),y._readableStreamController._pendingPullIntos.length>0&&Ct(y._readableStreamController,0),C._readableStreamController._pendingPullIntos.length>0&&Ct(C._readableStreamController,0),(!c||!d)&&P(void 0);},"_closeSteps"),_errorSteps:n$3(()=>{r=false;},"_errorSteps")});}n$3(Ne,"pullWithDefaultReader");function Ee(_,v){ge(t)&&(ue(t),t=jn(e),ee(t));const W=v?C:y,Y=v?y:C;$n(t,_,1,{_chunkSteps:n$3(Ve=>{se(()=>{s=false,f=false;const Qe=v?d:c;if(v?c:d)Qe||Pt(W._readableStreamController,Ve);else {let To;try{To=Cn(Ve);}catch(Vr){Z(W._readableStreamController,Vr),Z(Y._readableStreamController,Vr),P(X(e,Vr));return}Qe||Pt(W._readableStreamController,Ve),Tt(Y._readableStreamController,To);}r=false,s?me():f&&U();});},"_chunkSteps"),_closeSteps:n$3(Ve=>{r=false;const Qe=v?d:c,Vt=v?c:d;Qe||rt(W._readableStreamController),Vt||rt(Y._readableStreamController),Ve!==void 0&&(Qe||Pt(W._readableStreamController,Ve),!Vt&&Y._readableStreamController._pendingPullIntos.length>0&&Ct(Y._readableStreamController,0)),(!Qe||!Vt)&&P(void 0);},"_closeSteps"),_errorSteps:n$3(()=>{r=false;},"_errorSteps")});}n$3(Ee,"pullWithBYOBReader");function me(){if(r)return s=true,T(void 0);r=true;const _=vr(y._readableStreamController);return _===null?Ne():Ee(_._view,false),T(void 0)}n$3(me,"pull1Algorithm");function U(){if(r)return f=true,T(void 0);r=true;const _=vr(C._readableStreamController);return _===null?Ne():Ee(_._view,true),T(void 0)}n$3(U,"pull2Algorithm");function x(_){if(c=true,p=_,d){const v=tt([p,R]),W=X(e,v);P(W);}return B}n$3(x,"cancel1Algorithm");function K(_){if(d=true,R=_,c){const v=tt([p,R]),W=X(e,v);P(W);}return B}n$3(K,"cancel2Algorithm");function be(){}return n$3(be,"startAlgorithm"),y=uo(be,me,x),C=uo(be,U,K),ee(t),[y,C]}n$3(ga,"ReadableByteStreamTee");function _a(e){return u(e)&&typeof e.getReader<"u"}n$3(_a,"isReadableStreamLike");function Sa(e){return _a(e)?Ra(e.getReader()):wa(e)}n$3(Sa,"ReadableStreamFrom");function wa(e){let t;const r=Tn(e,"async"),s=l;function f(){let d;try{d=di(r);}catch(R){return b(R)}const p=T(d);return F(p,R=>{if(!u(R))throw new TypeError("The promise returned by the iterator.next() method must fulfill with an object");if(hi(R))Oe(t._readableStreamController);else {const C=mi(R);Me(t._readableStreamController,C);}})}n$3(f,"pullAlgorithm");function c(d){const p=r.iterator;let R;try{R=St(p,"return");}catch(P){return b(P)}if(R===void 0)return T(void 0);let y;try{y=O(R,p,[d]);}catch(P){return b(P)}const C=T(y);return F(C,P=>{if(!u(P))throw new TypeError("The promise returned by the iterator.return() method must fulfill with an object")})}return n$3(c,"cancelAlgorithm"),t=ut(s,f,c,0),t}n$3(wa,"ReadableStreamFromIterable");function Ra(e){let t;const r=l;function s(){let c;try{c=e.read();}catch(d){return b(d)}return F(c,d=>{if(!u(d))throw new TypeError("The promise returned by the reader.read() method must fulfill with an object");if(d.done)Oe(t._readableStreamController);else {const p=d.value;Me(t._readableStreamController,p);}})}n$3(s,"pullAlgorithm");function f(c){try{return T(e.cancel(c))}catch(d){return b(d)}}return n$3(f,"cancelAlgorithm"),t=ut(r,s,f,0),t}n$3(Ra,"ReadableStreamFromDefaultReader");function Ta(e,t){ne(e,t);const r=e,s=r?.autoAllocateChunkSize,f=r?.cancel,c=r?.pull,d=r?.start,p=r?.type;return {autoAllocateChunkSize:s===void 0?void 0:mr(s,`${t} has member 'autoAllocateChunkSize' that`),cancel:f===void 0?void 0:Ca(f,r,`${t} has member 'cancel' that`),pull:c===void 0?void 0:Pa(c,r,`${t} has member 'pull' that`),start:d===void 0?void 0:Ea(d,r,`${t} has member 'start' that`),type:p===void 0?void 0:va(p,`${t} has member 'type' that`)}}n$3(Ta,"convertUnderlyingDefaultOrByteSource");function Ca(e,t,r){return G(e,r),s=>z(e,t,[s])}n$3(Ca,"convertUnderlyingSourceCancelCallback");function Pa(e,t,r){return G(e,r),s=>z(e,t,[s])}n$3(Pa,"convertUnderlyingSourcePullCallback");function Ea(e,t,r){return G(e,r),s=>O(e,t,[s])}n$3(Ea,"convertUnderlyingSourceStartCallback");function va(e,t){if(e=`${e}`,e!=="bytes")throw new TypeError(`${t} '${e}' is not a valid enumeration value for ReadableStreamType`);return e}n$3(va,"convertReadableStreamType");function Aa(e,t){return ne(e,t),{preventCancel:!!e?.preventCancel}}n$3(Aa,"convertIteratorOptions");function so(e,t){ne(e,t);const r=e?.preventAbort,s=e?.preventCancel,f=e?.preventClose,c=e?.signal;return c!==void 0&&Ba(c,`${t} has member 'signal' that`),{preventAbort:!!r,preventCancel:!!s,preventClose:!!f,signal:c}}n$3(so,"convertPipeOptions");function Ba(e,t){if(!ji(e))throw new TypeError(`${t} is not an AbortSignal.`)}n$3(Ba,"assertAbortSignal");function Wa(e,t){ne(e,t);const r=e?.readable;dr(r,"readable","ReadableWritablePair"),br(r,`${t} has member 'readable' that`);const s=e?.writable;return dr(s,"writable","ReadableWritablePair"),Un(s,`${t} has member 'writable' that`),{readable:r,writable:s}}n$3(Wa,"convertReadableWritablePair");class L{static{n$3(this,"ReadableStream");}constructor(t={},r={}){t===void 0?t=null:cn(t,"First parameter");const s=At(r,"Second parameter"),f=Ta(t,"First parameter");if(Ur(this),f.type==="bytes"){if(s.size!==void 0)throw new RangeError("The strategy for a byte stream cannot have a size function");const c=ot(s,0);Ci(this,f,c);}else {const c=vt(s),d=ot(s,1);ba(this,f,d,c);}}get locked(){if(!Te(this))throw Ie("locked");return Ce(this)}cancel(t=void 0){return Te(this)?Ce(this)?b(new TypeError("Cannot cancel a stream that already has a reader")):X(this,t):b(Ie("cancel"))}getReader(t=void 0){if(!Te(this))throw Ie("getReader");return Ei(t,"First parameter").mode===void 0?ze(this):jn(this)}pipeThrough(t,r={}){if(!Te(this))throw Ie("pipeThrough");le(t,1,"pipeThrough");const s=Wa(t,"First parameter"),f=so(r,"Second parameter");if(Ce(this))throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");if(De(s.writable))throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");const c=oo(this,s.writable,f.preventClose,f.preventAbort,f.preventCancel,f.signal);return Q(c),s.readable}pipeTo(t,r={}){if(!Te(this))return b(Ie("pipeTo"));if(t===void 0)return b("Parameter 1 is required in 'pipeTo'.");if(!Le(t))return b(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));let s;try{s=so(r,"Second parameter");}catch(f){return b(f)}return Ce(this)?b(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream")):De(t)?b(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream")):oo(this,t,s.preventClose,s.preventAbort,s.preventCancel,s.signal)}tee(){if(!Te(this))throw Ie("tee");const t=pa(this);return tt(t)}values(t=void 0){if(!Te(this))throw Ie("values");const r=Aa(t,"First parameter");return fi(this,r.preventCancel)}[Sr](t){return this.values(t)}static from(t){return Sa(t)}}Object.defineProperties(L,{from:{enumerable:true}}),Object.defineProperties(L.prototype,{cancel:{enumerable:true},getReader:{enumerable:true},pipeThrough:{enumerable:true},pipeTo:{enumerable:true},tee:{enumerable:true},values:{enumerable:true},locked:{enumerable:true}}),h(L.from,"from"),h(L.prototype.cancel,"cancel"),h(L.prototype.getReader,"getReader"),h(L.prototype.pipeThrough,"pipeThrough"),h(L.prototype.pipeTo,"pipeTo"),h(L.prototype.tee,"tee"),h(L.prototype.values,"values"),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(L.prototype,Symbol.toStringTag,{value:"ReadableStream",configurable:true}),Object.defineProperty(L.prototype,Sr,{value:L.prototype.values,writable:true,configurable:true});function ut(e,t,r,s=1,f=()=>1){const c=Object.create(L.prototype);Ur(c);const d=Object.create(he.prototype);return ao(c,d,e,t,r,s,f),c}n$3(ut,"CreateReadableStream");function uo(e,t,r){const s=Object.create(L.prototype);Ur(s);const f=Object.create(ce.prototype);return zn(s,f,e,t,r,0,void 0),s}n$3(uo,"CreateReadableByteStream");function Ur(e){e._state="readable",e._reader=void 0,e._storedError=void 0,e._disturbed=false;}n$3(Ur,"InitializeReadableStream");function Te(e){return !u(e)||!Object.prototype.hasOwnProperty.call(e,"_readableStreamController")?false:e instanceof L}n$3(Te,"IsReadableStream");function Ce(e){return e._reader!==void 0}n$3(Ce,"IsReadableStreamLocked");function X(e,t){if(e._disturbed=true,e._state==="closed")return T(void 0);if(e._state==="errored")return b(e._storedError);lt(e);const r=e._reader;if(r!==void 0&&We(r)){const f=r._readIntoRequests;r._readIntoRequests=new M,f.forEach(c=>{c._closeSteps(void 0);});}const s=e._readableStreamController[ar](t);return F(s,l)}n$3(X,"ReadableStreamCancel");function lt(e){e._state="closed";const t=e._reader;if(t!==void 0&&(ln(t),ge(t))){const r=t._readRequests;t._readRequests=new M,r.forEach(s=>{s._closeSteps();});}}n$3(lt,"ReadableStreamClose");function lo(e,t){e._state="errored",e._storedError=t;const r=e._reader;r!==void 0&&(cr(r,t),ge(r)?bn(r,t):Mn(r,t));}n$3(lo,"ReadableStreamError");function Ie(e){return new TypeError(`ReadableStream.prototype.${e} can only be used on a ReadableStream`)}n$3(Ie,"streamBrandCheckException$1");function fo(e,t){ne(e,t);const r=e?.highWaterMark;return dr(r,"highWaterMark","QueuingStrategyInit"),{highWaterMark:hr(r)}}n$3(fo,"convertQueuingStrategyInit");const co=n$3(e=>e.byteLength,"byteLengthSizeFunction");h(co,"size");class Dt{static{n$3(this,"ByteLengthQueuingStrategy");}constructor(t){le(t,1,"ByteLengthQueuingStrategy"),t=fo(t,"First parameter"),this._byteLengthQueuingStrategyHighWaterMark=t.highWaterMark;}get highWaterMark(){if(!mo(this))throw ho("highWaterMark");return this._byteLengthQueuingStrategyHighWaterMark}get size(){if(!mo(this))throw ho("size");return co}}Object.defineProperties(Dt.prototype,{highWaterMark:{enumerable:true},size:{enumerable:true}}),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(Dt.prototype,Symbol.toStringTag,{value:"ByteLengthQueuingStrategy",configurable:true});function ho(e){return new TypeError(`ByteLengthQueuingStrategy.prototype.${e} can only be used on a ByteLengthQueuingStrategy`)}n$3(ho,"byteLengthBrandCheckException");function mo(e){return !u(e)||!Object.prototype.hasOwnProperty.call(e,"_byteLengthQueuingStrategyHighWaterMark")?false:e instanceof Dt}n$3(mo,"IsByteLengthQueuingStrategy");const bo=n$3(()=>1,"countSizeFunction");h(bo,"size");class $t{static{n$3(this,"CountQueuingStrategy");}constructor(t){le(t,1,"CountQueuingStrategy"),t=fo(t,"First parameter"),this._countQueuingStrategyHighWaterMark=t.highWaterMark;}get highWaterMark(){if(!yo(this))throw po("highWaterMark");return this._countQueuingStrategyHighWaterMark}get size(){if(!yo(this))throw po("size");return bo}}Object.defineProperties($t.prototype,{highWaterMark:{enumerable:true},size:{enumerable:true}}),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty($t.prototype,Symbol.toStringTag,{value:"CountQueuingStrategy",configurable:true});function po(e){return new TypeError(`CountQueuingStrategy.prototype.${e} can only be used on a CountQueuingStrategy`)}n$3(po,"countBrandCheckException");function yo(e){return !u(e)||!Object.prototype.hasOwnProperty.call(e,"_countQueuingStrategyHighWaterMark")?false:e instanceof $t}n$3(yo,"IsCountQueuingStrategy");function ka(e,t){ne(e,t);const r=e?.cancel,s=e?.flush,f=e?.readableType,c=e?.start,d=e?.transform,p=e?.writableType;return {cancel:r===void 0?void 0:Fa(r,e,`${t} has member 'cancel' that`),flush:s===void 0?void 0:qa(s,e,`${t} has member 'flush' that`),readableType:f,start:c===void 0?void 0:Oa(c,e,`${t} has member 'start' that`),transform:d===void 0?void 0:Ia(d,e,`${t} has member 'transform' that`),writableType:p}}n$3(ka,"convertTransformer");function qa(e,t,r){return G(e,r),s=>z(e,t,[s])}n$3(qa,"convertTransformerFlushCallback");function Oa(e,t,r){return G(e,r),s=>O(e,t,[s])}n$3(Oa,"convertTransformerStartCallback");function Ia(e,t,r){return G(e,r),(s,f)=>z(e,t,[s,f])}n$3(Ia,"convertTransformerTransformCallback");function Fa(e,t,r){return G(e,r),s=>z(e,t,[s])}n$3(Fa,"convertTransformerCancelCallback");class Mt{static{n$3(this,"TransformStream");}constructor(t={},r={},s={}){t===void 0&&(t=null);const f=At(r,"Second parameter"),c=At(s,"Third parameter"),d=ka(t,"First parameter");if(d.readableType!==void 0)throw new RangeError("Invalid readableType specified");if(d.writableType!==void 0)throw new RangeError("Invalid writableType specified");const p=ot(c,0),R=vt(c),y=ot(f,1),C=vt(f);let P;const B=A(ee=>{P=ee;});za(this,B,y,C,p,R),La(this,d),d.start!==void 0?P(d.start(this._transformStreamController)):P(void 0);}get readable(){if(!go(this))throw Ro("readable");return this._readable}get writable(){if(!go(this))throw Ro("writable");return this._writable}}Object.defineProperties(Mt.prototype,{readable:{enumerable:true},writable:{enumerable:true}}),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(Mt.prototype,Symbol.toStringTag,{value:"TransformStream",configurable:true});function za(e,t,r,s,f,c){function d(){return t}n$3(d,"startAlgorithm");function p(B){return Ma(e,B)}n$3(p,"writeAlgorithm");function R(B){return Ua(e,B)}n$3(R,"abortAlgorithm");function y(){return xa(e)}n$3(y,"closeAlgorithm"),e._writable=$i(d,p,y,R,r,s);function C(){return Na(e)}n$3(C,"pullAlgorithm");function P(B){return Ha(e,B)}n$3(P,"cancelAlgorithm"),e._readable=ut(d,C,P,f,c),e._backpressure=void 0,e._backpressureChangePromise=void 0,e._backpressureChangePromise_resolve=void 0,Ut(e,true),e._transformStreamController=void 0;}n$3(za,"InitializeTransformStream");function go(e){return !u(e)||!Object.prototype.hasOwnProperty.call(e,"_transformStreamController")?false:e instanceof Mt}n$3(go,"IsTransformStream");function _o(e,t){J(e._readable._readableStreamController,t),xr(e,t);}n$3(_o,"TransformStreamError");function xr(e,t){Nt(e._transformStreamController),it(e._writable._writableStreamController,t),Nr(e);}n$3(xr,"TransformStreamErrorWritableAndUnblockWrite");function Nr(e){e._backpressure&&Ut(e,false);}n$3(Nr,"TransformStreamUnblockWrite");function Ut(e,t){e._backpressureChangePromise!==void 0&&e._backpressureChangePromise_resolve(),e._backpressureChangePromise=A(r=>{e._backpressureChangePromise_resolve=r;}),e._backpressure=t;}n$3(Ut,"TransformStreamSetBackpressure");class Pe{static{n$3(this,"TransformStreamDefaultController");}constructor(){throw new TypeError("Illegal constructor")}get desiredSize(){if(!xt(this))throw Ht("desiredSize");const t=this._controlledTransformStream._readable._readableStreamController;return Mr(t)}enqueue(t=void 0){if(!xt(this))throw Ht("enqueue");So(this,t);}error(t=void 0){if(!xt(this))throw Ht("error");Da(this,t);}terminate(){if(!xt(this))throw Ht("terminate");$a(this);}}Object.defineProperties(Pe.prototype,{enqueue:{enumerable:true},error:{enumerable:true},terminate:{enumerable:true},desiredSize:{enumerable:true}}),h(Pe.prototype.enqueue,"enqueue"),h(Pe.prototype.error,"error"),h(Pe.prototype.terminate,"terminate"),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(Pe.prototype,Symbol.toStringTag,{value:"TransformStreamDefaultController",configurable:true});function xt(e){return !u(e)||!Object.prototype.hasOwnProperty.call(e,"_controlledTransformStream")?false:e instanceof Pe}n$3(xt,"IsTransformStreamDefaultController");function ja(e,t,r,s,f){t._controlledTransformStream=e,e._transformStreamController=t,t._transformAlgorithm=r,t._flushAlgorithm=s,t._cancelAlgorithm=f,t._finishPromise=void 0,t._finishPromise_resolve=void 0,t._finishPromise_reject=void 0;}n$3(ja,"SetUpTransformStreamDefaultController");function La(e,t){const r=Object.create(Pe.prototype);let s,f,c;t.transform!==void 0?s=n$3(d=>t.transform(d,r),"transformAlgorithm"):s=n$3(d=>{try{return So(r,d),T(void 0)}catch(p){return b(p)}},"transformAlgorithm"),t.flush!==void 0?f=n$3(()=>t.flush(r),"flushAlgorithm"):f=n$3(()=>T(void 0),"flushAlgorithm"),t.cancel!==void 0?c=n$3(d=>t.cancel(d),"cancelAlgorithm"):c=n$3(()=>T(void 0),"cancelAlgorithm"),ja(e,r,s,f,c);}n$3(La,"SetUpTransformStreamDefaultControllerFromTransformer");function Nt(e){e._transformAlgorithm=void 0,e._flushAlgorithm=void 0,e._cancelAlgorithm=void 0;}n$3(Nt,"TransformStreamDefaultControllerClearAlgorithms");function So(e,t){const r=e._controlledTransformStream,s=r._readable._readableStreamController;if(!Ue(s))throw new TypeError("Readable side is not in a state that permits enqueue");try{Me(s,t);}catch(c){throw xr(r,c),r._readable._storedError}ma(s)!==r._backpressure&&Ut(r,true);}n$3(So,"TransformStreamDefaultControllerEnqueue");function Da(e,t){_o(e._controlledTransformStream,t);}n$3(Da,"TransformStreamDefaultControllerError");function wo(e,t){const r=e._transformAlgorithm(t);return F(r,void 0,s=>{throw _o(e._controlledTransformStream,s),s})}n$3(wo,"TransformStreamDefaultControllerPerformTransform");function $a(e){const t=e._controlledTransformStream,r=t._readable._readableStreamController;Oe(r);const s=new TypeError("TransformStream terminated");xr(t,s);}n$3($a,"TransformStreamDefaultControllerTerminate");function Ma(e,t){const r=e._transformStreamController;if(e._backpressure){const s=e._backpressureChangePromise;return F(s,()=>{const f=e._writable;if(f._state==="erroring")throw f._storedError;return wo(r,t)})}return wo(r,t)}n$3(Ma,"TransformStreamDefaultSinkWriteAlgorithm");function Ua(e,t){const r=e._transformStreamController;if(r._finishPromise!==void 0)return r._finishPromise;const s=e._readable;r._finishPromise=A((c,d)=>{r._finishPromise_resolve=c,r._finishPromise_reject=d;});const f=r._cancelAlgorithm(t);return Nt(r),g(f,()=>(s._state==="errored"?xe(r,s._storedError):(J(s._readableStreamController,t),Hr(r)),null),c=>(J(s._readableStreamController,c),xe(r,c),null)),r._finishPromise}n$3(Ua,"TransformStreamDefaultSinkAbortAlgorithm");function xa(e){const t=e._transformStreamController;if(t._finishPromise!==void 0)return t._finishPromise;const r=e._readable;t._finishPromise=A((f,c)=>{t._finishPromise_resolve=f,t._finishPromise_reject=c;});const s=t._flushAlgorithm();return Nt(t),g(s,()=>(r._state==="errored"?xe(t,r._storedError):(Oe(r._readableStreamController),Hr(t)),null),f=>(J(r._readableStreamController,f),xe(t,f),null)),t._finishPromise}n$3(xa,"TransformStreamDefaultSinkCloseAlgorithm");function Na(e){return Ut(e,false),e._backpressureChangePromise}n$3(Na,"TransformStreamDefaultSourcePullAlgorithm");function Ha(e,t){const r=e._transformStreamController;if(r._finishPromise!==void 0)return r._finishPromise;const s=e._writable;r._finishPromise=A((c,d)=>{r._finishPromise_resolve=c,r._finishPromise_reject=d;});const f=r._cancelAlgorithm(t);return Nt(r),g(f,()=>(s._state==="errored"?xe(r,s._storedError):(it(s._writableStreamController,t),Nr(e),Hr(r)),null),c=>(it(s._writableStreamController,c),Nr(e),xe(r,c),null)),r._finishPromise}n$3(Ha,"TransformStreamDefaultSourceCancelAlgorithm");function Ht(e){return new TypeError(`TransformStreamDefaultController.prototype.${e} can only be used on a TransformStreamDefaultController`)}n$3(Ht,"defaultControllerBrandCheckException");function Hr(e){e._finishPromise_resolve!==void 0&&(e._finishPromise_resolve(),e._finishPromise_resolve=void 0,e._finishPromise_reject=void 0);}n$3(Hr,"defaultControllerFinishPromiseResolve");function xe(e,t){e._finishPromise_reject!==void 0&&(Q(e._finishPromise),e._finishPromise_reject(t),e._finishPromise_resolve=void 0,e._finishPromise_reject=void 0);}n$3(xe,"defaultControllerFinishPromiseReject");function Ro(e){return new TypeError(`TransformStream.prototype.${e} can only be used on a TransformStream`)}n$3(Ro,"streamBrandCheckException"),a.ByteLengthQueuingStrategy=Dt,a.CountQueuingStrategy=$t,a.ReadableByteStreamController=ce,a.ReadableStream=L,a.ReadableStreamBYOBReader=we,a.ReadableStreamBYOBRequest=ve,a.ReadableStreamDefaultController=he,a.ReadableStreamDefaultReader=ye,a.TransformStream=Mt,a.TransformStreamDefaultController=Pe,a.WritableStream=Re,a.WritableStreamDefaultController=$e,a.WritableStreamDefaultWriter=de;});}(ct,ct.exports)),ct.exports}n$3(ns,"requirePonyfill_es2018");var Ao;function os(){if(Ao)return Eo;Ao=1;const i=65536;if(!globalThis.ReadableStream)try{const o=require("node:process"),{emitWarning:a}=o;try{o.emitWarning=()=>{},Object.assign(globalThis,require("node:stream/web")),o.emitWarning=a;}catch(l){throw o.emitWarning=a,l}}catch{Object.assign(globalThis,ns());}try{const{Blob:o}=require("buffer");o&&!o.prototype.stream&&(o.prototype.stream=n$3(function(l){let u=0;const m=this;return new ReadableStream({type:"bytes",async pull(h){const E=await m.slice(u,Math.min(m.size,u+i)).arrayBuffer();u+=E.byteLength,h.enqueue(new Uint8Array(E)),u===m.size&&h.close();}})},"name"));}catch{}return Eo}n$3(os,"requireStreams"),os();/*! fetch-blob. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */const Bo=65536;async function*Qr(i,o=true){for(const a of i)if("stream"in a)yield*a.stream();else if(ArrayBuffer.isView(a))if(o){let l=a.byteOffset;const u=a.byteOffset+a.byteLength;for(;l!==u;){const m=Math.min(u-l,Bo),h=a.buffer.slice(l,l+m);l+=h.byteLength,yield new Uint8Array(h);}}else yield a;else {let l=0,u=a;for(;l!==u.size;){const h=await u.slice(l,Math.min(u.size,l+Bo)).arrayBuffer();l+=h.byteLength,yield new Uint8Array(h);}}}n$3(Qr,"toIterator");const Wo=class on{static{n$3(this,"Blob");}#e=[];#t="";#r=0;#n="transparent";constructor(o=[],a={}){if(typeof o!="object"||o===null)throw new TypeError("Failed to construct 'Blob': The provided value cannot be converted to a sequence.");if(typeof o[Symbol.iterator]!="function")throw new TypeError("Failed to construct 'Blob': The object must have a callable @@iterator property.");if(typeof a!="object"&&typeof a!="function")throw new TypeError("Failed to construct 'Blob': parameter 2 cannot convert to dictionary.");a===null&&(a={});const l=new TextEncoder;for(const m of o){let h;ArrayBuffer.isView(m)?h=new Uint8Array(m.buffer.slice(m.byteOffset,m.byteOffset+m.byteLength)):m instanceof ArrayBuffer?h=new Uint8Array(m.slice(0)):m instanceof on?h=m:h=l.encode(`${m}`),this.#r+=ArrayBuffer.isView(h)?h.byteLength:h.size,this.#e.push(h);}this.#n=`${a.endings===void 0?"transparent":a.endings}`;const u=a.type===void 0?"":String(a.type);this.#t=/^[\x20-\x7E]*$/.test(u)?u:"";}get size(){return this.#r}get type(){return this.#t}async text(){const o=new TextDecoder;let a="";for await(const l of Qr(this.#e,false))a+=o.decode(l,{stream:true});return a+=o.decode(),a}async arrayBuffer(){const o=new Uint8Array(this.size);let a=0;for await(const l of Qr(this.#e,false))o.set(l,a),a+=l.length;return o.buffer}stream(){const o=Qr(this.#e,true);return new globalThis.ReadableStream({type:"bytes",async pull(a){const l=await o.next();l.done?a.close():a.enqueue(l.value);},async cancel(){await o.return();}})}slice(o=0,a=this.size,l=""){const{size:u}=this;let m=o<0?Math.max(u+o,0):Math.min(o,u),h=a<0?Math.max(u+a,0):Math.min(a,u);const S=Math.max(h-m,0),E=this.#e,w=[];let A=0;for(const b of E){if(A>=S)break;const q=ArrayBuffer.isView(b)?b.byteLength:b.size;if(m&&q<=m)m-=q,h-=q;else {let g;ArrayBuffer.isView(b)?(g=b.subarray(m,Math.min(q,h)),A+=g.byteLength):(g=b.slice(m,Math.min(q,h)),A+=g.size),h-=q,w.push(g),m=0;}}const T=new on([],{type:String(l).toLowerCase()});return T.#r=S,T.#e=w,T}get[Symbol.toStringTag](){return "Blob"}static[Symbol.hasInstance](o){return o&&typeof o=="object"&&typeof o.constructor=="function"&&(typeof o.stream=="function"||typeof o.arrayBuffer=="function")&&/^(Blob|File)$/.test(o[Symbol.toStringTag])}};Object.defineProperties(Wo.prototype,{size:{enumerable:true},type:{enumerable:true},slice:{enumerable:true}});const Ze=Wo,is=class extends Ze{static{n$3(this,"File");}#e=0;#t="";constructor(o,a,l={}){if(arguments.length<2)throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`);super(o,l),l===null&&(l={});const u=l.lastModified===void 0?Date.now():Number(l.lastModified);Number.isNaN(u)||(this.#e=u),this.#t=String(a);}get name(){return this.#t}get lastModified(){return this.#e}get[Symbol.toStringTag](){return "File"}static[Symbol.hasInstance](o){return !!o&&o instanceof Ze&&/^(File)$/.test(o[Symbol.toStringTag])}},Yr=is;/*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */var{toStringTag:dt,iterator:as,hasInstance:ss}=Symbol,ko=Math.random,us="append,set,get,getAll,delete,keys,values,entries,forEach,constructor".split(","),qo=n$3((i,o,a)=>(i+="",/^(Blob|File)$/.test(o&&o[dt])?[(a=a!==void 0?a+"":o[dt]=="File"?o.name:"blob",i),o.name!==a||o[dt]=="blob"?new Yr([o],a,o):o]:[i,o+""]),"f"),Gr=n$3((i,o)=>(o?i:i.replace(/\r?\n|\r/g,`\r
`)).replace(/\n/g,"%0A").replace(/\r/g,"%0D").replace(/"/g,"%22"),"e$1"),Fe=n$3((i,o,a)=>{if(o.length<a)throw new TypeError(`Failed to execute '${i}' on 'FormData': ${a} arguments required, but only ${o.length} present.`)},"x");const Zt=class{static{n$3(this,"FormData");}#e=[];constructor(...o){if(o.length)throw new TypeError("Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.")}get[dt](){return "FormData"}[as](){return this.entries()}static[ss](o){return o&&typeof o=="object"&&o[dt]==="FormData"&&!us.some(a=>typeof o[a]!="function")}append(...o){Fe("append",arguments,2),this.#e.push(qo(...o));}delete(o){Fe("delete",arguments,1),o+="",this.#e=this.#e.filter(([a])=>a!==o);}get(o){Fe("get",arguments,1),o+="";for(var a=this.#e,l=a.length,u=0;u<l;u++)if(a[u][0]===o)return a[u][1];return null}getAll(o,a){return Fe("getAll",arguments,1),a=[],o+="",this.#e.forEach(l=>l[0]===o&&a.push(l[1])),a}has(o){return Fe("has",arguments,1),o+="",this.#e.some(a=>a[0]===o)}forEach(o,a){Fe("forEach",arguments,1);for(var[l,u]of this)o.call(a,u,l,this);}set(...o){Fe("set",arguments,2);var a=[],l=true;o=qo(...o),this.#e.forEach(u=>{u[0]===o[0]?l&&(l=!a.push(o)):a.push(u);}),l&&a.push(o),this.#e=a;}*entries(){yield*this.#e;}*keys(){for(var[o]of this)yield o;}*values(){for(var[,o]of this)yield o;}};function ls(i,o=Ze){var a=`${ko()}${ko()}`.replace(/\./g,"").slice(-28).padStart(32,"-"),l=[],u=`--${a}\r
Content-Disposition: form-data; name="`;return i.forEach((m,h)=>typeof m=="string"?l.push(u+Gr(h)+`"\r
\r
${m.replace(/\r(?!\n)|(?<!\r)\n/g,`\r
`)}\r
`):l.push(u+Gr(h)+`"; filename="${Gr(m.name,1)}"\r
Content-Type: ${m.type||"application/octet-stream"}\r
\r
`,m,`\r
`)),l.push(`--${a}--`),new o(l,{type:"multipart/form-data; boundary="+a})}n$3(ls,"formDataToBlob");class Kt extends Error{static{n$3(this,"FetchBaseError");}constructor(o,a){super(o),Error.captureStackTrace(this,this.constructor),this.type=a;}get name(){return this.constructor.name}get[Symbol.toStringTag](){return this.constructor.name}}class te extends Kt{static{n$3(this,"FetchError");}constructor(o,a,l){super(o,a),l&&(this.code=this.errno=l.code,this.erroredSysCall=l.syscall);}}const Jt=Symbol.toStringTag,Oo=n$3(i=>typeof i=="object"&&typeof i.append=="function"&&typeof i.delete=="function"&&typeof i.get=="function"&&typeof i.getAll=="function"&&typeof i.has=="function"&&typeof i.set=="function"&&typeof i.sort=="function"&&i[Jt]==="URLSearchParams","isURLSearchParameters"),Xt=n$3(i=>i&&typeof i=="object"&&typeof i.arrayBuffer=="function"&&typeof i.type=="string"&&typeof i.stream=="function"&&typeof i.constructor=="function"&&/^(Blob|File)$/.test(i[Jt]),"isBlob"),fs=n$3(i=>typeof i=="object"&&(i[Jt]==="AbortSignal"||i[Jt]==="EventTarget"),"isAbortSignal"),cs=n$3((i,o)=>{const a=new URL(o).hostname,l=new URL(i).hostname;return a===l||a.endsWith(`.${l}`)},"isDomainOrSubdomain"),ds=n$3((i,o)=>{const a=new URL(o).protocol,l=new URL(i).protocol;return a===l},"isSameProtocol"),hs=promisify(ie.pipeline),N$2=Symbol("Body internals");class ht{static{n$3(this,"Body");}constructor(o,{size:a=0}={}){let l=null;o===null?o=null:Oo(o)?o=Buffer$1.from(o.toString()):Xt(o)||Buffer$1.isBuffer(o)||(types$3.isAnyArrayBuffer(o)?o=Buffer$1.from(o):ArrayBuffer.isView(o)?o=Buffer$1.from(o.buffer,o.byteOffset,o.byteLength):o instanceof ie||(o instanceof Zt?(o=ls(o),l=o.type.split("=")[1]):o=Buffer$1.from(String(o))));let u=o;Buffer$1.isBuffer(o)?u=ie.Readable.from(o):Xt(o)&&(u=ie.Readable.from(o.stream())),this[N$2]={body:o,stream:u,boundary:l,disturbed:false,error:null},this.size=a,o instanceof ie&&o.on("error",m=>{const h=m instanceof Kt?m:new te(`Invalid response body while trying to fetch ${this.url}: ${m.message}`,"system",m);this[N$2].error=h;});}get body(){return this[N$2].stream}get bodyUsed(){return this[N$2].disturbed}async arrayBuffer(){const{buffer:o,byteOffset:a,byteLength:l}=await Zr(this);return o.slice(a,a+l)}async formData(){const o=this.headers.get("content-type");if(o.startsWith("application/x-www-form-urlencoded")){const l=new Zt,u=new URLSearchParams(await this.text());for(const[m,h]of u)l.append(m,h);return l}const{toFormData:a}=await import('./chunks/multipart-parser.mjs');return a(this.body,o)}async blob(){const o=this.headers&&this.headers.get("content-type")||this[N$2].body&&this[N$2].body.type||"",a=await this.arrayBuffer();return new Ze([a],{type:o})}async json(){const o=await this.text();return JSON.parse(o)}async text(){const o=await Zr(this);return new TextDecoder().decode(o)}buffer(){return Zr(this)}}ht.prototype.buffer=deprecate(ht.prototype.buffer,"Please use 'response.arrayBuffer()' instead of 'response.buffer()'","node-fetch#buffer"),Object.defineProperties(ht.prototype,{body:{enumerable:true},bodyUsed:{enumerable:true},arrayBuffer:{enumerable:true},blob:{enumerable:true},json:{enumerable:true},text:{enumerable:true},data:{get:deprecate(()=>{},"data doesn't exist, use json(), text(), arrayBuffer(), or body instead","https://github.com/node-fetch/node-fetch/issues/1000 (response)")}});async function Zr(i){if(i[N$2].disturbed)throw new TypeError(`body used already for: ${i.url}`);if(i[N$2].disturbed=true,i[N$2].error)throw i[N$2].error;const{body:o}=i;if(o===null)return Buffer$1.alloc(0);if(!(o instanceof ie))return Buffer$1.alloc(0);const a=[];let l=0;try{for await(const u of o){if(i.size>0&&l+u.length>i.size){const m=new te(`content size at ${i.url} over limit: ${i.size}`,"max-size");throw o.destroy(m),m}l+=u.length,a.push(u);}}catch(u){throw u instanceof Kt?u:new te(`Invalid response body while trying to fetch ${i.url}: ${u.message}`,"system",u)}if(o.readableEnded===true||o._readableState.ended===true)try{return a.every(u=>typeof u=="string")?Buffer$1.from(a.join("")):Buffer$1.concat(a,l)}catch(u){throw new te(`Could not create Buffer from response body for ${i.url}: ${u.message}`,"system",u)}else throw new te(`Premature close of server response while trying to fetch ${i.url}`)}n$3(Zr,"consumeBody");const Kr=n$3((i,o)=>{let a,l,{body:u}=i[N$2];if(i.bodyUsed)throw new Error("cannot clone body after it is used");return u instanceof ie&&typeof u.getBoundary!="function"&&(a=new PassThrough({highWaterMark:o}),l=new PassThrough({highWaterMark:o}),u.pipe(a),u.pipe(l),i[N$2].stream=a,u=l),u},"clone"),ms=deprecate(i=>i.getBoundary(),"form-data doesn't follow the spec and requires special treatment. Use alternative package","https://github.com/node-fetch/node-fetch/issues/1167"),Io=n$3((i,o)=>i===null?null:typeof i=="string"?"text/plain;charset=UTF-8":Oo(i)?"application/x-www-form-urlencoded;charset=UTF-8":Xt(i)?i.type||null:Buffer$1.isBuffer(i)||types$3.isAnyArrayBuffer(i)||ArrayBuffer.isView(i)?null:i instanceof Zt?`multipart/form-data; boundary=${o[N$2].boundary}`:i&&typeof i.getBoundary=="function"?`multipart/form-data;boundary=${ms(i)}`:i instanceof ie?null:"text/plain;charset=UTF-8","extractContentType"),bs=n$3(i=>{const{body:o}=i[N$2];return o===null?0:Xt(o)?o.size:Buffer$1.isBuffer(o)?o.length:o&&typeof o.getLengthSync=="function"&&o.hasKnownLength&&o.hasKnownLength()?o.getLengthSync():null},"getTotalBytes"),ps=n$3(async(i,{body:o})=>{o===null?i.end():await hs(o,i);},"writeToStream"),er=typeof ft.validateHeaderName=="function"?ft.validateHeaderName:i=>{if(!/^[\^`\-\w!#$%&'*+.|~]+$/.test(i)){const o=new TypeError(`Header name must be a valid HTTP token [${i}]`);throw Object.defineProperty(o,"code",{value:"ERR_INVALID_HTTP_TOKEN"}),o}},Jr=typeof ft.validateHeaderValue=="function"?ft.validateHeaderValue:(i,o)=>{if(/[^\t\u0020-\u007E\u0080-\u00FF]/.test(o)){const a=new TypeError(`Invalid character in header content ["${i}"]`);throw Object.defineProperty(a,"code",{value:"ERR_INVALID_CHAR"}),a}};class ae extends URLSearchParams{static{n$3(this,"Headers");}constructor(o){let a=[];if(o instanceof ae){const l=o.raw();for(const[u,m]of Object.entries(l))a.push(...m.map(h=>[u,h]));}else if(o!=null)if(typeof o=="object"&&!types$3.isBoxedPrimitive(o)){const l=o[Symbol.iterator];if(l==null)a.push(...Object.entries(o));else {if(typeof l!="function")throw new TypeError("Header pairs must be iterable");a=[...o].map(u=>{if(typeof u!="object"||types$3.isBoxedPrimitive(u))throw new TypeError("Each header pair must be an iterable object");return [...u]}).map(u=>{if(u.length!==2)throw new TypeError("Each header pair must be a name/value tuple");return [...u]});}}else throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");return a=a.length>0?a.map(([l,u])=>(er(l),Jr(l,String(u)),[String(l).toLowerCase(),String(u)])):void 0,super(a),new Proxy(this,{get(l,u,m){switch(u){case "append":case "set":return (h,S)=>(er(h),Jr(h,String(S)),URLSearchParams.prototype[u].call(l,String(h).toLowerCase(),String(S)));case "delete":case "has":case "getAll":return h=>(er(h),URLSearchParams.prototype[u].call(l,String(h).toLowerCase()));case "keys":return ()=>(l.sort(),new Set(URLSearchParams.prototype.keys.call(l)).keys());default:return Reflect.get(l,u,m)}}})}get[Symbol.toStringTag](){return this.constructor.name}toString(){return Object.prototype.toString.call(this)}get(o){const a=this.getAll(o);if(a.length===0)return null;let l=a.join(", ");return /^content-encoding$/i.test(o)&&(l=l.toLowerCase()),l}forEach(o,a=void 0){for(const l of this.keys())Reflect.apply(o,a,[this.get(l),l,this]);}*values(){for(const o of this.keys())yield this.get(o);}*entries(){for(const o of this.keys())yield [o,this.get(o)];}[Symbol.iterator](){return this.entries()}raw(){return [...this.keys()].reduce((o,a)=>(o[a]=this.getAll(a),o),{})}[Symbol.for("nodejs.util.inspect.custom")](){return [...this.keys()].reduce((o,a)=>{const l=this.getAll(a);return a==="host"?o[a]=l[0]:o[a]=l.length>1?l:l[0],o},{})}}Object.defineProperties(ae.prototype,["get","entries","forEach","values"].reduce((i,o)=>(i[o]={enumerable:true},i),{}));function ys(i=[]){return new ae(i.reduce((o,a,l,u)=>(l%2===0&&o.push(u.slice(l,l+2)),o),[]).filter(([o,a])=>{try{return er(o),Jr(o,String(a)),!0}catch{return  false}}))}n$3(ys,"fromRawHeaders");const gs=new Set([301,302,303,307,308]),Xr=n$3(i=>gs.has(i),"isRedirect"),re=Symbol("Response internals");class H extends ht{static{n$3(this,"Response");}constructor(o=null,a={}){super(o,a);const l=a.status!=null?a.status:200,u=new ae(a.headers);if(o!==null&&!u.has("Content-Type")){const m=Io(o,this);m&&u.append("Content-Type",m);}this[re]={type:"default",url:a.url,status:l,statusText:a.statusText||"",headers:u,counter:a.counter,highWaterMark:a.highWaterMark};}get type(){return this[re].type}get url(){return this[re].url||""}get status(){return this[re].status}get ok(){return this[re].status>=200&&this[re].status<300}get redirected(){return this[re].counter>0}get statusText(){return this[re].statusText}get headers(){return this[re].headers}get highWaterMark(){return this[re].highWaterMark}clone(){return new H(Kr(this,this.highWaterMark),{type:this.type,url:this.url,status:this.status,statusText:this.statusText,headers:this.headers,ok:this.ok,redirected:this.redirected,size:this.size,highWaterMark:this.highWaterMark})}static redirect(o,a=302){if(!Xr(a))throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');return new H(null,{headers:{location:new URL(o).toString()},status:a})}static error(){const o=new H(null,{status:0,statusText:""});return o[re].type="error",o}static json(o=void 0,a={}){const l=JSON.stringify(o);if(l===void 0)throw new TypeError("data is not JSON serializable");const u=new ae(a&&a.headers);return u.has("content-type")||u.set("content-type","application/json"),new H(l,{...a,headers:u})}get[Symbol.toStringTag](){return "Response"}}Object.defineProperties(H.prototype,{type:{enumerable:true},url:{enumerable:true},status:{enumerable:true},ok:{enumerable:true},redirected:{enumerable:true},statusText:{enumerable:true},headers:{enumerable:true},clone:{enumerable:true}});const _s=n$3(i=>{if(i.search)return i.search;const o=i.href.length-1,a=i.hash||(i.href[o]==="#"?"#":"");return i.href[o-a.length]==="?"?"?":""},"getSearch");function Fo(i,o=false){return i==null||(i=new URL(i),/^(about|blob|data):$/.test(i.protocol))?"no-referrer":(i.username="",i.password="",i.hash="",o&&(i.pathname="",i.search=""),i)}n$3(Fo,"stripURLForUseAsAReferrer");const zo=new Set(["","no-referrer","no-referrer-when-downgrade","same-origin","origin","strict-origin","origin-when-cross-origin","strict-origin-when-cross-origin","unsafe-url"]),Ss="strict-origin-when-cross-origin";function ws(i){if(!zo.has(i))throw new TypeError(`Invalid referrerPolicy: ${i}`);return i}n$3(ws,"validateReferrerPolicy");function Rs(i){if(/^(http|ws)s:$/.test(i.protocol))return  true;const o=i.host.replace(/(^\[)|(]$)/g,""),a=isIP(o);return a===4&&/^127\./.test(o)||a===6&&/^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(o)?true:i.host==="localhost"||i.host.endsWith(".localhost")?false:i.protocol==="file:"}n$3(Rs,"isOriginPotentiallyTrustworthy");function Ke(i){return /^about:(blank|srcdoc)$/.test(i)||i.protocol==="data:"||/^(blob|filesystem):$/.test(i.protocol)?true:Rs(i)}n$3(Ke,"isUrlPotentiallyTrustworthy");function Ts(i,{referrerURLCallback:o,referrerOriginCallback:a}={}){if(i.referrer==="no-referrer"||i.referrerPolicy==="")return null;const l=i.referrerPolicy;if(i.referrer==="about:client")return "no-referrer";const u=i.referrer;let m=Fo(u),h=Fo(u,true);m.toString().length>4096&&(m=h),o&&(m=o(m)),a&&(h=a(h));const S=new URL(i.url);switch(l){case "no-referrer":return "no-referrer";case "origin":return h;case "unsafe-url":return m;case "strict-origin":return Ke(m)&&!Ke(S)?"no-referrer":h.toString();case "strict-origin-when-cross-origin":return m.origin===S.origin?m:Ke(m)&&!Ke(S)?"no-referrer":h;case "same-origin":return m.origin===S.origin?m:"no-referrer";case "origin-when-cross-origin":return m.origin===S.origin?m:h;case "no-referrer-when-downgrade":return Ke(m)&&!Ke(S)?"no-referrer":m;default:throw new TypeError(`Invalid referrerPolicy: ${l}`)}}n$3(Ts,"determineRequestsReferrer");function Cs(i){const o=(i.get("referrer-policy")||"").split(/[,\s]+/);let a="";for(const l of o)l&&zo.has(l)&&(a=l);return a}n$3(Cs,"parseReferrerPolicyFromHeader");const j=Symbol("Request internals"),mt=n$3(i=>typeof i=="object"&&typeof i[j]=="object","isRequest"),Ps=deprecate(()=>{},".data is not a valid RequestInit property, use .body instead","https://github.com/node-fetch/node-fetch/issues/1000 (request)");class Xe extends ht{static{n$3(this,"Request");}constructor(o,a={}){let l;if(mt(o)?l=new URL(o.url):(l=new URL(o),o={}),l.username!==""||l.password!=="")throw new TypeError(`${l} is an url with embedded credentials.`);let u=a.method||o.method||"GET";if(/^(delete|get|head|options|post|put)$/i.test(u)&&(u=u.toUpperCase()),!mt(a)&&"data"in a&&Ps(),(a.body!=null||mt(o)&&o.body!==null)&&(u==="GET"||u==="HEAD"))throw new TypeError("Request with GET/HEAD method cannot have body");const m=a.body?a.body:mt(o)&&o.body!==null?Kr(o):null;super(m,{size:a.size||o.size||0});const h=new ae(a.headers||o.headers||{});if(m!==null&&!h.has("Content-Type")){const w=Io(m,this);w&&h.set("Content-Type",w);}let S=mt(o)?o.signal:null;if("signal"in a&&(S=a.signal),S!=null&&!fs(S))throw new TypeError("Expected signal to be an instanceof AbortSignal or EventTarget");let E=a.referrer==null?o.referrer:a.referrer;if(E==="")E="no-referrer";else if(E){const w=new URL(E);E=/^about:(\/\/)?client$/.test(w)?"client":w;}else E=void 0;this[j]={method:u,redirect:a.redirect||o.redirect||"follow",headers:h,parsedURL:l,signal:S,referrer:E},this.follow=a.follow===void 0?o.follow===void 0?20:o.follow:a.follow,this.compress=a.compress===void 0?o.compress===void 0?true:o.compress:a.compress,this.counter=a.counter||o.counter||0,this.agent=a.agent||o.agent,this.highWaterMark=a.highWaterMark||o.highWaterMark||16384,this.insecureHTTPParser=a.insecureHTTPParser||o.insecureHTTPParser||false,this.referrerPolicy=a.referrerPolicy||o.referrerPolicy||"";}get method(){return this[j].method}get url(){return format$1(this[j].parsedURL)}get headers(){return this[j].headers}get redirect(){return this[j].redirect}get signal(){return this[j].signal}get referrer(){if(this[j].referrer==="no-referrer")return "";if(this[j].referrer==="client")return "about:client";if(this[j].referrer)return this[j].referrer.toString()}get referrerPolicy(){return this[j].referrerPolicy}set referrerPolicy(o){this[j].referrerPolicy=ws(o);}clone(){return new Xe(this)}get[Symbol.toStringTag](){return "Request"}}Object.defineProperties(Xe.prototype,{method:{enumerable:true},url:{enumerable:true},headers:{enumerable:true},redirect:{enumerable:true},clone:{enumerable:true},signal:{enumerable:true},referrer:{enumerable:true},referrerPolicy:{enumerable:true}});const Es=n$3(i=>{const{parsedURL:o}=i[j],a=new ae(i[j].headers);a.has("Accept")||a.set("Accept","*/*");let l=null;if(i.body===null&&/^(post|put)$/i.test(i.method)&&(l="0"),i.body!==null){const S=bs(i);typeof S=="number"&&!Number.isNaN(S)&&(l=String(S));}l&&a.set("Content-Length",l),i.referrerPolicy===""&&(i.referrerPolicy=Ss),i.referrer&&i.referrer!=="no-referrer"?i[j].referrer=Ts(i):i[j].referrer="no-referrer",i[j].referrer instanceof URL&&a.set("Referer",i.referrer),a.has("User-Agent")||a.set("User-Agent","node-fetch"),i.compress&&!a.has("Accept-Encoding")&&a.set("Accept-Encoding","gzip, deflate, br");let{agent:u}=i;typeof u=="function"&&(u=u(o));const m=_s(o),h={path:o.pathname+m,method:i.method,headers:a[Symbol.for("nodejs.util.inspect.custom")](),insecureHTTPParser:i.insecureHTTPParser,agent:u};return {parsedURL:o,options:h}},"getNodeRequestOptions");class jo extends Kt{static{n$3(this,"AbortError");}constructor(o,a="aborted"){super(o,a);}}/*! node-domexception. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */var en,Lo;function vs(){if(Lo)return en;if(Lo=1,!globalThis.DOMException)try{const{MessageChannel:i}=require("worker_threads"),o=new i().port1,a=new ArrayBuffer;o.postMessage(a,[a,a]);}catch(i){i.constructor.name==="DOMException"&&(globalThis.DOMException=i.constructor);}return en=globalThis.DOMException,en}n$3(vs,"requireNodeDomexception");var As=vs();const Bs=f$1(As),{stat:tn}=promises;n$3((i,o)=>Do(statSync(i),i,o),"blobFromSync");n$3((i,o)=>tn(i).then(a=>Do(a,i,o)),"blobFrom");n$3((i,o)=>tn(i).then(a=>$o(a,i,o)),"fileFrom");n$3((i,o)=>$o(statSync(i),i,o),"fileFromSync");const Do=n$3((i,o,a="")=>new Ze([new ir({path:o,size:i.size,lastModified:i.mtimeMs,start:0})],{type:a}),"fromBlob"),$o=n$3((i,o,a="")=>new Yr([new ir({path:o,size:i.size,lastModified:i.mtimeMs,start:0})],basename$1(o),{type:a,lastModified:i.mtimeMs}),"fromFile");class ir{static{n$3(this,"BlobDataItem");}#e;#t;constructor(o){this.#e=o.path,this.#t=o.start,this.size=o.size,this.lastModified=o.lastModified;}slice(o,a){return new ir({path:this.#e,lastModified:this.lastModified,size:a-o,start:this.#t+o})}async*stream(){const{mtimeMs:o}=await tn(this.#e);if(o>this.lastModified)throw new Bs("The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.","NotReadableError");yield*createReadStream(this.#e,{start:this.#t,end:this.#t+this.size-1});}get[Symbol.toStringTag](){return "Blob"}}const Is=new Set(["data:","http:","https:"]);async function Mo(i,o){return new Promise((a,l)=>{const u=new Xe(i,o),{parsedURL:m,options:h}=Es(u);if(!Is.has(m.protocol))throw new TypeError(`node-fetch cannot load ${i}. URL scheme "${m.protocol.replace(/:$/,"")}" is not supported.`);if(m.protocol==="data:"){const g=ts(u.url),V=new H(g,{headers:{"Content-Type":g.typeFull}});a(V);return}const S=(m.protocol==="https:"?Qa:ft).request,{signal:E}=u;let w=null;const A=n$3(()=>{const g=new jo("The operation was aborted.");l(g),u.body&&u.body instanceof ie.Readable&&u.body.destroy(g),!(!w||!w.body)&&w.body.emit("error",g);},"abort");if(E&&E.aborted){A();return}const T=n$3(()=>{A(),q();},"abortAndFinalize"),b=S(m.toString(),h);E&&E.addEventListener("abort",T);const q=n$3(()=>{b.abort(),E&&E.removeEventListener("abort",T);},"finalize");b.on("error",g=>{l(new te(`request to ${u.url} failed, reason: ${g.message}`,"system",g)),q();}),Fs(b,g=>{w&&w.body&&w.body.destroy(g);}),process.version<"v14"&&b.on("socket",g=>{let V;g.prependListener("end",()=>{V=g._eventsCount;}),g.prependListener("close",I=>{if(w&&V<g._eventsCount&&!I){const F=new Error("Premature close");F.code="ERR_STREAM_PREMATURE_CLOSE",w.body.emit("error",F);}});}),b.on("response",g=>{b.setTimeout(0);const V=ys(g.rawHeaders);if(Xr(g.statusCode)){const O=V.get("Location");let z=null;try{z=O===null?null:new URL(O,u.url);}catch{if(u.redirect!=="manual"){l(new te(`uri requested responds with an invalid redirect URL: ${O}`,"invalid-redirect")),q();return}}switch(u.redirect){case "error":l(new te(`uri requested responds with a redirect, redirect mode is set to error: ${u.url}`,"no-redirect")),q();return;case "manual":break;case "follow":{if(z===null)break;if(u.counter>=u.follow){l(new te(`maximum redirect reached at: ${u.url}`,"max-redirect")),q();return}const $={headers:new ae(u.headers),follow:u.follow,counter:u.counter+1,agent:u.agent,compress:u.compress,method:u.method,body:Kr(u),signal:u.signal,size:u.size,referrer:u.referrer,referrerPolicy:u.referrerPolicy};if(!cs(u.url,z)||!ds(u.url,z))for(const pt of ["authorization","www-authenticate","cookie","cookie2"])$.headers.delete(pt);if(g.statusCode!==303&&u.body&&o.body instanceof ie.Readable){l(new te("Cannot follow redirect with body being a readable stream","unsupported-redirect")),q();return}(g.statusCode===303||(g.statusCode===301||g.statusCode===302)&&u.method==="POST")&&($.method="GET",$.body=void 0,$.headers.delete("content-length"));const M=Cs(V);M&&($.referrerPolicy=M),a(Mo(new Xe(z,$))),q();return}default:return l(new TypeError(`Redirect option '${u.redirect}' is not a valid value of RequestRedirect`))}}E&&g.once("end",()=>{E.removeEventListener("abort",T);});let I=pipeline(g,new PassThrough,O=>{O&&l(O);});process.version<"v12.10"&&g.on("aborted",T);const F={url:u.url,status:g.statusCode,statusText:g.statusMessage,headers:V,size:u.size,counter:u.counter,highWaterMark:u.highWaterMark},Q=V.get("Content-Encoding");if(!u.compress||u.method==="HEAD"||Q===null||g.statusCode===204||g.statusCode===304){w=new H(I,F),a(w);return}const se={flush:Ye.Z_SYNC_FLUSH,finishFlush:Ye.Z_SYNC_FLUSH};if(Q==="gzip"||Q==="x-gzip"){I=pipeline(I,Ye.createGunzip(se),O=>{O&&l(O);}),w=new H(I,F),a(w);return}if(Q==="deflate"||Q==="x-deflate"){const O=pipeline(g,new PassThrough,z=>{z&&l(z);});O.once("data",z=>{(z[0]&15)===8?I=pipeline(I,Ye.createInflate(),$=>{$&&l($);}):I=pipeline(I,Ye.createInflateRaw(),$=>{$&&l($);}),w=new H(I,F),a(w);}),O.once("end",()=>{w||(w=new H(I,F),a(w));});return}if(Q==="br"){I=pipeline(I,Ye.createBrotliDecompress(),O=>{O&&l(O);}),w=new H(I,F),a(w);return}w=new H(I,F),a(w);}),ps(b,u).catch(l);})}n$3(Mo,"fetch$1");function Fs(i,o){const a=Buffer$1.from(`0\r
\r
`);let l=false,u=false,m;i.on("response",h=>{const{headers:S}=h;l=S["transfer-encoding"]==="chunked"&&!S["content-length"];}),i.on("socket",h=>{const S=n$3(()=>{if(l&&!u){const w=new Error("Premature close");w.code="ERR_STREAM_PREMATURE_CLOSE",o(w);}},"onSocketClose"),E=n$3(w=>{u=Buffer$1.compare(w.slice(-5),a)===0,!u&&m&&(u=Buffer$1.compare(m.slice(-3),a.slice(0,3))===0&&Buffer$1.compare(w.slice(-2),a.slice(3))===0),m=w;},"onData");h.prependListener("close",S),h.on("data",E),i.on("close",()=>{h.removeListener("close",S),h.removeListener("data",E);});});}n$3(Fs,"fixResponseChunkedTransferBadEnding");const Uo=new WeakMap,rn=new WeakMap;function k(i){const o=Uo.get(i);return console.assert(o!=null,"'this' is expected an Event object, but got",i),o}n$3(k,"pd");function xo(i){if(i.passiveListener!=null){typeof console<"u"&&typeof console.error=="function"&&console.error("Unable to preventDefault inside passive event listener invocation.",i.passiveListener);return}i.event.cancelable&&(i.canceled=true,typeof i.event.preventDefault=="function"&&i.event.preventDefault());}n$3(xo,"setCancelFlag");function Je(i,o){Uo.set(this,{eventTarget:i,event:o,eventPhase:2,currentTarget:i,canceled:false,stopped:false,immediateStopped:false,passiveListener:null,timeStamp:o.timeStamp||Date.now()}),Object.defineProperty(this,"isTrusted",{value:false,enumerable:true});const a=Object.keys(o);for(let l=0;l<a.length;++l){const u=a[l];u in this||Object.defineProperty(this,u,No(u));}}n$3(Je,"Event"),Je.prototype={get type(){return k(this).event.type},get target(){return k(this).eventTarget},get currentTarget(){return k(this).currentTarget},composedPath(){const i=k(this).currentTarget;return i==null?[]:[i]},get NONE(){return 0},get CAPTURING_PHASE(){return 1},get AT_TARGET(){return 2},get BUBBLING_PHASE(){return 3},get eventPhase(){return k(this).eventPhase},stopPropagation(){const i=k(this);i.stopped=true,typeof i.event.stopPropagation=="function"&&i.event.stopPropagation();},stopImmediatePropagation(){const i=k(this);i.stopped=true,i.immediateStopped=true,typeof i.event.stopImmediatePropagation=="function"&&i.event.stopImmediatePropagation();},get bubbles(){return !!k(this).event.bubbles},get cancelable(){return !!k(this).event.cancelable},preventDefault(){xo(k(this));},get defaultPrevented(){return k(this).canceled},get composed(){return !!k(this).event.composed},get timeStamp(){return k(this).timeStamp},get srcElement(){return k(this).eventTarget},get cancelBubble(){return k(this).stopped},set cancelBubble(i){if(!i)return;const o=k(this);o.stopped=true,typeof o.event.cancelBubble=="boolean"&&(o.event.cancelBubble=true);},get returnValue(){return !k(this).canceled},set returnValue(i){i||xo(k(this));},initEvent(){}},Object.defineProperty(Je.prototype,"constructor",{value:Je,configurable:true,writable:true}),typeof window<"u"&&typeof window.Event<"u"&&(Object.setPrototypeOf(Je.prototype,window.Event.prototype),rn.set(window.Event.prototype,Je));function No(i){return {get(){return k(this).event[i]},set(o){k(this).event[i]=o;},configurable:true,enumerable:true}}n$3(No,"defineRedirectDescriptor");function zs(i){return {value(){const o=k(this).event;return o[i].apply(o,arguments)},configurable:true,enumerable:true}}n$3(zs,"defineCallDescriptor");function js(i,o){const a=Object.keys(o);if(a.length===0)return i;function l(u,m){i.call(this,u,m);}n$3(l,"CustomEvent"),l.prototype=Object.create(i.prototype,{constructor:{value:l,configurable:true,writable:true}});for(let u=0;u<a.length;++u){const m=a[u];if(!(m in i.prototype)){const S=typeof Object.getOwnPropertyDescriptor(o,m).value=="function";Object.defineProperty(l.prototype,m,S?zs(m):No(m));}}return l}n$3(js,"defineWrapper");function Ho(i){if(i==null||i===Object.prototype)return Je;let o=rn.get(i);return o==null&&(o=js(Ho(Object.getPrototypeOf(i)),i),rn.set(i,o)),o}n$3(Ho,"getWrapper");function Ls(i,o){const a=Ho(Object.getPrototypeOf(o));return new a(i,o)}n$3(Ls,"wrapEvent");function Ds(i){return k(i).immediateStopped}n$3(Ds,"isStopped");function $s(i,o){k(i).eventPhase=o;}n$3($s,"setEventPhase");function Ms(i,o){k(i).currentTarget=o;}n$3(Ms,"setCurrentTarget");function Vo(i,o){k(i).passiveListener=o;}n$3(Vo,"setPassiveListener");const Qo=new WeakMap,Yo=1,Go=2,tr=3;function rr(i){return i!==null&&typeof i=="object"}n$3(rr,"isObject");function bt(i){const o=Qo.get(i);if(o==null)throw new TypeError("'this' is expected an EventTarget object, but got another value.");return o}n$3(bt,"getListeners");function Us(i){return {get(){let a=bt(this).get(i);for(;a!=null;){if(a.listenerType===tr)return a.listener;a=a.next;}return null},set(o){typeof o!="function"&&!rr(o)&&(o=null);const a=bt(this);let l=null,u=a.get(i);for(;u!=null;)u.listenerType===tr?l!==null?l.next=u.next:u.next!==null?a.set(i,u.next):a.delete(i):l=u,u=u.next;if(o!==null){const m={listener:o,listenerType:tr,passive:false,once:false,next:null};l===null?a.set(i,m):l.next=m;}},configurable:true,enumerable:true}}n$3(Us,"defineEventAttributeDescriptor");function Zo(i,o){Object.defineProperty(i,`on${o}`,Us(o));}n$3(Zo,"defineEventAttribute");function Ko(i){function o(){pe.call(this);}n$3(o,"CustomEventTarget"),o.prototype=Object.create(pe.prototype,{constructor:{value:o,configurable:true,writable:true}});for(let a=0;a<i.length;++a)Zo(o.prototype,i[a]);return o}n$3(Ko,"defineCustomEventTarget");function pe(){if(this instanceof pe){Qo.set(this,new Map);return}if(arguments.length===1&&Array.isArray(arguments[0]))return Ko(arguments[0]);if(arguments.length>0){const i=new Array(arguments.length);for(let o=0;o<arguments.length;++o)i[o]=arguments[o];return Ko(i)}throw new TypeError("Cannot call a class as a function")}n$3(pe,"EventTarget"),pe.prototype={addEventListener(i,o,a){if(o==null)return;if(typeof o!="function"&&!rr(o))throw new TypeError("'listener' should be a function or an object.");const l=bt(this),u=rr(a),h=(u?!!a.capture:!!a)?Yo:Go,S={listener:o,listenerType:h,passive:u&&!!a.passive,once:u&&!!a.once,next:null};let E=l.get(i);if(E===void 0){l.set(i,S);return}let w=null;for(;E!=null;){if(E.listener===o&&E.listenerType===h)return;w=E,E=E.next;}w.next=S;},removeEventListener(i,o,a){if(o==null)return;const l=bt(this),m=(rr(a)?!!a.capture:!!a)?Yo:Go;let h=null,S=l.get(i);for(;S!=null;){if(S.listener===o&&S.listenerType===m){h!==null?h.next=S.next:S.next!==null?l.set(i,S.next):l.delete(i);return}h=S,S=S.next;}},dispatchEvent(i){if(i==null||typeof i.type!="string")throw new TypeError('"event.type" should be a string.');const o=bt(this),a=i.type;let l=o.get(a);if(l==null)return  true;const u=Ls(this,i);let m=null;for(;l!=null;){if(l.once?m!==null?m.next=l.next:l.next!==null?o.set(a,l.next):o.delete(a):m=l,Vo(u,l.passive?l.listener:null),typeof l.listener=="function")try{l.listener.call(this,u);}catch(h){typeof console<"u"&&typeof console.error=="function"&&console.error(h);}else l.listenerType!==tr&&typeof l.listener.handleEvent=="function"&&l.listener.handleEvent(u);if(Ds(u))break;l=l.next;}return Vo(u,null),$s(u,0),Ms(u,null),!u.defaultPrevented}},Object.defineProperty(pe.prototype,"constructor",{value:pe,configurable:true,writable:true}),typeof window<"u"&&typeof window.EventTarget<"u"&&Object.setPrototypeOf(pe.prototype,window.EventTarget.prototype);class nr extends pe{static{n$3(this,"AbortSignal");}constructor(){throw super(),new TypeError("AbortSignal cannot be constructed directly")}get aborted(){const o=or.get(this);if(typeof o!="boolean")throw new TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this===null?"null":typeof this}`);return o}}Zo(nr.prototype,"abort");function xs(){const i=Object.create(nr.prototype);return pe.call(i),or.set(i,false),i}n$3(xs,"createAbortSignal");function Ns(i){or.get(i)===false&&(or.set(i,true),i.dispatchEvent({type:"abort"}));}n$3(Ns,"abortSignal");const or=new WeakMap;Object.defineProperties(nr.prototype,{aborted:{enumerable:true}}),typeof Symbol=="function"&&typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(nr.prototype,Symbol.toStringTag,{configurable:true,value:"AbortSignal"});let nn=class{static{n$3(this,"AbortController");}constructor(){Jo.set(this,xs());}get signal(){return Xo(this)}abort(){Ns(Xo(this));}};const Jo=new WeakMap;function Xo(i){const o=Jo.get(i);if(o==null)throw new TypeError(`Expected 'this' to be an 'AbortController' object, but got ${i===null?"null":typeof i}`);return o}n$3(Xo,"getSignal"),Object.defineProperties(nn.prototype,{signal:{enumerable:true},abort:{enumerable:true}}),typeof Symbol=="function"&&typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(nn.prototype,Symbol.toStringTag,{configurable:true,value:"AbortController"});var Hs=Object.defineProperty,Vs=n$3((i,o)=>Hs(i,"name",{value:o,configurable:true}),"e");const ei=Mo;ti();function ti(){!globalThis.process?.versions?.node&&!globalThis.process?.env?.DISABLE_NODE_FETCH_NATIVE_WARN&&console.warn("[node-fetch-native] Node.js compatible build of `node-fetch-native` is being used in a non-Node.js environment. Please make sure you are using proper export conditions or report this issue to https://github.com/unjs/node-fetch-native. You can set `process.env.DISABLE_NODE_FETCH_NATIVE_WARN` to disable this warning.");}n$3(ti,"s"),Vs(ti,"checkNodeEnvironment");

const o$3=!!globalThis.process?.env?.FORCE_NODE_FETCH,r$1=!o$3&&globalThis.fetch||ei,n$2=!o$3&&globalThis.Headers||ae,T$1=!o$3&&globalThis.AbortController||nn;

const suspectProtoRx = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/;
const suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
const JsonSigRx = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function jsonParseTransform(key, value) {
  if (key === "__proto__" || key === "constructor" && value && typeof value === "object" && "prototype" in value) {
    warnKeyDropped(key);
    return;
  }
  return value;
}
function warnKeyDropped(key) {
  console.warn(`[destr] Dropping "${key}" key to prevent prototype pollution.`);
}
function destr(value, options = {}) {
  if (typeof value !== "string") {
    return value;
  }
  if (value[0] === '"' && value[value.length - 1] === '"' && value.indexOf("\\") === -1) {
    return value.slice(1, -1);
  }
  const _value = value.trim();
  if (_value.length <= 9) {
    switch (_value.toLowerCase()) {
      case "true": {
        return true;
      }
      case "false": {
        return false;
      }
      case "undefined": {
        return void 0;
      }
      case "null": {
        return null;
      }
      case "nan": {
        return Number.NaN;
      }
      case "infinity": {
        return Number.POSITIVE_INFINITY;
      }
      case "-infinity": {
        return Number.NEGATIVE_INFINITY;
      }
    }
  }
  if (!JsonSigRx.test(value)) {
    if (options.strict) {
      throw new SyntaxError("[destr] Invalid JSON");
    }
    return value;
  }
  try {
    if (suspectProtoRx.test(value) || suspectConstructorRx.test(value)) {
      if (options.strict) {
        throw new Error("[destr] Possible prototype pollution");
      }
      return JSON.parse(value, jsonParseTransform);
    }
    return JSON.parse(value);
  } catch (error) {
    if (options.strict) {
      throw error;
    }
    return value;
  }
}

class FetchError extends Error {
  constructor(message, opts) {
    super(message, opts);
    this.name = "FetchError";
    if (opts?.cause && !this.cause) {
      this.cause = opts.cause;
    }
  }
}
function createFetchError(ctx) {
  const errorMessage = ctx.error?.message || ctx.error?.toString() || "";
  const method = ctx.request?.method || ctx.options?.method || "GET";
  const url = ctx.request?.url || String(ctx.request) || "/";
  const requestStr = `[${method}] ${JSON.stringify(url)}`;
  const statusStr = ctx.response ? `${ctx.response.status} ${ctx.response.statusText}` : "<no response>";
  const message = `${requestStr}: ${statusStr}${errorMessage ? ` ${errorMessage}` : ""}`;
  const fetchError = new FetchError(
    message,
    ctx.error ? { cause: ctx.error } : void 0
  );
  for (const key of ["request", "options", "response"]) {
    Object.defineProperty(fetchError, key, {
      get() {
        return ctx[key];
      }
    });
  }
  for (const [key, refKey] of [
    ["data", "_data"],
    ["status", "status"],
    ["statusCode", "status"],
    ["statusText", "statusText"],
    ["statusMessage", "statusText"]
  ]) {
    Object.defineProperty(fetchError, key, {
      get() {
        return ctx.response && ctx.response[refKey];
      }
    });
  }
  return fetchError;
}

const payloadMethods = new Set(
  Object.freeze(["PATCH", "POST", "PUT", "DELETE"])
);
function isPayloadMethod(method = "GET") {
  return payloadMethods.has(method.toUpperCase());
}
function isJSONSerializable(value) {
  if (value === void 0) {
    return false;
  }
  const t = typeof value;
  if (t === "string" || t === "number" || t === "boolean" || t === null) {
    return true;
  }
  if (t !== "object") {
    return false;
  }
  if (Array.isArray(value)) {
    return true;
  }
  if (value.buffer) {
    return false;
  }
  return value.constructor && value.constructor.name === "Object" || typeof value.toJSON === "function";
}
const textTypes = /* @__PURE__ */ new Set([
  "image/svg",
  "application/xml",
  "application/xhtml",
  "application/html"
]);
const JSON_RE = /^application\/(?:[\w!#$%&*.^`~-]*\+)?json(;.+)?$/i;
function detectResponseType(_contentType = "") {
  if (!_contentType) {
    return "json";
  }
  const contentType = _contentType.split(";").shift() || "";
  if (JSON_RE.test(contentType)) {
    return "json";
  }
  if (textTypes.has(contentType) || contentType.startsWith("text/")) {
    return "text";
  }
  return "blob";
}
function resolveFetchOptions(request, input, defaults, Headers) {
  const headers = mergeHeaders(
    input?.headers ?? request?.headers,
    defaults?.headers,
    Headers
  );
  let query;
  if (defaults?.query || defaults?.params || input?.params || input?.query) {
    query = {
      ...defaults?.params,
      ...defaults?.query,
      ...input?.params,
      ...input?.query
    };
  }
  return {
    ...defaults,
    ...input,
    query,
    params: query,
    headers
  };
}
function mergeHeaders(input, defaults, Headers) {
  if (!defaults) {
    return new Headers(input);
  }
  const headers = new Headers(defaults);
  if (input) {
    for (const [key, value] of Symbol.iterator in input || Array.isArray(input) ? input : new Headers(input)) {
      headers.set(key, value);
    }
  }
  return headers;
}
async function callHooks(context, hooks) {
  if (hooks) {
    if (Array.isArray(hooks)) {
      for (const hook of hooks) {
        await hook(context);
      }
    } else {
      await hooks(context);
    }
  }
}

const retryStatusCodes = /* @__PURE__ */ new Set([
  408,
  // Request Timeout
  409,
  // Conflict
  425,
  // Too Early (Experimental)
  429,
  // Too Many Requests
  500,
  // Internal Server Error
  502,
  // Bad Gateway
  503,
  // Service Unavailable
  504
  // Gateway Timeout
]);
const nullBodyResponses = /* @__PURE__ */ new Set([101, 204, 205, 304]);
function createFetch(globalOptions = {}) {
  const {
    fetch = globalThis.fetch,
    Headers = globalThis.Headers,
    AbortController = globalThis.AbortController
  } = globalOptions;
  async function onError(context) {
    const isAbort = context.error && context.error.name === "AbortError" && !context.options.timeout || false;
    if (context.options.retry !== false && !isAbort) {
      let retries;
      if (typeof context.options.retry === "number") {
        retries = context.options.retry;
      } else {
        retries = isPayloadMethod(context.options.method) ? 0 : 1;
      }
      const responseCode = context.response && context.response.status || 500;
      if (retries > 0 && (Array.isArray(context.options.retryStatusCodes) ? context.options.retryStatusCodes.includes(responseCode) : retryStatusCodes.has(responseCode))) {
        const retryDelay = typeof context.options.retryDelay === "function" ? context.options.retryDelay(context) : context.options.retryDelay || 0;
        if (retryDelay > 0) {
          await new Promise((resolve) => setTimeout(resolve, retryDelay));
        }
        return $fetchRaw(context.request, {
          ...context.options,
          retry: retries - 1
        });
      }
    }
    const error = createFetchError(context);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(error, $fetchRaw);
    }
    throw error;
  }
  const $fetchRaw = async function $fetchRaw2(_request, _options = {}) {
    const context = {
      request: _request,
      options: resolveFetchOptions(
        _request,
        _options,
        globalOptions.defaults,
        Headers
      ),
      response: void 0,
      error: void 0
    };
    if (context.options.method) {
      context.options.method = context.options.method.toUpperCase();
    }
    if (context.options.onRequest) {
      await callHooks(context, context.options.onRequest);
    }
    if (typeof context.request === "string") {
      if (context.options.baseURL) {
        context.request = withBase(context.request, context.options.baseURL);
      }
      if (context.options.query) {
        context.request = withQuery(context.request, context.options.query);
        delete context.options.query;
      }
      if ("query" in context.options) {
        delete context.options.query;
      }
      if ("params" in context.options) {
        delete context.options.params;
      }
    }
    if (context.options.body && isPayloadMethod(context.options.method)) {
      if (isJSONSerializable(context.options.body)) {
        context.options.body = typeof context.options.body === "string" ? context.options.body : JSON.stringify(context.options.body);
        context.options.headers = new Headers(context.options.headers || {});
        if (!context.options.headers.has("content-type")) {
          context.options.headers.set("content-type", "application/json");
        }
        if (!context.options.headers.has("accept")) {
          context.options.headers.set("accept", "application/json");
        }
      } else if (
        // ReadableStream Body
        "pipeTo" in context.options.body && typeof context.options.body.pipeTo === "function" || // Node.js Stream Body
        typeof context.options.body.pipe === "function"
      ) {
        if (!("duplex" in context.options)) {
          context.options.duplex = "half";
        }
      }
    }
    let abortTimeout;
    if (!context.options.signal && context.options.timeout) {
      const controller = new AbortController();
      abortTimeout = setTimeout(() => {
        const error = new Error(
          "[TimeoutError]: The operation was aborted due to timeout"
        );
        error.name = "TimeoutError";
        error.code = 23;
        controller.abort(error);
      }, context.options.timeout);
      context.options.signal = controller.signal;
    }
    try {
      context.response = await fetch(
        context.request,
        context.options
      );
    } catch (error) {
      context.error = error;
      if (context.options.onRequestError) {
        await callHooks(
          context,
          context.options.onRequestError
        );
      }
      return await onError(context);
    } finally {
      if (abortTimeout) {
        clearTimeout(abortTimeout);
      }
    }
    const hasBody = (context.response.body || // https://github.com/unjs/ofetch/issues/324
    // https://github.com/unjs/ofetch/issues/294
    // https://github.com/JakeChampion/fetch/issues/1454
    context.response._bodyInit) && !nullBodyResponses.has(context.response.status) && context.options.method !== "HEAD";
    if (hasBody) {
      const responseType = (context.options.parseResponse ? "json" : context.options.responseType) || detectResponseType(context.response.headers.get("content-type") || "");
      switch (responseType) {
        case "json": {
          const data = await context.response.text();
          const parseFunction = context.options.parseResponse || destr;
          context.response._data = parseFunction(data);
          break;
        }
        case "stream": {
          context.response._data = context.response.body || context.response._bodyInit;
          break;
        }
        default: {
          context.response._data = await context.response[responseType]();
        }
      }
    }
    if (context.options.onResponse) {
      await callHooks(
        context,
        context.options.onResponse
      );
    }
    if (!context.options.ignoreResponseError && context.response.status >= 400 && context.response.status < 600) {
      if (context.options.onResponseError) {
        await callHooks(
          context,
          context.options.onResponseError
        );
      }
      return await onError(context);
    }
    return context.response;
  };
  const $fetch = async function $fetch2(request, options) {
    const r = await $fetchRaw(request, options);
    return r._data;
  };
  $fetch.raw = $fetchRaw;
  $fetch.native = (...args) => fetch(...args);
  $fetch.create = (defaultOptions = {}, customGlobalOptions = {}) => createFetch({
    ...globalOptions,
    ...customGlobalOptions,
    defaults: {
      ...globalOptions.defaults,
      ...customGlobalOptions.defaults,
      ...defaultOptions
    }
  });
  return $fetch;
}

function createNodeFetch() {
  const useKeepAlive = JSON.parse(process.env.FETCH_KEEP_ALIVE || "false");
  if (!useKeepAlive) {
    return r$1;
  }
  const agentOptions = { keepAlive: true };
  const httpAgent = new ft.Agent(agentOptions);
  const httpsAgent = new Qa.Agent(agentOptions);
  const nodeFetchOptions = {
    agent(parsedURL) {
      return parsedURL.protocol === "http:" ? httpAgent : httpsAgent;
    }
  };
  return function nodeFetchWithKeepAlive(input, init) {
    return r$1(input, { ...nodeFetchOptions, ...init });
  };
}
const fetch = globalThis.fetch ? (...args) => globalThis.fetch(...args) : createNodeFetch();
const Headers = globalThis.Headers || n$2;
const AbortController$1 = globalThis.AbortController || T$1;
const ofetch = createFetch({ fetch, Headers, AbortController: AbortController$1 });

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function getAugmentedNamespace(n) {
  if (Object.prototype.hasOwnProperty.call(n, '__esModule')) return n;
  var f = n.default;
	if (typeof f == "function") {
		var a = function a () {
			if (this instanceof a) {
        return Reflect.construct(f, arguments, this.constructor);
			}
			return f.apply(this, arguments);
		};
		a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

var picocolors = {exports: {}};

var hasRequiredPicocolors;

function requirePicocolors () {
	if (hasRequiredPicocolors) return picocolors.exports;
	hasRequiredPicocolors = 1;
	let p = process || {}, argv = p.argv || [], env = p.env || {};
	let isColorSupported =
		!(!!env.NO_COLOR || argv.includes("--no-color")) &&
		(!!env.FORCE_COLOR || argv.includes("--color") || p.platform === "win32" || ((p.stdout || {}).isTTY && env.TERM !== "dumb") || !!env.CI);

	let formatter = (open, close, replace = open) =>
		input => {
			let string = "" + input, index = string.indexOf(close, open.length);
			return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close
		};

	let replaceClose = (string, close, replace, index) => {
		let result = "", cursor = 0;
		do {
			result += string.substring(cursor, index) + replace;
			cursor = index + close.length;
			index = string.indexOf(close, cursor);
		} while (~index)
		return result + string.substring(cursor)
	};

	let createColors = (enabled = isColorSupported) => {
		let f = enabled ? formatter : () => String;
		return {
			isColorSupported: enabled,
			reset: f("\x1b[0m", "\x1b[0m"),
			bold: f("\x1b[1m", "\x1b[22m", "\x1b[22m\x1b[1m"),
			dim: f("\x1b[2m", "\x1b[22m", "\x1b[22m\x1b[2m"),
			italic: f("\x1b[3m", "\x1b[23m"),
			underline: f("\x1b[4m", "\x1b[24m"),
			inverse: f("\x1b[7m", "\x1b[27m"),
			hidden: f("\x1b[8m", "\x1b[28m"),
			strikethrough: f("\x1b[9m", "\x1b[29m"),

			black: f("\x1b[30m", "\x1b[39m"),
			red: f("\x1b[31m", "\x1b[39m"),
			green: f("\x1b[32m", "\x1b[39m"),
			yellow: f("\x1b[33m", "\x1b[39m"),
			blue: f("\x1b[34m", "\x1b[39m"),
			magenta: f("\x1b[35m", "\x1b[39m"),
			cyan: f("\x1b[36m", "\x1b[39m"),
			white: f("\x1b[37m", "\x1b[39m"),
			gray: f("\x1b[90m", "\x1b[39m"),

			bgBlack: f("\x1b[40m", "\x1b[49m"),
			bgRed: f("\x1b[41m", "\x1b[49m"),
			bgGreen: f("\x1b[42m", "\x1b[49m"),
			bgYellow: f("\x1b[43m", "\x1b[49m"),
			bgBlue: f("\x1b[44m", "\x1b[49m"),
			bgMagenta: f("\x1b[45m", "\x1b[49m"),
			bgCyan: f("\x1b[46m", "\x1b[49m"),
			bgWhite: f("\x1b[47m", "\x1b[49m"),

			blackBright: f("\x1b[90m", "\x1b[39m"),
			redBright: f("\x1b[91m", "\x1b[39m"),
			greenBright: f("\x1b[92m", "\x1b[39m"),
			yellowBright: f("\x1b[93m", "\x1b[39m"),
			blueBright: f("\x1b[94m", "\x1b[39m"),
			magentaBright: f("\x1b[95m", "\x1b[39m"),
			cyanBright: f("\x1b[96m", "\x1b[39m"),
			whiteBright: f("\x1b[97m", "\x1b[39m"),

			bgBlackBright: f("\x1b[100m", "\x1b[49m"),
			bgRedBright: f("\x1b[101m", "\x1b[49m"),
			bgGreenBright: f("\x1b[102m", "\x1b[49m"),
			bgYellowBright: f("\x1b[103m", "\x1b[49m"),
			bgBlueBright: f("\x1b[104m", "\x1b[49m"),
			bgMagentaBright: f("\x1b[105m", "\x1b[49m"),
			bgCyanBright: f("\x1b[106m", "\x1b[49m"),
			bgWhiteBright: f("\x1b[107m", "\x1b[49m"),
		}
	};

	picocolors.exports = createColors();
	picocolors.exports.createColors = createColors;
	return picocolors.exports;
}

var picocolorsExports = /*@__PURE__*/ requirePicocolors();
const colors$1 = /*@__PURE__*/getDefaultExportFromCjs(picocolorsExports);

const BYTE_UNITS$1 = [
	'B',
	'kB',
	'MB',
	'GB',
	'TB',
	'PB',
	'EB',
	'ZB',
	'YB',
];

const BIBYTE_UNITS$1 = [
	'B',
	'KiB',
	'MiB',
	'GiB',
	'TiB',
	'PiB',
	'EiB',
	'ZiB',
	'YiB',
];

const BIT_UNITS$1 = [
	'b',
	'kbit',
	'Mbit',
	'Gbit',
	'Tbit',
	'Pbit',
	'Ebit',
	'Zbit',
	'Ybit',
];

const BIBIT_UNITS$1 = [
	'b',
	'kibit',
	'Mibit',
	'Gibit',
	'Tibit',
	'Pibit',
	'Eibit',
	'Zibit',
	'Yibit',
];

/*
Formats the given number using `Number#toLocaleString`.
- If locale is a string, the value is expected to be a locale-key (for example: `de`).
- If locale is true, the system default locale is used for translation.
- If no value for locale is specified, the number is returned unmodified.
*/
const toLocaleString$1 = (number, locale, options) => {
	let result = number;
	if (typeof locale === 'string' || Array.isArray(locale)) {
		result = number.toLocaleString(locale, options);
	} else if (locale === true || options !== undefined) {
		result = number.toLocaleString(undefined, options);
	}

	return result;
};

const log10 = numberOrBigInt => {
	if (typeof numberOrBigInt === 'number') {
		return Math.log10(numberOrBigInt);
	}

	const string = numberOrBigInt.toString(10);

	return string.length + Math.log10('0.' + string.slice(0, 15));
};

const log = numberOrBigInt => {
	if (typeof numberOrBigInt === 'number') {
		return Math.log(numberOrBigInt);
	}

	return log10(numberOrBigInt) * Math.log(10);
};

const divide = (numberOrBigInt, divisor) => {
	if (typeof numberOrBigInt === 'number') {
		return numberOrBigInt / divisor;
	}

	const integerPart = numberOrBigInt / BigInt(divisor);
	const remainder = numberOrBigInt % BigInt(divisor);
	return Number(integerPart) + (Number(remainder) / divisor);
};

function prettyBytes$1(number, options) {
	if (typeof number !== 'bigint' && !Number.isFinite(number)) {
		throw new TypeError(`Expected a finite number, got ${typeof number}: ${number}`);
	}

	options = {
		bits: false,
		binary: false,
		space: true,
		...options,
	};

	const UNITS = options.bits
		? (options.binary ? BIBIT_UNITS$1 : BIT_UNITS$1)
		: (options.binary ? BIBYTE_UNITS$1 : BYTE_UNITS$1);

	const separator = options.space ? ' ' : '';

	if (options.signed && (typeof number === 'number' ? number === 0 : number === 0n)) {
		return ` 0${separator}${UNITS[0]}`;
	}

	const isNegative = number < 0;
	const prefix = isNegative ? '-' : (options.signed ? '+' : '');

	if (isNegative) {
		number = -number;
	}

	let localeOptions;

	if (options.minimumFractionDigits !== undefined) {
		localeOptions = {minimumFractionDigits: options.minimumFractionDigits};
	}

	if (options.maximumFractionDigits !== undefined) {
		localeOptions = {maximumFractionDigits: options.maximumFractionDigits, ...localeOptions};
	}

	if (number < 1) {
		const numberString = toLocaleString$1(number, options.locale, localeOptions);
		return prefix + numberString + separator + UNITS[0];
	}

	const exponent = Math.min(Math.floor(options.binary ? log(number) / Math.log(1024) : log10(number) / 3), UNITS.length - 1);
	number = divide(number, (options.binary ? 1024 : 1000) ** exponent);

	if (!localeOptions) {
		number = number.toPrecision(3);
	}

	const numberString = toLocaleString$1(Number(number), options.locale, localeOptions);

	const unit = UNITS[exponent];

	return prefix + numberString + separator + unit;
}

var core = {};

var command = {};

var utils$2 = {};

var hasRequiredUtils$2;

function requireUtils$2 () {
	if (hasRequiredUtils$2) return utils$2;
	hasRequiredUtils$2 = 1;
	// We use any as a valid input type
	/* eslint-disable @typescript-eslint/no-explicit-any */
	Object.defineProperty(utils$2, "__esModule", { value: true });
	utils$2.toCommandProperties = utils$2.toCommandValue = void 0;
	/**
	 * Sanitizes an input into a string so it can be passed into issueCommand safely
	 * @param input input to sanitize into a string
	 */
	function toCommandValue(input) {
	    if (input === null || input === undefined) {
	        return '';
	    }
	    else if (typeof input === 'string' || input instanceof String) {
	        return input;
	    }
	    return JSON.stringify(input);
	}
	utils$2.toCommandValue = toCommandValue;
	/**
	 *
	 * @param annotationProperties
	 * @returns The command properties to send with the actual annotation command
	 * See IssueCommandProperties: https://github.com/actions/runner/blob/main/src/Runner.Worker/ActionCommandManager.cs#L646
	 */
	function toCommandProperties(annotationProperties) {
	    if (!Object.keys(annotationProperties).length) {
	        return {};
	    }
	    return {
	        title: annotationProperties.title,
	        file: annotationProperties.file,
	        line: annotationProperties.startLine,
	        endLine: annotationProperties.endLine,
	        col: annotationProperties.startColumn,
	        endColumn: annotationProperties.endColumn
	    };
	}
	utils$2.toCommandProperties = toCommandProperties;
	
	return utils$2;
}

var hasRequiredCommand;

function requireCommand () {
	if (hasRequiredCommand) return command;
	hasRequiredCommand = 1;
	var __createBinding = (command && command.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (command && command.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (command && command.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(command, "__esModule", { value: true });
	command.issue = command.issueCommand = void 0;
	const os = __importStar(require$$0);
	const utils_1 = requireUtils$2();
	/**
	 * Commands
	 *
	 * Command Format:
	 *   ::name key=value,key=value::message
	 *
	 * Examples:
	 *   ::warning::This is the message
	 *   ::set-env name=MY_VAR::some value
	 */
	function issueCommand(command, properties, message) {
	    const cmd = new Command(command, properties, message);
	    process.stdout.write(cmd.toString() + os.EOL);
	}
	command.issueCommand = issueCommand;
	function issue(name, message = '') {
	    issueCommand(name, {}, message);
	}
	command.issue = issue;
	const CMD_STRING = '::';
	class Command {
	    constructor(command, properties, message) {
	        if (!command) {
	            command = 'missing.command';
	        }
	        this.command = command;
	        this.properties = properties;
	        this.message = message;
	    }
	    toString() {
	        let cmdStr = CMD_STRING + this.command;
	        if (this.properties && Object.keys(this.properties).length > 0) {
	            cmdStr += ' ';
	            let first = true;
	            for (const key in this.properties) {
	                if (this.properties.hasOwnProperty(key)) {
	                    const val = this.properties[key];
	                    if (val) {
	                        if (first) {
	                            first = false;
	                        }
	                        else {
	                            cmdStr += ',';
	                        }
	                        cmdStr += `${key}=${escapeProperty(val)}`;
	                    }
	                }
	            }
	        }
	        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
	        return cmdStr;
	    }
	}
	function escapeData(s) {
	    return (0, utils_1.toCommandValue)(s)
	        .replace(/%/g, '%25')
	        .replace(/\r/g, '%0D')
	        .replace(/\n/g, '%0A');
	}
	function escapeProperty(s) {
	    return (0, utils_1.toCommandValue)(s)
	        .replace(/%/g, '%25')
	        .replace(/\r/g, '%0D')
	        .replace(/\n/g, '%0A')
	        .replace(/:/g, '%3A')
	        .replace(/,/g, '%2C');
	}
	
	return command;
}

var fileCommand = {};

var hasRequiredFileCommand;

function requireFileCommand () {
	if (hasRequiredFileCommand) return fileCommand;
	hasRequiredFileCommand = 1;
	// For internal use, subject to change.
	var __createBinding = (fileCommand && fileCommand.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (fileCommand && fileCommand.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (fileCommand && fileCommand.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(fileCommand, "__esModule", { value: true });
	fileCommand.prepareKeyValueMessage = fileCommand.issueFileCommand = void 0;
	// We use any as a valid input type
	/* eslint-disable @typescript-eslint/no-explicit-any */
	const crypto = __importStar(require$$3);
	const fs = __importStar(require$$0$1);
	const os = __importStar(require$$0);
	const utils_1 = requireUtils$2();
	function issueFileCommand(command, message) {
	    const filePath = process.env[`GITHUB_${command}`];
	    if (!filePath) {
	        throw new Error(`Unable to find environment variable for file command ${command}`);
	    }
	    if (!fs.existsSync(filePath)) {
	        throw new Error(`Missing file at path: ${filePath}`);
	    }
	    fs.appendFileSync(filePath, `${(0, utils_1.toCommandValue)(message)}${os.EOL}`, {
	        encoding: 'utf8'
	    });
	}
	fileCommand.issueFileCommand = issueFileCommand;
	function prepareKeyValueMessage(key, value) {
	    const delimiter = `ghadelimiter_${crypto.randomUUID()}`;
	    const convertedValue = (0, utils_1.toCommandValue)(value);
	    // These should realistically never happen, but just in case someone finds a
	    // way to exploit uuid generation let's not allow keys or values that contain
	    // the delimiter.
	    if (key.includes(delimiter)) {
	        throw new Error(`Unexpected input: name should not contain the delimiter "${delimiter}"`);
	    }
	    if (convertedValue.includes(delimiter)) {
	        throw new Error(`Unexpected input: value should not contain the delimiter "${delimiter}"`);
	    }
	    return `${key}<<${delimiter}${os.EOL}${convertedValue}${os.EOL}${delimiter}`;
	}
	fileCommand.prepareKeyValueMessage = prepareKeyValueMessage;
	
	return fileCommand;
}

var oidcUtils = {};

var lib = {};

var proxy = {};

var hasRequiredProxy;

function requireProxy () {
	if (hasRequiredProxy) return proxy;
	hasRequiredProxy = 1;
	Object.defineProperty(proxy, "__esModule", { value: true });
	proxy.checkBypass = proxy.getProxyUrl = void 0;
	function getProxyUrl(reqUrl) {
	    const usingSsl = reqUrl.protocol === 'https:';
	    if (checkBypass(reqUrl)) {
	        return undefined;
	    }
	    const proxyVar = (() => {
	        if (usingSsl) {
	            return process.env['https_proxy'] || process.env['HTTPS_PROXY'];
	        }
	        else {
	            return process.env['http_proxy'] || process.env['HTTP_PROXY'];
	        }
	    })();
	    if (proxyVar) {
	        try {
	            return new DecodedURL(proxyVar);
	        }
	        catch (_a) {
	            if (!proxyVar.startsWith('http://') && !proxyVar.startsWith('https://'))
	                return new DecodedURL(`http://${proxyVar}`);
	        }
	    }
	    else {
	        return undefined;
	    }
	}
	proxy.getProxyUrl = getProxyUrl;
	function checkBypass(reqUrl) {
	    if (!reqUrl.hostname) {
	        return false;
	    }
	    const reqHost = reqUrl.hostname;
	    if (isLoopbackAddress(reqHost)) {
	        return true;
	    }
	    const noProxy = process.env['no_proxy'] || process.env['NO_PROXY'] || '';
	    if (!noProxy) {
	        return false;
	    }
	    // Determine the request port
	    let reqPort;
	    if (reqUrl.port) {
	        reqPort = Number(reqUrl.port);
	    }
	    else if (reqUrl.protocol === 'http:') {
	        reqPort = 80;
	    }
	    else if (reqUrl.protocol === 'https:') {
	        reqPort = 443;
	    }
	    // Format the request hostname and hostname with port
	    const upperReqHosts = [reqUrl.hostname.toUpperCase()];
	    if (typeof reqPort === 'number') {
	        upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
	    }
	    // Compare request host against noproxy
	    for (const upperNoProxyItem of noProxy
	        .split(',')
	        .map(x => x.trim().toUpperCase())
	        .filter(x => x)) {
	        if (upperNoProxyItem === '*' ||
	            upperReqHosts.some(x => x === upperNoProxyItem ||
	                x.endsWith(`.${upperNoProxyItem}`) ||
	                (upperNoProxyItem.startsWith('.') &&
	                    x.endsWith(`${upperNoProxyItem}`)))) {
	            return true;
	        }
	    }
	    return false;
	}
	proxy.checkBypass = checkBypass;
	function isLoopbackAddress(host) {
	    const hostLower = host.toLowerCase();
	    return (hostLower === 'localhost' ||
	        hostLower.startsWith('127.') ||
	        hostLower.startsWith('[::1]') ||
	        hostLower.startsWith('[0:0:0:0:0:0:0:1]'));
	}
	class DecodedURL extends URL {
	    constructor(url, base) {
	        super(url, base);
	        this._decodedUsername = decodeURIComponent(super.username);
	        this._decodedPassword = decodeURIComponent(super.password);
	    }
	    get username() {
	        return this._decodedUsername;
	    }
	    get password() {
	        return this._decodedPassword;
	    }
	}
	
	return proxy;
}

var tunnel$1 = {};

var hasRequiredTunnel$1;

function requireTunnel$1 () {
	if (hasRequiredTunnel$1) return tunnel$1;
	hasRequiredTunnel$1 = 1;
	var tls = require$$4$1;
	var http = require$$2;
	var https = require$$1;
	var events = require$$0$3;
	var util = require$$0$2;


	tunnel$1.httpOverHttp = httpOverHttp;
	tunnel$1.httpsOverHttp = httpsOverHttp;
	tunnel$1.httpOverHttps = httpOverHttps;
	tunnel$1.httpsOverHttps = httpsOverHttps;


	function httpOverHttp(options) {
	  var agent = new TunnelingAgent(options);
	  agent.request = http.request;
	  return agent;
	}

	function httpsOverHttp(options) {
	  var agent = new TunnelingAgent(options);
	  agent.request = http.request;
	  agent.createSocket = createSecureSocket;
	  agent.defaultPort = 443;
	  return agent;
	}

	function httpOverHttps(options) {
	  var agent = new TunnelingAgent(options);
	  agent.request = https.request;
	  return agent;
	}

	function httpsOverHttps(options) {
	  var agent = new TunnelingAgent(options);
	  agent.request = https.request;
	  agent.createSocket = createSecureSocket;
	  agent.defaultPort = 443;
	  return agent;
	}


	function TunnelingAgent(options) {
	  var self = this;
	  self.options = options || {};
	  self.proxyOptions = self.options.proxy || {};
	  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;
	  self.requests = [];
	  self.sockets = [];

	  self.on('free', function onFree(socket, host, port, localAddress) {
	    var options = toOptions(host, port, localAddress);
	    for (var i = 0, len = self.requests.length; i < len; ++i) {
	      var pending = self.requests[i];
	      if (pending.host === options.host && pending.port === options.port) {
	        // Detect the request to connect same origin server,
	        // reuse the connection.
	        self.requests.splice(i, 1);
	        pending.request.onSocket(socket);
	        return;
	      }
	    }
	    socket.destroy();
	    self.removeSocket(socket);
	  });
	}
	util.inherits(TunnelingAgent, events.EventEmitter);

	TunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {
	  var self = this;
	  var options = mergeOptions({request: req}, self.options, toOptions(host, port, localAddress));

	  if (self.sockets.length >= this.maxSockets) {
	    // We are over limit so we'll add it to the queue.
	    self.requests.push(options);
	    return;
	  }

	  // If we are under maxSockets create a new one.
	  self.createSocket(options, function(socket) {
	    socket.on('free', onFree);
	    socket.on('close', onCloseOrRemove);
	    socket.on('agentRemove', onCloseOrRemove);
	    req.onSocket(socket);

	    function onFree() {
	      self.emit('free', socket, options);
	    }

	    function onCloseOrRemove(err) {
	      self.removeSocket(socket);
	      socket.removeListener('free', onFree);
	      socket.removeListener('close', onCloseOrRemove);
	      socket.removeListener('agentRemove', onCloseOrRemove);
	    }
	  });
	};

	TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
	  var self = this;
	  var placeholder = {};
	  self.sockets.push(placeholder);

	  var connectOptions = mergeOptions({}, self.proxyOptions, {
	    method: 'CONNECT',
	    path: options.host + ':' + options.port,
	    agent: false,
	    headers: {
	      host: options.host + ':' + options.port
	    }
	  });
	  if (options.localAddress) {
	    connectOptions.localAddress = options.localAddress;
	  }
	  if (connectOptions.proxyAuth) {
	    connectOptions.headers = connectOptions.headers || {};
	    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +
	        new Buffer(connectOptions.proxyAuth).toString('base64');
	  }

	  debug('making CONNECT request');
	  var connectReq = self.request(connectOptions);
	  connectReq.useChunkedEncodingByDefault = false; // for v0.6
	  connectReq.once('response', onResponse); // for v0.6
	  connectReq.once('upgrade', onUpgrade);   // for v0.6
	  connectReq.once('connect', onConnect);   // for v0.7 or later
	  connectReq.once('error', onError);
	  connectReq.end();

	  function onResponse(res) {
	    // Very hacky. This is necessary to avoid http-parser leaks.
	    res.upgrade = true;
	  }

	  function onUpgrade(res, socket, head) {
	    // Hacky.
	    process.nextTick(function() {
	      onConnect(res, socket, head);
	    });
	  }

	  function onConnect(res, socket, head) {
	    connectReq.removeAllListeners();
	    socket.removeAllListeners();

	    if (res.statusCode !== 200) {
	      debug('tunneling socket could not be established, statusCode=%d',
	        res.statusCode);
	      socket.destroy();
	      var error = new Error('tunneling socket could not be established, ' +
	        'statusCode=' + res.statusCode);
	      error.code = 'ECONNRESET';
	      options.request.emit('error', error);
	      self.removeSocket(placeholder);
	      return;
	    }
	    if (head.length > 0) {
	      debug('got illegal response body from proxy');
	      socket.destroy();
	      var error = new Error('got illegal response body from proxy');
	      error.code = 'ECONNRESET';
	      options.request.emit('error', error);
	      self.removeSocket(placeholder);
	      return;
	    }
	    debug('tunneling connection has established');
	    self.sockets[self.sockets.indexOf(placeholder)] = socket;
	    return cb(socket);
	  }

	  function onError(cause) {
	    connectReq.removeAllListeners();

	    debug('tunneling socket could not be established, cause=%s\n',
	          cause.message, cause.stack);
	    var error = new Error('tunneling socket could not be established, ' +
	                          'cause=' + cause.message);
	    error.code = 'ECONNRESET';
	    options.request.emit('error', error);
	    self.removeSocket(placeholder);
	  }
	};

	TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
	  var pos = this.sockets.indexOf(socket);
	  if (pos === -1) {
	    return;
	  }
	  this.sockets.splice(pos, 1);

	  var pending = this.requests.shift();
	  if (pending) {
	    // If we have pending requests and a socket gets closed a new one
	    // needs to be created to take over in the pool for the one that closed.
	    this.createSocket(pending, function(socket) {
	      pending.request.onSocket(socket);
	    });
	  }
	};

	function createSecureSocket(options, cb) {
	  var self = this;
	  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {
	    var hostHeader = options.request.getHeader('host');
	    var tlsOptions = mergeOptions({}, self.options, {
	      socket: socket,
	      servername: hostHeader ? hostHeader.replace(/:.*$/, '') : options.host
	    });

	    // 0 is dummy port for v0.6
	    var secureSocket = tls.connect(0, tlsOptions);
	    self.sockets[self.sockets.indexOf(socket)] = secureSocket;
	    cb(secureSocket);
	  });
	}


	function toOptions(host, port, localAddress) {
	  if (typeof host === 'string') { // since v0.10
	    return {
	      host: host,
	      port: port,
	      localAddress: localAddress
	    };
	  }
	  return host; // for v0.11 or later
	}

	function mergeOptions(target) {
	  for (var i = 1, len = arguments.length; i < len; ++i) {
	    var overrides = arguments[i];
	    if (typeof overrides === 'object') {
	      var keys = Object.keys(overrides);
	      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
	        var k = keys[j];
	        if (overrides[k] !== undefined) {
	          target[k] = overrides[k];
	        }
	      }
	    }
	  }
	  return target;
	}


	var debug;
	if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
	  debug = function() {
	    var args = Array.prototype.slice.call(arguments);
	    if (typeof args[0] === 'string') {
	      args[0] = 'TUNNEL: ' + args[0];
	    } else {
	      args.unshift('TUNNEL:');
	    }
	    console.error.apply(console, args);
	  };
	} else {
	  debug = function() {};
	}
	tunnel$1.debug = debug; // for test
	return tunnel$1;
}

var tunnel;
var hasRequiredTunnel;

function requireTunnel () {
	if (hasRequiredTunnel) return tunnel;
	hasRequiredTunnel = 1;
	tunnel = requireTunnel$1();
	return tunnel;
}

var undici = {};

var symbols$4;
var hasRequiredSymbols$4;

function requireSymbols$4 () {
	if (hasRequiredSymbols$4) return symbols$4;
	hasRequiredSymbols$4 = 1;
	symbols$4 = {
	  kClose: Symbol('close'),
	  kDestroy: Symbol('destroy'),
	  kDispatch: Symbol('dispatch'),
	  kUrl: Symbol('url'),
	  kWriting: Symbol('writing'),
	  kResuming: Symbol('resuming'),
	  kQueue: Symbol('queue'),
	  kConnect: Symbol('connect'),
	  kConnecting: Symbol('connecting'),
	  kHeadersList: Symbol('headers list'),
	  kKeepAliveDefaultTimeout: Symbol('default keep alive timeout'),
	  kKeepAliveMaxTimeout: Symbol('max keep alive timeout'),
	  kKeepAliveTimeoutThreshold: Symbol('keep alive timeout threshold'),
	  kKeepAliveTimeoutValue: Symbol('keep alive timeout'),
	  kKeepAlive: Symbol('keep alive'),
	  kHeadersTimeout: Symbol('headers timeout'),
	  kBodyTimeout: Symbol('body timeout'),
	  kServerName: Symbol('server name'),
	  kLocalAddress: Symbol('local address'),
	  kHost: Symbol('host'),
	  kNoRef: Symbol('no ref'),
	  kBodyUsed: Symbol('used'),
	  kRunning: Symbol('running'),
	  kBlocking: Symbol('blocking'),
	  kPending: Symbol('pending'),
	  kSize: Symbol('size'),
	  kBusy: Symbol('busy'),
	  kQueued: Symbol('queued'),
	  kFree: Symbol('free'),
	  kConnected: Symbol('connected'),
	  kClosed: Symbol('closed'),
	  kNeedDrain: Symbol('need drain'),
	  kReset: Symbol('reset'),
	  kDestroyed: Symbol.for('nodejs.stream.destroyed'),
	  kMaxHeadersSize: Symbol('max headers size'),
	  kRunningIdx: Symbol('running index'),
	  kPendingIdx: Symbol('pending index'),
	  kError: Symbol('error'),
	  kClients: Symbol('clients'),
	  kClient: Symbol('client'),
	  kParser: Symbol('parser'),
	  kOnDestroyed: Symbol('destroy callbacks'),
	  kPipelining: Symbol('pipelining'),
	  kSocket: Symbol('socket'),
	  kHostHeader: Symbol('host header'),
	  kConnector: Symbol('connector'),
	  kStrictContentLength: Symbol('strict content length'),
	  kMaxRedirections: Symbol('maxRedirections'),
	  kMaxRequests: Symbol('maxRequestsPerClient'),
	  kProxy: Symbol('proxy agent options'),
	  kCounter: Symbol('socket request counter'),
	  kInterceptors: Symbol('dispatch interceptors'),
	  kMaxResponseSize: Symbol('max response size'),
	  kHTTP2Session: Symbol('http2Session'),
	  kHTTP2SessionState: Symbol('http2Session state'),
	  kHTTP2BuildRequest: Symbol('http2 build request'),
	  kHTTP1BuildRequest: Symbol('http1 build request'),
	  kHTTP2CopyHeaders: Symbol('http2 copy headers'),
	  kHTTPConnVersion: Symbol('http connection version'),
	  kRetryHandlerDefaultRetry: Symbol('retry agent default retry'),
	  kConstruct: Symbol('constructable')
	};
	return symbols$4;
}

var errors;
var hasRequiredErrors;

function requireErrors () {
	if (hasRequiredErrors) return errors;
	hasRequiredErrors = 1;

	class UndiciError extends Error {
	  constructor (message) {
	    super(message);
	    this.name = 'UndiciError';
	    this.code = 'UND_ERR';
	  }
	}

	class ConnectTimeoutError extends UndiciError {
	  constructor (message) {
	    super(message);
	    Error.captureStackTrace(this, ConnectTimeoutError);
	    this.name = 'ConnectTimeoutError';
	    this.message = message || 'Connect Timeout Error';
	    this.code = 'UND_ERR_CONNECT_TIMEOUT';
	  }
	}

	class HeadersTimeoutError extends UndiciError {
	  constructor (message) {
	    super(message);
	    Error.captureStackTrace(this, HeadersTimeoutError);
	    this.name = 'HeadersTimeoutError';
	    this.message = message || 'Headers Timeout Error';
	    this.code = 'UND_ERR_HEADERS_TIMEOUT';
	  }
	}

	class HeadersOverflowError extends UndiciError {
	  constructor (message) {
	    super(message);
	    Error.captureStackTrace(this, HeadersOverflowError);
	    this.name = 'HeadersOverflowError';
	    this.message = message || 'Headers Overflow Error';
	    this.code = 'UND_ERR_HEADERS_OVERFLOW';
	  }
	}

	class BodyTimeoutError extends UndiciError {
	  constructor (message) {
	    super(message);
	    Error.captureStackTrace(this, BodyTimeoutError);
	    this.name = 'BodyTimeoutError';
	    this.message = message || 'Body Timeout Error';
	    this.code = 'UND_ERR_BODY_TIMEOUT';
	  }
	}

	class ResponseStatusCodeError extends UndiciError {
	  constructor (message, statusCode, headers, body) {
	    super(message);
	    Error.captureStackTrace(this, ResponseStatusCodeError);
	    this.name = 'ResponseStatusCodeError';
	    this.message = message || 'Response Status Code Error';
	    this.code = 'UND_ERR_RESPONSE_STATUS_CODE';
	    this.body = body;
	    this.status = statusCode;
	    this.statusCode = statusCode;
	    this.headers = headers;
	  }
	}

	class InvalidArgumentError extends UndiciError {
	  constructor (message) {
	    super(message);
	    Error.captureStackTrace(this, InvalidArgumentError);
	    this.name = 'InvalidArgumentError';
	    this.message = message || 'Invalid Argument Error';
	    this.code = 'UND_ERR_INVALID_ARG';
	  }
	}

	class InvalidReturnValueError extends UndiciError {
	  constructor (message) {
	    super(message);
	    Error.captureStackTrace(this, InvalidReturnValueError);
	    this.name = 'InvalidReturnValueError';
	    this.message = message || 'Invalid Return Value Error';
	    this.code = 'UND_ERR_INVALID_RETURN_VALUE';
	  }
	}

	class RequestAbortedError extends UndiciError {
	  constructor (message) {
	    super(message);
	    Error.captureStackTrace(this, RequestAbortedError);
	    this.name = 'AbortError';
	    this.message = message || 'Request aborted';
	    this.code = 'UND_ERR_ABORTED';
	  }
	}

	class InformationalError extends UndiciError {
	  constructor (message) {
	    super(message);
	    Error.captureStackTrace(this, InformationalError);
	    this.name = 'InformationalError';
	    this.message = message || 'Request information';
	    this.code = 'UND_ERR_INFO';
	  }
	}

	class RequestContentLengthMismatchError extends UndiciError {
	  constructor (message) {
	    super(message);
	    Error.captureStackTrace(this, RequestContentLengthMismatchError);
	    this.name = 'RequestContentLengthMismatchError';
	    this.message = message || 'Request body length does not match content-length header';
	    this.code = 'UND_ERR_REQ_CONTENT_LENGTH_MISMATCH';
	  }
	}

	class ResponseContentLengthMismatchError extends UndiciError {
	  constructor (message) {
	    super(message);
	    Error.captureStackTrace(this, ResponseContentLengthMismatchError);
	    this.name = 'ResponseContentLengthMismatchError';
	    this.message = message || 'Response body length does not match content-length header';
	    this.code = 'UND_ERR_RES_CONTENT_LENGTH_MISMATCH';
	  }
	}

	class ClientDestroyedError extends UndiciError {
	  constructor (message) {
	    super(message);
	    Error.captureStackTrace(this, ClientDestroyedError);
	    this.name = 'ClientDestroyedError';
	    this.message = message || 'The client is destroyed';
	    this.code = 'UND_ERR_DESTROYED';
	  }
	}

	class ClientClosedError extends UndiciError {
	  constructor (message) {
	    super(message);
	    Error.captureStackTrace(this, ClientClosedError);
	    this.name = 'ClientClosedError';
	    this.message = message || 'The client is closed';
	    this.code = 'UND_ERR_CLOSED';
	  }
	}

	class SocketError extends UndiciError {
	  constructor (message, socket) {
	    super(message);
	    Error.captureStackTrace(this, SocketError);
	    this.name = 'SocketError';
	    this.message = message || 'Socket error';
	    this.code = 'UND_ERR_SOCKET';
	    this.socket = socket;
	  }
	}

	class NotSupportedError extends UndiciError {
	  constructor (message) {
	    super(message);
	    Error.captureStackTrace(this, NotSupportedError);
	    this.name = 'NotSupportedError';
	    this.message = message || 'Not supported error';
	    this.code = 'UND_ERR_NOT_SUPPORTED';
	  }
	}

	class BalancedPoolMissingUpstreamError extends UndiciError {
	  constructor (message) {
	    super(message);
	    Error.captureStackTrace(this, NotSupportedError);
	    this.name = 'MissingUpstreamError';
	    this.message = message || 'No upstream has been added to the BalancedPool';
	    this.code = 'UND_ERR_BPL_MISSING_UPSTREAM';
	  }
	}

	class HTTPParserError extends Error {
	  constructor (message, code, data) {
	    super(message);
	    Error.captureStackTrace(this, HTTPParserError);
	    this.name = 'HTTPParserError';
	    this.code = code ? `HPE_${code}` : undefined;
	    this.data = data ? data.toString() : undefined;
	  }
	}

	class ResponseExceededMaxSizeError extends UndiciError {
	  constructor (message) {
	    super(message);
	    Error.captureStackTrace(this, ResponseExceededMaxSizeError);
	    this.name = 'ResponseExceededMaxSizeError';
	    this.message = message || 'Response content exceeded max size';
	    this.code = 'UND_ERR_RES_EXCEEDED_MAX_SIZE';
	  }
	}

	class RequestRetryError extends UndiciError {
	  constructor (message, code, { headers, data }) {
	    super(message);
	    Error.captureStackTrace(this, RequestRetryError);
	    this.name = 'RequestRetryError';
	    this.message = message || 'Request retry error';
	    this.code = 'UND_ERR_REQ_RETRY';
	    this.statusCode = code;
	    this.data = data;
	    this.headers = headers;
	  }
	}

	errors = {
	  HTTPParserError,
	  UndiciError,
	  HeadersTimeoutError,
	  HeadersOverflowError,
	  BodyTimeoutError,
	  RequestContentLengthMismatchError,
	  ConnectTimeoutError,
	  ResponseStatusCodeError,
	  InvalidArgumentError,
	  InvalidReturnValueError,
	  RequestAbortedError,
	  ClientDestroyedError,
	  ClientClosedError,
	  InformationalError,
	  SocketError,
	  NotSupportedError,
	  ResponseContentLengthMismatchError,
	  BalancedPoolMissingUpstreamError,
	  ResponseExceededMaxSizeError,
	  RequestRetryError
	};
	return errors;
}

var constants$6;
var hasRequiredConstants$6;

function requireConstants$6 () {
	if (hasRequiredConstants$6) return constants$6;
	hasRequiredConstants$6 = 1;

	/** @type {Record<string, string | undefined>} */
	const headerNameLowerCasedRecord = {};

	// https://developer.mozilla.org/docs/Web/HTTP/Headers
	const wellknownHeaderNames = [
	  'Accept',
	  'Accept-Encoding',
	  'Accept-Language',
	  'Accept-Ranges',
	  'Access-Control-Allow-Credentials',
	  'Access-Control-Allow-Headers',
	  'Access-Control-Allow-Methods',
	  'Access-Control-Allow-Origin',
	  'Access-Control-Expose-Headers',
	  'Access-Control-Max-Age',
	  'Access-Control-Request-Headers',
	  'Access-Control-Request-Method',
	  'Age',
	  'Allow',
	  'Alt-Svc',
	  'Alt-Used',
	  'Authorization',
	  'Cache-Control',
	  'Clear-Site-Data',
	  'Connection',
	  'Content-Disposition',
	  'Content-Encoding',
	  'Content-Language',
	  'Content-Length',
	  'Content-Location',
	  'Content-Range',
	  'Content-Security-Policy',
	  'Content-Security-Policy-Report-Only',
	  'Content-Type',
	  'Cookie',
	  'Cross-Origin-Embedder-Policy',
	  'Cross-Origin-Opener-Policy',
	  'Cross-Origin-Resource-Policy',
	  'Date',
	  'Device-Memory',
	  'Downlink',
	  'ECT',
	  'ETag',
	  'Expect',
	  'Expect-CT',
	  'Expires',
	  'Forwarded',
	  'From',
	  'Host',
	  'If-Match',
	  'If-Modified-Since',
	  'If-None-Match',
	  'If-Range',
	  'If-Unmodified-Since',
	  'Keep-Alive',
	  'Last-Modified',
	  'Link',
	  'Location',
	  'Max-Forwards',
	  'Origin',
	  'Permissions-Policy',
	  'Pragma',
	  'Proxy-Authenticate',
	  'Proxy-Authorization',
	  'RTT',
	  'Range',
	  'Referer',
	  'Referrer-Policy',
	  'Refresh',
	  'Retry-After',
	  'Sec-WebSocket-Accept',
	  'Sec-WebSocket-Extensions',
	  'Sec-WebSocket-Key',
	  'Sec-WebSocket-Protocol',
	  'Sec-WebSocket-Version',
	  'Server',
	  'Server-Timing',
	  'Service-Worker-Allowed',
	  'Service-Worker-Navigation-Preload',
	  'Set-Cookie',
	  'SourceMap',
	  'Strict-Transport-Security',
	  'Supports-Loading-Mode',
	  'TE',
	  'Timing-Allow-Origin',
	  'Trailer',
	  'Transfer-Encoding',
	  'Upgrade',
	  'Upgrade-Insecure-Requests',
	  'User-Agent',
	  'Vary',
	  'Via',
	  'WWW-Authenticate',
	  'X-Content-Type-Options',
	  'X-DNS-Prefetch-Control',
	  'X-Frame-Options',
	  'X-Permitted-Cross-Domain-Policies',
	  'X-Powered-By',
	  'X-Requested-With',
	  'X-XSS-Protection'
	];

	for (let i = 0; i < wellknownHeaderNames.length; ++i) {
	  const key = wellknownHeaderNames[i];
	  const lowerCasedKey = key.toLowerCase();
	  headerNameLowerCasedRecord[key] = headerNameLowerCasedRecord[lowerCasedKey] =
	    lowerCasedKey;
	}

	// Note: object prototypes should not be able to be referenced. e.g. `Object#hasOwnProperty`.
	Object.setPrototypeOf(headerNameLowerCasedRecord, null);

	constants$6 = {
	  wellknownHeaderNames,
	  headerNameLowerCasedRecord
	};
	return constants$6;
}

var util$6;
var hasRequiredUtil$6;

function requireUtil$6 () {
	if (hasRequiredUtil$6) return util$6;
	hasRequiredUtil$6 = 1;

	const assert = require$$0$4;
	const { kDestroyed, kBodyUsed } = requireSymbols$4();
	const { IncomingMessage } = require$$2;
	const stream = require$$0$6;
	const net = require$$0$5;
	const { InvalidArgumentError } = requireErrors();
	const { Blob } = require$$7;
	const nodeUtil = require$$0$2;
	const { stringify } = require$$8;
	const { headerNameLowerCasedRecord } = requireConstants$6();

	const [nodeMajor, nodeMinor] = process.versions.node.split('.').map(v => Number(v));

	function nop () {}

	function isStream (obj) {
	  return obj && typeof obj === 'object' && typeof obj.pipe === 'function' && typeof obj.on === 'function'
	}

	// based on https://github.com/node-fetch/fetch-blob/blob/8ab587d34080de94140b54f07168451e7d0b655e/index.js#L229-L241 (MIT License)
	function isBlobLike (object) {
	  return (Blob && object instanceof Blob) || (
	    object &&
	    typeof object === 'object' &&
	    (typeof object.stream === 'function' ||
	      typeof object.arrayBuffer === 'function') &&
	    /^(Blob|File)$/.test(object[Symbol.toStringTag])
	  )
	}

	function buildURL (url, queryParams) {
	  if (url.includes('?') || url.includes('#')) {
	    throw new Error('Query params cannot be passed when url already contains "?" or "#".')
	  }

	  const stringified = stringify(queryParams);

	  if (stringified) {
	    url += '?' + stringified;
	  }

	  return url
	}

	function parseURL (url) {
	  if (typeof url === 'string') {
	    url = new URL(url);

	    if (!/^https?:/.test(url.origin || url.protocol)) {
	      throw new InvalidArgumentError('Invalid URL protocol: the URL must start with `http:` or `https:`.')
	    }

	    return url
	  }

	  if (!url || typeof url !== 'object') {
	    throw new InvalidArgumentError('Invalid URL: The URL argument must be a non-null object.')
	  }

	  if (!/^https?:/.test(url.origin || url.protocol)) {
	    throw new InvalidArgumentError('Invalid URL protocol: the URL must start with `http:` or `https:`.')
	  }

	  if (!(url instanceof URL)) {
	    if (url.port != null && url.port !== '' && !Number.isFinite(parseInt(url.port))) {
	      throw new InvalidArgumentError('Invalid URL: port must be a valid integer or a string representation of an integer.')
	    }

	    if (url.path != null && typeof url.path !== 'string') {
	      throw new InvalidArgumentError('Invalid URL path: the path must be a string or null/undefined.')
	    }

	    if (url.pathname != null && typeof url.pathname !== 'string') {
	      throw new InvalidArgumentError('Invalid URL pathname: the pathname must be a string or null/undefined.')
	    }

	    if (url.hostname != null && typeof url.hostname !== 'string') {
	      throw new InvalidArgumentError('Invalid URL hostname: the hostname must be a string or null/undefined.')
	    }

	    if (url.origin != null && typeof url.origin !== 'string') {
	      throw new InvalidArgumentError('Invalid URL origin: the origin must be a string or null/undefined.')
	    }

	    const port = url.port != null
	      ? url.port
	      : (url.protocol === 'https:' ? 443 : 80);
	    let origin = url.origin != null
	      ? url.origin
	      : `${url.protocol}//${url.hostname}:${port}`;
	    let path = url.path != null
	      ? url.path
	      : `${url.pathname || ''}${url.search || ''}`;

	    if (origin.endsWith('/')) {
	      origin = origin.substring(0, origin.length - 1);
	    }

	    if (path && !path.startsWith('/')) {
	      path = `/${path}`;
	    }
	    // new URL(path, origin) is unsafe when `path` contains an absolute URL
	    // From https://developer.mozilla.org/en-US/docs/Web/API/URL/URL:
	    // If first parameter is a relative URL, second param is required, and will be used as the base URL.
	    // If first parameter is an absolute URL, a given second param will be ignored.
	    url = new URL(origin + path);
	  }

	  return url
	}

	function parseOrigin (url) {
	  url = parseURL(url);

	  if (url.pathname !== '/' || url.search || url.hash) {
	    throw new InvalidArgumentError('invalid url')
	  }

	  return url
	}

	function getHostname (host) {
	  if (host[0] === '[') {
	    const idx = host.indexOf(']');

	    assert(idx !== -1);
	    return host.substring(1, idx)
	  }

	  const idx = host.indexOf(':');
	  if (idx === -1) return host

	  return host.substring(0, idx)
	}

	// IP addresses are not valid server names per RFC6066
	// > Currently, the only server names supported are DNS hostnames
	function getServerName (host) {
	  if (!host) {
	    return null
	  }

	  assert.strictEqual(typeof host, 'string');

	  const servername = getHostname(host);
	  if (net.isIP(servername)) {
	    return ''
	  }

	  return servername
	}

	function deepClone (obj) {
	  return JSON.parse(JSON.stringify(obj))
	}

	function isAsyncIterable (obj) {
	  return !!(obj != null && typeof obj[Symbol.asyncIterator] === 'function')
	}

	function isIterable (obj) {
	  return !!(obj != null && (typeof obj[Symbol.iterator] === 'function' || typeof obj[Symbol.asyncIterator] === 'function'))
	}

	function bodyLength (body) {
	  if (body == null) {
	    return 0
	  } else if (isStream(body)) {
	    const state = body._readableState;
	    return state && state.objectMode === false && state.ended === true && Number.isFinite(state.length)
	      ? state.length
	      : null
	  } else if (isBlobLike(body)) {
	    return body.size != null ? body.size : null
	  } else if (isBuffer(body)) {
	    return body.byteLength
	  }

	  return null
	}

	function isDestroyed (stream) {
	  return !stream || !!(stream.destroyed || stream[kDestroyed])
	}

	function isReadableAborted (stream) {
	  const state = stream && stream._readableState;
	  return isDestroyed(stream) && state && !state.endEmitted
	}

	function destroy (stream, err) {
	  if (stream == null || !isStream(stream) || isDestroyed(stream)) {
	    return
	  }

	  if (typeof stream.destroy === 'function') {
	    if (Object.getPrototypeOf(stream).constructor === IncomingMessage) {
	      // See: https://github.com/nodejs/node/pull/38505/files
	      stream.socket = null;
	    }

	    stream.destroy(err);
	  } else if (err) {
	    process.nextTick((stream, err) => {
	      stream.emit('error', err);
	    }, stream, err);
	  }

	  if (stream.destroyed !== true) {
	    stream[kDestroyed] = true;
	  }
	}

	const KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/;
	function parseKeepAliveTimeout (val) {
	  const m = val.toString().match(KEEPALIVE_TIMEOUT_EXPR);
	  return m ? parseInt(m[1], 10) * 1000 : null
	}

	/**
	 * Retrieves a header name and returns its lowercase value.
	 * @param {string | Buffer} value Header name
	 * @returns {string}
	 */
	function headerNameToString (value) {
	  return headerNameLowerCasedRecord[value] || value.toLowerCase()
	}

	function parseHeaders (headers, obj = {}) {
	  // For H2 support
	  if (!Array.isArray(headers)) return headers

	  for (let i = 0; i < headers.length; i += 2) {
	    const key = headers[i].toString().toLowerCase();
	    let val = obj[key];

	    if (!val) {
	      if (Array.isArray(headers[i + 1])) {
	        obj[key] = headers[i + 1].map(x => x.toString('utf8'));
	      } else {
	        obj[key] = headers[i + 1].toString('utf8');
	      }
	    } else {
	      if (!Array.isArray(val)) {
	        val = [val];
	        obj[key] = val;
	      }
	      val.push(headers[i + 1].toString('utf8'));
	    }
	  }

	  // See https://github.com/nodejs/node/pull/46528
	  if ('content-length' in obj && 'content-disposition' in obj) {
	    obj['content-disposition'] = Buffer.from(obj['content-disposition']).toString('latin1');
	  }

	  return obj
	}

	function parseRawHeaders (headers) {
	  const ret = [];
	  let hasContentLength = false;
	  let contentDispositionIdx = -1;

	  for (let n = 0; n < headers.length; n += 2) {
	    const key = headers[n + 0].toString();
	    const val = headers[n + 1].toString('utf8');

	    if (key.length === 14 && (key === 'content-length' || key.toLowerCase() === 'content-length')) {
	      ret.push(key, val);
	      hasContentLength = true;
	    } else if (key.length === 19 && (key === 'content-disposition' || key.toLowerCase() === 'content-disposition')) {
	      contentDispositionIdx = ret.push(key, val) - 1;
	    } else {
	      ret.push(key, val);
	    }
	  }

	  // See https://github.com/nodejs/node/pull/46528
	  if (hasContentLength && contentDispositionIdx !== -1) {
	    ret[contentDispositionIdx] = Buffer.from(ret[contentDispositionIdx]).toString('latin1');
	  }

	  return ret
	}

	function isBuffer (buffer) {
	  // See, https://github.com/mcollina/undici/pull/319
	  return buffer instanceof Uint8Array || Buffer.isBuffer(buffer)
	}

	function validateHandler (handler, method, upgrade) {
	  if (!handler || typeof handler !== 'object') {
	    throw new InvalidArgumentError('handler must be an object')
	  }

	  if (typeof handler.onConnect !== 'function') {
	    throw new InvalidArgumentError('invalid onConnect method')
	  }

	  if (typeof handler.onError !== 'function') {
	    throw new InvalidArgumentError('invalid onError method')
	  }

	  if (typeof handler.onBodySent !== 'function' && handler.onBodySent !== undefined) {
	    throw new InvalidArgumentError('invalid onBodySent method')
	  }

	  if (upgrade || method === 'CONNECT') {
	    if (typeof handler.onUpgrade !== 'function') {
	      throw new InvalidArgumentError('invalid onUpgrade method')
	    }
	  } else {
	    if (typeof handler.onHeaders !== 'function') {
	      throw new InvalidArgumentError('invalid onHeaders method')
	    }

	    if (typeof handler.onData !== 'function') {
	      throw new InvalidArgumentError('invalid onData method')
	    }

	    if (typeof handler.onComplete !== 'function') {
	      throw new InvalidArgumentError('invalid onComplete method')
	    }
	  }
	}

	// A body is disturbed if it has been read from and it cannot
	// be re-used without losing state or data.
	function isDisturbed (body) {
	  return !!(body && (
	    stream.isDisturbed
	      ? stream.isDisturbed(body) || body[kBodyUsed] // TODO (fix): Why is body[kBodyUsed] needed?
	      : body[kBodyUsed] ||
	        body.readableDidRead ||
	        (body._readableState && body._readableState.dataEmitted) ||
	        isReadableAborted(body)
	  ))
	}

	function isErrored (body) {
	  return !!(body && (
	    stream.isErrored
	      ? stream.isErrored(body)
	      : /state: 'errored'/.test(nodeUtil.inspect(body)
	      )))
	}

	function isReadable (body) {
	  return !!(body && (
	    stream.isReadable
	      ? stream.isReadable(body)
	      : /state: 'readable'/.test(nodeUtil.inspect(body)
	      )))
	}

	function getSocketInfo (socket) {
	  return {
	    localAddress: socket.localAddress,
	    localPort: socket.localPort,
	    remoteAddress: socket.remoteAddress,
	    remotePort: socket.remotePort,
	    remoteFamily: socket.remoteFamily,
	    timeout: socket.timeout,
	    bytesWritten: socket.bytesWritten,
	    bytesRead: socket.bytesRead
	  }
	}

	async function * convertIterableToBuffer (iterable) {
	  for await (const chunk of iterable) {
	    yield Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk);
	  }
	}

	let ReadableStream;
	function ReadableStreamFrom (iterable) {
	  if (!ReadableStream) {
	    ReadableStream = require$$14.ReadableStream;
	  }

	  if (ReadableStream.from) {
	    return ReadableStream.from(convertIterableToBuffer(iterable))
	  }

	  let iterator;
	  return new ReadableStream(
	    {
	      async start () {
	        iterator = iterable[Symbol.asyncIterator]();
	      },
	      async pull (controller) {
	        const { done, value } = await iterator.next();
	        if (done) {
	          queueMicrotask(() => {
	            controller.close();
	          });
	        } else {
	          const buf = Buffer.isBuffer(value) ? value : Buffer.from(value);
	          controller.enqueue(new Uint8Array(buf));
	        }
	        return controller.desiredSize > 0
	      },
	      async cancel (reason) {
	        await iterator.return();
	      }
	    },
	    0
	  )
	}

	// The chunk should be a FormData instance and contains
	// all the required methods.
	function isFormDataLike (object) {
	  return (
	    object &&
	    typeof object === 'object' &&
	    typeof object.append === 'function' &&
	    typeof object.delete === 'function' &&
	    typeof object.get === 'function' &&
	    typeof object.getAll === 'function' &&
	    typeof object.has === 'function' &&
	    typeof object.set === 'function' &&
	    object[Symbol.toStringTag] === 'FormData'
	  )
	}

	function throwIfAborted (signal) {
	  if (!signal) { return }
	  if (typeof signal.throwIfAborted === 'function') {
	    signal.throwIfAborted();
	  } else {
	    if (signal.aborted) {
	      // DOMException not available < v17.0.0
	      const err = new Error('The operation was aborted');
	      err.name = 'AbortError';
	      throw err
	    }
	  }
	}

	function addAbortListener (signal, listener) {
	  if ('addEventListener' in signal) {
	    signal.addEventListener('abort', listener, { once: true });
	    return () => signal.removeEventListener('abort', listener)
	  }
	  signal.addListener('abort', listener);
	  return () => signal.removeListener('abort', listener)
	}

	const hasToWellFormed = !!String.prototype.toWellFormed;

	/**
	 * @param {string} val
	 */
	function toUSVString (val) {
	  if (hasToWellFormed) {
	    return `${val}`.toWellFormed()
	  } else if (nodeUtil.toUSVString) {
	    return nodeUtil.toUSVString(val)
	  }

	  return `${val}`
	}

	// Parsed accordingly to RFC 9110
	// https://www.rfc-editor.org/rfc/rfc9110#field.content-range
	function parseRangeHeader (range) {
	  if (range == null || range === '') return { start: 0, end: null, size: null }

	  const m = range ? range.match(/^bytes (\d+)-(\d+)\/(\d+)?$/) : null;
	  return m
	    ? {
	        start: parseInt(m[1]),
	        end: m[2] ? parseInt(m[2]) : null,
	        size: m[3] ? parseInt(m[3]) : null
	      }
	    : null
	}

	const kEnumerableProperty = Object.create(null);
	kEnumerableProperty.enumerable = true;

	util$6 = {
	  kEnumerableProperty,
	  nop,
	  isDisturbed,
	  isErrored,
	  isReadable,
	  toUSVString,
	  isReadableAborted,
	  isBlobLike,
	  parseOrigin,
	  parseURL,
	  getServerName,
	  isStream,
	  isIterable,
	  isAsyncIterable,
	  isDestroyed,
	  headerNameToString,
	  parseRawHeaders,
	  parseHeaders,
	  parseKeepAliveTimeout,
	  destroy,
	  bodyLength,
	  deepClone,
	  ReadableStreamFrom,
	  isBuffer,
	  validateHandler,
	  getSocketInfo,
	  isFormDataLike,
	  buildURL,
	  throwIfAborted,
	  addAbortListener,
	  parseRangeHeader,
	  nodeMajor,
	  nodeMinor,
	  nodeHasAutoSelectFamily: nodeMajor > 18 || (nodeMajor === 18 && nodeMinor >= 13),
	  safeHTTPMethods: ['GET', 'HEAD', 'OPTIONS', 'TRACE']
	};
	return util$6;
}

var timers;
var hasRequiredTimers;

function requireTimers () {
	if (hasRequiredTimers) return timers;
	hasRequiredTimers = 1;

	let fastNow = Date.now();
	let fastNowTimeout;

	const fastTimers = [];

	function onTimeout () {
	  fastNow = Date.now();

	  let len = fastTimers.length;
	  let idx = 0;
	  while (idx < len) {
	    const timer = fastTimers[idx];

	    if (timer.state === 0) {
	      timer.state = fastNow + timer.delay;
	    } else if (timer.state > 0 && fastNow >= timer.state) {
	      timer.state = -1;
	      timer.callback(timer.opaque);
	    }

	    if (timer.state === -1) {
	      timer.state = -2;
	      if (idx !== len - 1) {
	        fastTimers[idx] = fastTimers.pop();
	      } else {
	        fastTimers.pop();
	      }
	      len -= 1;
	    } else {
	      idx += 1;
	    }
	  }

	  if (fastTimers.length > 0) {
	    refreshTimeout();
	  }
	}

	function refreshTimeout () {
	  if (fastNowTimeout && fastNowTimeout.refresh) {
	    fastNowTimeout.refresh();
	  } else {
	    clearTimeout(fastNowTimeout);
	    fastNowTimeout = setTimeout(onTimeout, 1e3);
	    if (fastNowTimeout.unref) {
	      fastNowTimeout.unref();
	    }
	  }
	}

	class Timeout {
	  constructor (callback, delay, opaque) {
	    this.callback = callback;
	    this.delay = delay;
	    this.opaque = opaque;

	    //  -2 not in timer list
	    //  -1 in timer list but inactive
	    //   0 in timer list waiting for time
	    // > 0 in timer list waiting for time to expire
	    this.state = -2;

	    this.refresh();
	  }

	  refresh () {
	    if (this.state === -2) {
	      fastTimers.push(this);
	      if (!fastNowTimeout || fastTimers.length === 1) {
	        refreshTimeout();
	      }
	    }

	    this.state = 0;
	  }

	  clear () {
	    this.state = -1;
	  }
	}

	timers = {
	  setTimeout (callback, delay, opaque) {
	    return delay < 1e3
	      ? setTimeout(callback, delay, opaque)
	      : new Timeout(callback, delay, opaque)
	  },
	  clearTimeout (timeout) {
	    if (timeout instanceof Timeout) {
	      timeout.clear();
	    } else {
	      clearTimeout(timeout);
	    }
	  }
	};
	return timers;
}

var main$2 = {exports: {}};

var sbmh;
var hasRequiredSbmh;

function requireSbmh () {
	if (hasRequiredSbmh) return sbmh;
	hasRequiredSbmh = 1;

	/**
	 * Copyright Brian White. All rights reserved.
	 *
	 * @see https://github.com/mscdex/streamsearch
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to
	 * deal in the Software without restriction, including without limitation the
	 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
	 * sell copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
	 * IN THE SOFTWARE.
	 *
	 * Based heavily on the Streaming Boyer-Moore-Horspool C++ implementation
	 * by Hongli Lai at: https://github.com/FooBarWidget/boyer-moore-horspool
	 */
	const EventEmitter = require$$0$7.EventEmitter;
	const inherits = require$$1$1.inherits;

	function SBMH (needle) {
	  if (typeof needle === 'string') {
	    needle = Buffer.from(needle);
	  }

	  if (!Buffer.isBuffer(needle)) {
	    throw new TypeError('The needle has to be a String or a Buffer.')
	  }

	  const needleLength = needle.length;

	  if (needleLength === 0) {
	    throw new Error('The needle cannot be an empty String/Buffer.')
	  }

	  if (needleLength > 256) {
	    throw new Error('The needle cannot have a length bigger than 256.')
	  }

	  this.maxMatches = Infinity;
	  this.matches = 0;

	  this._occ = new Array(256)
	    .fill(needleLength); // Initialize occurrence table.
	  this._lookbehind_size = 0;
	  this._needle = needle;
	  this._bufpos = 0;

	  this._lookbehind = Buffer.alloc(needleLength);

	  // Populate occurrence table with analysis of the needle,
	  // ignoring last letter.
	  for (var i = 0; i < needleLength - 1; ++i) { // eslint-disable-line no-var
	    this._occ[needle[i]] = needleLength - 1 - i;
	  }
	}
	inherits(SBMH, EventEmitter);

	SBMH.prototype.reset = function () {
	  this._lookbehind_size = 0;
	  this.matches = 0;
	  this._bufpos = 0;
	};

	SBMH.prototype.push = function (chunk, pos) {
	  if (!Buffer.isBuffer(chunk)) {
	    chunk = Buffer.from(chunk, 'binary');
	  }
	  const chlen = chunk.length;
	  this._bufpos = pos || 0;
	  let r;
	  while (r !== chlen && this.matches < this.maxMatches) { r = this._sbmh_feed(chunk); }
	  return r
	};

	SBMH.prototype._sbmh_feed = function (data) {
	  const len = data.length;
	  const needle = this._needle;
	  const needleLength = needle.length;
	  const lastNeedleChar = needle[needleLength - 1];

	  // Positive: points to a position in `data`
	  //           pos == 3 points to data[3]
	  // Negative: points to a position in the lookbehind buffer
	  //           pos == -2 points to lookbehind[lookbehind_size - 2]
	  let pos = -this._lookbehind_size;
	  let ch;

	  if (pos < 0) {
	    // Lookbehind buffer is not empty. Perform Boyer-Moore-Horspool
	    // search with character lookup code that considers both the
	    // lookbehind buffer and the current round's haystack data.
	    //
	    // Loop until
	    //   there is a match.
	    // or until
	    //   we've moved past the position that requires the
	    //   lookbehind buffer. In this case we switch to the
	    //   optimized loop.
	    // or until
	    //   the character to look at lies outside the haystack.
	    while (pos < 0 && pos <= len - needleLength) {
	      ch = this._sbmh_lookup_char(data, pos + needleLength - 1);

	      if (
	        ch === lastNeedleChar &&
	        this._sbmh_memcmp(data, pos, needleLength - 1)
	      ) {
	        this._lookbehind_size = 0;
	        ++this.matches;
	        this.emit('info', true);

	        return (this._bufpos = pos + needleLength)
	      }
	      pos += this._occ[ch];
	    }

	    // No match.

	    if (pos < 0) {
	      // There's too few data for Boyer-Moore-Horspool to run,
	      // so let's use a different algorithm to skip as much as
	      // we can.
	      // Forward pos until
	      //   the trailing part of lookbehind + data
	      //   looks like the beginning of the needle
	      // or until
	      //   pos == 0
	      while (pos < 0 && !this._sbmh_memcmp(data, pos, len - pos)) { ++pos; }
	    }

	    if (pos >= 0) {
	      // Discard lookbehind buffer.
	      this.emit('info', false, this._lookbehind, 0, this._lookbehind_size);
	      this._lookbehind_size = 0;
	    } else {
	      // Cut off part of the lookbehind buffer that has
	      // been processed and append the entire haystack
	      // into it.
	      const bytesToCutOff = this._lookbehind_size + pos;
	      if (bytesToCutOff > 0) {
	        // The cut off data is guaranteed not to contain the needle.
	        this.emit('info', false, this._lookbehind, 0, bytesToCutOff);
	      }

	      this._lookbehind.copy(this._lookbehind, 0, bytesToCutOff,
	        this._lookbehind_size - bytesToCutOff);
	      this._lookbehind_size -= bytesToCutOff;

	      data.copy(this._lookbehind, this._lookbehind_size);
	      this._lookbehind_size += len;

	      this._bufpos = len;
	      return len
	    }
	  }

	  pos += (pos >= 0) * this._bufpos;

	  // Lookbehind buffer is now empty. We only need to check if the
	  // needle is in the haystack.
	  if (data.indexOf(needle, pos) !== -1) {
	    pos = data.indexOf(needle, pos);
	    ++this.matches;
	    if (pos > 0) { this.emit('info', true, data, this._bufpos, pos); } else { this.emit('info', true); }

	    return (this._bufpos = pos + needleLength)
	  } else {
	    pos = len - needleLength;
	  }

	  // There was no match. If there's trailing haystack data that we cannot
	  // match yet using the Boyer-Moore-Horspool algorithm (because the trailing
	  // data is less than the needle size) then match using a modified
	  // algorithm that starts matching from the beginning instead of the end.
	  // Whatever trailing data is left after running this algorithm is added to
	  // the lookbehind buffer.
	  while (
	    pos < len &&
	    (
	      data[pos] !== needle[0] ||
	      (
	        (Buffer.compare(
	          data.subarray(pos, pos + len - pos),
	          needle.subarray(0, len - pos)
	        ) !== 0)
	      )
	    )
	  ) {
	    ++pos;
	  }
	  if (pos < len) {
	    data.copy(this._lookbehind, 0, pos, pos + (len - pos));
	    this._lookbehind_size = len - pos;
	  }

	  // Everything until pos is guaranteed not to contain needle data.
	  if (pos > 0) { this.emit('info', false, data, this._bufpos, pos < len ? pos : len); }

	  this._bufpos = len;
	  return len
	};

	SBMH.prototype._sbmh_lookup_char = function (data, pos) {
	  return (pos < 0)
	    ? this._lookbehind[this._lookbehind_size + pos]
	    : data[pos]
	};

	SBMH.prototype._sbmh_memcmp = function (data, pos, len) {
	  for (var i = 0; i < len; ++i) { // eslint-disable-line no-var
	    if (this._sbmh_lookup_char(data, pos + i) !== this._needle[i]) { return false }
	  }
	  return true
	};

	sbmh = SBMH;
	return sbmh;
}

var PartStream_1;
var hasRequiredPartStream;

function requirePartStream () {
	if (hasRequiredPartStream) return PartStream_1;
	hasRequiredPartStream = 1;

	const inherits = require$$1$1.inherits;
	const ReadableStream = ie.Readable;

	function PartStream (opts) {
	  ReadableStream.call(this, opts);
	}
	inherits(PartStream, ReadableStream);

	PartStream.prototype._read = function (n) {};

	PartStream_1 = PartStream;
	return PartStream_1;
}

var getLimit;
var hasRequiredGetLimit;

function requireGetLimit () {
	if (hasRequiredGetLimit) return getLimit;
	hasRequiredGetLimit = 1;

	getLimit = function getLimit (limits, name, defaultLimit) {
	  if (
	    !limits ||
	    limits[name] === undefined ||
	    limits[name] === null
	  ) { return defaultLimit }

	  if (
	    typeof limits[name] !== 'number' ||
	    isNaN(limits[name])
	  ) { throw new TypeError('Limit ' + name + ' is not a valid number') }

	  return limits[name]
	};
	return getLimit;
}

var HeaderParser_1;
var hasRequiredHeaderParser;

function requireHeaderParser () {
	if (hasRequiredHeaderParser) return HeaderParser_1;
	hasRequiredHeaderParser = 1;

	const EventEmitter = require$$0$7.EventEmitter;
	const inherits = require$$1$1.inherits;
	const getLimit = requireGetLimit();

	const StreamSearch = requireSbmh();

	const B_DCRLF = Buffer.from('\r\n\r\n');
	const RE_CRLF = /\r\n/g;
	const RE_HDR = /^([^:]+):[ \t]?([\x00-\xFF]+)?$/; // eslint-disable-line no-control-regex

	function HeaderParser (cfg) {
	  EventEmitter.call(this);

	  cfg = cfg || {};
	  const self = this;
	  this.nread = 0;
	  this.maxed = false;
	  this.npairs = 0;
	  this.maxHeaderPairs = getLimit(cfg, 'maxHeaderPairs', 2000);
	  this.maxHeaderSize = getLimit(cfg, 'maxHeaderSize', 80 * 1024);
	  this.buffer = '';
	  this.header = {};
	  this.finished = false;
	  this.ss = new StreamSearch(B_DCRLF);
	  this.ss.on('info', function (isMatch, data, start, end) {
	    if (data && !self.maxed) {
	      if (self.nread + end - start >= self.maxHeaderSize) {
	        end = self.maxHeaderSize - self.nread + start;
	        self.nread = self.maxHeaderSize;
	        self.maxed = true;
	      } else { self.nread += (end - start); }

	      self.buffer += data.toString('binary', start, end);
	    }
	    if (isMatch) { self._finish(); }
	  });
	}
	inherits(HeaderParser, EventEmitter);

	HeaderParser.prototype.push = function (data) {
	  const r = this.ss.push(data);
	  if (this.finished) { return r }
	};

	HeaderParser.prototype.reset = function () {
	  this.finished = false;
	  this.buffer = '';
	  this.header = {};
	  this.ss.reset();
	};

	HeaderParser.prototype._finish = function () {
	  if (this.buffer) { this._parseHeader(); }
	  this.ss.matches = this.ss.maxMatches;
	  const header = this.header;
	  this.header = {};
	  this.buffer = '';
	  this.finished = true;
	  this.nread = this.npairs = 0;
	  this.maxed = false;
	  this.emit('header', header);
	};

	HeaderParser.prototype._parseHeader = function () {
	  if (this.npairs === this.maxHeaderPairs) { return }

	  const lines = this.buffer.split(RE_CRLF);
	  const len = lines.length;
	  let m, h;

	  for (var i = 0; i < len; ++i) { // eslint-disable-line no-var
	    if (lines[i].length === 0) { continue }
	    if (lines[i][0] === '\t' || lines[i][0] === ' ') {
	      // folded header content
	      // RFC2822 says to just remove the CRLF and not the whitespace following
	      // it, so we follow the RFC and include the leading whitespace ...
	      if (h) {
	        this.header[h][this.header[h].length - 1] += lines[i];
	        continue
	      }
	    }

	    const posColon = lines[i].indexOf(':');
	    if (
	      posColon === -1 ||
	      posColon === 0
	    ) {
	      return
	    }
	    m = RE_HDR.exec(lines[i]);
	    h = m[1].toLowerCase();
	    this.header[h] = this.header[h] || [];
	    this.header[h].push((m[2] || ''));
	    if (++this.npairs === this.maxHeaderPairs) { break }
	  }
	};

	HeaderParser_1 = HeaderParser;
	return HeaderParser_1;
}

var Dicer_1;
var hasRequiredDicer;

function requireDicer () {
	if (hasRequiredDicer) return Dicer_1;
	hasRequiredDicer = 1;

	const WritableStream = ie.Writable;
	const inherits = require$$1$1.inherits;

	const StreamSearch = requireSbmh();

	const PartStream = requirePartStream();
	const HeaderParser = requireHeaderParser();

	const DASH = 45;
	const B_ONEDASH = Buffer.from('-');
	const B_CRLF = Buffer.from('\r\n');
	const EMPTY_FN = function () {};

	function Dicer (cfg) {
	  if (!(this instanceof Dicer)) { return new Dicer(cfg) }
	  WritableStream.call(this, cfg);

	  if (!cfg || (!cfg.headerFirst && typeof cfg.boundary !== 'string')) { throw new TypeError('Boundary required') }

	  if (typeof cfg.boundary === 'string') { this.setBoundary(cfg.boundary); } else { this._bparser = undefined; }

	  this._headerFirst = cfg.headerFirst;

	  this._dashes = 0;
	  this._parts = 0;
	  this._finished = false;
	  this._realFinish = false;
	  this._isPreamble = true;
	  this._justMatched = false;
	  this._firstWrite = true;
	  this._inHeader = true;
	  this._part = undefined;
	  this._cb = undefined;
	  this._ignoreData = false;
	  this._partOpts = { highWaterMark: cfg.partHwm };
	  this._pause = false;

	  const self = this;
	  this._hparser = new HeaderParser(cfg);
	  this._hparser.on('header', function (header) {
	    self._inHeader = false;
	    self._part.emit('header', header);
	  });
	}
	inherits(Dicer, WritableStream);

	Dicer.prototype.emit = function (ev) {
	  if (ev === 'finish' && !this._realFinish) {
	    if (!this._finished) {
	      const self = this;
	      process.nextTick(function () {
	        self.emit('error', new Error('Unexpected end of multipart data'));
	        if (self._part && !self._ignoreData) {
	          const type = (self._isPreamble ? 'Preamble' : 'Part');
	          self._part.emit('error', new Error(type + ' terminated early due to unexpected end of multipart data'));
	          self._part.push(null);
	          process.nextTick(function () {
	            self._realFinish = true;
	            self.emit('finish');
	            self._realFinish = false;
	          });
	          return
	        }
	        self._realFinish = true;
	        self.emit('finish');
	        self._realFinish = false;
	      });
	    }
	  } else { WritableStream.prototype.emit.apply(this, arguments); }
	};

	Dicer.prototype._write = function (data, encoding, cb) {
	  // ignore unexpected data (e.g. extra trailer data after finished)
	  if (!this._hparser && !this._bparser) { return cb() }

	  if (this._headerFirst && this._isPreamble) {
	    if (!this._part) {
	      this._part = new PartStream(this._partOpts);
	      if (this.listenerCount('preamble') !== 0) { this.emit('preamble', this._part); } else { this._ignore(); }
	    }
	    const r = this._hparser.push(data);
	    if (!this._inHeader && r !== undefined && r < data.length) { data = data.slice(r); } else { return cb() }
	  }

	  // allows for "easier" testing
	  if (this._firstWrite) {
	    this._bparser.push(B_CRLF);
	    this._firstWrite = false;
	  }

	  this._bparser.push(data);

	  if (this._pause) { this._cb = cb; } else { cb(); }
	};

	Dicer.prototype.reset = function () {
	  this._part = undefined;
	  this._bparser = undefined;
	  this._hparser = undefined;
	};

	Dicer.prototype.setBoundary = function (boundary) {
	  const self = this;
	  this._bparser = new StreamSearch('\r\n--' + boundary);
	  this._bparser.on('info', function (isMatch, data, start, end) {
	    self._oninfo(isMatch, data, start, end);
	  });
	};

	Dicer.prototype._ignore = function () {
	  if (this._part && !this._ignoreData) {
	    this._ignoreData = true;
	    this._part.on('error', EMPTY_FN);
	    // we must perform some kind of read on the stream even though we are
	    // ignoring the data, otherwise node's Readable stream will not emit 'end'
	    // after pushing null to the stream
	    this._part.resume();
	  }
	};

	Dicer.prototype._oninfo = function (isMatch, data, start, end) {
	  let buf; const self = this; let i = 0; let r; let shouldWriteMore = true;

	  if (!this._part && this._justMatched && data) {
	    while (this._dashes < 2 && (start + i) < end) {
	      if (data[start + i] === DASH) {
	        ++i;
	        ++this._dashes;
	      } else {
	        if (this._dashes) { buf = B_ONEDASH; }
	        this._dashes = 0;
	        break
	      }
	    }
	    if (this._dashes === 2) {
	      if ((start + i) < end && this.listenerCount('trailer') !== 0) { this.emit('trailer', data.slice(start + i, end)); }
	      this.reset();
	      this._finished = true;
	      // no more parts will be added
	      if (self._parts === 0) {
	        self._realFinish = true;
	        self.emit('finish');
	        self._realFinish = false;
	      }
	    }
	    if (this._dashes) { return }
	  }
	  if (this._justMatched) { this._justMatched = false; }
	  if (!this._part) {
	    this._part = new PartStream(this._partOpts);
	    this._part._read = function (n) {
	      self._unpause();
	    };
	    if (this._isPreamble && this.listenerCount('preamble') !== 0) {
	      this.emit('preamble', this._part);
	    } else if (this._isPreamble !== true && this.listenerCount('part') !== 0) {
	      this.emit('part', this._part);
	    } else {
	      this._ignore();
	    }
	    if (!this._isPreamble) { this._inHeader = true; }
	  }
	  if (data && start < end && !this._ignoreData) {
	    if (this._isPreamble || !this._inHeader) {
	      if (buf) { shouldWriteMore = this._part.push(buf); }
	      shouldWriteMore = this._part.push(data.slice(start, end));
	      if (!shouldWriteMore) { this._pause = true; }
	    } else if (!this._isPreamble && this._inHeader) {
	      if (buf) { this._hparser.push(buf); }
	      r = this._hparser.push(data.slice(start, end));
	      if (!this._inHeader && r !== undefined && r < end) { this._oninfo(false, data, start + r, end); }
	    }
	  }
	  if (isMatch) {
	    this._hparser.reset();
	    if (this._isPreamble) { this._isPreamble = false; } else {
	      if (start !== end) {
	        ++this._parts;
	        this._part.on('end', function () {
	          if (--self._parts === 0) {
	            if (self._finished) {
	              self._realFinish = true;
	              self.emit('finish');
	              self._realFinish = false;
	            } else {
	              self._unpause();
	            }
	          }
	        });
	      }
	    }
	    this._part.push(null);
	    this._part = undefined;
	    this._ignoreData = false;
	    this._justMatched = true;
	    this._dashes = 0;
	  }
	};

	Dicer.prototype._unpause = function () {
	  if (!this._pause) { return }

	  this._pause = false;
	  if (this._cb) {
	    const cb = this._cb;
	    this._cb = undefined;
	    cb();
	  }
	};

	Dicer_1 = Dicer;
	return Dicer_1;
}

var decodeText_1;
var hasRequiredDecodeText;

function requireDecodeText () {
	if (hasRequiredDecodeText) return decodeText_1;
	hasRequiredDecodeText = 1;

	// Node has always utf-8
	const utf8Decoder = new TextDecoder('utf-8');
	const textDecoders = new Map([
	  ['utf-8', utf8Decoder],
	  ['utf8', utf8Decoder]
	]);

	function getDecoder (charset) {
	  let lc;
	  while (true) {
	    switch (charset) {
	      case 'utf-8':
	      case 'utf8':
	        return decoders.utf8
	      case 'latin1':
	      case 'ascii': // TODO: Make these a separate, strict decoder?
	      case 'us-ascii':
	      case 'iso-8859-1':
	      case 'iso8859-1':
	      case 'iso88591':
	      case 'iso_8859-1':
	      case 'windows-1252':
	      case 'iso_8859-1:1987':
	      case 'cp1252':
	      case 'x-cp1252':
	        return decoders.latin1
	      case 'utf16le':
	      case 'utf-16le':
	      case 'ucs2':
	      case 'ucs-2':
	        return decoders.utf16le
	      case 'base64':
	        return decoders.base64
	      default:
	        if (lc === undefined) {
	          lc = true;
	          charset = charset.toLowerCase();
	          continue
	        }
	        return decoders.other.bind(charset)
	    }
	  }
	}

	const decoders = {
	  utf8: (data, sourceEncoding) => {
	    if (data.length === 0) {
	      return ''
	    }
	    if (typeof data === 'string') {
	      data = Buffer.from(data, sourceEncoding);
	    }
	    return data.utf8Slice(0, data.length)
	  },

	  latin1: (data, sourceEncoding) => {
	    if (data.length === 0) {
	      return ''
	    }
	    if (typeof data === 'string') {
	      return data
	    }
	    return data.latin1Slice(0, data.length)
	  },

	  utf16le: (data, sourceEncoding) => {
	    if (data.length === 0) {
	      return ''
	    }
	    if (typeof data === 'string') {
	      data = Buffer.from(data, sourceEncoding);
	    }
	    return data.ucs2Slice(0, data.length)
	  },

	  base64: (data, sourceEncoding) => {
	    if (data.length === 0) {
	      return ''
	    }
	    if (typeof data === 'string') {
	      data = Buffer.from(data, sourceEncoding);
	    }
	    return data.base64Slice(0, data.length)
	  },

	  other: (data, sourceEncoding) => {
	    if (data.length === 0) {
	      return ''
	    }
	    if (typeof data === 'string') {
	      data = Buffer.from(data, sourceEncoding);
	    }

	    if (textDecoders.has(this.toString())) {
	      try {
	        return textDecoders.get(this).decode(data)
	      } catch {}
	    }
	    return typeof data === 'string'
	      ? data
	      : data.toString()
	  }
	};

	function decodeText (text, sourceEncoding, destEncoding) {
	  if (text) {
	    return getDecoder(destEncoding)(text, sourceEncoding)
	  }
	  return text
	}

	decodeText_1 = decodeText;
	return decodeText_1;
}

/* eslint-disable object-property-newline */

var parseParams_1;
var hasRequiredParseParams;

function requireParseParams () {
	if (hasRequiredParseParams) return parseParams_1;
	hasRequiredParseParams = 1;

	const decodeText = requireDecodeText();

	const RE_ENCODED = /%[a-fA-F0-9][a-fA-F0-9]/g;

	const EncodedLookup = {
	  '%00': '\x00', '%01': '\x01', '%02': '\x02', '%03': '\x03', '%04': '\x04',
	  '%05': '\x05', '%06': '\x06', '%07': '\x07', '%08': '\x08', '%09': '\x09',
	  '%0a': '\x0a', '%0A': '\x0a', '%0b': '\x0b', '%0B': '\x0b', '%0c': '\x0c',
	  '%0C': '\x0c', '%0d': '\x0d', '%0D': '\x0d', '%0e': '\x0e', '%0E': '\x0e',
	  '%0f': '\x0f', '%0F': '\x0f', '%10': '\x10', '%11': '\x11', '%12': '\x12',
	  '%13': '\x13', '%14': '\x14', '%15': '\x15', '%16': '\x16', '%17': '\x17',
	  '%18': '\x18', '%19': '\x19', '%1a': '\x1a', '%1A': '\x1a', '%1b': '\x1b',
	  '%1B': '\x1b', '%1c': '\x1c', '%1C': '\x1c', '%1d': '\x1d', '%1D': '\x1d',
	  '%1e': '\x1e', '%1E': '\x1e', '%1f': '\x1f', '%1F': '\x1f', '%20': '\x20',
	  '%21': '\x21', '%22': '\x22', '%23': '\x23', '%24': '\x24', '%25': '\x25',
	  '%26': '\x26', '%27': '\x27', '%28': '\x28', '%29': '\x29', '%2a': '\x2a',
	  '%2A': '\x2a', '%2b': '\x2b', '%2B': '\x2b', '%2c': '\x2c', '%2C': '\x2c',
	  '%2d': '\x2d', '%2D': '\x2d', '%2e': '\x2e', '%2E': '\x2e', '%2f': '\x2f',
	  '%2F': '\x2f', '%30': '\x30', '%31': '\x31', '%32': '\x32', '%33': '\x33',
	  '%34': '\x34', '%35': '\x35', '%36': '\x36', '%37': '\x37', '%38': '\x38',
	  '%39': '\x39', '%3a': '\x3a', '%3A': '\x3a', '%3b': '\x3b', '%3B': '\x3b',
	  '%3c': '\x3c', '%3C': '\x3c', '%3d': '\x3d', '%3D': '\x3d', '%3e': '\x3e',
	  '%3E': '\x3e', '%3f': '\x3f', '%3F': '\x3f', '%40': '\x40', '%41': '\x41',
	  '%42': '\x42', '%43': '\x43', '%44': '\x44', '%45': '\x45', '%46': '\x46',
	  '%47': '\x47', '%48': '\x48', '%49': '\x49', '%4a': '\x4a', '%4A': '\x4a',
	  '%4b': '\x4b', '%4B': '\x4b', '%4c': '\x4c', '%4C': '\x4c', '%4d': '\x4d',
	  '%4D': '\x4d', '%4e': '\x4e', '%4E': '\x4e', '%4f': '\x4f', '%4F': '\x4f',
	  '%50': '\x50', '%51': '\x51', '%52': '\x52', '%53': '\x53', '%54': '\x54',
	  '%55': '\x55', '%56': '\x56', '%57': '\x57', '%58': '\x58', '%59': '\x59',
	  '%5a': '\x5a', '%5A': '\x5a', '%5b': '\x5b', '%5B': '\x5b', '%5c': '\x5c',
	  '%5C': '\x5c', '%5d': '\x5d', '%5D': '\x5d', '%5e': '\x5e', '%5E': '\x5e',
	  '%5f': '\x5f', '%5F': '\x5f', '%60': '\x60', '%61': '\x61', '%62': '\x62',
	  '%63': '\x63', '%64': '\x64', '%65': '\x65', '%66': '\x66', '%67': '\x67',
	  '%68': '\x68', '%69': '\x69', '%6a': '\x6a', '%6A': '\x6a', '%6b': '\x6b',
	  '%6B': '\x6b', '%6c': '\x6c', '%6C': '\x6c', '%6d': '\x6d', '%6D': '\x6d',
	  '%6e': '\x6e', '%6E': '\x6e', '%6f': '\x6f', '%6F': '\x6f', '%70': '\x70',
	  '%71': '\x71', '%72': '\x72', '%73': '\x73', '%74': '\x74', '%75': '\x75',
	  '%76': '\x76', '%77': '\x77', '%78': '\x78', '%79': '\x79', '%7a': '\x7a',
	  '%7A': '\x7a', '%7b': '\x7b', '%7B': '\x7b', '%7c': '\x7c', '%7C': '\x7c',
	  '%7d': '\x7d', '%7D': '\x7d', '%7e': '\x7e', '%7E': '\x7e', '%7f': '\x7f',
	  '%7F': '\x7f', '%80': '\x80', '%81': '\x81', '%82': '\x82', '%83': '\x83',
	  '%84': '\x84', '%85': '\x85', '%86': '\x86', '%87': '\x87', '%88': '\x88',
	  '%89': '\x89', '%8a': '\x8a', '%8A': '\x8a', '%8b': '\x8b', '%8B': '\x8b',
	  '%8c': '\x8c', '%8C': '\x8c', '%8d': '\x8d', '%8D': '\x8d', '%8e': '\x8e',
	  '%8E': '\x8e', '%8f': '\x8f', '%8F': '\x8f', '%90': '\x90', '%91': '\x91',
	  '%92': '\x92', '%93': '\x93', '%94': '\x94', '%95': '\x95', '%96': '\x96',
	  '%97': '\x97', '%98': '\x98', '%99': '\x99', '%9a': '\x9a', '%9A': '\x9a',
	  '%9b': '\x9b', '%9B': '\x9b', '%9c': '\x9c', '%9C': '\x9c', '%9d': '\x9d',
	  '%9D': '\x9d', '%9e': '\x9e', '%9E': '\x9e', '%9f': '\x9f', '%9F': '\x9f',
	  '%a0': '\xa0', '%A0': '\xa0', '%a1': '\xa1', '%A1': '\xa1', '%a2': '\xa2',
	  '%A2': '\xa2', '%a3': '\xa3', '%A3': '\xa3', '%a4': '\xa4', '%A4': '\xa4',
	  '%a5': '\xa5', '%A5': '\xa5', '%a6': '\xa6', '%A6': '\xa6', '%a7': '\xa7',
	  '%A7': '\xa7', '%a8': '\xa8', '%A8': '\xa8', '%a9': '\xa9', '%A9': '\xa9',
	  '%aa': '\xaa', '%Aa': '\xaa', '%aA': '\xaa', '%AA': '\xaa', '%ab': '\xab',
	  '%Ab': '\xab', '%aB': '\xab', '%AB': '\xab', '%ac': '\xac', '%Ac': '\xac',
	  '%aC': '\xac', '%AC': '\xac', '%ad': '\xad', '%Ad': '\xad', '%aD': '\xad',
	  '%AD': '\xad', '%ae': '\xae', '%Ae': '\xae', '%aE': '\xae', '%AE': '\xae',
	  '%af': '\xaf', '%Af': '\xaf', '%aF': '\xaf', '%AF': '\xaf', '%b0': '\xb0',
	  '%B0': '\xb0', '%b1': '\xb1', '%B1': '\xb1', '%b2': '\xb2', '%B2': '\xb2',
	  '%b3': '\xb3', '%B3': '\xb3', '%b4': '\xb4', '%B4': '\xb4', '%b5': '\xb5',
	  '%B5': '\xb5', '%b6': '\xb6', '%B6': '\xb6', '%b7': '\xb7', '%B7': '\xb7',
	  '%b8': '\xb8', '%B8': '\xb8', '%b9': '\xb9', '%B9': '\xb9', '%ba': '\xba',
	  '%Ba': '\xba', '%bA': '\xba', '%BA': '\xba', '%bb': '\xbb', '%Bb': '\xbb',
	  '%bB': '\xbb', '%BB': '\xbb', '%bc': '\xbc', '%Bc': '\xbc', '%bC': '\xbc',
	  '%BC': '\xbc', '%bd': '\xbd', '%Bd': '\xbd', '%bD': '\xbd', '%BD': '\xbd',
	  '%be': '\xbe', '%Be': '\xbe', '%bE': '\xbe', '%BE': '\xbe', '%bf': '\xbf',
	  '%Bf': '\xbf', '%bF': '\xbf', '%BF': '\xbf', '%c0': '\xc0', '%C0': '\xc0',
	  '%c1': '\xc1', '%C1': '\xc1', '%c2': '\xc2', '%C2': '\xc2', '%c3': '\xc3',
	  '%C3': '\xc3', '%c4': '\xc4', '%C4': '\xc4', '%c5': '\xc5', '%C5': '\xc5',
	  '%c6': '\xc6', '%C6': '\xc6', '%c7': '\xc7', '%C7': '\xc7', '%c8': '\xc8',
	  '%C8': '\xc8', '%c9': '\xc9', '%C9': '\xc9', '%ca': '\xca', '%Ca': '\xca',
	  '%cA': '\xca', '%CA': '\xca', '%cb': '\xcb', '%Cb': '\xcb', '%cB': '\xcb',
	  '%CB': '\xcb', '%cc': '\xcc', '%Cc': '\xcc', '%cC': '\xcc', '%CC': '\xcc',
	  '%cd': '\xcd', '%Cd': '\xcd', '%cD': '\xcd', '%CD': '\xcd', '%ce': '\xce',
	  '%Ce': '\xce', '%cE': '\xce', '%CE': '\xce', '%cf': '\xcf', '%Cf': '\xcf',
	  '%cF': '\xcf', '%CF': '\xcf', '%d0': '\xd0', '%D0': '\xd0', '%d1': '\xd1',
	  '%D1': '\xd1', '%d2': '\xd2', '%D2': '\xd2', '%d3': '\xd3', '%D3': '\xd3',
	  '%d4': '\xd4', '%D4': '\xd4', '%d5': '\xd5', '%D5': '\xd5', '%d6': '\xd6',
	  '%D6': '\xd6', '%d7': '\xd7', '%D7': '\xd7', '%d8': '\xd8', '%D8': '\xd8',
	  '%d9': '\xd9', '%D9': '\xd9', '%da': '\xda', '%Da': '\xda', '%dA': '\xda',
	  '%DA': '\xda', '%db': '\xdb', '%Db': '\xdb', '%dB': '\xdb', '%DB': '\xdb',
	  '%dc': '\xdc', '%Dc': '\xdc', '%dC': '\xdc', '%DC': '\xdc', '%dd': '\xdd',
	  '%Dd': '\xdd', '%dD': '\xdd', '%DD': '\xdd', '%de': '\xde', '%De': '\xde',
	  '%dE': '\xde', '%DE': '\xde', '%df': '\xdf', '%Df': '\xdf', '%dF': '\xdf',
	  '%DF': '\xdf', '%e0': '\xe0', '%E0': '\xe0', '%e1': '\xe1', '%E1': '\xe1',
	  '%e2': '\xe2', '%E2': '\xe2', '%e3': '\xe3', '%E3': '\xe3', '%e4': '\xe4',
	  '%E4': '\xe4', '%e5': '\xe5', '%E5': '\xe5', '%e6': '\xe6', '%E6': '\xe6',
	  '%e7': '\xe7', '%E7': '\xe7', '%e8': '\xe8', '%E8': '\xe8', '%e9': '\xe9',
	  '%E9': '\xe9', '%ea': '\xea', '%Ea': '\xea', '%eA': '\xea', '%EA': '\xea',
	  '%eb': '\xeb', '%Eb': '\xeb', '%eB': '\xeb', '%EB': '\xeb', '%ec': '\xec',
	  '%Ec': '\xec', '%eC': '\xec', '%EC': '\xec', '%ed': '\xed', '%Ed': '\xed',
	  '%eD': '\xed', '%ED': '\xed', '%ee': '\xee', '%Ee': '\xee', '%eE': '\xee',
	  '%EE': '\xee', '%ef': '\xef', '%Ef': '\xef', '%eF': '\xef', '%EF': '\xef',
	  '%f0': '\xf0', '%F0': '\xf0', '%f1': '\xf1', '%F1': '\xf1', '%f2': '\xf2',
	  '%F2': '\xf2', '%f3': '\xf3', '%F3': '\xf3', '%f4': '\xf4', '%F4': '\xf4',
	  '%f5': '\xf5', '%F5': '\xf5', '%f6': '\xf6', '%F6': '\xf6', '%f7': '\xf7',
	  '%F7': '\xf7', '%f8': '\xf8', '%F8': '\xf8', '%f9': '\xf9', '%F9': '\xf9',
	  '%fa': '\xfa', '%Fa': '\xfa', '%fA': '\xfa', '%FA': '\xfa', '%fb': '\xfb',
	  '%Fb': '\xfb', '%fB': '\xfb', '%FB': '\xfb', '%fc': '\xfc', '%Fc': '\xfc',
	  '%fC': '\xfc', '%FC': '\xfc', '%fd': '\xfd', '%Fd': '\xfd', '%fD': '\xfd',
	  '%FD': '\xfd', '%fe': '\xfe', '%Fe': '\xfe', '%fE': '\xfe', '%FE': '\xfe',
	  '%ff': '\xff', '%Ff': '\xff', '%fF': '\xff', '%FF': '\xff'
	};

	function encodedReplacer (match) {
	  return EncodedLookup[match]
	}

	const STATE_KEY = 0;
	const STATE_VALUE = 1;
	const STATE_CHARSET = 2;
	const STATE_LANG = 3;

	function parseParams (str) {
	  const res = [];
	  let state = STATE_KEY;
	  let charset = '';
	  let inquote = false;
	  let escaping = false;
	  let p = 0;
	  let tmp = '';
	  const len = str.length;

	  for (var i = 0; i < len; ++i) { // eslint-disable-line no-var
	    const char = str[i];
	    if (char === '\\' && inquote) {
	      if (escaping) { escaping = false; } else {
	        escaping = true;
	        continue
	      }
	    } else if (char === '"') {
	      if (!escaping) {
	        if (inquote) {
	          inquote = false;
	          state = STATE_KEY;
	        } else { inquote = true; }
	        continue
	      } else { escaping = false; }
	    } else {
	      if (escaping && inquote) { tmp += '\\'; }
	      escaping = false;
	      if ((state === STATE_CHARSET || state === STATE_LANG) && char === "'") {
	        if (state === STATE_CHARSET) {
	          state = STATE_LANG;
	          charset = tmp.substring(1);
	        } else { state = STATE_VALUE; }
	        tmp = '';
	        continue
	      } else if (state === STATE_KEY &&
	        (char === '*' || char === '=') &&
	        res.length) {
	        state = char === '*'
	          ? STATE_CHARSET
	          : STATE_VALUE;
	        res[p] = [tmp, undefined];
	        tmp = '';
	        continue
	      } else if (!inquote && char === ';') {
	        state = STATE_KEY;
	        if (charset) {
	          if (tmp.length) {
	            tmp = decodeText(tmp.replace(RE_ENCODED, encodedReplacer),
	              'binary',
	              charset);
	          }
	          charset = '';
	        } else if (tmp.length) {
	          tmp = decodeText(tmp, 'binary', 'utf8');
	        }
	        if (res[p] === undefined) { res[p] = tmp; } else { res[p][1] = tmp; }
	        tmp = '';
	        ++p;
	        continue
	      } else if (!inquote && (char === ' ' || char === '\t')) { continue }
	    }
	    tmp += char;
	  }
	  if (charset && tmp.length) {
	    tmp = decodeText(tmp.replace(RE_ENCODED, encodedReplacer),
	      'binary',
	      charset);
	  } else if (tmp) {
	    tmp = decodeText(tmp, 'binary', 'utf8');
	  }

	  if (res[p] === undefined) {
	    if (tmp) { res[p] = tmp; }
	  } else { res[p][1] = tmp; }

	  return res
	}

	parseParams_1 = parseParams;
	return parseParams_1;
}

var basename;
var hasRequiredBasename;

function requireBasename () {
	if (hasRequiredBasename) return basename;
	hasRequiredBasename = 1;

	basename = function basename (path) {
	  if (typeof path !== 'string') { return '' }
	  for (var i = path.length - 1; i >= 0; --i) { // eslint-disable-line no-var
	    switch (path.charCodeAt(i)) {
	      case 0x2F: // '/'
	      case 0x5C: // '\'
	        path = path.slice(i + 1);
	        return (path === '..' || path === '.' ? '' : path)
	    }
	  }
	  return (path === '..' || path === '.' ? '' : path)
	};
	return basename;
}

var multipart;
var hasRequiredMultipart;

function requireMultipart () {
	if (hasRequiredMultipart) return multipart;
	hasRequiredMultipart = 1;

	// TODO:
	//  * support 1 nested multipart level
	//    (see second multipart example here:
	//     http://www.w3.org/TR/html401/interact/forms.html#didx-multipartform-data)
	//  * support limits.fieldNameSize
	//     -- this will require modifications to utils.parseParams

	const { Readable } = ie;
	const { inherits } = require$$1$1;

	const Dicer = requireDicer();

	const parseParams = requireParseParams();
	const decodeText = requireDecodeText();
	const basename = requireBasename();
	const getLimit = requireGetLimit();

	const RE_BOUNDARY = /^boundary$/i;
	const RE_FIELD = /^form-data$/i;
	const RE_CHARSET = /^charset$/i;
	const RE_FILENAME = /^filename$/i;
	const RE_NAME = /^name$/i;

	Multipart.detect = /^multipart\/form-data/i;
	function Multipart (boy, cfg) {
	  let i;
	  let len;
	  const self = this;
	  let boundary;
	  const limits = cfg.limits;
	  const isPartAFile = cfg.isPartAFile || ((fieldName, contentType, fileName) => (contentType === 'application/octet-stream' || fileName !== undefined));
	  const parsedConType = cfg.parsedConType || [];
	  const defCharset = cfg.defCharset || 'utf8';
	  const preservePath = cfg.preservePath;
	  const fileOpts = { highWaterMark: cfg.fileHwm };

	  for (i = 0, len = parsedConType.length; i < len; ++i) {
	    if (Array.isArray(parsedConType[i]) &&
	      RE_BOUNDARY.test(parsedConType[i][0])) {
	      boundary = parsedConType[i][1];
	      break
	    }
	  }

	  function checkFinished () {
	    if (nends === 0 && finished && !boy._done) {
	      finished = false;
	      self.end();
	    }
	  }

	  if (typeof boundary !== 'string') { throw new Error('Multipart: Boundary not found') }

	  const fieldSizeLimit = getLimit(limits, 'fieldSize', 1 * 1024 * 1024);
	  const fileSizeLimit = getLimit(limits, 'fileSize', Infinity);
	  const filesLimit = getLimit(limits, 'files', Infinity);
	  const fieldsLimit = getLimit(limits, 'fields', Infinity);
	  const partsLimit = getLimit(limits, 'parts', Infinity);
	  const headerPairsLimit = getLimit(limits, 'headerPairs', 2000);
	  const headerSizeLimit = getLimit(limits, 'headerSize', 80 * 1024);

	  let nfiles = 0;
	  let nfields = 0;
	  let nends = 0;
	  let curFile;
	  let curField;
	  let finished = false;

	  this._needDrain = false;
	  this._pause = false;
	  this._cb = undefined;
	  this._nparts = 0;
	  this._boy = boy;

	  const parserCfg = {
	    boundary,
	    maxHeaderPairs: headerPairsLimit,
	    maxHeaderSize: headerSizeLimit,
	    partHwm: fileOpts.highWaterMark,
	    highWaterMark: cfg.highWaterMark
	  };

	  this.parser = new Dicer(parserCfg);
	  this.parser.on('drain', function () {
	    self._needDrain = false;
	    if (self._cb && !self._pause) {
	      const cb = self._cb;
	      self._cb = undefined;
	      cb();
	    }
	  }).on('part', function onPart (part) {
	    if (++self._nparts > partsLimit) {
	      self.parser.removeListener('part', onPart);
	      self.parser.on('part', skipPart);
	      boy.hitPartsLimit = true;
	      boy.emit('partsLimit');
	      return skipPart(part)
	    }

	    // hack because streams2 _always_ doesn't emit 'end' until nextTick, so let
	    // us emit 'end' early since we know the part has ended if we are already
	    // seeing the next part
	    if (curField) {
	      const field = curField;
	      field.emit('end');
	      field.removeAllListeners('end');
	    }

	    part.on('header', function (header) {
	      let contype;
	      let fieldname;
	      let parsed;
	      let charset;
	      let encoding;
	      let filename;
	      let nsize = 0;

	      if (header['content-type']) {
	        parsed = parseParams(header['content-type'][0]);
	        if (parsed[0]) {
	          contype = parsed[0].toLowerCase();
	          for (i = 0, len = parsed.length; i < len; ++i) {
	            if (RE_CHARSET.test(parsed[i][0])) {
	              charset = parsed[i][1].toLowerCase();
	              break
	            }
	          }
	        }
	      }

	      if (contype === undefined) { contype = 'text/plain'; }
	      if (charset === undefined) { charset = defCharset; }

	      if (header['content-disposition']) {
	        parsed = parseParams(header['content-disposition'][0]);
	        if (!RE_FIELD.test(parsed[0])) { return skipPart(part) }
	        for (i = 0, len = parsed.length; i < len; ++i) {
	          if (RE_NAME.test(parsed[i][0])) {
	            fieldname = parsed[i][1];
	          } else if (RE_FILENAME.test(parsed[i][0])) {
	            filename = parsed[i][1];
	            if (!preservePath) { filename = basename(filename); }
	          }
	        }
	      } else { return skipPart(part) }

	      if (header['content-transfer-encoding']) { encoding = header['content-transfer-encoding'][0].toLowerCase(); } else { encoding = '7bit'; }

	      let onData,
	        onEnd;

	      if (isPartAFile(fieldname, contype, filename)) {
	        // file/binary field
	        if (nfiles === filesLimit) {
	          if (!boy.hitFilesLimit) {
	            boy.hitFilesLimit = true;
	            boy.emit('filesLimit');
	          }
	          return skipPart(part)
	        }

	        ++nfiles;

	        if (boy.listenerCount('file') === 0) {
	          self.parser._ignore();
	          return
	        }

	        ++nends;
	        const file = new FileStream(fileOpts);
	        curFile = file;
	        file.on('end', function () {
	          --nends;
	          self._pause = false;
	          checkFinished();
	          if (self._cb && !self._needDrain) {
	            const cb = self._cb;
	            self._cb = undefined;
	            cb();
	          }
	        });
	        file._read = function (n) {
	          if (!self._pause) { return }
	          self._pause = false;
	          if (self._cb && !self._needDrain) {
	            const cb = self._cb;
	            self._cb = undefined;
	            cb();
	          }
	        };
	        boy.emit('file', fieldname, file, filename, encoding, contype);

	        onData = function (data) {
	          if ((nsize += data.length) > fileSizeLimit) {
	            const extralen = fileSizeLimit - nsize + data.length;
	            if (extralen > 0) { file.push(data.slice(0, extralen)); }
	            file.truncated = true;
	            file.bytesRead = fileSizeLimit;
	            part.removeAllListeners('data');
	            file.emit('limit');
	            return
	          } else if (!file.push(data)) { self._pause = true; }

	          file.bytesRead = nsize;
	        };

	        onEnd = function () {
	          curFile = undefined;
	          file.push(null);
	        };
	      } else {
	        // non-file field
	        if (nfields === fieldsLimit) {
	          if (!boy.hitFieldsLimit) {
	            boy.hitFieldsLimit = true;
	            boy.emit('fieldsLimit');
	          }
	          return skipPart(part)
	        }

	        ++nfields;
	        ++nends;
	        let buffer = '';
	        let truncated = false;
	        curField = part;

	        onData = function (data) {
	          if ((nsize += data.length) > fieldSizeLimit) {
	            const extralen = (fieldSizeLimit - (nsize - data.length));
	            buffer += data.toString('binary', 0, extralen);
	            truncated = true;
	            part.removeAllListeners('data');
	          } else { buffer += data.toString('binary'); }
	        };

	        onEnd = function () {
	          curField = undefined;
	          if (buffer.length) { buffer = decodeText(buffer, 'binary', charset); }
	          boy.emit('field', fieldname, buffer, false, truncated, encoding, contype);
	          --nends;
	          checkFinished();
	        };
	      }

	      /* As of node@2efe4ab761666 (v0.10.29+/v0.11.14+), busboy had become
	         broken. Streams2/streams3 is a huge black box of confusion, but
	         somehow overriding the sync state seems to fix things again (and still
	         seems to work for previous node versions).
	      */
	      part._readableState.sync = false;

	      part.on('data', onData);
	      part.on('end', onEnd);
	    }).on('error', function (err) {
	      if (curFile) { curFile.emit('error', err); }
	    });
	  }).on('error', function (err) {
	    boy.emit('error', err);
	  }).on('finish', function () {
	    finished = true;
	    checkFinished();
	  });
	}

	Multipart.prototype.write = function (chunk, cb) {
	  const r = this.parser.write(chunk);
	  if (r && !this._pause) {
	    cb();
	  } else {
	    this._needDrain = !r;
	    this._cb = cb;
	  }
	};

	Multipart.prototype.end = function () {
	  const self = this;

	  if (self.parser.writable) {
	    self.parser.end();
	  } else if (!self._boy._done) {
	    process.nextTick(function () {
	      self._boy._done = true;
	      self._boy.emit('finish');
	    });
	  }
	};

	function skipPart (part) {
	  part.resume();
	}

	function FileStream (opts) {
	  Readable.call(this, opts);

	  this.bytesRead = 0;

	  this.truncated = false;
	}

	inherits(FileStream, Readable);

	FileStream.prototype._read = function (n) {};

	multipart = Multipart;
	return multipart;
}

var Decoder_1;
var hasRequiredDecoder;

function requireDecoder () {
	if (hasRequiredDecoder) return Decoder_1;
	hasRequiredDecoder = 1;

	const RE_PLUS = /\+/g;

	const HEX = [
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
	  0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	  0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
	];

	function Decoder () {
	  this.buffer = undefined;
	}
	Decoder.prototype.write = function (str) {
	  // Replace '+' with ' ' before decoding
	  str = str.replace(RE_PLUS, ' ');
	  let res = '';
	  let i = 0; let p = 0; const len = str.length;
	  for (; i < len; ++i) {
	    if (this.buffer !== undefined) {
	      if (!HEX[str.charCodeAt(i)]) {
	        res += '%' + this.buffer;
	        this.buffer = undefined;
	        --i; // retry character
	      } else {
	        this.buffer += str[i];
	        ++p;
	        if (this.buffer.length === 2) {
	          res += String.fromCharCode(parseInt(this.buffer, 16));
	          this.buffer = undefined;
	        }
	      }
	    } else if (str[i] === '%') {
	      if (i > p) {
	        res += str.substring(p, i);
	        p = i;
	      }
	      this.buffer = '';
	      ++p;
	    }
	  }
	  if (p < len && this.buffer === undefined) { res += str.substring(p); }
	  return res
	};
	Decoder.prototype.reset = function () {
	  this.buffer = undefined;
	};

	Decoder_1 = Decoder;
	return Decoder_1;
}

var urlencoded;
var hasRequiredUrlencoded;

function requireUrlencoded () {
	if (hasRequiredUrlencoded) return urlencoded;
	hasRequiredUrlencoded = 1;

	const Decoder = requireDecoder();
	const decodeText = requireDecodeText();
	const getLimit = requireGetLimit();

	const RE_CHARSET = /^charset$/i;

	UrlEncoded.detect = /^application\/x-www-form-urlencoded/i;
	function UrlEncoded (boy, cfg) {
	  const limits = cfg.limits;
	  const parsedConType = cfg.parsedConType;
	  this.boy = boy;

	  this.fieldSizeLimit = getLimit(limits, 'fieldSize', 1 * 1024 * 1024);
	  this.fieldNameSizeLimit = getLimit(limits, 'fieldNameSize', 100);
	  this.fieldsLimit = getLimit(limits, 'fields', Infinity);

	  let charset;
	  for (var i = 0, len = parsedConType.length; i < len; ++i) { // eslint-disable-line no-var
	    if (Array.isArray(parsedConType[i]) &&
	        RE_CHARSET.test(parsedConType[i][0])) {
	      charset = parsedConType[i][1].toLowerCase();
	      break
	    }
	  }

	  if (charset === undefined) { charset = cfg.defCharset || 'utf8'; }

	  this.decoder = new Decoder();
	  this.charset = charset;
	  this._fields = 0;
	  this._state = 'key';
	  this._checkingBytes = true;
	  this._bytesKey = 0;
	  this._bytesVal = 0;
	  this._key = '';
	  this._val = '';
	  this._keyTrunc = false;
	  this._valTrunc = false;
	  this._hitLimit = false;
	}

	UrlEncoded.prototype.write = function (data, cb) {
	  if (this._fields === this.fieldsLimit) {
	    if (!this.boy.hitFieldsLimit) {
	      this.boy.hitFieldsLimit = true;
	      this.boy.emit('fieldsLimit');
	    }
	    return cb()
	  }

	  let idxeq; let idxamp; let i; let p = 0; const len = data.length;

	  while (p < len) {
	    if (this._state === 'key') {
	      idxeq = idxamp = undefined;
	      for (i = p; i < len; ++i) {
	        if (!this._checkingBytes) { ++p; }
	        if (data[i] === 0x3D/* = */) {
	          idxeq = i;
	          break
	        } else if (data[i] === 0x26/* & */) {
	          idxamp = i;
	          break
	        }
	        if (this._checkingBytes && this._bytesKey === this.fieldNameSizeLimit) {
	          this._hitLimit = true;
	          break
	        } else if (this._checkingBytes) { ++this._bytesKey; }
	      }

	      if (idxeq !== undefined) {
	        // key with assignment
	        if (idxeq > p) { this._key += this.decoder.write(data.toString('binary', p, idxeq)); }
	        this._state = 'val';

	        this._hitLimit = false;
	        this._checkingBytes = true;
	        this._val = '';
	        this._bytesVal = 0;
	        this._valTrunc = false;
	        this.decoder.reset();

	        p = idxeq + 1;
	      } else if (idxamp !== undefined) {
	        // key with no assignment
	        ++this._fields;
	        let key; const keyTrunc = this._keyTrunc;
	        if (idxamp > p) { key = (this._key += this.decoder.write(data.toString('binary', p, idxamp))); } else { key = this._key; }

	        this._hitLimit = false;
	        this._checkingBytes = true;
	        this._key = '';
	        this._bytesKey = 0;
	        this._keyTrunc = false;
	        this.decoder.reset();

	        if (key.length) {
	          this.boy.emit('field', decodeText(key, 'binary', this.charset),
	            '',
	            keyTrunc,
	            false);
	        }

	        p = idxamp + 1;
	        if (this._fields === this.fieldsLimit) { return cb() }
	      } else if (this._hitLimit) {
	        // we may not have hit the actual limit if there are encoded bytes...
	        if (i > p) { this._key += this.decoder.write(data.toString('binary', p, i)); }
	        p = i;
	        if ((this._bytesKey = this._key.length) === this.fieldNameSizeLimit) {
	          // yep, we actually did hit the limit
	          this._checkingBytes = false;
	          this._keyTrunc = true;
	        }
	      } else {
	        if (p < len) { this._key += this.decoder.write(data.toString('binary', p)); }
	        p = len;
	      }
	    } else {
	      idxamp = undefined;
	      for (i = p; i < len; ++i) {
	        if (!this._checkingBytes) { ++p; }
	        if (data[i] === 0x26/* & */) {
	          idxamp = i;
	          break
	        }
	        if (this._checkingBytes && this._bytesVal === this.fieldSizeLimit) {
	          this._hitLimit = true;
	          break
	        } else if (this._checkingBytes) { ++this._bytesVal; }
	      }

	      if (idxamp !== undefined) {
	        ++this._fields;
	        if (idxamp > p) { this._val += this.decoder.write(data.toString('binary', p, idxamp)); }
	        this.boy.emit('field', decodeText(this._key, 'binary', this.charset),
	          decodeText(this._val, 'binary', this.charset),
	          this._keyTrunc,
	          this._valTrunc);
	        this._state = 'key';

	        this._hitLimit = false;
	        this._checkingBytes = true;
	        this._key = '';
	        this._bytesKey = 0;
	        this._keyTrunc = false;
	        this.decoder.reset();

	        p = idxamp + 1;
	        if (this._fields === this.fieldsLimit) { return cb() }
	      } else if (this._hitLimit) {
	        // we may not have hit the actual limit if there are encoded bytes...
	        if (i > p) { this._val += this.decoder.write(data.toString('binary', p, i)); }
	        p = i;
	        if ((this._val === '' && this.fieldSizeLimit === 0) ||
	            (this._bytesVal = this._val.length) === this.fieldSizeLimit) {
	          // yep, we actually did hit the limit
	          this._checkingBytes = false;
	          this._valTrunc = true;
	        }
	      } else {
	        if (p < len) { this._val += this.decoder.write(data.toString('binary', p)); }
	        p = len;
	      }
	    }
	  }
	  cb();
	};

	UrlEncoded.prototype.end = function () {
	  if (this.boy._done) { return }

	  if (this._state === 'key' && this._key.length > 0) {
	    this.boy.emit('field', decodeText(this._key, 'binary', this.charset),
	      '',
	      this._keyTrunc,
	      false);
	  } else if (this._state === 'val') {
	    this.boy.emit('field', decodeText(this._key, 'binary', this.charset),
	      decodeText(this._val, 'binary', this.charset),
	      this._keyTrunc,
	      this._valTrunc);
	  }
	  this.boy._done = true;
	  this.boy.emit('finish');
	};

	urlencoded = UrlEncoded;
	return urlencoded;
}

var hasRequiredMain$1;

function requireMain$1 () {
	if (hasRequiredMain$1) return main$2.exports;
	hasRequiredMain$1 = 1;

	const WritableStream = ie.Writable;
	const { inherits } = require$$1$1;
	const Dicer = requireDicer();

	const MultipartParser = requireMultipart();
	const UrlencodedParser = requireUrlencoded();
	const parseParams = requireParseParams();

	function Busboy (opts) {
	  if (!(this instanceof Busboy)) { return new Busboy(opts) }

	  if (typeof opts !== 'object') {
	    throw new TypeError('Busboy expected an options-Object.')
	  }
	  if (typeof opts.headers !== 'object') {
	    throw new TypeError('Busboy expected an options-Object with headers-attribute.')
	  }
	  if (typeof opts.headers['content-type'] !== 'string') {
	    throw new TypeError('Missing Content-Type-header.')
	  }

	  const {
	    headers,
	    ...streamOptions
	  } = opts;

	  this.opts = {
	    autoDestroy: false,
	    ...streamOptions
	  };
	  WritableStream.call(this, this.opts);

	  this._done = false;
	  this._parser = this.getParserByHeaders(headers);
	  this._finished = false;
	}
	inherits(Busboy, WritableStream);

	Busboy.prototype.emit = function (ev) {
	  if (ev === 'finish') {
	    if (!this._done) {
	      this._parser?.end();
	      return
	    } else if (this._finished) {
	      return
	    }
	    this._finished = true;
	  }
	  WritableStream.prototype.emit.apply(this, arguments);
	};

	Busboy.prototype.getParserByHeaders = function (headers) {
	  const parsed = parseParams(headers['content-type']);

	  const cfg = {
	    defCharset: this.opts.defCharset,
	    fileHwm: this.opts.fileHwm,
	    headers,
	    highWaterMark: this.opts.highWaterMark,
	    isPartAFile: this.opts.isPartAFile,
	    limits: this.opts.limits,
	    parsedConType: parsed,
	    preservePath: this.opts.preservePath
	  };

	  if (MultipartParser.detect.test(parsed[0])) {
	    return new MultipartParser(this, cfg)
	  }
	  if (UrlencodedParser.detect.test(parsed[0])) {
	    return new UrlencodedParser(this, cfg)
	  }
	  throw new Error('Unsupported Content-Type.')
	};

	Busboy.prototype._write = function (chunk, encoding, cb) {
	  this._parser.write(chunk, cb);
	};

	main$2.exports = Busboy;
	main$2.exports.default = Busboy;
	main$2.exports.Busboy = Busboy;

	main$2.exports.Dicer = Dicer;
	return main$2.exports;
}

var constants$5;
var hasRequiredConstants$5;

function requireConstants$5 () {
	if (hasRequiredConstants$5) return constants$5;
	hasRequiredConstants$5 = 1;

	const { MessageChannel, receiveMessageOnPort } = require$$0$8;

	const corsSafeListedMethods = ['GET', 'HEAD', 'POST'];
	const corsSafeListedMethodsSet = new Set(corsSafeListedMethods);

	const nullBodyStatus = [101, 204, 205, 304];

	const redirectStatus = [301, 302, 303, 307, 308];
	const redirectStatusSet = new Set(redirectStatus);

	// https://fetch.spec.whatwg.org/#block-bad-port
	const badPorts = [
	  '1', '7', '9', '11', '13', '15', '17', '19', '20', '21', '22', '23', '25', '37', '42', '43', '53', '69', '77', '79',
	  '87', '95', '101', '102', '103', '104', '109', '110', '111', '113', '115', '117', '119', '123', '135', '137',
	  '139', '143', '161', '179', '389', '427', '465', '512', '513', '514', '515', '526', '530', '531', '532',
	  '540', '548', '554', '556', '563', '587', '601', '636', '989', '990', '993', '995', '1719', '1720', '1723',
	  '2049', '3659', '4045', '5060', '5061', '6000', '6566', '6665', '6666', '6667', '6668', '6669', '6697',
	  '10080'
	];

	const badPortsSet = new Set(badPorts);

	// https://w3c.github.io/webappsec-referrer-policy/#referrer-policies
	const referrerPolicy = [
	  '',
	  'no-referrer',
	  'no-referrer-when-downgrade',
	  'same-origin',
	  'origin',
	  'strict-origin',
	  'origin-when-cross-origin',
	  'strict-origin-when-cross-origin',
	  'unsafe-url'
	];
	const referrerPolicySet = new Set(referrerPolicy);

	const requestRedirect = ['follow', 'manual', 'error'];

	const safeMethods = ['GET', 'HEAD', 'OPTIONS', 'TRACE'];
	const safeMethodsSet = new Set(safeMethods);

	const requestMode = ['navigate', 'same-origin', 'no-cors', 'cors'];

	const requestCredentials = ['omit', 'same-origin', 'include'];

	const requestCache = [
	  'default',
	  'no-store',
	  'reload',
	  'no-cache',
	  'force-cache',
	  'only-if-cached'
	];

	// https://fetch.spec.whatwg.org/#request-body-header-name
	const requestBodyHeader = [
	  'content-encoding',
	  'content-language',
	  'content-location',
	  'content-type',
	  // See https://github.com/nodejs/undici/issues/2021
	  // 'Content-Length' is a forbidden header name, which is typically
	  // removed in the Headers implementation. However, undici doesn't
	  // filter out headers, so we add it here.
	  'content-length'
	];

	// https://fetch.spec.whatwg.org/#enumdef-requestduplex
	const requestDuplex = [
	  'half'
	];

	// http://fetch.spec.whatwg.org/#forbidden-method
	const forbiddenMethods = ['CONNECT', 'TRACE', 'TRACK'];
	const forbiddenMethodsSet = new Set(forbiddenMethods);

	const subresource = [
	  'audio',
	  'audioworklet',
	  'font',
	  'image',
	  'manifest',
	  'paintworklet',
	  'script',
	  'style',
	  'track',
	  'video',
	  'xslt',
	  ''
	];
	const subresourceSet = new Set(subresource);

	/** @type {globalThis['DOMException']} */
	const DOMException = globalThis.DOMException ?? (() => {
	  // DOMException was only made a global in Node v17.0.0,
	  // but fetch supports >= v16.8.
	  try {
	    atob('~');
	  } catch (err) {
	    return Object.getPrototypeOf(err).constructor
	  }
	})();

	let channel;

	/** @type {globalThis['structuredClone']} */
	const structuredClone =
	  globalThis.structuredClone ??
	  // https://github.com/nodejs/node/blob/b27ae24dcc4251bad726d9d84baf678d1f707fed/lib/internal/structured_clone.js
	  // structuredClone was added in v17.0.0, but fetch supports v16.8
	  function structuredClone (value, options = undefined) {
	    if (arguments.length === 0) {
	      throw new TypeError('missing argument')
	    }

	    if (!channel) {
	      channel = new MessageChannel();
	    }
	    channel.port1.unref();
	    channel.port2.unref();
	    channel.port1.postMessage(value, options?.transfer);
	    return receiveMessageOnPort(channel.port2).message
	  };

	constants$5 = {
	  DOMException,
	  structuredClone,
	  subresource,
	  forbiddenMethods,
	  requestBodyHeader,
	  referrerPolicy,
	  requestRedirect,
	  requestMode,
	  requestCredentials,
	  requestCache,
	  redirectStatus,
	  corsSafeListedMethods,
	  nullBodyStatus,
	  safeMethods,
	  badPorts,
	  requestDuplex,
	  subresourceSet,
	  badPortsSet,
	  redirectStatusSet,
	  corsSafeListedMethodsSet,
	  safeMethodsSet,
	  forbiddenMethodsSet,
	  referrerPolicySet
	};
	return constants$5;
}

var global$3;
var hasRequiredGlobal$1;

function requireGlobal$1 () {
	if (hasRequiredGlobal$1) return global$3;
	hasRequiredGlobal$1 = 1;

	// In case of breaking changes, increase the version
	// number to avoid conflicts.
	const globalOrigin = Symbol.for('undici.globalOrigin.1');

	function getGlobalOrigin () {
	  return globalThis[globalOrigin]
	}

	function setGlobalOrigin (newOrigin) {
	  if (newOrigin === undefined) {
	    Object.defineProperty(globalThis, globalOrigin, {
	      value: undefined,
	      writable: true,
	      enumerable: false,
	      configurable: false
	    });

	    return
	  }

	  const parsedURL = new URL(newOrigin);

	  if (parsedURL.protocol !== 'http:' && parsedURL.protocol !== 'https:') {
	    throw new TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`)
	  }

	  Object.defineProperty(globalThis, globalOrigin, {
	    value: parsedURL,
	    writable: true,
	    enumerable: false,
	    configurable: false
	  });
	}

	global$3 = {
	  getGlobalOrigin,
	  setGlobalOrigin
	};
	return global$3;
}

var util$5;
var hasRequiredUtil$5;

function requireUtil$5 () {
	if (hasRequiredUtil$5) return util$5;
	hasRequiredUtil$5 = 1;

	const { redirectStatusSet, referrerPolicySet: referrerPolicyTokens, badPortsSet } = requireConstants$5();
	const { getGlobalOrigin } = requireGlobal$1();
	const { performance } = require$$2$1;
	const { isBlobLike, toUSVString, ReadableStreamFrom } = requireUtil$6();
	const assert = require$$0$4;
	const { isUint8Array } = require$$5;

	let supportedHashes = [];

	// https://nodejs.org/api/crypto.html#determining-if-crypto-support-is-unavailable
	/** @type {import('crypto')|undefined} */
	let crypto;

	try {
	  crypto = require('crypto');
	  const possibleRelevantHashes = ['sha256', 'sha384', 'sha512'];
	  supportedHashes = crypto.getHashes().filter((hash) => possibleRelevantHashes.includes(hash));
	/* c8 ignore next 3 */
	} catch {
	}

	function responseURL (response) {
	  // https://fetch.spec.whatwg.org/#responses
	  // A response has an associated URL. It is a pointer to the last URL
	  // in responses URL list and null if responses URL list is empty.
	  const urlList = response.urlList;
	  const length = urlList.length;
	  return length === 0 ? null : urlList[length - 1].toString()
	}

	// https://fetch.spec.whatwg.org/#concept-response-location-url
	function responseLocationURL (response, requestFragment) {
	  // 1. If responses status is not a redirect status, then return null.
	  if (!redirectStatusSet.has(response.status)) {
	    return null
	  }

	  // 2. Let location be the result of extracting header list values given
	  // `Location` and responses header list.
	  let location = response.headersList.get('location');

	  // 3. If location is a header value, then set location to the result of
	  //    parsing location with responses URL.
	  if (location !== null && isValidHeaderValue(location)) {
	    location = new URL(location, responseURL(response));
	  }

	  // 4. If location is a URL whose fragment is null, then set locations
	  // fragment to requestFragment.
	  if (location && !location.hash) {
	    location.hash = requestFragment;
	  }

	  // 5. Return location.
	  return location
	}

	/** @returns {URL} */
	function requestCurrentURL (request) {
	  return request.urlList[request.urlList.length - 1]
	}

	function requestBadPort (request) {
	  // 1. Let url be requests current URL.
	  const url = requestCurrentURL(request);

	  // 2. If urls scheme is an HTTP(S) scheme and urls port is a bad port,
	  // then return blocked.
	  if (urlIsHttpHttpsScheme(url) && badPortsSet.has(url.port)) {
	    return 'blocked'
	  }

	  // 3. Return allowed.
	  return 'allowed'
	}

	function isErrorLike (object) {
	  return object instanceof Error || (
	    object?.constructor?.name === 'Error' ||
	    object?.constructor?.name === 'DOMException'
	  )
	}

	// Check whether |statusText| is a ByteString and
	// matches the Reason-Phrase token production.
	// RFC 2616: https://tools.ietf.org/html/rfc2616
	// RFC 7230: https://tools.ietf.org/html/rfc7230
	// "reason-phrase = *( HTAB / SP / VCHAR / obs-text )"
	// https://github.com/chromium/chromium/blob/94.0.4604.1/third_party/blink/renderer/core/fetch/response.cc#L116
	function isValidReasonPhrase (statusText) {
	  for (let i = 0; i < statusText.length; ++i) {
	    const c = statusText.charCodeAt(i);
	    if (
	      !(
	        (
	          c === 0x09 || // HTAB
	          (c >= 0x20 && c <= 0x7e) || // SP / VCHAR
	          (c >= 0x80 && c <= 0xff)
	        ) // obs-text
	      )
	    ) {
	      return false
	    }
	  }
	  return true
	}

	/**
	 * @see https://tools.ietf.org/html/rfc7230#section-3.2.6
	 * @param {number} c
	 */
	function isTokenCharCode (c) {
	  switch (c) {
	    case 0x22:
	    case 0x28:
	    case 0x29:
	    case 0x2c:
	    case 0x2f:
	    case 0x3a:
	    case 0x3b:
	    case 0x3c:
	    case 0x3d:
	    case 0x3e:
	    case 0x3f:
	    case 0x40:
	    case 0x5b:
	    case 0x5c:
	    case 0x5d:
	    case 0x7b:
	    case 0x7d:
	      // DQUOTE and "(),/:;<=>?@[\]{}"
	      return false
	    default:
	      // VCHAR %x21-7E
	      return c >= 0x21 && c <= 0x7e
	  }
	}

	/**
	 * @param {string} characters
	 */
	function isValidHTTPToken (characters) {
	  if (characters.length === 0) {
	    return false
	  }
	  for (let i = 0; i < characters.length; ++i) {
	    if (!isTokenCharCode(characters.charCodeAt(i))) {
	      return false
	    }
	  }
	  return true
	}

	/**
	 * @see https://fetch.spec.whatwg.org/#header-name
	 * @param {string} potentialValue
	 */
	function isValidHeaderName (potentialValue) {
	  return isValidHTTPToken(potentialValue)
	}

	/**
	 * @see https://fetch.spec.whatwg.org/#header-value
	 * @param {string} potentialValue
	 */
	function isValidHeaderValue (potentialValue) {
	  // - Has no leading or trailing HTTP tab or space bytes.
	  // - Contains no 0x00 (NUL) or HTTP newline bytes.
	  if (
	    potentialValue.startsWith('\t') ||
	    potentialValue.startsWith(' ') ||
	    potentialValue.endsWith('\t') ||
	    potentialValue.endsWith(' ')
	  ) {
	    return false
	  }

	  if (
	    potentialValue.includes('\0') ||
	    potentialValue.includes('\r') ||
	    potentialValue.includes('\n')
	  ) {
	    return false
	  }

	  return true
	}

	// https://w3c.github.io/webappsec-referrer-policy/#set-requests-referrer-policy-on-redirect
	function setRequestReferrerPolicyOnRedirect (request, actualResponse) {
	  //  Given a request request and a response actualResponse, this algorithm
	  //  updates requests referrer policy according to the Referrer-Policy
	  //  header (if any) in actualResponse.

	  // 1. Let policy be the result of executing  8.1 Parse a referrer policy
	  // from a Referrer-Policy header on actualResponse.

	  // 8.1 Parse a referrer policy from a Referrer-Policy header
	  // 1. Let policy-tokens be the result of extracting header list values given `Referrer-Policy` and responses header list.
	  const { headersList } = actualResponse;
	  // 2. Let policy be the empty string.
	  // 3. For each token in policy-tokens, if token is a referrer policy and token is not the empty string, then set policy to token.
	  // 4. Return policy.
	  const policyHeader = (headersList.get('referrer-policy') ?? '').split(',');

	  // Note: As the referrer-policy can contain multiple policies
	  // separated by comma, we need to loop through all of them
	  // and pick the first valid one.
	  // Ref: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy#specify_a_fallback_policy
	  let policy = '';
	  if (policyHeader.length > 0) {
	    // The right-most policy takes precedence.
	    // The left-most policy is the fallback.
	    for (let i = policyHeader.length; i !== 0; i--) {
	      const token = policyHeader[i - 1].trim();
	      if (referrerPolicyTokens.has(token)) {
	        policy = token;
	        break
	      }
	    }
	  }

	  // 2. If policy is not the empty string, then set requests referrer policy to policy.
	  if (policy !== '') {
	    request.referrerPolicy = policy;
	  }
	}

	// https://fetch.spec.whatwg.org/#cross-origin-resource-policy-check
	function crossOriginResourcePolicyCheck () {
	  // TODO
	  return 'allowed'
	}

	// https://fetch.spec.whatwg.org/#concept-cors-check
	function corsCheck () {
	  // TODO
	  return 'success'
	}

	// https://fetch.spec.whatwg.org/#concept-tao-check
	function TAOCheck () {
	  // TODO
	  return 'success'
	}

	function appendFetchMetadata (httpRequest) {
	  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-dest-header
	  //  TODO

	  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-mode-header

	  //  1. Assert: rs url is a potentially trustworthy URL.
	  //  TODO

	  //  2. Let header be a Structured Header whose value is a token.
	  let header = null;

	  //  3. Set headers value to rs mode.
	  header = httpRequest.mode;

	  //  4. Set a structured field value `Sec-Fetch-Mode`/header in rs header list.
	  httpRequest.headersList.set('sec-fetch-mode', header);

	  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-site-header
	  //  TODO

	  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-user-header
	  //  TODO
	}

	// https://fetch.spec.whatwg.org/#append-a-request-origin-header
	function appendRequestOriginHeader (request) {
	  // 1. Let serializedOrigin be the result of byte-serializing a request origin with request.
	  let serializedOrigin = request.origin;

	  // 2. If requests response tainting is "cors" or requests mode is "websocket", then append (`Origin`, serializedOrigin) to requests header list.
	  if (request.responseTainting === 'cors' || request.mode === 'websocket') {
	    if (serializedOrigin) {
	      request.headersList.append('origin', serializedOrigin);
	    }

	  // 3. Otherwise, if requests method is neither `GET` nor `HEAD`, then:
	  } else if (request.method !== 'GET' && request.method !== 'HEAD') {
	    // 1. Switch on requests referrer policy:
	    switch (request.referrerPolicy) {
	      case 'no-referrer':
	        // Set serializedOrigin to `null`.
	        serializedOrigin = null;
	        break
	      case 'no-referrer-when-downgrade':
	      case 'strict-origin':
	      case 'strict-origin-when-cross-origin':
	        // If requests origin is a tuple origin, its scheme is "https", and requests current URLs scheme is not "https", then set serializedOrigin to `null`.
	        if (request.origin && urlHasHttpsScheme(request.origin) && !urlHasHttpsScheme(requestCurrentURL(request))) {
	          serializedOrigin = null;
	        }
	        break
	      case 'same-origin':
	        // If requests origin is not same origin with requests current URLs origin, then set serializedOrigin to `null`.
	        if (!sameOrigin(request, requestCurrentURL(request))) {
	          serializedOrigin = null;
	        }
	        break
	        // Do nothing.
	    }

	    if (serializedOrigin) {
	      // 2. Append (`Origin`, serializedOrigin) to requests header list.
	      request.headersList.append('origin', serializedOrigin);
	    }
	  }
	}

	function coarsenedSharedCurrentTime (crossOriginIsolatedCapability) {
	  // TODO
	  return performance.now()
	}

	// https://fetch.spec.whatwg.org/#create-an-opaque-timing-info
	function createOpaqueTimingInfo (timingInfo) {
	  return {
	    startTime: timingInfo.startTime ?? 0,
	    redirectStartTime: 0,
	    redirectEndTime: 0,
	    postRedirectStartTime: timingInfo.startTime ?? 0,
	    finalServiceWorkerStartTime: 0,
	    finalNetworkResponseStartTime: 0,
	    finalNetworkRequestStartTime: 0,
	    endTime: 0,
	    encodedBodySize: 0,
	    decodedBodySize: 0,
	    finalConnectionTimingInfo: null
	  }
	}

	// https://html.spec.whatwg.org/multipage/origin.html#policy-container
	function makePolicyContainer () {
	  // Note: the fetch spec doesn't make use of embedder policy or CSP list
	  return {
	    referrerPolicy: 'strict-origin-when-cross-origin'
	  }
	}

	// https://html.spec.whatwg.org/multipage/origin.html#clone-a-policy-container
	function clonePolicyContainer (policyContainer) {
	  return {
	    referrerPolicy: policyContainer.referrerPolicy
	  }
	}

	// https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer
	function determineRequestsReferrer (request) {
	  // 1. Let policy be request's referrer policy.
	  const policy = request.referrerPolicy;

	  // Note: policy cannot (shouldn't) be null or an empty string.
	  assert(policy);

	  // 2. Let environment be requests client.

	  let referrerSource = null;

	  // 3. Switch on requests referrer:
	  if (request.referrer === 'client') {
	    // Note: node isn't a browser and doesn't implement document/iframes,
	    // so we bypass this step and replace it with our own.

	    const globalOrigin = getGlobalOrigin();

	    if (!globalOrigin || globalOrigin.origin === 'null') {
	      return 'no-referrer'
	    }

	    // note: we need to clone it as it's mutated
	    referrerSource = new URL(globalOrigin);
	  } else if (request.referrer instanceof URL) {
	    // Let referrerSource be requests referrer.
	    referrerSource = request.referrer;
	  }

	  // 4. Let requests referrerURL be the result of stripping referrerSource for
	  //    use as a referrer.
	  let referrerURL = stripURLForReferrer(referrerSource);

	  // 5. Let referrerOrigin be the result of stripping referrerSource for use as
	  //    a referrer, with the origin-only flag set to true.
	  const referrerOrigin = stripURLForReferrer(referrerSource, true);

	  // 6. If the result of serializing referrerURL is a string whose length is
	  //    greater than 4096, set referrerURL to referrerOrigin.
	  if (referrerURL.toString().length > 4096) {
	    referrerURL = referrerOrigin;
	  }

	  const areSameOrigin = sameOrigin(request, referrerURL);
	  const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerURL) &&
	    !isURLPotentiallyTrustworthy(request.url);

	  // 8. Execute the switch statements corresponding to the value of policy:
	  switch (policy) {
	    case 'origin': return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, true)
	    case 'unsafe-url': return referrerURL
	    case 'same-origin':
	      return areSameOrigin ? referrerOrigin : 'no-referrer'
	    case 'origin-when-cross-origin':
	      return areSameOrigin ? referrerURL : referrerOrigin
	    case 'strict-origin-when-cross-origin': {
	      const currentURL = requestCurrentURL(request);

	      // 1. If the origin of referrerURL and the origin of requests current
	      //    URL are the same, then return referrerURL.
	      if (sameOrigin(referrerURL, currentURL)) {
	        return referrerURL
	      }

	      // 2. If referrerURL is a potentially trustworthy URL and requests
	      //    current URL is not a potentially trustworthy URL, then return no
	      //    referrer.
	      if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {
	        return 'no-referrer'
	      }

	      // 3. Return referrerOrigin.
	      return referrerOrigin
	    }
	    case 'strict-origin': // eslint-disable-line
	      /**
	         * 1. If referrerURL is a potentially trustworthy URL and
	         * requests current URL is not a potentially trustworthy URL,
	         * then return no referrer.
	         * 2. Return referrerOrigin
	        */
	    case 'no-referrer-when-downgrade': // eslint-disable-line
	      /**
	       * 1. If referrerURL is a potentially trustworthy URL and
	       * requests current URL is not a potentially trustworthy URL,
	       * then return no referrer.
	       * 2. Return referrerOrigin
	      */

	    default: // eslint-disable-line
	      return isNonPotentiallyTrustWorthy ? 'no-referrer' : referrerOrigin
	  }
	}

	/**
	 * @see https://w3c.github.io/webappsec-referrer-policy/#strip-url
	 * @param {URL} url
	 * @param {boolean|undefined} originOnly
	 */
	function stripURLForReferrer (url, originOnly) {
	  // 1. Assert: url is a URL.
	  assert(url instanceof URL);

	  // 2. If urls scheme is a local scheme, then return no referrer.
	  if (url.protocol === 'file:' || url.protocol === 'about:' || url.protocol === 'blank:') {
	    return 'no-referrer'
	  }

	  // 3. Set urls username to the empty string.
	  url.username = '';

	  // 4. Set urls password to the empty string.
	  url.password = '';

	  // 5. Set urls fragment to null.
	  url.hash = '';

	  // 6. If the origin-only flag is true, then:
	  if (originOnly) {
	    // 1. Set urls path to  the empty string .
	    url.pathname = '';

	    // 2. Set urls query to null.
	    url.search = '';
	  }

	  // 7. Return url.
	  return url
	}

	function isURLPotentiallyTrustworthy (url) {
	  if (!(url instanceof URL)) {
	    return false
	  }

	  // If child of about, return true
	  if (url.href === 'about:blank' || url.href === 'about:srcdoc') {
	    return true
	  }

	  // If scheme is data, return true
	  if (url.protocol === 'data:') return true

	  // If file, return true
	  if (url.protocol === 'file:') return true

	  return isOriginPotentiallyTrustworthy(url.origin)

	  function isOriginPotentiallyTrustworthy (origin) {
	    // If origin is explicitly null, return false
	    if (origin == null || origin === 'null') return false

	    const originAsURL = new URL(origin);

	    // If secure, return true
	    if (originAsURL.protocol === 'https:' || originAsURL.protocol === 'wss:') {
	      return true
	    }

	    // If localhost or variants, return true
	    if (/^127(?:\.[0-9]+){0,2}\.[0-9]+$|^\[(?:0*:)*?:?0*1\]$/.test(originAsURL.hostname) ||
	     (originAsURL.hostname === 'localhost' || originAsURL.hostname.includes('localhost.')) ||
	     (originAsURL.hostname.endsWith('.localhost'))) {
	      return true
	    }

	    // If any other, return false
	    return false
	  }
	}

	/**
	 * @see https://w3c.github.io/webappsec-subresource-integrity/#does-response-match-metadatalist
	 * @param {Uint8Array} bytes
	 * @param {string} metadataList
	 */
	function bytesMatch (bytes, metadataList) {
	  // If node is not built with OpenSSL support, we cannot check
	  // a request's integrity, so allow it by default (the spec will
	  // allow requests if an invalid hash is given, as precedence).
	  /* istanbul ignore if: only if node is built with --without-ssl */
	  if (crypto === undefined) {
	    return true
	  }

	  // 1. Let parsedMetadata be the result of parsing metadataList.
	  const parsedMetadata = parseMetadata(metadataList);

	  // 2. If parsedMetadata is no metadata, return true.
	  if (parsedMetadata === 'no metadata') {
	    return true
	  }

	  // 3. If response is not eligible for integrity validation, return false.
	  // TODO

	  // 4. If parsedMetadata is the empty set, return true.
	  if (parsedMetadata.length === 0) {
	    return true
	  }

	  // 5. Let metadata be the result of getting the strongest
	  //    metadata from parsedMetadata.
	  const strongest = getStrongestMetadata(parsedMetadata);
	  const metadata = filterMetadataListByAlgorithm(parsedMetadata, strongest);

	  // 6. For each item in metadata:
	  for (const item of metadata) {
	    // 1. Let algorithm be the alg component of item.
	    const algorithm = item.algo;

	    // 2. Let expectedValue be the val component of item.
	    const expectedValue = item.hash;

	    // See https://github.com/web-platform-tests/wpt/commit/e4c5cc7a5e48093220528dfdd1c4012dc3837a0e
	    // "be liberal with padding". This is annoying, and it's not even in the spec.

	    // 3. Let actualValue be the result of applying algorithm to bytes.
	    let actualValue = crypto.createHash(algorithm).update(bytes).digest('base64');

	    if (actualValue[actualValue.length - 1] === '=') {
	      if (actualValue[actualValue.length - 2] === '=') {
	        actualValue = actualValue.slice(0, -2);
	      } else {
	        actualValue = actualValue.slice(0, -1);
	      }
	    }

	    // 4. If actualValue is a case-sensitive match for expectedValue,
	    //    return true.
	    if (compareBase64Mixed(actualValue, expectedValue)) {
	      return true
	    }
	  }

	  // 7. Return false.
	  return false
	}

	// https://w3c.github.io/webappsec-subresource-integrity/#grammardef-hash-with-options
	// https://www.w3.org/TR/CSP2/#source-list-syntax
	// https://www.rfc-editor.org/rfc/rfc5234#appendix-B.1
	const parseHashWithOptions = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\s|$)( +[!-~]*)?)?/i;

	/**
	 * @see https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata
	 * @param {string} metadata
	 */
	function parseMetadata (metadata) {
	  // 1. Let result be the empty set.
	  /** @type {{ algo: string, hash: string }[]} */
	  const result = [];

	  // 2. Let empty be equal to true.
	  let empty = true;

	  // 3. For each token returned by splitting metadata on spaces:
	  for (const token of metadata.split(' ')) {
	    // 1. Set empty to false.
	    empty = false;

	    // 2. Parse token as a hash-with-options.
	    const parsedToken = parseHashWithOptions.exec(token);

	    // 3. If token does not parse, continue to the next token.
	    if (
	      parsedToken === null ||
	      parsedToken.groups === undefined ||
	      parsedToken.groups.algo === undefined
	    ) {
	      // Note: Chromium blocks the request at this point, but Firefox
	      // gives a warning that an invalid integrity was given. The
	      // correct behavior is to ignore these, and subsequently not
	      // check the integrity of the resource.
	      continue
	    }

	    // 4. Let algorithm be the hash-algo component of token.
	    const algorithm = parsedToken.groups.algo.toLowerCase();

	    // 5. If algorithm is a hash function recognized by the user
	    //    agent, add the parsed token to result.
	    if (supportedHashes.includes(algorithm)) {
	      result.push(parsedToken.groups);
	    }
	  }

	  // 4. Return no metadata if empty is true, otherwise return result.
	  if (empty === true) {
	    return 'no metadata'
	  }

	  return result
	}

	/**
	 * @param {{ algo: 'sha256' | 'sha384' | 'sha512' }[]} metadataList
	 */
	function getStrongestMetadata (metadataList) {
	  // Let algorithm be the algo component of the first item in metadataList.
	  // Can be sha256
	  let algorithm = metadataList[0].algo;
	  // If the algorithm is sha512, then it is the strongest
	  // and we can return immediately
	  if (algorithm[3] === '5') {
	    return algorithm
	  }

	  for (let i = 1; i < metadataList.length; ++i) {
	    const metadata = metadataList[i];
	    // If the algorithm is sha512, then it is the strongest
	    // and we can break the loop immediately
	    if (metadata.algo[3] === '5') {
	      algorithm = 'sha512';
	      break
	    // If the algorithm is sha384, then a potential sha256 or sha384 is ignored
	    } else if (algorithm[3] === '3') {
	      continue
	    // algorithm is sha256, check if algorithm is sha384 and if so, set it as
	    // the strongest
	    } else if (metadata.algo[3] === '3') {
	      algorithm = 'sha384';
	    }
	  }
	  return algorithm
	}

	function filterMetadataListByAlgorithm (metadataList, algorithm) {
	  if (metadataList.length === 1) {
	    return metadataList
	  }

	  let pos = 0;
	  for (let i = 0; i < metadataList.length; ++i) {
	    if (metadataList[i].algo === algorithm) {
	      metadataList[pos++] = metadataList[i];
	    }
	  }

	  metadataList.length = pos;

	  return metadataList
	}

	/**
	 * Compares two base64 strings, allowing for base64url
	 * in the second string.
	 *
	* @param {string} actualValue always base64
	 * @param {string} expectedValue base64 or base64url
	 * @returns {boolean}
	 */
	function compareBase64Mixed (actualValue, expectedValue) {
	  if (actualValue.length !== expectedValue.length) {
	    return false
	  }
	  for (let i = 0; i < actualValue.length; ++i) {
	    if (actualValue[i] !== expectedValue[i]) {
	      if (
	        (actualValue[i] === '+' && expectedValue[i] === '-') ||
	        (actualValue[i] === '/' && expectedValue[i] === '_')
	      ) {
	        continue
	      }
	      return false
	    }
	  }

	  return true
	}

	// https://w3c.github.io/webappsec-upgrade-insecure-requests/#upgrade-request
	function tryUpgradeRequestToAPotentiallyTrustworthyURL (request) {
	  // TODO
	}

	/**
	 * @link {https://html.spec.whatwg.org/multipage/origin.html#same-origin}
	 * @param {URL} A
	 * @param {URL} B
	 */
	function sameOrigin (A, B) {
	  // 1. If A and B are the same opaque origin, then return true.
	  if (A.origin === B.origin && A.origin === 'null') {
	    return true
	  }

	  // 2. If A and B are both tuple origins and their schemes,
	  //    hosts, and port are identical, then return true.
	  if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {
	    return true
	  }

	  // 3. Return false.
	  return false
	}

	function createDeferredPromise () {
	  let res;
	  let rej;
	  const promise = new Promise((resolve, reject) => {
	    res = resolve;
	    rej = reject;
	  });

	  return { promise, resolve: res, reject: rej }
	}

	function isAborted (fetchParams) {
	  return fetchParams.controller.state === 'aborted'
	}

	function isCancelled (fetchParams) {
	  return fetchParams.controller.state === 'aborted' ||
	    fetchParams.controller.state === 'terminated'
	}

	const normalizeMethodRecord = {
	  delete: 'DELETE',
	  DELETE: 'DELETE',
	  get: 'GET',
	  GET: 'GET',
	  head: 'HEAD',
	  HEAD: 'HEAD',
	  options: 'OPTIONS',
	  OPTIONS: 'OPTIONS',
	  post: 'POST',
	  POST: 'POST',
	  put: 'PUT',
	  PUT: 'PUT'
	};

	// Note: object prototypes should not be able to be referenced. e.g. `Object#hasOwnProperty`.
	Object.setPrototypeOf(normalizeMethodRecord, null);

	/**
	 * @see https://fetch.spec.whatwg.org/#concept-method-normalize
	 * @param {string} method
	 */
	function normalizeMethod (method) {
	  return normalizeMethodRecord[method.toLowerCase()] ?? method
	}

	// https://infra.spec.whatwg.org/#serialize-a-javascript-value-to-a-json-string
	function serializeJavascriptValueToJSONString (value) {
	  // 1. Let result be ? Call(%JSON.stringify%, undefined,  value ).
	  const result = JSON.stringify(value);

	  // 2. If result is undefined, then throw a TypeError.
	  if (result === undefined) {
	    throw new TypeError('Value is not JSON serializable')
	  }

	  // 3. Assert: result is a string.
	  assert(typeof result === 'string');

	  // 4. Return result.
	  return result
	}

	// https://tc39.es/ecma262/#sec-%25iteratorprototype%25-object
	const esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));

	/**
	 * @see https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object
	 * @param {() => unknown[]} iterator
	 * @param {string} name name of the instance
	 * @param {'key'|'value'|'key+value'} kind
	 */
	function makeIterator (iterator, name, kind) {
	  const object = {
	    index: 0,
	    kind,
	    target: iterator
	  };

	  const i = {
	    next () {
	      // 1. Let interface be the interface for which the iterator prototype object exists.

	      // 2. Let thisValue be the this value.

	      // 3. Let object be ? ToObject(thisValue).

	      // 4. If object is a platform object, then perform a security
	      //    check, passing:

	      // 5. If object is not a default iterator object for interface,
	      //    then throw a TypeError.
	      if (Object.getPrototypeOf(this) !== i) {
	        throw new TypeError(
	          `'next' called on an object that does not implement interface ${name} Iterator.`
	        )
	      }

	      // 6. Let index be objects index.
	      // 7. Let kind be objects kind.
	      // 8. Let values be objects target's value pairs to iterate over.
	      const { index, kind, target } = object;
	      const values = target();

	      // 9. Let len be the length of values.
	      const len = values.length;

	      // 10. If index is greater than or equal to len, then return
	      //     CreateIterResultObject(undefined, true).
	      if (index >= len) {
	        return { value: undefined, done: true }
	      }

	      // 11. Let pair be the entry in values at index index.
	      const pair = values[index];

	      // 12. Set objects index to index + 1.
	      object.index = index + 1;

	      // 13. Return the iterator result for pair and kind.
	      return iteratorResult(pair, kind)
	    },
	    // The class string of an iterator prototype object for a given interface is the
	    // result of concatenating the identifier of the interface and the string " Iterator".
	    [Symbol.toStringTag]: `${name} Iterator`
	  };

	  // The [[Prototype]] internal slot of an iterator prototype object must be %IteratorPrototype%.
	  Object.setPrototypeOf(i, esIteratorPrototype);
	  // esIteratorPrototype needs to be the prototype of i
	  // which is the prototype of an empty object. Yes, it's confusing.
	  return Object.setPrototypeOf({}, i)
	}

	// https://webidl.spec.whatwg.org/#iterator-result
	function iteratorResult (pair, kind) {
	  let result;

	  // 1. Let result be a value determined by the value of kind:
	  switch (kind) {
	    case 'key': {
	      // 1. Let idlKey be pairs key.
	      // 2. Let key be the result of converting idlKey to an
	      //    ECMAScript value.
	      // 3. result is key.
	      result = pair[0];
	      break
	    }
	    case 'value': {
	      // 1. Let idlValue be pairs value.
	      // 2. Let value be the result of converting idlValue to
	      //    an ECMAScript value.
	      // 3. result is value.
	      result = pair[1];
	      break
	    }
	    case 'key+value': {
	      // 1. Let idlKey be pairs key.
	      // 2. Let idlValue be pairs value.
	      // 3. Let key be the result of converting idlKey to an
	      //    ECMAScript value.
	      // 4. Let value be the result of converting idlValue to
	      //    an ECMAScript value.
	      // 5. Let array be ! ArrayCreate(2).
	      // 6. Call ! CreateDataProperty(array, "0", key).
	      // 7. Call ! CreateDataProperty(array, "1", value).
	      // 8. result is array.
	      result = pair;
	      break
	    }
	  }

	  // 2. Return CreateIterResultObject(result, false).
	  return { value: result, done: false }
	}

	/**
	 * @see https://fetch.spec.whatwg.org/#body-fully-read
	 */
	async function fullyReadBody (body, processBody, processBodyError) {
	  // 1. If taskDestination is null, then set taskDestination to
	  //    the result of starting a new parallel queue.

	  // 2. Let successSteps given a byte sequence bytes be to queue a
	  //    fetch task to run processBody given bytes, with taskDestination.
	  const successSteps = processBody;

	  // 3. Let errorSteps be to queue a fetch task to run processBodyError,
	  //    with taskDestination.
	  const errorSteps = processBodyError;

	  // 4. Let reader be the result of getting a reader for bodys stream.
	  //    If that threw an exception, then run errorSteps with that
	  //    exception and return.
	  let reader;

	  try {
	    reader = body.stream.getReader();
	  } catch (e) {
	    errorSteps(e);
	    return
	  }

	  // 5. Read all bytes from reader, given successSteps and errorSteps.
	  try {
	    const result = await readAllBytes(reader);
	    successSteps(result);
	  } catch (e) {
	    errorSteps(e);
	  }
	}

	/** @type {ReadableStream} */
	let ReadableStream = globalThis.ReadableStream;

	function isReadableStreamLike (stream) {
	  if (!ReadableStream) {
	    ReadableStream = require$$14.ReadableStream;
	  }

	  return stream instanceof ReadableStream || (
	    stream[Symbol.toStringTag] === 'ReadableStream' &&
	    typeof stream.tee === 'function'
	  )
	}

	const MAXIMUM_ARGUMENT_LENGTH = 65535;

	/**
	 * @see https://infra.spec.whatwg.org/#isomorphic-decode
	 * @param {number[]|Uint8Array} input
	 */
	function isomorphicDecode (input) {
	  // 1. To isomorphic decode a byte sequence input, return a string whose code point
	  //    length is equal to inputs length and whose code points have the same values
	  //    as the values of inputs bytes, in the same order.

	  if (input.length < MAXIMUM_ARGUMENT_LENGTH) {
	    return String.fromCharCode(...input)
	  }

	  return input.reduce((previous, current) => previous + String.fromCharCode(current), '')
	}

	/**
	 * @param {ReadableStreamController<Uint8Array>} controller
	 */
	function readableStreamClose (controller) {
	  try {
	    controller.close();
	  } catch (err) {
	    // TODO: add comment explaining why this error occurs.
	    if (!err.message.includes('Controller is already closed')) {
	      throw err
	    }
	  }
	}

	/**
	 * @see https://infra.spec.whatwg.org/#isomorphic-encode
	 * @param {string} input
	 */
	function isomorphicEncode (input) {
	  // 1. Assert: input contains no code points greater than U+00FF.
	  for (let i = 0; i < input.length; i++) {
	    assert(input.charCodeAt(i) <= 0xFF);
	  }

	  // 2. Return a byte sequence whose length is equal to inputs code
	  //    point length and whose bytes have the same values as the
	  //    values of inputs code points, in the same order
	  return input
	}

	/**
	 * @see https://streams.spec.whatwg.org/#readablestreamdefaultreader-read-all-bytes
	 * @see https://streams.spec.whatwg.org/#read-loop
	 * @param {ReadableStreamDefaultReader} reader
	 */
	async function readAllBytes (reader) {
	  const bytes = [];
	  let byteLength = 0;

	  while (true) {
	    const { done, value: chunk } = await reader.read();

	    if (done) {
	      // 1. Call successSteps with bytes.
	      return Buffer.concat(bytes, byteLength)
	    }

	    // 1. If chunk is not a Uint8Array object, call failureSteps
	    //    with a TypeError and abort these steps.
	    if (!isUint8Array(chunk)) {
	      throw new TypeError('Received non-Uint8Array chunk')
	    }

	    // 2. Append the bytes represented by chunk to bytes.
	    bytes.push(chunk);
	    byteLength += chunk.length;

	    // 3. Read-loop given reader, bytes, successSteps, and failureSteps.
	  }
	}

	/**
	 * @see https://fetch.spec.whatwg.org/#is-local
	 * @param {URL} url
	 */
	function urlIsLocal (url) {
	  assert('protocol' in url); // ensure it's a url object

	  const protocol = url.protocol;

	  return protocol === 'about:' || protocol === 'blob:' || protocol === 'data:'
	}

	/**
	 * @param {string|URL} url
	 */
	function urlHasHttpsScheme (url) {
	  if (typeof url === 'string') {
	    return url.startsWith('https:')
	  }

	  return url.protocol === 'https:'
	}

	/**
	 * @see https://fetch.spec.whatwg.org/#http-scheme
	 * @param {URL} url
	 */
	function urlIsHttpHttpsScheme (url) {
	  assert('protocol' in url); // ensure it's a url object

	  const protocol = url.protocol;

	  return protocol === 'http:' || protocol === 'https:'
	}

	/**
	 * Fetch supports node >= 16.8.0, but Object.hasOwn was added in v16.9.0.
	 */
	const hasOwn = Object.hasOwn || ((dict, key) => Object.prototype.hasOwnProperty.call(dict, key));

	util$5 = {
	  isAborted,
	  isCancelled,
	  createDeferredPromise,
	  ReadableStreamFrom,
	  toUSVString,
	  tryUpgradeRequestToAPotentiallyTrustworthyURL,
	  coarsenedSharedCurrentTime,
	  determineRequestsReferrer,
	  makePolicyContainer,
	  clonePolicyContainer,
	  appendFetchMetadata,
	  appendRequestOriginHeader,
	  TAOCheck,
	  corsCheck,
	  crossOriginResourcePolicyCheck,
	  createOpaqueTimingInfo,
	  setRequestReferrerPolicyOnRedirect,
	  isValidHTTPToken,
	  requestBadPort,
	  requestCurrentURL,
	  responseURL,
	  responseLocationURL,
	  isBlobLike,
	  isURLPotentiallyTrustworthy,
	  isValidReasonPhrase,
	  sameOrigin,
	  normalizeMethod,
	  serializeJavascriptValueToJSONString,
	  makeIterator,
	  isValidHeaderName,
	  isValidHeaderValue,
	  hasOwn,
	  isErrorLike,
	  fullyReadBody,
	  bytesMatch,
	  isReadableStreamLike,
	  readableStreamClose,
	  isomorphicEncode,
	  isomorphicDecode,
	  urlIsLocal,
	  urlHasHttpsScheme,
	  urlIsHttpHttpsScheme,
	  readAllBytes,
	  normalizeMethodRecord,
	  parseMetadata
	};
	return util$5;
}

var symbols$3;
var hasRequiredSymbols$3;

function requireSymbols$3 () {
	if (hasRequiredSymbols$3) return symbols$3;
	hasRequiredSymbols$3 = 1;

	symbols$3 = {
	  kUrl: Symbol('url'),
	  kHeaders: Symbol('headers'),
	  kSignal: Symbol('signal'),
	  kState: Symbol('state'),
	  kGuard: Symbol('guard'),
	  kRealm: Symbol('realm')
	};
	return symbols$3;
}

var webidl_1;
var hasRequiredWebidl;

function requireWebidl () {
	if (hasRequiredWebidl) return webidl_1;
	hasRequiredWebidl = 1;

	const { types } = require$$0$2;
	const { hasOwn, toUSVString } = requireUtil$5();

	/** @type {import('../../types/webidl').Webidl} */
	const webidl = {};
	webidl.converters = {};
	webidl.util = {};
	webidl.errors = {};

	webidl.errors.exception = function (message) {
	  return new TypeError(`${message.header}: ${message.message}`)
	};

	webidl.errors.conversionFailed = function (context) {
	  const plural = context.types.length === 1 ? '' : ' one of';
	  const message =
	    `${context.argument} could not be converted to` +
	    `${plural}: ${context.types.join(', ')}.`;

	  return webidl.errors.exception({
	    header: context.prefix,
	    message
	  })
	};

	webidl.errors.invalidArgument = function (context) {
	  return webidl.errors.exception({
	    header: context.prefix,
	    message: `"${context.value}" is an invalid ${context.type}.`
	  })
	};

	// https://webidl.spec.whatwg.org/#implements
	webidl.brandCheck = function (V, I, opts = undefined) {
	  if (opts?.strict !== false && !(V instanceof I)) {
	    throw new TypeError('Illegal invocation')
	  } else {
	    return V?.[Symbol.toStringTag] === I.prototype[Symbol.toStringTag]
	  }
	};

	webidl.argumentLengthCheck = function ({ length }, min, ctx) {
	  if (length < min) {
	    throw webidl.errors.exception({
	      message: `${min} argument${min !== 1 ? 's' : ''} required, ` +
	               `but${length ? ' only' : ''} ${length} found.`,
	      ...ctx
	    })
	  }
	};

	webidl.illegalConstructor = function () {
	  throw webidl.errors.exception({
	    header: 'TypeError',
	    message: 'Illegal constructor'
	  })
	};

	// https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values
	webidl.util.Type = function (V) {
	  switch (typeof V) {
	    case 'undefined': return 'Undefined'
	    case 'boolean': return 'Boolean'
	    case 'string': return 'String'
	    case 'symbol': return 'Symbol'
	    case 'number': return 'Number'
	    case 'bigint': return 'BigInt'
	    case 'function':
	    case 'object': {
	      if (V === null) {
	        return 'Null'
	      }

	      return 'Object'
	    }
	  }
	};

	// https://webidl.spec.whatwg.org/#abstract-opdef-converttoint
	webidl.util.ConvertToInt = function (V, bitLength, signedness, opts = {}) {
	  let upperBound;
	  let lowerBound;

	  // 1. If bitLength is 64, then:
	  if (bitLength === 64) {
	    // 1. Let upperBound be 2^53  1.
	    upperBound = Math.pow(2, 53) - 1;

	    // 2. If signedness is "unsigned", then let lowerBound be 0.
	    if (signedness === 'unsigned') {
	      lowerBound = 0;
	    } else {
	      // 3. Otherwise let lowerBound be 2^53 + 1.
	      lowerBound = Math.pow(-2, 53) + 1;
	    }
	  } else if (signedness === 'unsigned') {
	    // 2. Otherwise, if signedness is "unsigned", then:

	    // 1. Let lowerBound be 0.
	    lowerBound = 0;

	    // 2. Let upperBound be 2^bitLength  1.
	    upperBound = Math.pow(2, bitLength) - 1;
	  } else {
	    // 3. Otherwise:

	    // 1. Let lowerBound be -2^bitLength  1.
	    lowerBound = Math.pow(-2, bitLength) - 1;

	    // 2. Let upperBound be 2^bitLength  1  1.
	    upperBound = Math.pow(2, bitLength - 1) - 1;
	  }

	  // 4. Let x be ? ToNumber(V).
	  let x = Number(V);

	  // 5. If x is 0, then set x to +0.
	  if (x === 0) {
	    x = 0;
	  }

	  // 6. If the conversion is to an IDL type associated
	  //    with the [EnforceRange] extended attribute, then:
	  if (opts.enforceRange === true) {
	    // 1. If x is NaN, +, or , then throw a TypeError.
	    if (
	      Number.isNaN(x) ||
	      x === Number.POSITIVE_INFINITY ||
	      x === Number.NEGATIVE_INFINITY
	    ) {
	      throw webidl.errors.exception({
	        header: 'Integer conversion',
	        message: `Could not convert ${V} to an integer.`
	      })
	    }

	    // 2. Set x to IntegerPart(x).
	    x = webidl.util.IntegerPart(x);

	    // 3. If x < lowerBound or x > upperBound, then
	    //    throw a TypeError.
	    if (x < lowerBound || x > upperBound) {
	      throw webidl.errors.exception({
	        header: 'Integer conversion',
	        message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`
	      })
	    }

	    // 4. Return x.
	    return x
	  }

	  // 7. If x is not NaN and the conversion is to an IDL
	  //    type associated with the [Clamp] extended
	  //    attribute, then:
	  if (!Number.isNaN(x) && opts.clamp === true) {
	    // 1. Set x to min(max(x, lowerBound), upperBound).
	    x = Math.min(Math.max(x, lowerBound), upperBound);

	    // 2. Round x to the nearest integer, choosing the
	    //    even integer if it lies halfway between two,
	    //    and choosing +0 rather than 0.
	    if (Math.floor(x) % 2 === 0) {
	      x = Math.floor(x);
	    } else {
	      x = Math.ceil(x);
	    }

	    // 3. Return x.
	    return x
	  }

	  // 8. If x is NaN, +0, +, or , then return +0.
	  if (
	    Number.isNaN(x) ||
	    (x === 0 && Object.is(0, x)) ||
	    x === Number.POSITIVE_INFINITY ||
	    x === Number.NEGATIVE_INFINITY
	  ) {
	    return 0
	  }

	  // 9. Set x to IntegerPart(x).
	  x = webidl.util.IntegerPart(x);

	  // 10. Set x to x modulo 2^bitLength.
	  x = x % Math.pow(2, bitLength);

	  // 11. If signedness is "signed" and x  2^bitLength  1,
	  //    then return x  2^bitLength.
	  if (signedness === 'signed' && x >= Math.pow(2, bitLength) - 1) {
	    return x - Math.pow(2, bitLength)
	  }

	  // 12. Otherwise, return x.
	  return x
	};

	// https://webidl.spec.whatwg.org/#abstract-opdef-integerpart
	webidl.util.IntegerPart = function (n) {
	  // 1. Let r be floor(abs(n)).
	  const r = Math.floor(Math.abs(n));

	  // 2. If n < 0, then return -1  r.
	  if (n < 0) {
	    return -1 * r
	  }

	  // 3. Otherwise, return r.
	  return r
	};

	// https://webidl.spec.whatwg.org/#es-sequence
	webidl.sequenceConverter = function (converter) {
	  return (V) => {
	    // 1. If Type(V) is not Object, throw a TypeError.
	    if (webidl.util.Type(V) !== 'Object') {
	      throw webidl.errors.exception({
	        header: 'Sequence',
	        message: `Value of type ${webidl.util.Type(V)} is not an Object.`
	      })
	    }

	    // 2. Let method be ? GetMethod(V, @@iterator).
	    /** @type {Generator} */
	    const method = V?.[Symbol.iterator]?.();
	    const seq = [];

	    // 3. If method is undefined, throw a TypeError.
	    if (
	      method === undefined ||
	      typeof method.next !== 'function'
	    ) {
	      throw webidl.errors.exception({
	        header: 'Sequence',
	        message: 'Object is not an iterator.'
	      })
	    }

	    // https://webidl.spec.whatwg.org/#create-sequence-from-iterable
	    while (true) {
	      const { done, value } = method.next();

	      if (done) {
	        break
	      }

	      seq.push(converter(value));
	    }

	    return seq
	  }
	};

	// https://webidl.spec.whatwg.org/#es-to-record
	webidl.recordConverter = function (keyConverter, valueConverter) {
	  return (O) => {
	    // 1. If Type(O) is not Object, throw a TypeError.
	    if (webidl.util.Type(O) !== 'Object') {
	      throw webidl.errors.exception({
	        header: 'Record',
	        message: `Value of type ${webidl.util.Type(O)} is not an Object.`
	      })
	    }

	    // 2. Let result be a new empty instance of record<K, V>.
	    const result = {};

	    if (!types.isProxy(O)) {
	      // Object.keys only returns enumerable properties
	      const keys = Object.keys(O);

	      for (const key of keys) {
	        // 1. Let typedKey be key converted to an IDL value of type K.
	        const typedKey = keyConverter(key);

	        // 2. Let value be ? Get(O, key).
	        // 3. Let typedValue be value converted to an IDL value of type V.
	        const typedValue = valueConverter(O[key]);

	        // 4. Set result[typedKey] to typedValue.
	        result[typedKey] = typedValue;
	      }

	      // 5. Return result.
	      return result
	    }

	    // 3. Let keys be ? O.[[OwnPropertyKeys]]().
	    const keys = Reflect.ownKeys(O);

	    // 4. For each key of keys.
	    for (const key of keys) {
	      // 1. Let desc be ? O.[[GetOwnProperty]](key).
	      const desc = Reflect.getOwnPropertyDescriptor(O, key);

	      // 2. If desc is not undefined and desc.[[Enumerable]] is true:
	      if (desc?.enumerable) {
	        // 1. Let typedKey be key converted to an IDL value of type K.
	        const typedKey = keyConverter(key);

	        // 2. Let value be ? Get(O, key).
	        // 3. Let typedValue be value converted to an IDL value of type V.
	        const typedValue = valueConverter(O[key]);

	        // 4. Set result[typedKey] to typedValue.
	        result[typedKey] = typedValue;
	      }
	    }

	    // 5. Return result.
	    return result
	  }
	};

	webidl.interfaceConverter = function (i) {
	  return (V, opts = {}) => {
	    if (opts.strict !== false && !(V instanceof i)) {
	      throw webidl.errors.exception({
	        header: i.name,
	        message: `Expected ${V} to be an instance of ${i.name}.`
	      })
	    }

	    return V
	  }
	};

	webidl.dictionaryConverter = function (converters) {
	  return (dictionary) => {
	    const type = webidl.util.Type(dictionary);
	    const dict = {};

	    if (type === 'Null' || type === 'Undefined') {
	      return dict
	    } else if (type !== 'Object') {
	      throw webidl.errors.exception({
	        header: 'Dictionary',
	        message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`
	      })
	    }

	    for (const options of converters) {
	      const { key, defaultValue, required, converter } = options;

	      if (required === true) {
	        if (!hasOwn(dictionary, key)) {
	          throw webidl.errors.exception({
	            header: 'Dictionary',
	            message: `Missing required key "${key}".`
	          })
	        }
	      }

	      let value = dictionary[key];
	      const hasDefault = hasOwn(options, 'defaultValue');

	      // Only use defaultValue if value is undefined and
	      // a defaultValue options was provided.
	      if (hasDefault && value !== null) {
	        value = value ?? defaultValue;
	      }

	      // A key can be optional and have no default value.
	      // When this happens, do not perform a conversion,
	      // and do not assign the key a value.
	      if (required || hasDefault || value !== undefined) {
	        value = converter(value);

	        if (
	          options.allowedValues &&
	          !options.allowedValues.includes(value)
	        ) {
	          throw webidl.errors.exception({
	            header: 'Dictionary',
	            message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(', ')}.`
	          })
	        }

	        dict[key] = value;
	      }
	    }

	    return dict
	  }
	};

	webidl.nullableConverter = function (converter) {
	  return (V) => {
	    if (V === null) {
	      return V
	    }

	    return converter(V)
	  }
	};

	// https://webidl.spec.whatwg.org/#es-DOMString
	webidl.converters.DOMString = function (V, opts = {}) {
	  // 1. If V is null and the conversion is to an IDL type
	  //    associated with the [LegacyNullToEmptyString]
	  //    extended attribute, then return the DOMString value
	  //    that represents the empty string.
	  if (V === null && opts.legacyNullToEmptyString) {
	    return ''
	  }

	  // 2. Let x be ? ToString(V).
	  if (typeof V === 'symbol') {
	    throw new TypeError('Could not convert argument of type symbol to string.')
	  }

	  // 3. Return the IDL DOMString value that represents the
	  //    same sequence of code units as the one the
	  //    ECMAScript String value x represents.
	  return String(V)
	};

	// https://webidl.spec.whatwg.org/#es-ByteString
	webidl.converters.ByteString = function (V) {
	  // 1. Let x be ? ToString(V).
	  // Note: DOMString converter perform ? ToString(V)
	  const x = webidl.converters.DOMString(V);

	  // 2. If the value of any element of x is greater than
	  //    255, then throw a TypeError.
	  for (let index = 0; index < x.length; index++) {
	    if (x.charCodeAt(index) > 255) {
	      throw new TypeError(
	        'Cannot convert argument to a ByteString because the character at ' +
	        `index ${index} has a value of ${x.charCodeAt(index)} which is greater than 255.`
	      )
	    }
	  }

	  // 3. Return an IDL ByteString value whose length is the
	  //    length of x, and where the value of each element is
	  //    the value of the corresponding element of x.
	  return x
	};

	// https://webidl.spec.whatwg.org/#es-USVString
	webidl.converters.USVString = toUSVString;

	// https://webidl.spec.whatwg.org/#es-boolean
	webidl.converters.boolean = function (V) {
	  // 1. Let x be the result of computing ToBoolean(V).
	  const x = Boolean(V);

	  // 2. Return the IDL boolean value that is the one that represents
	  //    the same truth value as the ECMAScript Boolean value x.
	  return x
	};

	// https://webidl.spec.whatwg.org/#es-any
	webidl.converters.any = function (V) {
	  return V
	};

	// https://webidl.spec.whatwg.org/#es-long-long
	webidl.converters['long long'] = function (V) {
	  // 1. Let x be ? ConvertToInt(V, 64, "signed").
	  const x = webidl.util.ConvertToInt(V, 64, 'signed');

	  // 2. Return the IDL long long value that represents
	  //    the same numeric value as x.
	  return x
	};

	// https://webidl.spec.whatwg.org/#es-unsigned-long-long
	webidl.converters['unsigned long long'] = function (V) {
	  // 1. Let x be ? ConvertToInt(V, 64, "unsigned").
	  const x = webidl.util.ConvertToInt(V, 64, 'unsigned');

	  // 2. Return the IDL unsigned long long value that
	  //    represents the same numeric value as x.
	  return x
	};

	// https://webidl.spec.whatwg.org/#es-unsigned-long
	webidl.converters['unsigned long'] = function (V) {
	  // 1. Let x be ? ConvertToInt(V, 32, "unsigned").
	  const x = webidl.util.ConvertToInt(V, 32, 'unsigned');

	  // 2. Return the IDL unsigned long value that
	  //    represents the same numeric value as x.
	  return x
	};

	// https://webidl.spec.whatwg.org/#es-unsigned-short
	webidl.converters['unsigned short'] = function (V, opts) {
	  // 1. Let x be ? ConvertToInt(V, 16, "unsigned").
	  const x = webidl.util.ConvertToInt(V, 16, 'unsigned', opts);

	  // 2. Return the IDL unsigned short value that represents
	  //    the same numeric value as x.
	  return x
	};

	// https://webidl.spec.whatwg.org/#idl-ArrayBuffer
	webidl.converters.ArrayBuffer = function (V, opts = {}) {
	  // 1. If Type(V) is not Object, or V does not have an
	  //    [[ArrayBufferData]] internal slot, then throw a
	  //    TypeError.
	  // see: https://tc39.es/ecma262/#sec-properties-of-the-arraybuffer-instances
	  // see: https://tc39.es/ecma262/#sec-properties-of-the-sharedarraybuffer-instances
	  if (
	    webidl.util.Type(V) !== 'Object' ||
	    !types.isAnyArrayBuffer(V)
	  ) {
	    throw webidl.errors.conversionFailed({
	      prefix: `${V}`,
	      argument: `${V}`,
	      types: ['ArrayBuffer']
	    })
	  }

	  // 2. If the conversion is not to an IDL type associated
	  //    with the [AllowShared] extended attribute, and
	  //    IsSharedArrayBuffer(V) is true, then throw a
	  //    TypeError.
	  if (opts.allowShared === false && types.isSharedArrayBuffer(V)) {
	    throw webidl.errors.exception({
	      header: 'ArrayBuffer',
	      message: 'SharedArrayBuffer is not allowed.'
	    })
	  }

	  // 3. If the conversion is not to an IDL type associated
	  //    with the [AllowResizable] extended attribute, and
	  //    IsResizableArrayBuffer(V) is true, then throw a
	  //    TypeError.
	  // Note: resizable ArrayBuffers are currently a proposal.

	  // 4. Return the IDL ArrayBuffer value that is a
	  //    reference to the same object as V.
	  return V
	};

	webidl.converters.TypedArray = function (V, T, opts = {}) {
	  // 1. Let T be the IDL type V is being converted to.

	  // 2. If Type(V) is not Object, or V does not have a
	  //    [[TypedArrayName]] internal slot with a value
	  //    equal to Ts name, then throw a TypeError.
	  if (
	    webidl.util.Type(V) !== 'Object' ||
	    !types.isTypedArray(V) ||
	    V.constructor.name !== T.name
	  ) {
	    throw webidl.errors.conversionFailed({
	      prefix: `${T.name}`,
	      argument: `${V}`,
	      types: [T.name]
	    })
	  }

	  // 3. If the conversion is not to an IDL type associated
	  //    with the [AllowShared] extended attribute, and
	  //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is
	  //    true, then throw a TypeError.
	  if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {
	    throw webidl.errors.exception({
	      header: 'ArrayBuffer',
	      message: 'SharedArrayBuffer is not allowed.'
	    })
	  }

	  // 4. If the conversion is not to an IDL type associated
	  //    with the [AllowResizable] extended attribute, and
	  //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is
	  //    true, then throw a TypeError.
	  // Note: resizable array buffers are currently a proposal

	  // 5. Return the IDL value of type T that is a reference
	  //    to the same object as V.
	  return V
	};

	webidl.converters.DataView = function (V, opts = {}) {
	  // 1. If Type(V) is not Object, or V does not have a
	  //    [[DataView]] internal slot, then throw a TypeError.
	  if (webidl.util.Type(V) !== 'Object' || !types.isDataView(V)) {
	    throw webidl.errors.exception({
	      header: 'DataView',
	      message: 'Object is not a DataView.'
	    })
	  }

	  // 2. If the conversion is not to an IDL type associated
	  //    with the [AllowShared] extended attribute, and
	  //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is true,
	  //    then throw a TypeError.
	  if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {
	    throw webidl.errors.exception({
	      header: 'ArrayBuffer',
	      message: 'SharedArrayBuffer is not allowed.'
	    })
	  }

	  // 3. If the conversion is not to an IDL type associated
	  //    with the [AllowResizable] extended attribute, and
	  //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is
	  //    true, then throw a TypeError.
	  // Note: resizable ArrayBuffers are currently a proposal

	  // 4. Return the IDL DataView value that is a reference
	  //    to the same object as V.
	  return V
	};

	// https://webidl.spec.whatwg.org/#BufferSource
	webidl.converters.BufferSource = function (V, opts = {}) {
	  if (types.isAnyArrayBuffer(V)) {
	    return webidl.converters.ArrayBuffer(V, opts)
	  }

	  if (types.isTypedArray(V)) {
	    return webidl.converters.TypedArray(V, V.constructor)
	  }

	  if (types.isDataView(V)) {
	    return webidl.converters.DataView(V, opts)
	  }

	  throw new TypeError(`Could not convert ${V} to a BufferSource.`)
	};

	webidl.converters['sequence<ByteString>'] = webidl.sequenceConverter(
	  webidl.converters.ByteString
	);

	webidl.converters['sequence<sequence<ByteString>>'] = webidl.sequenceConverter(
	  webidl.converters['sequence<ByteString>']
	);

	webidl.converters['record<ByteString, ByteString>'] = webidl.recordConverter(
	  webidl.converters.ByteString,
	  webidl.converters.ByteString
	);

	webidl_1 = {
	  webidl
	};
	return webidl_1;
}

var dataURL;
var hasRequiredDataURL;

function requireDataURL () {
	if (hasRequiredDataURL) return dataURL;
	hasRequiredDataURL = 1;
	const assert = require$$0$4;
	const { atob } = require$$7;
	const { isomorphicDecode } = requireUtil$5();

	const encoder = new TextEncoder();

	/**
	 * @see https://mimesniff.spec.whatwg.org/#http-token-code-point
	 */
	const HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+-.^_|~A-Za-z0-9]+$/;
	const HTTP_WHITESPACE_REGEX = /(\u000A|\u000D|\u0009|\u0020)/; // eslint-disable-line
	/**
	 * @see https://mimesniff.spec.whatwg.org/#http-quoted-string-token-code-point
	 */
	const HTTP_QUOTED_STRING_TOKENS = /[\u0009|\u0020-\u007E|\u0080-\u00FF]/; // eslint-disable-line

	// https://fetch.spec.whatwg.org/#data-url-processor
	/** @param {URL} dataURL */
	function dataURLProcessor (dataURL) {
	  // 1. Assert: dataURLs scheme is "data".
	  assert(dataURL.protocol === 'data:');

	  // 2. Let input be the result of running the URL
	  // serializer on dataURL with exclude fragment
	  // set to true.
	  let input = URLSerializer(dataURL, true);

	  // 3. Remove the leading "data:" string from input.
	  input = input.slice(5);

	  // 4. Let position point at the start of input.
	  const position = { position: 0 };

	  // 5. Let mimeType be the result of collecting a
	  // sequence of code points that are not equal
	  // to U+002C (,), given position.
	  let mimeType = collectASequenceOfCodePointsFast(
	    ',',
	    input,
	    position
	  );

	  // 6. Strip leading and trailing ASCII whitespace
	  // from mimeType.
	  // Undici implementation note: we need to store the
	  // length because if the mimetype has spaces removed,
	  // the wrong amount will be sliced from the input in
	  // step #9
	  const mimeTypeLength = mimeType.length;
	  mimeType = removeASCIIWhitespace(mimeType, true, true);

	  // 7. If position is past the end of input, then
	  // return failure
	  if (position.position >= input.length) {
	    return 'failure'
	  }

	  // 8. Advance position by 1.
	  position.position++;

	  // 9. Let encodedBody be the remainder of input.
	  const encodedBody = input.slice(mimeTypeLength + 1);

	  // 10. Let body be the percent-decoding of encodedBody.
	  let body = stringPercentDecode(encodedBody);

	  // 11. If mimeType ends with U+003B (;), followed by
	  // zero or more U+0020 SPACE, followed by an ASCII
	  // case-insensitive match for "base64", then:
	  if (/;(\u0020){0,}base64$/i.test(mimeType)) {
	    // 1. Let stringBody be the isomorphic decode of body.
	    const stringBody = isomorphicDecode(body);

	    // 2. Set body to the forgiving-base64 decode of
	    // stringBody.
	    body = forgivingBase64(stringBody);

	    // 3. If body is failure, then return failure.
	    if (body === 'failure') {
	      return 'failure'
	    }

	    // 4. Remove the last 6 code points from mimeType.
	    mimeType = mimeType.slice(0, -6);

	    // 5. Remove trailing U+0020 SPACE code points from mimeType,
	    // if any.
	    mimeType = mimeType.replace(/(\u0020)+$/, '');

	    // 6. Remove the last U+003B (;) code point from mimeType.
	    mimeType = mimeType.slice(0, -1);
	  }

	  // 12. If mimeType starts with U+003B (;), then prepend
	  // "text/plain" to mimeType.
	  if (mimeType.startsWith(';')) {
	    mimeType = 'text/plain' + mimeType;
	  }

	  // 13. Let mimeTypeRecord be the result of parsing
	  // mimeType.
	  let mimeTypeRecord = parseMIMEType(mimeType);

	  // 14. If mimeTypeRecord is failure, then set
	  // mimeTypeRecord to text/plain;charset=US-ASCII.
	  if (mimeTypeRecord === 'failure') {
	    mimeTypeRecord = parseMIMEType('text/plain;charset=US-ASCII');
	  }

	  // 15. Return a new data: URL struct whose MIME
	  // type is mimeTypeRecord and body is body.
	  // https://fetch.spec.whatwg.org/#data-url-struct
	  return { mimeType: mimeTypeRecord, body }
	}

	// https://url.spec.whatwg.org/#concept-url-serializer
	/**
	 * @param {URL} url
	 * @param {boolean} excludeFragment
	 */
	function URLSerializer (url, excludeFragment = false) {
	  if (!excludeFragment) {
	    return url.href
	  }

	  const href = url.href;
	  const hashLength = url.hash.length;

	  return hashLength === 0 ? href : href.substring(0, href.length - hashLength)
	}

	// https://infra.spec.whatwg.org/#collect-a-sequence-of-code-points
	/**
	 * @param {(char: string) => boolean} condition
	 * @param {string} input
	 * @param {{ position: number }} position
	 */
	function collectASequenceOfCodePoints (condition, input, position) {
	  // 1. Let result be the empty string.
	  let result = '';

	  // 2. While position doesnt point past the end of input and the
	  // code point at position within input meets the condition condition:
	  while (position.position < input.length && condition(input[position.position])) {
	    // 1. Append that code point to the end of result.
	    result += input[position.position];

	    // 2. Advance position by 1.
	    position.position++;
	  }

	  // 3. Return result.
	  return result
	}

	/**
	 * A faster collectASequenceOfCodePoints that only works when comparing a single character.
	 * @param {string} char
	 * @param {string} input
	 * @param {{ position: number }} position
	 */
	function collectASequenceOfCodePointsFast (char, input, position) {
	  const idx = input.indexOf(char, position.position);
	  const start = position.position;

	  if (idx === -1) {
	    position.position = input.length;
	    return input.slice(start)
	  }

	  position.position = idx;
	  return input.slice(start, position.position)
	}

	// https://url.spec.whatwg.org/#string-percent-decode
	/** @param {string} input */
	function stringPercentDecode (input) {
	  // 1. Let bytes be the UTF-8 encoding of input.
	  const bytes = encoder.encode(input);

	  // 2. Return the percent-decoding of bytes.
	  return percentDecode(bytes)
	}

	// https://url.spec.whatwg.org/#percent-decode
	/** @param {Uint8Array} input */
	function percentDecode (input) {
	  // 1. Let output be an empty byte sequence.
	  /** @type {number[]} */
	  const output = [];

	  // 2. For each byte byte in input:
	  for (let i = 0; i < input.length; i++) {
	    const byte = input[i];

	    // 1. If byte is not 0x25 (%), then append byte to output.
	    if (byte !== 0x25) {
	      output.push(byte);

	    // 2. Otherwise, if byte is 0x25 (%) and the next two bytes
	    // after byte in input are not in the ranges
	    // 0x30 (0) to 0x39 (9), 0x41 (A) to 0x46 (F),
	    // and 0x61 (a) to 0x66 (f), all inclusive, append byte
	    // to output.
	    } else if (
	      byte === 0x25 &&
	      !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(input[i + 1], input[i + 2]))
	    ) {
	      output.push(0x25);

	    // 3. Otherwise:
	    } else {
	      // 1. Let bytePoint be the two bytes after byte in input,
	      // decoded, and then interpreted as hexadecimal number.
	      const nextTwoBytes = String.fromCharCode(input[i + 1], input[i + 2]);
	      const bytePoint = Number.parseInt(nextTwoBytes, 16);

	      // 2. Append a byte whose value is bytePoint to output.
	      output.push(bytePoint);

	      // 3. Skip the next two bytes in input.
	      i += 2;
	    }
	  }

	  // 3. Return output.
	  return Uint8Array.from(output)
	}

	// https://mimesniff.spec.whatwg.org/#parse-a-mime-type
	/** @param {string} input */
	function parseMIMEType (input) {
	  // 1. Remove any leading and trailing HTTP whitespace
	  // from input.
	  input = removeHTTPWhitespace(input, true, true);

	  // 2. Let position be a position variable for input,
	  // initially pointing at the start of input.
	  const position = { position: 0 };

	  // 3. Let type be the result of collecting a sequence
	  // of code points that are not U+002F (/) from
	  // input, given position.
	  const type = collectASequenceOfCodePointsFast(
	    '/',
	    input,
	    position
	  );

	  // 4. If type is the empty string or does not solely
	  // contain HTTP token code points, then return failure.
	  // https://mimesniff.spec.whatwg.org/#http-token-code-point
	  if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type)) {
	    return 'failure'
	  }

	  // 5. If position is past the end of input, then return
	  // failure
	  if (position.position > input.length) {
	    return 'failure'
	  }

	  // 6. Advance position by 1. (This skips past U+002F (/).)
	  position.position++;

	  // 7. Let subtype be the result of collecting a sequence of
	  // code points that are not U+003B (;) from input, given
	  // position.
	  let subtype = collectASequenceOfCodePointsFast(
	    ';',
	    input,
	    position
	  );

	  // 8. Remove any trailing HTTP whitespace from subtype.
	  subtype = removeHTTPWhitespace(subtype, false, true);

	  // 9. If subtype is the empty string or does not solely
	  // contain HTTP token code points, then return failure.
	  if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) {
	    return 'failure'
	  }

	  const typeLowercase = type.toLowerCase();
	  const subtypeLowercase = subtype.toLowerCase();

	  // 10. Let mimeType be a new MIME type record whose type
	  // is type, in ASCII lowercase, and subtype is subtype,
	  // in ASCII lowercase.
	  // https://mimesniff.spec.whatwg.org/#mime-type
	  const mimeType = {
	    type: typeLowercase,
	    subtype: subtypeLowercase,
	    /** @type {Map<string, string>} */
	    parameters: new Map(),
	    // https://mimesniff.spec.whatwg.org/#mime-type-essence
	    essence: `${typeLowercase}/${subtypeLowercase}`
	  };

	  // 11. While position is not past the end of input:
	  while (position.position < input.length) {
	    // 1. Advance position by 1. (This skips past U+003B (;).)
	    position.position++;

	    // 2. Collect a sequence of code points that are HTTP
	    // whitespace from input given position.
	    collectASequenceOfCodePoints(
	      // https://fetch.spec.whatwg.org/#http-whitespace
	      char => HTTP_WHITESPACE_REGEX.test(char),
	      input,
	      position
	    );

	    // 3. Let parameterName be the result of collecting a
	    // sequence of code points that are not U+003B (;)
	    // or U+003D (=) from input, given position.
	    let parameterName = collectASequenceOfCodePoints(
	      (char) => char !== ';' && char !== '=',
	      input,
	      position
	    );

	    // 4. Set parameterName to parameterName, in ASCII
	    // lowercase.
	    parameterName = parameterName.toLowerCase();

	    // 5. If position is not past the end of input, then:
	    if (position.position < input.length) {
	      // 1. If the code point at position within input is
	      // U+003B (;), then continue.
	      if (input[position.position] === ';') {
	        continue
	      }

	      // 2. Advance position by 1. (This skips past U+003D (=).)
	      position.position++;
	    }

	    // 6. If position is past the end of input, then break.
	    if (position.position > input.length) {
	      break
	    }

	    // 7. Let parameterValue be null.
	    let parameterValue = null;

	    // 8. If the code point at position within input is
	    // U+0022 ("), then:
	    if (input[position.position] === '"') {
	      // 1. Set parameterValue to the result of collecting
	      // an HTTP quoted string from input, given position
	      // and the extract-value flag.
	      parameterValue = collectAnHTTPQuotedString(input, position, true);

	      // 2. Collect a sequence of code points that are not
	      // U+003B (;) from input, given position.
	      collectASequenceOfCodePointsFast(
	        ';',
	        input,
	        position
	      );

	    // 9. Otherwise:
	    } else {
	      // 1. Set parameterValue to the result of collecting
	      // a sequence of code points that are not U+003B (;)
	      // from input, given position.
	      parameterValue = collectASequenceOfCodePointsFast(
	        ';',
	        input,
	        position
	      );

	      // 2. Remove any trailing HTTP whitespace from parameterValue.
	      parameterValue = removeHTTPWhitespace(parameterValue, false, true);

	      // 3. If parameterValue is the empty string, then continue.
	      if (parameterValue.length === 0) {
	        continue
	      }
	    }

	    // 10. If all of the following are true
	    // - parameterName is not the empty string
	    // - parameterName solely contains HTTP token code points
	    // - parameterValue solely contains HTTP quoted-string token code points
	    // - mimeTypes parameters[parameterName] does not exist
	    // then set mimeTypes parameters[parameterName] to parameterValue.
	    if (
	      parameterName.length !== 0 &&
	      HTTP_TOKEN_CODEPOINTS.test(parameterName) &&
	      (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) &&
	      !mimeType.parameters.has(parameterName)
	    ) {
	      mimeType.parameters.set(parameterName, parameterValue);
	    }
	  }

	  // 12. Return mimeType.
	  return mimeType
	}

	// https://infra.spec.whatwg.org/#forgiving-base64-decode
	/** @param {string} data */
	function forgivingBase64 (data) {
	  // 1. Remove all ASCII whitespace from data.
	  data = data.replace(/[\u0009\u000A\u000C\u000D\u0020]/g, '');  // eslint-disable-line

	  // 2. If datas code point length divides by 4 leaving
	  // no remainder, then:
	  if (data.length % 4 === 0) {
	    // 1. If data ends with one or two U+003D (=) code points,
	    // then remove them from data.
	    data = data.replace(/=?=$/, '');
	  }

	  // 3. If datas code point length divides by 4 leaving
	  // a remainder of 1, then return failure.
	  if (data.length % 4 === 1) {
	    return 'failure'
	  }

	  // 4. If data contains a code point that is not one of
	  //  U+002B (+)
	  //  U+002F (/)
	  //  ASCII alphanumeric
	  // then return failure.
	  if (/[^+/0-9A-Za-z]/.test(data)) {
	    return 'failure'
	  }

	  const binary = atob(data);
	  const bytes = new Uint8Array(binary.length);

	  for (let byte = 0; byte < binary.length; byte++) {
	    bytes[byte] = binary.charCodeAt(byte);
	  }

	  return bytes
	}

	// https://fetch.spec.whatwg.org/#collect-an-http-quoted-string
	// tests: https://fetch.spec.whatwg.org/#example-http-quoted-string
	/**
	 * @param {string} input
	 * @param {{ position: number }} position
	 * @param {boolean?} extractValue
	 */
	function collectAnHTTPQuotedString (input, position, extractValue) {
	  // 1. Let positionStart be position.
	  const positionStart = position.position;

	  // 2. Let value be the empty string.
	  let value = '';

	  // 3. Assert: the code point at position within input
	  // is U+0022 (").
	  assert(input[position.position] === '"');

	  // 4. Advance position by 1.
	  position.position++;

	  // 5. While true:
	  while (true) {
	    // 1. Append the result of collecting a sequence of code points
	    // that are not U+0022 (") or U+005C (\) from input, given
	    // position, to value.
	    value += collectASequenceOfCodePoints(
	      (char) => char !== '"' && char !== '\\',
	      input,
	      position
	    );

	    // 2. If position is past the end of input, then break.
	    if (position.position >= input.length) {
	      break
	    }

	    // 3. Let quoteOrBackslash be the code point at position within
	    // input.
	    const quoteOrBackslash = input[position.position];

	    // 4. Advance position by 1.
	    position.position++;

	    // 5. If quoteOrBackslash is U+005C (\), then:
	    if (quoteOrBackslash === '\\') {
	      // 1. If position is past the end of input, then append
	      // U+005C (\) to value and break.
	      if (position.position >= input.length) {
	        value += '\\';
	        break
	      }

	      // 2. Append the code point at position within input to value.
	      value += input[position.position];

	      // 3. Advance position by 1.
	      position.position++;

	    // 6. Otherwise:
	    } else {
	      // 1. Assert: quoteOrBackslash is U+0022 (").
	      assert(quoteOrBackslash === '"');

	      // 2. Break.
	      break
	    }
	  }

	  // 6. If the extract-value flag is set, then return value.
	  if (extractValue) {
	    return value
	  }

	  // 7. Return the code points from positionStart to position,
	  // inclusive, within input.
	  return input.slice(positionStart, position.position)
	}

	/**
	 * @see https://mimesniff.spec.whatwg.org/#serialize-a-mime-type
	 */
	function serializeAMimeType (mimeType) {
	  assert(mimeType !== 'failure');
	  const { parameters, essence } = mimeType;

	  // 1. Let serialization be the concatenation of mimeTypes
	  //    type, U+002F (/), and mimeTypes subtype.
	  let serialization = essence;

	  // 2. For each name  value of mimeTypes parameters:
	  for (let [name, value] of parameters.entries()) {
	    // 1. Append U+003B (;) to serialization.
	    serialization += ';';

	    // 2. Append name to serialization.
	    serialization += name;

	    // 3. Append U+003D (=) to serialization.
	    serialization += '=';

	    // 4. If value does not solely contain HTTP token code
	    //    points or value is the empty string, then:
	    if (!HTTP_TOKEN_CODEPOINTS.test(value)) {
	      // 1. Precede each occurence of U+0022 (") or
	      //    U+005C (\) in value with U+005C (\).
	      value = value.replace(/(\\|")/g, '\\$1');

	      // 2. Prepend U+0022 (") to value.
	      value = '"' + value;

	      // 3. Append U+0022 (") to value.
	      value += '"';
	    }

	    // 5. Append value to serialization.
	    serialization += value;
	  }

	  // 3. Return serialization.
	  return serialization
	}

	/**
	 * @see https://fetch.spec.whatwg.org/#http-whitespace
	 * @param {string} char
	 */
	function isHTTPWhiteSpace (char) {
	  return char === '\r' || char === '\n' || char === '\t' || char === ' '
	}

	/**
	 * @see https://fetch.spec.whatwg.org/#http-whitespace
	 * @param {string} str
	 */
	function removeHTTPWhitespace (str, leading = true, trailing = true) {
	  let lead = 0;
	  let trail = str.length - 1;

	  if (leading) {
	    for (; lead < str.length && isHTTPWhiteSpace(str[lead]); lead++);
	  }

	  if (trailing) {
	    for (; trail > 0 && isHTTPWhiteSpace(str[trail]); trail--);
	  }

	  return str.slice(lead, trail + 1)
	}

	/**
	 * @see https://infra.spec.whatwg.org/#ascii-whitespace
	 * @param {string} char
	 */
	function isASCIIWhitespace (char) {
	  return char === '\r' || char === '\n' || char === '\t' || char === '\f' || char === ' '
	}

	/**
	 * @see https://infra.spec.whatwg.org/#strip-leading-and-trailing-ascii-whitespace
	 */
	function removeASCIIWhitespace (str, leading = true, trailing = true) {
	  let lead = 0;
	  let trail = str.length - 1;

	  if (leading) {
	    for (; lead < str.length && isASCIIWhitespace(str[lead]); lead++);
	  }

	  if (trailing) {
	    for (; trail > 0 && isASCIIWhitespace(str[trail]); trail--);
	  }

	  return str.slice(lead, trail + 1)
	}

	dataURL = {
	  dataURLProcessor,
	  URLSerializer,
	  collectASequenceOfCodePoints,
	  collectASequenceOfCodePointsFast,
	  stringPercentDecode,
	  parseMIMEType,
	  collectAnHTTPQuotedString,
	  serializeAMimeType
	};
	return dataURL;
}

var file;
var hasRequiredFile;

function requireFile () {
	if (hasRequiredFile) return file;
	hasRequiredFile = 1;

	const { Blob, File: NativeFile } = require$$7;
	const { types } = require$$0$2;
	const { kState } = requireSymbols$3();
	const { isBlobLike } = requireUtil$5();
	const { webidl } = requireWebidl();
	const { parseMIMEType, serializeAMimeType } = requireDataURL();
	const { kEnumerableProperty } = requireUtil$6();
	const encoder = new TextEncoder();

	class File extends Blob {
	  constructor (fileBits, fileName, options = {}) {
	    // The File constructor is invoked with two or three parameters, depending
	    // on whether the optional dictionary parameter is used. When the File()
	    // constructor is invoked, user agents must run the following steps:
	    webidl.argumentLengthCheck(arguments, 2, { header: 'File constructor' });

	    fileBits = webidl.converters['sequence<BlobPart>'](fileBits);
	    fileName = webidl.converters.USVString(fileName);
	    options = webidl.converters.FilePropertyBag(options);

	    // 1. Let bytes be the result of processing blob parts given fileBits and
	    // options.
	    // Note: Blob handles this for us

	    // 2. Let n be the fileName argument to the constructor.
	    const n = fileName;

	    // 3. Process FilePropertyBag dictionary argument by running the following
	    // substeps:

	    //    1. If the type member is provided and is not the empty string, let t
	    //    be set to the type dictionary member. If t contains any characters
	    //    outside the range U+0020 to U+007E, then set t to the empty string
	    //    and return from these substeps.
	    //    2. Convert every character in t to ASCII lowercase.
	    let t = options.type;
	    let d;

	    // eslint-disable-next-line no-labels
	    substep: {
	      if (t) {
	        t = parseMIMEType(t);

	        if (t === 'failure') {
	          t = '';
	          // eslint-disable-next-line no-labels
	          break substep
	        }

	        t = serializeAMimeType(t).toLowerCase();
	      }

	      //    3. If the lastModified member is provided, let d be set to the
	      //    lastModified dictionary member. If it is not provided, set d to the
	      //    current date and time represented as the number of milliseconds since
	      //    the Unix Epoch (which is the equivalent of Date.now() [ECMA-262]).
	      d = options.lastModified;
	    }

	    // 4. Return a new File object F such that:
	    // F refers to the bytes byte sequence.
	    // F.size is set to the number of total bytes in bytes.
	    // F.name is set to n.
	    // F.type is set to t.
	    // F.lastModified is set to d.

	    super(processBlobParts(fileBits, options), { type: t });
	    this[kState] = {
	      name: n,
	      lastModified: d,
	      type: t
	    };
	  }

	  get name () {
	    webidl.brandCheck(this, File);

	    return this[kState].name
	  }

	  get lastModified () {
	    webidl.brandCheck(this, File);

	    return this[kState].lastModified
	  }

	  get type () {
	    webidl.brandCheck(this, File);

	    return this[kState].type
	  }
	}

	class FileLike {
	  constructor (blobLike, fileName, options = {}) {
	    // TODO: argument idl type check

	    // The File constructor is invoked with two or three parameters, depending
	    // on whether the optional dictionary parameter is used. When the File()
	    // constructor is invoked, user agents must run the following steps:

	    // 1. Let bytes be the result of processing blob parts given fileBits and
	    // options.

	    // 2. Let n be the fileName argument to the constructor.
	    const n = fileName;

	    // 3. Process FilePropertyBag dictionary argument by running the following
	    // substeps:

	    //    1. If the type member is provided and is not the empty string, let t
	    //    be set to the type dictionary member. If t contains any characters
	    //    outside the range U+0020 to U+007E, then set t to the empty string
	    //    and return from these substeps.
	    //    TODO
	    const t = options.type;

	    //    2. Convert every character in t to ASCII lowercase.
	    //    TODO

	    //    3. If the lastModified member is provided, let d be set to the
	    //    lastModified dictionary member. If it is not provided, set d to the
	    //    current date and time represented as the number of milliseconds since
	    //    the Unix Epoch (which is the equivalent of Date.now() [ECMA-262]).
	    const d = options.lastModified ?? Date.now();

	    // 4. Return a new File object F such that:
	    // F refers to the bytes byte sequence.
	    // F.size is set to the number of total bytes in bytes.
	    // F.name is set to n.
	    // F.type is set to t.
	    // F.lastModified is set to d.

	    this[kState] = {
	      blobLike,
	      name: n,
	      type: t,
	      lastModified: d
	    };
	  }

	  stream (...args) {
	    webidl.brandCheck(this, FileLike);

	    return this[kState].blobLike.stream(...args)
	  }

	  arrayBuffer (...args) {
	    webidl.brandCheck(this, FileLike);

	    return this[kState].blobLike.arrayBuffer(...args)
	  }

	  slice (...args) {
	    webidl.brandCheck(this, FileLike);

	    return this[kState].blobLike.slice(...args)
	  }

	  text (...args) {
	    webidl.brandCheck(this, FileLike);

	    return this[kState].blobLike.text(...args)
	  }

	  get size () {
	    webidl.brandCheck(this, FileLike);

	    return this[kState].blobLike.size
	  }

	  get type () {
	    webidl.brandCheck(this, FileLike);

	    return this[kState].blobLike.type
	  }

	  get name () {
	    webidl.brandCheck(this, FileLike);

	    return this[kState].name
	  }

	  get lastModified () {
	    webidl.brandCheck(this, FileLike);

	    return this[kState].lastModified
	  }

	  get [Symbol.toStringTag] () {
	    return 'File'
	  }
	}

	Object.defineProperties(File.prototype, {
	  [Symbol.toStringTag]: {
	    value: 'File',
	    configurable: true
	  },
	  name: kEnumerableProperty,
	  lastModified: kEnumerableProperty
	});

	webidl.converters.Blob = webidl.interfaceConverter(Blob);

	webidl.converters.BlobPart = function (V, opts) {
	  if (webidl.util.Type(V) === 'Object') {
	    if (isBlobLike(V)) {
	      return webidl.converters.Blob(V, { strict: false })
	    }

	    if (
	      ArrayBuffer.isView(V) ||
	      types.isAnyArrayBuffer(V)
	    ) {
	      return webidl.converters.BufferSource(V, opts)
	    }
	  }

	  return webidl.converters.USVString(V, opts)
	};

	webidl.converters['sequence<BlobPart>'] = webidl.sequenceConverter(
	  webidl.converters.BlobPart
	);

	// https://www.w3.org/TR/FileAPI/#dfn-FilePropertyBag
	webidl.converters.FilePropertyBag = webidl.dictionaryConverter([
	  {
	    key: 'lastModified',
	    converter: webidl.converters['long long'],
	    get defaultValue () {
	      return Date.now()
	    }
	  },
	  {
	    key: 'type',
	    converter: webidl.converters.DOMString,
	    defaultValue: ''
	  },
	  {
	    key: 'endings',
	    converter: (value) => {
	      value = webidl.converters.DOMString(value);
	      value = value.toLowerCase();

	      if (value !== 'native') {
	        value = 'transparent';
	      }

	      return value
	    },
	    defaultValue: 'transparent'
	  }
	]);

	/**
	 * @see https://www.w3.org/TR/FileAPI/#process-blob-parts
	 * @param {(NodeJS.TypedArray|Blob|string)[]} parts
	 * @param {{ type: string, endings: string }} options
	 */
	function processBlobParts (parts, options) {
	  // 1. Let bytes be an empty sequence of bytes.
	  /** @type {NodeJS.TypedArray[]} */
	  const bytes = [];

	  // 2. For each element in parts:
	  for (const element of parts) {
	    // 1. If element is a USVString, run the following substeps:
	    if (typeof element === 'string') {
	      // 1. Let s be element.
	      let s = element;

	      // 2. If the endings member of options is "native", set s
	      //    to the result of converting line endings to native
	      //    of element.
	      if (options.endings === 'native') {
	        s = convertLineEndingsNative(s);
	      }

	      // 3. Append the result of UTF-8 encoding s to bytes.
	      bytes.push(encoder.encode(s));
	    } else if (
	      types.isAnyArrayBuffer(element) ||
	      types.isTypedArray(element)
	    ) {
	      // 2. If element is a BufferSource, get a copy of the
	      //    bytes held by the buffer source, and append those
	      //    bytes to bytes.
	      if (!element.buffer) { // ArrayBuffer
	        bytes.push(new Uint8Array(element));
	      } else {
	        bytes.push(
	          new Uint8Array(element.buffer, element.byteOffset, element.byteLength)
	        );
	      }
	    } else if (isBlobLike(element)) {
	      // 3. If element is a Blob, append the bytes it represents
	      //    to bytes.
	      bytes.push(element);
	    }
	  }

	  // 3. Return bytes.
	  return bytes
	}

	/**
	 * @see https://www.w3.org/TR/FileAPI/#convert-line-endings-to-native
	 * @param {string} s
	 */
	function convertLineEndingsNative (s) {
	  // 1. Let native line ending be be the code point U+000A LF.
	  let nativeLineEnding = '\n';

	  // 2. If the underlying platforms conventions are to
	  //    represent newlines as a carriage return and line feed
	  //    sequence, set native line ending to the code point
	  //    U+000D CR followed by the code point U+000A LF.
	  if (process.platform === 'win32') {
	    nativeLineEnding = '\r\n';
	  }

	  return s.replace(/\r?\n/g, nativeLineEnding)
	}

	// If this function is moved to ./util.js, some tools (such as
	// rollup) will warn about circular dependencies. See:
	// https://github.com/nodejs/undici/issues/1629
	function isFileLike (object) {
	  return (
	    (NativeFile && object instanceof NativeFile) ||
	    object instanceof File || (
	      object &&
	      (typeof object.stream === 'function' ||
	      typeof object.arrayBuffer === 'function') &&
	      object[Symbol.toStringTag] === 'File'
	    )
	  )
	}

	file = { File, FileLike, isFileLike };
	return file;
}

var formdata;
var hasRequiredFormdata;

function requireFormdata () {
	if (hasRequiredFormdata) return formdata;
	hasRequiredFormdata = 1;

	const { isBlobLike, toUSVString, makeIterator } = requireUtil$5();
	const { kState } = requireSymbols$3();
	const { File: UndiciFile, FileLike, isFileLike } = requireFile();
	const { webidl } = requireWebidl();
	const { Blob, File: NativeFile } = require$$7;

	/** @type {globalThis['File']} */
	const File = NativeFile ?? UndiciFile;

	// https://xhr.spec.whatwg.org/#formdata
	class FormData {
	  constructor (form) {
	    if (form !== undefined) {
	      throw webidl.errors.conversionFailed({
	        prefix: 'FormData constructor',
	        argument: 'Argument 1',
	        types: ['undefined']
	      })
	    }

	    this[kState] = [];
	  }

	  append (name, value, filename = undefined) {
	    webidl.brandCheck(this, FormData);

	    webidl.argumentLengthCheck(arguments, 2, { header: 'FormData.append' });

	    if (arguments.length === 3 && !isBlobLike(value)) {
	      throw new TypeError(
	        "Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'"
	      )
	    }

	    // 1. Let value be value if given; otherwise blobValue.

	    name = webidl.converters.USVString(name);
	    value = isBlobLike(value)
	      ? webidl.converters.Blob(value, { strict: false })
	      : webidl.converters.USVString(value);
	    filename = arguments.length === 3
	      ? webidl.converters.USVString(filename)
	      : undefined;

	    // 2. Let entry be the result of creating an entry with
	    // name, value, and filename if given.
	    const entry = makeEntry(name, value, filename);

	    // 3. Append entry to thiss entry list.
	    this[kState].push(entry);
	  }

	  delete (name) {
	    webidl.brandCheck(this, FormData);

	    webidl.argumentLengthCheck(arguments, 1, { header: 'FormData.delete' });

	    name = webidl.converters.USVString(name);

	    // The delete(name) method steps are to remove all entries whose name
	    // is name from thiss entry list.
	    this[kState] = this[kState].filter(entry => entry.name !== name);
	  }

	  get (name) {
	    webidl.brandCheck(this, FormData);

	    webidl.argumentLengthCheck(arguments, 1, { header: 'FormData.get' });

	    name = webidl.converters.USVString(name);

	    // 1. If there is no entry whose name is name in thiss entry list,
	    // then return null.
	    const idx = this[kState].findIndex((entry) => entry.name === name);
	    if (idx === -1) {
	      return null
	    }

	    // 2. Return the value of the first entry whose name is name from
	    // thiss entry list.
	    return this[kState][idx].value
	  }

	  getAll (name) {
	    webidl.brandCheck(this, FormData);

	    webidl.argumentLengthCheck(arguments, 1, { header: 'FormData.getAll' });

	    name = webidl.converters.USVString(name);

	    // 1. If there is no entry whose name is name in thiss entry list,
	    // then return the empty list.
	    // 2. Return the values of all entries whose name is name, in order,
	    // from thiss entry list.
	    return this[kState]
	      .filter((entry) => entry.name === name)
	      .map((entry) => entry.value)
	  }

	  has (name) {
	    webidl.brandCheck(this, FormData);

	    webidl.argumentLengthCheck(arguments, 1, { header: 'FormData.has' });

	    name = webidl.converters.USVString(name);

	    // The has(name) method steps are to return true if there is an entry
	    // whose name is name in thiss entry list; otherwise false.
	    return this[kState].findIndex((entry) => entry.name === name) !== -1
	  }

	  set (name, value, filename = undefined) {
	    webidl.brandCheck(this, FormData);

	    webidl.argumentLengthCheck(arguments, 2, { header: 'FormData.set' });

	    if (arguments.length === 3 && !isBlobLike(value)) {
	      throw new TypeError(
	        "Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'"
	      )
	    }

	    // The set(name, value) and set(name, blobValue, filename) method steps
	    // are:

	    // 1. Let value be value if given; otherwise blobValue.

	    name = webidl.converters.USVString(name);
	    value = isBlobLike(value)
	      ? webidl.converters.Blob(value, { strict: false })
	      : webidl.converters.USVString(value);
	    filename = arguments.length === 3
	      ? toUSVString(filename)
	      : undefined;

	    // 2. Let entry be the result of creating an entry with name, value, and
	    // filename if given.
	    const entry = makeEntry(name, value, filename);

	    // 3. If there are entries in thiss entry list whose name is name, then
	    // replace the first such entry with entry and remove the others.
	    const idx = this[kState].findIndex((entry) => entry.name === name);
	    if (idx !== -1) {
	      this[kState] = [
	        ...this[kState].slice(0, idx),
	        entry,
	        ...this[kState].slice(idx + 1).filter((entry) => entry.name !== name)
	      ];
	    } else {
	      // 4. Otherwise, append entry to thiss entry list.
	      this[kState].push(entry);
	    }
	  }

	  entries () {
	    webidl.brandCheck(this, FormData);

	    return makeIterator(
	      () => this[kState].map(pair => [pair.name, pair.value]),
	      'FormData',
	      'key+value'
	    )
	  }

	  keys () {
	    webidl.brandCheck(this, FormData);

	    return makeIterator(
	      () => this[kState].map(pair => [pair.name, pair.value]),
	      'FormData',
	      'key'
	    )
	  }

	  values () {
	    webidl.brandCheck(this, FormData);

	    return makeIterator(
	      () => this[kState].map(pair => [pair.name, pair.value]),
	      'FormData',
	      'value'
	    )
	  }

	  /**
	   * @param {(value: string, key: string, self: FormData) => void} callbackFn
	   * @param {unknown} thisArg
	   */
	  forEach (callbackFn, thisArg = globalThis) {
	    webidl.brandCheck(this, FormData);

	    webidl.argumentLengthCheck(arguments, 1, { header: 'FormData.forEach' });

	    if (typeof callbackFn !== 'function') {
	      throw new TypeError(
	        "Failed to execute 'forEach' on 'FormData': parameter 1 is not of type 'Function'."
	      )
	    }

	    for (const [key, value] of this) {
	      callbackFn.apply(thisArg, [value, key, this]);
	    }
	  }
	}

	FormData.prototype[Symbol.iterator] = FormData.prototype.entries;

	Object.defineProperties(FormData.prototype, {
	  [Symbol.toStringTag]: {
	    value: 'FormData',
	    configurable: true
	  }
	});

	/**
	 * @see https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#create-an-entry
	 * @param {string} name
	 * @param {string|Blob} value
	 * @param {?string} filename
	 * @returns
	 */
	function makeEntry (name, value, filename) {
	  // 1. Set name to the result of converting name into a scalar value string.
	  // "To convert a string into a scalar value string, replace any surrogates
	  //  with U+FFFD."
	  // see: https://nodejs.org/dist/latest-v18.x/docs/api/buffer.html#buftostringencoding-start-end
	  name = Buffer.from(name).toString('utf8');

	  // 2. If value is a string, then set value to the result of converting
	  //    value into a scalar value string.
	  if (typeof value === 'string') {
	    value = Buffer.from(value).toString('utf8');
	  } else {
	    // 3. Otherwise:

	    // 1. If value is not a File object, then set value to a new File object,
	    //    representing the same bytes, whose name attribute value is "blob"
	    if (!isFileLike(value)) {
	      value = value instanceof Blob
	        ? new File([value], 'blob', { type: value.type })
	        : new FileLike(value, 'blob', { type: value.type });
	    }

	    // 2. If filename is given, then set value to a new File object,
	    //    representing the same bytes, whose name attribute is filename.
	    if (filename !== undefined) {
	      /** @type {FilePropertyBag} */
	      const options = {
	        type: value.type,
	        lastModified: value.lastModified
	      };

	      value = (NativeFile && value instanceof NativeFile) || value instanceof UndiciFile
	        ? new File([value], filename, options)
	        : new FileLike(value, filename, options);
	    }
	  }

	  // 4. Return an entry whose name is name and whose value is value.
	  return { name, value }
	}

	formdata = { FormData };
	return formdata;
}

var body;
var hasRequiredBody;

function requireBody () {
	if (hasRequiredBody) return body;
	hasRequiredBody = 1;

	const Busboy = requireMain$1();
	const util = requireUtil$6();
	const {
	  ReadableStreamFrom,
	  isBlobLike,
	  isReadableStreamLike,
	  readableStreamClose,
	  createDeferredPromise,
	  fullyReadBody
	} = requireUtil$5();
	const { FormData } = requireFormdata();
	const { kState } = requireSymbols$3();
	const { webidl } = requireWebidl();
	const { DOMException, structuredClone } = requireConstants$5();
	const { Blob, File: NativeFile } = require$$7;
	const { kBodyUsed } = requireSymbols$4();
	const assert = require$$0$4;
	const { isErrored } = requireUtil$6();
	const { isUint8Array, isArrayBuffer } = require$$5;
	const { File: UndiciFile } = requireFile();
	const { parseMIMEType, serializeAMimeType } = requireDataURL();

	let random;
	try {
	  const crypto = require('node:crypto');
	  random = (max) => crypto.randomInt(0, max);
	} catch {
	  random = (max) => Math.floor(Math.random(max));
	}

	let ReadableStream = globalThis.ReadableStream;

	/** @type {globalThis['File']} */
	const File = NativeFile ?? UndiciFile;
	const textEncoder = new TextEncoder();
	const textDecoder = new TextDecoder();

	// https://fetch.spec.whatwg.org/#concept-bodyinit-extract
	function extractBody (object, keepalive = false) {
	  if (!ReadableStream) {
	    ReadableStream = require$$14.ReadableStream;
	  }

	  // 1. Let stream be null.
	  let stream = null;

	  // 2. If object is a ReadableStream object, then set stream to object.
	  if (object instanceof ReadableStream) {
	    stream = object;
	  } else if (isBlobLike(object)) {
	    // 3. Otherwise, if object is a Blob object, set stream to the
	    //    result of running objects get stream.
	    stream = object.stream();
	  } else {
	    // 4. Otherwise, set stream to a new ReadableStream object, and set
	    //    up stream.
	    stream = new ReadableStream({
	      async pull (controller) {
	        controller.enqueue(
	          typeof source === 'string' ? textEncoder.encode(source) : source
	        );
	        queueMicrotask(() => readableStreamClose(controller));
	      },
	      start () {},
	      type: undefined
	    });
	  }

	  // 5. Assert: stream is a ReadableStream object.
	  assert(isReadableStreamLike(stream));

	  // 6. Let action be null.
	  let action = null;

	  // 7. Let source be null.
	  let source = null;

	  // 8. Let length be null.
	  let length = null;

	  // 9. Let type be null.
	  let type = null;

	  // 10. Switch on object:
	  if (typeof object === 'string') {
	    // Set source to the UTF-8 encoding of object.
	    // Note: setting source to a Uint8Array here breaks some mocking assumptions.
	    source = object;

	    // Set type to `text/plain;charset=UTF-8`.
	    type = 'text/plain;charset=UTF-8';
	  } else if (object instanceof URLSearchParams) {
	    // URLSearchParams

	    // spec says to run application/x-www-form-urlencoded on body.list
	    // this is implemented in Node.js as apart of an URLSearchParams instance toString method
	    // See: https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L490
	    // and https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L1100

	    // Set source to the result of running the application/x-www-form-urlencoded serializer with objects list.
	    source = object.toString();

	    // Set type to `application/x-www-form-urlencoded;charset=UTF-8`.
	    type = 'application/x-www-form-urlencoded;charset=UTF-8';
	  } else if (isArrayBuffer(object)) {
	    // BufferSource/ArrayBuffer

	    // Set source to a copy of the bytes held by object.
	    source = new Uint8Array(object.slice());
	  } else if (ArrayBuffer.isView(object)) {
	    // BufferSource/ArrayBufferView

	    // Set source to a copy of the bytes held by object.
	    source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));
	  } else if (util.isFormDataLike(object)) {
	    const boundary = `----formdata-undici-0${`${random(1e11)}`.padStart(11, '0')}`;
	    const prefix = `--${boundary}\r\nContent-Disposition: form-data`;

	    /*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */
	    const escape = (str) =>
	      str.replace(/\n/g, '%0A').replace(/\r/g, '%0D').replace(/"/g, '%22');
	    const normalizeLinefeeds = (value) => value.replace(/\r?\n|\r/g, '\r\n');

	    // Set action to this step: run the multipart/form-data
	    // encoding algorithm, with objects entry list and UTF-8.
	    // - This ensures that the body is immutable and can't be changed afterwords
	    // - That the content-length is calculated in advance.
	    // - And that all parts are pre-encoded and ready to be sent.

	    const blobParts = [];
	    const rn = new Uint8Array([13, 10]); // '\r\n'
	    length = 0;
	    let hasUnknownSizeValue = false;

	    for (const [name, value] of object) {
	      if (typeof value === 'string') {
	        const chunk = textEncoder.encode(prefix +
	          `; name="${escape(normalizeLinefeeds(name))}"` +
	          `\r\n\r\n${normalizeLinefeeds(value)}\r\n`);
	        blobParts.push(chunk);
	        length += chunk.byteLength;
	      } else {
	        const chunk = textEncoder.encode(`${prefix}; name="${escape(normalizeLinefeeds(name))}"` +
	          (value.name ? `; filename="${escape(value.name)}"` : '') + '\r\n' +
	          `Content-Type: ${
	            value.type || 'application/octet-stream'
	          }\r\n\r\n`);
	        blobParts.push(chunk, value, rn);
	        if (typeof value.size === 'number') {
	          length += chunk.byteLength + value.size + rn.byteLength;
	        } else {
	          hasUnknownSizeValue = true;
	        }
	      }
	    }

	    const chunk = textEncoder.encode(`--${boundary}--`);
	    blobParts.push(chunk);
	    length += chunk.byteLength;
	    if (hasUnknownSizeValue) {
	      length = null;
	    }

	    // Set source to object.
	    source = object;

	    action = async function * () {
	      for (const part of blobParts) {
	        if (part.stream) {
	          yield * part.stream();
	        } else {
	          yield part;
	        }
	      }
	    };

	    // Set type to `multipart/form-data; boundary=`,
	    // followed by the multipart/form-data boundary string generated
	    // by the multipart/form-data encoding algorithm.
	    type = 'multipart/form-data; boundary=' + boundary;
	  } else if (isBlobLike(object)) {
	    // Blob

	    // Set source to object.
	    source = object;

	    // Set length to objects size.
	    length = object.size;

	    // If objects type attribute is not the empty byte sequence, set
	    // type to its value.
	    if (object.type) {
	      type = object.type;
	    }
	  } else if (typeof object[Symbol.asyncIterator] === 'function') {
	    // If keepalive is true, then throw a TypeError.
	    if (keepalive) {
	      throw new TypeError('keepalive')
	    }

	    // If object is disturbed or locked, then throw a TypeError.
	    if (util.isDisturbed(object) || object.locked) {
	      throw new TypeError(
	        'Response body object should not be disturbed or locked'
	      )
	    }

	    stream =
	      object instanceof ReadableStream ? object : ReadableStreamFrom(object);
	  }

	  // 11. If source is a byte sequence, then set action to a
	  // step that returns source and length to sources length.
	  if (typeof source === 'string' || util.isBuffer(source)) {
	    length = Buffer.byteLength(source);
	  }

	  // 12. If action is non-null, then run these steps in in parallel:
	  if (action != null) {
	    // Run action.
	    let iterator;
	    stream = new ReadableStream({
	      async start () {
	        iterator = action(object)[Symbol.asyncIterator]();
	      },
	      async pull (controller) {
	        const { value, done } = await iterator.next();
	        if (done) {
	          // When running action is done, close stream.
	          queueMicrotask(() => {
	            controller.close();
	          });
	        } else {
	          // Whenever one or more bytes are available and stream is not errored,
	          // enqueue a Uint8Array wrapping an ArrayBuffer containing the available
	          // bytes into stream.
	          if (!isErrored(stream)) {
	            controller.enqueue(new Uint8Array(value));
	          }
	        }
	        return controller.desiredSize > 0
	      },
	      async cancel (reason) {
	        await iterator.return();
	      },
	      type: undefined
	    });
	  }

	  // 13. Let body be a body whose stream is stream, source is source,
	  // and length is length.
	  const body = { stream, source, length };

	  // 14. Return (body, type).
	  return [body, type]
	}

	// https://fetch.spec.whatwg.org/#bodyinit-safely-extract
	function safelyExtractBody (object, keepalive = false) {
	  if (!ReadableStream) {
	    // istanbul ignore next
	    ReadableStream = require$$14.ReadableStream;
	  }

	  // To safely extract a body and a `Content-Type` value from
	  // a byte sequence or BodyInit object object, run these steps:

	  // 1. If object is a ReadableStream object, then:
	  if (object instanceof ReadableStream) {
	    // Assert: object is neither disturbed nor locked.
	    // istanbul ignore next
	    assert(!util.isDisturbed(object), 'The body has already been consumed.');
	    // istanbul ignore next
	    assert(!object.locked, 'The stream is locked.');
	  }

	  // 2. Return the results of extracting object.
	  return extractBody(object, keepalive)
	}

	function cloneBody (body) {
	  // To clone a body body, run these steps:

	  // https://fetch.spec.whatwg.org/#concept-body-clone

	  // 1. Let  out1, out2  be the result of teeing bodys stream.
	  const [out1, out2] = body.stream.tee();
	  const out2Clone = structuredClone(out2, { transfer: [out2] });
	  // This, for whatever reasons, unrefs out2Clone which allows
	  // the process to exit by itself.
	  const [, finalClone] = out2Clone.tee();

	  // 2. Set bodys stream to out1.
	  body.stream = out1;

	  // 3. Return a body whose stream is out2 and other members are copied from body.
	  return {
	    stream: finalClone,
	    length: body.length,
	    source: body.source
	  }
	}

	async function * consumeBody (body) {
	  if (body) {
	    if (isUint8Array(body)) {
	      yield body;
	    } else {
	      const stream = body.stream;

	      if (util.isDisturbed(stream)) {
	        throw new TypeError('The body has already been consumed.')
	      }

	      if (stream.locked) {
	        throw new TypeError('The stream is locked.')
	      }

	      // Compat.
	      stream[kBodyUsed] = true;

	      yield * stream;
	    }
	  }
	}

	function throwIfAborted (state) {
	  if (state.aborted) {
	    throw new DOMException('The operation was aborted.', 'AbortError')
	  }
	}

	function bodyMixinMethods (instance) {
	  const methods = {
	    blob () {
	      // The blob() method steps are to return the result of
	      // running consume body with this and the following step
	      // given a byte sequence bytes: return a Blob whose
	      // contents are bytes and whose type attribute is thiss
	      // MIME type.
	      return specConsumeBody(this, (bytes) => {
	        let mimeType = bodyMimeType(this);

	        if (mimeType === 'failure') {
	          mimeType = '';
	        } else if (mimeType) {
	          mimeType = serializeAMimeType(mimeType);
	        }

	        // Return a Blob whose contents are bytes and type attribute
	        // is mimeType.
	        return new Blob([bytes], { type: mimeType })
	      }, instance)
	    },

	    arrayBuffer () {
	      // The arrayBuffer() method steps are to return the result
	      // of running consume body with this and the following step
	      // given a byte sequence bytes: return a new ArrayBuffer
	      // whose contents are bytes.
	      return specConsumeBody(this, (bytes) => {
	        return new Uint8Array(bytes).buffer
	      }, instance)
	    },

	    text () {
	      // The text() method steps are to return the result of running
	      // consume body with this and UTF-8 decode.
	      return specConsumeBody(this, utf8DecodeBytes, instance)
	    },

	    json () {
	      // The json() method steps are to return the result of running
	      // consume body with this and parse JSON from bytes.
	      return specConsumeBody(this, parseJSONFromBytes, instance)
	    },

	    async formData () {
	      webidl.brandCheck(this, instance);

	      throwIfAborted(this[kState]);

	      const contentType = this.headers.get('Content-Type');

	      // If mimeTypes essence is "multipart/form-data", then:
	      if (/multipart\/form-data/.test(contentType)) {
	        const headers = {};
	        for (const [key, value] of this.headers) headers[key.toLowerCase()] = value;

	        const responseFormData = new FormData();

	        let busboy;

	        try {
	          busboy = new Busboy({
	            headers,
	            preservePath: true
	          });
	        } catch (err) {
	          throw new DOMException(`${err}`, 'AbortError')
	        }

	        busboy.on('field', (name, value) => {
	          responseFormData.append(name, value);
	        });
	        busboy.on('file', (name, value, filename, encoding, mimeType) => {
	          const chunks = [];

	          if (encoding === 'base64' || encoding.toLowerCase() === 'base64') {
	            let base64chunk = '';

	            value.on('data', (chunk) => {
	              base64chunk += chunk.toString().replace(/[\r\n]/gm, '');

	              const end = base64chunk.length - base64chunk.length % 4;
	              chunks.push(Buffer.from(base64chunk.slice(0, end), 'base64'));

	              base64chunk = base64chunk.slice(end);
	            });
	            value.on('end', () => {
	              chunks.push(Buffer.from(base64chunk, 'base64'));
	              responseFormData.append(name, new File(chunks, filename, { type: mimeType }));
	            });
	          } else {
	            value.on('data', (chunk) => {
	              chunks.push(chunk);
	            });
	            value.on('end', () => {
	              responseFormData.append(name, new File(chunks, filename, { type: mimeType }));
	            });
	          }
	        });

	        const busboyResolve = new Promise((resolve, reject) => {
	          busboy.on('finish', resolve);
	          busboy.on('error', (err) => reject(new TypeError(err)));
	        });

	        if (this.body !== null) for await (const chunk of consumeBody(this[kState].body)) busboy.write(chunk);
	        busboy.end();
	        await busboyResolve;

	        return responseFormData
	      } else if (/application\/x-www-form-urlencoded/.test(contentType)) {
	        // Otherwise, if mimeTypes essence is "application/x-www-form-urlencoded", then:

	        // 1. Let entries be the result of parsing bytes.
	        let entries;
	        try {
	          let text = '';
	          // application/x-www-form-urlencoded parser will keep the BOM.
	          // https://url.spec.whatwg.org/#concept-urlencoded-parser
	          // Note that streaming decoder is stateful and cannot be reused
	          const streamingDecoder = new TextDecoder('utf-8', { ignoreBOM: true });

	          for await (const chunk of consumeBody(this[kState].body)) {
	            if (!isUint8Array(chunk)) {
	              throw new TypeError('Expected Uint8Array chunk')
	            }
	            text += streamingDecoder.decode(chunk, { stream: true });
	          }
	          text += streamingDecoder.decode();
	          entries = new URLSearchParams(text);
	        } catch (err) {
	          // istanbul ignore next: Unclear when new URLSearchParams can fail on a string.
	          // 2. If entries is failure, then throw a TypeError.
	          throw Object.assign(new TypeError(), { cause: err })
	        }

	        // 3. Return a new FormData object whose entries are entries.
	        const formData = new FormData();
	        for (const [name, value] of entries) {
	          formData.append(name, value);
	        }
	        return formData
	      } else {
	        // Wait a tick before checking if the request has been aborted.
	        // Otherwise, a TypeError can be thrown when an AbortError should.
	        await Promise.resolve();

	        throwIfAborted(this[kState]);

	        // Otherwise, throw a TypeError.
	        throw webidl.errors.exception({
	          header: `${instance.name}.formData`,
	          message: 'Could not parse content as FormData.'
	        })
	      }
	    }
	  };

	  return methods
	}

	function mixinBody (prototype) {
	  Object.assign(prototype.prototype, bodyMixinMethods(prototype));
	}

	/**
	 * @see https://fetch.spec.whatwg.org/#concept-body-consume-body
	 * @param {Response|Request} object
	 * @param {(value: unknown) => unknown} convertBytesToJSValue
	 * @param {Response|Request} instance
	 */
	async function specConsumeBody (object, convertBytesToJSValue, instance) {
	  webidl.brandCheck(object, instance);

	  throwIfAborted(object[kState]);

	  // 1. If object is unusable, then return a promise rejected
	  //    with a TypeError.
	  if (bodyUnusable(object[kState].body)) {
	    throw new TypeError('Body is unusable')
	  }

	  // 2. Let promise be a new promise.
	  const promise = createDeferredPromise();

	  // 3. Let errorSteps given error be to reject promise with error.
	  const errorSteps = (error) => promise.reject(error);

	  // 4. Let successSteps given a byte sequence data be to resolve
	  //    promise with the result of running convertBytesToJSValue
	  //    with data. If that threw an exception, then run errorSteps
	  //    with that exception.
	  const successSteps = (data) => {
	    try {
	      promise.resolve(convertBytesToJSValue(data));
	    } catch (e) {
	      errorSteps(e);
	    }
	  };

	  // 5. If objects body is null, then run successSteps with an
	  //    empty byte sequence.
	  if (object[kState].body == null) {
	    successSteps(new Uint8Array());
	    return promise.promise
	  }

	  // 6. Otherwise, fully read objects body given successSteps,
	  //    errorSteps, and objects relevant global object.
	  await fullyReadBody(object[kState].body, successSteps, errorSteps);

	  // 7. Return promise.
	  return promise.promise
	}

	// https://fetch.spec.whatwg.org/#body-unusable
	function bodyUnusable (body) {
	  // An object including the Body interface mixin is
	  // said to be unusable if its body is non-null and
	  // its bodys stream is disturbed or locked.
	  return body != null && (body.stream.locked || util.isDisturbed(body.stream))
	}

	/**
	 * @see https://encoding.spec.whatwg.org/#utf-8-decode
	 * @param {Buffer} buffer
	 */
	function utf8DecodeBytes (buffer) {
	  if (buffer.length === 0) {
	    return ''
	  }

	  // 1. Let buffer be the result of peeking three bytes from
	  //    ioQueue, converted to a byte sequence.

	  // 2. If buffer is 0xEF 0xBB 0xBF, then read three
	  //    bytes from ioQueue. (Do nothing with those bytes.)
	  if (buffer[0] === 0xEF && buffer[1] === 0xBB && buffer[2] === 0xBF) {
	    buffer = buffer.subarray(3);
	  }

	  // 3. Process a queue with an instance of UTF-8s
	  //    decoder, ioQueue, output, and "replacement".
	  const output = textDecoder.decode(buffer);

	  // 4. Return output.
	  return output
	}

	/**
	 * @see https://infra.spec.whatwg.org/#parse-json-bytes-to-a-javascript-value
	 * @param {Uint8Array} bytes
	 */
	function parseJSONFromBytes (bytes) {
	  return JSON.parse(utf8DecodeBytes(bytes))
	}

	/**
	 * @see https://fetch.spec.whatwg.org/#concept-body-mime-type
	 * @param {import('./response').Response|import('./request').Request} object
	 */
	function bodyMimeType (object) {
	  const { headersList } = object[kState];
	  const contentType = headersList.get('content-type');

	  if (contentType === null) {
	    return 'failure'
	  }

	  return parseMIMEType(contentType)
	}

	body = {
	  extractBody,
	  safelyExtractBody,
	  cloneBody,
	  mixinBody
	};
	return body;
}

var request$1;
var hasRequiredRequest$1;

function requireRequest$1 () {
	if (hasRequiredRequest$1) return request$1;
	hasRequiredRequest$1 = 1;

	const {
	  InvalidArgumentError,
	  NotSupportedError
	} = requireErrors();
	const assert = require$$0$4;
	const { kHTTP2BuildRequest, kHTTP2CopyHeaders, kHTTP1BuildRequest } = requireSymbols$4();
	const util = requireUtil$6();

	// tokenRegExp and headerCharRegex have been lifted from
	// https://github.com/nodejs/node/blob/main/lib/_http_common.js

	/**
	 * Verifies that the given val is a valid HTTP token
	 * per the rules defined in RFC 7230
	 * See https://tools.ietf.org/html/rfc7230#section-3.2.6
	 */
	const tokenRegExp = /^[\^_`a-zA-Z\-0-9!#$%&'*+.|~]+$/;

	/**
	 * Matches if val contains an invalid field-vchar
	 *  field-value    = *( field-content / obs-fold )
	 *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]
	 *  field-vchar    = VCHAR / obs-text
	 */
	const headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/;

	// Verifies that a given path is valid does not contain control chars \x00 to \x20
	const invalidPathRegex = /[^\u0021-\u00ff]/;

	const kHandler = Symbol('handler');

	const channels = {};

	let extractBody;

	try {
	  const diagnosticsChannel = require('diagnostics_channel');
	  channels.create = diagnosticsChannel.channel('undici:request:create');
	  channels.bodySent = diagnosticsChannel.channel('undici:request:bodySent');
	  channels.headers = diagnosticsChannel.channel('undici:request:headers');
	  channels.trailers = diagnosticsChannel.channel('undici:request:trailers');
	  channels.error = diagnosticsChannel.channel('undici:request:error');
	} catch {
	  channels.create = { hasSubscribers: false };
	  channels.bodySent = { hasSubscribers: false };
	  channels.headers = { hasSubscribers: false };
	  channels.trailers = { hasSubscribers: false };
	  channels.error = { hasSubscribers: false };
	}

	class Request {
	  constructor (origin, {
	    path,
	    method,
	    body,
	    headers,
	    query,
	    idempotent,
	    blocking,
	    upgrade,
	    headersTimeout,
	    bodyTimeout,
	    reset,
	    throwOnError,
	    expectContinue
	  }, handler) {
	    if (typeof path !== 'string') {
	      throw new InvalidArgumentError('path must be a string')
	    } else if (
	      path[0] !== '/' &&
	      !(path.startsWith('http://') || path.startsWith('https://')) &&
	      method !== 'CONNECT'
	    ) {
	      throw new InvalidArgumentError('path must be an absolute URL or start with a slash')
	    } else if (invalidPathRegex.exec(path) !== null) {
	      throw new InvalidArgumentError('invalid request path')
	    }

	    if (typeof method !== 'string') {
	      throw new InvalidArgumentError('method must be a string')
	    } else if (tokenRegExp.exec(method) === null) {
	      throw new InvalidArgumentError('invalid request method')
	    }

	    if (upgrade && typeof upgrade !== 'string') {
	      throw new InvalidArgumentError('upgrade must be a string')
	    }

	    if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {
	      throw new InvalidArgumentError('invalid headersTimeout')
	    }

	    if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {
	      throw new InvalidArgumentError('invalid bodyTimeout')
	    }

	    if (reset != null && typeof reset !== 'boolean') {
	      throw new InvalidArgumentError('invalid reset')
	    }

	    if (expectContinue != null && typeof expectContinue !== 'boolean') {
	      throw new InvalidArgumentError('invalid expectContinue')
	    }

	    this.headersTimeout = headersTimeout;

	    this.bodyTimeout = bodyTimeout;

	    this.throwOnError = throwOnError === true;

	    this.method = method;

	    this.abort = null;

	    if (body == null) {
	      this.body = null;
	    } else if (util.isStream(body)) {
	      this.body = body;

	      const rState = this.body._readableState;
	      if (!rState || !rState.autoDestroy) {
	        this.endHandler = function autoDestroy () {
	          util.destroy(this);
	        };
	        this.body.on('end', this.endHandler);
	      }

	      this.errorHandler = err => {
	        if (this.abort) {
	          this.abort(err);
	        } else {
	          this.error = err;
	        }
	      };
	      this.body.on('error', this.errorHandler);
	    } else if (util.isBuffer(body)) {
	      this.body = body.byteLength ? body : null;
	    } else if (ArrayBuffer.isView(body)) {
	      this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null;
	    } else if (body instanceof ArrayBuffer) {
	      this.body = body.byteLength ? Buffer.from(body) : null;
	    } else if (typeof body === 'string') {
	      this.body = body.length ? Buffer.from(body) : null;
	    } else if (util.isFormDataLike(body) || util.isIterable(body) || util.isBlobLike(body)) {
	      this.body = body;
	    } else {
	      throw new InvalidArgumentError('body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable')
	    }

	    this.completed = false;

	    this.aborted = false;

	    this.upgrade = upgrade || null;

	    this.path = query ? util.buildURL(path, query) : path;

	    this.origin = origin;

	    this.idempotent = idempotent == null
	      ? method === 'HEAD' || method === 'GET'
	      : idempotent;

	    this.blocking = blocking == null ? false : blocking;

	    this.reset = reset == null ? null : reset;

	    this.host = null;

	    this.contentLength = null;

	    this.contentType = null;

	    this.headers = '';

	    // Only for H2
	    this.expectContinue = expectContinue != null ? expectContinue : false;

	    if (Array.isArray(headers)) {
	      if (headers.length % 2 !== 0) {
	        throw new InvalidArgumentError('headers array must be even')
	      }
	      for (let i = 0; i < headers.length; i += 2) {
	        processHeader(this, headers[i], headers[i + 1]);
	      }
	    } else if (headers && typeof headers === 'object') {
	      const keys = Object.keys(headers);
	      for (let i = 0; i < keys.length; i++) {
	        const key = keys[i];
	        processHeader(this, key, headers[key]);
	      }
	    } else if (headers != null) {
	      throw new InvalidArgumentError('headers must be an object or an array')
	    }

	    if (util.isFormDataLike(this.body)) {
	      if (util.nodeMajor < 16 || (util.nodeMajor === 16 && util.nodeMinor < 8)) {
	        throw new InvalidArgumentError('Form-Data bodies are only supported in node v16.8 and newer.')
	      }

	      if (!extractBody) {
	        extractBody = requireBody().extractBody;
	      }

	      const [bodyStream, contentType] = extractBody(body);
	      if (this.contentType == null) {
	        this.contentType = contentType;
	        this.headers += `content-type: ${contentType}\r\n`;
	      }
	      this.body = bodyStream.stream;
	      this.contentLength = bodyStream.length;
	    } else if (util.isBlobLike(body) && this.contentType == null && body.type) {
	      this.contentType = body.type;
	      this.headers += `content-type: ${body.type}\r\n`;
	    }

	    util.validateHandler(handler, method, upgrade);

	    this.servername = util.getServerName(this.host);

	    this[kHandler] = handler;

	    if (channels.create.hasSubscribers) {
	      channels.create.publish({ request: this });
	    }
	  }

	  onBodySent (chunk) {
	    if (this[kHandler].onBodySent) {
	      try {
	        return this[kHandler].onBodySent(chunk)
	      } catch (err) {
	        this.abort(err);
	      }
	    }
	  }

	  onRequestSent () {
	    if (channels.bodySent.hasSubscribers) {
	      channels.bodySent.publish({ request: this });
	    }

	    if (this[kHandler].onRequestSent) {
	      try {
	        return this[kHandler].onRequestSent()
	      } catch (err) {
	        this.abort(err);
	      }
	    }
	  }

	  onConnect (abort) {
	    assert(!this.aborted);
	    assert(!this.completed);

	    if (this.error) {
	      abort(this.error);
	    } else {
	      this.abort = abort;
	      return this[kHandler].onConnect(abort)
	    }
	  }

	  onHeaders (statusCode, headers, resume, statusText) {
	    assert(!this.aborted);
	    assert(!this.completed);

	    if (channels.headers.hasSubscribers) {
	      channels.headers.publish({ request: this, response: { statusCode, headers, statusText } });
	    }

	    try {
	      return this[kHandler].onHeaders(statusCode, headers, resume, statusText)
	    } catch (err) {
	      this.abort(err);
	    }
	  }

	  onData (chunk) {
	    assert(!this.aborted);
	    assert(!this.completed);

	    try {
	      return this[kHandler].onData(chunk)
	    } catch (err) {
	      this.abort(err);
	      return false
	    }
	  }

	  onUpgrade (statusCode, headers, socket) {
	    assert(!this.aborted);
	    assert(!this.completed);

	    return this[kHandler].onUpgrade(statusCode, headers, socket)
	  }

	  onComplete (trailers) {
	    this.onFinally();

	    assert(!this.aborted);

	    this.completed = true;
	    if (channels.trailers.hasSubscribers) {
	      channels.trailers.publish({ request: this, trailers });
	    }

	    try {
	      return this[kHandler].onComplete(trailers)
	    } catch (err) {
	      // TODO (fix): This might be a bad idea?
	      this.onError(err);
	    }
	  }

	  onError (error) {
	    this.onFinally();

	    if (channels.error.hasSubscribers) {
	      channels.error.publish({ request: this, error });
	    }

	    if (this.aborted) {
	      return
	    }
	    this.aborted = true;

	    return this[kHandler].onError(error)
	  }

	  onFinally () {
	    if (this.errorHandler) {
	      this.body.off('error', this.errorHandler);
	      this.errorHandler = null;
	    }

	    if (this.endHandler) {
	      this.body.off('end', this.endHandler);
	      this.endHandler = null;
	    }
	  }

	  // TODO: adjust to support H2
	  addHeader (key, value) {
	    processHeader(this, key, value);
	    return this
	  }

	  static [kHTTP1BuildRequest] (origin, opts, handler) {
	    // TODO: Migrate header parsing here, to make Requests
	    // HTTP agnostic
	    return new Request(origin, opts, handler)
	  }

	  static [kHTTP2BuildRequest] (origin, opts, handler) {
	    const headers = opts.headers;
	    opts = { ...opts, headers: null };

	    const request = new Request(origin, opts, handler);

	    request.headers = {};

	    if (Array.isArray(headers)) {
	      if (headers.length % 2 !== 0) {
	        throw new InvalidArgumentError('headers array must be even')
	      }
	      for (let i = 0; i < headers.length; i += 2) {
	        processHeader(request, headers[i], headers[i + 1], true);
	      }
	    } else if (headers && typeof headers === 'object') {
	      const keys = Object.keys(headers);
	      for (let i = 0; i < keys.length; i++) {
	        const key = keys[i];
	        processHeader(request, key, headers[key], true);
	      }
	    } else if (headers != null) {
	      throw new InvalidArgumentError('headers must be an object or an array')
	    }

	    return request
	  }

	  static [kHTTP2CopyHeaders] (raw) {
	    const rawHeaders = raw.split('\r\n');
	    const headers = {};

	    for (const header of rawHeaders) {
	      const [key, value] = header.split(': ');

	      if (value == null || value.length === 0) continue

	      if (headers[key]) headers[key] += `,${value}`;
	      else headers[key] = value;
	    }

	    return headers
	  }
	}

	function processHeaderValue (key, val, skipAppend) {
	  if (val && typeof val === 'object') {
	    throw new InvalidArgumentError(`invalid ${key} header`)
	  }

	  val = val != null ? `${val}` : '';

	  if (headerCharRegex.exec(val) !== null) {
	    throw new InvalidArgumentError(`invalid ${key} header`)
	  }

	  return skipAppend ? val : `${key}: ${val}\r\n`
	}

	function processHeader (request, key, val, skipAppend = false) {
	  if (val && (typeof val === 'object' && !Array.isArray(val))) {
	    throw new InvalidArgumentError(`invalid ${key} header`)
	  } else if (val === undefined) {
	    return
	  }

	  if (
	    request.host === null &&
	    key.length === 4 &&
	    key.toLowerCase() === 'host'
	  ) {
	    if (headerCharRegex.exec(val) !== null) {
	      throw new InvalidArgumentError(`invalid ${key} header`)
	    }
	    // Consumed by Client
	    request.host = val;
	  } else if (
	    request.contentLength === null &&
	    key.length === 14 &&
	    key.toLowerCase() === 'content-length'
	  ) {
	    request.contentLength = parseInt(val, 10);
	    if (!Number.isFinite(request.contentLength)) {
	      throw new InvalidArgumentError('invalid content-length header')
	    }
	  } else if (
	    request.contentType === null &&
	    key.length === 12 &&
	    key.toLowerCase() === 'content-type'
	  ) {
	    request.contentType = val;
	    if (skipAppend) request.headers[key] = processHeaderValue(key, val, skipAppend);
	    else request.headers += processHeaderValue(key, val);
	  } else if (
	    key.length === 17 &&
	    key.toLowerCase() === 'transfer-encoding'
	  ) {
	    throw new InvalidArgumentError('invalid transfer-encoding header')
	  } else if (
	    key.length === 10 &&
	    key.toLowerCase() === 'connection'
	  ) {
	    const value = typeof val === 'string' ? val.toLowerCase() : null;
	    if (value !== 'close' && value !== 'keep-alive') {
	      throw new InvalidArgumentError('invalid connection header')
	    } else if (value === 'close') {
	      request.reset = true;
	    }
	  } else if (
	    key.length === 10 &&
	    key.toLowerCase() === 'keep-alive'
	  ) {
	    throw new InvalidArgumentError('invalid keep-alive header')
	  } else if (
	    key.length === 7 &&
	    key.toLowerCase() === 'upgrade'
	  ) {
	    throw new InvalidArgumentError('invalid upgrade header')
	  } else if (
	    key.length === 6 &&
	    key.toLowerCase() === 'expect'
	  ) {
	    throw new NotSupportedError('expect header not supported')
	  } else if (tokenRegExp.exec(key) === null) {
	    throw new InvalidArgumentError('invalid header key')
	  } else {
	    if (Array.isArray(val)) {
	      for (let i = 0; i < val.length; i++) {
	        if (skipAppend) {
	          if (request.headers[key]) request.headers[key] += `,${processHeaderValue(key, val[i], skipAppend)}`;
	          else request.headers[key] = processHeaderValue(key, val[i], skipAppend);
	        } else {
	          request.headers += processHeaderValue(key, val[i]);
	        }
	      }
	    } else {
	      if (skipAppend) request.headers[key] = processHeaderValue(key, val, skipAppend);
	      else request.headers += processHeaderValue(key, val);
	    }
	  }
	}

	request$1 = Request;
	return request$1;
}

var dispatcher;
var hasRequiredDispatcher;

function requireDispatcher () {
	if (hasRequiredDispatcher) return dispatcher;
	hasRequiredDispatcher = 1;

	const EventEmitter = require$$0$3;

	class Dispatcher extends EventEmitter {
	  dispatch () {
	    throw new Error('not implemented')
	  }

	  close () {
	    throw new Error('not implemented')
	  }

	  destroy () {
	    throw new Error('not implemented')
	  }
	}

	dispatcher = Dispatcher;
	return dispatcher;
}

var dispatcherBase;
var hasRequiredDispatcherBase;

function requireDispatcherBase () {
	if (hasRequiredDispatcherBase) return dispatcherBase;
	hasRequiredDispatcherBase = 1;

	const Dispatcher = requireDispatcher();
	const {
	  ClientDestroyedError,
	  ClientClosedError,
	  InvalidArgumentError
	} = requireErrors();
	const { kDestroy, kClose, kDispatch, kInterceptors } = requireSymbols$4();

	const kDestroyed = Symbol('destroyed');
	const kClosed = Symbol('closed');
	const kOnDestroyed = Symbol('onDestroyed');
	const kOnClosed = Symbol('onClosed');
	const kInterceptedDispatch = Symbol('Intercepted Dispatch');

	class DispatcherBase extends Dispatcher {
	  constructor () {
	    super();

	    this[kDestroyed] = false;
	    this[kOnDestroyed] = null;
	    this[kClosed] = false;
	    this[kOnClosed] = [];
	  }

	  get destroyed () {
	    return this[kDestroyed]
	  }

	  get closed () {
	    return this[kClosed]
	  }

	  get interceptors () {
	    return this[kInterceptors]
	  }

	  set interceptors (newInterceptors) {
	    if (newInterceptors) {
	      for (let i = newInterceptors.length - 1; i >= 0; i--) {
	        const interceptor = this[kInterceptors][i];
	        if (typeof interceptor !== 'function') {
	          throw new InvalidArgumentError('interceptor must be an function')
	        }
	      }
	    }

	    this[kInterceptors] = newInterceptors;
	  }

	  close (callback) {
	    if (callback === undefined) {
	      return new Promise((resolve, reject) => {
	        this.close((err, data) => {
	          return err ? reject(err) : resolve(data)
	        });
	      })
	    }

	    if (typeof callback !== 'function') {
	      throw new InvalidArgumentError('invalid callback')
	    }

	    if (this[kDestroyed]) {
	      queueMicrotask(() => callback(new ClientDestroyedError(), null));
	      return
	    }

	    if (this[kClosed]) {
	      if (this[kOnClosed]) {
	        this[kOnClosed].push(callback);
	      } else {
	        queueMicrotask(() => callback(null, null));
	      }
	      return
	    }

	    this[kClosed] = true;
	    this[kOnClosed].push(callback);

	    const onClosed = () => {
	      const callbacks = this[kOnClosed];
	      this[kOnClosed] = null;
	      for (let i = 0; i < callbacks.length; i++) {
	        callbacks[i](null, null);
	      }
	    };

	    // Should not error.
	    this[kClose]()
	      .then(() => this.destroy())
	      .then(() => {
	        queueMicrotask(onClosed);
	      });
	  }

	  destroy (err, callback) {
	    if (typeof err === 'function') {
	      callback = err;
	      err = null;
	    }

	    if (callback === undefined) {
	      return new Promise((resolve, reject) => {
	        this.destroy(err, (err, data) => {
	          return err ? /* istanbul ignore next: should never error */ reject(err) : resolve(data)
	        });
	      })
	    }

	    if (typeof callback !== 'function') {
	      throw new InvalidArgumentError('invalid callback')
	    }

	    if (this[kDestroyed]) {
	      if (this[kOnDestroyed]) {
	        this[kOnDestroyed].push(callback);
	      } else {
	        queueMicrotask(() => callback(null, null));
	      }
	      return
	    }

	    if (!err) {
	      err = new ClientDestroyedError();
	    }

	    this[kDestroyed] = true;
	    this[kOnDestroyed] = this[kOnDestroyed] || [];
	    this[kOnDestroyed].push(callback);

	    const onDestroyed = () => {
	      const callbacks = this[kOnDestroyed];
	      this[kOnDestroyed] = null;
	      for (let i = 0; i < callbacks.length; i++) {
	        callbacks[i](null, null);
	      }
	    };

	    // Should not error.
	    this[kDestroy](err).then(() => {
	      queueMicrotask(onDestroyed);
	    });
	  }

	  [kInterceptedDispatch] (opts, handler) {
	    if (!this[kInterceptors] || this[kInterceptors].length === 0) {
	      this[kInterceptedDispatch] = this[kDispatch];
	      return this[kDispatch](opts, handler)
	    }

	    let dispatch = this[kDispatch].bind(this);
	    for (let i = this[kInterceptors].length - 1; i >= 0; i--) {
	      dispatch = this[kInterceptors][i](dispatch);
	    }
	    this[kInterceptedDispatch] = dispatch;
	    return dispatch(opts, handler)
	  }

	  dispatch (opts, handler) {
	    if (!handler || typeof handler !== 'object') {
	      throw new InvalidArgumentError('handler must be an object')
	    }

	    try {
	      if (!opts || typeof opts !== 'object') {
	        throw new InvalidArgumentError('opts must be an object.')
	      }

	      if (this[kDestroyed] || this[kOnDestroyed]) {
	        throw new ClientDestroyedError()
	      }

	      if (this[kClosed]) {
	        throw new ClientClosedError()
	      }

	      return this[kInterceptedDispatch](opts, handler)
	    } catch (err) {
	      if (typeof handler.onError !== 'function') {
	        throw new InvalidArgumentError('invalid onError method')
	      }

	      handler.onError(err);

	      return false
	    }
	  }
	}

	dispatcherBase = DispatcherBase;
	return dispatcherBase;
}

var connect;
var hasRequiredConnect;

function requireConnect () {
	if (hasRequiredConnect) return connect;
	hasRequiredConnect = 1;

	const net = require$$0$5;
	const assert = require$$0$4;
	const util = requireUtil$6();
	const { InvalidArgumentError, ConnectTimeoutError } = requireErrors();

	let tls; // include tls conditionally since it is not always available

	// TODO: session re-use does not wait for the first
	// connection to resolve the session and might therefore
	// resolve the same servername multiple times even when
	// re-use is enabled.

	let SessionCache;
	// FIXME: remove workaround when the Node bug is fixed
	// https://github.com/nodejs/node/issues/49344#issuecomment-1741776308
	if (commonjsGlobal.FinalizationRegistry && !process.env.NODE_V8_COVERAGE) {
	  SessionCache = class WeakSessionCache {
	    constructor (maxCachedSessions) {
	      this._maxCachedSessions = maxCachedSessions;
	      this._sessionCache = new Map();
	      this._sessionRegistry = new commonjsGlobal.FinalizationRegistry((key) => {
	        if (this._sessionCache.size < this._maxCachedSessions) {
	          return
	        }

	        const ref = this._sessionCache.get(key);
	        if (ref !== undefined && ref.deref() === undefined) {
	          this._sessionCache.delete(key);
	        }
	      });
	    }

	    get (sessionKey) {
	      const ref = this._sessionCache.get(sessionKey);
	      return ref ? ref.deref() : null
	    }

	    set (sessionKey, session) {
	      if (this._maxCachedSessions === 0) {
	        return
	      }

	      this._sessionCache.set(sessionKey, new WeakRef(session));
	      this._sessionRegistry.register(session, sessionKey);
	    }
	  };
	} else {
	  SessionCache = class SimpleSessionCache {
	    constructor (maxCachedSessions) {
	      this._maxCachedSessions = maxCachedSessions;
	      this._sessionCache = new Map();
	    }

	    get (sessionKey) {
	      return this._sessionCache.get(sessionKey)
	    }

	    set (sessionKey, session) {
	      if (this._maxCachedSessions === 0) {
	        return
	      }

	      if (this._sessionCache.size >= this._maxCachedSessions) {
	        // remove the oldest session
	        const { value: oldestKey } = this._sessionCache.keys().next();
	        this._sessionCache.delete(oldestKey);
	      }

	      this._sessionCache.set(sessionKey, session);
	    }
	  };
	}

	function buildConnector ({ allowH2, maxCachedSessions, socketPath, timeout, ...opts }) {
	  if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {
	    throw new InvalidArgumentError('maxCachedSessions must be a positive integer or zero')
	  }

	  const options = { path: socketPath, ...opts };
	  const sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions);
	  timeout = timeout == null ? 10e3 : timeout;
	  allowH2 = allowH2 != null ? allowH2 : false;
	  return function connect ({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {
	    let socket;
	    if (protocol === 'https:') {
	      if (!tls) {
	        tls = require$$4$1;
	      }
	      servername = servername || options.servername || util.getServerName(host) || null;

	      const sessionKey = servername || hostname;
	      const session = sessionCache.get(sessionKey) || null;

	      assert(sessionKey);

	      socket = tls.connect({
	        highWaterMark: 16384, // TLS in node can't have bigger HWM anyway...
	        ...options,
	        servername,
	        session,
	        localAddress,
	        // TODO(HTTP/2): Add support for h2c
	        ALPNProtocols: allowH2 ? ['http/1.1', 'h2'] : ['http/1.1'],
	        socket: httpSocket, // upgrade socket connection
	        port: port || 443,
	        host: hostname
	      });

	      socket
	        .on('session', function (session) {
	          // TODO (fix): Can a session become invalid once established? Don't think so?
	          sessionCache.set(sessionKey, session);
	        });
	    } else {
	      assert(!httpSocket, 'httpSocket can only be sent on TLS update');
	      socket = net.connect({
	        highWaterMark: 64 * 1024, // Same as nodejs fs streams.
	        ...options,
	        localAddress,
	        port: port || 80,
	        host: hostname
	      });
	    }

	    // Set TCP keep alive options on the socket here instead of in connect() for the case of assigning the socket
	    if (options.keepAlive == null || options.keepAlive) {
	      const keepAliveInitialDelay = options.keepAliveInitialDelay === undefined ? 60e3 : options.keepAliveInitialDelay;
	      socket.setKeepAlive(true, keepAliveInitialDelay);
	    }

	    const cancelTimeout = setupTimeout(() => onConnectTimeout(socket), timeout);

	    socket
	      .setNoDelay(true)
	      .once(protocol === 'https:' ? 'secureConnect' : 'connect', function () {
	        cancelTimeout();

	        if (callback) {
	          const cb = callback;
	          callback = null;
	          cb(null, this);
	        }
	      })
	      .on('error', function (err) {
	        cancelTimeout();

	        if (callback) {
	          const cb = callback;
	          callback = null;
	          cb(err);
	        }
	      });

	    return socket
	  }
	}

	function setupTimeout (onConnectTimeout, timeout) {
	  if (!timeout) {
	    return () => {}
	  }

	  let s1 = null;
	  let s2 = null;
	  const timeoutId = setTimeout(() => {
	    // setImmediate is added to make sure that we priotorise socket error events over timeouts
	    s1 = setImmediate(() => {
	      if (process.platform === 'win32') {
	        // Windows needs an extra setImmediate probably due to implementation differences in the socket logic
	        s2 = setImmediate(() => onConnectTimeout());
	      } else {
	        onConnectTimeout();
	      }
	    });
	  }, timeout);
	  return () => {
	    clearTimeout(timeoutId);
	    clearImmediate(s1);
	    clearImmediate(s2);
	  }
	}

	function onConnectTimeout (socket) {
	  util.destroy(socket, new ConnectTimeoutError());
	}

	connect = buildConnector;
	return connect;
}

var constants$4 = {};

var utils$1 = {};

var hasRequiredUtils$1;

function requireUtils$1 () {
	if (hasRequiredUtils$1) return utils$1;
	hasRequiredUtils$1 = 1;
	Object.defineProperty(utils$1, "__esModule", { value: true });
	utils$1.enumToMap = void 0;
	function enumToMap(obj) {
	    const res = {};
	    Object.keys(obj).forEach((key) => {
	        const value = obj[key];
	        if (typeof value === 'number') {
	            res[key] = value;
	        }
	    });
	    return res;
	}
	utils$1.enumToMap = enumToMap;
	
	return utils$1;
}

var hasRequiredConstants$4;

function requireConstants$4 () {
	if (hasRequiredConstants$4) return constants$4;
	hasRequiredConstants$4 = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.SPECIAL_HEADERS = exports.HEADER_STATE = exports.MINOR = exports.MAJOR = exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS = exports.TOKEN = exports.STRICT_TOKEN = exports.HEX = exports.URL_CHAR = exports.STRICT_URL_CHAR = exports.USERINFO_CHARS = exports.MARK = exports.ALPHANUM = exports.NUM = exports.HEX_MAP = exports.NUM_MAP = exports.ALPHA = exports.FINISH = exports.H_METHOD_MAP = exports.METHOD_MAP = exports.METHODS_RTSP = exports.METHODS_ICE = exports.METHODS_HTTP = exports.METHODS = exports.LENIENT_FLAGS = exports.FLAGS = exports.TYPE = exports.ERROR = void 0;
		const utils_1 = requireUtils$1();
		(function (ERROR) {
		    ERROR[ERROR["OK"] = 0] = "OK";
		    ERROR[ERROR["INTERNAL"] = 1] = "INTERNAL";
		    ERROR[ERROR["STRICT"] = 2] = "STRICT";
		    ERROR[ERROR["LF_EXPECTED"] = 3] = "LF_EXPECTED";
		    ERROR[ERROR["UNEXPECTED_CONTENT_LENGTH"] = 4] = "UNEXPECTED_CONTENT_LENGTH";
		    ERROR[ERROR["CLOSED_CONNECTION"] = 5] = "CLOSED_CONNECTION";
		    ERROR[ERROR["INVALID_METHOD"] = 6] = "INVALID_METHOD";
		    ERROR[ERROR["INVALID_URL"] = 7] = "INVALID_URL";
		    ERROR[ERROR["INVALID_CONSTANT"] = 8] = "INVALID_CONSTANT";
		    ERROR[ERROR["INVALID_VERSION"] = 9] = "INVALID_VERSION";
		    ERROR[ERROR["INVALID_HEADER_TOKEN"] = 10] = "INVALID_HEADER_TOKEN";
		    ERROR[ERROR["INVALID_CONTENT_LENGTH"] = 11] = "INVALID_CONTENT_LENGTH";
		    ERROR[ERROR["INVALID_CHUNK_SIZE"] = 12] = "INVALID_CHUNK_SIZE";
		    ERROR[ERROR["INVALID_STATUS"] = 13] = "INVALID_STATUS";
		    ERROR[ERROR["INVALID_EOF_STATE"] = 14] = "INVALID_EOF_STATE";
		    ERROR[ERROR["INVALID_TRANSFER_ENCODING"] = 15] = "INVALID_TRANSFER_ENCODING";
		    ERROR[ERROR["CB_MESSAGE_BEGIN"] = 16] = "CB_MESSAGE_BEGIN";
		    ERROR[ERROR["CB_HEADERS_COMPLETE"] = 17] = "CB_HEADERS_COMPLETE";
		    ERROR[ERROR["CB_MESSAGE_COMPLETE"] = 18] = "CB_MESSAGE_COMPLETE";
		    ERROR[ERROR["CB_CHUNK_HEADER"] = 19] = "CB_CHUNK_HEADER";
		    ERROR[ERROR["CB_CHUNK_COMPLETE"] = 20] = "CB_CHUNK_COMPLETE";
		    ERROR[ERROR["PAUSED"] = 21] = "PAUSED";
		    ERROR[ERROR["PAUSED_UPGRADE"] = 22] = "PAUSED_UPGRADE";
		    ERROR[ERROR["PAUSED_H2_UPGRADE"] = 23] = "PAUSED_H2_UPGRADE";
		    ERROR[ERROR["USER"] = 24] = "USER";
		})(exports.ERROR || (exports.ERROR = {}));
		(function (TYPE) {
		    TYPE[TYPE["BOTH"] = 0] = "BOTH";
		    TYPE[TYPE["REQUEST"] = 1] = "REQUEST";
		    TYPE[TYPE["RESPONSE"] = 2] = "RESPONSE";
		})(exports.TYPE || (exports.TYPE = {}));
		(function (FLAGS) {
		    FLAGS[FLAGS["CONNECTION_KEEP_ALIVE"] = 1] = "CONNECTION_KEEP_ALIVE";
		    FLAGS[FLAGS["CONNECTION_CLOSE"] = 2] = "CONNECTION_CLOSE";
		    FLAGS[FLAGS["CONNECTION_UPGRADE"] = 4] = "CONNECTION_UPGRADE";
		    FLAGS[FLAGS["CHUNKED"] = 8] = "CHUNKED";
		    FLAGS[FLAGS["UPGRADE"] = 16] = "UPGRADE";
		    FLAGS[FLAGS["CONTENT_LENGTH"] = 32] = "CONTENT_LENGTH";
		    FLAGS[FLAGS["SKIPBODY"] = 64] = "SKIPBODY";
		    FLAGS[FLAGS["TRAILING"] = 128] = "TRAILING";
		    // 1 << 8 is unused
		    FLAGS[FLAGS["TRANSFER_ENCODING"] = 512] = "TRANSFER_ENCODING";
		})(exports.FLAGS || (exports.FLAGS = {}));
		(function (LENIENT_FLAGS) {
		    LENIENT_FLAGS[LENIENT_FLAGS["HEADERS"] = 1] = "HEADERS";
		    LENIENT_FLAGS[LENIENT_FLAGS["CHUNKED_LENGTH"] = 2] = "CHUNKED_LENGTH";
		    LENIENT_FLAGS[LENIENT_FLAGS["KEEP_ALIVE"] = 4] = "KEEP_ALIVE";
		})(exports.LENIENT_FLAGS || (exports.LENIENT_FLAGS = {}));
		var METHODS;
		(function (METHODS) {
		    METHODS[METHODS["DELETE"] = 0] = "DELETE";
		    METHODS[METHODS["GET"] = 1] = "GET";
		    METHODS[METHODS["HEAD"] = 2] = "HEAD";
		    METHODS[METHODS["POST"] = 3] = "POST";
		    METHODS[METHODS["PUT"] = 4] = "PUT";
		    /* pathological */
		    METHODS[METHODS["CONNECT"] = 5] = "CONNECT";
		    METHODS[METHODS["OPTIONS"] = 6] = "OPTIONS";
		    METHODS[METHODS["TRACE"] = 7] = "TRACE";
		    /* WebDAV */
		    METHODS[METHODS["COPY"] = 8] = "COPY";
		    METHODS[METHODS["LOCK"] = 9] = "LOCK";
		    METHODS[METHODS["MKCOL"] = 10] = "MKCOL";
		    METHODS[METHODS["MOVE"] = 11] = "MOVE";
		    METHODS[METHODS["PROPFIND"] = 12] = "PROPFIND";
		    METHODS[METHODS["PROPPATCH"] = 13] = "PROPPATCH";
		    METHODS[METHODS["SEARCH"] = 14] = "SEARCH";
		    METHODS[METHODS["UNLOCK"] = 15] = "UNLOCK";
		    METHODS[METHODS["BIND"] = 16] = "BIND";
		    METHODS[METHODS["REBIND"] = 17] = "REBIND";
		    METHODS[METHODS["UNBIND"] = 18] = "UNBIND";
		    METHODS[METHODS["ACL"] = 19] = "ACL";
		    /* subversion */
		    METHODS[METHODS["REPORT"] = 20] = "REPORT";
		    METHODS[METHODS["MKACTIVITY"] = 21] = "MKACTIVITY";
		    METHODS[METHODS["CHECKOUT"] = 22] = "CHECKOUT";
		    METHODS[METHODS["MERGE"] = 23] = "MERGE";
		    /* upnp */
		    METHODS[METHODS["M-SEARCH"] = 24] = "M-SEARCH";
		    METHODS[METHODS["NOTIFY"] = 25] = "NOTIFY";
		    METHODS[METHODS["SUBSCRIBE"] = 26] = "SUBSCRIBE";
		    METHODS[METHODS["UNSUBSCRIBE"] = 27] = "UNSUBSCRIBE";
		    /* RFC-5789 */
		    METHODS[METHODS["PATCH"] = 28] = "PATCH";
		    METHODS[METHODS["PURGE"] = 29] = "PURGE";
		    /* CalDAV */
		    METHODS[METHODS["MKCALENDAR"] = 30] = "MKCALENDAR";
		    /* RFC-2068, section 19.6.1.2 */
		    METHODS[METHODS["LINK"] = 31] = "LINK";
		    METHODS[METHODS["UNLINK"] = 32] = "UNLINK";
		    /* icecast */
		    METHODS[METHODS["SOURCE"] = 33] = "SOURCE";
		    /* RFC-7540, section 11.6 */
		    METHODS[METHODS["PRI"] = 34] = "PRI";
		    /* RFC-2326 RTSP */
		    METHODS[METHODS["DESCRIBE"] = 35] = "DESCRIBE";
		    METHODS[METHODS["ANNOUNCE"] = 36] = "ANNOUNCE";
		    METHODS[METHODS["SETUP"] = 37] = "SETUP";
		    METHODS[METHODS["PLAY"] = 38] = "PLAY";
		    METHODS[METHODS["PAUSE"] = 39] = "PAUSE";
		    METHODS[METHODS["TEARDOWN"] = 40] = "TEARDOWN";
		    METHODS[METHODS["GET_PARAMETER"] = 41] = "GET_PARAMETER";
		    METHODS[METHODS["SET_PARAMETER"] = 42] = "SET_PARAMETER";
		    METHODS[METHODS["REDIRECT"] = 43] = "REDIRECT";
		    METHODS[METHODS["RECORD"] = 44] = "RECORD";
		    /* RAOP */
		    METHODS[METHODS["FLUSH"] = 45] = "FLUSH";
		})(METHODS = exports.METHODS || (exports.METHODS = {}));
		exports.METHODS_HTTP = [
		    METHODS.DELETE,
		    METHODS.GET,
		    METHODS.HEAD,
		    METHODS.POST,
		    METHODS.PUT,
		    METHODS.CONNECT,
		    METHODS.OPTIONS,
		    METHODS.TRACE,
		    METHODS.COPY,
		    METHODS.LOCK,
		    METHODS.MKCOL,
		    METHODS.MOVE,
		    METHODS.PROPFIND,
		    METHODS.PROPPATCH,
		    METHODS.SEARCH,
		    METHODS.UNLOCK,
		    METHODS.BIND,
		    METHODS.REBIND,
		    METHODS.UNBIND,
		    METHODS.ACL,
		    METHODS.REPORT,
		    METHODS.MKACTIVITY,
		    METHODS.CHECKOUT,
		    METHODS.MERGE,
		    METHODS['M-SEARCH'],
		    METHODS.NOTIFY,
		    METHODS.SUBSCRIBE,
		    METHODS.UNSUBSCRIBE,
		    METHODS.PATCH,
		    METHODS.PURGE,
		    METHODS.MKCALENDAR,
		    METHODS.LINK,
		    METHODS.UNLINK,
		    METHODS.PRI,
		    // TODO(indutny): should we allow it with HTTP?
		    METHODS.SOURCE,
		];
		exports.METHODS_ICE = [
		    METHODS.SOURCE,
		];
		exports.METHODS_RTSP = [
		    METHODS.OPTIONS,
		    METHODS.DESCRIBE,
		    METHODS.ANNOUNCE,
		    METHODS.SETUP,
		    METHODS.PLAY,
		    METHODS.PAUSE,
		    METHODS.TEARDOWN,
		    METHODS.GET_PARAMETER,
		    METHODS.SET_PARAMETER,
		    METHODS.REDIRECT,
		    METHODS.RECORD,
		    METHODS.FLUSH,
		    // For AirPlay
		    METHODS.GET,
		    METHODS.POST,
		];
		exports.METHOD_MAP = utils_1.enumToMap(METHODS);
		exports.H_METHOD_MAP = {};
		Object.keys(exports.METHOD_MAP).forEach((key) => {
		    if (/^H/.test(key)) {
		        exports.H_METHOD_MAP[key] = exports.METHOD_MAP[key];
		    }
		});
		(function (FINISH) {
		    FINISH[FINISH["SAFE"] = 0] = "SAFE";
		    FINISH[FINISH["SAFE_WITH_CB"] = 1] = "SAFE_WITH_CB";
		    FINISH[FINISH["UNSAFE"] = 2] = "UNSAFE";
		})(exports.FINISH || (exports.FINISH = {}));
		exports.ALPHA = [];
		for (let i = 'A'.charCodeAt(0); i <= 'Z'.charCodeAt(0); i++) {
		    // Upper case
		    exports.ALPHA.push(String.fromCharCode(i));
		    // Lower case
		    exports.ALPHA.push(String.fromCharCode(i + 0x20));
		}
		exports.NUM_MAP = {
		    0: 0, 1: 1, 2: 2, 3: 3, 4: 4,
		    5: 5, 6: 6, 7: 7, 8: 8, 9: 9,
		};
		exports.HEX_MAP = {
		    0: 0, 1: 1, 2: 2, 3: 3, 4: 4,
		    5: 5, 6: 6, 7: 7, 8: 8, 9: 9,
		    A: 0XA, B: 0XB, C: 0XC, D: 0XD, E: 0XE, F: 0XF,
		    a: 0xa, b: 0xb, c: 0xc, d: 0xd, e: 0xe, f: 0xf,
		};
		exports.NUM = [
		    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
		];
		exports.ALPHANUM = exports.ALPHA.concat(exports.NUM);
		exports.MARK = ['-', '_', '.', '!', '~', '*', '\'', '(', ')'];
		exports.USERINFO_CHARS = exports.ALPHANUM
		    .concat(exports.MARK)
		    .concat(['%', ';', ':', '&', '=', '+', '$', ',']);
		// TODO(indutny): use RFC
		exports.STRICT_URL_CHAR = [
		    '!', '"', '$', '%', '&', '\'',
		    '(', ')', '*', '+', ',', '-', '.', '/',
		    ':', ';', '<', '=', '>',
		    '@', '[', '\\', ']', '^', '_',
		    '`',
		    '{', '|', '}', '~',
		].concat(exports.ALPHANUM);
		exports.URL_CHAR = exports.STRICT_URL_CHAR
		    .concat(['\t', '\f']);
		// All characters with 0x80 bit set to 1
		for (let i = 0x80; i <= 0xff; i++) {
		    exports.URL_CHAR.push(i);
		}
		exports.HEX = exports.NUM.concat(['a', 'b', 'c', 'd', 'e', 'f', 'A', 'B', 'C', 'D', 'E', 'F']);
		/* Tokens as defined by rfc 2616. Also lowercases them.
		 *        token       = 1*<any CHAR except CTLs or separators>
		 *     separators     = "(" | ")" | "<" | ">" | "@"
		 *                    | "," | ";" | ":" | "\" | <">
		 *                    | "/" | "[" | "]" | "?" | "="
		 *                    | "{" | "}" | SP | HT
		 */
		exports.STRICT_TOKEN = [
		    '!', '#', '$', '%', '&', '\'',
		    '*', '+', '-', '.',
		    '^', '_', '`',
		    '|', '~',
		].concat(exports.ALPHANUM);
		exports.TOKEN = exports.STRICT_TOKEN.concat([' ']);
		/*
		 * Verify that a char is a valid visible (printable) US-ASCII
		 * character or %x80-FF
		 */
		exports.HEADER_CHARS = ['\t'];
		for (let i = 32; i <= 255; i++) {
		    if (i !== 127) {
		        exports.HEADER_CHARS.push(i);
		    }
		}
		// ',' = \x44
		exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS.filter((c) => c !== 44);
		exports.MAJOR = exports.NUM_MAP;
		exports.MINOR = exports.MAJOR;
		var HEADER_STATE;
		(function (HEADER_STATE) {
		    HEADER_STATE[HEADER_STATE["GENERAL"] = 0] = "GENERAL";
		    HEADER_STATE[HEADER_STATE["CONNECTION"] = 1] = "CONNECTION";
		    HEADER_STATE[HEADER_STATE["CONTENT_LENGTH"] = 2] = "CONTENT_LENGTH";
		    HEADER_STATE[HEADER_STATE["TRANSFER_ENCODING"] = 3] = "TRANSFER_ENCODING";
		    HEADER_STATE[HEADER_STATE["UPGRADE"] = 4] = "UPGRADE";
		    HEADER_STATE[HEADER_STATE["CONNECTION_KEEP_ALIVE"] = 5] = "CONNECTION_KEEP_ALIVE";
		    HEADER_STATE[HEADER_STATE["CONNECTION_CLOSE"] = 6] = "CONNECTION_CLOSE";
		    HEADER_STATE[HEADER_STATE["CONNECTION_UPGRADE"] = 7] = "CONNECTION_UPGRADE";
		    HEADER_STATE[HEADER_STATE["TRANSFER_ENCODING_CHUNKED"] = 8] = "TRANSFER_ENCODING_CHUNKED";
		})(HEADER_STATE = exports.HEADER_STATE || (exports.HEADER_STATE = {}));
		exports.SPECIAL_HEADERS = {
		    'connection': HEADER_STATE.CONNECTION,
		    'content-length': HEADER_STATE.CONTENT_LENGTH,
		    'proxy-connection': HEADER_STATE.CONNECTION,
		    'transfer-encoding': HEADER_STATE.TRANSFER_ENCODING,
		    'upgrade': HEADER_STATE.UPGRADE,
		};
		
	} (constants$4));
	return constants$4;
}

var RedirectHandler_1;
var hasRequiredRedirectHandler;

function requireRedirectHandler () {
	if (hasRequiredRedirectHandler) return RedirectHandler_1;
	hasRequiredRedirectHandler = 1;

	const util = requireUtil$6();
	const { kBodyUsed } = requireSymbols$4();
	const assert = require$$0$4;
	const { InvalidArgumentError } = requireErrors();
	const EE = require$$0$3;

	const redirectableStatusCodes = [300, 301, 302, 303, 307, 308];

	const kBody = Symbol('body');

	class BodyAsyncIterable {
	  constructor (body) {
	    this[kBody] = body;
	    this[kBodyUsed] = false;
	  }

	  async * [Symbol.asyncIterator] () {
	    assert(!this[kBodyUsed], 'disturbed');
	    this[kBodyUsed] = true;
	    yield * this[kBody];
	  }
	}

	class RedirectHandler {
	  constructor (dispatch, maxRedirections, opts, handler) {
	    if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
	      throw new InvalidArgumentError('maxRedirections must be a positive number')
	    }

	    util.validateHandler(handler, opts.method, opts.upgrade);

	    this.dispatch = dispatch;
	    this.location = null;
	    this.abort = null;
	    this.opts = { ...opts, maxRedirections: 0 }; // opts must be a copy
	    this.maxRedirections = maxRedirections;
	    this.handler = handler;
	    this.history = [];

	    if (util.isStream(this.opts.body)) {
	      // TODO (fix): Provide some way for the user to cache the file to e.g. /tmp
	      // so that it can be dispatched again?
	      // TODO (fix): Do we need 100-expect support to provide a way to do this properly?
	      if (util.bodyLength(this.opts.body) === 0) {
	        this.opts.body
	          .on('data', function () {
	            assert(false);
	          });
	      }

	      if (typeof this.opts.body.readableDidRead !== 'boolean') {
	        this.opts.body[kBodyUsed] = false;
	        EE.prototype.on.call(this.opts.body, 'data', function () {
	          this[kBodyUsed] = true;
	        });
	      }
	    } else if (this.opts.body && typeof this.opts.body.pipeTo === 'function') {
	      // TODO (fix): We can't access ReadableStream internal state
	      // to determine whether or not it has been disturbed. This is just
	      // a workaround.
	      this.opts.body = new BodyAsyncIterable(this.opts.body);
	    } else if (
	      this.opts.body &&
	      typeof this.opts.body !== 'string' &&
	      !ArrayBuffer.isView(this.opts.body) &&
	      util.isIterable(this.opts.body)
	    ) {
	      // TODO: Should we allow re-using iterable if !this.opts.idempotent
	      // or through some other flag?
	      this.opts.body = new BodyAsyncIterable(this.opts.body);
	    }
	  }

	  onConnect (abort) {
	    this.abort = abort;
	    this.handler.onConnect(abort, { history: this.history });
	  }

	  onUpgrade (statusCode, headers, socket) {
	    this.handler.onUpgrade(statusCode, headers, socket);
	  }

	  onError (error) {
	    this.handler.onError(error);
	  }

	  onHeaders (statusCode, headers, resume, statusText) {
	    this.location = this.history.length >= this.maxRedirections || util.isDisturbed(this.opts.body)
	      ? null
	      : parseLocation(statusCode, headers);

	    if (this.opts.origin) {
	      this.history.push(new URL(this.opts.path, this.opts.origin));
	    }

	    if (!this.location) {
	      return this.handler.onHeaders(statusCode, headers, resume, statusText)
	    }

	    const { origin, pathname, search } = util.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)));
	    const path = search ? `${pathname}${search}` : pathname;

	    // Remove headers referring to the original URL.
	    // By default it is Host only, unless it's a 303 (see below), which removes also all Content-* headers.
	    // https://tools.ietf.org/html/rfc7231#section-6.4
	    this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin);
	    this.opts.path = path;
	    this.opts.origin = origin;
	    this.opts.maxRedirections = 0;
	    this.opts.query = null;

	    // https://tools.ietf.org/html/rfc7231#section-6.4.4
	    // In case of HTTP 303, always replace method to be either HEAD or GET
	    if (statusCode === 303 && this.opts.method !== 'HEAD') {
	      this.opts.method = 'GET';
	      this.opts.body = null;
	    }
	  }

	  onData (chunk) {
	    if (this.location) ; else {
	      return this.handler.onData(chunk)
	    }
	  }

	  onComplete (trailers) {
	    if (this.location) {
	      /*
	        https://tools.ietf.org/html/rfc7231#section-6.4

	        TLDR: undici always ignores 3xx response trailers as they are not expected in case of redirections
	        and neither are useful if present.

	        See comment on onData method above for more detailed informations.
	      */

	      this.location = null;
	      this.abort = null;

	      this.dispatch(this.opts, this);
	    } else {
	      this.handler.onComplete(trailers);
	    }
	  }

	  onBodySent (chunk) {
	    if (this.handler.onBodySent) {
	      this.handler.onBodySent(chunk);
	    }
	  }
	}

	function parseLocation (statusCode, headers) {
	  if (redirectableStatusCodes.indexOf(statusCode) === -1) {
	    return null
	  }

	  for (let i = 0; i < headers.length; i += 2) {
	    if (headers[i].toString().toLowerCase() === 'location') {
	      return headers[i + 1]
	    }
	  }
	}

	// https://tools.ietf.org/html/rfc7231#section-6.4.4
	function shouldRemoveHeader (header, removeContent, unknownOrigin) {
	  if (header.length === 4) {
	    return util.headerNameToString(header) === 'host'
	  }
	  if (removeContent && util.headerNameToString(header).startsWith('content-')) {
	    return true
	  }
	  if (unknownOrigin && (header.length === 13 || header.length === 6 || header.length === 19)) {
	    const name = util.headerNameToString(header);
	    return name === 'authorization' || name === 'cookie' || name === 'proxy-authorization'
	  }
	  return false
	}

	// https://tools.ietf.org/html/rfc7231#section-6.4
	function cleanRequestHeaders (headers, removeContent, unknownOrigin) {
	  const ret = [];
	  if (Array.isArray(headers)) {
	    for (let i = 0; i < headers.length; i += 2) {
	      if (!shouldRemoveHeader(headers[i], removeContent, unknownOrigin)) {
	        ret.push(headers[i], headers[i + 1]);
	      }
	    }
	  } else if (headers && typeof headers === 'object') {
	    for (const key of Object.keys(headers)) {
	      if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {
	        ret.push(key, headers[key]);
	      }
	    }
	  } else {
	    assert(headers == null, 'headers must be an object or an array');
	  }
	  return ret
	}

	RedirectHandler_1 = RedirectHandler;
	return RedirectHandler_1;
}

var redirectInterceptor;
var hasRequiredRedirectInterceptor;

function requireRedirectInterceptor () {
	if (hasRequiredRedirectInterceptor) return redirectInterceptor;
	hasRequiredRedirectInterceptor = 1;

	const RedirectHandler = requireRedirectHandler();

	function createRedirectInterceptor ({ maxRedirections: defaultMaxRedirections }) {
	  return (dispatch) => {
	    return function Intercept (opts, handler) {
	      const { maxRedirections = defaultMaxRedirections } = opts;

	      if (!maxRedirections) {
	        return dispatch(opts, handler)
	      }

	      const redirectHandler = new RedirectHandler(dispatch, maxRedirections, opts, handler);
	      opts = { ...opts, maxRedirections: 0 }; // Stop sub dispatcher from also redirecting.
	      return dispatch(opts, redirectHandler)
	    }
	  }
	}

	redirectInterceptor = createRedirectInterceptor;
	return redirectInterceptor;
}

var llhttpWasm;
var hasRequiredLlhttpWasm;

function requireLlhttpWasm () {
	if (hasRequiredLlhttpWasm) return llhttpWasm;
	hasRequiredLlhttpWasm = 1;
	llhttpWasm = 'AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJsbGh0dHBfc3RhdHVzX25hbWUAIRpsbGh0dHBfc2V0X2xlbmllbnRfaGVhZGVycwAiIWxsaHR0cF9zZXRfbGVuaWVudF9jaHVua2VkX2xlbmd0aAAjHWxsaHR0cF9zZXRfbGVuaWVudF9rZWVwX2FsaXZlACQkbGxodHRwX3NldF9sZW5pZW50X3RyYW5zZmVyX2VuY29kaW5nACUYbGxodHRwX21lc3NhZ2VfbmVlZHNfZW9mAD8JFwEAQQELEQECAwQFCwYHNTk3MS8tJyspCsLgAkUCAAsIABCIgICAAAsZACAAEMKAgIAAGiAAIAI2AjggACABOgAoCxwAIAAgAC8BMiAALQAuIAAQwYCAgAAQgICAgAALKgEBf0HAABDGgICAACIBEMKAgIAAGiABQYCIgIAANgI4IAEgADoAKCABCwoAIAAQyICAgAALBwAgAC0AKAsHACAALQAqCwcAIAAtACsLBwAgAC0AKQsHACAALwEyCwcAIAAtAC4LRQEEfyAAKAIYIQEgAC0ALSECIAAtACghAyAAKAI4IQQgABDCgICAABogACAENgI4IAAgAzoAKCAAIAI6AC0gACABNgIYCxEAIAAgASABIAJqEMOAgIAACxAAIABBAEHcABDMgICAABoLZwEBf0EAIQECQCAAKAIMDQACQAJAAkACQCAALQAvDgMBAAMCCyAAKAI4IgFFDQAgASgCLCIBRQ0AIAAgARGAgICAAAAiAQ0DC0EADwsQyoCAgAAACyAAQcOWgIAANgIQQQ4hAQsgAQseAAJAIAAoAgwNACAAQdGbgIAANgIQIABBFTYCDAsLFgACQCAAKAIMQRVHDQAgAEEANgIMCwsWAAJAIAAoAgxBFkcNACAAQQA2AgwLCwcAIAAoAgwLBwAgACgCEAsJACAAIAE2AhALBwAgACgCFAsiAAJAIABBJEkNABDKgICAAAALIABBAnRBoLOAgABqKAIACyIAAkAgAEEuSQ0AEMqAgIAAAAsgAEECdEGwtICAAGooAgAL7gsBAX9B66iAgAAhAQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABBnH9qDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0Hhp4CAAA8LQaShgIAADwtBy6yAgAAPC0H+sYCAAA8LQcCkgIAADwtBq6SAgAAPC0GNqICAAA8LQeKmgIAADwtBgLCAgAAPC0G5r4CAAA8LQdekgIAADwtB75+AgAAPC0Hhn4CAAA8LQfqfgIAADwtB8qCAgAAPC0Gor4CAAA8LQa6ygIAADwtBiLCAgAAPC0Hsp4CAAA8LQYKigIAADwtBjp2AgAAPC0HQroCAAA8LQcqjgIAADwtBxbKAgAAPC0HfnICAAA8LQdKcgIAADwtBxKCAgAAPC0HXoICAAA8LQaKfgIAADwtB7a6AgAAPC0GrsICAAA8LQdSlgIAADwtBzK6AgAAPC0H6roCAAA8LQfyrgIAADwtB0rCAgAAPC0HxnYCAAA8LQbuggIAADwtB96uAgAAPC0GQsYCAAA8LQdexgIAADwtBoq2AgAAPC0HUp4CAAA8LQeCrgIAADwtBn6yAgAAPC0HrsYCAAA8LQdWfgIAADwtByrGAgAAPC0HepYCAAA8LQdSegIAADwtB9JyAgAAPC0GnsoCAAA8LQbGdgIAADwtBoJ2AgAAPC0G5sYCAAA8LQbywgIAADwtBkqGAgAAPC0GzpoCAAA8LQemsgIAADwtBrJ6AgAAPC0HUq4CAAA8LQfemgIAADwtBgKaAgAAPC0GwoYCAAA8LQf6egIAADwtBjaOAgAAPC0GJrYCAAA8LQfeigIAADwtBoLGAgAAPC0Gun4CAAA8LQcalgIAADwtB6J6AgAAPC0GTooCAAA8LQcKvgIAADwtBw52AgAAPC0GLrICAAA8LQeGdgIAADwtBja+AgAAPC0HqoYCAAA8LQbStgIAADwtB0q+AgAAPC0HfsoCAAA8LQdKygIAADwtB8LCAgAAPC0GpooCAAA8LQfmjgIAADwtBmZ6AgAAPC0G1rICAAA8LQZuwgIAADwtBkrKAgAAPC0G2q4CAAA8LQcKigIAADwtB+LKAgAAPC0GepYCAAA8LQdCigIAADwtBup6AgAAPC0GBnoCAAA8LEMqAgIAAAAtB1qGAgAAhAQsgAQsWACAAIAAtAC1B/gFxIAFBAEdyOgAtCxkAIAAgAC0ALUH9AXEgAUEAR0EBdHI6AC0LGQAgACAALQAtQfsBcSABQQBHQQJ0cjoALQsZACAAIAAtAC1B9wFxIAFBAEdBA3RyOgAtCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAgAiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCBCIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQcaRgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIwIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAggiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEH2ioCAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCNCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIMIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABB7ZqAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAjgiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCECIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQZWQgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAI8IgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAhQiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEGqm4CAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCQCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIYIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABB7ZOAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAkQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCJCIERQ0AIAAgBBGAgICAAAAhAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIsIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAigiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEH2iICAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCUCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIcIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABBwpmAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAkgiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCICIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQZSUgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAJMIgRFDQAgACAEEYCAgIAAACEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAlQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCWCIERQ0AIAAgBBGAgICAAAAhAwsgAwtFAQF/AkACQCAALwEwQRRxQRRHDQBBASEDIAAtAChBAUYNASAALwEyQeUARiEDDAELIAAtAClBBUYhAwsgACADOgAuQQAL/gEBA39BASEDAkAgAC8BMCIEQQhxDQAgACkDIEIAUiEDCwJAAkAgAC0ALkUNAEEBIQUgAC0AKUEFRg0BQQEhBSAEQcAAcUUgA3FBAUcNAQtBACEFIARBwABxDQBBAiEFIARB//8DcSIDQQhxDQACQCADQYAEcUUNAAJAIAAtAChBAUcNACAALQAtQQpxDQBBBQ8LQQQPCwJAIANBIHENAAJAIAAtAChBAUYNACAALwEyQf//A3EiAEGcf2pB5ABJDQAgAEHMAUYNACAAQbACRg0AQQQhBSAEQShxRQ0CIANBiARxQYAERg0CC0EADwtBAEEDIAApAyBQGyEFCyAFC2IBAn9BACEBAkAgAC0AKEEBRg0AIAAvATJB//8DcSICQZx/akHkAEkNACACQcwBRg0AIAJBsAJGDQAgAC8BMCIAQcAAcQ0AQQEhASAAQYgEcUGABEYNACAAQShxRSEBCyABC6cBAQN/AkACQAJAIAAtACpFDQAgAC0AK0UNAEEAIQMgAC8BMCIEQQJxRQ0BDAILQQAhAyAALwEwIgRBAXFFDQELQQEhAyAALQAoQQFGDQAgAC8BMkH//wNxIgVBnH9qQeQASQ0AIAVBzAFGDQAgBUGwAkYNACAEQcAAcQ0AQQAhAyAEQYgEcUGABEYNACAEQShxQQBHIQMLIABBADsBMCAAQQA6AC8gAwuZAQECfwJAAkACQCAALQAqRQ0AIAAtACtFDQBBACEBIAAvATAiAkECcUUNAQwCC0EAIQEgAC8BMCICQQFxRQ0BC0EBIQEgAC0AKEEBRg0AIAAvATJB//8DcSIAQZx/akHkAEkNACAAQcwBRg0AIABBsAJGDQAgAkHAAHENAEEAIQEgAkGIBHFBgARGDQAgAkEocUEARyEBCyABC1kAIABBGGpCADcDACAAQgA3AwAgAEE4akIANwMAIABBMGpCADcDACAAQShqQgA3AwAgAEEgakIANwMAIABBEGpCADcDACAAQQhqQgA3AwAgAEHdATYCHEEAC3sBAX8CQCAAKAIMIgMNAAJAIAAoAgRFDQAgACABNgIECwJAIAAgASACEMSAgIAAIgMNACAAKAIMDwsgACADNgIcQQAhAyAAKAIEIgFFDQAgACABIAIgACgCCBGBgICAAAAiAUUNACAAIAI2AhQgACABNgIMIAEhAwsgAwvk8wEDDn8DfgR/I4CAgIAAQRBrIgMkgICAgAAgASEEIAEhBSABIQYgASEHIAEhCCABIQkgASEKIAEhCyABIQwgASENIAEhDiABIQ8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCHCIQQX9qDt0B2gEB2QECAwQFBgcICQoLDA0O2AEPENcBERLWARMUFRYXGBkaG+AB3wEcHR7VAR8gISIjJCXUASYnKCkqKyzTAdIBLS7RAdABLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVG2wFHSElKzwHOAUvNAUzMAU1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f4ABgQGCAYMBhAGFAYYBhwGIAYkBigGLAYwBjQGOAY8BkAGRAZIBkwGUAZUBlgGXAZgBmQGaAZsBnAGdAZ4BnwGgAaEBogGjAaQBpQGmAacBqAGpAaoBqwGsAa0BrgGvAbABsQGyAbMBtAG1AbYBtwHLAcoBuAHJAbkByAG6AbsBvAG9Ab4BvwHAAcEBwgHDAcQBxQHGAQDcAQtBACEQDMYBC0EOIRAMxQELQQ0hEAzEAQtBDyEQDMMBC0EQIRAMwgELQRMhEAzBAQtBFCEQDMABC0EVIRAMvwELQRYhEAy+AQtBFyEQDL0BC0EYIRAMvAELQRkhEAy7AQtBGiEQDLoBC0EbIRAMuQELQRwhEAy4AQtBCCEQDLcBC0EdIRAMtgELQSAhEAy1AQtBHyEQDLQBC0EHIRAMswELQSEhEAyyAQtBIiEQDLEBC0EeIRAMsAELQSMhEAyvAQtBEiEQDK4BC0ERIRAMrQELQSQhEAysAQtBJSEQDKsBC0EmIRAMqgELQSchEAypAQtBwwEhEAyoAQtBKSEQDKcBC0ErIRAMpgELQSwhEAylAQtBLSEQDKQBC0EuIRAMowELQS8hEAyiAQtBxAEhEAyhAQtBMCEQDKABC0E0IRAMnwELQQwhEAyeAQtBMSEQDJ0BC0EyIRAMnAELQTMhEAybAQtBOSEQDJoBC0E1IRAMmQELQcUBIRAMmAELQQshEAyXAQtBOiEQDJYBC0E2IRAMlQELQQohEAyUAQtBNyEQDJMBC0E4IRAMkgELQTwhEAyRAQtBOyEQDJABC0E9IRAMjwELQQkhEAyOAQtBKCEQDI0BC0E+IRAMjAELQT8hEAyLAQtBwAAhEAyKAQtBwQAhEAyJAQtBwgAhEAyIAQtBwwAhEAyHAQtBxAAhEAyGAQtBxQAhEAyFAQtBxgAhEAyEAQtBKiEQDIMBC0HHACEQDIIBC0HIACEQDIEBC0HJACEQDIABC0HKACEQDH8LQcsAIRAMfgtBzQAhEAx9C0HMACEQDHwLQc4AIRAMewtBzwAhEAx6C0HQACEQDHkLQdEAIRAMeAtB0gAhEAx3C0HTACEQDHYLQdQAIRAMdQtB1gAhEAx0C0HVACEQDHMLQQYhEAxyC0HXACEQDHELQQUhEAxwC0HYACEQDG8LQQQhEAxuC0HZACEQDG0LQdoAIRAMbAtB2wAhEAxrC0HcACEQDGoLQQMhEAxpC0HdACEQDGgLQd4AIRAMZwtB3wAhEAxmC0HhACEQDGULQeAAIRAMZAtB4gAhEAxjC0HjACEQDGILQQIhEAxhC0HkACEQDGALQeUAIRAMXwtB5gAhEAxeC0HnACEQDF0LQegAIRAMXAtB6QAhEAxbC0HqACEQDFoLQesAIRAMWQtB7AAhEAxYC0HtACEQDFcLQe4AIRAMVgtB7wAhEAxVC0HwACEQDFQLQfEAIRAMUwtB8gAhEAxSC0HzACEQDFELQfQAIRAMUAtB9QAhEAxPC0H2ACEQDE4LQfcAIRAMTQtB+AAhEAxMC0H5ACEQDEsLQfoAIRAMSgtB+wAhEAxJC0H8ACEQDEgLQf0AIRAMRwtB/gAhEAxGC0H/ACEQDEULQYABIRAMRAtBgQEhEAxDC0GCASEQDEILQYMBIRAMQQtBhAEhEAxAC0GFASEQDD8LQYYBIRAMPgtBhwEhEAw9C0GIASEQDDwLQYkBIRAMOwtBigEhEAw6C0GLASEQDDkLQYwBIRAMOAtBjQEhEAw3C0GOASEQDDYLQY8BIRAMNQtBkAEhEAw0C0GRASEQDDMLQZIBIRAMMgtBkwEhEAwxC0GUASEQDDALQZUBIRAMLwtBlgEhEAwuC0GXASEQDC0LQZgBIRAMLAtBmQEhEAwrC0GaASEQDCoLQZsBIRAMKQtBnAEhEAwoC0GdASEQDCcLQZ4BIRAMJgtBnwEhEAwlC0GgASEQDCQLQaEBIRAMIwtBogEhEAwiC0GjASEQDCELQaQBIRAMIAtBpQEhEAwfC0GmASEQDB4LQacBIRAMHQtBqAEhEAwcC0GpASEQDBsLQaoBIRAMGgtBqwEhEAwZC0GsASEQDBgLQa0BIRAMFwtBrgEhEAwWC0EBIRAMFQtBrwEhEAwUC0GwASEQDBMLQbEBIRAMEgtBswEhEAwRC0GyASEQDBALQbQBIRAMDwtBtQEhEAwOC0G2ASEQDA0LQbcBIRAMDAtBuAEhEAwLC0G5ASEQDAoLQboBIRAMCQtBuwEhEAwIC0HGASEQDAcLQbwBIRAMBgtBvQEhEAwFC0G+ASEQDAQLQb8BIRAMAwtBwAEhEAwCC0HCASEQDAELQcEBIRALA0ACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAQDscBAAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxweHyAhIyUoP0BBREVGR0hJSktMTU9QUVJT3gNXWVtcXWBiZWZnaGlqa2xtb3BxcnN0dXZ3eHl6e3x9foABggGFAYYBhwGJAYsBjAGNAY4BjwGQAZEBlAGVAZYBlwGYAZkBmgGbAZwBnQGeAZ8BoAGhAaIBowGkAaUBpgGnAagBqQGqAasBrAGtAa4BrwGwAbEBsgGzAbQBtQG2AbcBuAG5AboBuwG8Ab0BvgG/AcABwQHCAcMBxAHFAcYBxwHIAckBygHLAcwBzQHOAc8B0AHRAdIB0wHUAdUB1gHXAdgB2QHaAdsB3AHdAd4B4AHhAeIB4wHkAeUB5gHnAegB6QHqAesB7AHtAe4B7wHwAfEB8gHzAZkCpAKwAv4C/gILIAEiBCACRw3zAUHdASEQDP8DCyABIhAgAkcN3QFBwwEhEAz+AwsgASIBIAJHDZABQfcAIRAM/QMLIAEiASACRw2GAUHvACEQDPwDCyABIgEgAkcNf0HqACEQDPsDCyABIgEgAkcNe0HoACEQDPoDCyABIgEgAkcNeEHmACEQDPkDCyABIgEgAkcNGkEYIRAM+AMLIAEiASACRw0UQRIhEAz3AwsgASIBIAJHDVlBxQAhEAz2AwsgASIBIAJHDUpBPyEQDPUDCyABIgEgAkcNSEE8IRAM9AMLIAEiASACRw1BQTEhEAzzAwsgAC0ALkEBRg3rAwyHAgsgACABIgEgAhDAgICAAEEBRw3mASAAQgA3AyAM5wELIAAgASIBIAIQtICAgAAiEA3nASABIQEM9QILAkAgASIBIAJHDQBBBiEQDPADCyAAIAFBAWoiASACELuAgIAAIhAN6AEgASEBDDELIABCADcDIEESIRAM1QMLIAEiECACRw0rQR0hEAztAwsCQCABIgEgAkYNACABQQFqIQFBECEQDNQDC0EHIRAM7AMLIABCACAAKQMgIhEgAiABIhBrrSISfSITIBMgEVYbNwMgIBEgElYiFEUN5QFBCCEQDOsDCwJAIAEiASACRg0AIABBiYCAgAA2AgggACABNgIEIAEhAUEUIRAM0gMLQQkhEAzqAwsgASEBIAApAyBQDeQBIAEhAQzyAgsCQCABIgEgAkcNAEELIRAM6QMLIAAgAUEBaiIBIAIQtoCAgAAiEA3lASABIQEM8gILIAAgASIBIAIQuICAgAAiEA3lASABIQEM8gILIAAgASIBIAIQuICAgAAiEA3mASABIQEMDQsgACABIgEgAhC6gICAACIQDecBIAEhAQzwAgsCQCABIgEgAkcNAEEPIRAM5QMLIAEtAAAiEEE7Rg0IIBBBDUcN6AEgAUEBaiEBDO8CCyAAIAEiASACELqAgIAAIhAN6AEgASEBDPICCwNAAkAgAS0AAEHwtYCAAGotAAAiEEEBRg0AIBBBAkcN6wEgACgCBCEQIABBADYCBCAAIBAgAUEBaiIBELmAgIAAIhAN6gEgASEBDPQCCyABQQFqIgEgAkcNAAtBEiEQDOIDCyAAIAEiASACELqAgIAAIhAN6QEgASEBDAoLIAEiASACRw0GQRshEAzgAwsCQCABIgEgAkcNAEEWIRAM4AMLIABBioCAgAA2AgggACABNgIEIAAgASACELiAgIAAIhAN6gEgASEBQSAhEAzGAwsCQCABIgEgAkYNAANAAkAgAS0AAEHwt4CAAGotAAAiEEECRg0AAkAgEEF/ag4E5QHsAQDrAewBCyABQQFqIQFBCCEQDMgDCyABQQFqIgEgAkcNAAtBFSEQDN8DC0EVIRAM3gMLA0ACQCABLQAAQfC5gIAAai0AACIQQQJGDQAgEEF/ag4E3gHsAeAB6wHsAQsgAUEBaiIBIAJHDQALQRghEAzdAwsCQCABIgEgAkYNACAAQYuAgIAANgIIIAAgATYCBCABIQFBByEQDMQDC0EZIRAM3AMLIAFBAWohAQwCCwJAIAEiFCACRw0AQRohEAzbAwsgFCEBAkAgFC0AAEFzag4U3QLuAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gIA7gILQQAhECAAQQA2AhwgAEGvi4CAADYCECAAQQI2AgwgACAUQQFqNgIUDNoDCwJAIAEtAAAiEEE7Rg0AIBBBDUcN6AEgAUEBaiEBDOUCCyABQQFqIQELQSIhEAy/AwsCQCABIhAgAkcNAEEcIRAM2AMLQgAhESAQIQEgEC0AAEFQag435wHmAQECAwQFBgcIAAAAAAAAAAkKCwwNDgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADxAREhMUAAtBHiEQDL0DC0ICIREM5QELQgMhEQzkAQtCBCERDOMBC0IFIREM4gELQgYhEQzhAQtCByERDOABC0IIIREM3wELQgkhEQzeAQtCCiERDN0BC0ILIREM3AELQgwhEQzbAQtCDSERDNoBC0IOIREM2QELQg8hEQzYAQtCCiERDNcBC0ILIREM1gELQgwhEQzVAQtCDSERDNQBC0IOIREM0wELQg8hEQzSAQtCACERAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAQLQAAQVBqDjflAeQBAAECAwQFBgfmAeYB5gHmAeYB5gHmAQgJCgsMDeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gEODxAREhPmAQtCAiERDOQBC0IDIREM4wELQgQhEQziAQtCBSERDOEBC0IGIREM4AELQgchEQzfAQtCCCERDN4BC0IJIREM3QELQgohEQzcAQtCCyERDNsBC0IMIREM2gELQg0hEQzZAQtCDiERDNgBC0IPIREM1wELQgohEQzWAQtCCyERDNUBC0IMIREM1AELQg0hEQzTAQtCDiERDNIBC0IPIREM0QELIABCACAAKQMgIhEgAiABIhBrrSISfSITIBMgEVYbNwMgIBEgElYiFEUN0gFBHyEQDMADCwJAIAEiASACRg0AIABBiYCAgAA2AgggACABNgIEIAEhAUEkIRAMpwMLQSAhEAy/AwsgACABIhAgAhC+gICAAEF/ag4FtgEAxQIB0QHSAQtBESEQDKQDCyAAQQE6AC8gECEBDLsDCyABIgEgAkcN0gFBJCEQDLsDCyABIg0gAkcNHkHGACEQDLoDCyAAIAEiASACELKAgIAAIhAN1AEgASEBDLUBCyABIhAgAkcNJkHQACEQDLgDCwJAIAEiASACRw0AQSghEAy4AwsgAEEANgIEIABBjICAgAA2AgggACABIAEQsYCAgAAiEA3TASABIQEM2AELAkAgASIQIAJHDQBBKSEQDLcDCyAQLQAAIgFBIEYNFCABQQlHDdMBIBBBAWohAQwVCwJAIAEiASACRg0AIAFBAWohAQwXC0EqIRAMtQMLAkAgASIQIAJHDQBBKyEQDLUDCwJAIBAtAAAiAUEJRg0AIAFBIEcN1QELIAAtACxBCEYN0wEgECEBDJEDCwJAIAEiASACRw0AQSwhEAy0AwsgAS0AAEEKRw3VASABQQFqIQEMyQILIAEiDiACRw3VAUEvIRAMsgMLA0ACQCABLQAAIhBBIEYNAAJAIBBBdmoOBADcAdwBANoBCyABIQEM4AELIAFBAWoiASACRw0AC0ExIRAMsQMLQTIhECABIhQgAkYNsAMgAiAUayAAKAIAIgFqIRUgFCABa0EDaiEWAkADQCAULQAAIhdBIHIgFyAXQb9/akH/AXFBGkkbQf8BcSABQfC7gIAAai0AAEcNAQJAIAFBA0cNAEEGIQEMlgMLIAFBAWohASAUQQFqIhQgAkcNAAsgACAVNgIADLEDCyAAQQA2AgAgFCEBDNkBC0EzIRAgASIUIAJGDa8DIAIgFGsgACgCACIBaiEVIBQgAWtBCGohFgJAA0AgFC0AACIXQSByIBcgF0G/f2pB/wFxQRpJG0H/AXEgAUH0u4CAAGotAABHDQECQCABQQhHDQBBBSEBDJUDCyABQQFqIQEgFEEBaiIUIAJHDQALIAAgFTYCAAywAwsgAEEANgIAIBQhAQzYAQtBNCEQIAEiFCACRg2uAyACIBRrIAAoAgAiAWohFSAUIAFrQQVqIRYCQANAIBQtAAAiF0EgciAXIBdBv39qQf8BcUEaSRtB/wFxIAFB0MKAgABqLQAARw0BAkAgAUEFRw0AQQchAQyUAwsgAUEBaiEBIBRBAWoiFCACRw0ACyAAIBU2AgAMrwMLIABBADYCACAUIQEM1wELAkAgASIBIAJGDQADQAJAIAEtAABBgL6AgABqLQAAIhBBAUYNACAQQQJGDQogASEBDN0BCyABQQFqIgEgAkcNAAtBMCEQDK4DC0EwIRAMrQMLAkAgASIBIAJGDQADQAJAIAEtAAAiEEEgRg0AIBBBdmoOBNkB2gHaAdkB2gELIAFBAWoiASACRw0AC0E4IRAMrQMLQTghEAysAwsDQAJAIAEtAAAiEEEgRg0AIBBBCUcNAwsgAUEBaiIBIAJHDQALQTwhEAyrAwsDQAJAIAEtAAAiEEEgRg0AAkACQCAQQXZqDgTaAQEB2gEACyAQQSxGDdsBCyABIQEMBAsgAUEBaiIBIAJHDQALQT8hEAyqAwsgASEBDNsBC0HAACEQIAEiFCACRg2oAyACIBRrIAAoAgAiAWohFiAUIAFrQQZqIRcCQANAIBQtAABBIHIgAUGAwICAAGotAABHDQEgAUEGRg2OAyABQQFqIQEgFEEBaiIUIAJHDQALIAAgFjYCAAypAwsgAEEANgIAIBQhAQtBNiEQDI4DCwJAIAEiDyACRw0AQcEAIRAMpwMLIABBjICAgAA2AgggACAPNgIEIA8hASAALQAsQX9qDgTNAdUB1wHZAYcDCyABQQFqIQEMzAELAkAgASIBIAJGDQADQAJAIAEtAAAiEEEgciAQIBBBv39qQf8BcUEaSRtB/wFxIhBBCUYNACAQQSBGDQACQAJAAkACQCAQQZ1/ag4TAAMDAwMDAwMBAwMDAwMDAwMDAgMLIAFBAWohAUExIRAMkQMLIAFBAWohAUEyIRAMkAMLIAFBAWohAUEzIRAMjwMLIAEhAQzQAQsgAUEBaiIBIAJHDQALQTUhEAylAwtBNSEQDKQDCwJAIAEiASACRg0AA0ACQCABLQAAQYC8gIAAai0AAEEBRg0AIAEhAQzTAQsgAUEBaiIBIAJHDQALQT0hEAykAwtBPSEQDKMDCyAAIAEiASACELCAgIAAIhAN1gEgASEBDAELIBBBAWohAQtBPCEQDIcDCwJAIAEiASACRw0AQcIAIRAMoAMLAkADQAJAIAEtAABBd2oOGAAC/gL+AoQD/gL+Av4C/gL+Av4C/gL+Av4C/gL+Av4C/gL+Av4C/gL+Av4CAP4CCyABQQFqIgEgAkcNAAtBwgAhEAygAwsgAUEBaiEBIAAtAC1BAXFFDb0BIAEhAQtBLCEQDIUDCyABIgEgAkcN0wFBxAAhEAydAwsDQAJAIAEtAABBkMCAgABqLQAAQQFGDQAgASEBDLcCCyABQQFqIgEgAkcNAAtBxQAhEAycAwsgDS0AACIQQSBGDbMBIBBBOkcNgQMgACgCBCEBIABBADYCBCAAIAEgDRCvgICAACIBDdABIA1BAWohAQyzAgtBxwAhECABIg0gAkYNmgMgAiANayAAKAIAIgFqIRYgDSABa0EFaiEXA0AgDS0AACIUQSByIBQgFEG/f2pB/wFxQRpJG0H/AXEgAUGQwoCAAGotAABHDYADIAFBBUYN9AIgAUEBaiEBIA1BAWoiDSACRw0ACyAAIBY2AgAMmgMLQcgAIRAgASINIAJGDZkDIAIgDWsgACgCACIBaiEWIA0gAWtBCWohFwNAIA0tAAAiFEEgciAUIBRBv39qQf8BcUEaSRtB/wFxIAFBlsKAgABqLQAARw3/AgJAIAFBCUcNAEECIQEM9QILIAFBAWohASANQQFqIg0gAkcNAAsgACAWNgIADJkDCwJAIAEiDSACRw0AQckAIRAMmQMLAkACQCANLQAAIgFBIHIgASABQb9/akH/AXFBGkkbQf8BcUGSf2oOBwCAA4ADgAOAA4ADAYADCyANQQFqIQFBPiEQDIADCyANQQFqIQFBPyEQDP8CC0HKACEQIAEiDSACRg2XAyACIA1rIAAoAgAiAWohFiANIAFrQQFqIRcDQCANLQAAIhRBIHIgFCAUQb9/akH/AXFBGkkbQf8BcSABQaDCgIAAai0AAEcN/QIgAUEBRg3wAiABQQFqIQEgDUEBaiINIAJHDQALIAAgFjYCAAyXAwtBywAhECABIg0gAkYNlgMgAiANayAAKAIAIgFqIRYgDSABa0EOaiEXA0AgDS0AACIUQSByIBQgFEG/f2pB/wFxQRpJG0H/AXEgAUGiwoCAAGotAABHDfwCIAFBDkYN8AIgAUEBaiEBIA1BAWoiDSACRw0ACyAAIBY2AgAMlgMLQcwAIRAgASINIAJGDZUDIAIgDWsgACgCACIBaiEWIA0gAWtBD2ohFwNAIA0tAAAiFEEgciAUIBRBv39qQf8BcUEaSRtB/wFxIAFBwMKAgABqLQAARw37AgJAIAFBD0cNAEEDIQEM8QILIAFBAWohASANQQFqIg0gAkcNAAsgACAWNgIADJUDC0HNACEQIAEiDSACRg2UAyACIA1rIAAoAgAiAWohFiANIAFrQQVqIRcDQCANLQAAIhRBIHIgFCAUQb9/akH/AXFBGkkbQf8BcSABQdDCgIAAai0AAEcN+gICQCABQQVHDQBBBCEBDPACCyABQQFqIQEgDUEBaiINIAJHDQALIAAgFjYCAAyUAwsCQCABIg0gAkcNAEHOACEQDJQDCwJAAkACQAJAIA0tAAAiAUEgciABIAFBv39qQf8BcUEaSRtB/wFxQZ1/ag4TAP0C/QL9Av0C/QL9Av0C/QL9Av0C/QL9AgH9Av0C/QICA/0CCyANQQFqIQFBwQAhEAz9AgsgDUEBaiEBQcIAIRAM/AILIA1BAWohAUHDACEQDPsCCyANQQFqIQFBxAAhEAz6AgsCQCABIgEgAkYNACAAQY2AgIAANgIIIAAgATYCBCABIQFBxQAhEAz6AgtBzwAhEAySAwsgECEBAkACQCAQLQAAQXZqDgQBqAKoAgCoAgsgEEEBaiEBC0EnIRAM+AILAkAgASIBIAJHDQBB0QAhEAyRAwsCQCABLQAAQSBGDQAgASEBDI0BCyABQQFqIQEgAC0ALUEBcUUNxwEgASEBDIwBCyABIhcgAkcNyAFB0gAhEAyPAwtB0wAhECABIhQgAkYNjgMgAiAUayAAKAIAIgFqIRYgFCABa0EBaiEXA0AgFC0AACABQdbCgIAAai0AAEcNzAEgAUEBRg3HASABQQFqIQEgFEEBaiIUIAJHDQALIAAgFjYCAAyOAwsCQCABIgEgAkcNAEHVACEQDI4DCyABLQAAQQpHDcwBIAFBAWohAQzHAQsCQCABIgEgAkcNAEHWACEQDI0DCwJAAkAgAS0AAEF2ag4EAM0BzQEBzQELIAFBAWohAQzHAQsgAUEBaiEBQcoAIRAM8wILIAAgASIBIAIQroCAgAAiEA3LASABIQFBzQAhEAzyAgsgAC0AKUEiRg2FAwymAgsCQCABIgEgAkcNAEHbACEQDIoDC0EAIRRBASEXQQEhFkEAIRACQAJAAkACQAJAAkACQAJAAkAgAS0AAEFQag4K1AHTAQABAgMEBQYI1QELQQIhEAwGC0EDIRAMBQtBBCEQDAQLQQUhEAwDC0EGIRAMAgtBByEQDAELQQghEAtBACEXQQAhFkEAIRQMzAELQQkhEEEBIRRBACEXQQAhFgzLAQsCQCABIgEgAkcNAEHdACEQDIkDCyABLQAAQS5HDcwBIAFBAWohAQymAgsgASIBIAJHDcwBQd8AIRAMhwMLAkAgASIBIAJGDQAgAEGOgICAADYCCCAAIAE2AgQgASEBQdAAIRAM7gILQeAAIRAMhgMLQeEAIRAgASIBIAJGDYUDIAIgAWsgACgCACIUaiEWIAEgFGtBA2ohFwNAIAEtAAAgFEHiwoCAAGotAABHDc0BIBRBA0YNzAEgFEEBaiEUIAFBAWoiASACRw0ACyAAIBY2AgAMhQMLQeIAIRAgASIBIAJGDYQDIAIgAWsgACgCACIUaiEWIAEgFGtBAmohFwNAIAEtAAAgFEHmwoCAAGotAABHDcwBIBRBAkYNzgEgFEEBaiEUIAFBAWoiASACRw0ACyAAIBY2AgAMhAMLQeMAIRAgASIBIAJGDYMDIAIgAWsgACgCACIUaiEWIAEgFGtBA2ohFwNAIAEtAAAgFEHpwoCAAGotAABHDcsBIBRBA0YNzgEgFEEBaiEUIAFBAWoiASACRw0ACyAAIBY2AgAMgwMLAkAgASIBIAJHDQBB5QAhEAyDAwsgACABQQFqIgEgAhCogICAACIQDc0BIAEhAUHWACEQDOkCCwJAIAEiASACRg0AA0ACQCABLQAAIhBBIEYNAAJAAkACQCAQQbh/ag4LAAHPAc8BzwHPAc8BzwHPAc8BAs8BCyABQQFqIQFB0gAhEAztAgsgAUEBaiEBQdMAIRAM7AILIAFBAWohAUHUACEQDOsCCyABQQFqIgEgAkcNAAtB5AAhEAyCAwtB5AAhEAyBAwsDQAJAIAEtAABB8MKAgABqLQAAIhBBAUYNACAQQX5qDgPPAdAB0QHSAQsgAUEBaiIBIAJHDQALQeYAIRAMgAMLAkAgASIBIAJGDQAgAUEBaiEBDAMLQecAIRAM/wILA0ACQCABLQAAQfDEgIAAai0AACIQQQFGDQACQCAQQX5qDgTSAdMB1AEA1QELIAEhAUHXACEQDOcCCyABQQFqIgEgAkcNAAtB6AAhEAz+AgsCQCABIgEgAkcNAEHpACEQDP4CCwJAIAEtAAAiEEF2ag4augHVAdUBvAHVAdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHKAdUB1QEA0wELIAFBAWohAQtBBiEQDOMCCwNAAkAgAS0AAEHwxoCAAGotAABBAUYNACABIQEMngILIAFBAWoiASACRw0AC0HqACEQDPsCCwJAIAEiASACRg0AIAFBAWohAQwDC0HrACEQDPoCCwJAIAEiASACRw0AQewAIRAM+gILIAFBAWohAQwBCwJAIAEiASACRw0AQe0AIRAM+QILIAFBAWohAQtBBCEQDN4CCwJAIAEiFCACRw0AQe4AIRAM9wILIBQhAQJAAkACQCAULQAAQfDIgIAAai0AAEF/ag4H1AHVAdYBAJwCAQLXAQsgFEEBaiEBDAoLIBRBAWohAQzNAQtBACEQIABBADYCHCAAQZuSgIAANgIQIABBBzYCDCAAIBRBAWo2AhQM9gILAkADQAJAIAEtAABB8MiAgABqLQAAIhBBBEYNAAJAAkAgEEF/ag4H0gHTAdQB2QEABAHZAQsgASEBQdoAIRAM4AILIAFBAWohAUHcACEQDN8CCyABQQFqIgEgAkcNAAtB7wAhEAz2AgsgAUEBaiEBDMsBCwJAIAEiFCACRw0AQfAAIRAM9QILIBQtAABBL0cN1AEgFEEBaiEBDAYLAkAgASIUIAJHDQBB8QAhEAz0AgsCQCAULQAAIgFBL0cNACAUQQFqIQFB3QAhEAzbAgsgAUF2aiIEQRZLDdMBQQEgBHRBiYCAAnFFDdMBDMoCCwJAIAEiASACRg0AIAFBAWohAUHeACEQDNoCC0HyACEQDPICCwJAIAEiFCACRw0AQfQAIRAM8gILIBQhAQJAIBQtAABB8MyAgABqLQAAQX9qDgPJApQCANQBC0HhACEQDNgCCwJAIAEiFCACRg0AA0ACQCAULQAAQfDKgIAAai0AACIBQQNGDQACQCABQX9qDgLLAgDVAQsgFCEBQd8AIRAM2gILIBRBAWoiFCACRw0AC0HzACEQDPECC0HzACEQDPACCwJAIAEiASACRg0AIABBj4CAgAA2AgggACABNgIEIAEhAUHgACEQDNcCC0H1ACEQDO8CCwJAIAEiASACRw0AQfYAIRAM7wILIABBj4CAgAA2AgggACABNgIEIAEhAQtBAyEQDNQCCwNAIAEtAABBIEcNwwIgAUEBaiIBIAJHDQALQfcAIRAM7AILAkAgASIBIAJHDQBB+AAhEAzsAgsgAS0AAEEgRw3OASABQQFqIQEM7wELIAAgASIBIAIQrICAgAAiEA3OASABIQEMjgILAkAgASIEIAJHDQBB+gAhEAzqAgsgBC0AAEHMAEcN0QEgBEEBaiEBQRMhEAzPAQsCQCABIgQgAkcNAEH7ACEQDOkCCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRADQCAELQAAIAFB8M6AgABqLQAARw3QASABQQVGDc4BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQfsAIRAM6AILAkAgASIEIAJHDQBB/AAhEAzoAgsCQAJAIAQtAABBvX9qDgwA0QHRAdEB0QHRAdEB0QHRAdEB0QEB0QELIARBAWohAUHmACEQDM8CCyAEQQFqIQFB5wAhEAzOAgsCQCABIgQgAkcNAEH9ACEQDOcCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHtz4CAAGotAABHDc8BIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEH9ACEQDOcCCyAAQQA2AgAgEEEBaiEBQRAhEAzMAQsCQCABIgQgAkcNAEH+ACEQDOYCCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRACQANAIAQtAAAgAUH2zoCAAGotAABHDc4BIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEH+ACEQDOYCCyAAQQA2AgAgEEEBaiEBQRYhEAzLAQsCQCABIgQgAkcNAEH/ACEQDOUCCyACIARrIAAoAgAiAWohFCAEIAFrQQNqIRACQANAIAQtAAAgAUH8zoCAAGotAABHDc0BIAFBA0YNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEH/ACEQDOUCCyAAQQA2AgAgEEEBaiEBQQUhEAzKAQsCQCABIgQgAkcNAEGAASEQDOQCCyAELQAAQdkARw3LASAEQQFqIQFBCCEQDMkBCwJAIAEiBCACRw0AQYEBIRAM4wILAkACQCAELQAAQbJ/ag4DAMwBAcwBCyAEQQFqIQFB6wAhEAzKAgsgBEEBaiEBQewAIRAMyQILAkAgASIEIAJHDQBBggEhEAziAgsCQAJAIAQtAABBuH9qDggAywHLAcsBywHLAcsBAcsBCyAEQQFqIQFB6gAhEAzJAgsgBEEBaiEBQe0AIRAMyAILAkAgASIEIAJHDQBBgwEhEAzhAgsgAiAEayAAKAIAIgFqIRAgBCABa0ECaiEUAkADQCAELQAAIAFBgM+AgABqLQAARw3JASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBA2AgBBgwEhEAzhAgtBACEQIABBADYCACAUQQFqIQEMxgELAkAgASIEIAJHDQBBhAEhEAzgAgsgAiAEayAAKAIAIgFqIRQgBCABa0EEaiEQAkADQCAELQAAIAFBg8+AgABqLQAARw3IASABQQRGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBhAEhEAzgAgsgAEEANgIAIBBBAWohAUEjIRAMxQELAkAgASIEIAJHDQBBhQEhEAzfAgsCQAJAIAQtAABBtH9qDggAyAHIAcgByAHIAcgBAcgBCyAEQQFqIQFB7wAhEAzGAgsgBEEBaiEBQfAAIRAMxQILAkAgASIEIAJHDQBBhgEhEAzeAgsgBC0AAEHFAEcNxQEgBEEBaiEBDIMCCwJAIAEiBCACRw0AQYcBIRAM3QILIAIgBGsgACgCACIBaiEUIAQgAWtBA2ohEAJAA0AgBC0AACABQYjPgIAAai0AAEcNxQEgAUEDRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQYcBIRAM3QILIABBADYCACAQQQFqIQFBLSEQDMIBCwJAIAEiBCACRw0AQYgBIRAM3AILIAIgBGsgACgCACIBaiEUIAQgAWtBCGohEAJAA0AgBC0AACABQdDPgIAAai0AAEcNxAEgAUEIRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQYgBIRAM3AILIABBADYCACAQQQFqIQFBKSEQDMEBCwJAIAEiASACRw0AQYkBIRAM2wILQQEhECABLQAAQd8ARw3AASABQQFqIQEMgQILAkAgASIEIAJHDQBBigEhEAzaAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQA0AgBC0AACABQYzPgIAAai0AAEcNwQEgAUEBRg2vAiABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGKASEQDNkCCwJAIAEiBCACRw0AQYsBIRAM2QILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQY7PgIAAai0AAEcNwQEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQYsBIRAM2QILIABBADYCACAQQQFqIQFBAiEQDL4BCwJAIAEiBCACRw0AQYwBIRAM2AILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQfDPgIAAai0AAEcNwAEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQYwBIRAM2AILIABBADYCACAQQQFqIQFBHyEQDL0BCwJAIAEiBCACRw0AQY0BIRAM1wILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQfLPgIAAai0AAEcNvwEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQY0BIRAM1wILIABBADYCACAQQQFqIQFBCSEQDLwBCwJAIAEiBCACRw0AQY4BIRAM1gILAkACQCAELQAAQbd/ag4HAL8BvwG/Ab8BvwEBvwELIARBAWohAUH4ACEQDL0CCyAEQQFqIQFB+QAhEAy8AgsCQCABIgQgAkcNAEGPASEQDNUCCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRACQANAIAQtAAAgAUGRz4CAAGotAABHDb0BIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGPASEQDNUCCyAAQQA2AgAgEEEBaiEBQRghEAy6AQsCQCABIgQgAkcNAEGQASEQDNQCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUGXz4CAAGotAABHDbwBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGQASEQDNQCCyAAQQA2AgAgEEEBaiEBQRchEAy5AQsCQCABIgQgAkcNAEGRASEQDNMCCyACIARrIAAoAgAiAWohFCAEIAFrQQZqIRACQANAIAQtAAAgAUGaz4CAAGotAABHDbsBIAFBBkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGRASEQDNMCCyAAQQA2AgAgEEEBaiEBQRUhEAy4AQsCQCABIgQgAkcNAEGSASEQDNICCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRACQANAIAQtAAAgAUGhz4CAAGotAABHDboBIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGSASEQDNICCyAAQQA2AgAgEEEBaiEBQR4hEAy3AQsCQCABIgQgAkcNAEGTASEQDNECCyAELQAAQcwARw24ASAEQQFqIQFBCiEQDLYBCwJAIAQgAkcNAEGUASEQDNACCwJAAkAgBC0AAEG/f2oODwC5AbkBuQG5AbkBuQG5AbkBuQG5AbkBuQG5AQG5AQsgBEEBaiEBQf4AIRAMtwILIARBAWohAUH/ACEQDLYCCwJAIAQgAkcNAEGVASEQDM8CCwJAAkAgBC0AAEG/f2oOAwC4AQG4AQsgBEEBaiEBQf0AIRAMtgILIARBAWohBEGAASEQDLUCCwJAIAQgAkcNAEGWASEQDM4CCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRACQANAIAQtAAAgAUGnz4CAAGotAABHDbYBIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGWASEQDM4CCyAAQQA2AgAgEEEBaiEBQQshEAyzAQsCQCAEIAJHDQBBlwEhEAzNAgsCQAJAAkACQCAELQAAQVNqDiMAuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AQG4AbgBuAG4AbgBArgBuAG4AQO4AQsgBEEBaiEBQfsAIRAMtgILIARBAWohAUH8ACEQDLUCCyAEQQFqIQRBgQEhEAy0AgsgBEEBaiEEQYIBIRAMswILAkAgBCACRw0AQZgBIRAMzAILIAIgBGsgACgCACIBaiEUIAQgAWtBBGohEAJAA0AgBC0AACABQanPgIAAai0AAEcNtAEgAUEERg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZgBIRAMzAILIABBADYCACAQQQFqIQFBGSEQDLEBCwJAIAQgAkcNAEGZASEQDMsCCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRACQANAIAQtAAAgAUGuz4CAAGotAABHDbMBIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGZASEQDMsCCyAAQQA2AgAgEEEBaiEBQQYhEAywAQsCQCAEIAJHDQBBmgEhEAzKAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFBtM+AgABqLQAARw2yASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBmgEhEAzKAgsgAEEANgIAIBBBAWohAUEcIRAMrwELAkAgBCACRw0AQZsBIRAMyQILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQbbPgIAAai0AAEcNsQEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZsBIRAMyQILIABBADYCACAQQQFqIQFBJyEQDK4BCwJAIAQgAkcNAEGcASEQDMgCCwJAAkAgBC0AAEGsf2oOAgABsQELIARBAWohBEGGASEQDK8CCyAEQQFqIQRBhwEhEAyuAgsCQCAEIAJHDQBBnQEhEAzHAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFBuM+AgABqLQAARw2vASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBnQEhEAzHAgsgAEEANgIAIBBBAWohAUEmIRAMrAELAkAgBCACRw0AQZ4BIRAMxgILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQbrPgIAAai0AAEcNrgEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZ4BIRAMxgILIABBADYCACAQQQFqIQFBAyEQDKsBCwJAIAQgAkcNAEGfASEQDMUCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHtz4CAAGotAABHDa0BIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGfASEQDMUCCyAAQQA2AgAgEEEBaiEBQQwhEAyqAQsCQCAEIAJHDQBBoAEhEAzEAgsgAiAEayAAKAIAIgFqIRQgBCABa0EDaiEQAkADQCAELQAAIAFBvM+AgABqLQAARw2sASABQQNGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBoAEhEAzEAgsgAEEANgIAIBBBAWohAUENIRAMqQELAkAgBCACRw0AQaEBIRAMwwILAkACQCAELQAAQbp/ag4LAKwBrAGsAawBrAGsAawBrAGsAQGsAQsgBEEBaiEEQYsBIRAMqgILIARBAWohBEGMASEQDKkCCwJAIAQgAkcNAEGiASEQDMICCyAELQAAQdAARw2pASAEQQFqIQQM6QELAkAgBCACRw0AQaMBIRAMwQILAkACQCAELQAAQbd/ag4HAaoBqgGqAaoBqgEAqgELIARBAWohBEGOASEQDKgCCyAEQQFqIQFBIiEQDKYBCwJAIAQgAkcNAEGkASEQDMACCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRACQANAIAQtAAAgAUHAz4CAAGotAABHDagBIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGkASEQDMACCyAAQQA2AgAgEEEBaiEBQR0hEAylAQsCQCAEIAJHDQBBpQEhEAy/AgsCQAJAIAQtAABBrn9qDgMAqAEBqAELIARBAWohBEGQASEQDKYCCyAEQQFqIQFBBCEQDKQBCwJAIAQgAkcNAEGmASEQDL4CCwJAAkACQAJAAkAgBC0AAEG/f2oOFQCqAaoBqgGqAaoBqgGqAaoBqgGqAQGqAaoBAqoBqgEDqgGqAQSqAQsgBEEBaiEEQYgBIRAMqAILIARBAWohBEGJASEQDKcCCyAEQQFqIQRBigEhEAymAgsgBEEBaiEEQY8BIRAMpQILIARBAWohBEGRASEQDKQCCwJAIAQgAkcNAEGnASEQDL0CCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHtz4CAAGotAABHDaUBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGnASEQDL0CCyAAQQA2AgAgEEEBaiEBQREhEAyiAQsCQCAEIAJHDQBBqAEhEAy8AgsgAiAEayAAKAIAIgFqIRQgBCABa0ECaiEQAkADQCAELQAAIAFBws+AgABqLQAARw2kASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBqAEhEAy8AgsgAEEANgIAIBBBAWohAUEsIRAMoQELAkAgBCACRw0AQakBIRAMuwILIAIgBGsgACgCACIBaiEUIAQgAWtBBGohEAJAA0AgBC0AACABQcXPgIAAai0AAEcNowEgAUEERg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQakBIRAMuwILIABBADYCACAQQQFqIQFBKyEQDKABCwJAIAQgAkcNAEGqASEQDLoCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHKz4CAAGotAABHDaIBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGqASEQDLoCCyAAQQA2AgAgEEEBaiEBQRQhEAyfAQsCQCAEIAJHDQBBqwEhEAy5AgsCQAJAAkACQCAELQAAQb5/ag4PAAECpAGkAaQBpAGkAaQBpAGkAaQBpAGkAQOkAQsgBEEBaiEEQZMBIRAMogILIARBAWohBEGUASEQDKECCyAEQQFqIQRBlQEhEAygAgsgBEEBaiEEQZYBIRAMnwILAkAgBCACRw0AQawBIRAMuAILIAQtAABBxQBHDZ8BIARBAWohBAzgAQsCQCAEIAJHDQBBrQEhEAy3AgsgAiAEayAAKAIAIgFqIRQgBCABa0ECaiEQAkADQCAELQAAIAFBzc+AgABqLQAARw2fASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBrQEhEAy3AgsgAEEANgIAIBBBAWohAUEOIRAMnAELAkAgBCACRw0AQa4BIRAMtgILIAQtAABB0ABHDZ0BIARBAWohAUElIRAMmwELAkAgBCACRw0AQa8BIRAMtQILIAIgBGsgACgCACIBaiEUIAQgAWtBCGohEAJAA0AgBC0AACABQdDPgIAAai0AAEcNnQEgAUEIRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQa8BIRAMtQILIABBADYCACAQQQFqIQFBKiEQDJoBCwJAIAQgAkcNAEGwASEQDLQCCwJAAkAgBC0AAEGrf2oOCwCdAZ0BnQGdAZ0BnQGdAZ0BnQEBnQELIARBAWohBEGaASEQDJsCCyAEQQFqIQRBmwEhEAyaAgsCQCAEIAJHDQBBsQEhEAyzAgsCQAJAIAQtAABBv39qDhQAnAGcAZwBnAGcAZwBnAGcAZwBnAGcAZwBnAGcAZwBnAGcAZwBAZwBCyAEQQFqIQRBmQEhEAyaAgsgBEEBaiEEQZwBIRAMmQILAkAgBCACRw0AQbIBIRAMsgILIAIgBGsgACgCACIBaiEUIAQgAWtBA2ohEAJAA0AgBC0AACABQdnPgIAAai0AAEcNmgEgAUEDRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQbIBIRAMsgILIABBADYCACAQQQFqIQFBISEQDJcBCwJAIAQgAkcNAEGzASEQDLECCyACIARrIAAoAgAiAWohFCAEIAFrQQZqIRACQANAIAQtAAAgAUHdz4CAAGotAABHDZkBIAFBBkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGzASEQDLECCyAAQQA2AgAgEEEBaiEBQRohEAyWAQsCQCAEIAJHDQBBtAEhEAywAgsCQAJAAkAgBC0AAEG7f2oOEQCaAZoBmgGaAZoBmgGaAZoBmgEBmgGaAZoBmgGaAQKaAQsgBEEBaiEEQZ0BIRAMmAILIARBAWohBEGeASEQDJcCCyAEQQFqIQRBnwEhEAyWAgsCQCAEIAJHDQBBtQEhEAyvAgsgAiAEayAAKAIAIgFqIRQgBCABa0EFaiEQAkADQCAELQAAIAFB5M+AgABqLQAARw2XASABQQVGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBtQEhEAyvAgsgAEEANgIAIBBBAWohAUEoIRAMlAELAkAgBCACRw0AQbYBIRAMrgILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQerPgIAAai0AAEcNlgEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQbYBIRAMrgILIABBADYCACAQQQFqIQFBByEQDJMBCwJAIAQgAkcNAEG3ASEQDK0CCwJAAkAgBC0AAEG7f2oODgCWAZYBlgGWAZYBlgGWAZYBlgGWAZYBlgEBlgELIARBAWohBEGhASEQDJQCCyAEQQFqIQRBogEhEAyTAgsCQCAEIAJHDQBBuAEhEAysAgsgAiAEayAAKAIAIgFqIRQgBCABa0ECaiEQAkADQCAELQAAIAFB7c+AgABqLQAARw2UASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBuAEhEAysAgsgAEEANgIAIBBBAWohAUESIRAMkQELAkAgBCACRw0AQbkBIRAMqwILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQfDPgIAAai0AAEcNkwEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQbkBIRAMqwILIABBADYCACAQQQFqIQFBICEQDJABCwJAIAQgAkcNAEG6ASEQDKoCCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRACQANAIAQtAAAgAUHyz4CAAGotAABHDZIBIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEG6ASEQDKoCCyAAQQA2AgAgEEEBaiEBQQ8hEAyPAQsCQCAEIAJHDQBBuwEhEAypAgsCQAJAIAQtAABBt39qDgcAkgGSAZIBkgGSAQGSAQsgBEEBaiEEQaUBIRAMkAILIARBAWohBEGmASEQDI8CCwJAIAQgAkcNAEG8ASEQDKgCCyACIARrIAAoAgAiAWohFCAEIAFrQQdqIRACQANAIAQtAAAgAUH0z4CAAGotAABHDZABIAFBB0YNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEG8ASEQDKgCCyAAQQA2AgAgEEEBaiEBQRshEAyNAQsCQCAEIAJHDQBBvQEhEAynAgsCQAJAAkAgBC0AAEG+f2oOEgCRAZEBkQGRAZEBkQGRAZEBkQEBkQGRAZEBkQGRAZEBApEBCyAEQQFqIQRBpAEhEAyPAgsgBEEBaiEEQacBIRAMjgILIARBAWohBEGoASEQDI0CCwJAIAQgAkcNAEG+ASEQDKYCCyAELQAAQc4ARw2NASAEQQFqIQQMzwELAkAgBCACRw0AQb8BIRAMpQILAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgBC0AAEG/f2oOFQABAgOcAQQFBpwBnAGcAQcICQoLnAEMDQ4PnAELIARBAWohAUHoACEQDJoCCyAEQQFqIQFB6QAhEAyZAgsgBEEBaiEBQe4AIRAMmAILIARBAWohAUHyACEQDJcCCyAEQQFqIQFB8wAhEAyWAgsgBEEBaiEBQfYAIRAMlQILIARBAWohAUH3ACEQDJQCCyAEQQFqIQFB+gAhEAyTAgsgBEEBaiEEQYMBIRAMkgILIARBAWohBEGEASEQDJECCyAEQQFqIQRBhQEhEAyQAgsgBEEBaiEEQZIBIRAMjwILIARBAWohBEGYASEQDI4CCyAEQQFqIQRBoAEhEAyNAgsgBEEBaiEEQaMBIRAMjAILIARBAWohBEGqASEQDIsCCwJAIAQgAkYNACAAQZCAgIAANgIIIAAgBDYCBEGrASEQDIsCC0HAASEQDKMCCyAAIAUgAhCqgICAACIBDYsBIAUhAQxcCwJAIAYgAkYNACAGQQFqIQUMjQELQcIBIRAMoQILA0ACQCAQLQAAQXZqDgSMAQAAjwEACyAQQQFqIhAgAkcNAAtBwwEhEAygAgsCQCAHIAJGDQAgAEGRgICAADYCCCAAIAc2AgQgByEBQQEhEAyHAgtBxAEhEAyfAgsCQCAHIAJHDQBBxQEhEAyfAgsCQAJAIActAABBdmoOBAHOAc4BAM4BCyAHQQFqIQYMjQELIAdBAWohBQyJAQsCQCAHIAJHDQBBxgEhEAyeAgsCQAJAIActAABBdmoOFwGPAY8BAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAQCPAQsgB0EBaiEHC0GwASEQDIQCCwJAIAggAkcNAEHIASEQDJ0CCyAILQAAQSBHDY0BIABBADsBMiAIQQFqIQFBswEhEAyDAgsgASEXAkADQCAXIgcgAkYNASAHLQAAQVBqQf8BcSIQQQpPDcwBAkAgAC8BMiIUQZkzSw0AIAAgFEEKbCIUOwEyIBBB//8DcyAUQf7/A3FJDQAgB0EBaiEXIAAgFCAQaiIQOwEyIBBB//8DcUHoB0kNAQsLQQAhECAAQQA2AhwgAEHBiYCAADYCECAAQQ02AgwgACAHQQFqNgIUDJwCC0HHASEQDJsCCyAAIAggAhCugICAACIQRQ3KASAQQRVHDYwBIABByAE2AhwgACAINgIUIABByZeAgAA2AhAgAEEVNgIMQQAhEAyaAgsCQCAJIAJHDQBBzAEhEAyaAgtBACEUQQEhF0EBIRZBACEQAkACQAJAAkACQAJAAkACQAJAIAktAABBUGoOCpYBlQEAAQIDBAUGCJcBC0ECIRAMBgtBAyEQDAULQQQhEAwEC0EFIRAMAwtBBiEQDAILQQchEAwBC0EIIRALQQAhF0EAIRZBACEUDI4BC0EJIRBBASEUQQAhF0EAIRYMjQELAkAgCiACRw0AQc4BIRAMmQILIAotAABBLkcNjgEgCkEBaiEJDMoBCyALIAJHDY4BQdABIRAMlwILAkAgCyACRg0AIABBjoCAgAA2AgggACALNgIEQbcBIRAM/gELQdEBIRAMlgILAkAgBCACRw0AQdIBIRAMlgILIAIgBGsgACgCACIQaiEUIAQgEGtBBGohCwNAIAQtAAAgEEH8z4CAAGotAABHDY4BIBBBBEYN6QEgEEEBaiEQIARBAWoiBCACRw0ACyAAIBQ2AgBB0gEhEAyVAgsgACAMIAIQrICAgAAiAQ2NASAMIQEMuAELAkAgBCACRw0AQdQBIRAMlAILIAIgBGsgACgCACIQaiEUIAQgEGtBAWohDANAIAQtAAAgEEGB0ICAAGotAABHDY8BIBBBAUYNjgEgEEEBaiEQIARBAWoiBCACRw0ACyAAIBQ2AgBB1AEhEAyTAgsCQCAEIAJHDQBB1gEhEAyTAgsgAiAEayAAKAIAIhBqIRQgBCAQa0ECaiELA0AgBC0AACAQQYPQgIAAai0AAEcNjgEgEEECRg2QASAQQQFqIRAgBEEBaiIEIAJHDQALIAAgFDYCAEHWASEQDJICCwJAIAQgAkcNAEHXASEQDJICCwJAAkAgBC0AAEG7f2oOEACPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BAY8BCyAEQQFqIQRBuwEhEAz5AQsgBEEBaiEEQbwBIRAM+AELAkAgBCACRw0AQdgBIRAMkQILIAQtAABByABHDYwBIARBAWohBAzEAQsCQCAEIAJGDQAgAEGQgICAADYCCCAAIAQ2AgRBvgEhEAz3AQtB2QEhEAyPAgsCQCAEIAJHDQBB2gEhEAyPAgsgBC0AAEHIAEYNwwEgAEEBOgAoDLkBCyAAQQI6AC8gACAEIAIQpoCAgAAiEA2NAUHCASEQDPQBCyAALQAoQX9qDgK3AbkBuAELA0ACQCAELQAAQXZqDgQAjgGOAQCOAQsgBEEBaiIEIAJHDQALQd0BIRAMiwILIABBADoALyAALQAtQQRxRQ2EAgsgAEEAOgAvIABBAToANCABIQEMjAELIBBBFUYN2gEgAEEANgIcIAAgATYCFCAAQaeOgIAANgIQIABBEjYCDEEAIRAMiAILAkAgACAQIAIQtICAgAAiBA0AIBAhAQyBAgsCQCAEQRVHDQAgAEEDNgIcIAAgEDYCFCAAQbCYgIAANgIQIABBFTYCDEEAIRAMiAILIABBADYCHCAAIBA2AhQgAEGnjoCAADYCECAAQRI2AgxBACEQDIcCCyAQQRVGDdYBIABBADYCHCAAIAE2AhQgAEHajYCAADYCECAAQRQ2AgxBACEQDIYCCyAAKAIEIRcgAEEANgIEIBAgEadqIhYhASAAIBcgECAWIBQbIhAQtYCAgAAiFEUNjQEgAEEHNgIcIAAgEDYCFCAAIBQ2AgxBACEQDIUCCyAAIAAvATBBgAFyOwEwIAEhAQtBKiEQDOoBCyAQQRVGDdEBIABBADYCHCAAIAE2AhQgAEGDjICAADYCECAAQRM2AgxBACEQDIICCyAQQRVGDc8BIABBADYCHCAAIAE2AhQgAEGaj4CAADYCECAAQSI2AgxBACEQDIECCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQt4CAgAAiEA0AIAFBAWohAQyNAQsgAEEMNgIcIAAgEDYCDCAAIAFBAWo2AhRBACEQDIACCyAQQRVGDcwBIABBADYCHCAAIAE2AhQgAEGaj4CAADYCECAAQSI2AgxBACEQDP8BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQt4CAgAAiEA0AIAFBAWohAQyMAQsgAEENNgIcIAAgEDYCDCAAIAFBAWo2AhRBACEQDP4BCyAQQRVGDckBIABBADYCHCAAIAE2AhQgAEHGjICAADYCECAAQSM2AgxBACEQDP0BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQuYCAgAAiEA0AIAFBAWohAQyLAQsgAEEONgIcIAAgEDYCDCAAIAFBAWo2AhRBACEQDPwBCyAAQQA2AhwgACABNgIUIABBwJWAgAA2AhAgAEECNgIMQQAhEAz7AQsgEEEVRg3FASAAQQA2AhwgACABNgIUIABBxoyAgAA2AhAgAEEjNgIMQQAhEAz6AQsgAEEQNgIcIAAgATYCFCAAIBA2AgxBACEQDPkBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQuYCAgAAiBA0AIAFBAWohAQzxAQsgAEERNgIcIAAgBDYCDCAAIAFBAWo2AhRBACEQDPgBCyAQQRVGDcEBIABBADYCHCAAIAE2AhQgAEHGjICAADYCECAAQSM2AgxBACEQDPcBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQuYCAgAAiEA0AIAFBAWohAQyIAQsgAEETNgIcIAAgEDYCDCAAIAFBAWo2AhRBACEQDPYBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQuYCAgAAiBA0AIAFBAWohAQztAQsgAEEUNgIcIAAgBDYCDCAAIAFBAWo2AhRBACEQDPUBCyAQQRVGDb0BIABBADYCHCAAIAE2AhQgAEGaj4CAADYCECAAQSI2AgxBACEQDPQBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQt4CAgAAiEA0AIAFBAWohAQyGAQsgAEEWNgIcIAAgEDYCDCAAIAFBAWo2AhRBACEQDPMBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQt4CAgAAiBA0AIAFBAWohAQzpAQsgAEEXNgIcIAAgBDYCDCAAIAFBAWo2AhRBACEQDPIBCyAAQQA2AhwgACABNgIUIABBzZOAgAA2AhAgAEEMNgIMQQAhEAzxAQtCASERCyAQQQFqIQECQCAAKQMgIhJC//////////8PVg0AIAAgEkIEhiARhDcDICABIQEMhAELIABBADYCHCAAIAE2AhQgAEGtiYCAADYCECAAQQw2AgxBACEQDO8BCyAAQQA2AhwgACAQNgIUIABBzZOAgAA2AhAgAEEMNgIMQQAhEAzuAQsgACgCBCEXIABBADYCBCAQIBGnaiIWIQEgACAXIBAgFiAUGyIQELWAgIAAIhRFDXMgAEEFNgIcIAAgEDYCFCAAIBQ2AgxBACEQDO0BCyAAQQA2AhwgACAQNgIUIABBqpyAgAA2AhAgAEEPNgIMQQAhEAzsAQsgACAQIAIQtICAgAAiAQ0BIBAhAQtBDiEQDNEBCwJAIAFBFUcNACAAQQI2AhwgACAQNgIUIABBsJiAgAA2AhAgAEEVNgIMQQAhEAzqAQsgAEEANgIcIAAgEDYCFCAAQaeOgIAANgIQIABBEjYCDEEAIRAM6QELIAFBAWohEAJAIAAvATAiAUGAAXFFDQACQCAAIBAgAhC7gICAACIBDQAgECEBDHALIAFBFUcNugEgAEEFNgIcIAAgEDYCFCAAQfmXgIAANgIQIABBFTYCDEEAIRAM6QELAkAgAUGgBHFBoARHDQAgAC0ALUECcQ0AIABBADYCHCAAIBA2AhQgAEGWk4CAADYCECAAQQQ2AgxBACEQDOkBCyAAIBAgAhC9gICAABogECEBAkACQAJAAkACQCAAIBAgAhCzgICAAA4WAgEABAQEBAQEBAQEBAQEBAQEBAQEAwQLIABBAToALgsgACAALwEwQcAAcjsBMCAQIQELQSYhEAzRAQsgAEEjNgIcIAAgEDYCFCAAQaWWgIAANgIQIABBFTYCDEEAIRAM6QELIABBADYCHCAAIBA2AhQgAEHVi4CAADYCECAAQRE2AgxBACEQDOgBCyAALQAtQQFxRQ0BQcMBIRAMzgELAkAgDSACRg0AA0ACQCANLQAAQSBGDQAgDSEBDMQBCyANQQFqIg0gAkcNAAtBJSEQDOcBC0ElIRAM5gELIAAoAgQhBCAAQQA2AgQgACAEIA0Qr4CAgAAiBEUNrQEgAEEmNgIcIAAgBDYCDCAAIA1BAWo2AhRBACEQDOUBCyAQQRVGDasBIABBADYCHCAAIAE2AhQgAEH9jYCAADYCECAAQR02AgxBACEQDOQBCyAAQSc2AhwgACABNgIUIAAgEDYCDEEAIRAM4wELIBAhAUEBIRQCQAJAAkACQAJAAkACQCAALQAsQX5qDgcGBQUDAQIABQsgACAALwEwQQhyOwEwDAMLQQIhFAwBC0EEIRQLIABBAToALCAAIAAvATAgFHI7ATALIBAhAQtBKyEQDMoBCyAAQQA2AhwgACAQNgIUIABBq5KAgAA2AhAgAEELNgIMQQAhEAziAQsgAEEANgIcIAAgATYCFCAAQeGPgIAANgIQIABBCjYCDEEAIRAM4QELIABBADoALCAQIQEMvQELIBAhAUEBIRQCQAJAAkACQAJAIAAtACxBe2oOBAMBAgAFCyAAIAAvATBBCHI7ATAMAwtBAiEUDAELQQQhFAsgAEEBOgAsIAAgAC8BMCAUcjsBMAsgECEBC0EpIRAMxQELIABBADYCHCAAIAE2AhQgAEHwlICAADYCECAAQQM2AgxBACEQDN0BCwJAIA4tAABBDUcNACAAKAIEIQEgAEEANgIEAkAgACABIA4QsYCAgAAiAQ0AIA5BAWohAQx1CyAAQSw2AhwgACABNgIMIAAgDkEBajYCFEEAIRAM3QELIAAtAC1BAXFFDQFBxAEhEAzDAQsCQCAOIAJHDQBBLSEQDNwBCwJAAkADQAJAIA4tAABBdmoOBAIAAAMACyAOQQFqIg4gAkcNAAtBLSEQDN0BCyAAKAIEIQEgAEEANgIEAkAgACABIA4QsYCAgAAiAQ0AIA4hAQx0CyAAQSw2AhwgACAONgIUIAAgATYCDEEAIRAM3AELIAAoAgQhASAAQQA2AgQCQCAAIAEgDhCxgICAACIBDQAgDkEBaiEBDHMLIABBLDYCHCAAIAE2AgwgACAOQQFqNgIUQQAhEAzbAQsgACgCBCEEIABBADYCBCAAIAQgDhCxgICAACIEDaABIA4hAQzOAQsgEEEsRw0BIAFBAWohEEEBIQECQAJAAkACQAJAIAAtACxBe2oOBAMBAgQACyAQIQEMBAtBAiEBDAELQQQhAQsgAEEBOgAsIAAgAC8BMCABcjsBMCAQIQEMAQsgACAALwEwQQhyOwEwIBAhAQtBOSEQDL8BCyAAQQA6ACwgASEBC0E0IRAMvQELIAAgAC8BMEEgcjsBMCABIQEMAgsgACgCBCEEIABBADYCBAJAIAAgBCABELGAgIAAIgQNACABIQEMxwELIABBNzYCHCAAIAE2AhQgACAENgIMQQAhEAzUAQsgAEEIOgAsIAEhAQtBMCEQDLkBCwJAIAAtAChBAUYNACABIQEMBAsgAC0ALUEIcUUNkwEgASEBDAMLIAAtADBBIHENlAFBxQEhEAy3AQsCQCAPIAJGDQACQANAAkAgDy0AAEFQaiIBQf8BcUEKSQ0AIA8hAUE1IRAMugELIAApAyAiEUKZs+bMmbPmzBlWDQEgACARQgp+IhE3AyAgESABrUL/AYMiEkJ/hVYNASAAIBEgEnw3AyAgD0EBaiIPIAJHDQALQTkhEAzRAQsgACgCBCECIABBADYCBCAAIAIgD0EBaiIEELGAgIAAIgINlQEgBCEBDMMBC0E5IRAMzwELAkAgAC8BMCIBQQhxRQ0AIAAtAChBAUcNACAALQAtQQhxRQ2QAQsgACABQff7A3FBgARyOwEwIA8hAQtBNyEQDLQBCyAAIAAvATBBEHI7ATAMqwELIBBBFUYNiwEgAEEANgIcIAAgATYCFCAAQfCOgIAANgIQIABBHDYCDEEAIRAMywELIABBwwA2AhwgACABNgIMIAAgDUEBajYCFEEAIRAMygELAkAgAS0AAEE6Rw0AIAAoAgQhECAAQQA2AgQCQCAAIBAgARCvgICAACIQDQAgAUEBaiEBDGMLIABBwwA2AhwgACAQNgIMIAAgAUEBajYCFEEAIRAMygELIABBADYCHCAAIAE2AhQgAEGxkYCAADYCECAAQQo2AgxBACEQDMkBCyAAQQA2AhwgACABNgIUIABBoJmAgAA2AhAgAEEeNgIMQQAhEAzIAQsgAEEANgIACyAAQYASOwEqIAAgF0EBaiIBIAIQqICAgAAiEA0BIAEhAQtBxwAhEAysAQsgEEEVRw2DASAAQdEANgIcIAAgATYCFCAAQeOXgIAANgIQIABBFTYCDEEAIRAMxAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDF4LIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMwwELIABBADYCHCAAIBQ2AhQgAEHBqICAADYCECAAQQc2AgwgAEEANgIAQQAhEAzCAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMXQsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAzBAQtBACEQIABBADYCHCAAIAE2AhQgAEGAkYCAADYCECAAQQk2AgwMwAELIBBBFUYNfSAAQQA2AhwgACABNgIUIABBlI2AgAA2AhAgAEEhNgIMQQAhEAy/AQtBASEWQQAhF0EAIRRBASEQCyAAIBA6ACsgAUEBaiEBAkACQCAALQAtQRBxDQACQAJAAkAgAC0AKg4DAQACBAsgFkUNAwwCCyAUDQEMAgsgF0UNAQsgACgCBCEQIABBADYCBAJAIAAgECABEK2AgIAAIhANACABIQEMXAsgAEHYADYCHCAAIAE2AhQgACAQNgIMQQAhEAy+AQsgACgCBCEEIABBADYCBAJAIAAgBCABEK2AgIAAIgQNACABIQEMrQELIABB2QA2AhwgACABNgIUIAAgBDYCDEEAIRAMvQELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARCtgICAACIEDQAgASEBDKsBCyAAQdoANgIcIAAgATYCFCAAIAQ2AgxBACEQDLwBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQrYCAgAAiBA0AIAEhAQypAQsgAEHcADYCHCAAIAE2AhQgACAENgIMQQAhEAy7AQsCQCABLQAAQVBqIhBB/wFxQQpPDQAgACAQOgAqIAFBAWohAUHPACEQDKIBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQrYCAgAAiBA0AIAEhAQynAQsgAEHeADYCHCAAIAE2AhQgACAENgIMQQAhEAy6AQsgAEEANgIAIBdBAWohAQJAIAAtAClBI08NACABIQEMWQsgAEEANgIcIAAgATYCFCAAQdOJgIAANgIQIABBCDYCDEEAIRAMuQELIABBADYCAAtBACEQIABBADYCHCAAIAE2AhQgAEGQs4CAADYCECAAQQg2AgwMtwELIABBADYCACAXQQFqIQECQCAALQApQSFHDQAgASEBDFYLIABBADYCHCAAIAE2AhQgAEGbioCAADYCECAAQQg2AgxBACEQDLYBCyAAQQA2AgAgF0EBaiEBAkAgAC0AKSIQQV1qQQtPDQAgASEBDFULAkAgEEEGSw0AQQEgEHRBygBxRQ0AIAEhAQxVC0EAIRAgAEEANgIcIAAgATYCFCAAQfeJgIAANgIQIABBCDYCDAy1AQsgEEEVRg1xIABBADYCHCAAIAE2AhQgAEG5jYCAADYCECAAQRo2AgxBACEQDLQBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxUCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDLMBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQdIANgIcIAAgATYCFCAAIBA2AgxBACEQDLIBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDLEBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxRCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDLABCyAAQQA2AhwgACABNgIUIABBxoqAgAA2AhAgAEEHNgIMQQAhEAyvAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAyuAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAytAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMTQsgAEHlADYCHCAAIAE2AhQgACAQNgIMQQAhEAysAQsgAEEANgIcIAAgATYCFCAAQdyIgIAANgIQIABBBzYCDEEAIRAMqwELIBBBP0cNASABQQFqIQELQQUhEAyQAQtBACEQIABBADYCHCAAIAE2AhQgAEH9koCAADYCECAAQQc2AgwMqAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMpwELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0wA2AhwgACABNgIUIAAgEDYCDEEAIRAMpgELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEYLIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMpQELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0gA2AhwgACAUNgIUIAAgATYCDEEAIRAMpAELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0wA2AhwgACAUNgIUIAAgATYCDEEAIRAMowELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDEMLIABB5QA2AhwgACAUNgIUIAAgATYCDEEAIRAMogELIABBADYCHCAAIBQ2AhQgAEHDj4CAADYCECAAQQc2AgxBACEQDKEBCyAAQQA2AhwgACABNgIUIABBw4+AgAA2AhAgAEEHNgIMQQAhEAygAQtBACEQIABBADYCHCAAIBQ2AhQgAEGMnICAADYCECAAQQc2AgwMnwELIABBADYCHCAAIBQ2AhQgAEGMnICAADYCECAAQQc2AgxBACEQDJ4BCyAAQQA2AhwgACAUNgIUIABB/pGAgAA2AhAgAEEHNgIMQQAhEAydAQsgAEEANgIcIAAgATYCFCAAQY6bgIAANgIQIABBBjYCDEEAIRAMnAELIBBBFUYNVyAAQQA2AhwgACABNgIUIABBzI6AgAA2AhAgAEEgNgIMQQAhEAybAQsgAEEANgIAIBBBAWohAUEkIRALIAAgEDoAKSAAKAIEIRAgAEEANgIEIAAgECABEKuAgIAAIhANVCABIQEMPgsgAEEANgIAC0EAIRAgAEEANgIcIAAgBDYCFCAAQfGbgIAANgIQIABBBjYCDAyXAQsgAUEVRg1QIABBADYCHCAAIAU2AhQgAEHwjICAADYCECAAQRs2AgxBACEQDJYBCyAAKAIEIQUgAEEANgIEIAAgBSAQEKmAgIAAIgUNASAQQQFqIQULQa0BIRAMewsgAEHBATYCHCAAIAU2AgwgACAQQQFqNgIUQQAhEAyTAQsgACgCBCEGIABBADYCBCAAIAYgEBCpgICAACIGDQEgEEEBaiEGC0GuASEQDHgLIABBwgE2AhwgACAGNgIMIAAgEEEBajYCFEEAIRAMkAELIABBADYCHCAAIAc2AhQgAEGXi4CAADYCECAAQQ02AgxBACEQDI8BCyAAQQA2AhwgACAINgIUIABB45CAgAA2AhAgAEEJNgIMQQAhEAyOAQsgAEEANgIcIAAgCDYCFCAAQZSNgIAANgIQIABBITYCDEEAIRAMjQELQQEhFkEAIRdBACEUQQEhEAsgACAQOgArIAlBAWohCAJAAkAgAC0ALUEQcQ0AAkACQAJAIAAtACoOAwEAAgQLIBZFDQMMAgsgFA0BDAILIBdFDQELIAAoAgQhECAAQQA2AgQgACAQIAgQrYCAgAAiEEUNPSAAQckBNgIcIAAgCDYCFCAAIBA2AgxBACEQDIwBCyAAKAIEIQQgAEEANgIEIAAgBCAIEK2AgIAAIgRFDXYgAEHKATYCHCAAIAg2AhQgACAENgIMQQAhEAyLAQsgACgCBCEEIABBADYCBCAAIAQgCRCtgICAACIERQ10IABBywE2AhwgACAJNgIUIAAgBDYCDEEAIRAMigELIAAoAgQhBCAAQQA2AgQgACAEIAoQrYCAgAAiBEUNciAAQc0BNgIcIAAgCjYCFCAAIAQ2AgxBACEQDIkBCwJAIAstAABBUGoiEEH/AXFBCk8NACAAIBA6ACogC0EBaiEKQbYBIRAMcAsgACgCBCEEIABBADYCBCAAIAQgCxCtgICAACIERQ1wIABBzwE2AhwgACALNgIUIAAgBDYCDEEAIRAMiAELIABBADYCHCAAIAQ2AhQgAEGQs4CAADYCECAAQQg2AgwgAEEANgIAQQAhEAyHAQsgAUEVRg0/IABBADYCHCAAIAw2AhQgAEHMjoCAADYCECAAQSA2AgxBACEQDIYBCyAAQYEEOwEoIAAoAgQhECAAQgA3AwAgACAQIAxBAWoiDBCrgICAACIQRQ04IABB0wE2AhwgACAMNgIUIAAgEDYCDEEAIRAMhQELIABBADYCAAtBACEQIABBADYCHCAAIAQ2AhQgAEHYm4CAADYCECAAQQg2AgwMgwELIAAoAgQhECAAQgA3AwAgACAQIAtBAWoiCxCrgICAACIQDQFBxgEhEAxpCyAAQQI6ACgMVQsgAEHVATYCHCAAIAs2AhQgACAQNgIMQQAhEAyAAQsgEEEVRg03IABBADYCHCAAIAQ2AhQgAEGkjICAADYCECAAQRA2AgxBACEQDH8LIAAtADRBAUcNNCAAIAQgAhC8gICAACIQRQ00IBBBFUcNNSAAQdwBNgIcIAAgBDYCFCAAQdWWgIAANgIQIABBFTYCDEEAIRAMfgtBACEQIABBADYCHCAAQa+LgIAANgIQIABBAjYCDCAAIBRBAWo2AhQMfQtBACEQDGMLQQIhEAxiC0ENIRAMYQtBDyEQDGALQSUhEAxfC0ETIRAMXgtBFSEQDF0LQRYhEAxcC0EXIRAMWwtBGCEQDFoLQRkhEAxZC0EaIRAMWAtBGyEQDFcLQRwhEAxWC0EdIRAMVQtBHyEQDFQLQSEhEAxTC0EjIRAMUgtBxgAhEAxRC0EuIRAMUAtBLyEQDE8LQTshEAxOC0E9IRAMTQtByAAhEAxMC0HJACEQDEsLQcsAIRAMSgtBzAAhEAxJC0HOACEQDEgLQdEAIRAMRwtB1QAhEAxGC0HYACEQDEULQdkAIRAMRAtB2wAhEAxDC0HkACEQDEILQeUAIRAMQQtB8QAhEAxAC0H0ACEQDD8LQY0BIRAMPgtBlwEhEAw9C0GpASEQDDwLQawBIRAMOwtBwAEhEAw6C0G5ASEQDDkLQa8BIRAMOAtBsQEhEAw3C0GyASEQDDYLQbQBIRAMNQtBtQEhEAw0C0G6ASEQDDMLQb0BIRAMMgtBvwEhEAwxC0HBASEQDDALIABBADYCHCAAIAQ2AhQgAEHpi4CAADYCECAAQR82AgxBACEQDEgLIABB2wE2AhwgACAENgIUIABB+paAgAA2AhAgAEEVNgIMQQAhEAxHCyAAQfgANgIcIAAgDDYCFCAAQcqYgIAANgIQIABBFTYCDEEAIRAMRgsgAEHRADYCHCAAIAU2AhQgAEGwl4CAADYCECAAQRU2AgxBACEQDEULIABB+QA2AhwgACABNgIUIAAgEDYCDEEAIRAMRAsgAEH4ADYCHCAAIAE2AhQgAEHKmICAADYCECAAQRU2AgxBACEQDEMLIABB5AA2AhwgACABNgIUIABB45eAgAA2AhAgAEEVNgIMQQAhEAxCCyAAQdcANgIcIAAgATYCFCAAQcmXgIAANgIQIABBFTYCDEEAIRAMQQsgAEEANgIcIAAgATYCFCAAQbmNgIAANgIQIABBGjYCDEEAIRAMQAsgAEHCADYCHCAAIAE2AhQgAEHjmICAADYCECAAQRU2AgxBACEQDD8LIABBADYCBCAAIA8gDxCxgICAACIERQ0BIABBOjYCHCAAIAQ2AgwgACAPQQFqNgIUQQAhEAw+CyAAKAIEIQQgAEEANgIEAkAgACAEIAEQsYCAgAAiBEUNACAAQTs2AhwgACAENgIMIAAgAUEBajYCFEEAIRAMPgsgAUEBaiEBDC0LIA9BAWohAQwtCyAAQQA2AhwgACAPNgIUIABB5JKAgAA2AhAgAEEENgIMQQAhEAw7CyAAQTY2AhwgACAENgIUIAAgAjYCDEEAIRAMOgsgAEEuNgIcIAAgDjYCFCAAIAQ2AgxBACEQDDkLIABB0AA2AhwgACABNgIUIABBkZiAgAA2AhAgAEEVNgIMQQAhEAw4CyANQQFqIQEMLAsgAEEVNgIcIAAgATYCFCAAQYKZgIAANgIQIABBFTYCDEEAIRAMNgsgAEEbNgIcIAAgATYCFCAAQZGXgIAANgIQIABBFTYCDEEAIRAMNQsgAEEPNgIcIAAgATYCFCAAQZGXgIAANgIQIABBFTYCDEEAIRAMNAsgAEELNgIcIAAgATYCFCAAQZGXgIAANgIQIABBFTYCDEEAIRAMMwsgAEEaNgIcIAAgATYCFCAAQYKZgIAANgIQIABBFTYCDEEAIRAMMgsgAEELNgIcIAAgATYCFCAAQYKZgIAANgIQIABBFTYCDEEAIRAMMQsgAEEKNgIcIAAgATYCFCAAQeSWgIAANgIQIABBFTYCDEEAIRAMMAsgAEEeNgIcIAAgATYCFCAAQfmXgIAANgIQIABBFTYCDEEAIRAMLwsgAEEANgIcIAAgEDYCFCAAQdqNgIAANgIQIABBFDYCDEEAIRAMLgsgAEEENgIcIAAgATYCFCAAQbCYgIAANgIQIABBFTYCDEEAIRAMLQsgAEEANgIAIAtBAWohCwtBuAEhEAwSCyAAQQA2AgAgEEEBaiEBQfUAIRAMEQsgASEBAkAgAC0AKUEFRw0AQeMAIRAMEQtB4gAhEAwQC0EAIRAgAEEANgIcIABB5JGAgAA2AhAgAEEHNgIMIAAgFEEBajYCFAwoCyAAQQA2AgAgF0EBaiEBQcAAIRAMDgtBASEBCyAAIAE6ACwgAEEANgIAIBdBAWohAQtBKCEQDAsLIAEhAQtBOCEQDAkLAkAgASIPIAJGDQADQAJAIA8tAABBgL6AgABqLQAAIgFBAUYNACABQQJHDQMgD0EBaiEBDAQLIA9BAWoiDyACRw0AC0E+IRAMIgtBPiEQDCELIABBADoALCAPIQEMAQtBCyEQDAYLQTohEAwFCyABQQFqIQFBLSEQDAQLIAAgAToALCAAQQA2AgAgFkEBaiEBQQwhEAwDCyAAQQA2AgAgF0EBaiEBQQohEAwCCyAAQQA2AgALIABBADoALCANIQFBCSEQDAALC0EAIRAgAEEANgIcIAAgCzYCFCAAQc2QgIAANgIQIABBCTYCDAwXC0EAIRAgAEEANgIcIAAgCjYCFCAAQemKgIAANgIQIABBCTYCDAwWC0EAIRAgAEEANgIcIAAgCTYCFCAAQbeQgIAANgIQIABBCTYCDAwVC0EAIRAgAEEANgIcIAAgCDYCFCAAQZyRgIAANgIQIABBCTYCDAwUC0EAIRAgAEEANgIcIAAgATYCFCAAQc2QgIAANgIQIABBCTYCDAwTC0EAIRAgAEEANgIcIAAgATYCFCAAQemKgIAANgIQIABBCTYCDAwSC0EAIRAgAEEANgIcIAAgATYCFCAAQbeQgIAANgIQIABBCTYCDAwRC0EAIRAgAEEANgIcIAAgATYCFCAAQZyRgIAANgIQIABBCTYCDAwQC0EAIRAgAEEANgIcIAAgATYCFCAAQZeVgIAANgIQIABBDzYCDAwPC0EAIRAgAEEANgIcIAAgATYCFCAAQZeVgIAANgIQIABBDzYCDAwOC0EAIRAgAEEANgIcIAAgATYCFCAAQcCSgIAANgIQIABBCzYCDAwNC0EAIRAgAEEANgIcIAAgATYCFCAAQZWJgIAANgIQIABBCzYCDAwMC0EAIRAgAEEANgIcIAAgATYCFCAAQeGPgIAANgIQIABBCjYCDAwLC0EAIRAgAEEANgIcIAAgATYCFCAAQfuPgIAANgIQIABBCjYCDAwKC0EAIRAgAEEANgIcIAAgATYCFCAAQfGZgIAANgIQIABBAjYCDAwJC0EAIRAgAEEANgIcIAAgATYCFCAAQcSUgIAANgIQIABBAjYCDAwIC0EAIRAgAEEANgIcIAAgATYCFCAAQfKVgIAANgIQIABBAjYCDAwHCyAAQQI2AhwgACABNgIUIABBnJqAgAA2AhAgAEEWNgIMQQAhEAwGC0EBIRAMBQtB1AAhECABIgQgAkYNBCADQQhqIAAgBCACQdjCgIAAQQoQxYCAgAAgAygCDCEEIAMoAggOAwEEAgALEMqAgIAAAAsgAEEANgIcIABBtZqAgAA2AhAgAEEXNgIMIAAgBEEBajYCFEEAIRAMAgsgAEEANgIcIAAgBDYCFCAAQcqagIAANgIQIABBCTYCDEEAIRAMAQsCQCABIgQgAkcNAEEiIRAMAQsgAEGJgICAADYCCCAAIAQ2AgRBISEQCyADQRBqJICAgIAAIBALrwEBAn8gASgCACEGAkACQCACIANGDQAgBCAGaiEEIAYgA2ogAmshByACIAZBf3MgBWoiBmohBQNAAkAgAi0AACAELQAARg0AQQIhBAwDCwJAIAYNAEEAIQQgBSECDAMLIAZBf2ohBiAEQQFqIQQgAkEBaiICIANHDQALIAchBiADIQILIABBATYCACABIAY2AgAgACACNgIEDwsgAUEANgIAIAAgBDYCACAAIAI2AgQLCgAgABDHgICAAAvyNgELfyOAgICAAEEQayIBJICAgIAAAkBBACgCoNCAgAANAEEAEMuAgIAAQYDUhIAAayICQdkASQ0AQQAhAwJAQQAoAuDTgIAAIgQNAEEAQn83AuzTgIAAQQBCgICEgICAwAA3AuTTgIAAQQAgAUEIakFwcUHYqtWqBXMiBDYC4NOAgABBAEEANgL004CAAEEAQQA2AsTTgIAAC0EAIAI2AszTgIAAQQBBgNSEgAA2AsjTgIAAQQBBgNSEgAA2ApjQgIAAQQAgBDYCrNCAgABBAEF/NgKo0ICAAANAIANBxNCAgABqIANBuNCAgABqIgQ2AgAgBCADQbDQgIAAaiIFNgIAIANBvNCAgABqIAU2AgAgA0HM0ICAAGogA0HA0ICAAGoiBTYCACAFIAQ2AgAgA0HU0ICAAGogA0HI0ICAAGoiBDYCACAEIAU2AgAgA0HQ0ICAAGogBDYCACADQSBqIgNBgAJHDQALQYDUhIAAQXhBgNSEgABrQQ9xQQBBgNSEgABBCGpBD3EbIgNqIgRBBGogAkFIaiIFIANrIgNBAXI2AgBBAEEAKALw04CAADYCpNCAgABBACADNgKU0ICAAEEAIAQ2AqDQgIAAQYDUhIAAIAVqQTg2AgQLAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB7AFLDQACQEEAKAKI0ICAACIGQRAgAEETakFwcSAAQQtJGyICQQN2IgR2IgNBA3FFDQACQAJAIANBAXEgBHJBAXMiBUEDdCIEQbDQgIAAaiIDIARBuNCAgABqKAIAIgQoAggiAkcNAEEAIAZBfiAFd3E2AojQgIAADAELIAMgAjYCCCACIAM2AgwLIARBCGohAyAEIAVBA3QiBUEDcjYCBCAEIAVqIgQgBCgCBEEBcjYCBAwMCyACQQAoApDQgIAAIgdNDQECQCADRQ0AAkACQCADIAR0QQIgBHQiA0EAIANrcnEiA0EAIANrcUF/aiIDIANBDHZBEHEiA3YiBEEFdkEIcSIFIANyIAQgBXYiA0ECdkEEcSIEciADIAR2IgNBAXZBAnEiBHIgAyAEdiIDQQF2QQFxIgRyIAMgBHZqIgRBA3QiA0Gw0ICAAGoiBSADQbjQgIAAaigCACIDKAIIIgBHDQBBACAGQX4gBHdxIgY2AojQgIAADAELIAUgADYCCCAAIAU2AgwLIAMgAkEDcjYCBCADIARBA3QiBGogBCACayIFNgIAIAMgAmoiACAFQQFyNgIEAkAgB0UNACAHQXhxQbDQgIAAaiECQQAoApzQgIAAIQQCQAJAIAZBASAHQQN2dCIIcQ0AQQAgBiAIcjYCiNCAgAAgAiEIDAELIAIoAgghCAsgCCAENgIMIAIgBDYCCCAEIAI2AgwgBCAINgIICyADQQhqIQNBACAANgKc0ICAAEEAIAU2ApDQgIAADAwLQQAoAozQgIAAIglFDQEgCUEAIAlrcUF/aiIDIANBDHZBEHEiA3YiBEEFdkEIcSIFIANyIAQgBXYiA0ECdkEEcSIEciADIAR2IgNBAXZBAnEiBHIgAyAEdiIDQQF2QQFxIgRyIAMgBHZqQQJ0QbjSgIAAaigCACIAKAIEQXhxIAJrIQQgACEFAkADQAJAIAUoAhAiAw0AIAVBFGooAgAiA0UNAgsgAygCBEF4cSACayIFIAQgBSAESSIFGyEEIAMgACAFGyEAIAMhBQwACwsgACgCGCEKAkAgACgCDCIIIABGDQAgACgCCCIDQQAoApjQgIAASRogCCADNgIIIAMgCDYCDAwLCwJAIABBFGoiBSgCACIDDQAgACgCECIDRQ0DIABBEGohBQsDQCAFIQsgAyIIQRRqIgUoAgAiAw0AIAhBEGohBSAIKAIQIgMNAAsgC0EANgIADAoLQX8hAiAAQb9/Sw0AIABBE2oiA0FwcSECQQAoAozQgIAAIgdFDQBBACELAkAgAkGAAkkNAEEfIQsgAkH///8HSw0AIANBCHYiAyADQYD+P2pBEHZBCHEiA3QiBCAEQYDgH2pBEHZBBHEiBHQiBSAFQYCAD2pBEHZBAnEiBXRBD3YgAyAEciAFcmsiA0EBdCACIANBFWp2QQFxckEcaiELC0EAIAJrIQQCQAJAAkACQCALQQJ0QbjSgIAAaigCACIFDQBBACEDQQAhCAwBC0EAIQMgAkEAQRkgC0EBdmsgC0EfRht0IQBBACEIA0ACQCAFKAIEQXhxIAJrIgYgBE8NACAGIQQgBSEIIAYNAEEAIQQgBSEIIAUhAwwDCyADIAVBFGooAgAiBiAGIAUgAEEddkEEcWpBEGooAgAiBUYbIAMgBhshAyAAQQF0IQAgBQ0ACwsCQCADIAhyDQBBACEIQQIgC3QiA0EAIANrciAHcSIDRQ0DIANBACADa3FBf2oiAyADQQx2QRBxIgN2IgVBBXZBCHEiACADciAFIAB2IgNBAnZBBHEiBXIgAyAFdiIDQQF2QQJxIgVyIAMgBXYiA0EBdkEBcSIFciADIAV2akECdEG40oCAAGooAgAhAwsgA0UNAQsDQCADKAIEQXhxIAJrIgYgBEkhAAJAIAMoAhAiBQ0AIANBFGooAgAhBQsgBiAEIAAbIQQgAyAIIAAbIQggBSEDIAUNAAsLIAhFDQAgBEEAKAKQ0ICAACACa08NACAIKAIYIQsCQCAIKAIMIgAgCEYNACAIKAIIIgNBACgCmNCAgABJGiAAIAM2AgggAyAANgIMDAkLAkAgCEEUaiIFKAIAIgMNACAIKAIQIgNFDQMgCEEQaiEFCwNAIAUhBiADIgBBFGoiBSgCACIDDQAgAEEQaiEFIAAoAhAiAw0ACyAGQQA2AgAMCAsCQEEAKAKQ0ICAACIDIAJJDQBBACgCnNCAgAAhBAJAAkAgAyACayIFQRBJDQAgBCACaiIAIAVBAXI2AgRBACAFNgKQ0ICAAEEAIAA2ApzQgIAAIAQgA2ogBTYCACAEIAJBA3I2AgQMAQsgBCADQQNyNgIEIAQgA2oiAyADKAIEQQFyNgIEQQBBADYCnNCAgABBAEEANgKQ0ICAAAsgBEEIaiEDDAoLAkBBACgClNCAgAAiACACTQ0AQQAoAqDQgIAAIgMgAmoiBCAAIAJrIgVBAXI2AgRBACAFNgKU0ICAAEEAIAQ2AqDQgIAAIAMgAkEDcjYCBCADQQhqIQMMCgsCQAJAQQAoAuDTgIAARQ0AQQAoAujTgIAAIQQMAQtBAEJ/NwLs04CAAEEAQoCAhICAgMAANwLk04CAAEEAIAFBDGpBcHFB2KrVqgVzNgLg04CAAEEAQQA2AvTTgIAAQQBBADYCxNOAgABBgIAEIQQLQQAhAwJAIAQgAkHHAGoiB2oiBkEAIARrIgtxIgggAksNAEEAQTA2AvjTgIAADAoLAkBBACgCwNOAgAAiA0UNAAJAQQAoArjTgIAAIgQgCGoiBSAETQ0AIAUgA00NAQtBACEDQQBBMDYC+NOAgAAMCgtBAC0AxNOAgABBBHENBAJAAkACQEEAKAKg0ICAACIERQ0AQcjTgIAAIQMDQAJAIAMoAgAiBSAESw0AIAUgAygCBGogBEsNAwsgAygCCCIDDQALC0EAEMuAgIAAIgBBf0YNBSAIIQYCQEEAKALk04CAACIDQX9qIgQgAHFFDQAgCCAAayAEIABqQQAgA2txaiEGCyAGIAJNDQUgBkH+////B0sNBQJAQQAoAsDTgIAAIgNFDQBBACgCuNOAgAAiBCAGaiIFIARNDQYgBSADSw0GCyAGEMuAgIAAIgMgAEcNAQwHCyAGIABrIAtxIgZB/v///wdLDQQgBhDLgICAACIAIAMoAgAgAygCBGpGDQMgACEDCwJAIANBf0YNACACQcgAaiAGTQ0AAkAgByAGa0EAKALo04CAACIEakEAIARrcSIEQf7///8HTQ0AIAMhAAwHCwJAIAQQy4CAgABBf0YNACAEIAZqIQYgAyEADAcLQQAgBmsQy4CAgAAaDAQLIAMhACADQX9HDQUMAwtBACEIDAcLQQAhAAwFCyAAQX9HDQILQQBBACgCxNOAgABBBHI2AsTTgIAACyAIQf7///8HSw0BIAgQy4CAgAAhAEEAEMuAgIAAIQMgAEF/Rg0BIANBf0YNASAAIANPDQEgAyAAayIGIAJBOGpNDQELQQBBACgCuNOAgAAgBmoiAzYCuNOAgAACQCADQQAoArzTgIAATQ0AQQAgAzYCvNOAgAALAkACQAJAAkBBACgCoNCAgAAiBEUNAEHI04CAACEDA0AgACADKAIAIgUgAygCBCIIakYNAiADKAIIIgMNAAwDCwsCQAJAQQAoApjQgIAAIgNFDQAgACADTw0BC0EAIAA2ApjQgIAAC0EAIQNBACAGNgLM04CAAEEAIAA2AsjTgIAAQQBBfzYCqNCAgABBAEEAKALg04CAADYCrNCAgABBAEEANgLU04CAAANAIANBxNCAgABqIANBuNCAgABqIgQ2AgAgBCADQbDQgIAAaiIFNgIAIANBvNCAgABqIAU2AgAgA0HM0ICAAGogA0HA0ICAAGoiBTYCACAFIAQ2AgAgA0HU0ICAAGogA0HI0ICAAGoiBDYCACAEIAU2AgAgA0HQ0ICAAGogBDYCACADQSBqIgNBgAJHDQALIABBeCAAa0EPcUEAIABBCGpBD3EbIgNqIgQgBkFIaiIFIANrIgNBAXI2AgRBAEEAKALw04CAADYCpNCAgABBACADNgKU0ICAAEEAIAQ2AqDQgIAAIAAgBWpBODYCBAwCCyADLQAMQQhxDQAgBCAFSQ0AIAQgAE8NACAEQXggBGtBD3FBACAEQQhqQQ9xGyIFaiIAQQAoApTQgIAAIAZqIgsgBWsiBUEBcjYCBCADIAggBmo2AgRBAEEAKALw04CAADYCpNCAgABBACAFNgKU0ICAAEEAIAA2AqDQgIAAIAQgC2pBODYCBAwBCwJAIABBACgCmNCAgAAiCE8NAEEAIAA2ApjQgIAAIAAhCAsgACAGaiEFQcjTgIAAIQMCQAJAAkACQAJAAkACQANAIAMoAgAgBUYNASADKAIIIgMNAAwCCwsgAy0ADEEIcUUNAQtByNOAgAAhAwNAAkAgAygCACIFIARLDQAgBSADKAIEaiIFIARLDQMLIAMoAgghAwwACwsgAyAANgIAIAMgAygCBCAGajYCBCAAQXggAGtBD3FBACAAQQhqQQ9xG2oiCyACQQNyNgIEIAVBeCAFa0EPcUEAIAVBCGpBD3EbaiIGIAsgAmoiAmshAwJAIAYgBEcNAEEAIAI2AqDQgIAAQQBBACgClNCAgAAgA2oiAzYClNCAgAAgAiADQQFyNgIEDAMLAkAgBkEAKAKc0ICAAEcNAEEAIAI2ApzQgIAAQQBBACgCkNCAgAAgA2oiAzYCkNCAgAAgAiADQQFyNgIEIAIgA2ogAzYCAAwDCwJAIAYoAgQiBEEDcUEBRw0AIARBeHEhBwJAAkAgBEH/AUsNACAGKAIIIgUgBEEDdiIIQQN0QbDQgIAAaiIARhoCQCAGKAIMIgQgBUcNAEEAQQAoAojQgIAAQX4gCHdxNgKI0ICAAAwCCyAEIABGGiAEIAU2AgggBSAENgIMDAELIAYoAhghCQJAAkAgBigCDCIAIAZGDQAgBigCCCIEIAhJGiAAIAQ2AgggBCAANgIMDAELAkAgBkEUaiIEKAIAIgUNACAGQRBqIgQoAgAiBQ0AQQAhAAwBCwNAIAQhCCAFIgBBFGoiBCgCACIFDQAgAEEQaiEEIAAoAhAiBQ0ACyAIQQA2AgALIAlFDQACQAJAIAYgBigCHCIFQQJ0QbjSgIAAaiIEKAIARw0AIAQgADYCACAADQFBAEEAKAKM0ICAAEF+IAV3cTYCjNCAgAAMAgsgCUEQQRQgCSgCECAGRhtqIAA2AgAgAEUNAQsgACAJNgIYAkAgBigCECIERQ0AIAAgBDYCECAEIAA2AhgLIAYoAhQiBEUNACAAQRRqIAQ2AgAgBCAANgIYCyAHIANqIQMgBiAHaiIGKAIEIQQLIAYgBEF+cTYCBCACIANqIAM2AgAgAiADQQFyNgIEAkAgA0H/AUsNACADQXhxQbDQgIAAaiEEAkACQEEAKAKI0ICAACIFQQEgA0EDdnQiA3ENAEEAIAUgA3I2AojQgIAAIAQhAwwBCyAEKAIIIQMLIAMgAjYCDCAEIAI2AgggAiAENgIMIAIgAzYCCAwDC0EfIQQCQCADQf///wdLDQAgA0EIdiIEIARBgP4/akEQdkEIcSIEdCIFIAVBgOAfakEQdkEEcSIFdCIAIABBgIAPakEQdkECcSIAdEEPdiAEIAVyIAByayIEQQF0IAMgBEEVanZBAXFyQRxqIQQLIAIgBDYCHCACQgA3AhAgBEECdEG40oCAAGohBQJAQQAoAozQgIAAIgBBASAEdCIIcQ0AIAUgAjYCAEEAIAAgCHI2AozQgIAAIAIgBTYCGCACIAI2AgggAiACNgIMDAMLIANBAEEZIARBAXZrIARBH0YbdCEEIAUoAgAhAANAIAAiBSgCBEF4cSADRg0CIARBHXYhACAEQQF0IQQgBSAAQQRxakEQaiIIKAIAIgANAAsgCCACNgIAIAIgBTYCGCACIAI2AgwgAiACNgIIDAILIABBeCAAa0EPcUEAIABBCGpBD3EbIgNqIgsgBkFIaiIIIANrIgNBAXI2AgQgACAIakE4NgIEIAQgBUE3IAVrQQ9xQQAgBUFJakEPcRtqQUFqIgggCCAEQRBqSRsiCEEjNgIEQQBBACgC8NOAgAA2AqTQgIAAQQAgAzYClNCAgABBACALNgKg0ICAACAIQRBqQQApAtDTgIAANwIAIAhBACkCyNOAgAA3AghBACAIQQhqNgLQ04CAAEEAIAY2AszTgIAAQQAgADYCyNOAgABBAEEANgLU04CAACAIQSRqIQMDQCADQQc2AgAgA0EEaiIDIAVJDQALIAggBEYNAyAIIAgoAgRBfnE2AgQgCCAIIARrIgA2AgAgBCAAQQFyNgIEAkAgAEH/AUsNACAAQXhxQbDQgIAAaiEDAkACQEEAKAKI0ICAACIFQQEgAEEDdnQiAHENAEEAIAUgAHI2AojQgIAAIAMhBQwBCyADKAIIIQULIAUgBDYCDCADIAQ2AgggBCADNgIMIAQgBTYCCAwEC0EfIQMCQCAAQf///wdLDQAgAEEIdiIDIANBgP4/akEQdkEIcSIDdCIFIAVBgOAfakEQdkEEcSIFdCIIIAhBgIAPakEQdkECcSIIdEEPdiADIAVyIAhyayIDQQF0IAAgA0EVanZBAXFyQRxqIQMLIAQgAzYCHCAEQgA3AhAgA0ECdEG40oCAAGohBQJAQQAoAozQgIAAIghBASADdCIGcQ0AIAUgBDYCAEEAIAggBnI2AozQgIAAIAQgBTYCGCAEIAQ2AgggBCAENgIMDAQLIABBAEEZIANBAXZrIANBH0YbdCEDIAUoAgAhCANAIAgiBSgCBEF4cSAARg0DIANBHXYhCCADQQF0IQMgBSAIQQRxakEQaiIGKAIAIggNAAsgBiAENgIAIAQgBTYCGCAEIAQ2AgwgBCAENgIIDAMLIAUoAggiAyACNgIMIAUgAjYCCCACQQA2AhggAiAFNgIMIAIgAzYCCAsgC0EIaiEDDAULIAUoAggiAyAENgIMIAUgBDYCCCAEQQA2AhggBCAFNgIMIAQgAzYCCAtBACgClNCAgAAiAyACTQ0AQQAoAqDQgIAAIgQgAmoiBSADIAJrIgNBAXI2AgRBACADNgKU0ICAAEEAIAU2AqDQgIAAIAQgAkEDcjYCBCAEQQhqIQMMAwtBACEDQQBBMDYC+NOAgAAMAgsCQCALRQ0AAkACQCAIIAgoAhwiBUECdEG40oCAAGoiAygCAEcNACADIAA2AgAgAA0BQQAgB0F+IAV3cSIHNgKM0ICAAAwCCyALQRBBFCALKAIQIAhGG2ogADYCACAARQ0BCyAAIAs2AhgCQCAIKAIQIgNFDQAgACADNgIQIAMgADYCGAsgCEEUaigCACIDRQ0AIABBFGogAzYCACADIAA2AhgLAkACQCAEQQ9LDQAgCCAEIAJqIgNBA3I2AgQgCCADaiIDIAMoAgRBAXI2AgQMAQsgCCACaiIAIARBAXI2AgQgCCACQQNyNgIEIAAgBGogBDYCAAJAIARB/wFLDQAgBEF4cUGw0ICAAGohAwJAAkBBACgCiNCAgAAiBUEBIARBA3Z0IgRxDQBBACAFIARyNgKI0ICAACADIQQMAQsgAygCCCEECyAEIAA2AgwgAyAANgIIIAAgAzYCDCAAIAQ2AggMAQtBHyEDAkAgBEH///8HSw0AIARBCHYiAyADQYD+P2pBEHZBCHEiA3QiBSAFQYDgH2pBEHZBBHEiBXQiAiACQYCAD2pBEHZBAnEiAnRBD3YgAyAFciACcmsiA0EBdCAEIANBFWp2QQFxckEcaiEDCyAAIAM2AhwgAEIANwIQIANBAnRBuNKAgABqIQUCQCAHQQEgA3QiAnENACAFIAA2AgBBACAHIAJyNgKM0ICAACAAIAU2AhggACAANgIIIAAgADYCDAwBCyAEQQBBGSADQQF2ayADQR9GG3QhAyAFKAIAIQICQANAIAIiBSgCBEF4cSAERg0BIANBHXYhAiADQQF0IQMgBSACQQRxakEQaiIGKAIAIgINAAsgBiAANgIAIAAgBTYCGCAAIAA2AgwgACAANgIIDAELIAUoAggiAyAANgIMIAUgADYCCCAAQQA2AhggACAFNgIMIAAgAzYCCAsgCEEIaiEDDAELAkAgCkUNAAJAAkAgACAAKAIcIgVBAnRBuNKAgABqIgMoAgBHDQAgAyAINgIAIAgNAUEAIAlBfiAFd3E2AozQgIAADAILIApBEEEUIAooAhAgAEYbaiAINgIAIAhFDQELIAggCjYCGAJAIAAoAhAiA0UNACAIIAM2AhAgAyAINgIYCyAAQRRqKAIAIgNFDQAgCEEUaiADNgIAIAMgCDYCGAsCQAJAIARBD0sNACAAIAQgAmoiA0EDcjYCBCAAIANqIgMgAygCBEEBcjYCBAwBCyAAIAJqIgUgBEEBcjYCBCAAIAJBA3I2AgQgBSAEaiAENgIAAkAgB0UNACAHQXhxQbDQgIAAaiECQQAoApzQgIAAIQMCQAJAQQEgB0EDdnQiCCAGcQ0AQQAgCCAGcjYCiNCAgAAgAiEIDAELIAIoAgghCAsgCCADNgIMIAIgAzYCCCADIAI2AgwgAyAINgIIC0EAIAU2ApzQgIAAQQAgBDYCkNCAgAALIABBCGohAwsgAUEQaiSAgICAACADCwoAIAAQyYCAgAAL4g0BB38CQCAARQ0AIABBeGoiASAAQXxqKAIAIgJBeHEiAGohAwJAIAJBAXENACACQQNxRQ0BIAEgASgCACICayIBQQAoApjQgIAAIgRJDQEgAiAAaiEAAkAgAUEAKAKc0ICAAEYNAAJAIAJB/wFLDQAgASgCCCIEIAJBA3YiBUEDdEGw0ICAAGoiBkYaAkAgASgCDCICIARHDQBBAEEAKAKI0ICAAEF+IAV3cTYCiNCAgAAMAwsgAiAGRhogAiAENgIIIAQgAjYCDAwCCyABKAIYIQcCQAJAIAEoAgwiBiABRg0AIAEoAggiAiAESRogBiACNgIIIAIgBjYCDAwBCwJAIAFBFGoiAigCACIEDQAgAUEQaiICKAIAIgQNAEEAIQYMAQsDQCACIQUgBCIGQRRqIgIoAgAiBA0AIAZBEGohAiAGKAIQIgQNAAsgBUEANgIACyAHRQ0BAkACQCABIAEoAhwiBEECdEG40oCAAGoiAigCAEcNACACIAY2AgAgBg0BQQBBACgCjNCAgABBfiAEd3E2AozQgIAADAMLIAdBEEEUIAcoAhAgAUYbaiAGNgIAIAZFDQILIAYgBzYCGAJAIAEoAhAiAkUNACAGIAI2AhAgAiAGNgIYCyABKAIUIgJFDQEgBkEUaiACNgIAIAIgBjYCGAwBCyADKAIEIgJBA3FBA0cNACADIAJBfnE2AgRBACAANgKQ0ICAACABIABqIAA2AgAgASAAQQFyNgIEDwsgASADTw0AIAMoAgQiAkEBcUUNAAJAAkAgAkECcQ0AAkAgA0EAKAKg0ICAAEcNAEEAIAE2AqDQgIAAQQBBACgClNCAgAAgAGoiADYClNCAgAAgASAAQQFyNgIEIAFBACgCnNCAgABHDQNBAEEANgKQ0ICAAEEAQQA2ApzQgIAADwsCQCADQQAoApzQgIAARw0AQQAgATYCnNCAgABBAEEAKAKQ0ICAACAAaiIANgKQ0ICAACABIABBAXI2AgQgASAAaiAANgIADwsgAkF4cSAAaiEAAkACQCACQf8BSw0AIAMoAggiBCACQQN2IgVBA3RBsNCAgABqIgZGGgJAIAMoAgwiAiAERw0AQQBBACgCiNCAgABBfiAFd3E2AojQgIAADAILIAIgBkYaIAIgBDYCCCAEIAI2AgwMAQsgAygCGCEHAkACQCADKAIMIgYgA0YNACADKAIIIgJBACgCmNCAgABJGiAGIAI2AgggAiAGNgIMDAELAkAgA0EUaiICKAIAIgQNACADQRBqIgIoAgAiBA0AQQAhBgwBCwNAIAIhBSAEIgZBFGoiAigCACIEDQAgBkEQaiECIAYoAhAiBA0ACyAFQQA2AgALIAdFDQACQAJAIAMgAygCHCIEQQJ0QbjSgIAAaiICKAIARw0AIAIgBjYCACAGDQFBAEEAKAKM0ICAAEF+IAR3cTYCjNCAgAAMAgsgB0EQQRQgBygCECADRhtqIAY2AgAgBkUNAQsgBiAHNgIYAkAgAygCECICRQ0AIAYgAjYCECACIAY2AhgLIAMoAhQiAkUNACAGQRRqIAI2AgAgAiAGNgIYCyABIABqIAA2AgAgASAAQQFyNgIEIAFBACgCnNCAgABHDQFBACAANgKQ0ICAAA8LIAMgAkF+cTYCBCABIABqIAA2AgAgASAAQQFyNgIECwJAIABB/wFLDQAgAEF4cUGw0ICAAGohAgJAAkBBACgCiNCAgAAiBEEBIABBA3Z0IgBxDQBBACAEIAByNgKI0ICAACACIQAMAQsgAigCCCEACyAAIAE2AgwgAiABNgIIIAEgAjYCDCABIAA2AggPC0EfIQICQCAAQf///wdLDQAgAEEIdiICIAJBgP4/akEQdkEIcSICdCIEIARBgOAfakEQdkEEcSIEdCIGIAZBgIAPakEQdkECcSIGdEEPdiACIARyIAZyayICQQF0IAAgAkEVanZBAXFyQRxqIQILIAEgAjYCHCABQgA3AhAgAkECdEG40oCAAGohBAJAAkBBACgCjNCAgAAiBkEBIAJ0IgNxDQAgBCABNgIAQQAgBiADcjYCjNCAgAAgASAENgIYIAEgATYCCCABIAE2AgwMAQsgAEEAQRkgAkEBdmsgAkEfRht0IQIgBCgCACEGAkADQCAGIgQoAgRBeHEgAEYNASACQR12IQYgAkEBdCECIAQgBkEEcWpBEGoiAygCACIGDQALIAMgATYCACABIAQ2AhggASABNgIMIAEgATYCCAwBCyAEKAIIIgAgATYCDCAEIAE2AgggAUEANgIYIAEgBDYCDCABIAA2AggLQQBBACgCqNCAgABBf2oiAUF/IAEbNgKo0ICAAAsLBAAAAAtOAAJAIAANAD8AQRB0DwsCQCAAQf//A3ENACAAQX9MDQACQCAAQRB2QAAiAEF/Rw0AQQBBMDYC+NOAgABBfw8LIABBEHQPCxDKgICAAAAL8gICA38BfgJAIAJFDQAgACABOgAAIAIgAGoiA0F/aiABOgAAIAJBA0kNACAAIAE6AAIgACABOgABIANBfWogAToAACADQX5qIAE6AAAgAkEHSQ0AIAAgAToAAyADQXxqIAE6AAAgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIFayICQSBJDQAgAa1CgYCAgBB+IQYgAyAFaiEBA0AgASAGNwMYIAEgBjcDECABIAY3AwggASAGNwMAIAFBIGohASACQWBqIgJBH0sNAAsLIAALC45IAQBBgAgLhkgBAAAAAgAAAAMAAAAAAAAAAAAAAAQAAAAFAAAAAAAAAAAAAAAGAAAABwAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEludmFsaWQgY2hhciBpbiB1cmwgcXVlcnkAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9ib2R5AENvbnRlbnQtTGVuZ3RoIG92ZXJmbG93AENodW5rIHNpemUgb3ZlcmZsb3cAUmVzcG9uc2Ugb3ZlcmZsb3cASW52YWxpZCBtZXRob2QgZm9yIEhUVFAveC54IHJlcXVlc3QASW52YWxpZCBtZXRob2QgZm9yIFJUU1AveC54IHJlcXVlc3QARXhwZWN0ZWQgU09VUkNFIG1ldGhvZCBmb3IgSUNFL3gueCByZXF1ZXN0AEludmFsaWQgY2hhciBpbiB1cmwgZnJhZ21lbnQgc3RhcnQARXhwZWN0ZWQgZG90AFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fc3RhdHVzAEludmFsaWQgcmVzcG9uc2Ugc3RhdHVzAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMAVXNlciBjYWxsYmFjayBlcnJvcgBgb25fcmVzZXRgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19oZWFkZXJgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21ldGhvZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl92ZXJzaW9uAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBIVFRQIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABEdXBsaWNhdGUgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyIGluIHVybCBwYXRoAENvbnRlbnQtTGVuZ3RoIGNhbid0IGJlIHByZXNlbnQgd2l0aCBUcmFuc2Zlci1FbmNvZGluZwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBzaXplAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX3ZhbHVlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgdmFsdWUATWlzc2luZyBleHBlY3RlZCBMRiBhZnRlciBoZWFkZXIgdmFsdWUASW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fbmFtZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIG5hbWUAUGF1c2Ugb24gQ09OTkVDVC9VcGdyYWRlAFBhdXNlIG9uIFBSSS9VcGdyYWRlAEV4cGVjdGVkIEhUVFAvMiBDb25uZWN0aW9uIFByZWZhY2UAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9tZXRob2QARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgbWV0aG9kAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX2ZpZWxkAFBhdXNlZABJbnZhbGlkIHdvcmQgZW5jb3VudGVyZWQASW52YWxpZCBtZXRob2QgZW5jb3VudGVyZWQAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzY2hlbWEAUmVxdWVzdCBoYXMgaW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX05BTUVfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUASFBFX0NCX01FVEhPRF9DT01QTEVURQBIUEVfQ0JfSEVBREVSX0ZJRUxEX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUASU5WQUxJRF9TU0xfQ0VSVElGSUNBVEUAUEFVU0UATk9fUkVTUE9OU0UAVU5TVVBQT1JURURfTUVESUFfVFlQRQBHT05FAE5PVF9BQ0NFUFRBQkxFAFNFUlZJQ0VfVU5BVkFJTEFCTEUAUkFOR0VfTk9UX1NBVElTRklBQkxFAE9SSUdJTl9JU19VTlJFQUNIQUJMRQBSRVNQT05TRV9JU19TVEFMRQBQVVJHRQBNRVJHRQBSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFAFJFUVVFU1RfSEVBREVSX1RPT19MQVJHRQBQQVlMT0FEX1RPT19MQVJHRQBJTlNVRkZJQ0lFTlRfU1RPUkFHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBIUEVfVU5FWFBFQ1RFRF9TUEFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAE5PVF9GT1VORABQUk9QRklORABVTkJJTkQAUkVCSU5EAFVOQVVUSE9SSVpFRABNRVRIT0RfTk9UX0FMTE9XRUQASFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQAQUxSRUFEWV9SRVBPUlRFRABBQ0NFUFRFRABOT1RfSU1QTEVNRU5URUQATE9PUF9ERVRFQ1RFRABIUEVfQ1JfRVhQRUNURUQASFBFX0xGX0VYUEVDVEVEAENSRUFURUQASU1fVVNFRABIUEVfUEFVU0VEAFRJTUVPVVRfT0NDVVJFRABQQVlNRU5UX1JFUVVJUkVEAFBSRUNPTkRJVElPTl9SRVFVSVJFRABQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRABORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAExFTkdUSF9SRVFVSVJFRABTU0xfQ0VSVElGSUNBVEVfUkVRVUlSRUQAVVBHUkFERV9SRVFVSVJFRABQQUdFX0VYUElSRUQAUFJFQ09ORElUSU9OX0ZBSUxFRABFWFBFQ1RBVElPTl9GQUlMRUQAUkVWQUxJREFUSU9OX0ZBSUxFRABTU0xfSEFORFNIQUtFX0ZBSUxFRABMT0NLRUQAVFJBTlNGT1JNQVRJT05fQVBQTElFRABOT1RfTU9ESUZJRUQATk9UX0VYVEVOREVEAEJBTkRXSURUSF9MSU1JVF9FWENFRURFRABTSVRFX0lTX09WRVJMT0FERUQASEVBRABFeHBlY3RlZCBIVFRQLwAAXhMAACYTAAAwEAAA8BcAAJ0TAAAVEgAAORcAAPASAAAKEAAAdRIAAK0SAACCEwAATxQAAH8QAACgFQAAIxQAAIkSAACLFAAATRUAANQRAADPFAAAEBgAAMkWAADcFgAAwREAAOAXAAC7FAAAdBQAAHwVAADlFAAACBcAAB8QAABlFQAAoxQAACgVAAACFQAAmRUAACwQAACLGQAATw8AANQOAABqEAAAzhAAAAIXAACJDgAAbhMAABwTAABmFAAAVhcAAMETAADNEwAAbBMAAGgXAABmFwAAXxcAACITAADODwAAaQ4AANgOAABjFgAAyxMAAKoOAAAoFwAAJhcAAMUTAABdFgAA6BEAAGcTAABlEwAA8hYAAHMTAAAdFwAA+RYAAPMRAADPDgAAzhUAAAwSAACzEQAApREAAGEQAAAyFwAAuxMAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIDAgICAgIAAAICAAICAAICAgICAgICAgIABAAAAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAACAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbG9zZWVlcC1hbGl2ZQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEAAAEBAAEBAAEBAQEBAQEBAQEAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AAAAAAAAAAAAAAAAAAAByYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AAAAAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQIAAQMAAAAAAAAAAAAAAAAAAAAAAAAEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAQAAAgAAAAAAAAAAAAAAAAAAAAAAAAMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAIAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABOT1VOQ0VFQ0tPVVRORUNURVRFQ1JJQkVMVVNIRVRFQURTRUFSQ0hSR0VDVElWSVRZTEVOREFSVkVPVElGWVBUSU9OU0NIU0VBWVNUQVRDSEdFT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8=';
	return llhttpWasm;
}

var llhttp_simdWasm;
var hasRequiredLlhttp_simdWasm;

function requireLlhttp_simdWasm () {
	if (hasRequiredLlhttp_simdWasm) return llhttp_simdWasm;
	hasRequiredLlhttp_simdWasm = 1;
	llhttp_simdWasm = 'AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJsbGh0dHBfc3RhdHVzX25hbWUAIRpsbGh0dHBfc2V0X2xlbmllbnRfaGVhZGVycwAiIWxsaHR0cF9zZXRfbGVuaWVudF9jaHVua2VkX2xlbmd0aAAjHWxsaHR0cF9zZXRfbGVuaWVudF9rZWVwX2FsaXZlACQkbGxodHRwX3NldF9sZW5pZW50X3RyYW5zZmVyX2VuY29kaW5nACUYbGxodHRwX21lc3NhZ2VfbmVlZHNfZW9mAD8JFwEAQQELEQECAwQFCwYHNTk3MS8tJyspCrLgAkUCAAsIABCIgICAAAsZACAAEMKAgIAAGiAAIAI2AjggACABOgAoCxwAIAAgAC8BMiAALQAuIAAQwYCAgAAQgICAgAALKgEBf0HAABDGgICAACIBEMKAgIAAGiABQYCIgIAANgI4IAEgADoAKCABCwoAIAAQyICAgAALBwAgAC0AKAsHACAALQAqCwcAIAAtACsLBwAgAC0AKQsHACAALwEyCwcAIAAtAC4LRQEEfyAAKAIYIQEgAC0ALSECIAAtACghAyAAKAI4IQQgABDCgICAABogACAENgI4IAAgAzoAKCAAIAI6AC0gACABNgIYCxEAIAAgASABIAJqEMOAgIAACxAAIABBAEHcABDMgICAABoLZwEBf0EAIQECQCAAKAIMDQACQAJAAkACQCAALQAvDgMBAAMCCyAAKAI4IgFFDQAgASgCLCIBRQ0AIAAgARGAgICAAAAiAQ0DC0EADwsQyoCAgAAACyAAQcOWgIAANgIQQQ4hAQsgAQseAAJAIAAoAgwNACAAQdGbgIAANgIQIABBFTYCDAsLFgACQCAAKAIMQRVHDQAgAEEANgIMCwsWAAJAIAAoAgxBFkcNACAAQQA2AgwLCwcAIAAoAgwLBwAgACgCEAsJACAAIAE2AhALBwAgACgCFAsiAAJAIABBJEkNABDKgICAAAALIABBAnRBoLOAgABqKAIACyIAAkAgAEEuSQ0AEMqAgIAAAAsgAEECdEGwtICAAGooAgAL7gsBAX9B66iAgAAhAQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABBnH9qDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0Hhp4CAAA8LQaShgIAADwtBy6yAgAAPC0H+sYCAAA8LQcCkgIAADwtBq6SAgAAPC0GNqICAAA8LQeKmgIAADwtBgLCAgAAPC0G5r4CAAA8LQdekgIAADwtB75+AgAAPC0Hhn4CAAA8LQfqfgIAADwtB8qCAgAAPC0Gor4CAAA8LQa6ygIAADwtBiLCAgAAPC0Hsp4CAAA8LQYKigIAADwtBjp2AgAAPC0HQroCAAA8LQcqjgIAADwtBxbKAgAAPC0HfnICAAA8LQdKcgIAADwtBxKCAgAAPC0HXoICAAA8LQaKfgIAADwtB7a6AgAAPC0GrsICAAA8LQdSlgIAADwtBzK6AgAAPC0H6roCAAA8LQfyrgIAADwtB0rCAgAAPC0HxnYCAAA8LQbuggIAADwtB96uAgAAPC0GQsYCAAA8LQdexgIAADwtBoq2AgAAPC0HUp4CAAA8LQeCrgIAADwtBn6yAgAAPC0HrsYCAAA8LQdWfgIAADwtByrGAgAAPC0HepYCAAA8LQdSegIAADwtB9JyAgAAPC0GnsoCAAA8LQbGdgIAADwtBoJ2AgAAPC0G5sYCAAA8LQbywgIAADwtBkqGAgAAPC0GzpoCAAA8LQemsgIAADwtBrJ6AgAAPC0HUq4CAAA8LQfemgIAADwtBgKaAgAAPC0GwoYCAAA8LQf6egIAADwtBjaOAgAAPC0GJrYCAAA8LQfeigIAADwtBoLGAgAAPC0Gun4CAAA8LQcalgIAADwtB6J6AgAAPC0GTooCAAA8LQcKvgIAADwtBw52AgAAPC0GLrICAAA8LQeGdgIAADwtBja+AgAAPC0HqoYCAAA8LQbStgIAADwtB0q+AgAAPC0HfsoCAAA8LQdKygIAADwtB8LCAgAAPC0GpooCAAA8LQfmjgIAADwtBmZ6AgAAPC0G1rICAAA8LQZuwgIAADwtBkrKAgAAPC0G2q4CAAA8LQcKigIAADwtB+LKAgAAPC0GepYCAAA8LQdCigIAADwtBup6AgAAPC0GBnoCAAA8LEMqAgIAAAAtB1qGAgAAhAQsgAQsWACAAIAAtAC1B/gFxIAFBAEdyOgAtCxkAIAAgAC0ALUH9AXEgAUEAR0EBdHI6AC0LGQAgACAALQAtQfsBcSABQQBHQQJ0cjoALQsZACAAIAAtAC1B9wFxIAFBAEdBA3RyOgAtCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAgAiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCBCIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQcaRgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIwIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAggiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEH2ioCAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCNCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIMIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABB7ZqAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAjgiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCECIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQZWQgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAI8IgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAhQiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEGqm4CAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCQCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIYIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABB7ZOAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAkQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCJCIERQ0AIAAgBBGAgICAAAAhAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIsIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAigiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEH2iICAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCUCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIcIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABBwpmAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAkgiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCICIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQZSUgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAJMIgRFDQAgACAEEYCAgIAAACEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAlQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCWCIERQ0AIAAgBBGAgICAAAAhAwsgAwtFAQF/AkACQCAALwEwQRRxQRRHDQBBASEDIAAtAChBAUYNASAALwEyQeUARiEDDAELIAAtAClBBUYhAwsgACADOgAuQQAL/gEBA39BASEDAkAgAC8BMCIEQQhxDQAgACkDIEIAUiEDCwJAAkAgAC0ALkUNAEEBIQUgAC0AKUEFRg0BQQEhBSAEQcAAcUUgA3FBAUcNAQtBACEFIARBwABxDQBBAiEFIARB//8DcSIDQQhxDQACQCADQYAEcUUNAAJAIAAtAChBAUcNACAALQAtQQpxDQBBBQ8LQQQPCwJAIANBIHENAAJAIAAtAChBAUYNACAALwEyQf//A3EiAEGcf2pB5ABJDQAgAEHMAUYNACAAQbACRg0AQQQhBSAEQShxRQ0CIANBiARxQYAERg0CC0EADwtBAEEDIAApAyBQGyEFCyAFC2IBAn9BACEBAkAgAC0AKEEBRg0AIAAvATJB//8DcSICQZx/akHkAEkNACACQcwBRg0AIAJBsAJGDQAgAC8BMCIAQcAAcQ0AQQEhASAAQYgEcUGABEYNACAAQShxRSEBCyABC6cBAQN/AkACQAJAIAAtACpFDQAgAC0AK0UNAEEAIQMgAC8BMCIEQQJxRQ0BDAILQQAhAyAALwEwIgRBAXFFDQELQQEhAyAALQAoQQFGDQAgAC8BMkH//wNxIgVBnH9qQeQASQ0AIAVBzAFGDQAgBUGwAkYNACAEQcAAcQ0AQQAhAyAEQYgEcUGABEYNACAEQShxQQBHIQMLIABBADsBMCAAQQA6AC8gAwuZAQECfwJAAkACQCAALQAqRQ0AIAAtACtFDQBBACEBIAAvATAiAkECcUUNAQwCC0EAIQEgAC8BMCICQQFxRQ0BC0EBIQEgAC0AKEEBRg0AIAAvATJB//8DcSIAQZx/akHkAEkNACAAQcwBRg0AIABBsAJGDQAgAkHAAHENAEEAIQEgAkGIBHFBgARGDQAgAkEocUEARyEBCyABC0kBAXsgAEEQav0MAAAAAAAAAAAAAAAAAAAAACIB/QsDACAAIAH9CwMAIABBMGogAf0LAwAgAEEgaiAB/QsDACAAQd0BNgIcQQALewEBfwJAIAAoAgwiAw0AAkAgACgCBEUNACAAIAE2AgQLAkAgACABIAIQxICAgAAiAw0AIAAoAgwPCyAAIAM2AhxBACEDIAAoAgQiAUUNACAAIAEgAiAAKAIIEYGAgIAAACIBRQ0AIAAgAjYCFCAAIAE2AgwgASEDCyADC+TzAQMOfwN+BH8jgICAgABBEGsiAySAgICAACABIQQgASEFIAEhBiABIQcgASEIIAEhCSABIQogASELIAEhDCABIQ0gASEOIAEhDwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIcIhBBf2oO3QHaAQHZAQIDBAUGBwgJCgsMDQ7YAQ8Q1wEREtYBExQVFhcYGRob4AHfARwdHtUBHyAhIiMkJdQBJicoKSorLNMB0gEtLtEB0AEvMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUbbAUdISUrPAc4BS80BTMwBTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBmwGcAZ0BngGfAaABoQGiAaMBpAGlAaYBpwGoAakBqgGrAawBrQGuAa8BsAGxAbIBswG0AbUBtgG3AcsBygG4AckBuQHIAboBuwG8Ab0BvgG/AcABwQHCAcMBxAHFAcYBANwBC0EAIRAMxgELQQ4hEAzFAQtBDSEQDMQBC0EPIRAMwwELQRAhEAzCAQtBEyEQDMEBC0EUIRAMwAELQRUhEAy/AQtBFiEQDL4BC0EXIRAMvQELQRghEAy8AQtBGSEQDLsBC0EaIRAMugELQRshEAy5AQtBHCEQDLgBC0EIIRAMtwELQR0hEAy2AQtBICEQDLUBC0EfIRAMtAELQQchEAyzAQtBISEQDLIBC0EiIRAMsQELQR4hEAywAQtBIyEQDK8BC0ESIRAMrgELQREhEAytAQtBJCEQDKwBC0ElIRAMqwELQSYhEAyqAQtBJyEQDKkBC0HDASEQDKgBC0EpIRAMpwELQSshEAymAQtBLCEQDKUBC0EtIRAMpAELQS4hEAyjAQtBLyEQDKIBC0HEASEQDKEBC0EwIRAMoAELQTQhEAyfAQtBDCEQDJ4BC0ExIRAMnQELQTIhEAycAQtBMyEQDJsBC0E5IRAMmgELQTUhEAyZAQtBxQEhEAyYAQtBCyEQDJcBC0E6IRAMlgELQTYhEAyVAQtBCiEQDJQBC0E3IRAMkwELQTghEAySAQtBPCEQDJEBC0E7IRAMkAELQT0hEAyPAQtBCSEQDI4BC0EoIRAMjQELQT4hEAyMAQtBPyEQDIsBC0HAACEQDIoBC0HBACEQDIkBC0HCACEQDIgBC0HDACEQDIcBC0HEACEQDIYBC0HFACEQDIUBC0HGACEQDIQBC0EqIRAMgwELQccAIRAMggELQcgAIRAMgQELQckAIRAMgAELQcoAIRAMfwtBywAhEAx+C0HNACEQDH0LQcwAIRAMfAtBzgAhEAx7C0HPACEQDHoLQdAAIRAMeQtB0QAhEAx4C0HSACEQDHcLQdMAIRAMdgtB1AAhEAx1C0HWACEQDHQLQdUAIRAMcwtBBiEQDHILQdcAIRAMcQtBBSEQDHALQdgAIRAMbwtBBCEQDG4LQdkAIRAMbQtB2gAhEAxsC0HbACEQDGsLQdwAIRAMagtBAyEQDGkLQd0AIRAMaAtB3gAhEAxnC0HfACEQDGYLQeEAIRAMZQtB4AAhEAxkC0HiACEQDGMLQeMAIRAMYgtBAiEQDGELQeQAIRAMYAtB5QAhEAxfC0HmACEQDF4LQecAIRAMXQtB6AAhEAxcC0HpACEQDFsLQeoAIRAMWgtB6wAhEAxZC0HsACEQDFgLQe0AIRAMVwtB7gAhEAxWC0HvACEQDFULQfAAIRAMVAtB8QAhEAxTC0HyACEQDFILQfMAIRAMUQtB9AAhEAxQC0H1ACEQDE8LQfYAIRAMTgtB9wAhEAxNC0H4ACEQDEwLQfkAIRAMSwtB+gAhEAxKC0H7ACEQDEkLQfwAIRAMSAtB/QAhEAxHC0H+ACEQDEYLQf8AIRAMRQtBgAEhEAxEC0GBASEQDEMLQYIBIRAMQgtBgwEhEAxBC0GEASEQDEALQYUBIRAMPwtBhgEhEAw+C0GHASEQDD0LQYgBIRAMPAtBiQEhEAw7C0GKASEQDDoLQYsBIRAMOQtBjAEhEAw4C0GNASEQDDcLQY4BIRAMNgtBjwEhEAw1C0GQASEQDDQLQZEBIRAMMwtBkgEhEAwyC0GTASEQDDELQZQBIRAMMAtBlQEhEAwvC0GWASEQDC4LQZcBIRAMLQtBmAEhEAwsC0GZASEQDCsLQZoBIRAMKgtBmwEhEAwpC0GcASEQDCgLQZ0BIRAMJwtBngEhEAwmC0GfASEQDCULQaABIRAMJAtBoQEhEAwjC0GiASEQDCILQaMBIRAMIQtBpAEhEAwgC0GlASEQDB8LQaYBIRAMHgtBpwEhEAwdC0GoASEQDBwLQakBIRAMGwtBqgEhEAwaC0GrASEQDBkLQawBIRAMGAtBrQEhEAwXC0GuASEQDBYLQQEhEAwVC0GvASEQDBQLQbABIRAMEwtBsQEhEAwSC0GzASEQDBELQbIBIRAMEAtBtAEhEAwPC0G1ASEQDA4LQbYBIRAMDQtBtwEhEAwMC0G4ASEQDAsLQbkBIRAMCgtBugEhEAwJC0G7ASEQDAgLQcYBIRAMBwtBvAEhEAwGC0G9ASEQDAULQb4BIRAMBAtBvwEhEAwDC0HAASEQDAILQcIBIRAMAQtBwQEhEAsDQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBAOxwEAAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB4fICEjJSg/QEFERUZHSElKS0xNT1BRUlPeA1dZW1xdYGJlZmdoaWprbG1vcHFyc3R1dnd4eXp7fH1+gAGCAYUBhgGHAYkBiwGMAY0BjgGPAZABkQGUAZUBlgGXAZgBmQGaAZsBnAGdAZ4BnwGgAaEBogGjAaQBpQGmAacBqAGpAaoBqwGsAa0BrgGvAbABsQGyAbMBtAG1AbYBtwG4AbkBugG7AbwBvQG+Ab8BwAHBAcIBwwHEAcUBxgHHAcgByQHKAcsBzAHNAc4BzwHQAdEB0gHTAdQB1QHWAdcB2AHZAdoB2wHcAd0B3gHgAeEB4gHjAeQB5QHmAecB6AHpAeoB6wHsAe0B7gHvAfAB8QHyAfMBmQKkArAC/gL+AgsgASIEIAJHDfMBQd0BIRAM/wMLIAEiECACRw3dAUHDASEQDP4DCyABIgEgAkcNkAFB9wAhEAz9AwsgASIBIAJHDYYBQe8AIRAM/AMLIAEiASACRw1/QeoAIRAM+wMLIAEiASACRw17QegAIRAM+gMLIAEiASACRw14QeYAIRAM+QMLIAEiASACRw0aQRghEAz4AwsgASIBIAJHDRRBEiEQDPcDCyABIgEgAkcNWUHFACEQDPYDCyABIgEgAkcNSkE/IRAM9QMLIAEiASACRw1IQTwhEAz0AwsgASIBIAJHDUFBMSEQDPMDCyAALQAuQQFGDesDDIcCCyAAIAEiASACEMCAgIAAQQFHDeYBIABCADcDIAznAQsgACABIgEgAhC0gICAACIQDecBIAEhAQz1AgsCQCABIgEgAkcNAEEGIRAM8AMLIAAgAUEBaiIBIAIQu4CAgAAiEA3oASABIQEMMQsgAEIANwMgQRIhEAzVAwsgASIQIAJHDStBHSEQDO0DCwJAIAEiASACRg0AIAFBAWohAUEQIRAM1AMLQQchEAzsAwsgAEIAIAApAyAiESACIAEiEGutIhJ9IhMgEyARVhs3AyAgESASViIURQ3lAUEIIRAM6wMLAkAgASIBIAJGDQAgAEGJgICAADYCCCAAIAE2AgQgASEBQRQhEAzSAwtBCSEQDOoDCyABIQEgACkDIFAN5AEgASEBDPICCwJAIAEiASACRw0AQQshEAzpAwsgACABQQFqIgEgAhC2gICAACIQDeUBIAEhAQzyAgsgACABIgEgAhC4gICAACIQDeUBIAEhAQzyAgsgACABIgEgAhC4gICAACIQDeYBIAEhAQwNCyAAIAEiASACELqAgIAAIhAN5wEgASEBDPACCwJAIAEiASACRw0AQQ8hEAzlAwsgAS0AACIQQTtGDQggEEENRw3oASABQQFqIQEM7wILIAAgASIBIAIQuoCAgAAiEA3oASABIQEM8gILA0ACQCABLQAAQfC1gIAAai0AACIQQQFGDQAgEEECRw3rASAAKAIEIRAgAEEANgIEIAAgECABQQFqIgEQuYCAgAAiEA3qASABIQEM9AILIAFBAWoiASACRw0AC0ESIRAM4gMLIAAgASIBIAIQuoCAgAAiEA3pASABIQEMCgsgASIBIAJHDQZBGyEQDOADCwJAIAEiASACRw0AQRYhEAzgAwsgAEGKgICAADYCCCAAIAE2AgQgACABIAIQuICAgAAiEA3qASABIQFBICEQDMYDCwJAIAEiASACRg0AA0ACQCABLQAAQfC3gIAAai0AACIQQQJGDQACQCAQQX9qDgTlAewBAOsB7AELIAFBAWohAUEIIRAMyAMLIAFBAWoiASACRw0AC0EVIRAM3wMLQRUhEAzeAwsDQAJAIAEtAABB8LmAgABqLQAAIhBBAkYNACAQQX9qDgTeAewB4AHrAewBCyABQQFqIgEgAkcNAAtBGCEQDN0DCwJAIAEiASACRg0AIABBi4CAgAA2AgggACABNgIEIAEhAUEHIRAMxAMLQRkhEAzcAwsgAUEBaiEBDAILAkAgASIUIAJHDQBBGiEQDNsDCyAUIQECQCAULQAAQXNqDhTdAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gLuAgDuAgtBACEQIABBADYCHCAAQa+LgIAANgIQIABBAjYCDCAAIBRBAWo2AhQM2gMLAkAgAS0AACIQQTtGDQAgEEENRw3oASABQQFqIQEM5QILIAFBAWohAQtBIiEQDL8DCwJAIAEiECACRw0AQRwhEAzYAwtCACERIBAhASAQLQAAQVBqDjfnAeYBAQIDBAUGBwgAAAAAAAAACQoLDA0OAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPEBESExQAC0EeIRAMvQMLQgIhEQzlAQtCAyERDOQBC0IEIREM4wELQgUhEQziAQtCBiERDOEBC0IHIREM4AELQgghEQzfAQtCCSERDN4BC0IKIREM3QELQgshEQzcAQtCDCERDNsBC0INIREM2gELQg4hEQzZAQtCDyERDNgBC0IKIREM1wELQgshEQzWAQtCDCERDNUBC0INIREM1AELQg4hEQzTAQtCDyERDNIBC0IAIRECQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBAtAABBUGoON+UB5AEAAQIDBAUGB+YB5gHmAeYB5gHmAeYBCAkKCwwN5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAQ4PEBESE+YBC0ICIREM5AELQgMhEQzjAQtCBCERDOIBC0IFIREM4QELQgYhEQzgAQtCByERDN8BC0IIIREM3gELQgkhEQzdAQtCCiERDNwBC0ILIREM2wELQgwhEQzaAQtCDSERDNkBC0IOIREM2AELQg8hEQzXAQtCCiERDNYBC0ILIREM1QELQgwhEQzUAQtCDSERDNMBC0IOIREM0gELQg8hEQzRAQsgAEIAIAApAyAiESACIAEiEGutIhJ9IhMgEyARVhs3AyAgESASViIURQ3SAUEfIRAMwAMLAkAgASIBIAJGDQAgAEGJgICAADYCCCAAIAE2AgQgASEBQSQhEAynAwtBICEQDL8DCyAAIAEiECACEL6AgIAAQX9qDgW2AQDFAgHRAdIBC0ERIRAMpAMLIABBAToALyAQIQEMuwMLIAEiASACRw3SAUEkIRAMuwMLIAEiDSACRw0eQcYAIRAMugMLIAAgASIBIAIQsoCAgAAiEA3UASABIQEMtQELIAEiECACRw0mQdAAIRAMuAMLAkAgASIBIAJHDQBBKCEQDLgDCyAAQQA2AgQgAEGMgICAADYCCCAAIAEgARCxgICAACIQDdMBIAEhAQzYAQsCQCABIhAgAkcNAEEpIRAMtwMLIBAtAAAiAUEgRg0UIAFBCUcN0wEgEEEBaiEBDBULAkAgASIBIAJGDQAgAUEBaiEBDBcLQSohEAy1AwsCQCABIhAgAkcNAEErIRAMtQMLAkAgEC0AACIBQQlGDQAgAUEgRw3VAQsgAC0ALEEIRg3TASAQIQEMkQMLAkAgASIBIAJHDQBBLCEQDLQDCyABLQAAQQpHDdUBIAFBAWohAQzJAgsgASIOIAJHDdUBQS8hEAyyAwsDQAJAIAEtAAAiEEEgRg0AAkAgEEF2ag4EANwB3AEA2gELIAEhAQzgAQsgAUEBaiIBIAJHDQALQTEhEAyxAwtBMiEQIAEiFCACRg2wAyACIBRrIAAoAgAiAWohFSAUIAFrQQNqIRYCQANAIBQtAAAiF0EgciAXIBdBv39qQf8BcUEaSRtB/wFxIAFB8LuAgABqLQAARw0BAkAgAUEDRw0AQQYhAQyWAwsgAUEBaiEBIBRBAWoiFCACRw0ACyAAIBU2AgAMsQMLIABBADYCACAUIQEM2QELQTMhECABIhQgAkYNrwMgAiAUayAAKAIAIgFqIRUgFCABa0EIaiEWAkADQCAULQAAIhdBIHIgFyAXQb9/akH/AXFBGkkbQf8BcSABQfS7gIAAai0AAEcNAQJAIAFBCEcNAEEFIQEMlQMLIAFBAWohASAUQQFqIhQgAkcNAAsgACAVNgIADLADCyAAQQA2AgAgFCEBDNgBC0E0IRAgASIUIAJGDa4DIAIgFGsgACgCACIBaiEVIBQgAWtBBWohFgJAA0AgFC0AACIXQSByIBcgF0G/f2pB/wFxQRpJG0H/AXEgAUHQwoCAAGotAABHDQECQCABQQVHDQBBByEBDJQDCyABQQFqIQEgFEEBaiIUIAJHDQALIAAgFTYCAAyvAwsgAEEANgIAIBQhAQzXAQsCQCABIgEgAkYNAANAAkAgAS0AAEGAvoCAAGotAAAiEEEBRg0AIBBBAkYNCiABIQEM3QELIAFBAWoiASACRw0AC0EwIRAMrgMLQTAhEAytAwsCQCABIgEgAkYNAANAAkAgAS0AACIQQSBGDQAgEEF2ag4E2QHaAdoB2QHaAQsgAUEBaiIBIAJHDQALQTghEAytAwtBOCEQDKwDCwNAAkAgAS0AACIQQSBGDQAgEEEJRw0DCyABQQFqIgEgAkcNAAtBPCEQDKsDCwNAAkAgAS0AACIQQSBGDQACQAJAIBBBdmoOBNoBAQHaAQALIBBBLEYN2wELIAEhAQwECyABQQFqIgEgAkcNAAtBPyEQDKoDCyABIQEM2wELQcAAIRAgASIUIAJGDagDIAIgFGsgACgCACIBaiEWIBQgAWtBBmohFwJAA0AgFC0AAEEgciABQYDAgIAAai0AAEcNASABQQZGDY4DIAFBAWohASAUQQFqIhQgAkcNAAsgACAWNgIADKkDCyAAQQA2AgAgFCEBC0E2IRAMjgMLAkAgASIPIAJHDQBBwQAhEAynAwsgAEGMgICAADYCCCAAIA82AgQgDyEBIAAtACxBf2oOBM0B1QHXAdkBhwMLIAFBAWohAQzMAQsCQCABIgEgAkYNAANAAkAgAS0AACIQQSByIBAgEEG/f2pB/wFxQRpJG0H/AXEiEEEJRg0AIBBBIEYNAAJAAkACQAJAIBBBnX9qDhMAAwMDAwMDAwEDAwMDAwMDAwMCAwsgAUEBaiEBQTEhEAyRAwsgAUEBaiEBQTIhEAyQAwsgAUEBaiEBQTMhEAyPAwsgASEBDNABCyABQQFqIgEgAkcNAAtBNSEQDKUDC0E1IRAMpAMLAkAgASIBIAJGDQADQAJAIAEtAABBgLyAgABqLQAAQQFGDQAgASEBDNMBCyABQQFqIgEgAkcNAAtBPSEQDKQDC0E9IRAMowMLIAAgASIBIAIQsICAgAAiEA3WASABIQEMAQsgEEEBaiEBC0E8IRAMhwMLAkAgASIBIAJHDQBBwgAhEAygAwsCQANAAkAgAS0AAEF3ag4YAAL+Av4ChAP+Av4C/gL+Av4C/gL+Av4C/gL+Av4C/gL+Av4C/gL+Av4C/gIA/gILIAFBAWoiASACRw0AC0HCACEQDKADCyABQQFqIQEgAC0ALUEBcUUNvQEgASEBC0EsIRAMhQMLIAEiASACRw3TAUHEACEQDJ0DCwNAAkAgAS0AAEGQwICAAGotAABBAUYNACABIQEMtwILIAFBAWoiASACRw0AC0HFACEQDJwDCyANLQAAIhBBIEYNswEgEEE6Rw2BAyAAKAIEIQEgAEEANgIEIAAgASANEK+AgIAAIgEN0AEgDUEBaiEBDLMCC0HHACEQIAEiDSACRg2aAyACIA1rIAAoAgAiAWohFiANIAFrQQVqIRcDQCANLQAAIhRBIHIgFCAUQb9/akH/AXFBGkkbQf8BcSABQZDCgIAAai0AAEcNgAMgAUEFRg30AiABQQFqIQEgDUEBaiINIAJHDQALIAAgFjYCAAyaAwtByAAhECABIg0gAkYNmQMgAiANayAAKAIAIgFqIRYgDSABa0EJaiEXA0AgDS0AACIUQSByIBQgFEG/f2pB/wFxQRpJG0H/AXEgAUGWwoCAAGotAABHDf8CAkAgAUEJRw0AQQIhAQz1AgsgAUEBaiEBIA1BAWoiDSACRw0ACyAAIBY2AgAMmQMLAkAgASINIAJHDQBByQAhEAyZAwsCQAJAIA0tAAAiAUEgciABIAFBv39qQf8BcUEaSRtB/wFxQZJ/ag4HAIADgAOAA4ADgAMBgAMLIA1BAWohAUE+IRAMgAMLIA1BAWohAUE/IRAM/wILQcoAIRAgASINIAJGDZcDIAIgDWsgACgCACIBaiEWIA0gAWtBAWohFwNAIA0tAAAiFEEgciAUIBRBv39qQf8BcUEaSRtB/wFxIAFBoMKAgABqLQAARw39AiABQQFGDfACIAFBAWohASANQQFqIg0gAkcNAAsgACAWNgIADJcDC0HLACEQIAEiDSACRg2WAyACIA1rIAAoAgAiAWohFiANIAFrQQ5qIRcDQCANLQAAIhRBIHIgFCAUQb9/akH/AXFBGkkbQf8BcSABQaLCgIAAai0AAEcN/AIgAUEORg3wAiABQQFqIQEgDUEBaiINIAJHDQALIAAgFjYCAAyWAwtBzAAhECABIg0gAkYNlQMgAiANayAAKAIAIgFqIRYgDSABa0EPaiEXA0AgDS0AACIUQSByIBQgFEG/f2pB/wFxQRpJG0H/AXEgAUHAwoCAAGotAABHDfsCAkAgAUEPRw0AQQMhAQzxAgsgAUEBaiEBIA1BAWoiDSACRw0ACyAAIBY2AgAMlQMLQc0AIRAgASINIAJGDZQDIAIgDWsgACgCACIBaiEWIA0gAWtBBWohFwNAIA0tAAAiFEEgciAUIBRBv39qQf8BcUEaSRtB/wFxIAFB0MKAgABqLQAARw36AgJAIAFBBUcNAEEEIQEM8AILIAFBAWohASANQQFqIg0gAkcNAAsgACAWNgIADJQDCwJAIAEiDSACRw0AQc4AIRAMlAMLAkACQAJAAkAgDS0AACIBQSByIAEgAUG/f2pB/wFxQRpJG0H/AXFBnX9qDhMA/QL9Av0C/QL9Av0C/QL9Av0C/QL9Av0CAf0C/QL9AgID/QILIA1BAWohAUHBACEQDP0CCyANQQFqIQFBwgAhEAz8AgsgDUEBaiEBQcMAIRAM+wILIA1BAWohAUHEACEQDPoCCwJAIAEiASACRg0AIABBjYCAgAA2AgggACABNgIEIAEhAUHFACEQDPoCC0HPACEQDJIDCyAQIQECQAJAIBAtAABBdmoOBAGoAqgCAKgCCyAQQQFqIQELQSchEAz4AgsCQCABIgEgAkcNAEHRACEQDJEDCwJAIAEtAABBIEYNACABIQEMjQELIAFBAWohASAALQAtQQFxRQ3HASABIQEMjAELIAEiFyACRw3IAUHSACEQDI8DC0HTACEQIAEiFCACRg2OAyACIBRrIAAoAgAiAWohFiAUIAFrQQFqIRcDQCAULQAAIAFB1sKAgABqLQAARw3MASABQQFGDccBIAFBAWohASAUQQFqIhQgAkcNAAsgACAWNgIADI4DCwJAIAEiASACRw0AQdUAIRAMjgMLIAEtAABBCkcNzAEgAUEBaiEBDMcBCwJAIAEiASACRw0AQdYAIRAMjQMLAkACQCABLQAAQXZqDgQAzQHNAQHNAQsgAUEBaiEBDMcBCyABQQFqIQFBygAhEAzzAgsgACABIgEgAhCugICAACIQDcsBIAEhAUHNACEQDPICCyAALQApQSJGDYUDDKYCCwJAIAEiASACRw0AQdsAIRAMigMLQQAhFEEBIRdBASEWQQAhEAJAAkACQAJAAkACQAJAAkACQCABLQAAQVBqDgrUAdMBAAECAwQFBgjVAQtBAiEQDAYLQQMhEAwFC0EEIRAMBAtBBSEQDAMLQQYhEAwCC0EHIRAMAQtBCCEQC0EAIRdBACEWQQAhFAzMAQtBCSEQQQEhFEEAIRdBACEWDMsBCwJAIAEiASACRw0AQd0AIRAMiQMLIAEtAABBLkcNzAEgAUEBaiEBDKYCCyABIgEgAkcNzAFB3wAhEAyHAwsCQCABIgEgAkYNACAAQY6AgIAANgIIIAAgATYCBCABIQFB0AAhEAzuAgtB4AAhEAyGAwtB4QAhECABIgEgAkYNhQMgAiABayAAKAIAIhRqIRYgASAUa0EDaiEXA0AgAS0AACAUQeLCgIAAai0AAEcNzQEgFEEDRg3MASAUQQFqIRQgAUEBaiIBIAJHDQALIAAgFjYCAAyFAwtB4gAhECABIgEgAkYNhAMgAiABayAAKAIAIhRqIRYgASAUa0ECaiEXA0AgAS0AACAUQebCgIAAai0AAEcNzAEgFEECRg3OASAUQQFqIRQgAUEBaiIBIAJHDQALIAAgFjYCAAyEAwtB4wAhECABIgEgAkYNgwMgAiABayAAKAIAIhRqIRYgASAUa0EDaiEXA0AgAS0AACAUQenCgIAAai0AAEcNywEgFEEDRg3OASAUQQFqIRQgAUEBaiIBIAJHDQALIAAgFjYCAAyDAwsCQCABIgEgAkcNAEHlACEQDIMDCyAAIAFBAWoiASACEKiAgIAAIhANzQEgASEBQdYAIRAM6QILAkAgASIBIAJGDQADQAJAIAEtAAAiEEEgRg0AAkACQAJAIBBBuH9qDgsAAc8BzwHPAc8BzwHPAc8BzwECzwELIAFBAWohAUHSACEQDO0CCyABQQFqIQFB0wAhEAzsAgsgAUEBaiEBQdQAIRAM6wILIAFBAWoiASACRw0AC0HkACEQDIIDC0HkACEQDIEDCwNAAkAgAS0AAEHwwoCAAGotAAAiEEEBRg0AIBBBfmoOA88B0AHRAdIBCyABQQFqIgEgAkcNAAtB5gAhEAyAAwsCQCABIgEgAkYNACABQQFqIQEMAwtB5wAhEAz/AgsDQAJAIAEtAABB8MSAgABqLQAAIhBBAUYNAAJAIBBBfmoOBNIB0wHUAQDVAQsgASEBQdcAIRAM5wILIAFBAWoiASACRw0AC0HoACEQDP4CCwJAIAEiASACRw0AQekAIRAM/gILAkAgAS0AACIQQXZqDhq6AdUB1QG8AdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHVAcoB1QHVAQDTAQsgAUEBaiEBC0EGIRAM4wILA0ACQCABLQAAQfDGgIAAai0AAEEBRg0AIAEhAQyeAgsgAUEBaiIBIAJHDQALQeoAIRAM+wILAkAgASIBIAJGDQAgAUEBaiEBDAMLQesAIRAM+gILAkAgASIBIAJHDQBB7AAhEAz6AgsgAUEBaiEBDAELAkAgASIBIAJHDQBB7QAhEAz5AgsgAUEBaiEBC0EEIRAM3gILAkAgASIUIAJHDQBB7gAhEAz3AgsgFCEBAkACQAJAIBQtAABB8MiAgABqLQAAQX9qDgfUAdUB1gEAnAIBAtcBCyAUQQFqIQEMCgsgFEEBaiEBDM0BC0EAIRAgAEEANgIcIABBm5KAgAA2AhAgAEEHNgIMIAAgFEEBajYCFAz2AgsCQANAAkAgAS0AAEHwyICAAGotAAAiEEEERg0AAkACQCAQQX9qDgfSAdMB1AHZAQAEAdkBCyABIQFB2gAhEAzgAgsgAUEBaiEBQdwAIRAM3wILIAFBAWoiASACRw0AC0HvACEQDPYCCyABQQFqIQEMywELAkAgASIUIAJHDQBB8AAhEAz1AgsgFC0AAEEvRw3UASAUQQFqIQEMBgsCQCABIhQgAkcNAEHxACEQDPQCCwJAIBQtAAAiAUEvRw0AIBRBAWohAUHdACEQDNsCCyABQXZqIgRBFksN0wFBASAEdEGJgIACcUUN0wEMygILAkAgASIBIAJGDQAgAUEBaiEBQd4AIRAM2gILQfIAIRAM8gILAkAgASIUIAJHDQBB9AAhEAzyAgsgFCEBAkAgFC0AAEHwzICAAGotAABBf2oOA8kClAIA1AELQeEAIRAM2AILAkAgASIUIAJGDQADQAJAIBQtAABB8MqAgABqLQAAIgFBA0YNAAJAIAFBf2oOAssCANUBCyAUIQFB3wAhEAzaAgsgFEEBaiIUIAJHDQALQfMAIRAM8QILQfMAIRAM8AILAkAgASIBIAJGDQAgAEGPgICAADYCCCAAIAE2AgQgASEBQeAAIRAM1wILQfUAIRAM7wILAkAgASIBIAJHDQBB9gAhEAzvAgsgAEGPgICAADYCCCAAIAE2AgQgASEBC0EDIRAM1AILA0AgAS0AAEEgRw3DAiABQQFqIgEgAkcNAAtB9wAhEAzsAgsCQCABIgEgAkcNAEH4ACEQDOwCCyABLQAAQSBHDc4BIAFBAWohAQzvAQsgACABIgEgAhCsgICAACIQDc4BIAEhAQyOAgsCQCABIgQgAkcNAEH6ACEQDOoCCyAELQAAQcwARw3RASAEQQFqIQFBEyEQDM8BCwJAIAEiBCACRw0AQfsAIRAM6QILIAIgBGsgACgCACIBaiEUIAQgAWtBBWohEANAIAQtAAAgAUHwzoCAAGotAABHDdABIAFBBUYNzgEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBB+wAhEAzoAgsCQCABIgQgAkcNAEH8ACEQDOgCCwJAAkAgBC0AAEG9f2oODADRAdEB0QHRAdEB0QHRAdEB0QHRAQHRAQsgBEEBaiEBQeYAIRAMzwILIARBAWohAUHnACEQDM4CCwJAIAEiBCACRw0AQf0AIRAM5wILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQe3PgIAAai0AAEcNzwEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQf0AIRAM5wILIABBADYCACAQQQFqIQFBECEQDMwBCwJAIAEiBCACRw0AQf4AIRAM5gILIAIgBGsgACgCACIBaiEUIAQgAWtBBWohEAJAA0AgBC0AACABQfbOgIAAai0AAEcNzgEgAUEFRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQf4AIRAM5gILIABBADYCACAQQQFqIQFBFiEQDMsBCwJAIAEiBCACRw0AQf8AIRAM5QILIAIgBGsgACgCACIBaiEUIAQgAWtBA2ohEAJAA0AgBC0AACABQfzOgIAAai0AAEcNzQEgAUEDRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQf8AIRAM5QILIABBADYCACAQQQFqIQFBBSEQDMoBCwJAIAEiBCACRw0AQYABIRAM5AILIAQtAABB2QBHDcsBIARBAWohAUEIIRAMyQELAkAgASIEIAJHDQBBgQEhEAzjAgsCQAJAIAQtAABBsn9qDgMAzAEBzAELIARBAWohAUHrACEQDMoCCyAEQQFqIQFB7AAhEAzJAgsCQCABIgQgAkcNAEGCASEQDOICCwJAAkAgBC0AAEG4f2oOCADLAcsBywHLAcsBywEBywELIARBAWohAUHqACEQDMkCCyAEQQFqIQFB7QAhEAzIAgsCQCABIgQgAkcNAEGDASEQDOECCyACIARrIAAoAgAiAWohECAEIAFrQQJqIRQCQANAIAQtAAAgAUGAz4CAAGotAABHDckBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgEDYCAEGDASEQDOECC0EAIRAgAEEANgIAIBRBAWohAQzGAQsCQCABIgQgAkcNAEGEASEQDOACCyACIARrIAAoAgAiAWohFCAEIAFrQQRqIRACQANAIAQtAAAgAUGDz4CAAGotAABHDcgBIAFBBEYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGEASEQDOACCyAAQQA2AgAgEEEBaiEBQSMhEAzFAQsCQCABIgQgAkcNAEGFASEQDN8CCwJAAkAgBC0AAEG0f2oOCADIAcgByAHIAcgByAEByAELIARBAWohAUHvACEQDMYCCyAEQQFqIQFB8AAhEAzFAgsCQCABIgQgAkcNAEGGASEQDN4CCyAELQAAQcUARw3FASAEQQFqIQEMgwILAkAgASIEIAJHDQBBhwEhEAzdAgsgAiAEayAAKAIAIgFqIRQgBCABa0EDaiEQAkADQCAELQAAIAFBiM+AgABqLQAARw3FASABQQNGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBhwEhEAzdAgsgAEEANgIAIBBBAWohAUEtIRAMwgELAkAgASIEIAJHDQBBiAEhEAzcAgsgAiAEayAAKAIAIgFqIRQgBCABa0EIaiEQAkADQCAELQAAIAFB0M+AgABqLQAARw3EASABQQhGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBiAEhEAzcAgsgAEEANgIAIBBBAWohAUEpIRAMwQELAkAgASIBIAJHDQBBiQEhEAzbAgtBASEQIAEtAABB3wBHDcABIAFBAWohAQyBAgsCQCABIgQgAkcNAEGKASEQDNoCCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRADQCAELQAAIAFBjM+AgABqLQAARw3BASABQQFGDa8CIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQYoBIRAM2QILAkAgASIEIAJHDQBBiwEhEAzZAgsgAiAEayAAKAIAIgFqIRQgBCABa0ECaiEQAkADQCAELQAAIAFBjs+AgABqLQAARw3BASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBiwEhEAzZAgsgAEEANgIAIBBBAWohAUECIRAMvgELAkAgASIEIAJHDQBBjAEhEAzYAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFB8M+AgABqLQAARw3AASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBjAEhEAzYAgsgAEEANgIAIBBBAWohAUEfIRAMvQELAkAgASIEIAJHDQBBjQEhEAzXAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFB8s+AgABqLQAARw2/ASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBjQEhEAzXAgsgAEEANgIAIBBBAWohAUEJIRAMvAELAkAgASIEIAJHDQBBjgEhEAzWAgsCQAJAIAQtAABBt39qDgcAvwG/Ab8BvwG/AQG/AQsgBEEBaiEBQfgAIRAMvQILIARBAWohAUH5ACEQDLwCCwJAIAEiBCACRw0AQY8BIRAM1QILIAIgBGsgACgCACIBaiEUIAQgAWtBBWohEAJAA0AgBC0AACABQZHPgIAAai0AAEcNvQEgAUEFRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQY8BIRAM1QILIABBADYCACAQQQFqIQFBGCEQDLoBCwJAIAEiBCACRw0AQZABIRAM1AILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQZfPgIAAai0AAEcNvAEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZABIRAM1AILIABBADYCACAQQQFqIQFBFyEQDLkBCwJAIAEiBCACRw0AQZEBIRAM0wILIAIgBGsgACgCACIBaiEUIAQgAWtBBmohEAJAA0AgBC0AACABQZrPgIAAai0AAEcNuwEgAUEGRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZEBIRAM0wILIABBADYCACAQQQFqIQFBFSEQDLgBCwJAIAEiBCACRw0AQZIBIRAM0gILIAIgBGsgACgCACIBaiEUIAQgAWtBBWohEAJAA0AgBC0AACABQaHPgIAAai0AAEcNugEgAUEFRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZIBIRAM0gILIABBADYCACAQQQFqIQFBHiEQDLcBCwJAIAEiBCACRw0AQZMBIRAM0QILIAQtAABBzABHDbgBIARBAWohAUEKIRAMtgELAkAgBCACRw0AQZQBIRAM0AILAkACQCAELQAAQb9/ag4PALkBuQG5AbkBuQG5AbkBuQG5AbkBuQG5AbkBAbkBCyAEQQFqIQFB/gAhEAy3AgsgBEEBaiEBQf8AIRAMtgILAkAgBCACRw0AQZUBIRAMzwILAkACQCAELQAAQb9/ag4DALgBAbgBCyAEQQFqIQFB/QAhEAy2AgsgBEEBaiEEQYABIRAMtQILAkAgBCACRw0AQZYBIRAMzgILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQafPgIAAai0AAEcNtgEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZYBIRAMzgILIABBADYCACAQQQFqIQFBCyEQDLMBCwJAIAQgAkcNAEGXASEQDM0CCwJAAkACQAJAIAQtAABBU2oOIwC4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBAbgBuAG4AbgBuAECuAG4AbgBA7gBCyAEQQFqIQFB+wAhEAy2AgsgBEEBaiEBQfwAIRAMtQILIARBAWohBEGBASEQDLQCCyAEQQFqIQRBggEhEAyzAgsCQCAEIAJHDQBBmAEhEAzMAgsgAiAEayAAKAIAIgFqIRQgBCABa0EEaiEQAkADQCAELQAAIAFBqc+AgABqLQAARw20ASABQQRGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBmAEhEAzMAgsgAEEANgIAIBBBAWohAUEZIRAMsQELAkAgBCACRw0AQZkBIRAMywILIAIgBGsgACgCACIBaiEUIAQgAWtBBWohEAJAA0AgBC0AACABQa7PgIAAai0AAEcNswEgAUEFRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZkBIRAMywILIABBADYCACAQQQFqIQFBBiEQDLABCwJAIAQgAkcNAEGaASEQDMoCCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRACQANAIAQtAAAgAUG0z4CAAGotAABHDbIBIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGaASEQDMoCCyAAQQA2AgAgEEEBaiEBQRwhEAyvAQsCQCAEIAJHDQBBmwEhEAzJAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFBts+AgABqLQAARw2xASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBmwEhEAzJAgsgAEEANgIAIBBBAWohAUEnIRAMrgELAkAgBCACRw0AQZwBIRAMyAILAkACQCAELQAAQax/ag4CAAGxAQsgBEEBaiEEQYYBIRAMrwILIARBAWohBEGHASEQDK4CCwJAIAQgAkcNAEGdASEQDMcCCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRACQANAIAQtAAAgAUG4z4CAAGotAABHDa8BIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGdASEQDMcCCyAAQQA2AgAgEEEBaiEBQSYhEAysAQsCQCAEIAJHDQBBngEhEAzGAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFBus+AgABqLQAARw2uASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBngEhEAzGAgsgAEEANgIAIBBBAWohAUEDIRAMqwELAkAgBCACRw0AQZ8BIRAMxQILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQe3PgIAAai0AAEcNrQEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZ8BIRAMxQILIABBADYCACAQQQFqIQFBDCEQDKoBCwJAIAQgAkcNAEGgASEQDMQCCyACIARrIAAoAgAiAWohFCAEIAFrQQNqIRACQANAIAQtAAAgAUG8z4CAAGotAABHDawBIAFBA0YNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGgASEQDMQCCyAAQQA2AgAgEEEBaiEBQQ0hEAypAQsCQCAEIAJHDQBBoQEhEAzDAgsCQAJAIAQtAABBun9qDgsArAGsAawBrAGsAawBrAGsAawBAawBCyAEQQFqIQRBiwEhEAyqAgsgBEEBaiEEQYwBIRAMqQILAkAgBCACRw0AQaIBIRAMwgILIAQtAABB0ABHDakBIARBAWohBAzpAQsCQCAEIAJHDQBBowEhEAzBAgsCQAJAIAQtAABBt39qDgcBqgGqAaoBqgGqAQCqAQsgBEEBaiEEQY4BIRAMqAILIARBAWohAUEiIRAMpgELAkAgBCACRw0AQaQBIRAMwAILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQcDPgIAAai0AAEcNqAEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQaQBIRAMwAILIABBADYCACAQQQFqIQFBHSEQDKUBCwJAIAQgAkcNAEGlASEQDL8CCwJAAkAgBC0AAEGuf2oOAwCoAQGoAQsgBEEBaiEEQZABIRAMpgILIARBAWohAUEEIRAMpAELAkAgBCACRw0AQaYBIRAMvgILAkACQAJAAkACQCAELQAAQb9/ag4VAKoBqgGqAaoBqgGqAaoBqgGqAaoBAaoBqgECqgGqAQOqAaoBBKoBCyAEQQFqIQRBiAEhEAyoAgsgBEEBaiEEQYkBIRAMpwILIARBAWohBEGKASEQDKYCCyAEQQFqIQRBjwEhEAylAgsgBEEBaiEEQZEBIRAMpAILAkAgBCACRw0AQacBIRAMvQILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQe3PgIAAai0AAEcNpQEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQacBIRAMvQILIABBADYCACAQQQFqIQFBESEQDKIBCwJAIAQgAkcNAEGoASEQDLwCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHCz4CAAGotAABHDaQBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGoASEQDLwCCyAAQQA2AgAgEEEBaiEBQSwhEAyhAQsCQCAEIAJHDQBBqQEhEAy7AgsgAiAEayAAKAIAIgFqIRQgBCABa0EEaiEQAkADQCAELQAAIAFBxc+AgABqLQAARw2jASABQQRGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBqQEhEAy7AgsgAEEANgIAIBBBAWohAUErIRAMoAELAkAgBCACRw0AQaoBIRAMugILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQcrPgIAAai0AAEcNogEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQaoBIRAMugILIABBADYCACAQQQFqIQFBFCEQDJ8BCwJAIAQgAkcNAEGrASEQDLkCCwJAAkACQAJAIAQtAABBvn9qDg8AAQKkAaQBpAGkAaQBpAGkAaQBpAGkAaQBA6QBCyAEQQFqIQRBkwEhEAyiAgsgBEEBaiEEQZQBIRAMoQILIARBAWohBEGVASEQDKACCyAEQQFqIQRBlgEhEAyfAgsCQCAEIAJHDQBBrAEhEAy4AgsgBC0AAEHFAEcNnwEgBEEBaiEEDOABCwJAIAQgAkcNAEGtASEQDLcCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHNz4CAAGotAABHDZ8BIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGtASEQDLcCCyAAQQA2AgAgEEEBaiEBQQ4hEAycAQsCQCAEIAJHDQBBrgEhEAy2AgsgBC0AAEHQAEcNnQEgBEEBaiEBQSUhEAybAQsCQCAEIAJHDQBBrwEhEAy1AgsgAiAEayAAKAIAIgFqIRQgBCABa0EIaiEQAkADQCAELQAAIAFB0M+AgABqLQAARw2dASABQQhGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBrwEhEAy1AgsgAEEANgIAIBBBAWohAUEqIRAMmgELAkAgBCACRw0AQbABIRAMtAILAkACQCAELQAAQat/ag4LAJ0BnQGdAZ0BnQGdAZ0BnQGdAQGdAQsgBEEBaiEEQZoBIRAMmwILIARBAWohBEGbASEQDJoCCwJAIAQgAkcNAEGxASEQDLMCCwJAAkAgBC0AAEG/f2oOFACcAZwBnAGcAZwBnAGcAZwBnAGcAZwBnAGcAZwBnAGcAZwBnAEBnAELIARBAWohBEGZASEQDJoCCyAEQQFqIQRBnAEhEAyZAgsCQCAEIAJHDQBBsgEhEAyyAgsgAiAEayAAKAIAIgFqIRQgBCABa0EDaiEQAkADQCAELQAAIAFB2c+AgABqLQAARw2aASABQQNGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBsgEhEAyyAgsgAEEANgIAIBBBAWohAUEhIRAMlwELAkAgBCACRw0AQbMBIRAMsQILIAIgBGsgACgCACIBaiEUIAQgAWtBBmohEAJAA0AgBC0AACABQd3PgIAAai0AAEcNmQEgAUEGRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQbMBIRAMsQILIABBADYCACAQQQFqIQFBGiEQDJYBCwJAIAQgAkcNAEG0ASEQDLACCwJAAkACQCAELQAAQbt/ag4RAJoBmgGaAZoBmgGaAZoBmgGaAQGaAZoBmgGaAZoBApoBCyAEQQFqIQRBnQEhEAyYAgsgBEEBaiEEQZ4BIRAMlwILIARBAWohBEGfASEQDJYCCwJAIAQgAkcNAEG1ASEQDK8CCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRACQANAIAQtAAAgAUHkz4CAAGotAABHDZcBIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEG1ASEQDK8CCyAAQQA2AgAgEEEBaiEBQSghEAyUAQsCQCAEIAJHDQBBtgEhEAyuAgsgAiAEayAAKAIAIgFqIRQgBCABa0ECaiEQAkADQCAELQAAIAFB6s+AgABqLQAARw2WASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBtgEhEAyuAgsgAEEANgIAIBBBAWohAUEHIRAMkwELAkAgBCACRw0AQbcBIRAMrQILAkACQCAELQAAQbt/ag4OAJYBlgGWAZYBlgGWAZYBlgGWAZYBlgGWAQGWAQsgBEEBaiEEQaEBIRAMlAILIARBAWohBEGiASEQDJMCCwJAIAQgAkcNAEG4ASEQDKwCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHtz4CAAGotAABHDZQBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEG4ASEQDKwCCyAAQQA2AgAgEEEBaiEBQRIhEAyRAQsCQCAEIAJHDQBBuQEhEAyrAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFB8M+AgABqLQAARw2TASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBuQEhEAyrAgsgAEEANgIAIBBBAWohAUEgIRAMkAELAkAgBCACRw0AQboBIRAMqgILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQfLPgIAAai0AAEcNkgEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQboBIRAMqgILIABBADYCACAQQQFqIQFBDyEQDI8BCwJAIAQgAkcNAEG7ASEQDKkCCwJAAkAgBC0AAEG3f2oOBwCSAZIBkgGSAZIBAZIBCyAEQQFqIQRBpQEhEAyQAgsgBEEBaiEEQaYBIRAMjwILAkAgBCACRw0AQbwBIRAMqAILIAIgBGsgACgCACIBaiEUIAQgAWtBB2ohEAJAA0AgBC0AACABQfTPgIAAai0AAEcNkAEgAUEHRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQbwBIRAMqAILIABBADYCACAQQQFqIQFBGyEQDI0BCwJAIAQgAkcNAEG9ASEQDKcCCwJAAkACQCAELQAAQb5/ag4SAJEBkQGRAZEBkQGRAZEBkQGRAQGRAZEBkQGRAZEBkQECkQELIARBAWohBEGkASEQDI8CCyAEQQFqIQRBpwEhEAyOAgsgBEEBaiEEQagBIRAMjQILAkAgBCACRw0AQb4BIRAMpgILIAQtAABBzgBHDY0BIARBAWohBAzPAQsCQCAEIAJHDQBBvwEhEAylAgsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAELQAAQb9/ag4VAAECA5wBBAUGnAGcAZwBBwgJCgucAQwNDg+cAQsgBEEBaiEBQegAIRAMmgILIARBAWohAUHpACEQDJkCCyAEQQFqIQFB7gAhEAyYAgsgBEEBaiEBQfIAIRAMlwILIARBAWohAUHzACEQDJYCCyAEQQFqIQFB9gAhEAyVAgsgBEEBaiEBQfcAIRAMlAILIARBAWohAUH6ACEQDJMCCyAEQQFqIQRBgwEhEAySAgsgBEEBaiEEQYQBIRAMkQILIARBAWohBEGFASEQDJACCyAEQQFqIQRBkgEhEAyPAgsgBEEBaiEEQZgBIRAMjgILIARBAWohBEGgASEQDI0CCyAEQQFqIQRBowEhEAyMAgsgBEEBaiEEQaoBIRAMiwILAkAgBCACRg0AIABBkICAgAA2AgggACAENgIEQasBIRAMiwILQcABIRAMowILIAAgBSACEKqAgIAAIgENiwEgBSEBDFwLAkAgBiACRg0AIAZBAWohBQyNAQtBwgEhEAyhAgsDQAJAIBAtAABBdmoOBIwBAACPAQALIBBBAWoiECACRw0AC0HDASEQDKACCwJAIAcgAkYNACAAQZGAgIAANgIIIAAgBzYCBCAHIQFBASEQDIcCC0HEASEQDJ8CCwJAIAcgAkcNAEHFASEQDJ8CCwJAAkAgBy0AAEF2ag4EAc4BzgEAzgELIAdBAWohBgyNAQsgB0EBaiEFDIkBCwJAIAcgAkcNAEHGASEQDJ4CCwJAAkAgBy0AAEF2ag4XAY8BjwEBjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BAI8BCyAHQQFqIQcLQbABIRAMhAILAkAgCCACRw0AQcgBIRAMnQILIAgtAABBIEcNjQEgAEEAOwEyIAhBAWohAUGzASEQDIMCCyABIRcCQANAIBciByACRg0BIActAABBUGpB/wFxIhBBCk8NzAECQCAALwEyIhRBmTNLDQAgACAUQQpsIhQ7ATIgEEH//wNzIBRB/v8DcUkNACAHQQFqIRcgACAUIBBqIhA7ATIgEEH//wNxQegHSQ0BCwtBACEQIABBADYCHCAAQcGJgIAANgIQIABBDTYCDCAAIAdBAWo2AhQMnAILQccBIRAMmwILIAAgCCACEK6AgIAAIhBFDcoBIBBBFUcNjAEgAEHIATYCHCAAIAg2AhQgAEHJl4CAADYCECAAQRU2AgxBACEQDJoCCwJAIAkgAkcNAEHMASEQDJoCC0EAIRRBASEXQQEhFkEAIRACQAJAAkACQAJAAkACQAJAAkAgCS0AAEFQag4KlgGVAQABAgMEBQYIlwELQQIhEAwGC0EDIRAMBQtBBCEQDAQLQQUhEAwDC0EGIRAMAgtBByEQDAELQQghEAtBACEXQQAhFkEAIRQMjgELQQkhEEEBIRRBACEXQQAhFgyNAQsCQCAKIAJHDQBBzgEhEAyZAgsgCi0AAEEuRw2OASAKQQFqIQkMygELIAsgAkcNjgFB0AEhEAyXAgsCQCALIAJGDQAgAEGOgICAADYCCCAAIAs2AgRBtwEhEAz+AQtB0QEhEAyWAgsCQCAEIAJHDQBB0gEhEAyWAgsgAiAEayAAKAIAIhBqIRQgBCAQa0EEaiELA0AgBC0AACAQQfzPgIAAai0AAEcNjgEgEEEERg3pASAQQQFqIRAgBEEBaiIEIAJHDQALIAAgFDYCAEHSASEQDJUCCyAAIAwgAhCsgICAACIBDY0BIAwhAQy4AQsCQCAEIAJHDQBB1AEhEAyUAgsgAiAEayAAKAIAIhBqIRQgBCAQa0EBaiEMA0AgBC0AACAQQYHQgIAAai0AAEcNjwEgEEEBRg2OASAQQQFqIRAgBEEBaiIEIAJHDQALIAAgFDYCAEHUASEQDJMCCwJAIAQgAkcNAEHWASEQDJMCCyACIARrIAAoAgAiEGohFCAEIBBrQQJqIQsDQCAELQAAIBBBg9CAgABqLQAARw2OASAQQQJGDZABIBBBAWohECAEQQFqIgQgAkcNAAsgACAUNgIAQdYBIRAMkgILAkAgBCACRw0AQdcBIRAMkgILAkACQCAELQAAQbt/ag4QAI8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwEBjwELIARBAWohBEG7ASEQDPkBCyAEQQFqIQRBvAEhEAz4AQsCQCAEIAJHDQBB2AEhEAyRAgsgBC0AAEHIAEcNjAEgBEEBaiEEDMQBCwJAIAQgAkYNACAAQZCAgIAANgIIIAAgBDYCBEG+ASEQDPcBC0HZASEQDI8CCwJAIAQgAkcNAEHaASEQDI8CCyAELQAAQcgARg3DASAAQQE6ACgMuQELIABBAjoALyAAIAQgAhCmgICAACIQDY0BQcIBIRAM9AELIAAtAChBf2oOArcBuQG4AQsDQAJAIAQtAABBdmoOBACOAY4BAI4BCyAEQQFqIgQgAkcNAAtB3QEhEAyLAgsgAEEAOgAvIAAtAC1BBHFFDYQCCyAAQQA6AC8gAEEBOgA0IAEhAQyMAQsgEEEVRg3aASAAQQA2AhwgACABNgIUIABBp46AgAA2AhAgAEESNgIMQQAhEAyIAgsCQCAAIBAgAhC0gICAACIEDQAgECEBDIECCwJAIARBFUcNACAAQQM2AhwgACAQNgIUIABBsJiAgAA2AhAgAEEVNgIMQQAhEAyIAgsgAEEANgIcIAAgEDYCFCAAQaeOgIAANgIQIABBEjYCDEEAIRAMhwILIBBBFUYN1gEgAEEANgIcIAAgATYCFCAAQdqNgIAANgIQIABBFDYCDEEAIRAMhgILIAAoAgQhFyAAQQA2AgQgECARp2oiFiEBIAAgFyAQIBYgFBsiEBC1gICAACIURQ2NASAAQQc2AhwgACAQNgIUIAAgFDYCDEEAIRAMhQILIAAgAC8BMEGAAXI7ATAgASEBC0EqIRAM6gELIBBBFUYN0QEgAEEANgIcIAAgATYCFCAAQYOMgIAANgIQIABBEzYCDEEAIRAMggILIBBBFUYNzwEgAEEANgIcIAAgATYCFCAAQZqPgIAANgIQIABBIjYCDEEAIRAMgQILIAAoAgQhECAAQQA2AgQCQCAAIBAgARC3gICAACIQDQAgAUEBaiEBDI0BCyAAQQw2AhwgACAQNgIMIAAgAUEBajYCFEEAIRAMgAILIBBBFUYNzAEgAEEANgIcIAAgATYCFCAAQZqPgIAANgIQIABBIjYCDEEAIRAM/wELIAAoAgQhECAAQQA2AgQCQCAAIBAgARC3gICAACIQDQAgAUEBaiEBDIwBCyAAQQ02AhwgACAQNgIMIAAgAUEBajYCFEEAIRAM/gELIBBBFUYNyQEgAEEANgIcIAAgATYCFCAAQcaMgIAANgIQIABBIzYCDEEAIRAM/QELIAAoAgQhECAAQQA2AgQCQCAAIBAgARC5gICAACIQDQAgAUEBaiEBDIsBCyAAQQ42AhwgACAQNgIMIAAgAUEBajYCFEEAIRAM/AELIABBADYCHCAAIAE2AhQgAEHAlYCAADYCECAAQQI2AgxBACEQDPsBCyAQQRVGDcUBIABBADYCHCAAIAE2AhQgAEHGjICAADYCECAAQSM2AgxBACEQDPoBCyAAQRA2AhwgACABNgIUIAAgEDYCDEEAIRAM+QELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARC5gICAACIEDQAgAUEBaiEBDPEBCyAAQRE2AhwgACAENgIMIAAgAUEBajYCFEEAIRAM+AELIBBBFUYNwQEgAEEANgIcIAAgATYCFCAAQcaMgIAANgIQIABBIzYCDEEAIRAM9wELIAAoAgQhECAAQQA2AgQCQCAAIBAgARC5gICAACIQDQAgAUEBaiEBDIgBCyAAQRM2AhwgACAQNgIMIAAgAUEBajYCFEEAIRAM9gELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARC5gICAACIEDQAgAUEBaiEBDO0BCyAAQRQ2AhwgACAENgIMIAAgAUEBajYCFEEAIRAM9QELIBBBFUYNvQEgAEEANgIcIAAgATYCFCAAQZqPgIAANgIQIABBIjYCDEEAIRAM9AELIAAoAgQhECAAQQA2AgQCQCAAIBAgARC3gICAACIQDQAgAUEBaiEBDIYBCyAAQRY2AhwgACAQNgIMIAAgAUEBajYCFEEAIRAM8wELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARC3gICAACIEDQAgAUEBaiEBDOkBCyAAQRc2AhwgACAENgIMIAAgAUEBajYCFEEAIRAM8gELIABBADYCHCAAIAE2AhQgAEHNk4CAADYCECAAQQw2AgxBACEQDPEBC0IBIRELIBBBAWohAQJAIAApAyAiEkL//////////w9WDQAgACASQgSGIBGENwMgIAEhAQyEAQsgAEEANgIcIAAgATYCFCAAQa2JgIAANgIQIABBDDYCDEEAIRAM7wELIABBADYCHCAAIBA2AhQgAEHNk4CAADYCECAAQQw2AgxBACEQDO4BCyAAKAIEIRcgAEEANgIEIBAgEadqIhYhASAAIBcgECAWIBQbIhAQtYCAgAAiFEUNcyAAQQU2AhwgACAQNgIUIAAgFDYCDEEAIRAM7QELIABBADYCHCAAIBA2AhQgAEGqnICAADYCECAAQQ82AgxBACEQDOwBCyAAIBAgAhC0gICAACIBDQEgECEBC0EOIRAM0QELAkAgAUEVRw0AIABBAjYCHCAAIBA2AhQgAEGwmICAADYCECAAQRU2AgxBACEQDOoBCyAAQQA2AhwgACAQNgIUIABBp46AgAA2AhAgAEESNgIMQQAhEAzpAQsgAUEBaiEQAkAgAC8BMCIBQYABcUUNAAJAIAAgECACELuAgIAAIgENACAQIQEMcAsgAUEVRw26ASAAQQU2AhwgACAQNgIUIABB+ZeAgAA2AhAgAEEVNgIMQQAhEAzpAQsCQCABQaAEcUGgBEcNACAALQAtQQJxDQAgAEEANgIcIAAgEDYCFCAAQZaTgIAANgIQIABBBDYCDEEAIRAM6QELIAAgECACEL2AgIAAGiAQIQECQAJAAkACQAJAIAAgECACELOAgIAADhYCAQAEBAQEBAQEBAQEBAQEBAQEBAQDBAsgAEEBOgAuCyAAIAAvATBBwAByOwEwIBAhAQtBJiEQDNEBCyAAQSM2AhwgACAQNgIUIABBpZaAgAA2AhAgAEEVNgIMQQAhEAzpAQsgAEEANgIcIAAgEDYCFCAAQdWLgIAANgIQIABBETYCDEEAIRAM6AELIAAtAC1BAXFFDQFBwwEhEAzOAQsCQCANIAJGDQADQAJAIA0tAABBIEYNACANIQEMxAELIA1BAWoiDSACRw0AC0ElIRAM5wELQSUhEAzmAQsgACgCBCEEIABBADYCBCAAIAQgDRCvgICAACIERQ2tASAAQSY2AhwgACAENgIMIAAgDUEBajYCFEEAIRAM5QELIBBBFUYNqwEgAEEANgIcIAAgATYCFCAAQf2NgIAANgIQIABBHTYCDEEAIRAM5AELIABBJzYCHCAAIAE2AhQgACAQNgIMQQAhEAzjAQsgECEBQQEhFAJAAkACQAJAAkACQAJAIAAtACxBfmoOBwYFBQMBAgAFCyAAIAAvATBBCHI7ATAMAwtBAiEUDAELQQQhFAsgAEEBOgAsIAAgAC8BMCAUcjsBMAsgECEBC0ErIRAMygELIABBADYCHCAAIBA2AhQgAEGrkoCAADYCECAAQQs2AgxBACEQDOIBCyAAQQA2AhwgACABNgIUIABB4Y+AgAA2AhAgAEEKNgIMQQAhEAzhAQsgAEEAOgAsIBAhAQy9AQsgECEBQQEhFAJAAkACQAJAAkAgAC0ALEF7ag4EAwECAAULIAAgAC8BMEEIcjsBMAwDC0ECIRQMAQtBBCEUCyAAQQE6ACwgACAALwEwIBRyOwEwCyAQIQELQSkhEAzFAQsgAEEANgIcIAAgATYCFCAAQfCUgIAANgIQIABBAzYCDEEAIRAM3QELAkAgDi0AAEENRw0AIAAoAgQhASAAQQA2AgQCQCAAIAEgDhCxgICAACIBDQAgDkEBaiEBDHULIABBLDYCHCAAIAE2AgwgACAOQQFqNgIUQQAhEAzdAQsgAC0ALUEBcUUNAUHEASEQDMMBCwJAIA4gAkcNAEEtIRAM3AELAkACQANAAkAgDi0AAEF2ag4EAgAAAwALIA5BAWoiDiACRw0AC0EtIRAM3QELIAAoAgQhASAAQQA2AgQCQCAAIAEgDhCxgICAACIBDQAgDiEBDHQLIABBLDYCHCAAIA42AhQgACABNgIMQQAhEAzcAQsgACgCBCEBIABBADYCBAJAIAAgASAOELGAgIAAIgENACAOQQFqIQEMcwsgAEEsNgIcIAAgATYCDCAAIA5BAWo2AhRBACEQDNsBCyAAKAIEIQQgAEEANgIEIAAgBCAOELGAgIAAIgQNoAEgDiEBDM4BCyAQQSxHDQEgAUEBaiEQQQEhAQJAAkACQAJAAkAgAC0ALEF7ag4EAwECBAALIBAhAQwEC0ECIQEMAQtBBCEBCyAAQQE6ACwgACAALwEwIAFyOwEwIBAhAQwBCyAAIAAvATBBCHI7ATAgECEBC0E5IRAMvwELIABBADoALCABIQELQTQhEAy9AQsgACAALwEwQSByOwEwIAEhAQwCCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQsYCAgAAiBA0AIAEhAQzHAQsgAEE3NgIcIAAgATYCFCAAIAQ2AgxBACEQDNQBCyAAQQg6ACwgASEBC0EwIRAMuQELAkAgAC0AKEEBRg0AIAEhAQwECyAALQAtQQhxRQ2TASABIQEMAwsgAC0AMEEgcQ2UAUHFASEQDLcBCwJAIA8gAkYNAAJAA0ACQCAPLQAAQVBqIgFB/wFxQQpJDQAgDyEBQTUhEAy6AQsgACkDICIRQpmz5syZs+bMGVYNASAAIBFCCn4iETcDICARIAGtQv8BgyISQn+FVg0BIAAgESASfDcDICAPQQFqIg8gAkcNAAtBOSEQDNEBCyAAKAIEIQIgAEEANgIEIAAgAiAPQQFqIgQQsYCAgAAiAg2VASAEIQEMwwELQTkhEAzPAQsCQCAALwEwIgFBCHFFDQAgAC0AKEEBRw0AIAAtAC1BCHFFDZABCyAAIAFB9/sDcUGABHI7ATAgDyEBC0E3IRAMtAELIAAgAC8BMEEQcjsBMAyrAQsgEEEVRg2LASAAQQA2AhwgACABNgIUIABB8I6AgAA2AhAgAEEcNgIMQQAhEAzLAQsgAEHDADYCHCAAIAE2AgwgACANQQFqNgIUQQAhEAzKAQsCQCABLQAAQTpHDQAgACgCBCEQIABBADYCBAJAIAAgECABEK+AgIAAIhANACABQQFqIQEMYwsgAEHDADYCHCAAIBA2AgwgACABQQFqNgIUQQAhEAzKAQsgAEEANgIcIAAgATYCFCAAQbGRgIAANgIQIABBCjYCDEEAIRAMyQELIABBADYCHCAAIAE2AhQgAEGgmYCAADYCECAAQR42AgxBACEQDMgBCyAAQQA2AgALIABBgBI7ASogACAXQQFqIgEgAhCogICAACIQDQEgASEBC0HHACEQDKwBCyAQQRVHDYMBIABB0QA2AhwgACABNgIUIABB45eAgAA2AhAgAEEVNgIMQQAhEAzEAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMXgsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAzDAQsgAEEANgIcIAAgFDYCFCAAQcGogIAANgIQIABBBzYCDCAAQQA2AgBBACEQDMIBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxdCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDMEBC0EAIRAgAEEANgIcIAAgATYCFCAAQYCRgIAANgIQIABBCTYCDAzAAQsgEEEVRg19IABBADYCHCAAIAE2AhQgAEGUjYCAADYCECAAQSE2AgxBACEQDL8BC0EBIRZBACEXQQAhFEEBIRALIAAgEDoAKyABQQFqIQECQAJAIAAtAC1BEHENAAJAAkACQCAALQAqDgMBAAIECyAWRQ0DDAILIBQNAQwCCyAXRQ0BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQrYCAgAAiEA0AIAEhAQxcCyAAQdgANgIcIAAgATYCFCAAIBA2AgxBACEQDL4BCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQrYCAgAAiBA0AIAEhAQytAQsgAEHZADYCHCAAIAE2AhQgACAENgIMQQAhEAy9AQsgACgCBCEEIABBADYCBAJAIAAgBCABEK2AgIAAIgQNACABIQEMqwELIABB2gA2AhwgACABNgIUIAAgBDYCDEEAIRAMvAELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARCtgICAACIEDQAgASEBDKkBCyAAQdwANgIcIAAgATYCFCAAIAQ2AgxBACEQDLsBCwJAIAEtAABBUGoiEEH/AXFBCk8NACAAIBA6ACogAUEBaiEBQc8AIRAMogELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARCtgICAACIEDQAgASEBDKcBCyAAQd4ANgIcIAAgATYCFCAAIAQ2AgxBACEQDLoBCyAAQQA2AgAgF0EBaiEBAkAgAC0AKUEjTw0AIAEhAQxZCyAAQQA2AhwgACABNgIUIABB04mAgAA2AhAgAEEINgIMQQAhEAy5AQsgAEEANgIAC0EAIRAgAEEANgIcIAAgATYCFCAAQZCzgIAANgIQIABBCDYCDAy3AQsgAEEANgIAIBdBAWohAQJAIAAtAClBIUcNACABIQEMVgsgAEEANgIcIAAgATYCFCAAQZuKgIAANgIQIABBCDYCDEEAIRAMtgELIABBADYCACAXQQFqIQECQCAALQApIhBBXWpBC08NACABIQEMVQsCQCAQQQZLDQBBASAQdEHKAHFFDQAgASEBDFULQQAhECAAQQA2AhwgACABNgIUIABB94mAgAA2AhAgAEEINgIMDLUBCyAQQRVGDXEgAEEANgIcIAAgATYCFCAAQbmNgIAANgIQIABBGjYCDEEAIRAMtAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDFQLIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMswELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDE0LIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMsgELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDE0LIABB0wA2AhwgACABNgIUIAAgEDYCDEEAIRAMsQELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDFELIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMsAELIABBADYCHCAAIAE2AhQgAEHGioCAADYCECAAQQc2AgxBACEQDK8BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxJCyAAQdIANgIcIAAgATYCFCAAIBA2AgxBACEQDK4BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxJCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDK0BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDKwBCyAAQQA2AhwgACABNgIUIABB3IiAgAA2AhAgAEEHNgIMQQAhEAyrAQsgEEE/Rw0BIAFBAWohAQtBBSEQDJABC0EAIRAgAEEANgIcIAAgATYCFCAAQf2SgIAANgIQIABBBzYCDAyoAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMQgsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAynAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMQgsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAymAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMRgsgAEHlADYCHCAAIAE2AhQgACAQNgIMQQAhEAylAQsgACgCBCEBIABBADYCBAJAIAAgASAUEKeAgIAAIgENACAUIQEMPwsgAEHSADYCHCAAIBQ2AhQgACABNgIMQQAhEAykAQsgACgCBCEBIABBADYCBAJAIAAgASAUEKeAgIAAIgENACAUIQEMPwsgAEHTADYCHCAAIBQ2AhQgACABNgIMQQAhEAyjAQsgACgCBCEBIABBADYCBAJAIAAgASAUEKeAgIAAIgENACAUIQEMQwsgAEHlADYCHCAAIBQ2AhQgACABNgIMQQAhEAyiAQsgAEEANgIcIAAgFDYCFCAAQcOPgIAANgIQIABBBzYCDEEAIRAMoQELIABBADYCHCAAIAE2AhQgAEHDj4CAADYCECAAQQc2AgxBACEQDKABC0EAIRAgAEEANgIcIAAgFDYCFCAAQYycgIAANgIQIABBBzYCDAyfAQsgAEEANgIcIAAgFDYCFCAAQYycgIAANgIQIABBBzYCDEEAIRAMngELIABBADYCHCAAIBQ2AhQgAEH+kYCAADYCECAAQQc2AgxBACEQDJ0BCyAAQQA2AhwgACABNgIUIABBjpuAgAA2AhAgAEEGNgIMQQAhEAycAQsgEEEVRg1XIABBADYCHCAAIAE2AhQgAEHMjoCAADYCECAAQSA2AgxBACEQDJsBCyAAQQA2AgAgEEEBaiEBQSQhEAsgACAQOgApIAAoAgQhECAAQQA2AgQgACAQIAEQq4CAgAAiEA1UIAEhAQw+CyAAQQA2AgALQQAhECAAQQA2AhwgACAENgIUIABB8ZuAgAA2AhAgAEEGNgIMDJcBCyABQRVGDVAgAEEANgIcIAAgBTYCFCAAQfCMgIAANgIQIABBGzYCDEEAIRAMlgELIAAoAgQhBSAAQQA2AgQgACAFIBAQqYCAgAAiBQ0BIBBBAWohBQtBrQEhEAx7CyAAQcEBNgIcIAAgBTYCDCAAIBBBAWo2AhRBACEQDJMBCyAAKAIEIQYgAEEANgIEIAAgBiAQEKmAgIAAIgYNASAQQQFqIQYLQa4BIRAMeAsgAEHCATYCHCAAIAY2AgwgACAQQQFqNgIUQQAhEAyQAQsgAEEANgIcIAAgBzYCFCAAQZeLgIAANgIQIABBDTYCDEEAIRAMjwELIABBADYCHCAAIAg2AhQgAEHjkICAADYCECAAQQk2AgxBACEQDI4BCyAAQQA2AhwgACAINgIUIABBlI2AgAA2AhAgAEEhNgIMQQAhEAyNAQtBASEWQQAhF0EAIRRBASEQCyAAIBA6ACsgCUEBaiEIAkACQCAALQAtQRBxDQACQAJAAkAgAC0AKg4DAQACBAsgFkUNAwwCCyAUDQEMAgsgF0UNAQsgACgCBCEQIABBADYCBCAAIBAgCBCtgICAACIQRQ09IABByQE2AhwgACAINgIUIAAgEDYCDEEAIRAMjAELIAAoAgQhBCAAQQA2AgQgACAEIAgQrYCAgAAiBEUNdiAAQcoBNgIcIAAgCDYCFCAAIAQ2AgxBACEQDIsBCyAAKAIEIQQgAEEANgIEIAAgBCAJEK2AgIAAIgRFDXQgAEHLATYCHCAAIAk2AhQgACAENgIMQQAhEAyKAQsgACgCBCEEIABBADYCBCAAIAQgChCtgICAACIERQ1yIABBzQE2AhwgACAKNgIUIAAgBDYCDEEAIRAMiQELAkAgCy0AAEFQaiIQQf8BcUEKTw0AIAAgEDoAKiALQQFqIQpBtgEhEAxwCyAAKAIEIQQgAEEANgIEIAAgBCALEK2AgIAAIgRFDXAgAEHPATYCHCAAIAs2AhQgACAENgIMQQAhEAyIAQsgAEEANgIcIAAgBDYCFCAAQZCzgIAANgIQIABBCDYCDCAAQQA2AgBBACEQDIcBCyABQRVGDT8gAEEANgIcIAAgDDYCFCAAQcyOgIAANgIQIABBIDYCDEEAIRAMhgELIABBgQQ7ASggACgCBCEQIABCADcDACAAIBAgDEEBaiIMEKuAgIAAIhBFDTggAEHTATYCHCAAIAw2AhQgACAQNgIMQQAhEAyFAQsgAEEANgIAC0EAIRAgAEEANgIcIAAgBDYCFCAAQdibgIAANgIQIABBCDYCDAyDAQsgACgCBCEQIABCADcDACAAIBAgC0EBaiILEKuAgIAAIhANAUHGASEQDGkLIABBAjoAKAxVCyAAQdUBNgIcIAAgCzYCFCAAIBA2AgxBACEQDIABCyAQQRVGDTcgAEEANgIcIAAgBDYCFCAAQaSMgIAANgIQIABBEDYCDEEAIRAMfwsgAC0ANEEBRw00IAAgBCACELyAgIAAIhBFDTQgEEEVRw01IABB3AE2AhwgACAENgIUIABB1ZaAgAA2AhAgAEEVNgIMQQAhEAx+C0EAIRAgAEEANgIcIABBr4uAgAA2AhAgAEECNgIMIAAgFEEBajYCFAx9C0EAIRAMYwtBAiEQDGILQQ0hEAxhC0EPIRAMYAtBJSEQDF8LQRMhEAxeC0EVIRAMXQtBFiEQDFwLQRchEAxbC0EYIRAMWgtBGSEQDFkLQRohEAxYC0EbIRAMVwtBHCEQDFYLQR0hEAxVC0EfIRAMVAtBISEQDFMLQSMhEAxSC0HGACEQDFELQS4hEAxQC0EvIRAMTwtBOyEQDE4LQT0hEAxNC0HIACEQDEwLQckAIRAMSwtBywAhEAxKC0HMACEQDEkLQc4AIRAMSAtB0QAhEAxHC0HVACEQDEYLQdgAIRAMRQtB2QAhEAxEC0HbACEQDEMLQeQAIRAMQgtB5QAhEAxBC0HxACEQDEALQfQAIRAMPwtBjQEhEAw+C0GXASEQDD0LQakBIRAMPAtBrAEhEAw7C0HAASEQDDoLQbkBIRAMOQtBrwEhEAw4C0GxASEQDDcLQbIBIRAMNgtBtAEhEAw1C0G1ASEQDDQLQboBIRAMMwtBvQEhEAwyC0G/ASEQDDELQcEBIRAMMAsgAEEANgIcIAAgBDYCFCAAQemLgIAANgIQIABBHzYCDEEAIRAMSAsgAEHbATYCHCAAIAQ2AhQgAEH6loCAADYCECAAQRU2AgxBACEQDEcLIABB+AA2AhwgACAMNgIUIABBypiAgAA2AhAgAEEVNgIMQQAhEAxGCyAAQdEANgIcIAAgBTYCFCAAQbCXgIAANgIQIABBFTYCDEEAIRAMRQsgAEH5ADYCHCAAIAE2AhQgACAQNgIMQQAhEAxECyAAQfgANgIcIAAgATYCFCAAQcqYgIAANgIQIABBFTYCDEEAIRAMQwsgAEHkADYCHCAAIAE2AhQgAEHjl4CAADYCECAAQRU2AgxBACEQDEILIABB1wA2AhwgACABNgIUIABByZeAgAA2AhAgAEEVNgIMQQAhEAxBCyAAQQA2AhwgACABNgIUIABBuY2AgAA2AhAgAEEaNgIMQQAhEAxACyAAQcIANgIcIAAgATYCFCAAQeOYgIAANgIQIABBFTYCDEEAIRAMPwsgAEEANgIEIAAgDyAPELGAgIAAIgRFDQEgAEE6NgIcIAAgBDYCDCAAIA9BAWo2AhRBACEQDD4LIAAoAgQhBCAAQQA2AgQCQCAAIAQgARCxgICAACIERQ0AIABBOzYCHCAAIAQ2AgwgACABQQFqNgIUQQAhEAw+CyABQQFqIQEMLQsgD0EBaiEBDC0LIABBADYCHCAAIA82AhQgAEHkkoCAADYCECAAQQQ2AgxBACEQDDsLIABBNjYCHCAAIAQ2AhQgACACNgIMQQAhEAw6CyAAQS42AhwgACAONgIUIAAgBDYCDEEAIRAMOQsgAEHQADYCHCAAIAE2AhQgAEGRmICAADYCECAAQRU2AgxBACEQDDgLIA1BAWohAQwsCyAAQRU2AhwgACABNgIUIABBgpmAgAA2AhAgAEEVNgIMQQAhEAw2CyAAQRs2AhwgACABNgIUIABBkZeAgAA2AhAgAEEVNgIMQQAhEAw1CyAAQQ82AhwgACABNgIUIABBkZeAgAA2AhAgAEEVNgIMQQAhEAw0CyAAQQs2AhwgACABNgIUIABBkZeAgAA2AhAgAEEVNgIMQQAhEAwzCyAAQRo2AhwgACABNgIUIABBgpmAgAA2AhAgAEEVNgIMQQAhEAwyCyAAQQs2AhwgACABNgIUIABBgpmAgAA2AhAgAEEVNgIMQQAhEAwxCyAAQQo2AhwgACABNgIUIABB5JaAgAA2AhAgAEEVNgIMQQAhEAwwCyAAQR42AhwgACABNgIUIABB+ZeAgAA2AhAgAEEVNgIMQQAhEAwvCyAAQQA2AhwgACAQNgIUIABB2o2AgAA2AhAgAEEUNgIMQQAhEAwuCyAAQQQ2AhwgACABNgIUIABBsJiAgAA2AhAgAEEVNgIMQQAhEAwtCyAAQQA2AgAgC0EBaiELC0G4ASEQDBILIABBADYCACAQQQFqIQFB9QAhEAwRCyABIQECQCAALQApQQVHDQBB4wAhEAwRC0HiACEQDBALQQAhECAAQQA2AhwgAEHkkYCAADYCECAAQQc2AgwgACAUQQFqNgIUDCgLIABBADYCACAXQQFqIQFBwAAhEAwOC0EBIQELIAAgAToALCAAQQA2AgAgF0EBaiEBC0EoIRAMCwsgASEBC0E4IRAMCQsCQCABIg8gAkYNAANAAkAgDy0AAEGAvoCAAGotAAAiAUEBRg0AIAFBAkcNAyAPQQFqIQEMBAsgD0EBaiIPIAJHDQALQT4hEAwiC0E+IRAMIQsgAEEAOgAsIA8hAQwBC0ELIRAMBgtBOiEQDAULIAFBAWohAUEtIRAMBAsgACABOgAsIABBADYCACAWQQFqIQFBDCEQDAMLIABBADYCACAXQQFqIQFBCiEQDAILIABBADYCAAsgAEEAOgAsIA0hAUEJIRAMAAsLQQAhECAAQQA2AhwgACALNgIUIABBzZCAgAA2AhAgAEEJNgIMDBcLQQAhECAAQQA2AhwgACAKNgIUIABB6YqAgAA2AhAgAEEJNgIMDBYLQQAhECAAQQA2AhwgACAJNgIUIABBt5CAgAA2AhAgAEEJNgIMDBULQQAhECAAQQA2AhwgACAINgIUIABBnJGAgAA2AhAgAEEJNgIMDBQLQQAhECAAQQA2AhwgACABNgIUIABBzZCAgAA2AhAgAEEJNgIMDBMLQQAhECAAQQA2AhwgACABNgIUIABB6YqAgAA2AhAgAEEJNgIMDBILQQAhECAAQQA2AhwgACABNgIUIABBt5CAgAA2AhAgAEEJNgIMDBELQQAhECAAQQA2AhwgACABNgIUIABBnJGAgAA2AhAgAEEJNgIMDBALQQAhECAAQQA2AhwgACABNgIUIABBl5WAgAA2AhAgAEEPNgIMDA8LQQAhECAAQQA2AhwgACABNgIUIABBl5WAgAA2AhAgAEEPNgIMDA4LQQAhECAAQQA2AhwgACABNgIUIABBwJKAgAA2AhAgAEELNgIMDA0LQQAhECAAQQA2AhwgACABNgIUIABBlYmAgAA2AhAgAEELNgIMDAwLQQAhECAAQQA2AhwgACABNgIUIABB4Y+AgAA2AhAgAEEKNgIMDAsLQQAhECAAQQA2AhwgACABNgIUIABB+4+AgAA2AhAgAEEKNgIMDAoLQQAhECAAQQA2AhwgACABNgIUIABB8ZmAgAA2AhAgAEECNgIMDAkLQQAhECAAQQA2AhwgACABNgIUIABBxJSAgAA2AhAgAEECNgIMDAgLQQAhECAAQQA2AhwgACABNgIUIABB8pWAgAA2AhAgAEECNgIMDAcLIABBAjYCHCAAIAE2AhQgAEGcmoCAADYCECAAQRY2AgxBACEQDAYLQQEhEAwFC0HUACEQIAEiBCACRg0EIANBCGogACAEIAJB2MKAgABBChDFgICAACADKAIMIQQgAygCCA4DAQQCAAsQyoCAgAAACyAAQQA2AhwgAEG1moCAADYCECAAQRc2AgwgACAEQQFqNgIUQQAhEAwCCyAAQQA2AhwgACAENgIUIABBypqAgAA2AhAgAEEJNgIMQQAhEAwBCwJAIAEiBCACRw0AQSIhEAwBCyAAQYmAgIAANgIIIAAgBDYCBEEhIRALIANBEGokgICAgAAgEAuvAQECfyABKAIAIQYCQAJAIAIgA0YNACAEIAZqIQQgBiADaiACayEHIAIgBkF/cyAFaiIGaiEFA0ACQCACLQAAIAQtAABGDQBBAiEEDAMLAkAgBg0AQQAhBCAFIQIMAwsgBkF/aiEGIARBAWohBCACQQFqIgIgA0cNAAsgByEGIAMhAgsgAEEBNgIAIAEgBjYCACAAIAI2AgQPCyABQQA2AgAgACAENgIAIAAgAjYCBAsKACAAEMeAgIAAC/I2AQt/I4CAgIAAQRBrIgEkgICAgAACQEEAKAKg0ICAAA0AQQAQy4CAgABBgNSEgABrIgJB2QBJDQBBACEDAkBBACgC4NOAgAAiBA0AQQBCfzcC7NOAgABBAEKAgISAgIDAADcC5NOAgABBACABQQhqQXBxQdiq1aoFcyIENgLg04CAAEEAQQA2AvTTgIAAQQBBADYCxNOAgAALQQAgAjYCzNOAgABBAEGA1ISAADYCyNOAgABBAEGA1ISAADYCmNCAgABBACAENgKs0ICAAEEAQX82AqjQgIAAA0AgA0HE0ICAAGogA0G40ICAAGoiBDYCACAEIANBsNCAgABqIgU2AgAgA0G80ICAAGogBTYCACADQczQgIAAaiADQcDQgIAAaiIFNgIAIAUgBDYCACADQdTQgIAAaiADQcjQgIAAaiIENgIAIAQgBTYCACADQdDQgIAAaiAENgIAIANBIGoiA0GAAkcNAAtBgNSEgABBeEGA1ISAAGtBD3FBAEGA1ISAAEEIakEPcRsiA2oiBEEEaiACQUhqIgUgA2siA0EBcjYCAEEAQQAoAvDTgIAANgKk0ICAAEEAIAM2ApTQgIAAQQAgBDYCoNCAgABBgNSEgAAgBWpBODYCBAsCQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAEHsAUsNAAJAQQAoAojQgIAAIgZBECAAQRNqQXBxIABBC0kbIgJBA3YiBHYiA0EDcUUNAAJAAkAgA0EBcSAEckEBcyIFQQN0IgRBsNCAgABqIgMgBEG40ICAAGooAgAiBCgCCCICRw0AQQAgBkF+IAV3cTYCiNCAgAAMAQsgAyACNgIIIAIgAzYCDAsgBEEIaiEDIAQgBUEDdCIFQQNyNgIEIAQgBWoiBCAEKAIEQQFyNgIEDAwLIAJBACgCkNCAgAAiB00NAQJAIANFDQACQAJAIAMgBHRBAiAEdCIDQQAgA2tycSIDQQAgA2txQX9qIgMgA0EMdkEQcSIDdiIEQQV2QQhxIgUgA3IgBCAFdiIDQQJ2QQRxIgRyIAMgBHYiA0EBdkECcSIEciADIAR2IgNBAXZBAXEiBHIgAyAEdmoiBEEDdCIDQbDQgIAAaiIFIANBuNCAgABqKAIAIgMoAggiAEcNAEEAIAZBfiAEd3EiBjYCiNCAgAAMAQsgBSAANgIIIAAgBTYCDAsgAyACQQNyNgIEIAMgBEEDdCIEaiAEIAJrIgU2AgAgAyACaiIAIAVBAXI2AgQCQCAHRQ0AIAdBeHFBsNCAgABqIQJBACgCnNCAgAAhBAJAAkAgBkEBIAdBA3Z0IghxDQBBACAGIAhyNgKI0ICAACACIQgMAQsgAigCCCEICyAIIAQ2AgwgAiAENgIIIAQgAjYCDCAEIAg2AggLIANBCGohA0EAIAA2ApzQgIAAQQAgBTYCkNCAgAAMDAtBACgCjNCAgAAiCUUNASAJQQAgCWtxQX9qIgMgA0EMdkEQcSIDdiIEQQV2QQhxIgUgA3IgBCAFdiIDQQJ2QQRxIgRyIAMgBHYiA0EBdkECcSIEciADIAR2IgNBAXZBAXEiBHIgAyAEdmpBAnRBuNKAgABqKAIAIgAoAgRBeHEgAmshBCAAIQUCQANAAkAgBSgCECIDDQAgBUEUaigCACIDRQ0CCyADKAIEQXhxIAJrIgUgBCAFIARJIgUbIQQgAyAAIAUbIQAgAyEFDAALCyAAKAIYIQoCQCAAKAIMIgggAEYNACAAKAIIIgNBACgCmNCAgABJGiAIIAM2AgggAyAINgIMDAsLAkAgAEEUaiIFKAIAIgMNACAAKAIQIgNFDQMgAEEQaiEFCwNAIAUhCyADIghBFGoiBSgCACIDDQAgCEEQaiEFIAgoAhAiAw0ACyALQQA2AgAMCgtBfyECIABBv39LDQAgAEETaiIDQXBxIQJBACgCjNCAgAAiB0UNAEEAIQsCQCACQYACSQ0AQR8hCyACQf///wdLDQAgA0EIdiIDIANBgP4/akEQdkEIcSIDdCIEIARBgOAfakEQdkEEcSIEdCIFIAVBgIAPakEQdkECcSIFdEEPdiADIARyIAVyayIDQQF0IAIgA0EVanZBAXFyQRxqIQsLQQAgAmshBAJAAkACQAJAIAtBAnRBuNKAgABqKAIAIgUNAEEAIQNBACEIDAELQQAhAyACQQBBGSALQQF2ayALQR9GG3QhAEEAIQgDQAJAIAUoAgRBeHEgAmsiBiAETw0AIAYhBCAFIQggBg0AQQAhBCAFIQggBSEDDAMLIAMgBUEUaigCACIGIAYgBSAAQR12QQRxakEQaigCACIFRhsgAyAGGyEDIABBAXQhACAFDQALCwJAIAMgCHINAEEAIQhBAiALdCIDQQAgA2tyIAdxIgNFDQMgA0EAIANrcUF/aiIDIANBDHZBEHEiA3YiBUEFdkEIcSIAIANyIAUgAHYiA0ECdkEEcSIFciADIAV2IgNBAXZBAnEiBXIgAyAFdiIDQQF2QQFxIgVyIAMgBXZqQQJ0QbjSgIAAaigCACEDCyADRQ0BCwNAIAMoAgRBeHEgAmsiBiAESSEAAkAgAygCECIFDQAgA0EUaigCACEFCyAGIAQgABshBCADIAggABshCCAFIQMgBQ0ACwsgCEUNACAEQQAoApDQgIAAIAJrTw0AIAgoAhghCwJAIAgoAgwiACAIRg0AIAgoAggiA0EAKAKY0ICAAEkaIAAgAzYCCCADIAA2AgwMCQsCQCAIQRRqIgUoAgAiAw0AIAgoAhAiA0UNAyAIQRBqIQULA0AgBSEGIAMiAEEUaiIFKAIAIgMNACAAQRBqIQUgACgCECIDDQALIAZBADYCAAwICwJAQQAoApDQgIAAIgMgAkkNAEEAKAKc0ICAACEEAkACQCADIAJrIgVBEEkNACAEIAJqIgAgBUEBcjYCBEEAIAU2ApDQgIAAQQAgADYCnNCAgAAgBCADaiAFNgIAIAQgAkEDcjYCBAwBCyAEIANBA3I2AgQgBCADaiIDIAMoAgRBAXI2AgRBAEEANgKc0ICAAEEAQQA2ApDQgIAACyAEQQhqIQMMCgsCQEEAKAKU0ICAACIAIAJNDQBBACgCoNCAgAAiAyACaiIEIAAgAmsiBUEBcjYCBEEAIAU2ApTQgIAAQQAgBDYCoNCAgAAgAyACQQNyNgIEIANBCGohAwwKCwJAAkBBACgC4NOAgABFDQBBACgC6NOAgAAhBAwBC0EAQn83AuzTgIAAQQBCgICEgICAwAA3AuTTgIAAQQAgAUEMakFwcUHYqtWqBXM2AuDTgIAAQQBBADYC9NOAgABBAEEANgLE04CAAEGAgAQhBAtBACEDAkAgBCACQccAaiIHaiIGQQAgBGsiC3EiCCACSw0AQQBBMDYC+NOAgAAMCgsCQEEAKALA04CAACIDRQ0AAkBBACgCuNOAgAAiBCAIaiIFIARNDQAgBSADTQ0BC0EAIQNBAEEwNgL404CAAAwKC0EALQDE04CAAEEEcQ0EAkACQAJAQQAoAqDQgIAAIgRFDQBByNOAgAAhAwNAAkAgAygCACIFIARLDQAgBSADKAIEaiAESw0DCyADKAIIIgMNAAsLQQAQy4CAgAAiAEF/Rg0FIAghBgJAQQAoAuTTgIAAIgNBf2oiBCAAcUUNACAIIABrIAQgAGpBACADa3FqIQYLIAYgAk0NBSAGQf7///8HSw0FAkBBACgCwNOAgAAiA0UNAEEAKAK404CAACIEIAZqIgUgBE0NBiAFIANLDQYLIAYQy4CAgAAiAyAARw0BDAcLIAYgAGsgC3EiBkH+////B0sNBCAGEMuAgIAAIgAgAygCACADKAIEakYNAyAAIQMLAkAgA0F/Rg0AIAJByABqIAZNDQACQCAHIAZrQQAoAujTgIAAIgRqQQAgBGtxIgRB/v///wdNDQAgAyEADAcLAkAgBBDLgICAAEF/Rg0AIAQgBmohBiADIQAMBwtBACAGaxDLgICAABoMBAsgAyEAIANBf0cNBQwDC0EAIQgMBwtBACEADAULIABBf0cNAgtBAEEAKALE04CAAEEEcjYCxNOAgAALIAhB/v///wdLDQEgCBDLgICAACEAQQAQy4CAgAAhAyAAQX9GDQEgA0F/Rg0BIAAgA08NASADIABrIgYgAkE4ak0NAQtBAEEAKAK404CAACAGaiIDNgK404CAAAJAIANBACgCvNOAgABNDQBBACADNgK804CAAAsCQAJAAkACQEEAKAKg0ICAACIERQ0AQcjTgIAAIQMDQCAAIAMoAgAiBSADKAIEIghqRg0CIAMoAggiAw0ADAMLCwJAAkBBACgCmNCAgAAiA0UNACAAIANPDQELQQAgADYCmNCAgAALQQAhA0EAIAY2AszTgIAAQQAgADYCyNOAgABBAEF/NgKo0ICAAEEAQQAoAuDTgIAANgKs0ICAAEEAQQA2AtTTgIAAA0AgA0HE0ICAAGogA0G40ICAAGoiBDYCACAEIANBsNCAgABqIgU2AgAgA0G80ICAAGogBTYCACADQczQgIAAaiADQcDQgIAAaiIFNgIAIAUgBDYCACADQdTQgIAAaiADQcjQgIAAaiIENgIAIAQgBTYCACADQdDQgIAAaiAENgIAIANBIGoiA0GAAkcNAAsgAEF4IABrQQ9xQQAgAEEIakEPcRsiA2oiBCAGQUhqIgUgA2siA0EBcjYCBEEAQQAoAvDTgIAANgKk0ICAAEEAIAM2ApTQgIAAQQAgBDYCoNCAgAAgACAFakE4NgIEDAILIAMtAAxBCHENACAEIAVJDQAgBCAATw0AIARBeCAEa0EPcUEAIARBCGpBD3EbIgVqIgBBACgClNCAgAAgBmoiCyAFayIFQQFyNgIEIAMgCCAGajYCBEEAQQAoAvDTgIAANgKk0ICAAEEAIAU2ApTQgIAAQQAgADYCoNCAgAAgBCALakE4NgIEDAELAkAgAEEAKAKY0ICAACIITw0AQQAgADYCmNCAgAAgACEICyAAIAZqIQVByNOAgAAhAwJAAkACQAJAAkACQAJAA0AgAygCACAFRg0BIAMoAggiAw0ADAILCyADLQAMQQhxRQ0BC0HI04CAACEDA0ACQCADKAIAIgUgBEsNACAFIAMoAgRqIgUgBEsNAwsgAygCCCEDDAALCyADIAA2AgAgAyADKAIEIAZqNgIEIABBeCAAa0EPcUEAIABBCGpBD3EbaiILIAJBA3I2AgQgBUF4IAVrQQ9xQQAgBUEIakEPcRtqIgYgCyACaiICayEDAkAgBiAERw0AQQAgAjYCoNCAgABBAEEAKAKU0ICAACADaiIDNgKU0ICAACACIANBAXI2AgQMAwsCQCAGQQAoApzQgIAARw0AQQAgAjYCnNCAgABBAEEAKAKQ0ICAACADaiIDNgKQ0ICAACACIANBAXI2AgQgAiADaiADNgIADAMLAkAgBigCBCIEQQNxQQFHDQAgBEF4cSEHAkACQCAEQf8BSw0AIAYoAggiBSAEQQN2IghBA3RBsNCAgABqIgBGGgJAIAYoAgwiBCAFRw0AQQBBACgCiNCAgABBfiAId3E2AojQgIAADAILIAQgAEYaIAQgBTYCCCAFIAQ2AgwMAQsgBigCGCEJAkACQCAGKAIMIgAgBkYNACAGKAIIIgQgCEkaIAAgBDYCCCAEIAA2AgwMAQsCQCAGQRRqIgQoAgAiBQ0AIAZBEGoiBCgCACIFDQBBACEADAELA0AgBCEIIAUiAEEUaiIEKAIAIgUNACAAQRBqIQQgACgCECIFDQALIAhBADYCAAsgCUUNAAJAAkAgBiAGKAIcIgVBAnRBuNKAgABqIgQoAgBHDQAgBCAANgIAIAANAUEAQQAoAozQgIAAQX4gBXdxNgKM0ICAAAwCCyAJQRBBFCAJKAIQIAZGG2ogADYCACAARQ0BCyAAIAk2AhgCQCAGKAIQIgRFDQAgACAENgIQIAQgADYCGAsgBigCFCIERQ0AIABBFGogBDYCACAEIAA2AhgLIAcgA2ohAyAGIAdqIgYoAgQhBAsgBiAEQX5xNgIEIAIgA2ogAzYCACACIANBAXI2AgQCQCADQf8BSw0AIANBeHFBsNCAgABqIQQCQAJAQQAoAojQgIAAIgVBASADQQN2dCIDcQ0AQQAgBSADcjYCiNCAgAAgBCEDDAELIAQoAgghAwsgAyACNgIMIAQgAjYCCCACIAQ2AgwgAiADNgIIDAMLQR8hBAJAIANB////B0sNACADQQh2IgQgBEGA/j9qQRB2QQhxIgR0IgUgBUGA4B9qQRB2QQRxIgV0IgAgAEGAgA9qQRB2QQJxIgB0QQ92IAQgBXIgAHJrIgRBAXQgAyAEQRVqdkEBcXJBHGohBAsgAiAENgIcIAJCADcCECAEQQJ0QbjSgIAAaiEFAkBBACgCjNCAgAAiAEEBIAR0IghxDQAgBSACNgIAQQAgACAIcjYCjNCAgAAgAiAFNgIYIAIgAjYCCCACIAI2AgwMAwsgA0EAQRkgBEEBdmsgBEEfRht0IQQgBSgCACEAA0AgACIFKAIEQXhxIANGDQIgBEEddiEAIARBAXQhBCAFIABBBHFqQRBqIggoAgAiAA0ACyAIIAI2AgAgAiAFNgIYIAIgAjYCDCACIAI2AggMAgsgAEF4IABrQQ9xQQAgAEEIakEPcRsiA2oiCyAGQUhqIgggA2siA0EBcjYCBCAAIAhqQTg2AgQgBCAFQTcgBWtBD3FBACAFQUlqQQ9xG2pBQWoiCCAIIARBEGpJGyIIQSM2AgRBAEEAKALw04CAADYCpNCAgABBACADNgKU0ICAAEEAIAs2AqDQgIAAIAhBEGpBACkC0NOAgAA3AgAgCEEAKQLI04CAADcCCEEAIAhBCGo2AtDTgIAAQQAgBjYCzNOAgABBACAANgLI04CAAEEAQQA2AtTTgIAAIAhBJGohAwNAIANBBzYCACADQQRqIgMgBUkNAAsgCCAERg0DIAggCCgCBEF+cTYCBCAIIAggBGsiADYCACAEIABBAXI2AgQCQCAAQf8BSw0AIABBeHFBsNCAgABqIQMCQAJAQQAoAojQgIAAIgVBASAAQQN2dCIAcQ0AQQAgBSAAcjYCiNCAgAAgAyEFDAELIAMoAgghBQsgBSAENgIMIAMgBDYCCCAEIAM2AgwgBCAFNgIIDAQLQR8hAwJAIABB////B0sNACAAQQh2IgMgA0GA/j9qQRB2QQhxIgN0IgUgBUGA4B9qQRB2QQRxIgV0IgggCEGAgA9qQRB2QQJxIgh0QQ92IAMgBXIgCHJrIgNBAXQgACADQRVqdkEBcXJBHGohAwsgBCADNgIcIARCADcCECADQQJ0QbjSgIAAaiEFAkBBACgCjNCAgAAiCEEBIAN0IgZxDQAgBSAENgIAQQAgCCAGcjYCjNCAgAAgBCAFNgIYIAQgBDYCCCAEIAQ2AgwMBAsgAEEAQRkgA0EBdmsgA0EfRht0IQMgBSgCACEIA0AgCCIFKAIEQXhxIABGDQMgA0EddiEIIANBAXQhAyAFIAhBBHFqQRBqIgYoAgAiCA0ACyAGIAQ2AgAgBCAFNgIYIAQgBDYCDCAEIAQ2AggMAwsgBSgCCCIDIAI2AgwgBSACNgIIIAJBADYCGCACIAU2AgwgAiADNgIICyALQQhqIQMMBQsgBSgCCCIDIAQ2AgwgBSAENgIIIARBADYCGCAEIAU2AgwgBCADNgIIC0EAKAKU0ICAACIDIAJNDQBBACgCoNCAgAAiBCACaiIFIAMgAmsiA0EBcjYCBEEAIAM2ApTQgIAAQQAgBTYCoNCAgAAgBCACQQNyNgIEIARBCGohAwwDC0EAIQNBAEEwNgL404CAAAwCCwJAIAtFDQACQAJAIAggCCgCHCIFQQJ0QbjSgIAAaiIDKAIARw0AIAMgADYCACAADQFBACAHQX4gBXdxIgc2AozQgIAADAILIAtBEEEUIAsoAhAgCEYbaiAANgIAIABFDQELIAAgCzYCGAJAIAgoAhAiA0UNACAAIAM2AhAgAyAANgIYCyAIQRRqKAIAIgNFDQAgAEEUaiADNgIAIAMgADYCGAsCQAJAIARBD0sNACAIIAQgAmoiA0EDcjYCBCAIIANqIgMgAygCBEEBcjYCBAwBCyAIIAJqIgAgBEEBcjYCBCAIIAJBA3I2AgQgACAEaiAENgIAAkAgBEH/AUsNACAEQXhxQbDQgIAAaiEDAkACQEEAKAKI0ICAACIFQQEgBEEDdnQiBHENAEEAIAUgBHI2AojQgIAAIAMhBAwBCyADKAIIIQQLIAQgADYCDCADIAA2AgggACADNgIMIAAgBDYCCAwBC0EfIQMCQCAEQf///wdLDQAgBEEIdiIDIANBgP4/akEQdkEIcSIDdCIFIAVBgOAfakEQdkEEcSIFdCICIAJBgIAPakEQdkECcSICdEEPdiADIAVyIAJyayIDQQF0IAQgA0EVanZBAXFyQRxqIQMLIAAgAzYCHCAAQgA3AhAgA0ECdEG40oCAAGohBQJAIAdBASADdCICcQ0AIAUgADYCAEEAIAcgAnI2AozQgIAAIAAgBTYCGCAAIAA2AgggACAANgIMDAELIARBAEEZIANBAXZrIANBH0YbdCEDIAUoAgAhAgJAA0AgAiIFKAIEQXhxIARGDQEgA0EddiECIANBAXQhAyAFIAJBBHFqQRBqIgYoAgAiAg0ACyAGIAA2AgAgACAFNgIYIAAgADYCDCAAIAA2AggMAQsgBSgCCCIDIAA2AgwgBSAANgIIIABBADYCGCAAIAU2AgwgACADNgIICyAIQQhqIQMMAQsCQCAKRQ0AAkACQCAAIAAoAhwiBUECdEG40oCAAGoiAygCAEcNACADIAg2AgAgCA0BQQAgCUF+IAV3cTYCjNCAgAAMAgsgCkEQQRQgCigCECAARhtqIAg2AgAgCEUNAQsgCCAKNgIYAkAgACgCECIDRQ0AIAggAzYCECADIAg2AhgLIABBFGooAgAiA0UNACAIQRRqIAM2AgAgAyAINgIYCwJAAkAgBEEPSw0AIAAgBCACaiIDQQNyNgIEIAAgA2oiAyADKAIEQQFyNgIEDAELIAAgAmoiBSAEQQFyNgIEIAAgAkEDcjYCBCAFIARqIAQ2AgACQCAHRQ0AIAdBeHFBsNCAgABqIQJBACgCnNCAgAAhAwJAAkBBASAHQQN2dCIIIAZxDQBBACAIIAZyNgKI0ICAACACIQgMAQsgAigCCCEICyAIIAM2AgwgAiADNgIIIAMgAjYCDCADIAg2AggLQQAgBTYCnNCAgABBACAENgKQ0ICAAAsgAEEIaiEDCyABQRBqJICAgIAAIAMLCgAgABDJgICAAAviDQEHfwJAIABFDQAgAEF4aiIBIABBfGooAgAiAkF4cSIAaiEDAkAgAkEBcQ0AIAJBA3FFDQEgASABKAIAIgJrIgFBACgCmNCAgAAiBEkNASACIABqIQACQCABQQAoApzQgIAARg0AAkAgAkH/AUsNACABKAIIIgQgAkEDdiIFQQN0QbDQgIAAaiIGRhoCQCABKAIMIgIgBEcNAEEAQQAoAojQgIAAQX4gBXdxNgKI0ICAAAwDCyACIAZGGiACIAQ2AgggBCACNgIMDAILIAEoAhghBwJAAkAgASgCDCIGIAFGDQAgASgCCCICIARJGiAGIAI2AgggAiAGNgIMDAELAkAgAUEUaiICKAIAIgQNACABQRBqIgIoAgAiBA0AQQAhBgwBCwNAIAIhBSAEIgZBFGoiAigCACIEDQAgBkEQaiECIAYoAhAiBA0ACyAFQQA2AgALIAdFDQECQAJAIAEgASgCHCIEQQJ0QbjSgIAAaiICKAIARw0AIAIgBjYCACAGDQFBAEEAKAKM0ICAAEF+IAR3cTYCjNCAgAAMAwsgB0EQQRQgBygCECABRhtqIAY2AgAgBkUNAgsgBiAHNgIYAkAgASgCECICRQ0AIAYgAjYCECACIAY2AhgLIAEoAhQiAkUNASAGQRRqIAI2AgAgAiAGNgIYDAELIAMoAgQiAkEDcUEDRw0AIAMgAkF+cTYCBEEAIAA2ApDQgIAAIAEgAGogADYCACABIABBAXI2AgQPCyABIANPDQAgAygCBCICQQFxRQ0AAkACQCACQQJxDQACQCADQQAoAqDQgIAARw0AQQAgATYCoNCAgABBAEEAKAKU0ICAACAAaiIANgKU0ICAACABIABBAXI2AgQgAUEAKAKc0ICAAEcNA0EAQQA2ApDQgIAAQQBBADYCnNCAgAAPCwJAIANBACgCnNCAgABHDQBBACABNgKc0ICAAEEAQQAoApDQgIAAIABqIgA2ApDQgIAAIAEgAEEBcjYCBCABIABqIAA2AgAPCyACQXhxIABqIQACQAJAIAJB/wFLDQAgAygCCCIEIAJBA3YiBUEDdEGw0ICAAGoiBkYaAkAgAygCDCICIARHDQBBAEEAKAKI0ICAAEF+IAV3cTYCiNCAgAAMAgsgAiAGRhogAiAENgIIIAQgAjYCDAwBCyADKAIYIQcCQAJAIAMoAgwiBiADRg0AIAMoAggiAkEAKAKY0ICAAEkaIAYgAjYCCCACIAY2AgwMAQsCQCADQRRqIgIoAgAiBA0AIANBEGoiAigCACIEDQBBACEGDAELA0AgAiEFIAQiBkEUaiICKAIAIgQNACAGQRBqIQIgBigCECIEDQALIAVBADYCAAsgB0UNAAJAAkAgAyADKAIcIgRBAnRBuNKAgABqIgIoAgBHDQAgAiAGNgIAIAYNAUEAQQAoAozQgIAAQX4gBHdxNgKM0ICAAAwCCyAHQRBBFCAHKAIQIANGG2ogBjYCACAGRQ0BCyAGIAc2AhgCQCADKAIQIgJFDQAgBiACNgIQIAIgBjYCGAsgAygCFCICRQ0AIAZBFGogAjYCACACIAY2AhgLIAEgAGogADYCACABIABBAXI2AgQgAUEAKAKc0ICAAEcNAUEAIAA2ApDQgIAADwsgAyACQX5xNgIEIAEgAGogADYCACABIABBAXI2AgQLAkAgAEH/AUsNACAAQXhxQbDQgIAAaiECAkACQEEAKAKI0ICAACIEQQEgAEEDdnQiAHENAEEAIAQgAHI2AojQgIAAIAIhAAwBCyACKAIIIQALIAAgATYCDCACIAE2AgggASACNgIMIAEgADYCCA8LQR8hAgJAIABB////B0sNACAAQQh2IgIgAkGA/j9qQRB2QQhxIgJ0IgQgBEGA4B9qQRB2QQRxIgR0IgYgBkGAgA9qQRB2QQJxIgZ0QQ92IAIgBHIgBnJrIgJBAXQgACACQRVqdkEBcXJBHGohAgsgASACNgIcIAFCADcCECACQQJ0QbjSgIAAaiEEAkACQEEAKAKM0ICAACIGQQEgAnQiA3ENACAEIAE2AgBBACAGIANyNgKM0ICAACABIAQ2AhggASABNgIIIAEgATYCDAwBCyAAQQBBGSACQQF2ayACQR9GG3QhAiAEKAIAIQYCQANAIAYiBCgCBEF4cSAARg0BIAJBHXYhBiACQQF0IQIgBCAGQQRxakEQaiIDKAIAIgYNAAsgAyABNgIAIAEgBDYCGCABIAE2AgwgASABNgIIDAELIAQoAggiACABNgIMIAQgATYCCCABQQA2AhggASAENgIMIAEgADYCCAtBAEEAKAKo0ICAAEF/aiIBQX8gARs2AqjQgIAACwsEAAAAC04AAkAgAA0APwBBEHQPCwJAIABB//8DcQ0AIABBf0wNAAJAIABBEHZAACIAQX9HDQBBAEEwNgL404CAAEF/DwsgAEEQdA8LEMqAgIAAAAvyAgIDfwF+AkAgAkUNACAAIAE6AAAgAiAAaiIDQX9qIAE6AAAgAkEDSQ0AIAAgAToAAiAAIAE6AAEgA0F9aiABOgAAIANBfmogAToAACACQQdJDQAgACABOgADIANBfGogAToAACACQQlJDQAgAEEAIABrQQNxIgRqIgMgAUH/AXFBgYKECGwiATYCACADIAIgBGtBfHEiBGoiAkF8aiABNgIAIARBCUkNACADIAE2AgggAyABNgIEIAJBeGogATYCACACQXRqIAE2AgAgBEEZSQ0AIAMgATYCGCADIAE2AhQgAyABNgIQIAMgATYCDCACQXBqIAE2AgAgAkFsaiABNgIAIAJBaGogATYCACACQWRqIAE2AgAgBCADQQRxQRhyIgVrIgJBIEkNACABrUKBgICAEH4hBiADIAVqIQEDQCABIAY3AxggASAGNwMQIAEgBjcDCCABIAY3AwAgAUEgaiEBIAJBYGoiAkEfSw0ACwsgAAsLjkgBAEGACAuGSAEAAAACAAAAAwAAAAAAAAAAAAAABAAAAAUAAAAAAAAAAAAAAAYAAAAHAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASW52YWxpZCBjaGFyIGluIHVybCBxdWVyeQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2JvZHkAQ29udGVudC1MZW5ndGggb3ZlcmZsb3cAQ2h1bmsgc2l6ZSBvdmVyZmxvdwBSZXNwb25zZSBvdmVyZmxvdwBJbnZhbGlkIG1ldGhvZCBmb3IgSFRUUC94LnggcmVxdWVzdABJbnZhbGlkIG1ldGhvZCBmb3IgUlRTUC94LnggcmVxdWVzdABFeHBlY3RlZCBTT1VSQ0UgbWV0aG9kIGZvciBJQ0UveC54IHJlcXVlc3QASW52YWxpZCBjaGFyIGluIHVybCBmcmFnbWVudCBzdGFydABFeHBlY3RlZCBkb3QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9zdGF0dXMASW52YWxpZCByZXNwb25zZSBzdGF0dXMASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucwBVc2VyIGNhbGxiYWNrIGVycm9yAGBvbl9yZXNldGAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2hlYWRlcmAgY2FsbGJhY2sgZXJyb3IAYG9uX21lc3NhZ2VfYmVnaW5gIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABsb3NlZWVwLWFsaXZlAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgAAAAAAAAAAAAAAAAAAAHJhbnNmZXItZW5jb2RpbmdwZ3JhZGUNCg0KDQpTTQ0KDQpUVFAvQ0UvVFNQLwAAAAAAAAAAAAAAAAECAAEDAAAAAAAAAAAAAAAAAAAAAAAABAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQUBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAABAAACAAAAAAAAAAAAAAAAAAAAAAAAAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAgAAAAACAAAAAAAAAAAAAAAAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==';
	return llhttp_simdWasm;
}

var client;
var hasRequiredClient;

function requireClient () {
	if (hasRequiredClient) return client;
	hasRequiredClient = 1;

	/* global WebAssembly */

	const assert = require$$0$4;
	const net = require$$0$5;
	const http = require$$2;
	const { pipeline } = require$$0$6;
	const util = requireUtil$6();
	const timers = requireTimers();
	const Request = requireRequest$1();
	const DispatcherBase = requireDispatcherBase();
	const {
	  RequestContentLengthMismatchError,
	  ResponseContentLengthMismatchError,
	  InvalidArgumentError,
	  RequestAbortedError,
	  HeadersTimeoutError,
	  HeadersOverflowError,
	  SocketError,
	  InformationalError,
	  BodyTimeoutError,
	  HTTPParserError,
	  ResponseExceededMaxSizeError,
	  ClientDestroyedError
	} = requireErrors();
	const buildConnector = requireConnect();
	const {
	  kUrl,
	  kReset,
	  kServerName,
	  kClient,
	  kBusy,
	  kParser,
	  kConnect,
	  kBlocking,
	  kResuming,
	  kRunning,
	  kPending,
	  kSize,
	  kWriting,
	  kQueue,
	  kConnected,
	  kConnecting,
	  kNeedDrain,
	  kNoRef,
	  kKeepAliveDefaultTimeout,
	  kHostHeader,
	  kPendingIdx,
	  kRunningIdx,
	  kError,
	  kPipelining,
	  kSocket,
	  kKeepAliveTimeoutValue,
	  kMaxHeadersSize,
	  kKeepAliveMaxTimeout,
	  kKeepAliveTimeoutThreshold,
	  kHeadersTimeout,
	  kBodyTimeout,
	  kStrictContentLength,
	  kConnector,
	  kMaxRedirections,
	  kMaxRequests,
	  kCounter,
	  kClose,
	  kDestroy,
	  kDispatch,
	  kInterceptors,
	  kLocalAddress,
	  kMaxResponseSize,
	  kHTTPConnVersion,
	  // HTTP2
	  kHost,
	  kHTTP2Session,
	  kHTTP2SessionState,
	  kHTTP2BuildRequest,
	  kHTTP2CopyHeaders,
	  kHTTP1BuildRequest
	} = requireSymbols$4();

	/** @type {import('http2')} */
	let http2;
	try {
	  http2 = require('http2');
	} catch {
	  // @ts-ignore
	  http2 = { constants: {} };
	}

	const {
	  constants: {
	    HTTP2_HEADER_AUTHORITY,
	    HTTP2_HEADER_METHOD,
	    HTTP2_HEADER_PATH,
	    HTTP2_HEADER_SCHEME,
	    HTTP2_HEADER_CONTENT_LENGTH,
	    HTTP2_HEADER_EXPECT,
	    HTTP2_HEADER_STATUS
	  }
	} = http2;

	// Experimental
	let h2ExperimentalWarned = false;

	const FastBuffer = Buffer[Symbol.species];

	const kClosedResolve = Symbol('kClosedResolve');

	const channels = {};

	try {
	  const diagnosticsChannel = require('diagnostics_channel');
	  channels.sendHeaders = diagnosticsChannel.channel('undici:client:sendHeaders');
	  channels.beforeConnect = diagnosticsChannel.channel('undici:client:beforeConnect');
	  channels.connectError = diagnosticsChannel.channel('undici:client:connectError');
	  channels.connected = diagnosticsChannel.channel('undici:client:connected');
	} catch {
	  channels.sendHeaders = { hasSubscribers: false };
	  channels.beforeConnect = { hasSubscribers: false };
	  channels.connectError = { hasSubscribers: false };
	  channels.connected = { hasSubscribers: false };
	}

	/**
	 * @type {import('../types/client').default}
	 */
	class Client extends DispatcherBase {
	  /**
	   *
	   * @param {string|URL} url
	   * @param {import('../types/client').Client.Options} options
	   */
	  constructor (url, {
	    interceptors,
	    maxHeaderSize,
	    headersTimeout,
	    socketTimeout,
	    requestTimeout,
	    connectTimeout,
	    bodyTimeout,
	    idleTimeout,
	    keepAlive,
	    keepAliveTimeout,
	    maxKeepAliveTimeout,
	    keepAliveMaxTimeout,
	    keepAliveTimeoutThreshold,
	    socketPath,
	    pipelining,
	    tls,
	    strictContentLength,
	    maxCachedSessions,
	    maxRedirections,
	    connect,
	    maxRequestsPerClient,
	    localAddress,
	    maxResponseSize,
	    autoSelectFamily,
	    autoSelectFamilyAttemptTimeout,
	    // h2
	    allowH2,
	    maxConcurrentStreams
	  } = {}) {
	    super();

	    if (keepAlive !== undefined) {
	      throw new InvalidArgumentError('unsupported keepAlive, use pipelining=0 instead')
	    }

	    if (socketTimeout !== undefined) {
	      throw new InvalidArgumentError('unsupported socketTimeout, use headersTimeout & bodyTimeout instead')
	    }

	    if (requestTimeout !== undefined) {
	      throw new InvalidArgumentError('unsupported requestTimeout, use headersTimeout & bodyTimeout instead')
	    }

	    if (idleTimeout !== undefined) {
	      throw new InvalidArgumentError('unsupported idleTimeout, use keepAliveTimeout instead')
	    }

	    if (maxKeepAliveTimeout !== undefined) {
	      throw new InvalidArgumentError('unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead')
	    }

	    if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {
	      throw new InvalidArgumentError('invalid maxHeaderSize')
	    }

	    if (socketPath != null && typeof socketPath !== 'string') {
	      throw new InvalidArgumentError('invalid socketPath')
	    }

	    if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {
	      throw new InvalidArgumentError('invalid connectTimeout')
	    }

	    if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {
	      throw new InvalidArgumentError('invalid keepAliveTimeout')
	    }

	    if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {
	      throw new InvalidArgumentError('invalid keepAliveMaxTimeout')
	    }

	    if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {
	      throw new InvalidArgumentError('invalid keepAliveTimeoutThreshold')
	    }

	    if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {
	      throw new InvalidArgumentError('headersTimeout must be a positive integer or zero')
	    }

	    if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {
	      throw new InvalidArgumentError('bodyTimeout must be a positive integer or zero')
	    }

	    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {
	      throw new InvalidArgumentError('connect must be a function or an object')
	    }

	    if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
	      throw new InvalidArgumentError('maxRedirections must be a positive number')
	    }

	    if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {
	      throw new InvalidArgumentError('maxRequestsPerClient must be a positive number')
	    }

	    if (localAddress != null && (typeof localAddress !== 'string' || net.isIP(localAddress) === 0)) {
	      throw new InvalidArgumentError('localAddress must be valid string IP address')
	    }

	    if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) {
	      throw new InvalidArgumentError('maxResponseSize must be a positive number')
	    }

	    if (
	      autoSelectFamilyAttemptTimeout != null &&
	      (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)
	    ) {
	      throw new InvalidArgumentError('autoSelectFamilyAttemptTimeout must be a positive number')
	    }

	    // h2
	    if (allowH2 != null && typeof allowH2 !== 'boolean') {
	      throw new InvalidArgumentError('allowH2 must be a valid boolean value')
	    }

	    if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== 'number' || maxConcurrentStreams < 1)) {
	      throw new InvalidArgumentError('maxConcurrentStreams must be a possitive integer, greater than 0')
	    }

	    if (typeof connect !== 'function') {
	      connect = buildConnector({
	        ...tls,
	        maxCachedSessions,
	        allowH2,
	        socketPath,
	        timeout: connectTimeout,
	        ...(util.nodeHasAutoSelectFamily && autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : undefined),
	        ...connect
	      });
	    }

	    this[kInterceptors] = interceptors && interceptors.Client && Array.isArray(interceptors.Client)
	      ? interceptors.Client
	      : [createRedirectInterceptor({ maxRedirections })];
	    this[kUrl] = util.parseOrigin(url);
	    this[kConnector] = connect;
	    this[kSocket] = null;
	    this[kPipelining] = pipelining != null ? pipelining : 1;
	    this[kMaxHeadersSize] = maxHeaderSize || http.maxHeaderSize;
	    this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;
	    this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 600e3 : keepAliveMaxTimeout;
	    this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold;
	    this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];
	    this[kServerName] = null;
	    this[kLocalAddress] = localAddress != null ? localAddress : null;
	    this[kResuming] = 0; // 0, idle, 1, scheduled, 2 resuming
	    this[kNeedDrain] = 0; // 0, idle, 1, scheduled, 2 resuming
	    this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ''}\r\n`;
	    this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 300e3;
	    this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 300e3;
	    this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;
	    this[kMaxRedirections] = maxRedirections;
	    this[kMaxRequests] = maxRequestsPerClient;
	    this[kClosedResolve] = null;
	    this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1;
	    this[kHTTPConnVersion] = 'h1';

	    // HTTP/2
	    this[kHTTP2Session] = null;
	    this[kHTTP2SessionState] = !allowH2
	      ? null
	      : {
	        // streams: null, // Fixed queue of streams - For future support of `push`
	          openStreams: 0, // Keep track of them to decide wether or not unref the session
	          maxConcurrentStreams: maxConcurrentStreams != null ? maxConcurrentStreams : 100 // Max peerConcurrentStreams for a Node h2 server
	        };
	    this[kHost] = `${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ''}`;

	    // kQueue is built up of 3 sections separated by
	    // the kRunningIdx and kPendingIdx indices.
	    // |   complete   |   running   |   pending   |
	    //                ^ kRunningIdx ^ kPendingIdx ^ kQueue.length
	    // kRunningIdx points to the first running element.
	    // kPendingIdx points to the first pending element.
	    // This implements a fast queue with an amortized
	    // time of O(1).

	    this[kQueue] = [];
	    this[kRunningIdx] = 0;
	    this[kPendingIdx] = 0;
	  }

	  get pipelining () {
	    return this[kPipelining]
	  }

	  set pipelining (value) {
	    this[kPipelining] = value;
	    resume(this, true);
	  }

	  get [kPending] () {
	    return this[kQueue].length - this[kPendingIdx]
	  }

	  get [kRunning] () {
	    return this[kPendingIdx] - this[kRunningIdx]
	  }

	  get [kSize] () {
	    return this[kQueue].length - this[kRunningIdx]
	  }

	  get [kConnected] () {
	    return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed
	  }

	  get [kBusy] () {
	    const socket = this[kSocket];
	    return (
	      (socket && (socket[kReset] || socket[kWriting] || socket[kBlocking])) ||
	      (this[kSize] >= (this[kPipelining] || 1)) ||
	      this[kPending] > 0
	    )
	  }

	  /* istanbul ignore: only used for test */
	  [kConnect] (cb) {
	    connect(this);
	    this.once('connect', cb);
	  }

	  [kDispatch] (opts, handler) {
	    const origin = opts.origin || this[kUrl].origin;

	    const request = this[kHTTPConnVersion] === 'h2'
	      ? Request[kHTTP2BuildRequest](origin, opts, handler)
	      : Request[kHTTP1BuildRequest](origin, opts, handler);

	    this[kQueue].push(request);
	    if (this[kResuming]) ; else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {
	      // Wait a tick in case stream/iterator is ended in the same tick.
	      this[kResuming] = 1;
	      process.nextTick(resume, this);
	    } else {
	      resume(this, true);
	    }

	    if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {
	      this[kNeedDrain] = 2;
	    }

	    return this[kNeedDrain] < 2
	  }

	  async [kClose] () {
	    // TODO: for H2 we need to gracefully flush the remaining enqueued
	    // request and close each stream.
	    return new Promise((resolve) => {
	      if (!this[kSize]) {
	        resolve(null);
	      } else {
	        this[kClosedResolve] = resolve;
	      }
	    })
	  }

	  async [kDestroy] (err) {
	    return new Promise((resolve) => {
	      const requests = this[kQueue].splice(this[kPendingIdx]);
	      for (let i = 0; i < requests.length; i++) {
	        const request = requests[i];
	        errorRequest(this, request, err);
	      }

	      const callback = () => {
	        if (this[kClosedResolve]) {
	          // TODO (fix): Should we error here with ClientDestroyedError?
	          this[kClosedResolve]();
	          this[kClosedResolve] = null;
	        }
	        resolve();
	      };

	      if (this[kHTTP2Session] != null) {
	        util.destroy(this[kHTTP2Session], err);
	        this[kHTTP2Session] = null;
	        this[kHTTP2SessionState] = null;
	      }

	      if (!this[kSocket]) {
	        queueMicrotask(callback);
	      } else {
	        util.destroy(this[kSocket].on('close', callback), err);
	      }

	      resume(this);
	    })
	  }
	}

	function onHttp2SessionError (err) {
	  assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID');

	  this[kSocket][kError] = err;

	  onError(this[kClient], err);
	}

	function onHttp2FrameError (type, code, id) {
	  const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`);

	  if (id === 0) {
	    this[kSocket][kError] = err;
	    onError(this[kClient], err);
	  }
	}

	function onHttp2SessionEnd () {
	  util.destroy(this, new SocketError('other side closed'));
	  util.destroy(this[kSocket], new SocketError('other side closed'));
	}

	function onHTTP2GoAway (code) {
	  const client = this[kClient];
	  const err = new InformationalError(`HTTP/2: "GOAWAY" frame received with code ${code}`);
	  client[kSocket] = null;
	  client[kHTTP2Session] = null;

	  if (client.destroyed) {
	    assert(this[kPending] === 0);

	    // Fail entire queue.
	    const requests = client[kQueue].splice(client[kRunningIdx]);
	    for (let i = 0; i < requests.length; i++) {
	      const request = requests[i];
	      errorRequest(this, request, err);
	    }
	  } else if (client[kRunning] > 0) {
	    // Fail head of pipeline.
	    const request = client[kQueue][client[kRunningIdx]];
	    client[kQueue][client[kRunningIdx]++] = null;

	    errorRequest(client, request, err);
	  }

	  client[kPendingIdx] = client[kRunningIdx];

	  assert(client[kRunning] === 0);

	  client.emit('disconnect',
	    client[kUrl],
	    [client],
	    err
	  );

	  resume(client);
	}

	const constants = requireConstants$4();
	const createRedirectInterceptor = requireRedirectInterceptor();
	const EMPTY_BUF = Buffer.alloc(0);

	async function lazyllhttp () {
	  const llhttpWasmData = process.env.JEST_WORKER_ID ? requireLlhttpWasm() : undefined;

	  let mod;
	  try {
	    mod = await WebAssembly.compile(Buffer.from(requireLlhttp_simdWasm(), 'base64'));
	  } catch (e) {
	    /* istanbul ignore next */

	    // We could check if the error was caused by the simd option not
	    // being enabled, but the occurring of this other error
	    // * https://github.com/emscripten-core/emscripten/issues/11495
	    // got me to remove that check to avoid breaking Node 12.
	    mod = await WebAssembly.compile(Buffer.from(llhttpWasmData || requireLlhttpWasm(), 'base64'));
	  }

	  return await WebAssembly.instantiate(mod, {
	    env: {
	      /* eslint-disable camelcase */

	      wasm_on_url: (p, at, len) => {
	        /* istanbul ignore next */
	        return 0
	      },
	      wasm_on_status: (p, at, len) => {
	        assert.strictEqual(currentParser.ptr, p);
	        const start = at - currentBufferPtr + currentBufferRef.byteOffset;
	        return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len)) || 0
	      },
	      wasm_on_message_begin: (p) => {
	        assert.strictEqual(currentParser.ptr, p);
	        return currentParser.onMessageBegin() || 0
	      },
	      wasm_on_header_field: (p, at, len) => {
	        assert.strictEqual(currentParser.ptr, p);
	        const start = at - currentBufferPtr + currentBufferRef.byteOffset;
	        return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len)) || 0
	      },
	      wasm_on_header_value: (p, at, len) => {
	        assert.strictEqual(currentParser.ptr, p);
	        const start = at - currentBufferPtr + currentBufferRef.byteOffset;
	        return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len)) || 0
	      },
	      wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {
	        assert.strictEqual(currentParser.ptr, p);
	        return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0
	      },
	      wasm_on_body: (p, at, len) => {
	        assert.strictEqual(currentParser.ptr, p);
	        const start = at - currentBufferPtr + currentBufferRef.byteOffset;
	        return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len)) || 0
	      },
	      wasm_on_message_complete: (p) => {
	        assert.strictEqual(currentParser.ptr, p);
	        return currentParser.onMessageComplete() || 0
	      }

	      /* eslint-enable camelcase */
	    }
	  })
	}

	let llhttpInstance = null;
	let llhttpPromise = lazyllhttp();
	llhttpPromise.catch();

	let currentParser = null;
	let currentBufferRef = null;
	let currentBufferSize = 0;
	let currentBufferPtr = null;

	const TIMEOUT_HEADERS = 1;
	const TIMEOUT_BODY = 2;
	const TIMEOUT_IDLE = 3;

	class Parser {
	  constructor (client, socket, { exports }) {
	    assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0);

	    this.llhttp = exports;
	    this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE);
	    this.client = client;
	    this.socket = socket;
	    this.timeout = null;
	    this.timeoutValue = null;
	    this.timeoutType = null;
	    this.statusCode = null;
	    this.statusText = '';
	    this.upgrade = false;
	    this.headers = [];
	    this.headersSize = 0;
	    this.headersMaxSize = client[kMaxHeadersSize];
	    this.shouldKeepAlive = false;
	    this.paused = false;
	    this.resume = this.resume.bind(this);

	    this.bytesRead = 0;

	    this.keepAlive = '';
	    this.contentLength = '';
	    this.connection = '';
	    this.maxResponseSize = client[kMaxResponseSize];
	  }

	  setTimeout (value, type) {
	    this.timeoutType = type;
	    if (value !== this.timeoutValue) {
	      timers.clearTimeout(this.timeout);
	      if (value) {
	        this.timeout = timers.setTimeout(onParserTimeout, value, this);
	        // istanbul ignore else: only for jest
	        if (this.timeout.unref) {
	          this.timeout.unref();
	        }
	      } else {
	        this.timeout = null;
	      }
	      this.timeoutValue = value;
	    } else if (this.timeout) {
	      // istanbul ignore else: only for jest
	      if (this.timeout.refresh) {
	        this.timeout.refresh();
	      }
	    }
	  }

	  resume () {
	    if (this.socket.destroyed || !this.paused) {
	      return
	    }

	    assert(this.ptr != null);
	    assert(currentParser == null);

	    this.llhttp.llhttp_resume(this.ptr);

	    assert(this.timeoutType === TIMEOUT_BODY);
	    if (this.timeout) {
	      // istanbul ignore else: only for jest
	      if (this.timeout.refresh) {
	        this.timeout.refresh();
	      }
	    }

	    this.paused = false;
	    this.execute(this.socket.read() || EMPTY_BUF); // Flush parser.
	    this.readMore();
	  }

	  readMore () {
	    while (!this.paused && this.ptr) {
	      const chunk = this.socket.read();
	      if (chunk === null) {
	        break
	      }
	      this.execute(chunk);
	    }
	  }

	  execute (data) {
	    assert(this.ptr != null);
	    assert(currentParser == null);
	    assert(!this.paused);

	    const { socket, llhttp } = this;

	    if (data.length > currentBufferSize) {
	      if (currentBufferPtr) {
	        llhttp.free(currentBufferPtr);
	      }
	      currentBufferSize = Math.ceil(data.length / 4096) * 4096;
	      currentBufferPtr = llhttp.malloc(currentBufferSize);
	    }

	    new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data);

	    // Call `execute` on the wasm parser.
	    // We pass the `llhttp_parser` pointer address, the pointer address of buffer view data,
	    // and finally the length of bytes to parse.
	    // The return value is an error code or `constants.ERROR.OK`.
	    try {
	      let ret;

	      try {
	        currentBufferRef = data;
	        currentParser = this;
	        ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);
	        /* eslint-disable-next-line no-useless-catch */
	      } catch (err) {
	        /* istanbul ignore next: difficult to make a test case for */
	        throw err
	      } finally {
	        currentParser = null;
	        currentBufferRef = null;
	      }

	      const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;

	      if (ret === constants.ERROR.PAUSED_UPGRADE) {
	        this.onUpgrade(data.slice(offset));
	      } else if (ret === constants.ERROR.PAUSED) {
	        this.paused = true;
	        socket.unshift(data.slice(offset));
	      } else if (ret !== constants.ERROR.OK) {
	        const ptr = llhttp.llhttp_get_error_reason(this.ptr);
	        let message = '';
	        /* istanbul ignore else: difficult to make a test case for */
	        if (ptr) {
	          const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);
	          message =
	            'Response does not match the HTTP/1.1 protocol (' +
	            Buffer.from(llhttp.memory.buffer, ptr, len).toString() +
	            ')';
	        }
	        throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset))
	      }
	    } catch (err) {
	      util.destroy(socket, err);
	    }
	  }

	  destroy () {
	    assert(this.ptr != null);
	    assert(currentParser == null);

	    this.llhttp.llhttp_free(this.ptr);
	    this.ptr = null;

	    timers.clearTimeout(this.timeout);
	    this.timeout = null;
	    this.timeoutValue = null;
	    this.timeoutType = null;

	    this.paused = false;
	  }

	  onStatus (buf) {
	    this.statusText = buf.toString();
	  }

	  onMessageBegin () {
	    const { socket, client } = this;

	    /* istanbul ignore next: difficult to make a test case for */
	    if (socket.destroyed) {
	      return -1
	    }

	    const request = client[kQueue][client[kRunningIdx]];
	    if (!request) {
	      return -1
	    }
	  }

	  onHeaderField (buf) {
	    const len = this.headers.length;

	    if ((len & 1) === 0) {
	      this.headers.push(buf);
	    } else {
	      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
	    }

	    this.trackHeader(buf.length);
	  }

	  onHeaderValue (buf) {
	    let len = this.headers.length;

	    if ((len & 1) === 1) {
	      this.headers.push(buf);
	      len += 1;
	    } else {
	      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
	    }

	    const key = this.headers[len - 2];
	    if (key.length === 10 && key.toString().toLowerCase() === 'keep-alive') {
	      this.keepAlive += buf.toString();
	    } else if (key.length === 10 && key.toString().toLowerCase() === 'connection') {
	      this.connection += buf.toString();
	    } else if (key.length === 14 && key.toString().toLowerCase() === 'content-length') {
	      this.contentLength += buf.toString();
	    }

	    this.trackHeader(buf.length);
	  }

	  trackHeader (len) {
	    this.headersSize += len;
	    if (this.headersSize >= this.headersMaxSize) {
	      util.destroy(this.socket, new HeadersOverflowError());
	    }
	  }

	  onUpgrade (head) {
	    const { upgrade, client, socket, headers, statusCode } = this;

	    assert(upgrade);

	    const request = client[kQueue][client[kRunningIdx]];
	    assert(request);

	    assert(!socket.destroyed);
	    assert(socket === client[kSocket]);
	    assert(!this.paused);
	    assert(request.upgrade || request.method === 'CONNECT');

	    this.statusCode = null;
	    this.statusText = '';
	    this.shouldKeepAlive = null;

	    assert(this.headers.length % 2 === 0);
	    this.headers = [];
	    this.headersSize = 0;

	    socket.unshift(head);

	    socket[kParser].destroy();
	    socket[kParser] = null;

	    socket[kClient] = null;
	    socket[kError] = null;
	    socket
	      .removeListener('error', onSocketError)
	      .removeListener('readable', onSocketReadable)
	      .removeListener('end', onSocketEnd)
	      .removeListener('close', onSocketClose);

	    client[kSocket] = null;
	    client[kQueue][client[kRunningIdx]++] = null;
	    client.emit('disconnect', client[kUrl], [client], new InformationalError('upgrade'));

	    try {
	      request.onUpgrade(statusCode, headers, socket);
	    } catch (err) {
	      util.destroy(socket, err);
	    }

	    resume(client);
	  }

	  onHeadersComplete (statusCode, upgrade, shouldKeepAlive) {
	    const { client, socket, headers, statusText } = this;

	    /* istanbul ignore next: difficult to make a test case for */
	    if (socket.destroyed) {
	      return -1
	    }

	    const request = client[kQueue][client[kRunningIdx]];

	    /* istanbul ignore next: difficult to make a test case for */
	    if (!request) {
	      return -1
	    }

	    assert(!this.upgrade);
	    assert(this.statusCode < 200);

	    if (statusCode === 100) {
	      util.destroy(socket, new SocketError('bad response', util.getSocketInfo(socket)));
	      return -1
	    }

	    /* this can only happen if server is misbehaving */
	    if (upgrade && !request.upgrade) {
	      util.destroy(socket, new SocketError('bad upgrade', util.getSocketInfo(socket)));
	      return -1
	    }

	    assert.strictEqual(this.timeoutType, TIMEOUT_HEADERS);

	    this.statusCode = statusCode;
	    this.shouldKeepAlive = (
	      shouldKeepAlive ||
	      // Override llhttp value which does not allow keepAlive for HEAD.
	      (request.method === 'HEAD' && !socket[kReset] && this.connection.toLowerCase() === 'keep-alive')
	    );

	    if (this.statusCode >= 200) {
	      const bodyTimeout = request.bodyTimeout != null
	        ? request.bodyTimeout
	        : client[kBodyTimeout];
	      this.setTimeout(bodyTimeout, TIMEOUT_BODY);
	    } else if (this.timeout) {
	      // istanbul ignore else: only for jest
	      if (this.timeout.refresh) {
	        this.timeout.refresh();
	      }
	    }

	    if (request.method === 'CONNECT') {
	      assert(client[kRunning] === 1);
	      this.upgrade = true;
	      return 2
	    }

	    if (upgrade) {
	      assert(client[kRunning] === 1);
	      this.upgrade = true;
	      return 2
	    }

	    assert(this.headers.length % 2 === 0);
	    this.headers = [];
	    this.headersSize = 0;

	    if (this.shouldKeepAlive && client[kPipelining]) {
	      const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null;

	      if (keepAliveTimeout != null) {
	        const timeout = Math.min(
	          keepAliveTimeout - client[kKeepAliveTimeoutThreshold],
	          client[kKeepAliveMaxTimeout]
	        );
	        if (timeout <= 0) {
	          socket[kReset] = true;
	        } else {
	          client[kKeepAliveTimeoutValue] = timeout;
	        }
	      } else {
	        client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];
	      }
	    } else {
	      // Stop more requests from being dispatched.
	      socket[kReset] = true;
	    }

	    const pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false;

	    if (request.aborted) {
	      return -1
	    }

	    if (request.method === 'HEAD') {
	      return 1
	    }

	    if (statusCode < 200) {
	      return 1
	    }

	    if (socket[kBlocking]) {
	      socket[kBlocking] = false;
	      resume(client);
	    }

	    return pause ? constants.ERROR.PAUSED : 0
	  }

	  onBody (buf) {
	    const { client, socket, statusCode, maxResponseSize } = this;

	    if (socket.destroyed) {
	      return -1
	    }

	    const request = client[kQueue][client[kRunningIdx]];
	    assert(request);

	    assert.strictEqual(this.timeoutType, TIMEOUT_BODY);
	    if (this.timeout) {
	      // istanbul ignore else: only for jest
	      if (this.timeout.refresh) {
	        this.timeout.refresh();
	      }
	    }

	    assert(statusCode >= 200);

	    if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {
	      util.destroy(socket, new ResponseExceededMaxSizeError());
	      return -1
	    }

	    this.bytesRead += buf.length;

	    if (request.onData(buf) === false) {
	      return constants.ERROR.PAUSED
	    }
	  }

	  onMessageComplete () {
	    const { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this;

	    if (socket.destroyed && (!statusCode || shouldKeepAlive)) {
	      return -1
	    }

	    if (upgrade) {
	      return
	    }

	    const request = client[kQueue][client[kRunningIdx]];
	    assert(request);

	    assert(statusCode >= 100);

	    this.statusCode = null;
	    this.statusText = '';
	    this.bytesRead = 0;
	    this.contentLength = '';
	    this.keepAlive = '';
	    this.connection = '';

	    assert(this.headers.length % 2 === 0);
	    this.headers = [];
	    this.headersSize = 0;

	    if (statusCode < 200) {
	      return
	    }

	    /* istanbul ignore next: should be handled by llhttp? */
	    if (request.method !== 'HEAD' && contentLength && bytesRead !== parseInt(contentLength, 10)) {
	      util.destroy(socket, new ResponseContentLengthMismatchError());
	      return -1
	    }

	    request.onComplete(headers);

	    client[kQueue][client[kRunningIdx]++] = null;

	    if (socket[kWriting]) {
	      assert.strictEqual(client[kRunning], 0);
	      // Response completed before request.
	      util.destroy(socket, new InformationalError('reset'));
	      return constants.ERROR.PAUSED
	    } else if (!shouldKeepAlive) {
	      util.destroy(socket, new InformationalError('reset'));
	      return constants.ERROR.PAUSED
	    } else if (socket[kReset] && client[kRunning] === 0) {
	      // Destroy socket once all requests have completed.
	      // The request at the tail of the pipeline is the one
	      // that requested reset and no further requests should
	      // have been queued since then.
	      util.destroy(socket, new InformationalError('reset'));
	      return constants.ERROR.PAUSED
	    } else if (client[kPipelining] === 1) {
	      // We must wait a full event loop cycle to reuse this socket to make sure
	      // that non-spec compliant servers are not closing the connection even if they
	      // said they won't.
	      setImmediate(resume, client);
	    } else {
	      resume(client);
	    }
	  }
	}

	function onParserTimeout (parser) {
	  const { socket, timeoutType, client } = parser;

	  /* istanbul ignore else */
	  if (timeoutType === TIMEOUT_HEADERS) {
	    if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {
	      assert(!parser.paused, 'cannot be paused while waiting for headers');
	      util.destroy(socket, new HeadersTimeoutError());
	    }
	  } else if (timeoutType === TIMEOUT_BODY) {
	    if (!parser.paused) {
	      util.destroy(socket, new BodyTimeoutError());
	    }
	  } else if (timeoutType === TIMEOUT_IDLE) {
	    assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue]);
	    util.destroy(socket, new InformationalError('socket idle timeout'));
	  }
	}

	function onSocketReadable () {
	  const { [kParser]: parser } = this;
	  if (parser) {
	    parser.readMore();
	  }
	}

	function onSocketError (err) {
	  const { [kClient]: client, [kParser]: parser } = this;

	  assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID');

	  if (client[kHTTPConnVersion] !== 'h2') {
	    // On Mac OS, we get an ECONNRESET even if there is a full body to be forwarded
	    // to the user.
	    if (err.code === 'ECONNRESET' && parser.statusCode && !parser.shouldKeepAlive) {
	      // We treat all incoming data so for as a valid response.
	      parser.onMessageComplete();
	      return
	    }
	  }

	  this[kError] = err;

	  onError(this[kClient], err);
	}

	function onError (client, err) {
	  if (
	    client[kRunning] === 0 &&
	    err.code !== 'UND_ERR_INFO' &&
	    err.code !== 'UND_ERR_SOCKET'
	  ) {
	    // Error is not caused by running request and not a recoverable
	    // socket error.

	    assert(client[kPendingIdx] === client[kRunningIdx]);

	    const requests = client[kQueue].splice(client[kRunningIdx]);
	    for (let i = 0; i < requests.length; i++) {
	      const request = requests[i];
	      errorRequest(client, request, err);
	    }
	    assert(client[kSize] === 0);
	  }
	}

	function onSocketEnd () {
	  const { [kParser]: parser, [kClient]: client } = this;

	  if (client[kHTTPConnVersion] !== 'h2') {
	    if (parser.statusCode && !parser.shouldKeepAlive) {
	      // We treat all incoming data so far as a valid response.
	      parser.onMessageComplete();
	      return
	    }
	  }

	  util.destroy(this, new SocketError('other side closed', util.getSocketInfo(this)));
	}

	function onSocketClose () {
	  const { [kClient]: client, [kParser]: parser } = this;

	  if (client[kHTTPConnVersion] === 'h1' && parser) {
	    if (!this[kError] && parser.statusCode && !parser.shouldKeepAlive) {
	      // We treat all incoming data so far as a valid response.
	      parser.onMessageComplete();
	    }

	    this[kParser].destroy();
	    this[kParser] = null;
	  }

	  const err = this[kError] || new SocketError('closed', util.getSocketInfo(this));

	  client[kSocket] = null;

	  if (client.destroyed) {
	    assert(client[kPending] === 0);

	    // Fail entire queue.
	    const requests = client[kQueue].splice(client[kRunningIdx]);
	    for (let i = 0; i < requests.length; i++) {
	      const request = requests[i];
	      errorRequest(client, request, err);
	    }
	  } else if (client[kRunning] > 0 && err.code !== 'UND_ERR_INFO') {
	    // Fail head of pipeline.
	    const request = client[kQueue][client[kRunningIdx]];
	    client[kQueue][client[kRunningIdx]++] = null;

	    errorRequest(client, request, err);
	  }

	  client[kPendingIdx] = client[kRunningIdx];

	  assert(client[kRunning] === 0);

	  client.emit('disconnect', client[kUrl], [client], err);

	  resume(client);
	}

	async function connect (client) {
	  assert(!client[kConnecting]);
	  assert(!client[kSocket]);

	  let { host, hostname, protocol, port } = client[kUrl];

	  // Resolve ipv6
	  if (hostname[0] === '[') {
	    const idx = hostname.indexOf(']');

	    assert(idx !== -1);
	    const ip = hostname.substring(1, idx);

	    assert(net.isIP(ip));
	    hostname = ip;
	  }

	  client[kConnecting] = true;

	  if (channels.beforeConnect.hasSubscribers) {
	    channels.beforeConnect.publish({
	      connectParams: {
	        host,
	        hostname,
	        protocol,
	        port,
	        servername: client[kServerName],
	        localAddress: client[kLocalAddress]
	      },
	      connector: client[kConnector]
	    });
	  }

	  try {
	    const socket = await new Promise((resolve, reject) => {
	      client[kConnector]({
	        host,
	        hostname,
	        protocol,
	        port,
	        servername: client[kServerName],
	        localAddress: client[kLocalAddress]
	      }, (err, socket) => {
	        if (err) {
	          reject(err);
	        } else {
	          resolve(socket);
	        }
	      });
	    });

	    if (client.destroyed) {
	      util.destroy(socket.on('error', () => {}), new ClientDestroyedError());
	      return
	    }

	    client[kConnecting] = false;

	    assert(socket);

	    const isH2 = socket.alpnProtocol === 'h2';
	    if (isH2) {
	      if (!h2ExperimentalWarned) {
	        h2ExperimentalWarned = true;
	        process.emitWarning('H2 support is experimental, expect them to change at any time.', {
	          code: 'UNDICI-H2'
	        });
	      }

	      const session = http2.connect(client[kUrl], {
	        createConnection: () => socket,
	        peerMaxConcurrentStreams: client[kHTTP2SessionState].maxConcurrentStreams
	      });

	      client[kHTTPConnVersion] = 'h2';
	      session[kClient] = client;
	      session[kSocket] = socket;
	      session.on('error', onHttp2SessionError);
	      session.on('frameError', onHttp2FrameError);
	      session.on('end', onHttp2SessionEnd);
	      session.on('goaway', onHTTP2GoAway);
	      session.on('close', onSocketClose);
	      session.unref();

	      client[kHTTP2Session] = session;
	      socket[kHTTP2Session] = session;
	    } else {
	      if (!llhttpInstance) {
	        llhttpInstance = await llhttpPromise;
	        llhttpPromise = null;
	      }

	      socket[kNoRef] = false;
	      socket[kWriting] = false;
	      socket[kReset] = false;
	      socket[kBlocking] = false;
	      socket[kParser] = new Parser(client, socket, llhttpInstance);
	    }

	    socket[kCounter] = 0;
	    socket[kMaxRequests] = client[kMaxRequests];
	    socket[kClient] = client;
	    socket[kError] = null;

	    socket
	      .on('error', onSocketError)
	      .on('readable', onSocketReadable)
	      .on('end', onSocketEnd)
	      .on('close', onSocketClose);

	    client[kSocket] = socket;

	    if (channels.connected.hasSubscribers) {
	      channels.connected.publish({
	        connectParams: {
	          host,
	          hostname,
	          protocol,
	          port,
	          servername: client[kServerName],
	          localAddress: client[kLocalAddress]
	        },
	        connector: client[kConnector],
	        socket
	      });
	    }
	    client.emit('connect', client[kUrl], [client]);
	  } catch (err) {
	    if (client.destroyed) {
	      return
	    }

	    client[kConnecting] = false;

	    if (channels.connectError.hasSubscribers) {
	      channels.connectError.publish({
	        connectParams: {
	          host,
	          hostname,
	          protocol,
	          port,
	          servername: client[kServerName],
	          localAddress: client[kLocalAddress]
	        },
	        connector: client[kConnector],
	        error: err
	      });
	    }

	    if (err.code === 'ERR_TLS_CERT_ALTNAME_INVALID') {
	      assert(client[kRunning] === 0);
	      while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {
	        const request = client[kQueue][client[kPendingIdx]++];
	        errorRequest(client, request, err);
	      }
	    } else {
	      onError(client, err);
	    }

	    client.emit('connectionError', client[kUrl], [client], err);
	  }

	  resume(client);
	}

	function emitDrain (client) {
	  client[kNeedDrain] = 0;
	  client.emit('drain', client[kUrl], [client]);
	}

	function resume (client, sync) {
	  if (client[kResuming] === 2) {
	    return
	  }

	  client[kResuming] = 2;

	  _resume(client, sync);
	  client[kResuming] = 0;

	  if (client[kRunningIdx] > 256) {
	    client[kQueue].splice(0, client[kRunningIdx]);
	    client[kPendingIdx] -= client[kRunningIdx];
	    client[kRunningIdx] = 0;
	  }
	}

	function _resume (client, sync) {
	  while (true) {
	    if (client.destroyed) {
	      assert(client[kPending] === 0);
	      return
	    }

	    if (client[kClosedResolve] && !client[kSize]) {
	      client[kClosedResolve]();
	      client[kClosedResolve] = null;
	      return
	    }

	    const socket = client[kSocket];

	    if (socket && !socket.destroyed && socket.alpnProtocol !== 'h2') {
	      if (client[kSize] === 0) {
	        if (!socket[kNoRef] && socket.unref) {
	          socket.unref();
	          socket[kNoRef] = true;
	        }
	      } else if (socket[kNoRef] && socket.ref) {
	        socket.ref();
	        socket[kNoRef] = false;
	      }

	      if (client[kSize] === 0) {
	        if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {
	          socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE);
	        }
	      } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {
	        if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {
	          const request = client[kQueue][client[kRunningIdx]];
	          const headersTimeout = request.headersTimeout != null
	            ? request.headersTimeout
	            : client[kHeadersTimeout];
	          socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);
	        }
	      }
	    }

	    if (client[kBusy]) {
	      client[kNeedDrain] = 2;
	    } else if (client[kNeedDrain] === 2) {
	      if (sync) {
	        client[kNeedDrain] = 1;
	        process.nextTick(emitDrain, client);
	      } else {
	        emitDrain(client);
	      }
	      continue
	    }

	    if (client[kPending] === 0) {
	      return
	    }

	    if (client[kRunning] >= (client[kPipelining] || 1)) {
	      return
	    }

	    const request = client[kQueue][client[kPendingIdx]];

	    if (client[kUrl].protocol === 'https:' && client[kServerName] !== request.servername) {
	      if (client[kRunning] > 0) {
	        return
	      }

	      client[kServerName] = request.servername;

	      if (socket && socket.servername !== request.servername) {
	        util.destroy(socket, new InformationalError('servername changed'));
	        return
	      }
	    }

	    if (client[kConnecting]) {
	      return
	    }

	    if (!socket && !client[kHTTP2Session]) {
	      connect(client);
	      return
	    }

	    if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) {
	      return
	    }

	    if (client[kRunning] > 0 && !request.idempotent) {
	      // Non-idempotent request cannot be retried.
	      // Ensure that no other requests are inflight and
	      // could cause failure.
	      return
	    }

	    if (client[kRunning] > 0 && (request.upgrade || request.method === 'CONNECT')) {
	      // Don't dispatch an upgrade until all preceding requests have completed.
	      // A misbehaving server might upgrade the connection before all pipelined
	      // request has completed.
	      return
	    }

	    if (client[kRunning] > 0 && util.bodyLength(request.body) !== 0 &&
	      (util.isStream(request.body) || util.isAsyncIterable(request.body))) {
	      // Request with stream or iterator body can error while other requests
	      // are inflight and indirectly error those as well.
	      // Ensure this doesn't happen by waiting for inflight
	      // to complete before dispatching.

	      // Request with stream or iterator body cannot be retried.
	      // Ensure that no other requests are inflight and
	      // could cause failure.
	      return
	    }

	    if (!request.aborted && write(client, request)) {
	      client[kPendingIdx]++;
	    } else {
	      client[kQueue].splice(client[kPendingIdx], 1);
	    }
	  }
	}

	// https://www.rfc-editor.org/rfc/rfc7230#section-3.3.2
	function shouldSendContentLength (method) {
	  return method !== 'GET' && method !== 'HEAD' && method !== 'OPTIONS' && method !== 'TRACE' && method !== 'CONNECT'
	}

	function write (client, request) {
	  if (client[kHTTPConnVersion] === 'h2') {
	    writeH2(client, client[kHTTP2Session], request);
	    return
	  }

	  const { body, method, path, host, upgrade, headers, blocking, reset } = request;

	  // https://tools.ietf.org/html/rfc7231#section-4.3.1
	  // https://tools.ietf.org/html/rfc7231#section-4.3.2
	  // https://tools.ietf.org/html/rfc7231#section-4.3.5

	  // Sending a payload body on a request that does not
	  // expect it can cause undefined behavior on some
	  // servers and corrupt connection state. Do not
	  // re-use the connection for further requests.

	  const expectsPayload = (
	    method === 'PUT' ||
	    method === 'POST' ||
	    method === 'PATCH'
	  );

	  if (body && typeof body.read === 'function') {
	    // Try to read EOF in order to get length.
	    body.read(0);
	  }

	  const bodyLength = util.bodyLength(body);

	  let contentLength = bodyLength;

	  if (contentLength === null) {
	    contentLength = request.contentLength;
	  }

	  if (contentLength === 0 && !expectsPayload) {
	    // https://tools.ietf.org/html/rfc7230#section-3.3.2
	    // A user agent SHOULD NOT send a Content-Length header field when
	    // the request message does not contain a payload body and the method
	    // semantics do not anticipate such a body.

	    contentLength = null;
	  }

	  // https://github.com/nodejs/undici/issues/2046
	  // A user agent may send a Content-Length header with 0 value, this should be allowed.
	  if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength !== null && request.contentLength !== contentLength) {
	    if (client[kStrictContentLength]) {
	      errorRequest(client, request, new RequestContentLengthMismatchError());
	      return false
	    }

	    process.emitWarning(new RequestContentLengthMismatchError());
	  }

	  const socket = client[kSocket];

	  try {
	    request.onConnect((err) => {
	      if (request.aborted || request.completed) {
	        return
	      }

	      errorRequest(client, request, err || new RequestAbortedError());

	      util.destroy(socket, new InformationalError('aborted'));
	    });
	  } catch (err) {
	    errorRequest(client, request, err);
	  }

	  if (request.aborted) {
	    return false
	  }

	  if (method === 'HEAD') {
	    // https://github.com/mcollina/undici/issues/258
	    // Close after a HEAD request to interop with misbehaving servers
	    // that may send a body in the response.

	    socket[kReset] = true;
	  }

	  if (upgrade || method === 'CONNECT') {
	    // On CONNECT or upgrade, block pipeline from dispatching further
	    // requests on this connection.

	    socket[kReset] = true;
	  }

	  if (reset != null) {
	    socket[kReset] = reset;
	  }

	  if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {
	    socket[kReset] = true;
	  }

	  if (blocking) {
	    socket[kBlocking] = true;
	  }

	  let header = `${method} ${path} HTTP/1.1\r\n`;

	  if (typeof host === 'string') {
	    header += `host: ${host}\r\n`;
	  } else {
	    header += client[kHostHeader];
	  }

	  if (upgrade) {
	    header += `connection: upgrade\r\nupgrade: ${upgrade}\r\n`;
	  } else if (client[kPipelining] && !socket[kReset]) {
	    header += 'connection: keep-alive\r\n';
	  } else {
	    header += 'connection: close\r\n';
	  }

	  if (headers) {
	    header += headers;
	  }

	  if (channels.sendHeaders.hasSubscribers) {
	    channels.sendHeaders.publish({ request, headers: header, socket });
	  }

	  /* istanbul ignore else: assertion */
	  if (!body || bodyLength === 0) {
	    if (contentLength === 0) {
	      socket.write(`${header}content-length: 0\r\n\r\n`, 'latin1');
	    } else {
	      assert(contentLength === null, 'no body must not have content length');
	      socket.write(`${header}\r\n`, 'latin1');
	    }
	    request.onRequestSent();
	  } else if (util.isBuffer(body)) {
	    assert(contentLength === body.byteLength, 'buffer body must have content length');

	    socket.cork();
	    socket.write(`${header}content-length: ${contentLength}\r\n\r\n`, 'latin1');
	    socket.write(body);
	    socket.uncork();
	    request.onBodySent(body);
	    request.onRequestSent();
	    if (!expectsPayload) {
	      socket[kReset] = true;
	    }
	  } else if (util.isBlobLike(body)) {
	    if (typeof body.stream === 'function') {
	      writeIterable({ body: body.stream(), client, request, socket, contentLength, header, expectsPayload });
	    } else {
	      writeBlob({ body, client, request, socket, contentLength, header, expectsPayload });
	    }
	  } else if (util.isStream(body)) {
	    writeStream({ body, client, request, socket, contentLength, header, expectsPayload });
	  } else if (util.isIterable(body)) {
	    writeIterable({ body, client, request, socket, contentLength, header, expectsPayload });
	  } else {
	    assert(false);
	  }

	  return true
	}

	function writeH2 (client, session, request) {
	  const { body, method, path, host, upgrade, expectContinue, signal, headers: reqHeaders } = request;

	  let headers;
	  if (typeof reqHeaders === 'string') headers = Request[kHTTP2CopyHeaders](reqHeaders.trim());
	  else headers = reqHeaders;

	  if (upgrade) {
	    errorRequest(client, request, new Error('Upgrade not supported for H2'));
	    return false
	  }

	  try {
	    // TODO(HTTP/2): Should we call onConnect immediately or on stream ready event?
	    request.onConnect((err) => {
	      if (request.aborted || request.completed) {
	        return
	      }

	      errorRequest(client, request, err || new RequestAbortedError());
	    });
	  } catch (err) {
	    errorRequest(client, request, err);
	  }

	  if (request.aborted) {
	    return false
	  }

	  /** @type {import('node:http2').ClientHttp2Stream} */
	  let stream;
	  const h2State = client[kHTTP2SessionState];

	  headers[HTTP2_HEADER_AUTHORITY] = host || client[kHost];
	  headers[HTTP2_HEADER_METHOD] = method;

	  if (method === 'CONNECT') {
	    session.ref();
	    // we are already connected, streams are pending, first request
	    // will create a new stream. We trigger a request to create the stream and wait until
	    // `ready` event is triggered
	    // We disabled endStream to allow the user to write to the stream
	    stream = session.request(headers, { endStream: false, signal });

	    if (stream.id && !stream.pending) {
	      request.onUpgrade(null, null, stream);
	      ++h2State.openStreams;
	    } else {
	      stream.once('ready', () => {
	        request.onUpgrade(null, null, stream);
	        ++h2State.openStreams;
	      });
	    }

	    stream.once('close', () => {
	      h2State.openStreams -= 1;
	      // TODO(HTTP/2): unref only if current streams count is 0
	      if (h2State.openStreams === 0) session.unref();
	    });

	    return true
	  }

	  // https://tools.ietf.org/html/rfc7540#section-8.3
	  // :path and :scheme headers must be omited when sending CONNECT

	  headers[HTTP2_HEADER_PATH] = path;
	  headers[HTTP2_HEADER_SCHEME] = 'https';

	  // https://tools.ietf.org/html/rfc7231#section-4.3.1
	  // https://tools.ietf.org/html/rfc7231#section-4.3.2
	  // https://tools.ietf.org/html/rfc7231#section-4.3.5

	  // Sending a payload body on a request that does not
	  // expect it can cause undefined behavior on some
	  // servers and corrupt connection state. Do not
	  // re-use the connection for further requests.

	  const expectsPayload = (
	    method === 'PUT' ||
	    method === 'POST' ||
	    method === 'PATCH'
	  );

	  if (body && typeof body.read === 'function') {
	    // Try to read EOF in order to get length.
	    body.read(0);
	  }

	  let contentLength = util.bodyLength(body);

	  if (contentLength == null) {
	    contentLength = request.contentLength;
	  }

	  if (contentLength === 0 || !expectsPayload) {
	    // https://tools.ietf.org/html/rfc7230#section-3.3.2
	    // A user agent SHOULD NOT send a Content-Length header field when
	    // the request message does not contain a payload body and the method
	    // semantics do not anticipate such a body.

	    contentLength = null;
	  }

	  // https://github.com/nodejs/undici/issues/2046
	  // A user agent may send a Content-Length header with 0 value, this should be allowed.
	  if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength != null && request.contentLength !== contentLength) {
	    if (client[kStrictContentLength]) {
	      errorRequest(client, request, new RequestContentLengthMismatchError());
	      return false
	    }

	    process.emitWarning(new RequestContentLengthMismatchError());
	  }

	  if (contentLength != null) {
	    assert(body, 'no body must not have content length');
	    headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`;
	  }

	  session.ref();

	  const shouldEndStream = method === 'GET' || method === 'HEAD';
	  if (expectContinue) {
	    headers[HTTP2_HEADER_EXPECT] = '100-continue';
	    stream = session.request(headers, { endStream: shouldEndStream, signal });

	    stream.once('continue', writeBodyH2);
	  } else {
	    stream = session.request(headers, {
	      endStream: shouldEndStream,
	      signal
	    });
	    writeBodyH2();
	  }

	  // Increment counter as we have new several streams open
	  ++h2State.openStreams;

	  stream.once('response', headers => {
	    const { [HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers;

	    if (request.onHeaders(Number(statusCode), realHeaders, stream.resume.bind(stream), '') === false) {
	      stream.pause();
	    }
	  });

	  stream.once('end', () => {
	    request.onComplete([]);
	  });

	  stream.on('data', (chunk) => {
	    if (request.onData(chunk) === false) {
	      stream.pause();
	    }
	  });

	  stream.once('close', () => {
	    h2State.openStreams -= 1;
	    // TODO(HTTP/2): unref only if current streams count is 0
	    if (h2State.openStreams === 0) {
	      session.unref();
	    }
	  });

	  stream.once('error', function (err) {
	    if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {
	      h2State.streams -= 1;
	      util.destroy(stream, err);
	    }
	  });

	  stream.once('frameError', (type, code) => {
	    const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`);
	    errorRequest(client, request, err);

	    if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {
	      h2State.streams -= 1;
	      util.destroy(stream, err);
	    }
	  });

	  // stream.on('aborted', () => {
	  //   // TODO(HTTP/2): Support aborted
	  // })

	  // stream.on('timeout', () => {
	  //   // TODO(HTTP/2): Support timeout
	  // })

	  // stream.on('push', headers => {
	  //   // TODO(HTTP/2): Suppor push
	  // })

	  // stream.on('trailers', headers => {
	  //   // TODO(HTTP/2): Support trailers
	  // })

	  return true

	  function writeBodyH2 () {
	    /* istanbul ignore else: assertion */
	    if (!body) {
	      request.onRequestSent();
	    } else if (util.isBuffer(body)) {
	      assert(contentLength === body.byteLength, 'buffer body must have content length');
	      stream.cork();
	      stream.write(body);
	      stream.uncork();
	      stream.end();
	      request.onBodySent(body);
	      request.onRequestSent();
	    } else if (util.isBlobLike(body)) {
	      if (typeof body.stream === 'function') {
	        writeIterable({
	          client,
	          request,
	          contentLength,
	          h2stream: stream,
	          expectsPayload,
	          body: body.stream(),
	          socket: client[kSocket],
	          header: ''
	        });
	      } else {
	        writeBlob({
	          body,
	          client,
	          request,
	          contentLength,
	          expectsPayload,
	          h2stream: stream,
	          header: '',
	          socket: client[kSocket]
	        });
	      }
	    } else if (util.isStream(body)) {
	      writeStream({
	        body,
	        client,
	        request,
	        contentLength,
	        expectsPayload,
	        socket: client[kSocket],
	        h2stream: stream,
	        header: ''
	      });
	    } else if (util.isIterable(body)) {
	      writeIterable({
	        body,
	        client,
	        request,
	        contentLength,
	        expectsPayload,
	        header: '',
	        h2stream: stream,
	        socket: client[kSocket]
	      });
	    } else {
	      assert(false);
	    }
	  }
	}

	function writeStream ({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
	  assert(contentLength !== 0 || client[kRunning] === 0, 'stream body cannot be pipelined');

	  if (client[kHTTPConnVersion] === 'h2') {
	    // For HTTP/2, is enough to pipe the stream
	    const pipe = pipeline(
	      body,
	      h2stream,
	      (err) => {
	        if (err) {
	          util.destroy(body, err);
	          util.destroy(h2stream, err);
	        } else {
	          request.onRequestSent();
	        }
	      }
	    );

	    pipe.on('data', onPipeData);
	    pipe.once('end', () => {
	      pipe.removeListener('data', onPipeData);
	      util.destroy(pipe);
	    });

	    function onPipeData (chunk) {
	      request.onBodySent(chunk);
	    }

	    return
	  }

	  let finished = false;

	  const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header });

	  const onData = function (chunk) {
	    if (finished) {
	      return
	    }

	    try {
	      if (!writer.write(chunk) && this.pause) {
	        this.pause();
	      }
	    } catch (err) {
	      util.destroy(this, err);
	    }
	  };
	  const onDrain = function () {
	    if (finished) {
	      return
	    }

	    if (body.resume) {
	      body.resume();
	    }
	  };
	  const onAbort = function () {
	    if (finished) {
	      return
	    }
	    const err = new RequestAbortedError();
	    queueMicrotask(() => onFinished(err));
	  };
	  const onFinished = function (err) {
	    if (finished) {
	      return
	    }

	    finished = true;

	    assert(socket.destroyed || (socket[kWriting] && client[kRunning] <= 1));

	    socket
	      .off('drain', onDrain)
	      .off('error', onFinished);

	    body
	      .removeListener('data', onData)
	      .removeListener('end', onFinished)
	      .removeListener('error', onFinished)
	      .removeListener('close', onAbort);

	    if (!err) {
	      try {
	        writer.end();
	      } catch (er) {
	        err = er;
	      }
	    }

	    writer.destroy(err);

	    if (err && (err.code !== 'UND_ERR_INFO' || err.message !== 'reset')) {
	      util.destroy(body, err);
	    } else {
	      util.destroy(body);
	    }
	  };

	  body
	    .on('data', onData)
	    .on('end', onFinished)
	    .on('error', onFinished)
	    .on('close', onAbort);

	  if (body.resume) {
	    body.resume();
	  }

	  socket
	    .on('drain', onDrain)
	    .on('error', onFinished);
	}

	async function writeBlob ({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
	  assert(contentLength === body.size, 'blob body must have content length');

	  const isH2 = client[kHTTPConnVersion] === 'h2';
	  try {
	    if (contentLength != null && contentLength !== body.size) {
	      throw new RequestContentLengthMismatchError()
	    }

	    const buffer = Buffer.from(await body.arrayBuffer());

	    if (isH2) {
	      h2stream.cork();
	      h2stream.write(buffer);
	      h2stream.uncork();
	    } else {
	      socket.cork();
	      socket.write(`${header}content-length: ${contentLength}\r\n\r\n`, 'latin1');
	      socket.write(buffer);
	      socket.uncork();
	    }

	    request.onBodySent(buffer);
	    request.onRequestSent();

	    if (!expectsPayload) {
	      socket[kReset] = true;
	    }

	    resume(client);
	  } catch (err) {
	    util.destroy(isH2 ? h2stream : socket, err);
	  }
	}

	async function writeIterable ({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
	  assert(contentLength !== 0 || client[kRunning] === 0, 'iterator body cannot be pipelined');

	  let callback = null;
	  function onDrain () {
	    if (callback) {
	      const cb = callback;
	      callback = null;
	      cb();
	    }
	  }

	  const waitForDrain = () => new Promise((resolve, reject) => {
	    assert(callback === null);

	    if (socket[kError]) {
	      reject(socket[kError]);
	    } else {
	      callback = resolve;
	    }
	  });

	  if (client[kHTTPConnVersion] === 'h2') {
	    h2stream
	      .on('close', onDrain)
	      .on('drain', onDrain);

	    try {
	      // It's up to the user to somehow abort the async iterable.
	      for await (const chunk of body) {
	        if (socket[kError]) {
	          throw socket[kError]
	        }

	        const res = h2stream.write(chunk);
	        request.onBodySent(chunk);
	        if (!res) {
	          await waitForDrain();
	        }
	      }
	    } catch (err) {
	      h2stream.destroy(err);
	    } finally {
	      request.onRequestSent();
	      h2stream.end();
	      h2stream
	        .off('close', onDrain)
	        .off('drain', onDrain);
	    }

	    return
	  }

	  socket
	    .on('close', onDrain)
	    .on('drain', onDrain);

	  const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header });
	  try {
	    // It's up to the user to somehow abort the async iterable.
	    for await (const chunk of body) {
	      if (socket[kError]) {
	        throw socket[kError]
	      }

	      if (!writer.write(chunk)) {
	        await waitForDrain();
	      }
	    }

	    writer.end();
	  } catch (err) {
	    writer.destroy(err);
	  } finally {
	    socket
	      .off('close', onDrain)
	      .off('drain', onDrain);
	  }
	}

	class AsyncWriter {
	  constructor ({ socket, request, contentLength, client, expectsPayload, header }) {
	    this.socket = socket;
	    this.request = request;
	    this.contentLength = contentLength;
	    this.client = client;
	    this.bytesWritten = 0;
	    this.expectsPayload = expectsPayload;
	    this.header = header;

	    socket[kWriting] = true;
	  }

	  write (chunk) {
	    const { socket, request, contentLength, client, bytesWritten, expectsPayload, header } = this;

	    if (socket[kError]) {
	      throw socket[kError]
	    }

	    if (socket.destroyed) {
	      return false
	    }

	    const len = Buffer.byteLength(chunk);
	    if (!len) {
	      return true
	    }

	    // We should defer writing chunks.
	    if (contentLength !== null && bytesWritten + len > contentLength) {
	      if (client[kStrictContentLength]) {
	        throw new RequestContentLengthMismatchError()
	      }

	      process.emitWarning(new RequestContentLengthMismatchError());
	    }

	    socket.cork();

	    if (bytesWritten === 0) {
	      if (!expectsPayload) {
	        socket[kReset] = true;
	      }

	      if (contentLength === null) {
	        socket.write(`${header}transfer-encoding: chunked\r\n`, 'latin1');
	      } else {
	        socket.write(`${header}content-length: ${contentLength}\r\n\r\n`, 'latin1');
	      }
	    }

	    if (contentLength === null) {
	      socket.write(`\r\n${len.toString(16)}\r\n`, 'latin1');
	    }

	    this.bytesWritten += len;

	    const ret = socket.write(chunk);

	    socket.uncork();

	    request.onBodySent(chunk);

	    if (!ret) {
	      if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
	        // istanbul ignore else: only for jest
	        if (socket[kParser].timeout.refresh) {
	          socket[kParser].timeout.refresh();
	        }
	      }
	    }

	    return ret
	  }

	  end () {
	    const { socket, contentLength, client, bytesWritten, expectsPayload, header, request } = this;
	    request.onRequestSent();

	    socket[kWriting] = false;

	    if (socket[kError]) {
	      throw socket[kError]
	    }

	    if (socket.destroyed) {
	      return
	    }

	    if (bytesWritten === 0) {
	      if (expectsPayload) {
	        // https://tools.ietf.org/html/rfc7230#section-3.3.2
	        // A user agent SHOULD send a Content-Length in a request message when
	        // no Transfer-Encoding is sent and the request method defines a meaning
	        // for an enclosed payload body.

	        socket.write(`${header}content-length: 0\r\n\r\n`, 'latin1');
	      } else {
	        socket.write(`${header}\r\n`, 'latin1');
	      }
	    } else if (contentLength === null) {
	      socket.write('\r\n0\r\n\r\n', 'latin1');
	    }

	    if (contentLength !== null && bytesWritten !== contentLength) {
	      if (client[kStrictContentLength]) {
	        throw new RequestContentLengthMismatchError()
	      } else {
	        process.emitWarning(new RequestContentLengthMismatchError());
	      }
	    }

	    if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
	      // istanbul ignore else: only for jest
	      if (socket[kParser].timeout.refresh) {
	        socket[kParser].timeout.refresh();
	      }
	    }

	    resume(client);
	  }

	  destroy (err) {
	    const { socket, client } = this;

	    socket[kWriting] = false;

	    if (err) {
	      assert(client[kRunning] <= 1, 'pipeline should only contain this request');
	      util.destroy(socket, err);
	    }
	  }
	}

	function errorRequest (client, request, err) {
	  try {
	    request.onError(err);
	    assert(request.aborted);
	  } catch (err) {
	    client.emit('error', err);
	  }
	}

	client = Client;
	return client;
}

/* eslint-disable */

var fixedQueue;
var hasRequiredFixedQueue;

function requireFixedQueue () {
	if (hasRequiredFixedQueue) return fixedQueue;
	hasRequiredFixedQueue = 1;

	// Extracted from node/lib/internal/fixed_queue.js

	// Currently optimal queue size, tested on V8 6.0 - 6.6. Must be power of two.
	const kSize = 2048;
	const kMask = kSize - 1;

	// The FixedQueue is implemented as a singly-linked list of fixed-size
	// circular buffers. It looks something like this:
	//
	//  head                                                       tail
	//    |                                                          |
	//    v                                                          v
	// +-----------+ <-----\       +-----------+ <------\         +-----------+
	// |  [null]   |        \----- |   next    |         \------- |   next    |
	// +-----------+               +-----------+                  +-----------+
	// |   item    | <-- bottom    |   item    | <-- bottom       |  [empty]  |
	// |   item    |               |   item    |                  |  [empty]  |
	// |   item    |               |   item    |                  |  [empty]  |
	// |   item    |               |   item    |                  |  [empty]  |
	// |   item    |               |   item    |       bottom --> |   item    |
	// |   item    |               |   item    |                  |   item    |
	// |    ...    |               |    ...    |                  |    ...    |
	// |   item    |               |   item    |                  |   item    |
	// |   item    |               |   item    |                  |   item    |
	// |  [empty]  | <-- top       |   item    |                  |   item    |
	// |  [empty]  |               |   item    |                  |   item    |
	// |  [empty]  |               |  [empty]  | <-- top  top --> |  [empty]  |
	// +-----------+               +-----------+                  +-----------+
	//
	// Or, if there is only one circular buffer, it looks something
	// like either of these:
	//
	//  head   tail                                 head   tail
	//    |     |                                     |     |
	//    v     v                                     v     v
	// +-----------+                               +-----------+
	// |  [null]   |                               |  [null]   |
	// +-----------+                               +-----------+
	// |  [empty]  |                               |   item    |
	// |  [empty]  |                               |   item    |
	// |   item    | <-- bottom            top --> |  [empty]  |
	// |   item    |                               |  [empty]  |
	// |  [empty]  | <-- top            bottom --> |   item    |
	// |  [empty]  |                               |   item    |
	// +-----------+                               +-----------+
	//
	// Adding a value means moving `top` forward by one, removing means
	// moving `bottom` forward by one. After reaching the end, the queue
	// wraps around.
	//
	// When `top === bottom` the current queue is empty and when
	// `top + 1 === bottom` it's full. This wastes a single space of storage
	// but allows much quicker checks.

	class FixedCircularBuffer {
	  constructor() {
	    this.bottom = 0;
	    this.top = 0;
	    this.list = new Array(kSize);
	    this.next = null;
	  }

	  isEmpty() {
	    return this.top === this.bottom;
	  }

	  isFull() {
	    return ((this.top + 1) & kMask) === this.bottom;
	  }

	  push(data) {
	    this.list[this.top] = data;
	    this.top = (this.top + 1) & kMask;
	  }

	  shift() {
	    const nextItem = this.list[this.bottom];
	    if (nextItem === undefined)
	      return null;
	    this.list[this.bottom] = undefined;
	    this.bottom = (this.bottom + 1) & kMask;
	    return nextItem;
	  }
	}

	fixedQueue = class FixedQueue {
	  constructor() {
	    this.head = this.tail = new FixedCircularBuffer();
	  }

	  isEmpty() {
	    return this.head.isEmpty();
	  }

	  push(data) {
	    if (this.head.isFull()) {
	      // Head is full: Creates a new queue, sets the old queue's `.next` to it,
	      // and sets it as the new main queue.
	      this.head = this.head.next = new FixedCircularBuffer();
	    }
	    this.head.push(data);
	  }

	  shift() {
	    const tail = this.tail;
	    const next = tail.shift();
	    if (tail.isEmpty() && tail.next !== null) {
	      // If there is another queue, it forms the new tail.
	      this.tail = tail.next;
	    }
	    return next;
	  }
	};
	return fixedQueue;
}

var poolStats;
var hasRequiredPoolStats;

function requirePoolStats () {
	if (hasRequiredPoolStats) return poolStats;
	hasRequiredPoolStats = 1;
	const { kFree, kConnected, kPending, kQueued, kRunning, kSize } = requireSymbols$4();
	const kPool = Symbol('pool');

	class PoolStats {
	  constructor (pool) {
	    this[kPool] = pool;
	  }

	  get connected () {
	    return this[kPool][kConnected]
	  }

	  get free () {
	    return this[kPool][kFree]
	  }

	  get pending () {
	    return this[kPool][kPending]
	  }

	  get queued () {
	    return this[kPool][kQueued]
	  }

	  get running () {
	    return this[kPool][kRunning]
	  }

	  get size () {
	    return this[kPool][kSize]
	  }
	}

	poolStats = PoolStats;
	return poolStats;
}

var poolBase;
var hasRequiredPoolBase;

function requirePoolBase () {
	if (hasRequiredPoolBase) return poolBase;
	hasRequiredPoolBase = 1;

	const DispatcherBase = requireDispatcherBase();
	const FixedQueue = requireFixedQueue();
	const { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } = requireSymbols$4();
	const PoolStats = requirePoolStats();

	const kClients = Symbol('clients');
	const kNeedDrain = Symbol('needDrain');
	const kQueue = Symbol('queue');
	const kClosedResolve = Symbol('closed resolve');
	const kOnDrain = Symbol('onDrain');
	const kOnConnect = Symbol('onConnect');
	const kOnDisconnect = Symbol('onDisconnect');
	const kOnConnectionError = Symbol('onConnectionError');
	const kGetDispatcher = Symbol('get dispatcher');
	const kAddClient = Symbol('add client');
	const kRemoveClient = Symbol('remove client');
	const kStats = Symbol('stats');

	class PoolBase extends DispatcherBase {
	  constructor () {
	    super();

	    this[kQueue] = new FixedQueue();
	    this[kClients] = [];
	    this[kQueued] = 0;

	    const pool = this;

	    this[kOnDrain] = function onDrain (origin, targets) {
	      const queue = pool[kQueue];

	      let needDrain = false;

	      while (!needDrain) {
	        const item = queue.shift();
	        if (!item) {
	          break
	        }
	        pool[kQueued]--;
	        needDrain = !this.dispatch(item.opts, item.handler);
	      }

	      this[kNeedDrain] = needDrain;

	      if (!this[kNeedDrain] && pool[kNeedDrain]) {
	        pool[kNeedDrain] = false;
	        pool.emit('drain', origin, [pool, ...targets]);
	      }

	      if (pool[kClosedResolve] && queue.isEmpty()) {
	        Promise
	          .all(pool[kClients].map(c => c.close()))
	          .then(pool[kClosedResolve]);
	      }
	    };

	    this[kOnConnect] = (origin, targets) => {
	      pool.emit('connect', origin, [pool, ...targets]);
	    };

	    this[kOnDisconnect] = (origin, targets, err) => {
	      pool.emit('disconnect', origin, [pool, ...targets], err);
	    };

	    this[kOnConnectionError] = (origin, targets, err) => {
	      pool.emit('connectionError', origin, [pool, ...targets], err);
	    };

	    this[kStats] = new PoolStats(this);
	  }

	  get [kBusy] () {
	    return this[kNeedDrain]
	  }

	  get [kConnected] () {
	    return this[kClients].filter(client => client[kConnected]).length
	  }

	  get [kFree] () {
	    return this[kClients].filter(client => client[kConnected] && !client[kNeedDrain]).length
	  }

	  get [kPending] () {
	    let ret = this[kQueued];
	    for (const { [kPending]: pending } of this[kClients]) {
	      ret += pending;
	    }
	    return ret
	  }

	  get [kRunning] () {
	    let ret = 0;
	    for (const { [kRunning]: running } of this[kClients]) {
	      ret += running;
	    }
	    return ret
	  }

	  get [kSize] () {
	    let ret = this[kQueued];
	    for (const { [kSize]: size } of this[kClients]) {
	      ret += size;
	    }
	    return ret
	  }

	  get stats () {
	    return this[kStats]
	  }

	  async [kClose] () {
	    if (this[kQueue].isEmpty()) {
	      return Promise.all(this[kClients].map(c => c.close()))
	    } else {
	      return new Promise((resolve) => {
	        this[kClosedResolve] = resolve;
	      })
	    }
	  }

	  async [kDestroy] (err) {
	    while (true) {
	      const item = this[kQueue].shift();
	      if (!item) {
	        break
	      }
	      item.handler.onError(err);
	    }

	    return Promise.all(this[kClients].map(c => c.destroy(err)))
	  }

	  [kDispatch] (opts, handler) {
	    const dispatcher = this[kGetDispatcher]();

	    if (!dispatcher) {
	      this[kNeedDrain] = true;
	      this[kQueue].push({ opts, handler });
	      this[kQueued]++;
	    } else if (!dispatcher.dispatch(opts, handler)) {
	      dispatcher[kNeedDrain] = true;
	      this[kNeedDrain] = !this[kGetDispatcher]();
	    }

	    return !this[kNeedDrain]
	  }

	  [kAddClient] (client) {
	    client
	      .on('drain', this[kOnDrain])
	      .on('connect', this[kOnConnect])
	      .on('disconnect', this[kOnDisconnect])
	      .on('connectionError', this[kOnConnectionError]);

	    this[kClients].push(client);

	    if (this[kNeedDrain]) {
	      process.nextTick(() => {
	        if (this[kNeedDrain]) {
	          this[kOnDrain](client[kUrl], [this, client]);
	        }
	      });
	    }

	    return this
	  }

	  [kRemoveClient] (client) {
	    client.close(() => {
	      const idx = this[kClients].indexOf(client);
	      if (idx !== -1) {
	        this[kClients].splice(idx, 1);
	      }
	    });

	    this[kNeedDrain] = this[kClients].some(dispatcher => (
	      !dispatcher[kNeedDrain] &&
	      dispatcher.closed !== true &&
	      dispatcher.destroyed !== true
	    ));
	  }
	}

	poolBase = {
	  PoolBase,
	  kClients,
	  kNeedDrain,
	  kAddClient,
	  kRemoveClient,
	  kGetDispatcher
	};
	return poolBase;
}

var pool;
var hasRequiredPool;

function requirePool () {
	if (hasRequiredPool) return pool;
	hasRequiredPool = 1;

	const {
	  PoolBase,
	  kClients,
	  kNeedDrain,
	  kAddClient,
	  kGetDispatcher
	} = requirePoolBase();
	const Client = requireClient();
	const {
	  InvalidArgumentError
	} = requireErrors();
	const util = requireUtil$6();
	const { kUrl, kInterceptors } = requireSymbols$4();
	const buildConnector = requireConnect();

	const kOptions = Symbol('options');
	const kConnections = Symbol('connections');
	const kFactory = Symbol('factory');

	function defaultFactory (origin, opts) {
	  return new Client(origin, opts)
	}

	class Pool extends PoolBase {
	  constructor (origin, {
	    connections,
	    factory = defaultFactory,
	    connect,
	    connectTimeout,
	    tls,
	    maxCachedSessions,
	    socketPath,
	    autoSelectFamily,
	    autoSelectFamilyAttemptTimeout,
	    allowH2,
	    ...options
	  } = {}) {
	    super();

	    if (connections != null && (!Number.isFinite(connections) || connections < 0)) {
	      throw new InvalidArgumentError('invalid connections')
	    }

	    if (typeof factory !== 'function') {
	      throw new InvalidArgumentError('factory must be a function.')
	    }

	    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {
	      throw new InvalidArgumentError('connect must be a function or an object')
	    }

	    if (typeof connect !== 'function') {
	      connect = buildConnector({
	        ...tls,
	        maxCachedSessions,
	        allowH2,
	        socketPath,
	        timeout: connectTimeout,
	        ...(util.nodeHasAutoSelectFamily && autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : undefined),
	        ...connect
	      });
	    }

	    this[kInterceptors] = options.interceptors && options.interceptors.Pool && Array.isArray(options.interceptors.Pool)
	      ? options.interceptors.Pool
	      : [];
	    this[kConnections] = connections || null;
	    this[kUrl] = util.parseOrigin(origin);
	    this[kOptions] = { ...util.deepClone(options), connect, allowH2 };
	    this[kOptions].interceptors = options.interceptors
	      ? { ...options.interceptors }
	      : undefined;
	    this[kFactory] = factory;

	    this.on('connectionError', (origin, targets, error) => {
	      // If a connection error occurs, we remove the client from the pool,
	      // and emit a connectionError event. They will not be re-used.
	      // Fixes https://github.com/nodejs/undici/issues/3895
	      for (const target of targets) {
	        // Do not use kRemoveClient here, as it will close the client,
	        // but the client cannot be closed in this state.
	        const idx = this[kClients].indexOf(target);
	        if (idx !== -1) {
	          this[kClients].splice(idx, 1);
	        }
	      }
	    });
	  }

	  [kGetDispatcher] () {
	    let dispatcher = this[kClients].find(dispatcher => !dispatcher[kNeedDrain]);

	    if (dispatcher) {
	      return dispatcher
	    }

	    if (!this[kConnections] || this[kClients].length < this[kConnections]) {
	      dispatcher = this[kFactory](this[kUrl], this[kOptions]);
	      this[kAddClient](dispatcher);
	    }

	    return dispatcher
	  }
	}

	pool = Pool;
	return pool;
}

var balancedPool;
var hasRequiredBalancedPool;

function requireBalancedPool () {
	if (hasRequiredBalancedPool) return balancedPool;
	hasRequiredBalancedPool = 1;

	const {
	  BalancedPoolMissingUpstreamError,
	  InvalidArgumentError
	} = requireErrors();
	const {
	  PoolBase,
	  kClients,
	  kNeedDrain,
	  kAddClient,
	  kRemoveClient,
	  kGetDispatcher
	} = requirePoolBase();
	const Pool = requirePool();
	const { kUrl, kInterceptors } = requireSymbols$4();
	const { parseOrigin } = requireUtil$6();
	const kFactory = Symbol('factory');

	const kOptions = Symbol('options');
	const kGreatestCommonDivisor = Symbol('kGreatestCommonDivisor');
	const kCurrentWeight = Symbol('kCurrentWeight');
	const kIndex = Symbol('kIndex');
	const kWeight = Symbol('kWeight');
	const kMaxWeightPerServer = Symbol('kMaxWeightPerServer');
	const kErrorPenalty = Symbol('kErrorPenalty');

	function getGreatestCommonDivisor (a, b) {
	  if (b === 0) return a
	  return getGreatestCommonDivisor(b, a % b)
	}

	function defaultFactory (origin, opts) {
	  return new Pool(origin, opts)
	}

	class BalancedPool extends PoolBase {
	  constructor (upstreams = [], { factory = defaultFactory, ...opts } = {}) {
	    super();

	    this[kOptions] = opts;
	    this[kIndex] = -1;
	    this[kCurrentWeight] = 0;

	    this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100;
	    this[kErrorPenalty] = this[kOptions].errorPenalty || 15;

	    if (!Array.isArray(upstreams)) {
	      upstreams = [upstreams];
	    }

	    if (typeof factory !== 'function') {
	      throw new InvalidArgumentError('factory must be a function.')
	    }

	    this[kInterceptors] = opts.interceptors && opts.interceptors.BalancedPool && Array.isArray(opts.interceptors.BalancedPool)
	      ? opts.interceptors.BalancedPool
	      : [];
	    this[kFactory] = factory;

	    for (const upstream of upstreams) {
	      this.addUpstream(upstream);
	    }
	    this._updateBalancedPoolStats();
	  }

	  addUpstream (upstream) {
	    const upstreamOrigin = parseOrigin(upstream).origin;

	    if (this[kClients].find((pool) => (
	      pool[kUrl].origin === upstreamOrigin &&
	      pool.closed !== true &&
	      pool.destroyed !== true
	    ))) {
	      return this
	    }
	    const pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]));

	    this[kAddClient](pool);
	    pool.on('connect', () => {
	      pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty]);
	    });

	    pool.on('connectionError', () => {
	      pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
	      this._updateBalancedPoolStats();
	    });

	    pool.on('disconnect', (...args) => {
	      const err = args[2];
	      if (err && err.code === 'UND_ERR_SOCKET') {
	        // decrease the weight of the pool.
	        pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
	        this._updateBalancedPoolStats();
	      }
	    });

	    for (const client of this[kClients]) {
	      client[kWeight] = this[kMaxWeightPerServer];
	    }

	    this._updateBalancedPoolStats();

	    return this
	  }

	  _updateBalancedPoolStats () {
	    this[kGreatestCommonDivisor] = this[kClients].map(p => p[kWeight]).reduce(getGreatestCommonDivisor, 0);
	  }

	  removeUpstream (upstream) {
	    const upstreamOrigin = parseOrigin(upstream).origin;

	    const pool = this[kClients].find((pool) => (
	      pool[kUrl].origin === upstreamOrigin &&
	      pool.closed !== true &&
	      pool.destroyed !== true
	    ));

	    if (pool) {
	      this[kRemoveClient](pool);
	    }

	    return this
	  }

	  get upstreams () {
	    return this[kClients]
	      .filter(dispatcher => dispatcher.closed !== true && dispatcher.destroyed !== true)
	      .map((p) => p[kUrl].origin)
	  }

	  [kGetDispatcher] () {
	    // We validate that pools is greater than 0,
	    // otherwise we would have to wait until an upstream
	    // is added, which might never happen.
	    if (this[kClients].length === 0) {
	      throw new BalancedPoolMissingUpstreamError()
	    }

	    const dispatcher = this[kClients].find(dispatcher => (
	      !dispatcher[kNeedDrain] &&
	      dispatcher.closed !== true &&
	      dispatcher.destroyed !== true
	    ));

	    if (!dispatcher) {
	      return
	    }

	    const allClientsBusy = this[kClients].map(pool => pool[kNeedDrain]).reduce((a, b) => a && b, true);

	    if (allClientsBusy) {
	      return
	    }

	    let counter = 0;

	    let maxWeightIndex = this[kClients].findIndex(pool => !pool[kNeedDrain]);

	    while (counter++ < this[kClients].length) {
	      this[kIndex] = (this[kIndex] + 1) % this[kClients].length;
	      const pool = this[kClients][this[kIndex]];

	      // find pool index with the largest weight
	      if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain]) {
	        maxWeightIndex = this[kIndex];
	      }

	      // decrease the current weight every `this[kClients].length`.
	      if (this[kIndex] === 0) {
	        // Set the current weight to the next lower weight.
	        this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor];

	        if (this[kCurrentWeight] <= 0) {
	          this[kCurrentWeight] = this[kMaxWeightPerServer];
	        }
	      }
	      if (pool[kWeight] >= this[kCurrentWeight] && (!pool[kNeedDrain])) {
	        return pool
	      }
	    }

	    this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight];
	    this[kIndex] = maxWeightIndex;
	    return this[kClients][maxWeightIndex]
	  }
	}

	balancedPool = BalancedPool;
	return balancedPool;
}

var dispatcherWeakref;
var hasRequiredDispatcherWeakref;

function requireDispatcherWeakref () {
	if (hasRequiredDispatcherWeakref) return dispatcherWeakref;
	hasRequiredDispatcherWeakref = 1;

	/* istanbul ignore file: only for Node 12 */

	const { kConnected, kSize } = requireSymbols$4();

	class CompatWeakRef {
	  constructor (value) {
	    this.value = value;
	  }

	  deref () {
	    return this.value[kConnected] === 0 && this.value[kSize] === 0
	      ? undefined
	      : this.value
	  }
	}

	class CompatFinalizer {
	  constructor (finalizer) {
	    this.finalizer = finalizer;
	  }

	  register (dispatcher, key) {
	    if (dispatcher.on) {
	      dispatcher.on('disconnect', () => {
	        if (dispatcher[kConnected] === 0 && dispatcher[kSize] === 0) {
	          this.finalizer(key);
	        }
	      });
	    }
	  }
	}

	dispatcherWeakref = function () {
	  // FIXME: remove workaround when the Node bug is fixed
	  // https://github.com/nodejs/node/issues/49344#issuecomment-1741776308
	  if (process.env.NODE_V8_COVERAGE) {
	    return {
	      WeakRef: CompatWeakRef,
	      FinalizationRegistry: CompatFinalizer
	    }
	  }
	  return {
	    WeakRef: commonjsGlobal.WeakRef || CompatWeakRef,
	    FinalizationRegistry: commonjsGlobal.FinalizationRegistry || CompatFinalizer
	  }
	};
	return dispatcherWeakref;
}

var agent;
var hasRequiredAgent;

function requireAgent () {
	if (hasRequiredAgent) return agent;
	hasRequiredAgent = 1;

	const { InvalidArgumentError } = requireErrors();
	const { kClients, kRunning, kClose, kDestroy, kDispatch, kInterceptors } = requireSymbols$4();
	const DispatcherBase = requireDispatcherBase();
	const Pool = requirePool();
	const Client = requireClient();
	const util = requireUtil$6();
	const createRedirectInterceptor = requireRedirectInterceptor();
	const { WeakRef, FinalizationRegistry } = requireDispatcherWeakref()();

	const kOnConnect = Symbol('onConnect');
	const kOnDisconnect = Symbol('onDisconnect');
	const kOnConnectionError = Symbol('onConnectionError');
	const kMaxRedirections = Symbol('maxRedirections');
	const kOnDrain = Symbol('onDrain');
	const kFactory = Symbol('factory');
	const kFinalizer = Symbol('finalizer');
	const kOptions = Symbol('options');

	function defaultFactory (origin, opts) {
	  return opts && opts.connections === 1
	    ? new Client(origin, opts)
	    : new Pool(origin, opts)
	}

	class Agent extends DispatcherBase {
	  constructor ({ factory = defaultFactory, maxRedirections = 0, connect, ...options } = {}) {
	    super();

	    if (typeof factory !== 'function') {
	      throw new InvalidArgumentError('factory must be a function.')
	    }

	    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {
	      throw new InvalidArgumentError('connect must be a function or an object')
	    }

	    if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {
	      throw new InvalidArgumentError('maxRedirections must be a positive number')
	    }

	    if (connect && typeof connect !== 'function') {
	      connect = { ...connect };
	    }

	    this[kInterceptors] = options.interceptors && options.interceptors.Agent && Array.isArray(options.interceptors.Agent)
	      ? options.interceptors.Agent
	      : [createRedirectInterceptor({ maxRedirections })];

	    this[kOptions] = { ...util.deepClone(options), connect };
	    this[kOptions].interceptors = options.interceptors
	      ? { ...options.interceptors }
	      : undefined;
	    this[kMaxRedirections] = maxRedirections;
	    this[kFactory] = factory;
	    this[kClients] = new Map();
	    this[kFinalizer] = new FinalizationRegistry(/* istanbul ignore next: gc is undeterministic */ key => {
	      const ref = this[kClients].get(key);
	      if (ref !== undefined && ref.deref() === undefined) {
	        this[kClients].delete(key);
	      }
	    });

	    const agent = this;

	    this[kOnDrain] = (origin, targets) => {
	      agent.emit('drain', origin, [agent, ...targets]);
	    };

	    this[kOnConnect] = (origin, targets) => {
	      agent.emit('connect', origin, [agent, ...targets]);
	    };

	    this[kOnDisconnect] = (origin, targets, err) => {
	      agent.emit('disconnect', origin, [agent, ...targets], err);
	    };

	    this[kOnConnectionError] = (origin, targets, err) => {
	      agent.emit('connectionError', origin, [agent, ...targets], err);
	    };
	  }

	  get [kRunning] () {
	    let ret = 0;
	    for (const ref of this[kClients].values()) {
	      const client = ref.deref();
	      /* istanbul ignore next: gc is undeterministic */
	      if (client) {
	        ret += client[kRunning];
	      }
	    }
	    return ret
	  }

	  [kDispatch] (opts, handler) {
	    let key;
	    if (opts.origin && (typeof opts.origin === 'string' || opts.origin instanceof URL)) {
	      key = String(opts.origin);
	    } else {
	      throw new InvalidArgumentError('opts.origin must be a non-empty string or URL.')
	    }

	    const ref = this[kClients].get(key);

	    let dispatcher = ref ? ref.deref() : null;
	    if (!dispatcher) {
	      dispatcher = this[kFactory](opts.origin, this[kOptions])
	        .on('drain', this[kOnDrain])
	        .on('connect', this[kOnConnect])
	        .on('disconnect', this[kOnDisconnect])
	        .on('connectionError', this[kOnConnectionError]);

	      this[kClients].set(key, new WeakRef(dispatcher));
	      this[kFinalizer].register(dispatcher, key);
	    }

	    return dispatcher.dispatch(opts, handler)
	  }

	  async [kClose] () {
	    const closePromises = [];
	    for (const ref of this[kClients].values()) {
	      const client = ref.deref();
	      /* istanbul ignore else: gc is undeterministic */
	      if (client) {
	        closePromises.push(client.close());
	      }
	    }

	    await Promise.all(closePromises);
	  }

	  async [kDestroy] (err) {
	    const destroyPromises = [];
	    for (const ref of this[kClients].values()) {
	      const client = ref.deref();
	      /* istanbul ignore else: gc is undeterministic */
	      if (client) {
	        destroyPromises.push(client.destroy(err));
	      }
	    }

	    await Promise.all(destroyPromises);
	  }
	}

	agent = Agent;
	return agent;
}

var api = {};

var apiRequest = {exports: {}};

var readable$1;
var hasRequiredReadable;

function requireReadable () {
	if (hasRequiredReadable) return readable$1;
	hasRequiredReadable = 1;

	const assert = require$$0$4;
	const { Readable } = require$$0$6;
	const { RequestAbortedError, NotSupportedError, InvalidArgumentError } = requireErrors();
	const util = requireUtil$6();
	const { ReadableStreamFrom, toUSVString } = requireUtil$6();

	let Blob;

	const kConsume = Symbol('kConsume');
	const kReading = Symbol('kReading');
	const kBody = Symbol('kBody');
	const kAbort = Symbol('abort');
	const kContentType = Symbol('kContentType');

	const noop = () => {};

	readable$1 = class BodyReadable extends Readable {
	  constructor ({
	    resume,
	    abort,
	    contentType = '',
	    highWaterMark = 64 * 1024 // Same as nodejs fs streams.
	  }) {
	    super({
	      autoDestroy: true,
	      read: resume,
	      highWaterMark
	    });

	    this._readableState.dataEmitted = false;

	    this[kAbort] = abort;
	    this[kConsume] = null;
	    this[kBody] = null;
	    this[kContentType] = contentType;

	    // Is stream being consumed through Readable API?
	    // This is an optimization so that we avoid checking
	    // for 'data' and 'readable' listeners in the hot path
	    // inside push().
	    this[kReading] = false;
	  }

	  destroy (err) {
	    if (this.destroyed) {
	      // Node < 16
	      return this
	    }

	    if (!err && !this._readableState.endEmitted) {
	      err = new RequestAbortedError();
	    }

	    if (err) {
	      this[kAbort]();
	    }

	    return super.destroy(err)
	  }

	  emit (ev, ...args) {
	    if (ev === 'data') {
	      // Node < 16.7
	      this._readableState.dataEmitted = true;
	    } else if (ev === 'error') {
	      // Node < 16
	      this._readableState.errorEmitted = true;
	    }
	    return super.emit(ev, ...args)
	  }

	  on (ev, ...args) {
	    if (ev === 'data' || ev === 'readable') {
	      this[kReading] = true;
	    }
	    return super.on(ev, ...args)
	  }

	  addListener (ev, ...args) {
	    return this.on(ev, ...args)
	  }

	  off (ev, ...args) {
	    const ret = super.off(ev, ...args);
	    if (ev === 'data' || ev === 'readable') {
	      this[kReading] = (
	        this.listenerCount('data') > 0 ||
	        this.listenerCount('readable') > 0
	      );
	    }
	    return ret
	  }

	  removeListener (ev, ...args) {
	    return this.off(ev, ...args)
	  }

	  push (chunk) {
	    if (this[kConsume] && chunk !== null && this.readableLength === 0) {
	      consumePush(this[kConsume], chunk);
	      return this[kReading] ? super.push(chunk) : true
	    }
	    return super.push(chunk)
	  }

	  // https://fetch.spec.whatwg.org/#dom-body-text
	  async text () {
	    return consume(this, 'text')
	  }

	  // https://fetch.spec.whatwg.org/#dom-body-json
	  async json () {
	    return consume(this, 'json')
	  }

	  // https://fetch.spec.whatwg.org/#dom-body-blob
	  async blob () {
	    return consume(this, 'blob')
	  }

	  // https://fetch.spec.whatwg.org/#dom-body-arraybuffer
	  async arrayBuffer () {
	    return consume(this, 'arrayBuffer')
	  }

	  // https://fetch.spec.whatwg.org/#dom-body-formdata
	  async formData () {
	    // TODO: Implement.
	    throw new NotSupportedError()
	  }

	  // https://fetch.spec.whatwg.org/#dom-body-bodyused
	  get bodyUsed () {
	    return util.isDisturbed(this)
	  }

	  // https://fetch.spec.whatwg.org/#dom-body-body
	  get body () {
	    if (!this[kBody]) {
	      this[kBody] = ReadableStreamFrom(this);
	      if (this[kConsume]) {
	        // TODO: Is this the best way to force a lock?
	        this[kBody].getReader(); // Ensure stream is locked.
	        assert(this[kBody].locked);
	      }
	    }
	    return this[kBody]
	  }

	  dump (opts) {
	    let limit = opts && Number.isFinite(opts.limit) ? opts.limit : 262144;
	    const signal = opts && opts.signal;

	    if (signal) {
	      try {
	        if (typeof signal !== 'object' || !('aborted' in signal)) {
	          throw new InvalidArgumentError('signal must be an AbortSignal')
	        }
	        util.throwIfAborted(signal);
	      } catch (err) {
	        return Promise.reject(err)
	      }
	    }

	    if (this.closed) {
	      return Promise.resolve(null)
	    }

	    return new Promise((resolve, reject) => {
	      const signalListenerCleanup = signal
	        ? util.addAbortListener(signal, () => {
	          this.destroy();
	        })
	        : noop;

	      this
	        .on('close', function () {
	          signalListenerCleanup();
	          if (signal && signal.aborted) {
	            reject(signal.reason || Object.assign(new Error('The operation was aborted'), { name: 'AbortError' }));
	          } else {
	            resolve(null);
	          }
	        })
	        .on('error', noop)
	        .on('data', function (chunk) {
	          limit -= chunk.length;
	          if (limit <= 0) {
	            this.destroy();
	          }
	        })
	        .resume();
	    })
	  }
	};

	// https://streams.spec.whatwg.org/#readablestream-locked
	function isLocked (self) {
	  // Consume is an implicit lock.
	  return (self[kBody] && self[kBody].locked === true) || self[kConsume]
	}

	// https://fetch.spec.whatwg.org/#body-unusable
	function isUnusable (self) {
	  return util.isDisturbed(self) || isLocked(self)
	}

	async function consume (stream, type) {
	  if (isUnusable(stream)) {
	    throw new TypeError('unusable')
	  }

	  assert(!stream[kConsume]);

	  return new Promise((resolve, reject) => {
	    stream[kConsume] = {
	      type,
	      stream,
	      resolve,
	      reject,
	      length: 0,
	      body: []
	    };

	    stream
	      .on('error', function (err) {
	        consumeFinish(this[kConsume], err);
	      })
	      .on('close', function () {
	        if (this[kConsume].body !== null) {
	          consumeFinish(this[kConsume], new RequestAbortedError());
	        }
	      });

	    process.nextTick(consumeStart, stream[kConsume]);
	  })
	}

	function consumeStart (consume) {
	  if (consume.body === null) {
	    return
	  }

	  const { _readableState: state } = consume.stream;

	  for (const chunk of state.buffer) {
	    consumePush(consume, chunk);
	  }

	  if (state.endEmitted) {
	    consumeEnd(this[kConsume]);
	  } else {
	    consume.stream.on('end', function () {
	      consumeEnd(this[kConsume]);
	    });
	  }

	  consume.stream.resume();

	  while (consume.stream.read() != null) {
	    // Loop
	  }
	}

	function consumeEnd (consume) {
	  const { type, body, resolve, stream, length } = consume;

	  try {
	    if (type === 'text') {
	      resolve(toUSVString(Buffer.concat(body)));
	    } else if (type === 'json') {
	      resolve(JSON.parse(Buffer.concat(body)));
	    } else if (type === 'arrayBuffer') {
	      const dst = new Uint8Array(length);

	      let pos = 0;
	      for (const buf of body) {
	        dst.set(buf, pos);
	        pos += buf.byteLength;
	      }

	      resolve(dst.buffer);
	    } else if (type === 'blob') {
	      if (!Blob) {
	        Blob = require('buffer').Blob;
	      }
	      resolve(new Blob(body, { type: stream[kContentType] }));
	    }

	    consumeFinish(consume);
	  } catch (err) {
	    stream.destroy(err);
	  }
	}

	function consumePush (consume, chunk) {
	  consume.length += chunk.length;
	  consume.body.push(chunk);
	}

	function consumeFinish (consume, err) {
	  if (consume.body === null) {
	    return
	  }

	  if (err) {
	    consume.reject(err);
	  } else {
	    consume.resolve();
	  }

	  consume.type = null;
	  consume.stream = null;
	  consume.resolve = null;
	  consume.reject = null;
	  consume.length = 0;
	  consume.body = null;
	}
	return readable$1;
}

var util$4;
var hasRequiredUtil$4;

function requireUtil$4 () {
	if (hasRequiredUtil$4) return util$4;
	hasRequiredUtil$4 = 1;
	const assert = require$$0$4;
	const {
	  ResponseStatusCodeError
	} = requireErrors();
	const { toUSVString } = requireUtil$6();

	async function getResolveErrorBodyCallback ({ callback, body, contentType, statusCode, statusMessage, headers }) {
	  assert(body);

	  let chunks = [];
	  let limit = 0;

	  for await (const chunk of body) {
	    chunks.push(chunk);
	    limit += chunk.length;
	    if (limit > 128 * 1024) {
	      chunks = null;
	      break
	    }
	  }

	  if (statusCode === 204 || !contentType || !chunks) {
	    process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`, statusCode, headers));
	    return
	  }

	  try {
	    if (contentType.startsWith('application/json')) {
	      const payload = JSON.parse(toUSVString(Buffer.concat(chunks)));
	      process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`, statusCode, headers, payload));
	      return
	    }

	    if (contentType.startsWith('text/')) {
	      const payload = toUSVString(Buffer.concat(chunks));
	      process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`, statusCode, headers, payload));
	      return
	    }
	  } catch (err) {
	    // Process in a fallback if error
	  }

	  process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`, statusCode, headers));
	}

	util$4 = { getResolveErrorBodyCallback };
	return util$4;
}

var abortSignal;
var hasRequiredAbortSignal;

function requireAbortSignal () {
	if (hasRequiredAbortSignal) return abortSignal;
	hasRequiredAbortSignal = 1;
	const { addAbortListener } = requireUtil$6();
	const { RequestAbortedError } = requireErrors();

	const kListener = Symbol('kListener');
	const kSignal = Symbol('kSignal');

	function abort (self) {
	  if (self.abort) {
	    self.abort();
	  } else {
	    self.onError(new RequestAbortedError());
	  }
	}

	function addSignal (self, signal) {
	  self[kSignal] = null;
	  self[kListener] = null;

	  if (!signal) {
	    return
	  }

	  if (signal.aborted) {
	    abort(self);
	    return
	  }

	  self[kSignal] = signal;
	  self[kListener] = () => {
	    abort(self);
	  };

	  addAbortListener(self[kSignal], self[kListener]);
	}

	function removeSignal (self) {
	  if (!self[kSignal]) {
	    return
	  }

	  if ('removeEventListener' in self[kSignal]) {
	    self[kSignal].removeEventListener('abort', self[kListener]);
	  } else {
	    self[kSignal].removeListener('abort', self[kListener]);
	  }

	  self[kSignal] = null;
	  self[kListener] = null;
	}

	abortSignal = {
	  addSignal,
	  removeSignal
	};
	return abortSignal;
}

var hasRequiredApiRequest;

function requireApiRequest () {
	if (hasRequiredApiRequest) return apiRequest.exports;
	hasRequiredApiRequest = 1;

	const Readable = requireReadable();
	const {
	  InvalidArgumentError,
	  RequestAbortedError
	} = requireErrors();
	const util = requireUtil$6();
	const { getResolveErrorBodyCallback } = requireUtil$4();
	const { AsyncResource } = require$$4$2;
	const { addSignal, removeSignal } = requireAbortSignal();

	class RequestHandler extends AsyncResource {
	  constructor (opts, callback) {
	    if (!opts || typeof opts !== 'object') {
	      throw new InvalidArgumentError('invalid opts')
	    }

	    const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError, highWaterMark } = opts;

	    try {
	      if (typeof callback !== 'function') {
	        throw new InvalidArgumentError('invalid callback')
	      }

	      if (highWaterMark && (typeof highWaterMark !== 'number' || highWaterMark < 0)) {
	        throw new InvalidArgumentError('invalid highWaterMark')
	      }

	      if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {
	        throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')
	      }

	      if (method === 'CONNECT') {
	        throw new InvalidArgumentError('invalid method')
	      }

	      if (onInfo && typeof onInfo !== 'function') {
	        throw new InvalidArgumentError('invalid onInfo callback')
	      }

	      super('UNDICI_REQUEST');
	    } catch (err) {
	      if (util.isStream(body)) {
	        util.destroy(body.on('error', util.nop), err);
	      }
	      throw err
	    }

	    this.responseHeaders = responseHeaders || null;
	    this.opaque = opaque || null;
	    this.callback = callback;
	    this.res = null;
	    this.abort = null;
	    this.body = body;
	    this.trailers = {};
	    this.context = null;
	    this.onInfo = onInfo || null;
	    this.throwOnError = throwOnError;
	    this.highWaterMark = highWaterMark;

	    if (util.isStream(body)) {
	      body.on('error', (err) => {
	        this.onError(err);
	      });
	    }

	    addSignal(this, signal);
	  }

	  onConnect (abort, context) {
	    if (!this.callback) {
	      throw new RequestAbortedError()
	    }

	    this.abort = abort;
	    this.context = context;
	  }

	  onHeaders (statusCode, rawHeaders, resume, statusMessage) {
	    const { callback, opaque, abort, context, responseHeaders, highWaterMark } = this;

	    const headers = responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);

	    if (statusCode < 200) {
	      if (this.onInfo) {
	        this.onInfo({ statusCode, headers });
	      }
	      return
	    }

	    const parsedHeaders = responseHeaders === 'raw' ? util.parseHeaders(rawHeaders) : headers;
	    const contentType = parsedHeaders['content-type'];
	    const body = new Readable({ resume, abort, contentType, highWaterMark });

	    this.callback = null;
	    this.res = body;
	    if (callback !== null) {
	      if (this.throwOnError && statusCode >= 400) {
	        this.runInAsyncScope(getResolveErrorBodyCallback, null,
	          { callback, body, contentType, statusCode, statusMessage, headers }
	        );
	      } else {
	        this.runInAsyncScope(callback, null, null, {
	          statusCode,
	          headers,
	          trailers: this.trailers,
	          opaque,
	          body,
	          context
	        });
	      }
	    }
	  }

	  onData (chunk) {
	    const { res } = this;
	    return res.push(chunk)
	  }

	  onComplete (trailers) {
	    const { res } = this;

	    removeSignal(this);

	    util.parseHeaders(trailers, this.trailers);

	    res.push(null);
	  }

	  onError (err) {
	    const { res, callback, body, opaque } = this;

	    removeSignal(this);

	    if (callback) {
	      // TODO: Does this need queueMicrotask?
	      this.callback = null;
	      queueMicrotask(() => {
	        this.runInAsyncScope(callback, null, err, { opaque });
	      });
	    }

	    if (res) {
	      this.res = null;
	      // Ensure all queued handlers are invoked before destroying res.
	      queueMicrotask(() => {
	        util.destroy(res, err);
	      });
	    }

	    if (body) {
	      this.body = null;
	      util.destroy(body, err);
	    }
	  }
	}

	function request (opts, callback) {
	  if (callback === undefined) {
	    return new Promise((resolve, reject) => {
	      request.call(this, opts, (err, data) => {
	        return err ? reject(err) : resolve(data)
	      });
	    })
	  }

	  try {
	    this.dispatch(opts, new RequestHandler(opts, callback));
	  } catch (err) {
	    if (typeof callback !== 'function') {
	      throw err
	    }
	    const opaque = opts && opts.opaque;
	    queueMicrotask(() => callback(err, { opaque }));
	  }
	}

	apiRequest.exports = request;
	apiRequest.exports.RequestHandler = RequestHandler;
	return apiRequest.exports;
}

var apiStream;
var hasRequiredApiStream;

function requireApiStream () {
	if (hasRequiredApiStream) return apiStream;
	hasRequiredApiStream = 1;

	const { finished, PassThrough } = require$$0$6;
	const {
	  InvalidArgumentError,
	  InvalidReturnValueError,
	  RequestAbortedError
	} = requireErrors();
	const util = requireUtil$6();
	const { getResolveErrorBodyCallback } = requireUtil$4();
	const { AsyncResource } = require$$4$2;
	const { addSignal, removeSignal } = requireAbortSignal();

	class StreamHandler extends AsyncResource {
	  constructor (opts, factory, callback) {
	    if (!opts || typeof opts !== 'object') {
	      throw new InvalidArgumentError('invalid opts')
	    }

	    const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError } = opts;

	    try {
	      if (typeof callback !== 'function') {
	        throw new InvalidArgumentError('invalid callback')
	      }

	      if (typeof factory !== 'function') {
	        throw new InvalidArgumentError('invalid factory')
	      }

	      if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {
	        throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')
	      }

	      if (method === 'CONNECT') {
	        throw new InvalidArgumentError('invalid method')
	      }

	      if (onInfo && typeof onInfo !== 'function') {
	        throw new InvalidArgumentError('invalid onInfo callback')
	      }

	      super('UNDICI_STREAM');
	    } catch (err) {
	      if (util.isStream(body)) {
	        util.destroy(body.on('error', util.nop), err);
	      }
	      throw err
	    }

	    this.responseHeaders = responseHeaders || null;
	    this.opaque = opaque || null;
	    this.factory = factory;
	    this.callback = callback;
	    this.res = null;
	    this.abort = null;
	    this.context = null;
	    this.trailers = null;
	    this.body = body;
	    this.onInfo = onInfo || null;
	    this.throwOnError = throwOnError || false;

	    if (util.isStream(body)) {
	      body.on('error', (err) => {
	        this.onError(err);
	      });
	    }

	    addSignal(this, signal);
	  }

	  onConnect (abort, context) {
	    if (!this.callback) {
	      throw new RequestAbortedError()
	    }

	    this.abort = abort;
	    this.context = context;
	  }

	  onHeaders (statusCode, rawHeaders, resume, statusMessage) {
	    const { factory, opaque, context, callback, responseHeaders } = this;

	    const headers = responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);

	    if (statusCode < 200) {
	      if (this.onInfo) {
	        this.onInfo({ statusCode, headers });
	      }
	      return
	    }

	    this.factory = null;

	    let res;

	    if (this.throwOnError && statusCode >= 400) {
	      const parsedHeaders = responseHeaders === 'raw' ? util.parseHeaders(rawHeaders) : headers;
	      const contentType = parsedHeaders['content-type'];
	      res = new PassThrough();

	      this.callback = null;
	      this.runInAsyncScope(getResolveErrorBodyCallback, null,
	        { callback, body: res, contentType, statusCode, statusMessage, headers }
	      );
	    } else {
	      if (factory === null) {
	        return
	      }

	      res = this.runInAsyncScope(factory, null, {
	        statusCode,
	        headers,
	        opaque,
	        context
	      });

	      if (
	        !res ||
	        typeof res.write !== 'function' ||
	        typeof res.end !== 'function' ||
	        typeof res.on !== 'function'
	      ) {
	        throw new InvalidReturnValueError('expected Writable')
	      }

	      // TODO: Avoid finished. It registers an unnecessary amount of listeners.
	      finished(res, { readable: false }, (err) => {
	        const { callback, res, opaque, trailers, abort } = this;

	        this.res = null;
	        if (err || !res.readable) {
	          util.destroy(res, err);
	        }

	        this.callback = null;
	        this.runInAsyncScope(callback, null, err || null, { opaque, trailers });

	        if (err) {
	          abort();
	        }
	      });
	    }

	    res.on('drain', resume);

	    this.res = res;

	    const needDrain = res.writableNeedDrain !== undefined
	      ? res.writableNeedDrain
	      : res._writableState && res._writableState.needDrain;

	    return needDrain !== true
	  }

	  onData (chunk) {
	    const { res } = this;

	    return res ? res.write(chunk) : true
	  }

	  onComplete (trailers) {
	    const { res } = this;

	    removeSignal(this);

	    if (!res) {
	      return
	    }

	    this.trailers = util.parseHeaders(trailers);

	    res.end();
	  }

	  onError (err) {
	    const { res, callback, opaque, body } = this;

	    removeSignal(this);

	    this.factory = null;

	    if (res) {
	      this.res = null;
	      util.destroy(res, err);
	    } else if (callback) {
	      this.callback = null;
	      queueMicrotask(() => {
	        this.runInAsyncScope(callback, null, err, { opaque });
	      });
	    }

	    if (body) {
	      this.body = null;
	      util.destroy(body, err);
	    }
	  }
	}

	function stream (opts, factory, callback) {
	  if (callback === undefined) {
	    return new Promise((resolve, reject) => {
	      stream.call(this, opts, factory, (err, data) => {
	        return err ? reject(err) : resolve(data)
	      });
	    })
	  }

	  try {
	    this.dispatch(opts, new StreamHandler(opts, factory, callback));
	  } catch (err) {
	    if (typeof callback !== 'function') {
	      throw err
	    }
	    const opaque = opts && opts.opaque;
	    queueMicrotask(() => callback(err, { opaque }));
	  }
	}

	apiStream = stream;
	return apiStream;
}

var apiPipeline;
var hasRequiredApiPipeline;

function requireApiPipeline () {
	if (hasRequiredApiPipeline) return apiPipeline;
	hasRequiredApiPipeline = 1;

	const {
	  Readable,
	  Duplex,
	  PassThrough
	} = require$$0$6;
	const {
	  InvalidArgumentError,
	  InvalidReturnValueError,
	  RequestAbortedError
	} = requireErrors();
	const util = requireUtil$6();
	const { AsyncResource } = require$$4$2;
	const { addSignal, removeSignal } = requireAbortSignal();
	const assert = require$$0$4;

	const kResume = Symbol('resume');

	class PipelineRequest extends Readable {
	  constructor () {
	    super({ autoDestroy: true });

	    this[kResume] = null;
	  }

	  _read () {
	    const { [kResume]: resume } = this;

	    if (resume) {
	      this[kResume] = null;
	      resume();
	    }
	  }

	  _destroy (err, callback) {
	    this._read();

	    callback(err);
	  }
	}

	class PipelineResponse extends Readable {
	  constructor (resume) {
	    super({ autoDestroy: true });
	    this[kResume] = resume;
	  }

	  _read () {
	    this[kResume]();
	  }

	  _destroy (err, callback) {
	    if (!err && !this._readableState.endEmitted) {
	      err = new RequestAbortedError();
	    }

	    callback(err);
	  }
	}

	class PipelineHandler extends AsyncResource {
	  constructor (opts, handler) {
	    if (!opts || typeof opts !== 'object') {
	      throw new InvalidArgumentError('invalid opts')
	    }

	    if (typeof handler !== 'function') {
	      throw new InvalidArgumentError('invalid handler')
	    }

	    const { signal, method, opaque, onInfo, responseHeaders } = opts;

	    if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {
	      throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')
	    }

	    if (method === 'CONNECT') {
	      throw new InvalidArgumentError('invalid method')
	    }

	    if (onInfo && typeof onInfo !== 'function') {
	      throw new InvalidArgumentError('invalid onInfo callback')
	    }

	    super('UNDICI_PIPELINE');

	    this.opaque = opaque || null;
	    this.responseHeaders = responseHeaders || null;
	    this.handler = handler;
	    this.abort = null;
	    this.context = null;
	    this.onInfo = onInfo || null;

	    this.req = new PipelineRequest().on('error', util.nop);

	    this.ret = new Duplex({
	      readableObjectMode: opts.objectMode,
	      autoDestroy: true,
	      read: () => {
	        const { body } = this;

	        if (body && body.resume) {
	          body.resume();
	        }
	      },
	      write: (chunk, encoding, callback) => {
	        const { req } = this;

	        if (req.push(chunk, encoding) || req._readableState.destroyed) {
	          callback();
	        } else {
	          req[kResume] = callback;
	        }
	      },
	      destroy: (err, callback) => {
	        const { body, req, res, ret, abort } = this;

	        if (!err && !ret._readableState.endEmitted) {
	          err = new RequestAbortedError();
	        }

	        if (abort && err) {
	          abort();
	        }

	        util.destroy(body, err);
	        util.destroy(req, err);
	        util.destroy(res, err);

	        removeSignal(this);

	        callback(err);
	      }
	    }).on('prefinish', () => {
	      const { req } = this;

	      // Node < 15 does not call _final in same tick.
	      req.push(null);
	    });

	    this.res = null;

	    addSignal(this, signal);
	  }

	  onConnect (abort, context) {
	    const { ret, res } = this;

	    assert(!res, 'pipeline cannot be retried');

	    if (ret.destroyed) {
	      throw new RequestAbortedError()
	    }

	    this.abort = abort;
	    this.context = context;
	  }

	  onHeaders (statusCode, rawHeaders, resume) {
	    const { opaque, handler, context } = this;

	    if (statusCode < 200) {
	      if (this.onInfo) {
	        const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
	        this.onInfo({ statusCode, headers });
	      }
	      return
	    }

	    this.res = new PipelineResponse(resume);

	    let body;
	    try {
	      this.handler = null;
	      const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
	      body = this.runInAsyncScope(handler, null, {
	        statusCode,
	        headers,
	        opaque,
	        body: this.res,
	        context
	      });
	    } catch (err) {
	      this.res.on('error', util.nop);
	      throw err
	    }

	    if (!body || typeof body.on !== 'function') {
	      throw new InvalidReturnValueError('expected Readable')
	    }

	    body
	      .on('data', (chunk) => {
	        const { ret, body } = this;

	        if (!ret.push(chunk) && body.pause) {
	          body.pause();
	        }
	      })
	      .on('error', (err) => {
	        const { ret } = this;

	        util.destroy(ret, err);
	      })
	      .on('end', () => {
	        const { ret } = this;

	        ret.push(null);
	      })
	      .on('close', () => {
	        const { ret } = this;

	        if (!ret._readableState.ended) {
	          util.destroy(ret, new RequestAbortedError());
	        }
	      });

	    this.body = body;
	  }

	  onData (chunk) {
	    const { res } = this;
	    return res.push(chunk)
	  }

	  onComplete (trailers) {
	    const { res } = this;
	    res.push(null);
	  }

	  onError (err) {
	    const { ret } = this;
	    this.handler = null;
	    util.destroy(ret, err);
	  }
	}

	function pipeline (opts, handler) {
	  try {
	    const pipelineHandler = new PipelineHandler(opts, handler);
	    this.dispatch({ ...opts, body: pipelineHandler.req }, pipelineHandler);
	    return pipelineHandler.ret
	  } catch (err) {
	    return new PassThrough().destroy(err)
	  }
	}

	apiPipeline = pipeline;
	return apiPipeline;
}

var apiUpgrade;
var hasRequiredApiUpgrade;

function requireApiUpgrade () {
	if (hasRequiredApiUpgrade) return apiUpgrade;
	hasRequiredApiUpgrade = 1;

	const { InvalidArgumentError, RequestAbortedError, SocketError } = requireErrors();
	const { AsyncResource } = require$$4$2;
	const util = requireUtil$6();
	const { addSignal, removeSignal } = requireAbortSignal();
	const assert = require$$0$4;

	class UpgradeHandler extends AsyncResource {
	  constructor (opts, callback) {
	    if (!opts || typeof opts !== 'object') {
	      throw new InvalidArgumentError('invalid opts')
	    }

	    if (typeof callback !== 'function') {
	      throw new InvalidArgumentError('invalid callback')
	    }

	    const { signal, opaque, responseHeaders } = opts;

	    if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {
	      throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')
	    }

	    super('UNDICI_UPGRADE');

	    this.responseHeaders = responseHeaders || null;
	    this.opaque = opaque || null;
	    this.callback = callback;
	    this.abort = null;
	    this.context = null;

	    addSignal(this, signal);
	  }

	  onConnect (abort, context) {
	    if (!this.callback) {
	      throw new RequestAbortedError()
	    }

	    this.abort = abort;
	    this.context = null;
	  }

	  onHeaders () {
	    throw new SocketError('bad upgrade', null)
	  }

	  onUpgrade (statusCode, rawHeaders, socket) {
	    const { callback, opaque, context } = this;

	    assert.strictEqual(statusCode, 101);

	    removeSignal(this);

	    this.callback = null;
	    const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
	    this.runInAsyncScope(callback, null, null, {
	      headers,
	      socket,
	      opaque,
	      context
	    });
	  }

	  onError (err) {
	    const { callback, opaque } = this;

	    removeSignal(this);

	    if (callback) {
	      this.callback = null;
	      queueMicrotask(() => {
	        this.runInAsyncScope(callback, null, err, { opaque });
	      });
	    }
	  }
	}

	function upgrade (opts, callback) {
	  if (callback === undefined) {
	    return new Promise((resolve, reject) => {
	      upgrade.call(this, opts, (err, data) => {
	        return err ? reject(err) : resolve(data)
	      });
	    })
	  }

	  try {
	    const upgradeHandler = new UpgradeHandler(opts, callback);
	    this.dispatch({
	      ...opts,
	      method: opts.method || 'GET',
	      upgrade: opts.protocol || 'Websocket'
	    }, upgradeHandler);
	  } catch (err) {
	    if (typeof callback !== 'function') {
	      throw err
	    }
	    const opaque = opts && opts.opaque;
	    queueMicrotask(() => callback(err, { opaque }));
	  }
	}

	apiUpgrade = upgrade;
	return apiUpgrade;
}

var apiConnect;
var hasRequiredApiConnect;

function requireApiConnect () {
	if (hasRequiredApiConnect) return apiConnect;
	hasRequiredApiConnect = 1;

	const { AsyncResource } = require$$4$2;
	const { InvalidArgumentError, RequestAbortedError, SocketError } = requireErrors();
	const util = requireUtil$6();
	const { addSignal, removeSignal } = requireAbortSignal();

	class ConnectHandler extends AsyncResource {
	  constructor (opts, callback) {
	    if (!opts || typeof opts !== 'object') {
	      throw new InvalidArgumentError('invalid opts')
	    }

	    if (typeof callback !== 'function') {
	      throw new InvalidArgumentError('invalid callback')
	    }

	    const { signal, opaque, responseHeaders } = opts;

	    if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {
	      throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')
	    }

	    super('UNDICI_CONNECT');

	    this.opaque = opaque || null;
	    this.responseHeaders = responseHeaders || null;
	    this.callback = callback;
	    this.abort = null;

	    addSignal(this, signal);
	  }

	  onConnect (abort, context) {
	    if (!this.callback) {
	      throw new RequestAbortedError()
	    }

	    this.abort = abort;
	    this.context = context;
	  }

	  onHeaders () {
	    throw new SocketError('bad connect', null)
	  }

	  onUpgrade (statusCode, rawHeaders, socket) {
	    const { callback, opaque, context } = this;

	    removeSignal(this);

	    this.callback = null;

	    let headers = rawHeaders;
	    // Indicates is an HTTP2Session
	    if (headers != null) {
	      headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
	    }

	    this.runInAsyncScope(callback, null, null, {
	      statusCode,
	      headers,
	      socket,
	      opaque,
	      context
	    });
	  }

	  onError (err) {
	    const { callback, opaque } = this;

	    removeSignal(this);

	    if (callback) {
	      this.callback = null;
	      queueMicrotask(() => {
	        this.runInAsyncScope(callback, null, err, { opaque });
	      });
	    }
	  }
	}

	function connect (opts, callback) {
	  if (callback === undefined) {
	    return new Promise((resolve, reject) => {
	      connect.call(this, opts, (err, data) => {
	        return err ? reject(err) : resolve(data)
	      });
	    })
	  }

	  try {
	    const connectHandler = new ConnectHandler(opts, callback);
	    this.dispatch({ ...opts, method: 'CONNECT' }, connectHandler);
	  } catch (err) {
	    if (typeof callback !== 'function') {
	      throw err
	    }
	    const opaque = opts && opts.opaque;
	    queueMicrotask(() => callback(err, { opaque }));
	  }
	}

	apiConnect = connect;
	return apiConnect;
}

var hasRequiredApi;

function requireApi () {
	if (hasRequiredApi) return api;
	hasRequiredApi = 1;

	api.request = requireApiRequest();
	api.stream = requireApiStream();
	api.pipeline = requireApiPipeline();
	api.upgrade = requireApiUpgrade();
	api.connect = requireApiConnect();
	return api;
}

var mockErrors;
var hasRequiredMockErrors;

function requireMockErrors () {
	if (hasRequiredMockErrors) return mockErrors;
	hasRequiredMockErrors = 1;

	const { UndiciError } = requireErrors();

	class MockNotMatchedError extends UndiciError {
	  constructor (message) {
	    super(message);
	    Error.captureStackTrace(this, MockNotMatchedError);
	    this.name = 'MockNotMatchedError';
	    this.message = message || 'The request does not match any registered mock dispatches';
	    this.code = 'UND_MOCK_ERR_MOCK_NOT_MATCHED';
	  }
	}

	mockErrors = {
	  MockNotMatchedError
	};
	return mockErrors;
}

var mockSymbols;
var hasRequiredMockSymbols;

function requireMockSymbols () {
	if (hasRequiredMockSymbols) return mockSymbols;
	hasRequiredMockSymbols = 1;

	mockSymbols = {
	  kAgent: Symbol('agent'),
	  kOptions: Symbol('options'),
	  kFactory: Symbol('factory'),
	  kDispatches: Symbol('dispatches'),
	  kDispatchKey: Symbol('dispatch key'),
	  kDefaultHeaders: Symbol('default headers'),
	  kDefaultTrailers: Symbol('default trailers'),
	  kContentLength: Symbol('content length'),
	  kMockAgent: Symbol('mock agent'),
	  kMockAgentSet: Symbol('mock agent set'),
	  kMockAgentGet: Symbol('mock agent get'),
	  kMockDispatch: Symbol('mock dispatch'),
	  kClose: Symbol('close'),
	  kOriginalClose: Symbol('original agent close'),
	  kOrigin: Symbol('origin'),
	  kIsMockActive: Symbol('is mock active'),
	  kNetConnect: Symbol('net connect'),
	  kGetNetConnect: Symbol('get net connect'),
	  kConnected: Symbol('connected')
	};
	return mockSymbols;
}

var mockUtils;
var hasRequiredMockUtils;

function requireMockUtils () {
	if (hasRequiredMockUtils) return mockUtils;
	hasRequiredMockUtils = 1;

	const { MockNotMatchedError } = requireMockErrors();
	const {
	  kDispatches,
	  kMockAgent,
	  kOriginalDispatch,
	  kOrigin,
	  kGetNetConnect
	} = requireMockSymbols();
	const { buildURL, nop } = requireUtil$6();
	const { STATUS_CODES } = require$$2;
	const {
	  types: {
	    isPromise
	  }
	} = require$$0$2;

	function matchValue (match, value) {
	  if (typeof match === 'string') {
	    return match === value
	  }
	  if (match instanceof RegExp) {
	    return match.test(value)
	  }
	  if (typeof match === 'function') {
	    return match(value) === true
	  }
	  return false
	}

	function lowerCaseEntries (headers) {
	  return Object.fromEntries(
	    Object.entries(headers).map(([headerName, headerValue]) => {
	      return [headerName.toLocaleLowerCase(), headerValue]
	    })
	  )
	}

	/**
	 * @param {import('../../index').Headers|string[]|Record<string, string>} headers
	 * @param {string} key
	 */
	function getHeaderByName (headers, key) {
	  if (Array.isArray(headers)) {
	    for (let i = 0; i < headers.length; i += 2) {
	      if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase()) {
	        return headers[i + 1]
	      }
	    }

	    return undefined
	  } else if (typeof headers.get === 'function') {
	    return headers.get(key)
	  } else {
	    return lowerCaseEntries(headers)[key.toLocaleLowerCase()]
	  }
	}

	/** @param {string[]} headers */
	function buildHeadersFromArray (headers) { // fetch HeadersList
	  const clone = headers.slice();
	  const entries = [];
	  for (let index = 0; index < clone.length; index += 2) {
	    entries.push([clone[index], clone[index + 1]]);
	  }
	  return Object.fromEntries(entries)
	}

	function matchHeaders (mockDispatch, headers) {
	  if (typeof mockDispatch.headers === 'function') {
	    if (Array.isArray(headers)) { // fetch HeadersList
	      headers = buildHeadersFromArray(headers);
	    }
	    return mockDispatch.headers(headers ? lowerCaseEntries(headers) : {})
	  }
	  if (typeof mockDispatch.headers === 'undefined') {
	    return true
	  }
	  if (typeof headers !== 'object' || typeof mockDispatch.headers !== 'object') {
	    return false
	  }

	  for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch.headers)) {
	    const headerValue = getHeaderByName(headers, matchHeaderName);

	    if (!matchValue(matchHeaderValue, headerValue)) {
	      return false
	    }
	  }
	  return true
	}

	function safeUrl (path) {
	  if (typeof path !== 'string') {
	    return path
	  }

	  const pathSegments = path.split('?');

	  if (pathSegments.length !== 2) {
	    return path
	  }

	  const qp = new URLSearchParams(pathSegments.pop());
	  qp.sort();
	  return [...pathSegments, qp.toString()].join('?')
	}

	function matchKey (mockDispatch, { path, method, body, headers }) {
	  const pathMatch = matchValue(mockDispatch.path, path);
	  const methodMatch = matchValue(mockDispatch.method, method);
	  const bodyMatch = typeof mockDispatch.body !== 'undefined' ? matchValue(mockDispatch.body, body) : true;
	  const headersMatch = matchHeaders(mockDispatch, headers);
	  return pathMatch && methodMatch && bodyMatch && headersMatch
	}

	function getResponseData (data) {
	  if (Buffer.isBuffer(data)) {
	    return data
	  } else if (typeof data === 'object') {
	    return JSON.stringify(data)
	  } else {
	    return data.toString()
	  }
	}

	function getMockDispatch (mockDispatches, key) {
	  const basePath = key.query ? buildURL(key.path, key.query) : key.path;
	  const resolvedPath = typeof basePath === 'string' ? safeUrl(basePath) : basePath;

	  // Match path
	  let matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path }) => matchValue(safeUrl(path), resolvedPath));
	  if (matchedMockDispatches.length === 0) {
	    throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`)
	  }

	  // Match method
	  matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue(method, key.method));
	  if (matchedMockDispatches.length === 0) {
	    throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}'`)
	  }

	  // Match body
	  matchedMockDispatches = matchedMockDispatches.filter(({ body }) => typeof body !== 'undefined' ? matchValue(body, key.body) : true);
	  if (matchedMockDispatches.length === 0) {
	    throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}'`)
	  }

	  // Match headers
	  matchedMockDispatches = matchedMockDispatches.filter((mockDispatch) => matchHeaders(mockDispatch, key.headers));
	  if (matchedMockDispatches.length === 0) {
	    throw new MockNotMatchedError(`Mock dispatch not matched for headers '${typeof key.headers === 'object' ? JSON.stringify(key.headers) : key.headers}'`)
	  }

	  return matchedMockDispatches[0]
	}

	function addMockDispatch (mockDispatches, key, data) {
	  const baseData = { timesInvoked: 0, times: 1, persist: false, consumed: false };
	  const replyData = typeof data === 'function' ? { callback: data } : { ...data };
	  const newMockDispatch = { ...baseData, ...key, pending: true, data: { error: null, ...replyData } };
	  mockDispatches.push(newMockDispatch);
	  return newMockDispatch
	}

	function deleteMockDispatch (mockDispatches, key) {
	  const index = mockDispatches.findIndex(dispatch => {
	    if (!dispatch.consumed) {
	      return false
	    }
	    return matchKey(dispatch, key)
	  });
	  if (index !== -1) {
	    mockDispatches.splice(index, 1);
	  }
	}

	function buildKey (opts) {
	  const { path, method, body, headers, query } = opts;
	  return {
	    path,
	    method,
	    body,
	    headers,
	    query
	  }
	}

	function generateKeyValues (data) {
	  return Object.entries(data).reduce((keyValuePairs, [key, value]) => [
	    ...keyValuePairs,
	    Buffer.from(`${key}`),
	    Array.isArray(value) ? value.map(x => Buffer.from(`${x}`)) : Buffer.from(`${value}`)
	  ], [])
	}

	/**
	 * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Status
	 * @param {number} statusCode
	 */
	function getStatusText (statusCode) {
	  return STATUS_CODES[statusCode] || 'unknown'
	}

	async function getResponse (body) {
	  const buffers = [];
	  for await (const data of body) {
	    buffers.push(data);
	  }
	  return Buffer.concat(buffers).toString('utf8')
	}

	/**
	 * Mock dispatch function used to simulate undici dispatches
	 */
	function mockDispatch (opts, handler) {
	  // Get mock dispatch from built key
	  const key = buildKey(opts);
	  const mockDispatch = getMockDispatch(this[kDispatches], key);

	  mockDispatch.timesInvoked++;

	  // Here's where we resolve a callback if a callback is present for the dispatch data.
	  if (mockDispatch.data.callback) {
	    mockDispatch.data = { ...mockDispatch.data, ...mockDispatch.data.callback(opts) };
	  }

	  // Parse mockDispatch data
	  const { data: { statusCode, data, headers, trailers, error }, delay, persist } = mockDispatch;
	  const { timesInvoked, times } = mockDispatch;

	  // If it's used up and not persistent, mark as consumed
	  mockDispatch.consumed = !persist && timesInvoked >= times;
	  mockDispatch.pending = timesInvoked < times;

	  // If specified, trigger dispatch error
	  if (error !== null) {
	    deleteMockDispatch(this[kDispatches], key);
	    handler.onError(error);
	    return true
	  }

	  // Handle the request with a delay if necessary
	  if (typeof delay === 'number' && delay > 0) {
	    setTimeout(() => {
	      handleReply(this[kDispatches]);
	    }, delay);
	  } else {
	    handleReply(this[kDispatches]);
	  }

	  function handleReply (mockDispatches, _data = data) {
	    // fetch's HeadersList is a 1D string array
	    const optsHeaders = Array.isArray(opts.headers)
	      ? buildHeadersFromArray(opts.headers)
	      : opts.headers;
	    const body = typeof _data === 'function'
	      ? _data({ ...opts, headers: optsHeaders })
	      : _data;

	    // util.types.isPromise is likely needed for jest.
	    if (isPromise(body)) {
	      // If handleReply is asynchronous, throwing an error
	      // in the callback will reject the promise, rather than
	      // synchronously throw the error, which breaks some tests.
	      // Rather, we wait for the callback to resolve if it is a
	      // promise, and then re-run handleReply with the new body.
	      body.then((newData) => handleReply(mockDispatches, newData));
	      return
	    }

	    const responseData = getResponseData(body);
	    const responseHeaders = generateKeyValues(headers);
	    const responseTrailers = generateKeyValues(trailers);

	    handler.abort = nop;
	    handler.onHeaders(statusCode, responseHeaders, resume, getStatusText(statusCode));
	    handler.onData(Buffer.from(responseData));
	    handler.onComplete(responseTrailers);
	    deleteMockDispatch(mockDispatches, key);
	  }

	  function resume () {}

	  return true
	}

	function buildMockDispatch () {
	  const agent = this[kMockAgent];
	  const origin = this[kOrigin];
	  const originalDispatch = this[kOriginalDispatch];

	  return function dispatch (opts, handler) {
	    if (agent.isMockActive) {
	      try {
	        mockDispatch.call(this, opts, handler);
	      } catch (error) {
	        if (error instanceof MockNotMatchedError) {
	          const netConnect = agent[kGetNetConnect]();
	          if (netConnect === false) {
	            throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`)
	          }
	          if (checkNetConnect(netConnect, origin)) {
	            originalDispatch.call(this, opts, handler);
	          } else {
	            throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`)
	          }
	        } else {
	          throw error
	        }
	      }
	    } else {
	      originalDispatch.call(this, opts, handler);
	    }
	  }
	}

	function checkNetConnect (netConnect, origin) {
	  const url = new URL(origin);
	  if (netConnect === true) {
	    return true
	  } else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue(matcher, url.host))) {
	    return true
	  }
	  return false
	}

	function buildMockOptions (opts) {
	  if (opts) {
	    const { agent, ...mockOptions } = opts;
	    return mockOptions
	  }
	}

	mockUtils = {
	  getResponseData,
	  getMockDispatch,
	  addMockDispatch,
	  deleteMockDispatch,
	  buildKey,
	  generateKeyValues,
	  matchValue,
	  getResponse,
	  getStatusText,
	  mockDispatch,
	  buildMockDispatch,
	  checkNetConnect,
	  buildMockOptions,
	  getHeaderByName
	};
	return mockUtils;
}

var mockInterceptor = {};

var hasRequiredMockInterceptor;

function requireMockInterceptor () {
	if (hasRequiredMockInterceptor) return mockInterceptor;
	hasRequiredMockInterceptor = 1;

	const { getResponseData, buildKey, addMockDispatch } = requireMockUtils();
	const {
	  kDispatches,
	  kDispatchKey,
	  kDefaultHeaders,
	  kDefaultTrailers,
	  kContentLength,
	  kMockDispatch
	} = requireMockSymbols();
	const { InvalidArgumentError } = requireErrors();
	const { buildURL } = requireUtil$6();

	/**
	 * Defines the scope API for an interceptor reply
	 */
	class MockScope {
	  constructor (mockDispatch) {
	    this[kMockDispatch] = mockDispatch;
	  }

	  /**
	   * Delay a reply by a set amount in ms.
	   */
	  delay (waitInMs) {
	    if (typeof waitInMs !== 'number' || !Number.isInteger(waitInMs) || waitInMs <= 0) {
	      throw new InvalidArgumentError('waitInMs must be a valid integer > 0')
	    }

	    this[kMockDispatch].delay = waitInMs;
	    return this
	  }

	  /**
	   * For a defined reply, never mark as consumed.
	   */
	  persist () {
	    this[kMockDispatch].persist = true;
	    return this
	  }

	  /**
	   * Allow one to define a reply for a set amount of matching requests.
	   */
	  times (repeatTimes) {
	    if (typeof repeatTimes !== 'number' || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {
	      throw new InvalidArgumentError('repeatTimes must be a valid integer > 0')
	    }

	    this[kMockDispatch].times = repeatTimes;
	    return this
	  }
	}

	/**
	 * Defines an interceptor for a Mock
	 */
	class MockInterceptor {
	  constructor (opts, mockDispatches) {
	    if (typeof opts !== 'object') {
	      throw new InvalidArgumentError('opts must be an object')
	    }
	    if (typeof opts.path === 'undefined') {
	      throw new InvalidArgumentError('opts.path must be defined')
	    }
	    if (typeof opts.method === 'undefined') {
	      opts.method = 'GET';
	    }
	    // See https://github.com/nodejs/undici/issues/1245
	    // As per RFC 3986, clients are not supposed to send URI
	    // fragments to servers when they retrieve a document,
	    if (typeof opts.path === 'string') {
	      if (opts.query) {
	        opts.path = buildURL(opts.path, opts.query);
	      } else {
	        // Matches https://github.com/nodejs/undici/blob/main/lib/fetch/index.js#L1811
	        const parsedURL = new URL(opts.path, 'data://');
	        opts.path = parsedURL.pathname + parsedURL.search;
	      }
	    }
	    if (typeof opts.method === 'string') {
	      opts.method = opts.method.toUpperCase();
	    }

	    this[kDispatchKey] = buildKey(opts);
	    this[kDispatches] = mockDispatches;
	    this[kDefaultHeaders] = {};
	    this[kDefaultTrailers] = {};
	    this[kContentLength] = false;
	  }

	  createMockScopeDispatchData (statusCode, data, responseOptions = {}) {
	    const responseData = getResponseData(data);
	    const contentLength = this[kContentLength] ? { 'content-length': responseData.length } : {};
	    const headers = { ...this[kDefaultHeaders], ...contentLength, ...responseOptions.headers };
	    const trailers = { ...this[kDefaultTrailers], ...responseOptions.trailers };

	    return { statusCode, data, headers, trailers }
	  }

	  validateReplyParameters (statusCode, data, responseOptions) {
	    if (typeof statusCode === 'undefined') {
	      throw new InvalidArgumentError('statusCode must be defined')
	    }
	    if (typeof data === 'undefined') {
	      throw new InvalidArgumentError('data must be defined')
	    }
	    if (typeof responseOptions !== 'object') {
	      throw new InvalidArgumentError('responseOptions must be an object')
	    }
	  }

	  /**
	   * Mock an undici request with a defined reply.
	   */
	  reply (replyData) {
	    // Values of reply aren't available right now as they
	    // can only be available when the reply callback is invoked.
	    if (typeof replyData === 'function') {
	      // We'll first wrap the provided callback in another function,
	      // this function will properly resolve the data from the callback
	      // when invoked.
	      const wrappedDefaultsCallback = (opts) => {
	        // Our reply options callback contains the parameter for statusCode, data and options.
	        const resolvedData = replyData(opts);

	        // Check if it is in the right format
	        if (typeof resolvedData !== 'object') {
	          throw new InvalidArgumentError('reply options callback must return an object')
	        }

	        const { statusCode, data = '', responseOptions = {} } = resolvedData;
	        this.validateReplyParameters(statusCode, data, responseOptions);
	        // Since the values can be obtained immediately we return them
	        // from this higher order function that will be resolved later.
	        return {
	          ...this.createMockScopeDispatchData(statusCode, data, responseOptions)
	        }
	      };

	      // Add usual dispatch data, but this time set the data parameter to function that will eventually provide data.
	      const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback);
	      return new MockScope(newMockDispatch)
	    }

	    // We can have either one or three parameters, if we get here,
	    // we should have 1-3 parameters. So we spread the arguments of
	    // this function to obtain the parameters, since replyData will always
	    // just be the statusCode.
	    const [statusCode, data = '', responseOptions = {}] = [...arguments];
	    this.validateReplyParameters(statusCode, data, responseOptions);

	    // Send in-already provided data like usual
	    const dispatchData = this.createMockScopeDispatchData(statusCode, data, responseOptions);
	    const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData);
	    return new MockScope(newMockDispatch)
	  }

	  /**
	   * Mock an undici request with a defined error.
	   */
	  replyWithError (error) {
	    if (typeof error === 'undefined') {
	      throw new InvalidArgumentError('error must be defined')
	    }

	    const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], { error });
	    return new MockScope(newMockDispatch)
	  }

	  /**
	   * Set default reply headers on the interceptor for subsequent replies
	   */
	  defaultReplyHeaders (headers) {
	    if (typeof headers === 'undefined') {
	      throw new InvalidArgumentError('headers must be defined')
	    }

	    this[kDefaultHeaders] = headers;
	    return this
	  }

	  /**
	   * Set default reply trailers on the interceptor for subsequent replies
	   */
	  defaultReplyTrailers (trailers) {
	    if (typeof trailers === 'undefined') {
	      throw new InvalidArgumentError('trailers must be defined')
	    }

	    this[kDefaultTrailers] = trailers;
	    return this
	  }

	  /**
	   * Set reply content length header for replies on the interceptor
	   */
	  replyContentLength () {
	    this[kContentLength] = true;
	    return this
	  }
	}

	mockInterceptor.MockInterceptor = MockInterceptor;
	mockInterceptor.MockScope = MockScope;
	return mockInterceptor;
}

var mockClient;
var hasRequiredMockClient;

function requireMockClient () {
	if (hasRequiredMockClient) return mockClient;
	hasRequiredMockClient = 1;

	const { promisify } = require$$0$2;
	const Client = requireClient();
	const { buildMockDispatch } = requireMockUtils();
	const {
	  kDispatches,
	  kMockAgent,
	  kClose,
	  kOriginalClose,
	  kOrigin,
	  kOriginalDispatch,
	  kConnected
	} = requireMockSymbols();
	const { MockInterceptor } = requireMockInterceptor();
	const Symbols = requireSymbols$4();
	const { InvalidArgumentError } = requireErrors();

	/**
	 * MockClient provides an API that extends the Client to influence the mockDispatches.
	 */
	class MockClient extends Client {
	  constructor (origin, opts) {
	    super(origin, opts);

	    if (!opts || !opts.agent || typeof opts.agent.dispatch !== 'function') {
	      throw new InvalidArgumentError('Argument opts.agent must implement Agent')
	    }

	    this[kMockAgent] = opts.agent;
	    this[kOrigin] = origin;
	    this[kDispatches] = [];
	    this[kConnected] = 1;
	    this[kOriginalDispatch] = this.dispatch;
	    this[kOriginalClose] = this.close.bind(this);

	    this.dispatch = buildMockDispatch.call(this);
	    this.close = this[kClose];
	  }

	  get [Symbols.kConnected] () {
	    return this[kConnected]
	  }

	  /**
	   * Sets up the base interceptor for mocking replies from undici.
	   */
	  intercept (opts) {
	    return new MockInterceptor(opts, this[kDispatches])
	  }

	  async [kClose] () {
	    await promisify(this[kOriginalClose])();
	    this[kConnected] = 0;
	    this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
	  }
	}

	mockClient = MockClient;
	return mockClient;
}

var mockPool;
var hasRequiredMockPool;

function requireMockPool () {
	if (hasRequiredMockPool) return mockPool;
	hasRequiredMockPool = 1;

	const { promisify } = require$$0$2;
	const Pool = requirePool();
	const { buildMockDispatch } = requireMockUtils();
	const {
	  kDispatches,
	  kMockAgent,
	  kClose,
	  kOriginalClose,
	  kOrigin,
	  kOriginalDispatch,
	  kConnected
	} = requireMockSymbols();
	const { MockInterceptor } = requireMockInterceptor();
	const Symbols = requireSymbols$4();
	const { InvalidArgumentError } = requireErrors();

	/**
	 * MockPool provides an API that extends the Pool to influence the mockDispatches.
	 */
	class MockPool extends Pool {
	  constructor (origin, opts) {
	    super(origin, opts);

	    if (!opts || !opts.agent || typeof opts.agent.dispatch !== 'function') {
	      throw new InvalidArgumentError('Argument opts.agent must implement Agent')
	    }

	    this[kMockAgent] = opts.agent;
	    this[kOrigin] = origin;
	    this[kDispatches] = [];
	    this[kConnected] = 1;
	    this[kOriginalDispatch] = this.dispatch;
	    this[kOriginalClose] = this.close.bind(this);

	    this.dispatch = buildMockDispatch.call(this);
	    this.close = this[kClose];
	  }

	  get [Symbols.kConnected] () {
	    return this[kConnected]
	  }

	  /**
	   * Sets up the base interceptor for mocking replies from undici.
	   */
	  intercept (opts) {
	    return new MockInterceptor(opts, this[kDispatches])
	  }

	  async [kClose] () {
	    await promisify(this[kOriginalClose])();
	    this[kConnected] = 0;
	    this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
	  }
	}

	mockPool = MockPool;
	return mockPool;
}

var pluralizer;
var hasRequiredPluralizer;

function requirePluralizer () {
	if (hasRequiredPluralizer) return pluralizer;
	hasRequiredPluralizer = 1;

	const singulars = {
	  pronoun: 'it',
	  is: 'is',
	  was: 'was',
	  this: 'this'
	};

	const plurals = {
	  pronoun: 'they',
	  is: 'are',
	  was: 'were',
	  this: 'these'
	};

	pluralizer = class Pluralizer {
	  constructor (singular, plural) {
	    this.singular = singular;
	    this.plural = plural;
	  }

	  pluralize (count) {
	    const one = count === 1;
	    const keys = one ? singulars : plurals;
	    const noun = one ? this.singular : this.plural;
	    return { ...keys, count, noun }
	  }
	};
	return pluralizer;
}

var pendingInterceptorsFormatter;
var hasRequiredPendingInterceptorsFormatter;

function requirePendingInterceptorsFormatter () {
	if (hasRequiredPendingInterceptorsFormatter) return pendingInterceptorsFormatter;
	hasRequiredPendingInterceptorsFormatter = 1;

	const { Transform } = require$$0$6;
	const { Console } = require$$1$2;

	/**
	 * Gets the output of `console.table()` as a string.
	 */
	pendingInterceptorsFormatter = class PendingInterceptorsFormatter {
	  constructor ({ disableColors } = {}) {
	    this.transform = new Transform({
	      transform (chunk, _enc, cb) {
	        cb(null, chunk);
	      }
	    });

	    this.logger = new Console({
	      stdout: this.transform,
	      inspectOptions: {
	        colors: !disableColors && !process.env.CI
	      }
	    });
	  }

	  format (pendingInterceptors) {
	    const withPrettyHeaders = pendingInterceptors.map(
	      ({ method, path, data: { statusCode }, persist, times, timesInvoked, origin }) => ({
	        Method: method,
	        Origin: origin,
	        Path: path,
	        'Status code': statusCode,
	        Persistent: persist ? '' : '',
	        Invocations: timesInvoked,
	        Remaining: persist ? Infinity : times - timesInvoked
	      }));

	    this.logger.table(withPrettyHeaders);
	    return this.transform.read().toString()
	  }
	};
	return pendingInterceptorsFormatter;
}

var mockAgent;
var hasRequiredMockAgent;

function requireMockAgent () {
	if (hasRequiredMockAgent) return mockAgent;
	hasRequiredMockAgent = 1;

	const { kClients } = requireSymbols$4();
	const Agent = requireAgent();
	const {
	  kAgent,
	  kMockAgentSet,
	  kMockAgentGet,
	  kDispatches,
	  kIsMockActive,
	  kNetConnect,
	  kGetNetConnect,
	  kOptions,
	  kFactory
	} = requireMockSymbols();
	const MockClient = requireMockClient();
	const MockPool = requireMockPool();
	const { matchValue, buildMockOptions } = requireMockUtils();
	const { InvalidArgumentError, UndiciError } = requireErrors();
	const Dispatcher = requireDispatcher();
	const Pluralizer = requirePluralizer();
	const PendingInterceptorsFormatter = requirePendingInterceptorsFormatter();

	class FakeWeakRef {
	  constructor (value) {
	    this.value = value;
	  }

	  deref () {
	    return this.value
	  }
	}

	class MockAgent extends Dispatcher {
	  constructor (opts) {
	    super(opts);

	    this[kNetConnect] = true;
	    this[kIsMockActive] = true;

	    // Instantiate Agent and encapsulate
	    if ((opts && opts.agent && typeof opts.agent.dispatch !== 'function')) {
	      throw new InvalidArgumentError('Argument opts.agent must implement Agent')
	    }
	    const agent = opts && opts.agent ? opts.agent : new Agent(opts);
	    this[kAgent] = agent;

	    this[kClients] = agent[kClients];
	    this[kOptions] = buildMockOptions(opts);
	  }

	  get (origin) {
	    let dispatcher = this[kMockAgentGet](origin);

	    if (!dispatcher) {
	      dispatcher = this[kFactory](origin);
	      this[kMockAgentSet](origin, dispatcher);
	    }
	    return dispatcher
	  }

	  dispatch (opts, handler) {
	    // Call MockAgent.get to perform additional setup before dispatching as normal
	    this.get(opts.origin);
	    return this[kAgent].dispatch(opts, handler)
	  }

	  async close () {
	    await this[kAgent].close();
	    this[kClients].clear();
	  }

	  deactivate () {
	    this[kIsMockActive] = false;
	  }

	  activate () {
	    this[kIsMockActive] = true;
	  }

	  enableNetConnect (matcher) {
	    if (typeof matcher === 'string' || typeof matcher === 'function' || matcher instanceof RegExp) {
	      if (Array.isArray(this[kNetConnect])) {
	        this[kNetConnect].push(matcher);
	      } else {
	        this[kNetConnect] = [matcher];
	      }
	    } else if (typeof matcher === 'undefined') {
	      this[kNetConnect] = true;
	    } else {
	      throw new InvalidArgumentError('Unsupported matcher. Must be one of String|Function|RegExp.')
	    }
	  }

	  disableNetConnect () {
	    this[kNetConnect] = false;
	  }

	  // This is required to bypass issues caused by using global symbols - see:
	  // https://github.com/nodejs/undici/issues/1447
	  get isMockActive () {
	    return this[kIsMockActive]
	  }

	  [kMockAgentSet] (origin, dispatcher) {
	    this[kClients].set(origin, new FakeWeakRef(dispatcher));
	  }

	  [kFactory] (origin) {
	    const mockOptions = Object.assign({ agent: this }, this[kOptions]);
	    return this[kOptions] && this[kOptions].connections === 1
	      ? new MockClient(origin, mockOptions)
	      : new MockPool(origin, mockOptions)
	  }

	  [kMockAgentGet] (origin) {
	    // First check if we can immediately find it
	    const ref = this[kClients].get(origin);
	    if (ref) {
	      return ref.deref()
	    }

	    // If the origin is not a string create a dummy parent pool and return to user
	    if (typeof origin !== 'string') {
	      const dispatcher = this[kFactory]('http://localhost:9999');
	      this[kMockAgentSet](origin, dispatcher);
	      return dispatcher
	    }

	    // If we match, create a pool and assign the same dispatches
	    for (const [keyMatcher, nonExplicitRef] of Array.from(this[kClients])) {
	      const nonExplicitDispatcher = nonExplicitRef.deref();
	      if (nonExplicitDispatcher && typeof keyMatcher !== 'string' && matchValue(keyMatcher, origin)) {
	        const dispatcher = this[kFactory](origin);
	        this[kMockAgentSet](origin, dispatcher);
	        dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches];
	        return dispatcher
	      }
	    }
	  }

	  [kGetNetConnect] () {
	    return this[kNetConnect]
	  }

	  pendingInterceptors () {
	    const mockAgentClients = this[kClients];

	    return Array.from(mockAgentClients.entries())
	      .flatMap(([origin, scope]) => scope.deref()[kDispatches].map(dispatch => ({ ...dispatch, origin })))
	      .filter(({ pending }) => pending)
	  }

	  assertNoPendingInterceptors ({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter() } = {}) {
	    const pending = this.pendingInterceptors();

	    if (pending.length === 0) {
	      return
	    }

	    const pluralizer = new Pluralizer('interceptor', 'interceptors').pluralize(pending.length);

	    throw new UndiciError(`
${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:

${pendingInterceptorsFormatter.format(pending)}
`.trim())
	  }
	}

	mockAgent = MockAgent;
	return mockAgent;
}

var proxyAgent;
var hasRequiredProxyAgent;

function requireProxyAgent () {
	if (hasRequiredProxyAgent) return proxyAgent;
	hasRequiredProxyAgent = 1;

	const { kProxy, kClose, kDestroy, kInterceptors } = requireSymbols$4();
	const { URL } = require$$7$1;
	const Agent = requireAgent();
	const Pool = requirePool();
	const DispatcherBase = requireDispatcherBase();
	const { InvalidArgumentError, RequestAbortedError } = requireErrors();
	const buildConnector = requireConnect();

	const kAgent = Symbol('proxy agent');
	const kClient = Symbol('proxy client');
	const kProxyHeaders = Symbol('proxy headers');
	const kRequestTls = Symbol('request tls settings');
	const kProxyTls = Symbol('proxy tls settings');
	const kConnectEndpoint = Symbol('connect endpoint function');

	function defaultProtocolPort (protocol) {
	  return protocol === 'https:' ? 443 : 80
	}

	function buildProxyOptions (opts) {
	  if (typeof opts === 'string') {
	    opts = { uri: opts };
	  }

	  if (!opts || !opts.uri) {
	    throw new InvalidArgumentError('Proxy opts.uri is mandatory')
	  }

	  return {
	    uri: opts.uri,
	    protocol: opts.protocol || 'https'
	  }
	}

	function defaultFactory (origin, opts) {
	  return new Pool(origin, opts)
	}

	class ProxyAgent extends DispatcherBase {
	  constructor (opts) {
	    super(opts);
	    this[kProxy] = buildProxyOptions(opts);
	    this[kAgent] = new Agent(opts);
	    this[kInterceptors] = opts.interceptors && opts.interceptors.ProxyAgent && Array.isArray(opts.interceptors.ProxyAgent)
	      ? opts.interceptors.ProxyAgent
	      : [];

	    if (typeof opts === 'string') {
	      opts = { uri: opts };
	    }

	    if (!opts || !opts.uri) {
	      throw new InvalidArgumentError('Proxy opts.uri is mandatory')
	    }

	    const { clientFactory = defaultFactory } = opts;

	    if (typeof clientFactory !== 'function') {
	      throw new InvalidArgumentError('Proxy opts.clientFactory must be a function.')
	    }

	    this[kRequestTls] = opts.requestTls;
	    this[kProxyTls] = opts.proxyTls;
	    this[kProxyHeaders] = opts.headers || {};

	    const resolvedUrl = new URL(opts.uri);
	    const { origin, port, host, username, password } = resolvedUrl;

	    if (opts.auth && opts.token) {
	      throw new InvalidArgumentError('opts.auth cannot be used in combination with opts.token')
	    } else if (opts.auth) {
	      /* @deprecated in favour of opts.token */
	      this[kProxyHeaders]['proxy-authorization'] = `Basic ${opts.auth}`;
	    } else if (opts.token) {
	      this[kProxyHeaders]['proxy-authorization'] = opts.token;
	    } else if (username && password) {
	      this[kProxyHeaders]['proxy-authorization'] = `Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString('base64')}`;
	    }

	    const connect = buildConnector({ ...opts.proxyTls });
	    this[kConnectEndpoint] = buildConnector({ ...opts.requestTls });
	    this[kClient] = clientFactory(resolvedUrl, { connect });
	    this[kAgent] = new Agent({
	      ...opts,
	      connect: async (opts, callback) => {
	        let requestedHost = opts.host;
	        if (!opts.port) {
	          requestedHost += `:${defaultProtocolPort(opts.protocol)}`;
	        }
	        try {
	          const { socket, statusCode } = await this[kClient].connect({
	            origin,
	            port,
	            path: requestedHost,
	            signal: opts.signal,
	            headers: {
	              ...this[kProxyHeaders],
	              host
	            }
	          });
	          if (statusCode !== 200) {
	            socket.on('error', () => {}).destroy();
	            callback(new RequestAbortedError(`Proxy response (${statusCode}) !== 200 when HTTP Tunneling`));
	          }
	          if (opts.protocol !== 'https:') {
	            callback(null, socket);
	            return
	          }
	          let servername;
	          if (this[kRequestTls]) {
	            servername = this[kRequestTls].servername;
	          } else {
	            servername = opts.servername;
	          }
	          this[kConnectEndpoint]({ ...opts, servername, httpSocket: socket }, callback);
	        } catch (err) {
	          callback(err);
	        }
	      }
	    });
	  }

	  dispatch (opts, handler) {
	    const { host } = new URL(opts.origin);
	    const headers = buildHeaders(opts.headers);
	    throwIfProxyAuthIsSent(headers);
	    return this[kAgent].dispatch(
	      {
	        ...opts,
	        headers: {
	          ...headers,
	          host
	        }
	      },
	      handler
	    )
	  }

	  async [kClose] () {
	    await this[kAgent].close();
	    await this[kClient].close();
	  }

	  async [kDestroy] () {
	    await this[kAgent].destroy();
	    await this[kClient].destroy();
	  }
	}

	/**
	 * @param {string[] | Record<string, string>} headers
	 * @returns {Record<string, string>}
	 */
	function buildHeaders (headers) {
	  // When using undici.fetch, the headers list is stored
	  // as an array.
	  if (Array.isArray(headers)) {
	    /** @type {Record<string, string>} */
	    const headersPair = {};

	    for (let i = 0; i < headers.length; i += 2) {
	      headersPair[headers[i]] = headers[i + 1];
	    }

	    return headersPair
	  }

	  return headers
	}

	/**
	 * @param {Record<string, string>} headers
	 *
	 * Previous versions of ProxyAgent suggests the Proxy-Authorization in request headers
	 * Nevertheless, it was changed and to avoid a security vulnerability by end users
	 * this check was created.
	 * It should be removed in the next major version for performance reasons
	 */
	function throwIfProxyAuthIsSent (headers) {
	  const existProxyAuth = headers && Object.keys(headers)
	    .find((key) => key.toLowerCase() === 'proxy-authorization');
	  if (existProxyAuth) {
	    throw new InvalidArgumentError('Proxy-Authorization should be sent in ProxyAgent constructor')
	  }
	}

	proxyAgent = ProxyAgent;
	return proxyAgent;
}

var RetryHandler_1;
var hasRequiredRetryHandler;

function requireRetryHandler () {
	if (hasRequiredRetryHandler) return RetryHandler_1;
	hasRequiredRetryHandler = 1;
	const assert = require$$0$4;

	const { kRetryHandlerDefaultRetry } = requireSymbols$4();
	const { RequestRetryError } = requireErrors();
	const { isDisturbed, parseHeaders, parseRangeHeader } = requireUtil$6();

	function calculateRetryAfterHeader (retryAfter) {
	  const current = Date.now();
	  const diff = new Date(retryAfter).getTime() - current;

	  return diff
	}

	class RetryHandler {
	  constructor (opts, handlers) {
	    const { retryOptions, ...dispatchOpts } = opts;
	    const {
	      // Retry scoped
	      retry: retryFn,
	      maxRetries,
	      maxTimeout,
	      minTimeout,
	      timeoutFactor,
	      // Response scoped
	      methods,
	      errorCodes,
	      retryAfter,
	      statusCodes
	    } = retryOptions ?? {};

	    this.dispatch = handlers.dispatch;
	    this.handler = handlers.handler;
	    this.opts = dispatchOpts;
	    this.abort = null;
	    this.aborted = false;
	    this.retryOpts = {
	      retry: retryFn ?? RetryHandler[kRetryHandlerDefaultRetry],
	      retryAfter: retryAfter ?? true,
	      maxTimeout: maxTimeout ?? 30 * 1000, // 30s,
	      timeout: minTimeout ?? 500, // .5s
	      timeoutFactor: timeoutFactor ?? 2,
	      maxRetries: maxRetries ?? 5,
	      // What errors we should retry
	      methods: methods ?? ['GET', 'HEAD', 'OPTIONS', 'PUT', 'DELETE', 'TRACE'],
	      // Indicates which errors to retry
	      statusCodes: statusCodes ?? [500, 502, 503, 504, 429],
	      // List of errors to retry
	      errorCodes: errorCodes ?? [
	        'ECONNRESET',
	        'ECONNREFUSED',
	        'ENOTFOUND',
	        'ENETDOWN',
	        'ENETUNREACH',
	        'EHOSTDOWN',
	        'EHOSTUNREACH',
	        'EPIPE'
	      ]
	    };

	    this.retryCount = 0;
	    this.start = 0;
	    this.end = null;
	    this.etag = null;
	    this.resume = null;

	    // Handle possible onConnect duplication
	    this.handler.onConnect(reason => {
	      this.aborted = true;
	      if (this.abort) {
	        this.abort(reason);
	      } else {
	        this.reason = reason;
	      }
	    });
	  }

	  onRequestSent () {
	    if (this.handler.onRequestSent) {
	      this.handler.onRequestSent();
	    }
	  }

	  onUpgrade (statusCode, headers, socket) {
	    if (this.handler.onUpgrade) {
	      this.handler.onUpgrade(statusCode, headers, socket);
	    }
	  }

	  onConnect (abort) {
	    if (this.aborted) {
	      abort(this.reason);
	    } else {
	      this.abort = abort;
	    }
	  }

	  onBodySent (chunk) {
	    if (this.handler.onBodySent) return this.handler.onBodySent(chunk)
	  }

	  static [kRetryHandlerDefaultRetry] (err, { state, opts }, cb) {
	    const { statusCode, code, headers } = err;
	    const { method, retryOptions } = opts;
	    const {
	      maxRetries,
	      timeout,
	      maxTimeout,
	      timeoutFactor,
	      statusCodes,
	      errorCodes,
	      methods
	    } = retryOptions;
	    let { counter, currentTimeout } = state;

	    currentTimeout =
	      currentTimeout != null && currentTimeout > 0 ? currentTimeout : timeout;

	    // Any code that is not a Undici's originated and allowed to retry
	    if (
	      code &&
	      code !== 'UND_ERR_REQ_RETRY' &&
	      code !== 'UND_ERR_SOCKET' &&
	      !errorCodes.includes(code)
	    ) {
	      cb(err);
	      return
	    }

	    // If a set of method are provided and the current method is not in the list
	    if (Array.isArray(methods) && !methods.includes(method)) {
	      cb(err);
	      return
	    }

	    // If a set of status code are provided and the current status code is not in the list
	    if (
	      statusCode != null &&
	      Array.isArray(statusCodes) &&
	      !statusCodes.includes(statusCode)
	    ) {
	      cb(err);
	      return
	    }

	    // If we reached the max number of retries
	    if (counter > maxRetries) {
	      cb(err);
	      return
	    }

	    let retryAfterHeader = headers != null && headers['retry-after'];
	    if (retryAfterHeader) {
	      retryAfterHeader = Number(retryAfterHeader);
	      retryAfterHeader = isNaN(retryAfterHeader)
	        ? calculateRetryAfterHeader(retryAfterHeader)
	        : retryAfterHeader * 1e3; // Retry-After is in seconds
	    }

	    const retryTimeout =
	      retryAfterHeader > 0
	        ? Math.min(retryAfterHeader, maxTimeout)
	        : Math.min(currentTimeout * timeoutFactor ** counter, maxTimeout);

	    state.currentTimeout = retryTimeout;

	    setTimeout(() => cb(null), retryTimeout);
	  }

	  onHeaders (statusCode, rawHeaders, resume, statusMessage) {
	    const headers = parseHeaders(rawHeaders);

	    this.retryCount += 1;

	    if (statusCode >= 300) {
	      this.abort(
	        new RequestRetryError('Request failed', statusCode, {
	          headers,
	          count: this.retryCount
	        })
	      );
	      return false
	    }

	    // Checkpoint for resume from where we left it
	    if (this.resume != null) {
	      this.resume = null;

	      if (statusCode !== 206) {
	        return true
	      }

	      const contentRange = parseRangeHeader(headers['content-range']);
	      // If no content range
	      if (!contentRange) {
	        this.abort(
	          new RequestRetryError('Content-Range mismatch', statusCode, {
	            headers,
	            count: this.retryCount
	          })
	        );
	        return false
	      }

	      // Let's start with a weak etag check
	      if (this.etag != null && this.etag !== headers.etag) {
	        this.abort(
	          new RequestRetryError('ETag mismatch', statusCode, {
	            headers,
	            count: this.retryCount
	          })
	        );
	        return false
	      }

	      const { start, size, end = size } = contentRange;

	      assert(this.start === start, 'content-range mismatch');
	      assert(this.end == null || this.end === end, 'content-range mismatch');

	      this.resume = resume;
	      return true
	    }

	    if (this.end == null) {
	      if (statusCode === 206) {
	        // First time we receive 206
	        const range = parseRangeHeader(headers['content-range']);

	        if (range == null) {
	          return this.handler.onHeaders(
	            statusCode,
	            rawHeaders,
	            resume,
	            statusMessage
	          )
	        }

	        const { start, size, end = size } = range;

	        assert(
	          start != null && Number.isFinite(start) && this.start !== start,
	          'content-range mismatch'
	        );
	        assert(Number.isFinite(start));
	        assert(
	          end != null && Number.isFinite(end) && this.end !== end,
	          'invalid content-length'
	        );

	        this.start = start;
	        this.end = end;
	      }

	      // We make our best to checkpoint the body for further range headers
	      if (this.end == null) {
	        const contentLength = headers['content-length'];
	        this.end = contentLength != null ? Number(contentLength) : null;
	      }

	      assert(Number.isFinite(this.start));
	      assert(
	        this.end == null || Number.isFinite(this.end),
	        'invalid content-length'
	      );

	      this.resume = resume;
	      this.etag = headers.etag != null ? headers.etag : null;

	      return this.handler.onHeaders(
	        statusCode,
	        rawHeaders,
	        resume,
	        statusMessage
	      )
	    }

	    const err = new RequestRetryError('Request failed', statusCode, {
	      headers,
	      count: this.retryCount
	    });

	    this.abort(err);

	    return false
	  }

	  onData (chunk) {
	    this.start += chunk.length;

	    return this.handler.onData(chunk)
	  }

	  onComplete (rawTrailers) {
	    this.retryCount = 0;
	    return this.handler.onComplete(rawTrailers)
	  }

	  onError (err) {
	    if (this.aborted || isDisturbed(this.opts.body)) {
	      return this.handler.onError(err)
	    }

	    this.retryOpts.retry(
	      err,
	      {
	        state: { counter: this.retryCount++, currentTimeout: this.retryAfter },
	        opts: { retryOptions: this.retryOpts, ...this.opts }
	      },
	      onRetry.bind(this)
	    );

	    function onRetry (err) {
	      if (err != null || this.aborted || isDisturbed(this.opts.body)) {
	        return this.handler.onError(err)
	      }

	      if (this.start !== 0) {
	        this.opts = {
	          ...this.opts,
	          headers: {
	            ...this.opts.headers,
	            range: `bytes=${this.start}-${this.end ?? ''}`
	          }
	        };
	      }

	      try {
	        this.dispatch(this.opts, this);
	      } catch (err) {
	        this.handler.onError(err);
	      }
	    }
	  }
	}

	RetryHandler_1 = RetryHandler;
	return RetryHandler_1;
}

var global$2;
var hasRequiredGlobal;

function requireGlobal () {
	if (hasRequiredGlobal) return global$2;
	hasRequiredGlobal = 1;

	// We include a version number for the Dispatcher API. In case of breaking changes,
	// this version number must be increased to avoid conflicts.
	const globalDispatcher = Symbol.for('undici.globalDispatcher.1');
	const { InvalidArgumentError } = requireErrors();
	const Agent = requireAgent();

	if (getGlobalDispatcher() === undefined) {
	  setGlobalDispatcher(new Agent());
	}

	function setGlobalDispatcher (agent) {
	  if (!agent || typeof agent.dispatch !== 'function') {
	    throw new InvalidArgumentError('Argument agent must implement Agent')
	  }
	  Object.defineProperty(globalThis, globalDispatcher, {
	    value: agent,
	    writable: true,
	    enumerable: false,
	    configurable: false
	  });
	}

	function getGlobalDispatcher () {
	  return globalThis[globalDispatcher]
	}

	global$2 = {
	  setGlobalDispatcher,
	  getGlobalDispatcher
	};
	return global$2;
}

var DecoratorHandler_1;
var hasRequiredDecoratorHandler;

function requireDecoratorHandler () {
	if (hasRequiredDecoratorHandler) return DecoratorHandler_1;
	hasRequiredDecoratorHandler = 1;

	DecoratorHandler_1 = class DecoratorHandler {
	  constructor (handler) {
	    this.handler = handler;
	  }

	  onConnect (...args) {
	    return this.handler.onConnect(...args)
	  }

	  onError (...args) {
	    return this.handler.onError(...args)
	  }

	  onUpgrade (...args) {
	    return this.handler.onUpgrade(...args)
	  }

	  onHeaders (...args) {
	    return this.handler.onHeaders(...args)
	  }

	  onData (...args) {
	    return this.handler.onData(...args)
	  }

	  onComplete (...args) {
	    return this.handler.onComplete(...args)
	  }

	  onBodySent (...args) {
	    return this.handler.onBodySent(...args)
	  }
	};
	return DecoratorHandler_1;
}

var headers;
var hasRequiredHeaders;

function requireHeaders () {
	if (hasRequiredHeaders) return headers;
	hasRequiredHeaders = 1;

	const { kHeadersList, kConstruct } = requireSymbols$4();
	const { kGuard } = requireSymbols$3();
	const { kEnumerableProperty } = requireUtil$6();
	const {
	  makeIterator,
	  isValidHeaderName,
	  isValidHeaderValue
	} = requireUtil$5();
	const util = require$$0$2;
	const { webidl } = requireWebidl();
	const assert = require$$0$4;

	const kHeadersMap = Symbol('headers map');
	const kHeadersSortedMap = Symbol('headers map sorted');

	/**
	 * @param {number} code
	 */
	function isHTTPWhiteSpaceCharCode (code) {
	  return code === 0x00a || code === 0x00d || code === 0x009 || code === 0x020
	}

	/**
	 * @see https://fetch.spec.whatwg.org/#concept-header-value-normalize
	 * @param {string} potentialValue
	 */
	function headerValueNormalize (potentialValue) {
	  //  To normalize a byte sequence potentialValue, remove
	  //  any leading and trailing HTTP whitespace bytes from
	  //  potentialValue.
	  let i = 0; let j = potentialValue.length;

	  while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j - 1))) --j;
	  while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i))) ++i;

	  return i === 0 && j === potentialValue.length ? potentialValue : potentialValue.substring(i, j)
	}

	function fill (headers, object) {
	  // To fill a Headers object headers with a given object object, run these steps:

	  // 1. If object is a sequence, then for each header in object:
	  // Note: webidl conversion to array has already been done.
	  if (Array.isArray(object)) {
	    for (let i = 0; i < object.length; ++i) {
	      const header = object[i];
	      // 1. If header does not contain exactly two items, then throw a TypeError.
	      if (header.length !== 2) {
	        throw webidl.errors.exception({
	          header: 'Headers constructor',
	          message: `expected name/value pair to be length 2, found ${header.length}.`
	        })
	      }

	      // 2. Append (headers first item, headers second item) to headers.
	      appendHeader(headers, header[0], header[1]);
	    }
	  } else if (typeof object === 'object' && object !== null) {
	    // Note: null should throw

	    // 2. Otherwise, object is a record, then for each key  value in object,
	    //    append (key, value) to headers
	    const keys = Object.keys(object);
	    for (let i = 0; i < keys.length; ++i) {
	      appendHeader(headers, keys[i], object[keys[i]]);
	    }
	  } else {
	    throw webidl.errors.conversionFailed({
	      prefix: 'Headers constructor',
	      argument: 'Argument 1',
	      types: ['sequence<sequence<ByteString>>', 'record<ByteString, ByteString>']
	    })
	  }
	}

	/**
	 * @see https://fetch.spec.whatwg.org/#concept-headers-append
	 */
	function appendHeader (headers, name, value) {
	  // 1. Normalize value.
	  value = headerValueNormalize(value);

	  // 2. If name is not a header name or value is not a
	  //    header value, then throw a TypeError.
	  if (!isValidHeaderName(name)) {
	    throw webidl.errors.invalidArgument({
	      prefix: 'Headers.append',
	      value: name,
	      type: 'header name'
	    })
	  } else if (!isValidHeaderValue(value)) {
	    throw webidl.errors.invalidArgument({
	      prefix: 'Headers.append',
	      value,
	      type: 'header value'
	    })
	  }

	  // 3. If headerss guard is "immutable", then throw a TypeError.
	  // 4. Otherwise, if headerss guard is "request" and name is a
	  //    forbidden header name, return.
	  // Note: undici does not implement forbidden header names
	  if (headers[kGuard] === 'immutable') {
	    throw new TypeError('immutable')
	  } else if (headers[kGuard] === 'request-no-cors') ;

	  // 6. Otherwise, if headerss guard is "response" and name is a
	  //    forbidden response-header name, return.

	  // 7. Append (name, value) to headerss header list.
	  return headers[kHeadersList].append(name, value)

	  // 8. If headerss guard is "request-no-cors", then remove
	  //    privileged no-CORS request headers from headers
	}

	class HeadersList {
	  /** @type {[string, string][]|null} */
	  cookies = null

	  constructor (init) {
	    if (init instanceof HeadersList) {
	      this[kHeadersMap] = new Map(init[kHeadersMap]);
	      this[kHeadersSortedMap] = init[kHeadersSortedMap];
	      this.cookies = init.cookies === null ? null : [...init.cookies];
	    } else {
	      this[kHeadersMap] = new Map(init);
	      this[kHeadersSortedMap] = null;
	    }
	  }

	  // https://fetch.spec.whatwg.org/#header-list-contains
	  contains (name) {
	    // A header list list contains a header name name if list
	    // contains a header whose name is a byte-case-insensitive
	    // match for name.
	    name = name.toLowerCase();

	    return this[kHeadersMap].has(name)
	  }

	  clear () {
	    this[kHeadersMap].clear();
	    this[kHeadersSortedMap] = null;
	    this.cookies = null;
	  }

	  // https://fetch.spec.whatwg.org/#concept-header-list-append
	  append (name, value) {
	    this[kHeadersSortedMap] = null;

	    // 1. If list contains name, then set name to the first such
	    //    headers name.
	    const lowercaseName = name.toLowerCase();
	    const exists = this[kHeadersMap].get(lowercaseName);

	    // 2. Append (name, value) to list.
	    if (exists) {
	      const delimiter = lowercaseName === 'cookie' ? '; ' : ', ';
	      this[kHeadersMap].set(lowercaseName, {
	        name: exists.name,
	        value: `${exists.value}${delimiter}${value}`
	      });
	    } else {
	      this[kHeadersMap].set(lowercaseName, { name, value });
	    }

	    if (lowercaseName === 'set-cookie') {
	      this.cookies ??= [];
	      this.cookies.push(value);
	    }
	  }

	  // https://fetch.spec.whatwg.org/#concept-header-list-set
	  set (name, value) {
	    this[kHeadersSortedMap] = null;
	    const lowercaseName = name.toLowerCase();

	    if (lowercaseName === 'set-cookie') {
	      this.cookies = [value];
	    }

	    // 1. If list contains name, then set the value of
	    //    the first such header to value and remove the
	    //    others.
	    // 2. Otherwise, append header (name, value) to list.
	    this[kHeadersMap].set(lowercaseName, { name, value });
	  }

	  // https://fetch.spec.whatwg.org/#concept-header-list-delete
	  delete (name) {
	    this[kHeadersSortedMap] = null;

	    name = name.toLowerCase();

	    if (name === 'set-cookie') {
	      this.cookies = null;
	    }

	    this[kHeadersMap].delete(name);
	  }

	  // https://fetch.spec.whatwg.org/#concept-header-list-get
	  get (name) {
	    const value = this[kHeadersMap].get(name.toLowerCase());

	    // 1. If list does not contain name, then return null.
	    // 2. Return the values of all headers in list whose name
	    //    is a byte-case-insensitive match for name,
	    //    separated from each other by 0x2C 0x20, in order.
	    return value === undefined ? null : value.value
	  }

	  * [Symbol.iterator] () {
	    // use the lowercased name
	    for (const [name, { value }] of this[kHeadersMap]) {
	      yield [name, value];
	    }
	  }

	  get entries () {
	    const headers = {};

	    if (this[kHeadersMap].size) {
	      for (const { name, value } of this[kHeadersMap].values()) {
	        headers[name] = value;
	      }
	    }

	    return headers
	  }
	}

	// https://fetch.spec.whatwg.org/#headers-class
	class Headers {
	  constructor (init = undefined) {
	    if (init === kConstruct) {
	      return
	    }
	    this[kHeadersList] = new HeadersList();

	    // The new Headers(init) constructor steps are:

	    // 1. Set thiss guard to "none".
	    this[kGuard] = 'none';

	    // 2. If init is given, then fill this with init.
	    if (init !== undefined) {
	      init = webidl.converters.HeadersInit(init);
	      fill(this, init);
	    }
	  }

	  // https://fetch.spec.whatwg.org/#dom-headers-append
	  append (name, value) {
	    webidl.brandCheck(this, Headers);

	    webidl.argumentLengthCheck(arguments, 2, { header: 'Headers.append' });

	    name = webidl.converters.ByteString(name);
	    value = webidl.converters.ByteString(value);

	    return appendHeader(this, name, value)
	  }

	  // https://fetch.spec.whatwg.org/#dom-headers-delete
	  delete (name) {
	    webidl.brandCheck(this, Headers);

	    webidl.argumentLengthCheck(arguments, 1, { header: 'Headers.delete' });

	    name = webidl.converters.ByteString(name);

	    // 1. If name is not a header name, then throw a TypeError.
	    if (!isValidHeaderName(name)) {
	      throw webidl.errors.invalidArgument({
	        prefix: 'Headers.delete',
	        value: name,
	        type: 'header name'
	      })
	    }

	    // 2. If thiss guard is "immutable", then throw a TypeError.
	    // 3. Otherwise, if thiss guard is "request" and name is a
	    //    forbidden header name, return.
	    // 4. Otherwise, if thiss guard is "request-no-cors", name
	    //    is not a no-CORS-safelisted request-header name, and
	    //    name is not a privileged no-CORS request-header name,
	    //    return.
	    // 5. Otherwise, if thiss guard is "response" and name is
	    //    a forbidden response-header name, return.
	    // Note: undici does not implement forbidden header names
	    if (this[kGuard] === 'immutable') {
	      throw new TypeError('immutable')
	    } else if (this[kGuard] === 'request-no-cors') ;

	    // 6. If thiss header list does not contain name, then
	    //    return.
	    if (!this[kHeadersList].contains(name)) {
	      return
	    }

	    // 7. Delete name from thiss header list.
	    // 8. If thiss guard is "request-no-cors", then remove
	    //    privileged no-CORS request headers from this.
	    this[kHeadersList].delete(name);
	  }

	  // https://fetch.spec.whatwg.org/#dom-headers-get
	  get (name) {
	    webidl.brandCheck(this, Headers);

	    webidl.argumentLengthCheck(arguments, 1, { header: 'Headers.get' });

	    name = webidl.converters.ByteString(name);

	    // 1. If name is not a header name, then throw a TypeError.
	    if (!isValidHeaderName(name)) {
	      throw webidl.errors.invalidArgument({
	        prefix: 'Headers.get',
	        value: name,
	        type: 'header name'
	      })
	    }

	    // 2. Return the result of getting name from thiss header
	    //    list.
	    return this[kHeadersList].get(name)
	  }

	  // https://fetch.spec.whatwg.org/#dom-headers-has
	  has (name) {
	    webidl.brandCheck(this, Headers);

	    webidl.argumentLengthCheck(arguments, 1, { header: 'Headers.has' });

	    name = webidl.converters.ByteString(name);

	    // 1. If name is not a header name, then throw a TypeError.
	    if (!isValidHeaderName(name)) {
	      throw webidl.errors.invalidArgument({
	        prefix: 'Headers.has',
	        value: name,
	        type: 'header name'
	      })
	    }

	    // 2. Return true if thiss header list contains name;
	    //    otherwise false.
	    return this[kHeadersList].contains(name)
	  }

	  // https://fetch.spec.whatwg.org/#dom-headers-set
	  set (name, value) {
	    webidl.brandCheck(this, Headers);

	    webidl.argumentLengthCheck(arguments, 2, { header: 'Headers.set' });

	    name = webidl.converters.ByteString(name);
	    value = webidl.converters.ByteString(value);

	    // 1. Normalize value.
	    value = headerValueNormalize(value);

	    // 2. If name is not a header name or value is not a
	    //    header value, then throw a TypeError.
	    if (!isValidHeaderName(name)) {
	      throw webidl.errors.invalidArgument({
	        prefix: 'Headers.set',
	        value: name,
	        type: 'header name'
	      })
	    } else if (!isValidHeaderValue(value)) {
	      throw webidl.errors.invalidArgument({
	        prefix: 'Headers.set',
	        value,
	        type: 'header value'
	      })
	    }

	    // 3. If thiss guard is "immutable", then throw a TypeError.
	    // 4. Otherwise, if thiss guard is "request" and name is a
	    //    forbidden header name, return.
	    // 5. Otherwise, if thiss guard is "request-no-cors" and
	    //    name/value is not a no-CORS-safelisted request-header,
	    //    return.
	    // 6. Otherwise, if thiss guard is "response" and name is a
	    //    forbidden response-header name, return.
	    // Note: undici does not implement forbidden header names
	    if (this[kGuard] === 'immutable') {
	      throw new TypeError('immutable')
	    } else if (this[kGuard] === 'request-no-cors') ;

	    // 7. Set (name, value) in thiss header list.
	    // 8. If thiss guard is "request-no-cors", then remove
	    //    privileged no-CORS request headers from this
	    this[kHeadersList].set(name, value);
	  }

	  // https://fetch.spec.whatwg.org/#dom-headers-getsetcookie
	  getSetCookie () {
	    webidl.brandCheck(this, Headers);

	    // 1. If thiss header list does not contain `Set-Cookie`, then return  .
	    // 2. Return the values of all headers in thiss header list whose name is
	    //    a byte-case-insensitive match for `Set-Cookie`, in order.

	    const list = this[kHeadersList].cookies;

	    if (list) {
	      return [...list]
	    }

	    return []
	  }

	  // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine
	  get [kHeadersSortedMap] () {
	    if (this[kHeadersList][kHeadersSortedMap]) {
	      return this[kHeadersList][kHeadersSortedMap]
	    }

	    // 1. Let headers be an empty list of headers with the key being the name
	    //    and value the value.
	    const headers = [];

	    // 2. Let names be the result of convert header names to a sorted-lowercase
	    //    set with all the names of the headers in list.
	    const names = [...this[kHeadersList]].sort((a, b) => a[0] < b[0] ? -1 : 1);
	    const cookies = this[kHeadersList].cookies;

	    // 3. For each name of names:
	    for (let i = 0; i < names.length; ++i) {
	      const [name, value] = names[i];
	      // 1. If name is `set-cookie`, then:
	      if (name === 'set-cookie') {
	        // 1. Let values be a list of all values of headers in list whose name
	        //    is a byte-case-insensitive match for name, in order.

	        // 2. For each value of values:
	        // 1. Append (name, value) to headers.
	        for (let j = 0; j < cookies.length; ++j) {
	          headers.push([name, cookies[j]]);
	        }
	      } else {
	        // 2. Otherwise:

	        // 1. Let value be the result of getting name from list.

	        // 2. Assert: value is non-null.
	        assert(value !== null);

	        // 3. Append (name, value) to headers.
	        headers.push([name, value]);
	      }
	    }

	    this[kHeadersList][kHeadersSortedMap] = headers;

	    // 4. Return headers.
	    return headers
	  }

	  keys () {
	    webidl.brandCheck(this, Headers);

	    if (this[kGuard] === 'immutable') {
	      const value = this[kHeadersSortedMap];
	      return makeIterator(() => value, 'Headers',
	        'key')
	    }

	    return makeIterator(
	      () => [...this[kHeadersSortedMap].values()],
	      'Headers',
	      'key'
	    )
	  }

	  values () {
	    webidl.brandCheck(this, Headers);

	    if (this[kGuard] === 'immutable') {
	      const value = this[kHeadersSortedMap];
	      return makeIterator(() => value, 'Headers',
	        'value')
	    }

	    return makeIterator(
	      () => [...this[kHeadersSortedMap].values()],
	      'Headers',
	      'value'
	    )
	  }

	  entries () {
	    webidl.brandCheck(this, Headers);

	    if (this[kGuard] === 'immutable') {
	      const value = this[kHeadersSortedMap];
	      return makeIterator(() => value, 'Headers',
	        'key+value')
	    }

	    return makeIterator(
	      () => [...this[kHeadersSortedMap].values()],
	      'Headers',
	      'key+value'
	    )
	  }

	  /**
	   * @param {(value: string, key: string, self: Headers) => void} callbackFn
	   * @param {unknown} thisArg
	   */
	  forEach (callbackFn, thisArg = globalThis) {
	    webidl.brandCheck(this, Headers);

	    webidl.argumentLengthCheck(arguments, 1, { header: 'Headers.forEach' });

	    if (typeof callbackFn !== 'function') {
	      throw new TypeError(
	        "Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'."
	      )
	    }

	    for (const [key, value] of this) {
	      callbackFn.apply(thisArg, [value, key, this]);
	    }
	  }

	  [Symbol.for('nodejs.util.inspect.custom')] () {
	    webidl.brandCheck(this, Headers);

	    return this[kHeadersList]
	  }
	}

	Headers.prototype[Symbol.iterator] = Headers.prototype.entries;

	Object.defineProperties(Headers.prototype, {
	  append: kEnumerableProperty,
	  delete: kEnumerableProperty,
	  get: kEnumerableProperty,
	  has: kEnumerableProperty,
	  set: kEnumerableProperty,
	  getSetCookie: kEnumerableProperty,
	  keys: kEnumerableProperty,
	  values: kEnumerableProperty,
	  entries: kEnumerableProperty,
	  forEach: kEnumerableProperty,
	  [Symbol.iterator]: { enumerable: false },
	  [Symbol.toStringTag]: {
	    value: 'Headers',
	    configurable: true
	  },
	  [util.inspect.custom]: {
	    enumerable: false
	  }
	});

	webidl.converters.HeadersInit = function (V) {
	  if (webidl.util.Type(V) === 'Object') {
	    if (V[Symbol.iterator]) {
	      return webidl.converters['sequence<sequence<ByteString>>'](V)
	    }

	    return webidl.converters['record<ByteString, ByteString>'](V)
	  }

	  throw webidl.errors.conversionFailed({
	    prefix: 'Headers constructor',
	    argument: 'Argument 1',
	    types: ['sequence<sequence<ByteString>>', 'record<ByteString, ByteString>']
	  })
	};

	headers = {
	  fill,
	  Headers,
	  HeadersList
	};
	return headers;
}

var response;
var hasRequiredResponse;

function requireResponse () {
	if (hasRequiredResponse) return response;
	hasRequiredResponse = 1;

	const { Headers, HeadersList, fill } = requireHeaders();
	const { extractBody, cloneBody, mixinBody } = requireBody();
	const util = requireUtil$6();
	const { kEnumerableProperty } = util;
	const {
	  isValidReasonPhrase,
	  isCancelled,
	  isAborted,
	  isBlobLike,
	  serializeJavascriptValueToJSONString,
	  isErrorLike,
	  isomorphicEncode
	} = requireUtil$5();
	const {
	  redirectStatusSet,
	  nullBodyStatus,
	  DOMException
	} = requireConstants$5();
	const { kState, kHeaders, kGuard, kRealm } = requireSymbols$3();
	const { webidl } = requireWebidl();
	const { FormData } = requireFormdata();
	const { getGlobalOrigin } = requireGlobal$1();
	const { URLSerializer } = requireDataURL();
	const { kHeadersList, kConstruct } = requireSymbols$4();
	const assert = require$$0$4;
	const { types } = require$$0$2;

	const ReadableStream = globalThis.ReadableStream || require$$14.ReadableStream;
	const textEncoder = new TextEncoder('utf-8');

	// https://fetch.spec.whatwg.org/#response-class
	class Response {
	  // Creates network error Response.
	  static error () {
	    // TODO
	    const relevantRealm = { settingsObject: {} };

	    // The static error() method steps are to return the result of creating a
	    // Response object, given a new network error, "immutable", and thiss
	    // relevant Realm.
	    const responseObject = new Response();
	    responseObject[kState] = makeNetworkError();
	    responseObject[kRealm] = relevantRealm;
	    responseObject[kHeaders][kHeadersList] = responseObject[kState].headersList;
	    responseObject[kHeaders][kGuard] = 'immutable';
	    responseObject[kHeaders][kRealm] = relevantRealm;
	    return responseObject
	  }

	  // https://fetch.spec.whatwg.org/#dom-response-json
	  static json (data, init = {}) {
	    webidl.argumentLengthCheck(arguments, 1, { header: 'Response.json' });

	    if (init !== null) {
	      init = webidl.converters.ResponseInit(init);
	    }

	    // 1. Let bytes the result of running serialize a JavaScript value to JSON bytes on data.
	    const bytes = textEncoder.encode(
	      serializeJavascriptValueToJSONString(data)
	    );

	    // 2. Let body be the result of extracting bytes.
	    const body = extractBody(bytes);

	    // 3. Let responseObject be the result of creating a Response object, given a new response,
	    //    "response", and thiss relevant Realm.
	    const relevantRealm = { settingsObject: {} };
	    const responseObject = new Response();
	    responseObject[kRealm] = relevantRealm;
	    responseObject[kHeaders][kGuard] = 'response';
	    responseObject[kHeaders][kRealm] = relevantRealm;

	    // 4. Perform initialize a response given responseObject, init, and (body, "application/json").
	    initializeResponse(responseObject, init, { body: body[0], type: 'application/json' });

	    // 5. Return responseObject.
	    return responseObject
	  }

	  // Creates a redirect Response that redirects to url with status status.
	  static redirect (url, status = 302) {
	    const relevantRealm = { settingsObject: {} };

	    webidl.argumentLengthCheck(arguments, 1, { header: 'Response.redirect' });

	    url = webidl.converters.USVString(url);
	    status = webidl.converters['unsigned short'](status);

	    // 1. Let parsedURL be the result of parsing url with current settings
	    // objects API base URL.
	    // 2. If parsedURL is failure, then throw a TypeError.
	    // TODO: base-URL?
	    let parsedURL;
	    try {
	      parsedURL = new URL(url, getGlobalOrigin());
	    } catch (err) {
	      throw Object.assign(new TypeError('Failed to parse URL from ' + url), {
	        cause: err
	      })
	    }

	    // 3. If status is not a redirect status, then throw a RangeError.
	    if (!redirectStatusSet.has(status)) {
	      throw new RangeError('Invalid status code ' + status)
	    }

	    // 4. Let responseObject be the result of creating a Response object,
	    // given a new response, "immutable", and thiss relevant Realm.
	    const responseObject = new Response();
	    responseObject[kRealm] = relevantRealm;
	    responseObject[kHeaders][kGuard] = 'immutable';
	    responseObject[kHeaders][kRealm] = relevantRealm;

	    // 5. Set responseObjects responses status to status.
	    responseObject[kState].status = status;

	    // 6. Let value be parsedURL, serialized and isomorphic encoded.
	    const value = isomorphicEncode(URLSerializer(parsedURL));

	    // 7. Append `Location`/value to responseObjects responses header list.
	    responseObject[kState].headersList.append('location', value);

	    // 8. Return responseObject.
	    return responseObject
	  }

	  // https://fetch.spec.whatwg.org/#dom-response
	  constructor (body = null, init = {}) {
	    if (body !== null) {
	      body = webidl.converters.BodyInit(body);
	    }

	    init = webidl.converters.ResponseInit(init);

	    // TODO
	    this[kRealm] = { settingsObject: {} };

	    // 1. Set thiss response to a new response.
	    this[kState] = makeResponse({});

	    // 2. Set thiss headers to a new Headers object with thiss relevant
	    // Realm, whose header list is thiss responses header list and guard
	    // is "response".
	    this[kHeaders] = new Headers(kConstruct);
	    this[kHeaders][kGuard] = 'response';
	    this[kHeaders][kHeadersList] = this[kState].headersList;
	    this[kHeaders][kRealm] = this[kRealm];

	    // 3. Let bodyWithType be null.
	    let bodyWithType = null;

	    // 4. If body is non-null, then set bodyWithType to the result of extracting body.
	    if (body != null) {
	      const [extractedBody, type] = extractBody(body);
	      bodyWithType = { body: extractedBody, type };
	    }

	    // 5. Perform initialize a response given this, init, and bodyWithType.
	    initializeResponse(this, init, bodyWithType);
	  }

	  // Returns responses type, e.g., "cors".
	  get type () {
	    webidl.brandCheck(this, Response);

	    // The type getter steps are to return thiss responses type.
	    return this[kState].type
	  }

	  // Returns responses URL, if it has one; otherwise the empty string.
	  get url () {
	    webidl.brandCheck(this, Response);

	    const urlList = this[kState].urlList;

	    // The url getter steps are to return the empty string if thiss
	    // responses URL is null; otherwise thiss responses URL,
	    // serialized with exclude fragment set to true.
	    const url = urlList[urlList.length - 1] ?? null;

	    if (url === null) {
	      return ''
	    }

	    return URLSerializer(url, true)
	  }

	  // Returns whether response was obtained through a redirect.
	  get redirected () {
	    webidl.brandCheck(this, Response);

	    // The redirected getter steps are to return true if thiss responses URL
	    // list has more than one item; otherwise false.
	    return this[kState].urlList.length > 1
	  }

	  // Returns responses status.
	  get status () {
	    webidl.brandCheck(this, Response);

	    // The status getter steps are to return thiss responses status.
	    return this[kState].status
	  }

	  // Returns whether responses status is an ok status.
	  get ok () {
	    webidl.brandCheck(this, Response);

	    // The ok getter steps are to return true if thiss responses status is an
	    // ok status; otherwise false.
	    return this[kState].status >= 200 && this[kState].status <= 299
	  }

	  // Returns responses status message.
	  get statusText () {
	    webidl.brandCheck(this, Response);

	    // The statusText getter steps are to return thiss responses status
	    // message.
	    return this[kState].statusText
	  }

	  // Returns responses headers as Headers.
	  get headers () {
	    webidl.brandCheck(this, Response);

	    // The headers getter steps are to return thiss headers.
	    return this[kHeaders]
	  }

	  get body () {
	    webidl.brandCheck(this, Response);

	    return this[kState].body ? this[kState].body.stream : null
	  }

	  get bodyUsed () {
	    webidl.brandCheck(this, Response);

	    return !!this[kState].body && util.isDisturbed(this[kState].body.stream)
	  }

	  // Returns a clone of response.
	  clone () {
	    webidl.brandCheck(this, Response);

	    // 1. If this is unusable, then throw a TypeError.
	    if (this.bodyUsed || (this.body && this.body.locked)) {
	      throw webidl.errors.exception({
	        header: 'Response.clone',
	        message: 'Body has already been consumed.'
	      })
	    }

	    // 2. Let clonedResponse be the result of cloning thiss response.
	    const clonedResponse = cloneResponse(this[kState]);

	    // 3. Return the result of creating a Response object, given
	    // clonedResponse, thiss headerss guard, and thiss relevant Realm.
	    const clonedResponseObject = new Response();
	    clonedResponseObject[kState] = clonedResponse;
	    clonedResponseObject[kRealm] = this[kRealm];
	    clonedResponseObject[kHeaders][kHeadersList] = clonedResponse.headersList;
	    clonedResponseObject[kHeaders][kGuard] = this[kHeaders][kGuard];
	    clonedResponseObject[kHeaders][kRealm] = this[kHeaders][kRealm];

	    return clonedResponseObject
	  }
	}

	mixinBody(Response);

	Object.defineProperties(Response.prototype, {
	  type: kEnumerableProperty,
	  url: kEnumerableProperty,
	  status: kEnumerableProperty,
	  ok: kEnumerableProperty,
	  redirected: kEnumerableProperty,
	  statusText: kEnumerableProperty,
	  headers: kEnumerableProperty,
	  clone: kEnumerableProperty,
	  body: kEnumerableProperty,
	  bodyUsed: kEnumerableProperty,
	  [Symbol.toStringTag]: {
	    value: 'Response',
	    configurable: true
	  }
	});

	Object.defineProperties(Response, {
	  json: kEnumerableProperty,
	  redirect: kEnumerableProperty,
	  error: kEnumerableProperty
	});

	// https://fetch.spec.whatwg.org/#concept-response-clone
	function cloneResponse (response) {
	  // To clone a response response, run these steps:

	  // 1. If response is a filtered response, then return a new identical
	  // filtered response whose internal response is a clone of responses
	  // internal response.
	  if (response.internalResponse) {
	    return filterResponse(
	      cloneResponse(response.internalResponse),
	      response.type
	    )
	  }

	  // 2. Let newResponse be a copy of response, except for its body.
	  const newResponse = makeResponse({ ...response, body: null });

	  // 3. If responses body is non-null, then set newResponses body to the
	  // result of cloning responses body.
	  if (response.body != null) {
	    newResponse.body = cloneBody(response.body);
	  }

	  // 4. Return newResponse.
	  return newResponse
	}

	function makeResponse (init) {
	  return {
	    aborted: false,
	    rangeRequested: false,
	    timingAllowPassed: false,
	    requestIncludesCredentials: false,
	    type: 'default',
	    status: 200,
	    timingInfo: null,
	    cacheState: '',
	    statusText: '',
	    ...init,
	    headersList: init.headersList
	      ? new HeadersList(init.headersList)
	      : new HeadersList(),
	    urlList: init.urlList ? [...init.urlList] : []
	  }
	}

	function makeNetworkError (reason) {
	  const isError = isErrorLike(reason);
	  return makeResponse({
	    type: 'error',
	    status: 0,
	    error: isError
	      ? reason
	      : new Error(reason ? String(reason) : reason),
	    aborted: reason && reason.name === 'AbortError'
	  })
	}

	function makeFilteredResponse (response, state) {
	  state = {
	    internalResponse: response,
	    ...state
	  };

	  return new Proxy(response, {
	    get (target, p) {
	      return p in state ? state[p] : target[p]
	    },
	    set (target, p, value) {
	      assert(!(p in state));
	      target[p] = value;
	      return true
	    }
	  })
	}

	// https://fetch.spec.whatwg.org/#concept-filtered-response
	function filterResponse (response, type) {
	  // Set response to the following filtered response with response as its
	  // internal response, depending on requests response tainting:
	  if (type === 'basic') {
	    // A basic filtered response is a filtered response whose type is "basic"
	    // and header list excludes any headers in internal responses header list
	    // whose name is a forbidden response-header name.

	    // Note: undici does not implement forbidden response-header names
	    return makeFilteredResponse(response, {
	      type: 'basic',
	      headersList: response.headersList
	    })
	  } else if (type === 'cors') {
	    // A CORS filtered response is a filtered response whose type is "cors"
	    // and header list excludes any headers in internal responses header
	    // list whose name is not a CORS-safelisted response-header name, given
	    // internal responses CORS-exposed header-name list.

	    // Note: undici does not implement CORS-safelisted response-header names
	    return makeFilteredResponse(response, {
	      type: 'cors',
	      headersList: response.headersList
	    })
	  } else if (type === 'opaque') {
	    // An opaque filtered response is a filtered response whose type is
	    // "opaque", URL list is the empty list, status is 0, status message
	    // is the empty byte sequence, header list is empty, and body is null.

	    return makeFilteredResponse(response, {
	      type: 'opaque',
	      urlList: Object.freeze([]),
	      status: 0,
	      statusText: '',
	      body: null
	    })
	  } else if (type === 'opaqueredirect') {
	    // An opaque-redirect filtered response is a filtered response whose type
	    // is "opaqueredirect", status is 0, status message is the empty byte
	    // sequence, header list is empty, and body is null.

	    return makeFilteredResponse(response, {
	      type: 'opaqueredirect',
	      status: 0,
	      statusText: '',
	      headersList: [],
	      body: null
	    })
	  } else {
	    assert(false);
	  }
	}

	// https://fetch.spec.whatwg.org/#appropriate-network-error
	function makeAppropriateNetworkError (fetchParams, err = null) {
	  // 1. Assert: fetchParams is canceled.
	  assert(isCancelled(fetchParams));

	  // 2. Return an aborted network error if fetchParams is aborted;
	  // otherwise return a network error.
	  return isAborted(fetchParams)
	    ? makeNetworkError(Object.assign(new DOMException('The operation was aborted.', 'AbortError'), { cause: err }))
	    : makeNetworkError(Object.assign(new DOMException('Request was cancelled.'), { cause: err }))
	}

	// https://whatpr.org/fetch/1392.html#initialize-a-response
	function initializeResponse (response, init, body) {
	  // 1. If init["status"] is not in the range 200 to 599, inclusive, then
	  //    throw a RangeError.
	  if (init.status !== null && (init.status < 200 || init.status > 599)) {
	    throw new RangeError('init["status"] must be in the range of 200 to 599, inclusive.')
	  }

	  // 2. If init["statusText"] does not match the reason-phrase token production,
	  //    then throw a TypeError.
	  if ('statusText' in init && init.statusText != null) {
	    // See, https://datatracker.ietf.org/doc/html/rfc7230#section-3.1.2:
	    //   reason-phrase  = *( HTAB / SP / VCHAR / obs-text )
	    if (!isValidReasonPhrase(String(init.statusText))) {
	      throw new TypeError('Invalid statusText')
	    }
	  }

	  // 3. Set responses responses status to init["status"].
	  if ('status' in init && init.status != null) {
	    response[kState].status = init.status;
	  }

	  // 4. Set responses responses status message to init["statusText"].
	  if ('statusText' in init && init.statusText != null) {
	    response[kState].statusText = init.statusText;
	  }

	  // 5. If init["headers"] exists, then fill responses headers with init["headers"].
	  if ('headers' in init && init.headers != null) {
	    fill(response[kHeaders], init.headers);
	  }

	  // 6. If body was given, then:
	  if (body) {
	    // 1. If response's status is a null body status, then throw a TypeError.
	    if (nullBodyStatus.includes(response.status)) {
	      throw webidl.errors.exception({
	        header: 'Response constructor',
	        message: 'Invalid response status code ' + response.status
	      })
	    }

	    // 2. Set response's body to body's body.
	    response[kState].body = body.body;

	    // 3. If body's type is non-null and response's header list does not contain
	    //    `Content-Type`, then append (`Content-Type`, body's type) to response's header list.
	    if (body.type != null && !response[kState].headersList.contains('Content-Type')) {
	      response[kState].headersList.append('content-type', body.type);
	    }
	  }
	}

	webidl.converters.ReadableStream = webidl.interfaceConverter(
	  ReadableStream
	);

	webidl.converters.FormData = webidl.interfaceConverter(
	  FormData
	);

	webidl.converters.URLSearchParams = webidl.interfaceConverter(
	  URLSearchParams
	);

	// https://fetch.spec.whatwg.org/#typedefdef-xmlhttprequestbodyinit
	webidl.converters.XMLHttpRequestBodyInit = function (V) {
	  if (typeof V === 'string') {
	    return webidl.converters.USVString(V)
	  }

	  if (isBlobLike(V)) {
	    return webidl.converters.Blob(V, { strict: false })
	  }

	  if (types.isArrayBuffer(V) || types.isTypedArray(V) || types.isDataView(V)) {
	    return webidl.converters.BufferSource(V)
	  }

	  if (util.isFormDataLike(V)) {
	    return webidl.converters.FormData(V, { strict: false })
	  }

	  if (V instanceof URLSearchParams) {
	    return webidl.converters.URLSearchParams(V)
	  }

	  return webidl.converters.DOMString(V)
	};

	// https://fetch.spec.whatwg.org/#bodyinit
	webidl.converters.BodyInit = function (V) {
	  if (V instanceof ReadableStream) {
	    return webidl.converters.ReadableStream(V)
	  }

	  // Note: the spec doesn't include async iterables,
	  // this is an undici extension.
	  if (V?.[Symbol.asyncIterator]) {
	    return V
	  }

	  return webidl.converters.XMLHttpRequestBodyInit(V)
	};

	webidl.converters.ResponseInit = webidl.dictionaryConverter([
	  {
	    key: 'status',
	    converter: webidl.converters['unsigned short'],
	    defaultValue: 200
	  },
	  {
	    key: 'statusText',
	    converter: webidl.converters.ByteString,
	    defaultValue: ''
	  },
	  {
	    key: 'headers',
	    converter: webidl.converters.HeadersInit
	  }
	]);

	response = {
	  makeNetworkError,
	  makeResponse,
	  makeAppropriateNetworkError,
	  filterResponse,
	  Response,
	  cloneResponse
	};
	return response;
}

/* globals AbortController */

var request;
var hasRequiredRequest;

function requireRequest () {
	if (hasRequiredRequest) return request;
	hasRequiredRequest = 1;

	const { extractBody, mixinBody, cloneBody } = requireBody();
	const { Headers, fill: fillHeaders, HeadersList } = requireHeaders();
	const { FinalizationRegistry } = requireDispatcherWeakref()();
	const util = requireUtil$6();
	const {
	  isValidHTTPToken,
	  sameOrigin,
	  normalizeMethod,
	  makePolicyContainer,
	  normalizeMethodRecord
	} = requireUtil$5();
	const {
	  forbiddenMethodsSet,
	  corsSafeListedMethodsSet,
	  referrerPolicy,
	  requestRedirect,
	  requestMode,
	  requestCredentials,
	  requestCache,
	  requestDuplex
	} = requireConstants$5();
	const { kEnumerableProperty } = util;
	const { kHeaders, kSignal, kState, kGuard, kRealm } = requireSymbols$3();
	const { webidl } = requireWebidl();
	const { getGlobalOrigin } = requireGlobal$1();
	const { URLSerializer } = requireDataURL();
	const { kHeadersList, kConstruct } = requireSymbols$4();
	const assert = require$$0$4;
	const { getMaxListeners, setMaxListeners, getEventListeners, defaultMaxListeners } = require$$0$3;

	let TransformStream = globalThis.TransformStream;

	const kAbortController = Symbol('abortController');

	const requestFinalizer = new FinalizationRegistry(({ signal, abort }) => {
	  signal.removeEventListener('abort', abort);
	});

	// https://fetch.spec.whatwg.org/#request-class
	class Request {
	  // https://fetch.spec.whatwg.org/#dom-request
	  constructor (input, init = {}) {
	    if (input === kConstruct) {
	      return
	    }

	    webidl.argumentLengthCheck(arguments, 1, { header: 'Request constructor' });

	    input = webidl.converters.RequestInfo(input);
	    init = webidl.converters.RequestInit(init);

	    // https://html.spec.whatwg.org/multipage/webappapis.html#environment-settings-object
	    this[kRealm] = {
	      settingsObject: {
	        baseUrl: getGlobalOrigin(),
	        get origin () {
	          return this.baseUrl?.origin
	        },
	        policyContainer: makePolicyContainer()
	      }
	    };

	    // 1. Let request be null.
	    let request = null;

	    // 2. Let fallbackMode be null.
	    let fallbackMode = null;

	    // 3. Let baseURL be thiss relevant settings objects API base URL.
	    const baseUrl = this[kRealm].settingsObject.baseUrl;

	    // 4. Let signal be null.
	    let signal = null;

	    // 5. If input is a string, then:
	    if (typeof input === 'string') {
	      // 1. Let parsedURL be the result of parsing input with baseURL.
	      // 2. If parsedURL is failure, then throw a TypeError.
	      let parsedURL;
	      try {
	        parsedURL = new URL(input, baseUrl);
	      } catch (err) {
	        throw new TypeError('Failed to parse URL from ' + input, { cause: err })
	      }

	      // 3. If parsedURL includes credentials, then throw a TypeError.
	      if (parsedURL.username || parsedURL.password) {
	        throw new TypeError(
	          'Request cannot be constructed from a URL that includes credentials: ' +
	            input
	        )
	      }

	      // 4. Set request to a new request whose URL is parsedURL.
	      request = makeRequest({ urlList: [parsedURL] });

	      // 5. Set fallbackMode to "cors".
	      fallbackMode = 'cors';
	    } else {
	      // 6. Otherwise:

	      // 7. Assert: input is a Request object.
	      assert(input instanceof Request);

	      // 8. Set request to inputs request.
	      request = input[kState];

	      // 9. Set signal to inputs signal.
	      signal = input[kSignal];
	    }

	    // 7. Let origin be thiss relevant settings objects origin.
	    const origin = this[kRealm].settingsObject.origin;

	    // 8. Let window be "client".
	    let window = 'client';

	    // 9. If requests window is an environment settings object and its origin
	    // is same origin with origin, then set window to requests window.
	    if (
	      request.window?.constructor?.name === 'EnvironmentSettingsObject' &&
	      sameOrigin(request.window, origin)
	    ) {
	      window = request.window;
	    }

	    // 10. If init["window"] exists and is non-null, then throw a TypeError.
	    if (init.window != null) {
	      throw new TypeError(`'window' option '${window}' must be null`)
	    }

	    // 11. If init["window"] exists, then set window to "no-window".
	    if ('window' in init) {
	      window = 'no-window';
	    }

	    // 12. Set request to a new request with the following properties:
	    request = makeRequest({
	      // URL requests URL.
	      // undici implementation note: this is set as the first item in request's urlList in makeRequest
	      // method requests method.
	      method: request.method,
	      // header list A copy of requests header list.
	      // undici implementation note: headersList is cloned in makeRequest
	      headersList: request.headersList,
	      // unsafe-request flag Set.
	      unsafeRequest: request.unsafeRequest,
	      // client Thiss relevant settings object.
	      client: this[kRealm].settingsObject,
	      // window window.
	      window,
	      // priority requests priority.
	      priority: request.priority,
	      // origin requests origin. The propagation of the origin is only significant for navigation requests
	      // being handled by a service worker. In this scenario a request can have an origin that is different
	      // from the current client.
	      origin: request.origin,
	      // referrer requests referrer.
	      referrer: request.referrer,
	      // referrer policy requests referrer policy.
	      referrerPolicy: request.referrerPolicy,
	      // mode requests mode.
	      mode: request.mode,
	      // credentials mode requests credentials mode.
	      credentials: request.credentials,
	      // cache mode requests cache mode.
	      cache: request.cache,
	      // redirect mode requests redirect mode.
	      redirect: request.redirect,
	      // integrity metadata requests integrity metadata.
	      integrity: request.integrity,
	      // keepalive requests keepalive.
	      keepalive: request.keepalive,
	      // reload-navigation flag requests reload-navigation flag.
	      reloadNavigation: request.reloadNavigation,
	      // history-navigation flag requests history-navigation flag.
	      historyNavigation: request.historyNavigation,
	      // URL list A clone of requests URL list.
	      urlList: [...request.urlList]
	    });

	    const initHasKey = Object.keys(init).length !== 0;

	    // 13. If init is not empty, then:
	    if (initHasKey) {
	      // 1. If requests mode is "navigate", then set it to "same-origin".
	      if (request.mode === 'navigate') {
	        request.mode = 'same-origin';
	      }

	      // 2. Unset requests reload-navigation flag.
	      request.reloadNavigation = false;

	      // 3. Unset requests history-navigation flag.
	      request.historyNavigation = false;

	      // 4. Set requests origin to "client".
	      request.origin = 'client';

	      // 5. Set requests referrer to "client"
	      request.referrer = 'client';

	      // 6. Set requests referrer policy to the empty string.
	      request.referrerPolicy = '';

	      // 7. Set requests URL to requests current URL.
	      request.url = request.urlList[request.urlList.length - 1];

	      // 8. Set requests URL list to  requests URL .
	      request.urlList = [request.url];
	    }

	    // 14. If init["referrer"] exists, then:
	    if (init.referrer !== undefined) {
	      // 1. Let referrer be init["referrer"].
	      const referrer = init.referrer;

	      // 2. If referrer is the empty string, then set requests referrer to "no-referrer".
	      if (referrer === '') {
	        request.referrer = 'no-referrer';
	      } else {
	        // 1. Let parsedReferrer be the result of parsing referrer with
	        // baseURL.
	        // 2. If parsedReferrer is failure, then throw a TypeError.
	        let parsedReferrer;
	        try {
	          parsedReferrer = new URL(referrer, baseUrl);
	        } catch (err) {
	          throw new TypeError(`Referrer "${referrer}" is not a valid URL.`, { cause: err })
	        }

	        // 3. If one of the following is true
	        // - parsedReferrers scheme is "about" and path is the string "client"
	        // - parsedReferrers origin is not same origin with origin
	        // then set requests referrer to "client".
	        if (
	          (parsedReferrer.protocol === 'about:' && parsedReferrer.hostname === 'client') ||
	          (origin && !sameOrigin(parsedReferrer, this[kRealm].settingsObject.baseUrl))
	        ) {
	          request.referrer = 'client';
	        } else {
	          // 4. Otherwise, set requests referrer to parsedReferrer.
	          request.referrer = parsedReferrer;
	        }
	      }
	    }

	    // 15. If init["referrerPolicy"] exists, then set requests referrer policy
	    // to it.
	    if (init.referrerPolicy !== undefined) {
	      request.referrerPolicy = init.referrerPolicy;
	    }

	    // 16. Let mode be init["mode"] if it exists, and fallbackMode otherwise.
	    let mode;
	    if (init.mode !== undefined) {
	      mode = init.mode;
	    } else {
	      mode = fallbackMode;
	    }

	    // 17. If mode is "navigate", then throw a TypeError.
	    if (mode === 'navigate') {
	      throw webidl.errors.exception({
	        header: 'Request constructor',
	        message: 'invalid request mode navigate.'
	      })
	    }

	    // 18. If mode is non-null, set requests mode to mode.
	    if (mode != null) {
	      request.mode = mode;
	    }

	    // 19. If init["credentials"] exists, then set requests credentials mode
	    // to it.
	    if (init.credentials !== undefined) {
	      request.credentials = init.credentials;
	    }

	    // 18. If init["cache"] exists, then set requests cache mode to it.
	    if (init.cache !== undefined) {
	      request.cache = init.cache;
	    }

	    // 21. If requests cache mode is "only-if-cached" and requests mode is
	    // not "same-origin", then throw a TypeError.
	    if (request.cache === 'only-if-cached' && request.mode !== 'same-origin') {
	      throw new TypeError(
	        "'only-if-cached' can be set only with 'same-origin' mode"
	      )
	    }

	    // 22. If init["redirect"] exists, then set requests redirect mode to it.
	    if (init.redirect !== undefined) {
	      request.redirect = init.redirect;
	    }

	    // 23. If init["integrity"] exists, then set requests integrity metadata to it.
	    if (init.integrity != null) {
	      request.integrity = String(init.integrity);
	    }

	    // 24. If init["keepalive"] exists, then set requests keepalive to it.
	    if (init.keepalive !== undefined) {
	      request.keepalive = Boolean(init.keepalive);
	    }

	    // 25. If init["method"] exists, then:
	    if (init.method !== undefined) {
	      // 1. Let method be init["method"].
	      let method = init.method;

	      // 2. If method is not a method or method is a forbidden method, then
	      // throw a TypeError.
	      if (!isValidHTTPToken(method)) {
	        throw new TypeError(`'${method}' is not a valid HTTP method.`)
	      }

	      if (forbiddenMethodsSet.has(method.toUpperCase())) {
	        throw new TypeError(`'${method}' HTTP method is unsupported.`)
	      }

	      // 3. Normalize method.
	      method = normalizeMethodRecord[method] ?? normalizeMethod(method);

	      // 4. Set requests method to method.
	      request.method = method;
	    }

	    // 26. If init["signal"] exists, then set signal to it.
	    if (init.signal !== undefined) {
	      signal = init.signal;
	    }

	    // 27. Set thiss request to request.
	    this[kState] = request;

	    // 28. Set thiss signal to a new AbortSignal object with thiss relevant
	    // Realm.
	    // TODO: could this be simplified with AbortSignal.any
	    // (https://dom.spec.whatwg.org/#dom-abortsignal-any)
	    const ac = new AbortController();
	    this[kSignal] = ac.signal;
	    this[kSignal][kRealm] = this[kRealm];

	    // 29. If signal is not null, then make thiss signal follow signal.
	    if (signal != null) {
	      if (
	        !signal ||
	        typeof signal.aborted !== 'boolean' ||
	        typeof signal.addEventListener !== 'function'
	      ) {
	        throw new TypeError(
	          "Failed to construct 'Request': member signal is not of type AbortSignal."
	        )
	      }

	      if (signal.aborted) {
	        ac.abort(signal.reason);
	      } else {
	        // Keep a strong ref to ac while request object
	        // is alive. This is needed to prevent AbortController
	        // from being prematurely garbage collected.
	        // See, https://github.com/nodejs/undici/issues/1926.
	        this[kAbortController] = ac;

	        const acRef = new WeakRef(ac);
	        const abort = function () {
	          const ac = acRef.deref();
	          if (ac !== undefined) {
	            ac.abort(this.reason);
	          }
	        };

	        // Third-party AbortControllers may not work with these.
	        // See, https://github.com/nodejs/undici/pull/1910#issuecomment-1464495619.
	        try {
	          // If the max amount of listeners is equal to the default, increase it
	          // This is only available in node >= v19.9.0
	          if (typeof getMaxListeners === 'function' && getMaxListeners(signal) === defaultMaxListeners) {
	            setMaxListeners(100, signal);
	          } else if (getEventListeners(signal, 'abort').length >= defaultMaxListeners) {
	            setMaxListeners(100, signal);
	          }
	        } catch {}

	        util.addAbortListener(signal, abort);
	        requestFinalizer.register(ac, { signal, abort });
	      }
	    }

	    // 30. Set thiss headers to a new Headers object with thiss relevant
	    // Realm, whose header list is requests header list and guard is
	    // "request".
	    this[kHeaders] = new Headers(kConstruct);
	    this[kHeaders][kHeadersList] = request.headersList;
	    this[kHeaders][kGuard] = 'request';
	    this[kHeaders][kRealm] = this[kRealm];

	    // 31. If thiss requests mode is "no-cors", then:
	    if (mode === 'no-cors') {
	      // 1. If thiss requests method is not a CORS-safelisted method,
	      // then throw a TypeError.
	      if (!corsSafeListedMethodsSet.has(request.method)) {
	        throw new TypeError(
	          `'${request.method} is unsupported in no-cors mode.`
	        )
	      }

	      // 2. Set thiss headerss guard to "request-no-cors".
	      this[kHeaders][kGuard] = 'request-no-cors';
	    }

	    // 32. If init is not empty, then:
	    if (initHasKey) {
	      /** @type {HeadersList} */
	      const headersList = this[kHeaders][kHeadersList];
	      // 1. Let headers be a copy of thiss headers and its associated header
	      // list.
	      // 2. If init["headers"] exists, then set headers to init["headers"].
	      const headers = init.headers !== undefined ? init.headers : new HeadersList(headersList);

	      // 3. Empty thiss headerss header list.
	      headersList.clear();

	      // 4. If headers is a Headers object, then for each header in its header
	      // list, append headers name/headers value to thiss headers.
	      if (headers instanceof HeadersList) {
	        for (const [key, val] of headers) {
	          headersList.append(key, val);
	        }
	        // Note: Copy the `set-cookie` meta-data.
	        headersList.cookies = headers.cookies;
	      } else {
	        // 5. Otherwise, fill thiss headers with headers.
	        fillHeaders(this[kHeaders], headers);
	      }
	    }

	    // 33. Let inputBody be inputs requests body if input is a Request
	    // object; otherwise null.
	    const inputBody = input instanceof Request ? input[kState].body : null;

	    // 34. If either init["body"] exists and is non-null or inputBody is
	    // non-null, and requests method is `GET` or `HEAD`, then throw a
	    // TypeError.
	    if (
	      (init.body != null || inputBody != null) &&
	      (request.method === 'GET' || request.method === 'HEAD')
	    ) {
	      throw new TypeError('Request with GET/HEAD method cannot have body.')
	    }

	    // 35. Let initBody be null.
	    let initBody = null;

	    // 36. If init["body"] exists and is non-null, then:
	    if (init.body != null) {
	      // 1. Let Content-Type be null.
	      // 2. Set initBody and Content-Type to the result of extracting
	      // init["body"], with keepalive set to requests keepalive.
	      const [extractedBody, contentType] = extractBody(
	        init.body,
	        request.keepalive
	      );
	      initBody = extractedBody;

	      // 3, If Content-Type is non-null and thiss headerss header list does
	      // not contain `Content-Type`, then append `Content-Type`/Content-Type to
	      // thiss headers.
	      if (contentType && !this[kHeaders][kHeadersList].contains('content-type')) {
	        this[kHeaders].append('content-type', contentType);
	      }
	    }

	    // 37. Let inputOrInitBody be initBody if it is non-null; otherwise
	    // inputBody.
	    const inputOrInitBody = initBody ?? inputBody;

	    // 38. If inputOrInitBody is non-null and inputOrInitBodys source is
	    // null, then:
	    if (inputOrInitBody != null && inputOrInitBody.source == null) {
	      // 1. If initBody is non-null and init["duplex"] does not exist,
	      //    then throw a TypeError.
	      if (initBody != null && init.duplex == null) {
	        throw new TypeError('RequestInit: duplex option is required when sending a body.')
	      }

	      // 2. If thiss requests mode is neither "same-origin" nor "cors",
	      // then throw a TypeError.
	      if (request.mode !== 'same-origin' && request.mode !== 'cors') {
	        throw new TypeError(
	          'If request is made from ReadableStream, mode should be "same-origin" or "cors"'
	        )
	      }

	      // 3. Set thiss requests use-CORS-preflight flag.
	      request.useCORSPreflightFlag = true;
	    }

	    // 39. Let finalBody be inputOrInitBody.
	    let finalBody = inputOrInitBody;

	    // 40. If initBody is null and inputBody is non-null, then:
	    if (initBody == null && inputBody != null) {
	      // 1. If input is unusable, then throw a TypeError.
	      if (util.isDisturbed(inputBody.stream) || inputBody.stream.locked) {
	        throw new TypeError(
	          'Cannot construct a Request with a Request object that has already been used.'
	        )
	      }

	      // 2. Set finalBody to the result of creating a proxy for inputBody.
	      if (!TransformStream) {
	        TransformStream = require$$14.TransformStream;
	      }

	      // https://streams.spec.whatwg.org/#readablestream-create-a-proxy
	      const identityTransform = new TransformStream();
	      inputBody.stream.pipeThrough(identityTransform);
	      finalBody = {
	        source: inputBody.source,
	        length: inputBody.length,
	        stream: identityTransform.readable
	      };
	    }

	    // 41. Set thiss requests body to finalBody.
	    this[kState].body = finalBody;
	  }

	  // Returns requests HTTP method, which is "GET" by default.
	  get method () {
	    webidl.brandCheck(this, Request);

	    // The method getter steps are to return thiss requests method.
	    return this[kState].method
	  }

	  // Returns the URL of request as a string.
	  get url () {
	    webidl.brandCheck(this, Request);

	    // The url getter steps are to return thiss requests URL, serialized.
	    return URLSerializer(this[kState].url)
	  }

	  // Returns a Headers object consisting of the headers associated with request.
	  // Note that headers added in the network layer by the user agent will not
	  // be accounted for in this object, e.g., the "Host" header.
	  get headers () {
	    webidl.brandCheck(this, Request);

	    // The headers getter steps are to return thiss headers.
	    return this[kHeaders]
	  }

	  // Returns the kind of resource requested by request, e.g., "document"
	  // or "script".
	  get destination () {
	    webidl.brandCheck(this, Request);

	    // The destination getter are to return thiss requests destination.
	    return this[kState].destination
	  }

	  // Returns the referrer of request. Its value can be a same-origin URL if
	  // explicitly set in init, the empty string to indicate no referrer, and
	  // "about:client" when defaulting to the globals default. This is used
	  // during fetching to determine the value of the `Referer` header of the
	  // request being made.
	  get referrer () {
	    webidl.brandCheck(this, Request);

	    // 1. If thiss requests referrer is "no-referrer", then return the
	    // empty string.
	    if (this[kState].referrer === 'no-referrer') {
	      return ''
	    }

	    // 2. If thiss requests referrer is "client", then return
	    // "about:client".
	    if (this[kState].referrer === 'client') {
	      return 'about:client'
	    }

	    // Return thiss requests referrer, serialized.
	    return this[kState].referrer.toString()
	  }

	  // Returns the referrer policy associated with request.
	  // This is used during fetching to compute the value of the requests
	  // referrer.
	  get referrerPolicy () {
	    webidl.brandCheck(this, Request);

	    // The referrerPolicy getter steps are to return thiss requests referrer policy.
	    return this[kState].referrerPolicy
	  }

	  // Returns the mode associated with request, which is a string indicating
	  // whether the request will use CORS, or will be restricted to same-origin
	  // URLs.
	  get mode () {
	    webidl.brandCheck(this, Request);

	    // The mode getter steps are to return thiss requests mode.
	    return this[kState].mode
	  }

	  // Returns the credentials mode associated with request,
	  // which is a string indicating whether credentials will be sent with the
	  // request always, never, or only when sent to a same-origin URL.
	  get credentials () {
	    // The credentials getter steps are to return thiss requests credentials mode.
	    return this[kState].credentials
	  }

	  // Returns the cache mode associated with request,
	  // which is a string indicating how the request will
	  // interact with the browsers cache when fetching.
	  get cache () {
	    webidl.brandCheck(this, Request);

	    // The cache getter steps are to return thiss requests cache mode.
	    return this[kState].cache
	  }

	  // Returns the redirect mode associated with request,
	  // which is a string indicating how redirects for the
	  // request will be handled during fetching. A request
	  // will follow redirects by default.
	  get redirect () {
	    webidl.brandCheck(this, Request);

	    // The redirect getter steps are to return thiss requests redirect mode.
	    return this[kState].redirect
	  }

	  // Returns requests subresource integrity metadata, which is a
	  // cryptographic hash of the resource being fetched. Its value
	  // consists of multiple hashes separated by whitespace. [SRI]
	  get integrity () {
	    webidl.brandCheck(this, Request);

	    // The integrity getter steps are to return thiss requests integrity
	    // metadata.
	    return this[kState].integrity
	  }

	  // Returns a boolean indicating whether or not request can outlive the
	  // global in which it was created.
	  get keepalive () {
	    webidl.brandCheck(this, Request);

	    // The keepalive getter steps are to return thiss requests keepalive.
	    return this[kState].keepalive
	  }

	  // Returns a boolean indicating whether or not request is for a reload
	  // navigation.
	  get isReloadNavigation () {
	    webidl.brandCheck(this, Request);

	    // The isReloadNavigation getter steps are to return true if thiss
	    // requests reload-navigation flag is set; otherwise false.
	    return this[kState].reloadNavigation
	  }

	  // Returns a boolean indicating whether or not request is for a history
	  // navigation (a.k.a. back-foward navigation).
	  get isHistoryNavigation () {
	    webidl.brandCheck(this, Request);

	    // The isHistoryNavigation getter steps are to return true if thiss requests
	    // history-navigation flag is set; otherwise false.
	    return this[kState].historyNavigation
	  }

	  // Returns the signal associated with request, which is an AbortSignal
	  // object indicating whether or not request has been aborted, and its
	  // abort event handler.
	  get signal () {
	    webidl.brandCheck(this, Request);

	    // The signal getter steps are to return thiss signal.
	    return this[kSignal]
	  }

	  get body () {
	    webidl.brandCheck(this, Request);

	    return this[kState].body ? this[kState].body.stream : null
	  }

	  get bodyUsed () {
	    webidl.brandCheck(this, Request);

	    return !!this[kState].body && util.isDisturbed(this[kState].body.stream)
	  }

	  get duplex () {
	    webidl.brandCheck(this, Request);

	    return 'half'
	  }

	  // Returns a clone of request.
	  clone () {
	    webidl.brandCheck(this, Request);

	    // 1. If this is unusable, then throw a TypeError.
	    if (this.bodyUsed || this.body?.locked) {
	      throw new TypeError('unusable')
	    }

	    // 2. Let clonedRequest be the result of cloning thiss request.
	    const clonedRequest = cloneRequest(this[kState]);

	    // 3. Let clonedRequestObject be the result of creating a Request object,
	    // given clonedRequest, thiss headerss guard, and thiss relevant Realm.
	    const clonedRequestObject = new Request(kConstruct);
	    clonedRequestObject[kState] = clonedRequest;
	    clonedRequestObject[kRealm] = this[kRealm];
	    clonedRequestObject[kHeaders] = new Headers(kConstruct);
	    clonedRequestObject[kHeaders][kHeadersList] = clonedRequest.headersList;
	    clonedRequestObject[kHeaders][kGuard] = this[kHeaders][kGuard];
	    clonedRequestObject[kHeaders][kRealm] = this[kHeaders][kRealm];

	    // 4. Make clonedRequestObjects signal follow thiss signal.
	    const ac = new AbortController();
	    if (this.signal.aborted) {
	      ac.abort(this.signal.reason);
	    } else {
	      util.addAbortListener(
	        this.signal,
	        () => {
	          ac.abort(this.signal.reason);
	        }
	      );
	    }
	    clonedRequestObject[kSignal] = ac.signal;

	    // 4. Return clonedRequestObject.
	    return clonedRequestObject
	  }
	}

	mixinBody(Request);

	function makeRequest (init) {
	  // https://fetch.spec.whatwg.org/#requests
	  const request = {
	    method: 'GET',
	    localURLsOnly: false,
	    unsafeRequest: false,
	    body: null,
	    client: null,
	    reservedClient: null,
	    replacesClientId: '',
	    window: 'client',
	    keepalive: false,
	    serviceWorkers: 'all',
	    initiator: '',
	    destination: '',
	    priority: null,
	    origin: 'client',
	    policyContainer: 'client',
	    referrer: 'client',
	    referrerPolicy: '',
	    mode: 'no-cors',
	    useCORSPreflightFlag: false,
	    credentials: 'same-origin',
	    useCredentials: false,
	    cache: 'default',
	    redirect: 'follow',
	    integrity: '',
	    cryptoGraphicsNonceMetadata: '',
	    parserMetadata: '',
	    reloadNavigation: false,
	    historyNavigation: false,
	    userActivation: false,
	    taintedOrigin: false,
	    redirectCount: 0,
	    responseTainting: 'basic',
	    preventNoCacheCacheControlHeaderModification: false,
	    done: false,
	    timingAllowFailed: false,
	    ...init,
	    headersList: init.headersList
	      ? new HeadersList(init.headersList)
	      : new HeadersList()
	  };
	  request.url = request.urlList[0];
	  return request
	}

	// https://fetch.spec.whatwg.org/#concept-request-clone
	function cloneRequest (request) {
	  // To clone a request request, run these steps:

	  // 1. Let newRequest be a copy of request, except for its body.
	  const newRequest = makeRequest({ ...request, body: null });

	  // 2. If requests body is non-null, set newRequests body to the
	  // result of cloning requests body.
	  if (request.body != null) {
	    newRequest.body = cloneBody(request.body);
	  }

	  // 3. Return newRequest.
	  return newRequest
	}

	Object.defineProperties(Request.prototype, {
	  method: kEnumerableProperty,
	  url: kEnumerableProperty,
	  headers: kEnumerableProperty,
	  redirect: kEnumerableProperty,
	  clone: kEnumerableProperty,
	  signal: kEnumerableProperty,
	  duplex: kEnumerableProperty,
	  destination: kEnumerableProperty,
	  body: kEnumerableProperty,
	  bodyUsed: kEnumerableProperty,
	  isHistoryNavigation: kEnumerableProperty,
	  isReloadNavigation: kEnumerableProperty,
	  keepalive: kEnumerableProperty,
	  integrity: kEnumerableProperty,
	  cache: kEnumerableProperty,
	  credentials: kEnumerableProperty,
	  attribute: kEnumerableProperty,
	  referrerPolicy: kEnumerableProperty,
	  referrer: kEnumerableProperty,
	  mode: kEnumerableProperty,
	  [Symbol.toStringTag]: {
	    value: 'Request',
	    configurable: true
	  }
	});

	webidl.converters.Request = webidl.interfaceConverter(
	  Request
	);

	// https://fetch.spec.whatwg.org/#requestinfo
	webidl.converters.RequestInfo = function (V) {
	  if (typeof V === 'string') {
	    return webidl.converters.USVString(V)
	  }

	  if (V instanceof Request) {
	    return webidl.converters.Request(V)
	  }

	  return webidl.converters.USVString(V)
	};

	webidl.converters.AbortSignal = webidl.interfaceConverter(
	  AbortSignal
	);

	// https://fetch.spec.whatwg.org/#requestinit
	webidl.converters.RequestInit = webidl.dictionaryConverter([
	  {
	    key: 'method',
	    converter: webidl.converters.ByteString
	  },
	  {
	    key: 'headers',
	    converter: webidl.converters.HeadersInit
	  },
	  {
	    key: 'body',
	    converter: webidl.nullableConverter(
	      webidl.converters.BodyInit
	    )
	  },
	  {
	    key: 'referrer',
	    converter: webidl.converters.USVString
	  },
	  {
	    key: 'referrerPolicy',
	    converter: webidl.converters.DOMString,
	    // https://w3c.github.io/webappsec-referrer-policy/#referrer-policy
	    allowedValues: referrerPolicy
	  },
	  {
	    key: 'mode',
	    converter: webidl.converters.DOMString,
	    // https://fetch.spec.whatwg.org/#concept-request-mode
	    allowedValues: requestMode
	  },
	  {
	    key: 'credentials',
	    converter: webidl.converters.DOMString,
	    // https://fetch.spec.whatwg.org/#requestcredentials
	    allowedValues: requestCredentials
	  },
	  {
	    key: 'cache',
	    converter: webidl.converters.DOMString,
	    // https://fetch.spec.whatwg.org/#requestcache
	    allowedValues: requestCache
	  },
	  {
	    key: 'redirect',
	    converter: webidl.converters.DOMString,
	    // https://fetch.spec.whatwg.org/#requestredirect
	    allowedValues: requestRedirect
	  },
	  {
	    key: 'integrity',
	    converter: webidl.converters.DOMString
	  },
	  {
	    key: 'keepalive',
	    converter: webidl.converters.boolean
	  },
	  {
	    key: 'signal',
	    converter: webidl.nullableConverter(
	      (signal) => webidl.converters.AbortSignal(
	        signal,
	        { strict: false }
	      )
	    )
	  },
	  {
	    key: 'window',
	    converter: webidl.converters.any
	  },
	  {
	    key: 'duplex',
	    converter: webidl.converters.DOMString,
	    allowedValues: requestDuplex
	  }
	]);

	request = { Request, makeRequest };
	return request;
}

var fetch_1;
var hasRequiredFetch;

function requireFetch () {
	if (hasRequiredFetch) return fetch_1;
	hasRequiredFetch = 1;

	const {
	  Response,
	  makeNetworkError,
	  makeAppropriateNetworkError,
	  filterResponse,
	  makeResponse
	} = requireResponse();
	const { Headers } = requireHeaders();
	const { Request, makeRequest } = requireRequest();
	const zlib = require$$3$1;
	const {
	  bytesMatch,
	  makePolicyContainer,
	  clonePolicyContainer,
	  requestBadPort,
	  TAOCheck,
	  appendRequestOriginHeader,
	  responseLocationURL,
	  requestCurrentURL,
	  setRequestReferrerPolicyOnRedirect,
	  tryUpgradeRequestToAPotentiallyTrustworthyURL,
	  createOpaqueTimingInfo,
	  appendFetchMetadata,
	  corsCheck,
	  crossOriginResourcePolicyCheck,
	  determineRequestsReferrer,
	  coarsenedSharedCurrentTime,
	  createDeferredPromise,
	  isBlobLike,
	  sameOrigin,
	  isCancelled,
	  isAborted,
	  isErrorLike,
	  fullyReadBody,
	  readableStreamClose,
	  isomorphicEncode,
	  urlIsLocal,
	  urlIsHttpHttpsScheme,
	  urlHasHttpsScheme
	} = requireUtil$5();
	const { kState, kHeaders, kGuard, kRealm } = requireSymbols$3();
	const assert = require$$0$4;
	const { safelyExtractBody } = requireBody();
	const {
	  redirectStatusSet,
	  nullBodyStatus,
	  safeMethodsSet,
	  requestBodyHeader,
	  subresourceSet,
	  DOMException
	} = requireConstants$5();
	const { kHeadersList } = requireSymbols$4();
	const EE = require$$0$3;
	const { Readable, pipeline } = require$$0$6;
	const { addAbortListener, isErrored, isReadable, nodeMajor, nodeMinor } = requireUtil$6();
	const { dataURLProcessor, serializeAMimeType } = requireDataURL();
	const { TransformStream } = require$$14;
	const { getGlobalDispatcher } = requireGlobal();
	const { webidl } = requireWebidl();
	const { STATUS_CODES } = require$$2;
	const GET_OR_HEAD = ['GET', 'HEAD'];

	/** @type {import('buffer').resolveObjectURL} */
	let resolveObjectURL;
	let ReadableStream = globalThis.ReadableStream;

	class Fetch extends EE {
	  constructor (dispatcher) {
	    super();

	    this.dispatcher = dispatcher;
	    this.connection = null;
	    this.dump = false;
	    this.state = 'ongoing';
	    // 2 terminated listeners get added per request,
	    // but only 1 gets removed. If there are 20 redirects,
	    // 21 listeners will be added.
	    // See https://github.com/nodejs/undici/issues/1711
	    // TODO (fix): Find and fix root cause for leaked listener.
	    this.setMaxListeners(21);
	  }

	  terminate (reason) {
	    if (this.state !== 'ongoing') {
	      return
	    }

	    this.state = 'terminated';
	    this.connection?.destroy(reason);
	    this.emit('terminated', reason);
	  }

	  // https://fetch.spec.whatwg.org/#fetch-controller-abort
	  abort (error) {
	    if (this.state !== 'ongoing') {
	      return
	    }

	    // 1. Set controllers state to "aborted".
	    this.state = 'aborted';

	    // 2. Let fallbackError be an "AbortError" DOMException.
	    // 3. Set error to fallbackError if it is not given.
	    if (!error) {
	      error = new DOMException('The operation was aborted.', 'AbortError');
	    }

	    // 4. Let serializedError be StructuredSerialize(error).
	    //    If that threw an exception, catch it, and let
	    //    serializedError be StructuredSerialize(fallbackError).

	    // 5. Set controllers serialized abort reason to serializedError.
	    this.serializedAbortReason = error;

	    this.connection?.destroy(error);
	    this.emit('terminated', error);
	  }
	}

	// https://fetch.spec.whatwg.org/#fetch-method
	function fetch (input, init = {}) {
	  webidl.argumentLengthCheck(arguments, 1, { header: 'globalThis.fetch' });

	  // 1. Let p be a new promise.
	  const p = createDeferredPromise();

	  // 2. Let requestObject be the result of invoking the initial value of
	  // Request as constructor with input and init as arguments. If this throws
	  // an exception, reject p with it and return p.
	  let requestObject;

	  try {
	    requestObject = new Request(input, init);
	  } catch (e) {
	    p.reject(e);
	    return p.promise
	  }

	  // 3. Let request be requestObjects request.
	  const request = requestObject[kState];

	  // 4. If requestObjects signals aborted flag is set, then:
	  if (requestObject.signal.aborted) {
	    // 1. Abort the fetch() call with p, request, null, and
	    //    requestObjects signals abort reason.
	    abortFetch(p, request, null, requestObject.signal.reason);

	    // 2. Return p.
	    return p.promise
	  }

	  // 5. Let globalObject be requests clients global object.
	  const globalObject = request.client.globalObject;

	  // 6. If globalObject is a ServiceWorkerGlobalScope object, then set
	  // requests service-workers mode to "none".
	  if (globalObject?.constructor?.name === 'ServiceWorkerGlobalScope') {
	    request.serviceWorkers = 'none';
	  }

	  // 7. Let responseObject be null.
	  let responseObject = null;

	  // 8. Let relevantRealm be thiss relevant Realm.
	  const relevantRealm = null;

	  // 9. Let locallyAborted be false.
	  let locallyAborted = false;

	  // 10. Let controller be null.
	  let controller = null;

	  // 11. Add the following abort steps to requestObjects signal:
	  addAbortListener(
	    requestObject.signal,
	    () => {
	      // 1. Set locallyAborted to true.
	      locallyAborted = true;

	      // 2. Assert: controller is non-null.
	      assert(controller != null);

	      // 3. Abort controller with requestObjects signals abort reason.
	      controller.abort(requestObject.signal.reason);

	      // 4. Abort the fetch() call with p, request, responseObject,
	      //    and requestObjects signals abort reason.
	      abortFetch(p, request, responseObject, requestObject.signal.reason);
	    }
	  );

	  // 12. Let handleFetchDone given response response be to finalize and
	  // report timing with response, globalObject, and "fetch".
	  const handleFetchDone = (response) =>
	    finalizeAndReportTiming(response, 'fetch');

	  // 13. Set controller to the result of calling fetch given request,
	  // with processResponseEndOfBody set to handleFetchDone, and processResponse
	  // given response being these substeps:

	  const processResponse = (response) => {
	    // 1. If locallyAborted is true, terminate these substeps.
	    if (locallyAborted) {
	      return Promise.resolve()
	    }

	    // 2. If responses aborted flag is set, then:
	    if (response.aborted) {
	      // 1. Let deserializedError be the result of deserialize a serialized
	      //    abort reason given controllers serialized abort reason and
	      //    relevantRealm.

	      // 2. Abort the fetch() call with p, request, responseObject, and
	      //    deserializedError.

	      abortFetch(p, request, responseObject, controller.serializedAbortReason);
	      return Promise.resolve()
	    }

	    // 3. If response is a network error, then reject p with a TypeError
	    // and terminate these substeps.
	    if (response.type === 'error') {
	      p.reject(
	        Object.assign(new TypeError('fetch failed'), { cause: response.error })
	      );
	      return Promise.resolve()
	    }

	    // 4. Set responseObject to the result of creating a Response object,
	    // given response, "immutable", and relevantRealm.
	    responseObject = new Response();
	    responseObject[kState] = response;
	    responseObject[kRealm] = relevantRealm;
	    responseObject[kHeaders][kHeadersList] = response.headersList;
	    responseObject[kHeaders][kGuard] = 'immutable';
	    responseObject[kHeaders][kRealm] = relevantRealm;

	    // 5. Resolve p with responseObject.
	    p.resolve(responseObject);
	  };

	  controller = fetching({
	    request,
	    processResponseEndOfBody: handleFetchDone,
	    processResponse,
	    dispatcher: init.dispatcher ?? getGlobalDispatcher() // undici
	  });

	  // 14. Return p.
	  return p.promise
	}

	// https://fetch.spec.whatwg.org/#finalize-and-report-timing
	function finalizeAndReportTiming (response, initiatorType = 'other') {
	  // 1. If response is an aborted network error, then return.
	  if (response.type === 'error' && response.aborted) {
	    return
	  }

	  // 2. If responses URL list is null or empty, then return.
	  if (!response.urlList?.length) {
	    return
	  }

	  // 3. Let originalURL be responses URL list[0].
	  const originalURL = response.urlList[0];

	  // 4. Let timingInfo be responses timing info.
	  let timingInfo = response.timingInfo;

	  // 5. Let cacheState be responses cache state.
	  let cacheState = response.cacheState;

	  // 6. If originalURLs scheme is not an HTTP(S) scheme, then return.
	  if (!urlIsHttpHttpsScheme(originalURL)) {
	    return
	  }

	  // 7. If timingInfo is null, then return.
	  if (timingInfo === null) {
	    return
	  }

	  // 8. If responses timing allow passed flag is not set, then:
	  if (!response.timingAllowPassed) {
	    //  1. Set timingInfo to a the result of creating an opaque timing info for timingInfo.
	    timingInfo = createOpaqueTimingInfo({
	      startTime: timingInfo.startTime
	    });

	    //  2. Set cacheState to the empty string.
	    cacheState = '';
	  }

	  // 9. Set timingInfos end time to the coarsened shared current time
	  // given globals relevant settings objects cross-origin isolated
	  // capability.
	  // TODO: given globals relevant settings objects cross-origin isolated
	  // capability?
	  timingInfo.endTime = coarsenedSharedCurrentTime();

	  // 10. Set responses timing info to timingInfo.
	  response.timingInfo = timingInfo;

	  // 11. Mark resource timing for timingInfo, originalURL, initiatorType,
	  // global, and cacheState.
	  markResourceTiming(
	    timingInfo,
	    originalURL,
	    initiatorType,
	    globalThis,
	    cacheState
	  );
	}

	// https://w3c.github.io/resource-timing/#dfn-mark-resource-timing
	function markResourceTiming (timingInfo, originalURL, initiatorType, globalThis, cacheState) {
	  if (nodeMajor > 18 || (nodeMajor === 18 && nodeMinor >= 2)) {
	    performance.markResourceTiming(timingInfo, originalURL.href, initiatorType, globalThis, cacheState);
	  }
	}

	// https://fetch.spec.whatwg.org/#abort-fetch
	function abortFetch (p, request, responseObject, error) {
	  // Note: AbortSignal.reason was added in node v17.2.0
	  // which would give us an undefined error to reject with.
	  // Remove this once node v16 is no longer supported.
	  if (!error) {
	    error = new DOMException('The operation was aborted.', 'AbortError');
	  }

	  // 1. Reject promise with error.
	  p.reject(error);

	  // 2. If requests body is not null and is readable, then cancel requests
	  // body with error.
	  if (request.body != null && isReadable(request.body?.stream)) {
	    request.body.stream.cancel(error).catch((err) => {
	      if (err.code === 'ERR_INVALID_STATE') {
	        // Node bug?
	        return
	      }
	      throw err
	    });
	  }

	  // 3. If responseObject is null, then return.
	  if (responseObject == null) {
	    return
	  }

	  // 4. Let response be responseObjects response.
	  const response = responseObject[kState];

	  // 5. If responses body is not null and is readable, then error responses
	  // body with error.
	  if (response.body != null && isReadable(response.body?.stream)) {
	    response.body.stream.cancel(error).catch((err) => {
	      if (err.code === 'ERR_INVALID_STATE') {
	        // Node bug?
	        return
	      }
	      throw err
	    });
	  }
	}

	// https://fetch.spec.whatwg.org/#fetching
	function fetching ({
	  request,
	  processRequestBodyChunkLength,
	  processRequestEndOfBody,
	  processResponse,
	  processResponseEndOfBody,
	  processResponseConsumeBody,
	  useParallelQueue = false,
	  dispatcher // undici
	}) {
	  // 1. Let taskDestination be null.
	  let taskDestination = null;

	  // 2. Let crossOriginIsolatedCapability be false.
	  let crossOriginIsolatedCapability = false;

	  // 3. If requests client is non-null, then:
	  if (request.client != null) {
	    // 1. Set taskDestination to requests clients global object.
	    taskDestination = request.client.globalObject;

	    // 2. Set crossOriginIsolatedCapability to requests clients cross-origin
	    // isolated capability.
	    crossOriginIsolatedCapability =
	      request.client.crossOriginIsolatedCapability;
	  }

	  // 4. If useParallelQueue is true, then set taskDestination to the result of
	  // starting a new parallel queue.
	  // TODO

	  // 5. Let timingInfo be a new fetch timing info whose start time and
	  // post-redirect start time are the coarsened shared current time given
	  // crossOriginIsolatedCapability.
	  const currenTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability);
	  const timingInfo = createOpaqueTimingInfo({
	    startTime: currenTime
	  });

	  // 6. Let fetchParams be a new fetch params whose
	  // request is request,
	  // timing info is timingInfo,
	  // process request body chunk length is processRequestBodyChunkLength,
	  // process request end-of-body is processRequestEndOfBody,
	  // process response is processResponse,
	  // process response consume body is processResponseConsumeBody,
	  // process response end-of-body is processResponseEndOfBody,
	  // task destination is taskDestination,
	  // and cross-origin isolated capability is crossOriginIsolatedCapability.
	  const fetchParams = {
	    controller: new Fetch(dispatcher),
	    request,
	    timingInfo,
	    processRequestBodyChunkLength,
	    processRequestEndOfBody,
	    processResponse,
	    processResponseConsumeBody,
	    processResponseEndOfBody,
	    taskDestination,
	    crossOriginIsolatedCapability
	  };

	  // 7. If requests body is a byte sequence, then set requests body to
	  //    requests body as a body.
	  // NOTE: Since fetching is only called from fetch, body should already be
	  // extracted.
	  assert(!request.body || request.body.stream);

	  // 8. If requests window is "client", then set requests window to requests
	  // client, if requests clients global object is a Window object; otherwise
	  // "no-window".
	  if (request.window === 'client') {
	    // TODO: What if request.client is null?
	    request.window =
	      request.client?.globalObject?.constructor?.name === 'Window'
	        ? request.client
	        : 'no-window';
	  }

	  // 9. If requests origin is "client", then set requests origin to requests
	  // clients origin.
	  if (request.origin === 'client') {
	    // TODO: What if request.client is null?
	    request.origin = request.client?.origin;
	  }

	  // 10. If all of the following conditions are true:
	  // TODO

	  // 11. If requests policy container is "client", then:
	  if (request.policyContainer === 'client') {
	    // 1. If requests client is non-null, then set requests policy
	    // container to a clone of requests clients policy container. [HTML]
	    if (request.client != null) {
	      request.policyContainer = clonePolicyContainer(
	        request.client.policyContainer
	      );
	    } else {
	      // 2. Otherwise, set requests policy container to a new policy
	      // container.
	      request.policyContainer = makePolicyContainer();
	    }
	  }

	  // 12. If requests header list does not contain `Accept`, then:
	  if (!request.headersList.contains('accept')) {
	    // 1. Let value be `*/*`.
	    const value = '*/*';

	    // 2. A user agent should set value to the first matching statement, if
	    // any, switching on requests destination:
	    // "document"
	    // "frame"
	    // "iframe"
	    // `text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8`
	    // "image"
	    // `image/png,image/svg+xml,image/*;q=0.8,*/*;q=0.5`
	    // "style"
	    // `text/css,*/*;q=0.1`
	    // TODO

	    // 3. Append `Accept`/value to requests header list.
	    request.headersList.append('accept', value);
	  }

	  // 13. If requests header list does not contain `Accept-Language`, then
	  // user agents should append `Accept-Language`/an appropriate value to
	  // requests header list.
	  if (!request.headersList.contains('accept-language')) {
	    request.headersList.append('accept-language', '*');
	  }

	  // 14. If requests priority is null, then use requests initiator and
	  // destination appropriately in setting requests priority to a
	  // user-agent-defined object.
	  if (request.priority === null) ;

	  // 15. If request is a subresource request, then:
	  if (subresourceSet.has(request.destination)) ;

	  // 16. Run main fetch given fetchParams.
	  mainFetch(fetchParams)
	    .catch(err => {
	      fetchParams.controller.terminate(err);
	    });

	  // 17. Return fetchParam's controller
	  return fetchParams.controller
	}

	// https://fetch.spec.whatwg.org/#concept-main-fetch
	async function mainFetch (fetchParams, recursive = false) {
	  // 1. Let request be fetchParamss request.
	  const request = fetchParams.request;

	  // 2. Let response be null.
	  let response = null;

	  // 3. If requests local-URLs-only flag is set and requests current URL is
	  // not local, then set response to a network error.
	  if (request.localURLsOnly && !urlIsLocal(requestCurrentURL(request))) {
	    response = makeNetworkError('local URLs only');
	  }

	  // 4. Run report Content Security Policy violations for request.
	  // TODO

	  // 5. Upgrade request to a potentially trustworthy URL, if appropriate.
	  tryUpgradeRequestToAPotentiallyTrustworthyURL(request);

	  // 6. If should request be blocked due to a bad port, should fetching request
	  // be blocked as mixed content, or should request be blocked by Content
	  // Security Policy returns blocked, then set response to a network error.
	  if (requestBadPort(request) === 'blocked') {
	    response = makeNetworkError('bad port');
	  }
	  // TODO: should fetching request be blocked as mixed content?
	  // TODO: should request be blocked by Content Security Policy?

	  // 7. If requests referrer policy is the empty string, then set requests
	  // referrer policy to requests policy containers referrer policy.
	  if (request.referrerPolicy === '') {
	    request.referrerPolicy = request.policyContainer.referrerPolicy;
	  }

	  // 8. If requests referrer is not "no-referrer", then set requests
	  // referrer to the result of invoking determine requests referrer.
	  if (request.referrer !== 'no-referrer') {
	    request.referrer = determineRequestsReferrer(request);
	  }

	  // 9. Set requests current URLs scheme to "https" if all of the following
	  // conditions are true:
	  // - requests current URLs scheme is "http"
	  // - requests current URLs host is a domain
	  // - Matching requests current URLs host per Known HSTS Host Domain Name
	  //   Matching results in either a superdomain match with an asserted
	  //   includeSubDomains directive or a congruent match (with or without an
	  //   asserted includeSubDomains directive). [HSTS]
	  // TODO

	  // 10. If recursive is false, then run the remaining steps in parallel.
	  // TODO

	  // 11. If response is null, then set response to the result of running
	  // the steps corresponding to the first matching statement:
	  if (response === null) {
	    response = await (async () => {
	      const currentURL = requestCurrentURL(request);

	      if (
	        // - requests current URLs origin is same origin with requests origin,
	        //   and requests response tainting is "basic"
	        (sameOrigin(currentURL, request.url) && request.responseTainting === 'basic') ||
	        // requests current URLs scheme is "data"
	        (currentURL.protocol === 'data:') ||
	        // - requests mode is "navigate" or "websocket"
	        (request.mode === 'navigate' || request.mode === 'websocket')
	      ) {
	        // 1. Set requests response tainting to "basic".
	        request.responseTainting = 'basic';

	        // 2. Return the result of running scheme fetch given fetchParams.
	        return await schemeFetch(fetchParams)
	      }

	      // requests mode is "same-origin"
	      if (request.mode === 'same-origin') {
	        // 1. Return a network error.
	        return makeNetworkError('request mode cannot be "same-origin"')
	      }

	      // requests mode is "no-cors"
	      if (request.mode === 'no-cors') {
	        // 1. If requests redirect mode is not "follow", then return a network
	        // error.
	        if (request.redirect !== 'follow') {
	          return makeNetworkError(
	            'redirect mode cannot be "follow" for "no-cors" request'
	          )
	        }

	        // 2. Set requests response tainting to "opaque".
	        request.responseTainting = 'opaque';

	        // 3. Return the result of running scheme fetch given fetchParams.
	        return await schemeFetch(fetchParams)
	      }

	      // requests current URLs scheme is not an HTTP(S) scheme
	      if (!urlIsHttpHttpsScheme(requestCurrentURL(request))) {
	        // Return a network error.
	        return makeNetworkError('URL scheme must be a HTTP(S) scheme')
	      }

	      // - requests use-CORS-preflight flag is set
	      // - requests unsafe-request flag is set and either requests method is
	      //   not a CORS-safelisted method or CORS-unsafe request-header names with
	      //   requests header list is not empty
	      //    1. Set requests response tainting to "cors".
	      //    2. Let corsWithPreflightResponse be the result of running HTTP fetch
	      //    given fetchParams and true.
	      //    3. If corsWithPreflightResponse is a network error, then clear cache
	      //    entries using request.
	      //    4. Return corsWithPreflightResponse.
	      // TODO

	      // Otherwise
	      //    1. Set requests response tainting to "cors".
	      request.responseTainting = 'cors';

	      //    2. Return the result of running HTTP fetch given fetchParams.
	      return await httpFetch(fetchParams)
	    })();
	  }

	  // 12. If recursive is true, then return response.
	  if (recursive) {
	    return response
	  }

	  // 13. If response is not a network error and response is not a filtered
	  // response, then:
	  if (response.status !== 0 && !response.internalResponse) {
	    // If requests response tainting is "cors", then:
	    if (request.responseTainting === 'cors') ;

	    // Set response to the following filtered response with response as its
	    // internal response, depending on requests response tainting:
	    if (request.responseTainting === 'basic') {
	      response = filterResponse(response, 'basic');
	    } else if (request.responseTainting === 'cors') {
	      response = filterResponse(response, 'cors');
	    } else if (request.responseTainting === 'opaque') {
	      response = filterResponse(response, 'opaque');
	    } else {
	      assert(false);
	    }
	  }

	  // 14. Let internalResponse be response, if response is a network error,
	  // and responses internal response otherwise.
	  let internalResponse =
	    response.status === 0 ? response : response.internalResponse;

	  // 15. If internalResponses URL list is empty, then set it to a clone of
	  // requests URL list.
	  if (internalResponse.urlList.length === 0) {
	    internalResponse.urlList.push(...request.urlList);
	  }

	  // 16. If requests timing allow failed flag is unset, then set
	  // internalResponses timing allow passed flag.
	  if (!request.timingAllowFailed) {
	    response.timingAllowPassed = true;
	  }

	  // 17. If response is not a network error and any of the following returns
	  // blocked
	  // - should internalResponse to request be blocked as mixed content
	  // - should internalResponse to request be blocked by Content Security Policy
	  // - should internalResponse to request be blocked due to its MIME type
	  // - should internalResponse to request be blocked due to nosniff
	  // TODO

	  // 18. If responses type is "opaque", internalResponses status is 206,
	  // internalResponses range-requested flag is set, and requests header
	  // list does not contain `Range`, then set response and internalResponse
	  // to a network error.
	  if (
	    response.type === 'opaque' &&
	    internalResponse.status === 206 &&
	    internalResponse.rangeRequested &&
	    !request.headers.contains('range')
	  ) {
	    response = internalResponse = makeNetworkError();
	  }

	  // 19. If response is not a network error and either requests method is
	  // `HEAD` or `CONNECT`, or internalResponses status is a null body status,
	  // set internalResponses body to null and disregard any enqueuing toward
	  // it (if any).
	  if (
	    response.status !== 0 &&
	    (request.method === 'HEAD' ||
	      request.method === 'CONNECT' ||
	      nullBodyStatus.includes(internalResponse.status))
	  ) {
	    internalResponse.body = null;
	    fetchParams.controller.dump = true;
	  }

	  // 20. If requests integrity metadata is not the empty string, then:
	  if (request.integrity) {
	    // 1. Let processBodyError be this step: run fetch finale given fetchParams
	    // and a network error.
	    const processBodyError = (reason) =>
	      fetchFinale(fetchParams, makeNetworkError(reason));

	    // 2. If requests response tainting is "opaque", or responses body is null,
	    // then run processBodyError and abort these steps.
	    if (request.responseTainting === 'opaque' || response.body == null) {
	      processBodyError(response.error);
	      return
	    }

	    // 3. Let processBody given bytes be these steps:
	    const processBody = (bytes) => {
	      // 1. If bytes do not match requests integrity metadata,
	      // then run processBodyError and abort these steps. [SRI]
	      if (!bytesMatch(bytes, request.integrity)) {
	        processBodyError('integrity mismatch');
	        return
	      }

	      // 2. Set responses body to bytes as a body.
	      response.body = safelyExtractBody(bytes)[0];

	      // 3. Run fetch finale given fetchParams and response.
	      fetchFinale(fetchParams, response);
	    };

	    // 4. Fully read responses body given processBody and processBodyError.
	    await fullyReadBody(response.body, processBody, processBodyError);
	  } else {
	    // 21. Otherwise, run fetch finale given fetchParams and response.
	    fetchFinale(fetchParams, response);
	  }
	}

	// https://fetch.spec.whatwg.org/#concept-scheme-fetch
	// given a fetch params fetchParams
	function schemeFetch (fetchParams) {
	  // Note: since the connection is destroyed on redirect, which sets fetchParams to a
	  // cancelled state, we do not want this condition to trigger *unless* there have been
	  // no redirects. See https://github.com/nodejs/undici/issues/1776
	  // 1. If fetchParams is canceled, then return the appropriate network error for fetchParams.
	  if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) {
	    return Promise.resolve(makeAppropriateNetworkError(fetchParams))
	  }

	  // 2. Let request be fetchParamss request.
	  const { request } = fetchParams;

	  const { protocol: scheme } = requestCurrentURL(request);

	  // 3. Switch on requests current URLs scheme and run the associated steps:
	  switch (scheme) {
	    case 'about:': {
	      // If requests current URLs path is the string "blank", then return a new response
	      // whose status message is `OK`, header list is  (`Content-Type`, `text/html;charset=utf-8`) ,
	      // and body is the empty byte sequence as a body.

	      // Otherwise, return a network error.
	      return Promise.resolve(makeNetworkError('about scheme is not supported'))
	    }
	    case 'blob:': {
	      if (!resolveObjectURL) {
	        resolveObjectURL = require$$7.resolveObjectURL;
	      }

	      // 1. Let blobURLEntry be requests current URLs blob URL entry.
	      const blobURLEntry = requestCurrentURL(request);

	      // https://github.com/web-platform-tests/wpt/blob/7b0ebaccc62b566a1965396e5be7bb2bc06f841f/FileAPI/url/resources/fetch-tests.js#L52-L56
	      // Buffer.resolveObjectURL does not ignore URL queries.
	      if (blobURLEntry.search.length !== 0) {
	        return Promise.resolve(makeNetworkError('NetworkError when attempting to fetch resource.'))
	      }

	      const blobURLEntryObject = resolveObjectURL(blobURLEntry.toString());

	      // 2. If requests method is not `GET`, blobURLEntry is null, or blobURLEntrys
	      //    object is not a Blob object, then return a network error.
	      if (request.method !== 'GET' || !isBlobLike(blobURLEntryObject)) {
	        return Promise.resolve(makeNetworkError('invalid method'))
	      }

	      // 3. Let bodyWithType be the result of safely extracting blobURLEntrys object.
	      const bodyWithType = safelyExtractBody(blobURLEntryObject);

	      // 4. Let body be bodyWithTypes body.
	      const body = bodyWithType[0];

	      // 5. Let length be bodys length, serialized and isomorphic encoded.
	      const length = isomorphicEncode(`${body.length}`);

	      // 6. Let type be bodyWithTypes type if it is non-null; otherwise the empty byte sequence.
	      const type = bodyWithType[1] ?? '';

	      // 7. Return a new response whose status message is `OK`, header list is
	      //     (`Content-Length`, length), (`Content-Type`, type) , and body is body.
	      const response = makeResponse({
	        statusText: 'OK',
	        headersList: [
	          ['content-length', { name: 'Content-Length', value: length }],
	          ['content-type', { name: 'Content-Type', value: type }]
	        ]
	      });

	      response.body = body;

	      return Promise.resolve(response)
	    }
	    case 'data:': {
	      // 1. Let dataURLStruct be the result of running the
	      //    data: URL processor on requests current URL.
	      const currentURL = requestCurrentURL(request);
	      const dataURLStruct = dataURLProcessor(currentURL);

	      // 2. If dataURLStruct is failure, then return a
	      //    network error.
	      if (dataURLStruct === 'failure') {
	        return Promise.resolve(makeNetworkError('failed to fetch the data URL'))
	      }

	      // 3. Let mimeType be dataURLStructs MIME type, serialized.
	      const mimeType = serializeAMimeType(dataURLStruct.mimeType);

	      // 4. Return a response whose status message is `OK`,
	      //    header list is  (`Content-Type`, mimeType) ,
	      //    and body is dataURLStructs body as a body.
	      return Promise.resolve(makeResponse({
	        statusText: 'OK',
	        headersList: [
	          ['content-type', { name: 'Content-Type', value: mimeType }]
	        ],
	        body: safelyExtractBody(dataURLStruct.body)[0]
	      }))
	    }
	    case 'file:': {
	      // For now, unfortunate as it is, file URLs are left as an exercise for the reader.
	      // When in doubt, return a network error.
	      return Promise.resolve(makeNetworkError('not implemented... yet...'))
	    }
	    case 'http:':
	    case 'https:': {
	      // Return the result of running HTTP fetch given fetchParams.

	      return httpFetch(fetchParams)
	        .catch((err) => makeNetworkError(err))
	    }
	    default: {
	      return Promise.resolve(makeNetworkError('unknown scheme'))
	    }
	  }
	}

	// https://fetch.spec.whatwg.org/#finalize-response
	function finalizeResponse (fetchParams, response) {
	  // 1. Set fetchParamss requests done flag.
	  fetchParams.request.done = true;

	  // 2, If fetchParamss process response done is not null, then queue a fetch
	  // task to run fetchParamss process response done given response, with
	  // fetchParamss task destination.
	  if (fetchParams.processResponseDone != null) {
	    queueMicrotask(() => fetchParams.processResponseDone(response));
	  }
	}

	// https://fetch.spec.whatwg.org/#fetch-finale
	function fetchFinale (fetchParams, response) {
	  // 1. If response is a network error, then:
	  if (response.type === 'error') {
	    // 1. Set responses URL list to  fetchParamss requests URL list[0] .
	    response.urlList = [fetchParams.request.urlList[0]];

	    // 2. Set responses timing info to the result of creating an opaque timing
	    // info for fetchParamss timing info.
	    response.timingInfo = createOpaqueTimingInfo({
	      startTime: fetchParams.timingInfo.startTime
	    });
	  }

	  // 2. Let processResponseEndOfBody be the following steps:
	  const processResponseEndOfBody = () => {
	    // 1. Set fetchParamss requests done flag.
	    fetchParams.request.done = true;

	    // If fetchParamss process response end-of-body is not null,
	    // then queue a fetch task to run fetchParamss process response
	    // end-of-body given response with fetchParamss task destination.
	    if (fetchParams.processResponseEndOfBody != null) {
	      queueMicrotask(() => fetchParams.processResponseEndOfBody(response));
	    }
	  };

	  // 3. If fetchParamss process response is non-null, then queue a fetch task
	  // to run fetchParamss process response given response, with fetchParamss
	  // task destination.
	  if (fetchParams.processResponse != null) {
	    queueMicrotask(() => fetchParams.processResponse(response));
	  }

	  // 4. If responses body is null, then run processResponseEndOfBody.
	  if (response.body == null) {
	    processResponseEndOfBody();
	  } else {
	  // 5. Otherwise:

	    // 1. Let transformStream be a new a TransformStream.

	    // 2. Let identityTransformAlgorithm be an algorithm which, given chunk,
	    // enqueues chunk in transformStream.
	    const identityTransformAlgorithm = (chunk, controller) => {
	      controller.enqueue(chunk);
	    };

	    // 3. Set up transformStream with transformAlgorithm set to identityTransformAlgorithm
	    // and flushAlgorithm set to processResponseEndOfBody.
	    const transformStream = new TransformStream({
	      start () {},
	      transform: identityTransformAlgorithm,
	      flush: processResponseEndOfBody
	    }, {
	      size () {
	        return 1
	      }
	    }, {
	      size () {
	        return 1
	      }
	    });

	    // 4. Set responses body to the result of piping responses body through transformStream.
	    response.body = { stream: response.body.stream.pipeThrough(transformStream) };
	  }

	  // 6. If fetchParamss process response consume body is non-null, then:
	  if (fetchParams.processResponseConsumeBody != null) {
	    // 1. Let processBody given nullOrBytes be this step: run fetchParamss
	    // process response consume body given response and nullOrBytes.
	    const processBody = (nullOrBytes) => fetchParams.processResponseConsumeBody(response, nullOrBytes);

	    // 2. Let processBodyError be this step: run fetchParamss process
	    // response consume body given response and failure.
	    const processBodyError = (failure) => fetchParams.processResponseConsumeBody(response, failure);

	    // 3. If responses body is null, then queue a fetch task to run processBody
	    // given null, with fetchParamss task destination.
	    if (response.body == null) {
	      queueMicrotask(() => processBody(null));
	    } else {
	      // 4. Otherwise, fully read responses body given processBody, processBodyError,
	      // and fetchParamss task destination.
	      return fullyReadBody(response.body, processBody, processBodyError)
	    }
	    return Promise.resolve()
	  }
	}

	// https://fetch.spec.whatwg.org/#http-fetch
	async function httpFetch (fetchParams) {
	  // 1. Let request be fetchParamss request.
	  const request = fetchParams.request;

	  // 2. Let response be null.
	  let response = null;

	  // 3. Let actualResponse be null.
	  let actualResponse = null;

	  // 4. Let timingInfo be fetchParamss timing info.
	  const timingInfo = fetchParams.timingInfo;

	  // 5. If requests service-workers mode is "all", then:
	  if (request.serviceWorkers === 'all') ;

	  // 6. If response is null, then:
	  if (response === null) {
	    // 1. If makeCORSPreflight is true and one of these conditions is true:
	    // TODO

	    // 2. If requests redirect mode is "follow", then set requests
	    // service-workers mode to "none".
	    if (request.redirect === 'follow') {
	      request.serviceWorkers = 'none';
	    }

	    // 3. Set response and actualResponse to the result of running
	    // HTTP-network-or-cache fetch given fetchParams.
	    actualResponse = response = await httpNetworkOrCacheFetch(fetchParams);

	    // 4. If requests response tainting is "cors" and a CORS check
	    // for request and response returns failure, then return a network error.
	    if (
	      request.responseTainting === 'cors' &&
	      corsCheck(request, response) === 'failure'
	    ) {
	      return makeNetworkError('cors failure')
	    }

	    // 5. If the TAO check for request and response returns failure, then set
	    // requests timing allow failed flag.
	    if (TAOCheck(request, response) === 'failure') {
	      request.timingAllowFailed = true;
	    }
	  }

	  // 7. If either requests response tainting or responses type
	  // is "opaque", and the cross-origin resource policy check with
	  // requests origin, requests client, requests destination,
	  // and actualResponse returns blocked, then return a network error.
	  if (
	    (request.responseTainting === 'opaque' || response.type === 'opaque') &&
	    crossOriginResourcePolicyCheck(
	      request.origin,
	      request.client,
	      request.destination,
	      actualResponse
	    ) === 'blocked'
	  ) {
	    return makeNetworkError('blocked')
	  }

	  // 8. If actualResponses status is a redirect status, then:
	  if (redirectStatusSet.has(actualResponse.status)) {
	    // 1. If actualResponses status is not 303, requests body is not null,
	    // and the connection uses HTTP/2, then user agents may, and are even
	    // encouraged to, transmit an RST_STREAM frame.
	    // See, https://github.com/whatwg/fetch/issues/1288
	    if (request.redirect !== 'manual') {
	      fetchParams.controller.connection.destroy();
	    }

	    // 2. Switch on requests redirect mode:
	    if (request.redirect === 'error') {
	      // Set response to a network error.
	      response = makeNetworkError('unexpected redirect');
	    } else if (request.redirect === 'manual') {
	      // Set response to an opaque-redirect filtered response whose internal
	      // response is actualResponse.
	      // NOTE(spec): On the web this would return an `opaqueredirect` response,
	      // but that doesn't make sense server side.
	      // See https://github.com/nodejs/undici/issues/1193.
	      response = actualResponse;
	    } else if (request.redirect === 'follow') {
	      // Set response to the result of running HTTP-redirect fetch given
	      // fetchParams and response.
	      response = await httpRedirectFetch(fetchParams, response);
	    } else {
	      assert(false);
	    }
	  }

	  // 9. Set responses timing info to timingInfo.
	  response.timingInfo = timingInfo;

	  // 10. Return response.
	  return response
	}

	// https://fetch.spec.whatwg.org/#http-redirect-fetch
	function httpRedirectFetch (fetchParams, response) {
	  // 1. Let request be fetchParamss request.
	  const request = fetchParams.request;

	  // 2. Let actualResponse be response, if response is not a filtered response,
	  // and responses internal response otherwise.
	  const actualResponse = response.internalResponse
	    ? response.internalResponse
	    : response;

	  // 3. Let locationURL be actualResponses location URL given requests current
	  // URLs fragment.
	  let locationURL;

	  try {
	    locationURL = responseLocationURL(
	      actualResponse,
	      requestCurrentURL(request).hash
	    );

	    // 4. If locationURL is null, then return response.
	    if (locationURL == null) {
	      return response
	    }
	  } catch (err) {
	    // 5. If locationURL is failure, then return a network error.
	    return Promise.resolve(makeNetworkError(err))
	  }

	  // 6. If locationURLs scheme is not an HTTP(S) scheme, then return a network
	  // error.
	  if (!urlIsHttpHttpsScheme(locationURL)) {
	    return Promise.resolve(makeNetworkError('URL scheme must be a HTTP(S) scheme'))
	  }

	  // 7. If requests redirect count is 20, then return a network error.
	  if (request.redirectCount === 20) {
	    return Promise.resolve(makeNetworkError('redirect count exceeded'))
	  }

	  // 8. Increase requests redirect count by 1.
	  request.redirectCount += 1;

	  // 9. If requests mode is "cors", locationURL includes credentials, and
	  // requests origin is not same origin with locationURLs origin, then return
	  //  a network error.
	  if (
	    request.mode === 'cors' &&
	    (locationURL.username || locationURL.password) &&
	    !sameOrigin(request, locationURL)
	  ) {
	    return Promise.resolve(makeNetworkError('cross origin not allowed for request mode "cors"'))
	  }

	  // 10. If requests response tainting is "cors" and locationURL includes
	  // credentials, then return a network error.
	  if (
	    request.responseTainting === 'cors' &&
	    (locationURL.username || locationURL.password)
	  ) {
	    return Promise.resolve(makeNetworkError(
	      'URL cannot contain credentials for request mode "cors"'
	    ))
	  }

	  // 11. If actualResponses status is not 303, requests body is non-null,
	  // and requests bodys source is null, then return a network error.
	  if (
	    actualResponse.status !== 303 &&
	    request.body != null &&
	    request.body.source == null
	  ) {
	    return Promise.resolve(makeNetworkError())
	  }

	  // 12. If one of the following is true
	  // - actualResponses status is 301 or 302 and requests method is `POST`
	  // - actualResponses status is 303 and requests method is not `GET` or `HEAD`
	  if (
	    ([301, 302].includes(actualResponse.status) && request.method === 'POST') ||
	    (actualResponse.status === 303 &&
	      !GET_OR_HEAD.includes(request.method))
	  ) {
	    // then:
	    // 1. Set requests method to `GET` and requests body to null.
	    request.method = 'GET';
	    request.body = null;

	    // 2. For each headerName of request-body-header name, delete headerName from
	    // requests header list.
	    for (const headerName of requestBodyHeader) {
	      request.headersList.delete(headerName);
	    }
	  }

	  // 13. If requests current URLs origin is not same origin with locationURLs
	  //     origin, then for each headerName of CORS non-wildcard request-header name,
	  //     delete headerName from requests header list.
	  if (!sameOrigin(requestCurrentURL(request), locationURL)) {
	    // https://fetch.spec.whatwg.org/#cors-non-wildcard-request-header-name
	    request.headersList.delete('authorization');

	    // https://fetch.spec.whatwg.org/#authentication-entries
	    request.headersList.delete('proxy-authorization', true);

	    // "Cookie" and "Host" are forbidden request-headers, which undici doesn't implement.
	    request.headersList.delete('cookie');
	    request.headersList.delete('host');
	  }

	  // 14. If requests body is non-null, then set requests body to the first return
	  // value of safely extracting requests bodys source.
	  if (request.body != null) {
	    assert(request.body.source != null);
	    request.body = safelyExtractBody(request.body.source)[0];
	  }

	  // 15. Let timingInfo be fetchParamss timing info.
	  const timingInfo = fetchParams.timingInfo;

	  // 16. Set timingInfos redirect end time and post-redirect start time to the
	  // coarsened shared current time given fetchParamss cross-origin isolated
	  // capability.
	  timingInfo.redirectEndTime = timingInfo.postRedirectStartTime =
	    coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);

	  // 17. If timingInfos redirect start time is 0, then set timingInfos
	  //  redirect start time to timingInfos start time.
	  if (timingInfo.redirectStartTime === 0) {
	    timingInfo.redirectStartTime = timingInfo.startTime;
	  }

	  // 18. Append locationURL to requests URL list.
	  request.urlList.push(locationURL);

	  // 19. Invoke set requests referrer policy on redirect on request and
	  // actualResponse.
	  setRequestReferrerPolicyOnRedirect(request, actualResponse);

	  // 20. Return the result of running main fetch given fetchParams and true.
	  return mainFetch(fetchParams, true)
	}

	// https://fetch.spec.whatwg.org/#http-network-or-cache-fetch
	async function httpNetworkOrCacheFetch (
	  fetchParams,
	  isAuthenticationFetch = false,
	  isNewConnectionFetch = false
	) {
	  // 1. Let request be fetchParamss request.
	  const request = fetchParams.request;

	  // 2. Let httpFetchParams be null.
	  let httpFetchParams = null;

	  // 3. Let httpRequest be null.
	  let httpRequest = null;

	  // 4. Let response be null.
	  let response = null;

	  // 8. Run these steps, but abort when the ongoing fetch is terminated:

	  //    1. If requests window is "no-window" and requests redirect mode is
	  //    "error", then set httpFetchParams to fetchParams and httpRequest to
	  //    request.
	  if (request.window === 'no-window' && request.redirect === 'error') {
	    httpFetchParams = fetchParams;
	    httpRequest = request;
	  } else {
	    // Otherwise:

	    // 1. Set httpRequest to a clone of request.
	    httpRequest = makeRequest(request);

	    // 2. Set httpFetchParams to a copy of fetchParams.
	    httpFetchParams = { ...fetchParams };

	    // 3. Set httpFetchParamss request to httpRequest.
	    httpFetchParams.request = httpRequest;
	  }

	  //    3. Let includeCredentials be true if one of
	  const includeCredentials =
	    request.credentials === 'include' ||
	    (request.credentials === 'same-origin' &&
	      request.responseTainting === 'basic');

	  //    4. Let contentLength be httpRequests bodys length, if httpRequests
	  //    body is non-null; otherwise null.
	  const contentLength = httpRequest.body ? httpRequest.body.length : null;

	  //    5. Let contentLengthHeaderValue be null.
	  let contentLengthHeaderValue = null;

	  //    6. If httpRequests body is null and httpRequests method is `POST` or
	  //    `PUT`, then set contentLengthHeaderValue to `0`.
	  if (
	    httpRequest.body == null &&
	    ['POST', 'PUT'].includes(httpRequest.method)
	  ) {
	    contentLengthHeaderValue = '0';
	  }

	  //    7. If contentLength is non-null, then set contentLengthHeaderValue to
	  //    contentLength, serialized and isomorphic encoded.
	  if (contentLength != null) {
	    contentLengthHeaderValue = isomorphicEncode(`${contentLength}`);
	  }

	  //    8. If contentLengthHeaderValue is non-null, then append
	  //    `Content-Length`/contentLengthHeaderValue to httpRequests header
	  //    list.
	  if (contentLengthHeaderValue != null) {
	    httpRequest.headersList.append('content-length', contentLengthHeaderValue);
	  }

	  //    9. If contentLengthHeaderValue is non-null, then append (`Content-Length`,
	  //    contentLengthHeaderValue) to httpRequests header list.

	  //    10. If contentLength is non-null and httpRequests keepalive is true,
	  //    then:
	  if (contentLength != null && httpRequest.keepalive) ;

	  //    11. If httpRequests referrer is a URL, then append
	  //    `Referer`/httpRequests referrer, serialized and isomorphic encoded,
	  //     to httpRequests header list.
	  if (httpRequest.referrer instanceof URL) {
	    httpRequest.headersList.append('referer', isomorphicEncode(httpRequest.referrer.href));
	  }

	  //    12. Append a request `Origin` header for httpRequest.
	  appendRequestOriginHeader(httpRequest);

	  //    13. Append the Fetch metadata headers for httpRequest. [FETCH-METADATA]
	  appendFetchMetadata(httpRequest);

	  //    14. If httpRequests header list does not contain `User-Agent`, then
	  //    user agents should append `User-Agent`/default `User-Agent` value to
	  //    httpRequests header list.
	  if (!httpRequest.headersList.contains('user-agent')) {
	    httpRequest.headersList.append('user-agent', typeof esbuildDetection === 'undefined' ? 'undici' : 'node');
	  }

	  //    15. If httpRequests cache mode is "default" and httpRequests header
	  //    list contains `If-Modified-Since`, `If-None-Match`,
	  //    `If-Unmodified-Since`, `If-Match`, or `If-Range`, then set
	  //    httpRequests cache mode to "no-store".
	  if (
	    httpRequest.cache === 'default' &&
	    (httpRequest.headersList.contains('if-modified-since') ||
	      httpRequest.headersList.contains('if-none-match') ||
	      httpRequest.headersList.contains('if-unmodified-since') ||
	      httpRequest.headersList.contains('if-match') ||
	      httpRequest.headersList.contains('if-range'))
	  ) {
	    httpRequest.cache = 'no-store';
	  }

	  //    16. If httpRequests cache mode is "no-cache", httpRequests prevent
	  //    no-cache cache-control header modification flag is unset, and
	  //    httpRequests header list does not contain `Cache-Control`, then append
	  //    `Cache-Control`/`max-age=0` to httpRequests header list.
	  if (
	    httpRequest.cache === 'no-cache' &&
	    !httpRequest.preventNoCacheCacheControlHeaderModification &&
	    !httpRequest.headersList.contains('cache-control')
	  ) {
	    httpRequest.headersList.append('cache-control', 'max-age=0');
	  }

	  //    17. If httpRequests cache mode is "no-store" or "reload", then:
	  if (httpRequest.cache === 'no-store' || httpRequest.cache === 'reload') {
	    // 1. If httpRequests header list does not contain `Pragma`, then append
	    // `Pragma`/`no-cache` to httpRequests header list.
	    if (!httpRequest.headersList.contains('pragma')) {
	      httpRequest.headersList.append('pragma', 'no-cache');
	    }

	    // 2. If httpRequests header list does not contain `Cache-Control`,
	    // then append `Cache-Control`/`no-cache` to httpRequests header list.
	    if (!httpRequest.headersList.contains('cache-control')) {
	      httpRequest.headersList.append('cache-control', 'no-cache');
	    }
	  }

	  //    18. If httpRequests header list contains `Range`, then append
	  //    `Accept-Encoding`/`identity` to httpRequests header list.
	  if (httpRequest.headersList.contains('range')) {
	    httpRequest.headersList.append('accept-encoding', 'identity');
	  }

	  //    19. Modify httpRequests header list per HTTP. Do not append a given
	  //    header if httpRequests header list contains that headers name.
	  //    TODO: https://github.com/whatwg/fetch/issues/1285#issuecomment-896560129
	  if (!httpRequest.headersList.contains('accept-encoding')) {
	    if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) {
	      httpRequest.headersList.append('accept-encoding', 'br, gzip, deflate');
	    } else {
	      httpRequest.headersList.append('accept-encoding', 'gzip, deflate');
	    }
	  }

	  httpRequest.headersList.delete('host');

	  //    21. If theres a proxy-authentication entry, use it as appropriate.
	  //    TODO: proxy-authentication

	  //    22. Set httpCache to the result of determining the HTTP cache
	  //    partition, given httpRequest.
	  //    TODO: cache

	  //    23. If httpCache is null, then set httpRequests cache mode to
	  //    "no-store".
	  {
	    httpRequest.cache = 'no-store';
	  }

	  //    24. If httpRequests cache mode is neither "no-store" nor "reload",
	  //    then:
	  if (httpRequest.mode !== 'no-store' && httpRequest.mode !== 'reload') ;

	  // 9. If aborted, then return the appropriate network error for fetchParams.
	  // TODO

	  // 10. If response is null, then:
	  if (response == null) {
	    // 1. If httpRequests cache mode is "only-if-cached", then return a
	    // network error.
	    if (httpRequest.mode === 'only-if-cached') {
	      return makeNetworkError('only if cached')
	    }

	    // 2. Let forwardResponse be the result of running HTTP-network fetch
	    // given httpFetchParams, includeCredentials, and isNewConnectionFetch.
	    const forwardResponse = await httpNetworkFetch(
	      httpFetchParams,
	      includeCredentials,
	      isNewConnectionFetch
	    );

	    // 3. If httpRequests method is unsafe and forwardResponses status is
	    // in the range 200 to 399, inclusive, invalidate appropriate stored
	    // responses in httpCache, as per the "Invalidation" chapter of HTTP
	    // Caching, and set storedResponse to null. [HTTP-CACHING]
	    if (
	      !safeMethodsSet.has(httpRequest.method) &&
	      forwardResponse.status >= 200 &&
	      forwardResponse.status <= 399
	    ) ;

	    // 5. If response is null, then:
	    if (response == null) {
	      // 1. Set response to forwardResponse.
	      response = forwardResponse;

	      // 2. Store httpRequest and forwardResponse in httpCache, as per the
	      // "Storing Responses in Caches" chapter of HTTP Caching. [HTTP-CACHING]
	      // TODO: cache
	    }
	  }

	  // 11. Set responses URL list to a clone of httpRequests URL list.
	  response.urlList = [...httpRequest.urlList];

	  // 12. If httpRequests header list contains `Range`, then set responses
	  // range-requested flag.
	  if (httpRequest.headersList.contains('range')) {
	    response.rangeRequested = true;
	  }

	  // 13. Set responses request-includes-credentials to includeCredentials.
	  response.requestIncludesCredentials = includeCredentials;

	  // 14. If responses status is 401, httpRequests response tainting is not
	  // "cors", includeCredentials is true, and requests window is an environment
	  // settings object, then:
	  // TODO

	  // 15. If responses status is 407, then:
	  if (response.status === 407) {
	    // 1. If requests window is "no-window", then return a network error.
	    if (request.window === 'no-window') {
	      return makeNetworkError()
	    }

	    // 2. ???

	    // 3. If fetchParams is canceled, then return the appropriate network error for fetchParams.
	    if (isCancelled(fetchParams)) {
	      return makeAppropriateNetworkError(fetchParams)
	    }

	    // 4. Prompt the end user as appropriate in requests window and store
	    // the result as a proxy-authentication entry. [HTTP-AUTH]
	    // TODO: Invoke some kind of callback?

	    // 5. Set response to the result of running HTTP-network-or-cache fetch given
	    // fetchParams.
	    // TODO
	    return makeNetworkError('proxy authentication required')
	  }

	  // 16. If all of the following are true
	  if (
	    // responses status is 421
	    response.status === 421 &&
	    // isNewConnectionFetch is false
	    !isNewConnectionFetch &&
	    // requests body is null, or requests body is non-null and requests bodys source is non-null
	    (request.body == null || request.body.source != null)
	  ) {
	    // then:

	    // 1. If fetchParams is canceled, then return the appropriate network error for fetchParams.
	    if (isCancelled(fetchParams)) {
	      return makeAppropriateNetworkError(fetchParams)
	    }

	    // 2. Set response to the result of running HTTP-network-or-cache
	    // fetch given fetchParams, isAuthenticationFetch, and true.

	    // TODO (spec): The spec doesn't specify this but we need to cancel
	    // the active response before we can start a new one.
	    // https://github.com/whatwg/fetch/issues/1293
	    fetchParams.controller.connection.destroy();

	    response = await httpNetworkOrCacheFetch(
	      fetchParams,
	      isAuthenticationFetch,
	      true
	    );
	  }

	  // 18. Return response.
	  return response
	}

	// https://fetch.spec.whatwg.org/#http-network-fetch
	async function httpNetworkFetch (
	  fetchParams,
	  includeCredentials = false,
	  forceNewConnection = false
	) {
	  assert(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed);

	  fetchParams.controller.connection = {
	    abort: null,
	    destroyed: false,
	    destroy (err) {
	      if (!this.destroyed) {
	        this.destroyed = true;
	        this.abort?.(err ?? new DOMException('The operation was aborted.', 'AbortError'));
	      }
	    }
	  };

	  // 1. Let request be fetchParamss request.
	  const request = fetchParams.request;

	  // 2. Let response be null.
	  let response = null;

	  // 3. Let timingInfo be fetchParamss timing info.
	  const timingInfo = fetchParams.timingInfo;

	  // 5. If httpCache is null, then set requests cache mode to "no-store".
	  {
	    request.cache = 'no-store';
	  }

	  // 8. Switch on requests mode:
	  if (request.mode === 'websocket') ;

	  // 9. Run these steps, but abort when the ongoing fetch is terminated:

	  //    1. If connection is failure, then return a network error.

	  //    2. Set timingInfos final connection timing info to the result of
	  //    calling clamp and coarsen connection timing info with connections
	  //    timing info, timingInfos post-redirect start time, and fetchParamss
	  //    cross-origin isolated capability.

	  //    3. If connection is not an HTTP/2 connection, requests body is non-null,
	  //    and requests bodys source is null, then append (`Transfer-Encoding`,
	  //    `chunked`) to requests header list.

	  //    4. Set timingInfos final network-request start time to the coarsened
	  //    shared current time given fetchParamss cross-origin isolated
	  //    capability.

	  //    5. Set response to the result of making an HTTP request over connection
	  //    using request with the following caveats:

	  //        - Follow the relevant requirements from HTTP. [HTTP] [HTTP-SEMANTICS]
	  //        [HTTP-COND] [HTTP-CACHING] [HTTP-AUTH]

	  //        - If requests body is non-null, and requests bodys source is null,
	  //        then the user agent may have a buffer of up to 64 kibibytes and store
	  //        a part of requests body in that buffer. If the user agent reads from
	  //        requests body beyond that buffers size and the user agent needs to
	  //        resend request, then instead return a network error.

	  //        - Set timingInfos final network-response start time to the coarsened
	  //        shared current time given fetchParamss cross-origin isolated capability,
	  //        immediately after the user agents HTTP parser receives the first byte
	  //        of the response (e.g., frame header bytes for HTTP/2 or response status
	  //        line for HTTP/1.x).

	  //        - Wait until all the headers are transmitted.

	  //        - Any responses whose status is in the range 100 to 199, inclusive,
	  //        and is not 101, are to be ignored, except for the purposes of setting
	  //        timingInfos final network-response start time above.

	  //    - If requests header list contains `Transfer-Encoding`/`chunked` and
	  //    response is transferred via HTTP/1.0 or older, then return a network
	  //    error.

	  //    - If the HTTP request results in a TLS client certificate dialog, then:

	  //        1. If requests window is an environment settings object, make the
	  //        dialog available in requests window.

	  //        2. Otherwise, return a network error.

	  // To transmit requests body body, run these steps:
	  let requestBody = null;
	  // 1. If body is null and fetchParamss process request end-of-body is
	  // non-null, then queue a fetch task given fetchParamss process request
	  // end-of-body and fetchParamss task destination.
	  if (request.body == null && fetchParams.processRequestEndOfBody) {
	    queueMicrotask(() => fetchParams.processRequestEndOfBody());
	  } else if (request.body != null) {
	    // 2. Otherwise, if body is non-null:

	    //    1. Let processBodyChunk given bytes be these steps:
	    const processBodyChunk = async function * (bytes) {
	      // 1. If the ongoing fetch is terminated, then abort these steps.
	      if (isCancelled(fetchParams)) {
	        return
	      }

	      // 2. Run this step in parallel: transmit bytes.
	      yield bytes;

	      // 3. If fetchParamss process request body is non-null, then run
	      // fetchParamss process request body given bytess length.
	      fetchParams.processRequestBodyChunkLength?.(bytes.byteLength);
	    };

	    // 2. Let processEndOfBody be these steps:
	    const processEndOfBody = () => {
	      // 1. If fetchParams is canceled, then abort these steps.
	      if (isCancelled(fetchParams)) {
	        return
	      }

	      // 2. If fetchParamss process request end-of-body is non-null,
	      // then run fetchParamss process request end-of-body.
	      if (fetchParams.processRequestEndOfBody) {
	        fetchParams.processRequestEndOfBody();
	      }
	    };

	    // 3. Let processBodyError given e be these steps:
	    const processBodyError = (e) => {
	      // 1. If fetchParams is canceled, then abort these steps.
	      if (isCancelled(fetchParams)) {
	        return
	      }

	      // 2. If e is an "AbortError" DOMException, then abort fetchParamss controller.
	      if (e.name === 'AbortError') {
	        fetchParams.controller.abort();
	      } else {
	        fetchParams.controller.terminate(e);
	      }
	    };

	    // 4. Incrementally read requests body given processBodyChunk, processEndOfBody,
	    // processBodyError, and fetchParamss task destination.
	    requestBody = (async function * () {
	      try {
	        for await (const bytes of request.body.stream) {
	          yield * processBodyChunk(bytes);
	        }
	        processEndOfBody();
	      } catch (err) {
	        processBodyError(err);
	      }
	    })();
	  }

	  try {
	    // socket is only provided for websockets
	    const { body, status, statusText, headersList, socket } = await dispatch({ body: requestBody });

	    if (socket) {
	      response = makeResponse({ status, statusText, headersList, socket });
	    } else {
	      const iterator = body[Symbol.asyncIterator]();
	      fetchParams.controller.next = () => iterator.next();

	      response = makeResponse({ status, statusText, headersList });
	    }
	  } catch (err) {
	    // 10. If aborted, then:
	    if (err.name === 'AbortError') {
	      // 1. If connection uses HTTP/2, then transmit an RST_STREAM frame.
	      fetchParams.controller.connection.destroy();

	      // 2. Return the appropriate network error for fetchParams.
	      return makeAppropriateNetworkError(fetchParams, err)
	    }

	    return makeNetworkError(err)
	  }

	  // 11. Let pullAlgorithm be an action that resumes the ongoing fetch
	  // if it is suspended.
	  const pullAlgorithm = () => {
	    fetchParams.controller.resume();
	  };

	  // 12. Let cancelAlgorithm be an algorithm that aborts fetchParamss
	  // controller with reason, given reason.
	  const cancelAlgorithm = (reason) => {
	    fetchParams.controller.abort(reason);
	  };

	  // 13. Let highWaterMark be a non-negative, non-NaN number, chosen by
	  // the user agent.
	  // TODO

	  // 14. Let sizeAlgorithm be an algorithm that accepts a chunk object
	  // and returns a non-negative, non-NaN, non-infinite number, chosen by the user agent.
	  // TODO

	  // 15. Let stream be a new ReadableStream.
	  // 16. Set up stream with pullAlgorithm set to pullAlgorithm,
	  // cancelAlgorithm set to cancelAlgorithm, highWaterMark set to
	  // highWaterMark, and sizeAlgorithm set to sizeAlgorithm.
	  if (!ReadableStream) {
	    ReadableStream = require$$14.ReadableStream;
	  }

	  const stream = new ReadableStream(
	    {
	      async start (controller) {
	        fetchParams.controller.controller = controller;
	      },
	      async pull (controller) {
	        await pullAlgorithm();
	      },
	      async cancel (reason) {
	        await cancelAlgorithm(reason);
	      }
	    },
	    {
	      highWaterMark: 0,
	      size () {
	        return 1
	      }
	    }
	  );

	  // 17. Run these steps, but abort when the ongoing fetch is terminated:

	  //    1. Set responses body to a new body whose stream is stream.
	  response.body = { stream };

	  //    2. If response is not a network error and requests cache mode is
	  //    not "no-store", then update response in httpCache for request.
	  //    TODO

	  //    3. If includeCredentials is true and the user agent is not configured
	  //    to block cookies for request (see section 7 of [COOKIES]), then run the
	  //    "set-cookie-string" parsing algorithm (see section 5.2 of [COOKIES]) on
	  //    the value of each header whose name is a byte-case-insensitive match for
	  //    `Set-Cookie` in responses header list, if any, and requests current URL.
	  //    TODO

	  // 18. If aborted, then:
	  // TODO

	  // 19. Run these steps in parallel:

	  //    1. Run these steps, but abort when fetchParams is canceled:
	  fetchParams.controller.on('terminated', onAborted);
	  fetchParams.controller.resume = async () => {
	    // 1. While true
	    while (true) {
	      // 1-3. See onData...

	      // 4. Set bytes to the result of handling content codings given
	      // codings and bytes.
	      let bytes;
	      let isFailure;
	      try {
	        const { done, value } = await fetchParams.controller.next();

	        if (isAborted(fetchParams)) {
	          break
	        }

	        bytes = done ? undefined : value;
	      } catch (err) {
	        if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {
	          // zlib doesn't like empty streams.
	          bytes = undefined;
	        } else {
	          bytes = err;

	          // err may be propagated from the result of calling readablestream.cancel,
	          // which might not be an error. https://github.com/nodejs/undici/issues/2009
	          isFailure = true;
	        }
	      }

	      if (bytes === undefined) {
	        // 2. Otherwise, if the bytes transmission for responses message
	        // body is done normally and stream is readable, then close
	        // stream, finalize response for fetchParams and response, and
	        // abort these in-parallel steps.
	        readableStreamClose(fetchParams.controller.controller);

	        finalizeResponse(fetchParams, response);

	        return
	      }

	      // 5. Increase timingInfos decoded body size by bytess length.
	      timingInfo.decodedBodySize += bytes?.byteLength ?? 0;

	      // 6. If bytes is failure, then terminate fetchParamss controller.
	      if (isFailure) {
	        fetchParams.controller.terminate(bytes);
	        return
	      }

	      // 7. Enqueue a Uint8Array wrapping an ArrayBuffer containing bytes
	      // into stream.
	      fetchParams.controller.controller.enqueue(new Uint8Array(bytes));

	      // 8. If stream is errored, then terminate the ongoing fetch.
	      if (isErrored(stream)) {
	        fetchParams.controller.terminate();
	        return
	      }

	      // 9. If stream doesnt need more data ask the user agent to suspend
	      // the ongoing fetch.
	      if (!fetchParams.controller.controller.desiredSize) {
	        return
	      }
	    }
	  };

	  //    2. If aborted, then:
	  function onAborted (reason) {
	    // 2. If fetchParams is aborted, then:
	    if (isAborted(fetchParams)) {
	      // 1. Set responses aborted flag.
	      response.aborted = true;

	      // 2. If stream is readable, then error stream with the result of
	      //    deserialize a serialized abort reason given fetchParamss
	      //    controllers serialized abort reason and an
	      //    implementation-defined realm.
	      if (isReadable(stream)) {
	        fetchParams.controller.controller.error(
	          fetchParams.controller.serializedAbortReason
	        );
	      }
	    } else {
	      // 3. Otherwise, if stream is readable, error stream with a TypeError.
	      if (isReadable(stream)) {
	        fetchParams.controller.controller.error(new TypeError('terminated', {
	          cause: isErrorLike(reason) ? reason : undefined
	        }));
	      }
	    }

	    // 4. If connection uses HTTP/2, then transmit an RST_STREAM frame.
	    // 5. Otherwise, the user agent should close connection unless it would be bad for performance to do so.
	    fetchParams.controller.connection.destroy();
	  }

	  // 20. Return response.
	  return response

	  async function dispatch ({ body }) {
	    const url = requestCurrentURL(request);
	    /** @type {import('../..').Agent} */
	    const agent = fetchParams.controller.dispatcher;

	    return new Promise((resolve, reject) => agent.dispatch(
	      {
	        path: url.pathname + url.search,
	        origin: url.origin,
	        method: request.method,
	        body: fetchParams.controller.dispatcher.isMockActive ? request.body && (request.body.source || request.body.stream) : body,
	        headers: request.headersList.entries,
	        maxRedirections: 0,
	        upgrade: request.mode === 'websocket' ? 'websocket' : undefined
	      },
	      {
	        body: null,
	        abort: null,

	        onConnect (abort) {
	          // TODO (fix): Do we need connection here?
	          const { connection } = fetchParams.controller;

	          if (connection.destroyed) {
	            abort(new DOMException('The operation was aborted.', 'AbortError'));
	          } else {
	            fetchParams.controller.on('terminated', abort);
	            this.abort = connection.abort = abort;
	          }
	        },

	        onHeaders (status, headersList, resume, statusText) {
	          if (status < 200) {
	            return
	          }

	          let codings = [];
	          let location = '';

	          const headers = new Headers();

	          // For H2, the headers are a plain JS object
	          // We distinguish between them and iterate accordingly
	          if (Array.isArray(headersList)) {
	            for (let n = 0; n < headersList.length; n += 2) {
	              const key = headersList[n + 0].toString('latin1');
	              const val = headersList[n + 1].toString('latin1');
	              if (key.toLowerCase() === 'content-encoding') {
	                // https://www.rfc-editor.org/rfc/rfc7231#section-3.1.2.1
	                // "All content-coding values are case-insensitive..."
	                codings = val.toLowerCase().split(',').map((x) => x.trim());
	              } else if (key.toLowerCase() === 'location') {
	                location = val;
	              }

	              headers[kHeadersList].append(key, val);
	            }
	          } else {
	            const keys = Object.keys(headersList);
	            for (const key of keys) {
	              const val = headersList[key];
	              if (key.toLowerCase() === 'content-encoding') {
	                // https://www.rfc-editor.org/rfc/rfc7231#section-3.1.2.1
	                // "All content-coding values are case-insensitive..."
	                codings = val.toLowerCase().split(',').map((x) => x.trim()).reverse();
	              } else if (key.toLowerCase() === 'location') {
	                location = val;
	              }

	              headers[kHeadersList].append(key, val);
	            }
	          }

	          this.body = new Readable({ read: resume });

	          const decoders = [];

	          const willFollow = request.redirect === 'follow' &&
	            location &&
	            redirectStatusSet.has(status);

	          // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding
	          if (request.method !== 'HEAD' && request.method !== 'CONNECT' && !nullBodyStatus.includes(status) && !willFollow) {
	            for (const coding of codings) {
	              // https://www.rfc-editor.org/rfc/rfc9112.html#section-7.2
	              if (coding === 'x-gzip' || coding === 'gzip') {
	                decoders.push(zlib.createGunzip({
	                  // Be less strict when decoding compressed responses, since sometimes
	                  // servers send slightly invalid responses that are still accepted
	                  // by common browsers.
	                  // Always using Z_SYNC_FLUSH is what cURL does.
	                  flush: zlib.constants.Z_SYNC_FLUSH,
	                  finishFlush: zlib.constants.Z_SYNC_FLUSH
	                }));
	              } else if (coding === 'deflate') {
	                decoders.push(zlib.createInflate());
	              } else if (coding === 'br') {
	                decoders.push(zlib.createBrotliDecompress());
	              } else {
	                decoders.length = 0;
	                break
	              }
	            }
	          }

	          resolve({
	            status,
	            statusText,
	            headersList: headers[kHeadersList],
	            body: decoders.length
	              ? pipeline(this.body, ...decoders, () => { })
	              : this.body.on('error', () => {})
	          });

	          return true
	        },

	        onData (chunk) {
	          if (fetchParams.controller.dump) {
	            return
	          }

	          // 1. If one or more bytes have been transmitted from responses
	          // message body, then:

	          //  1. Let bytes be the transmitted bytes.
	          const bytes = chunk;

	          //  2. Let codings be the result of extracting header list values
	          //  given `Content-Encoding` and responses header list.
	          //  See pullAlgorithm.

	          //  3. Increase timingInfos encoded body size by bytess length.
	          timingInfo.encodedBodySize += bytes.byteLength;

	          //  4. See pullAlgorithm...

	          return this.body.push(bytes)
	        },

	        onComplete () {
	          if (this.abort) {
	            fetchParams.controller.off('terminated', this.abort);
	          }

	          fetchParams.controller.ended = true;

	          this.body.push(null);
	        },

	        onError (error) {
	          if (this.abort) {
	            fetchParams.controller.off('terminated', this.abort);
	          }

	          this.body?.destroy(error);

	          fetchParams.controller.terminate(error);

	          reject(error);
	        },

	        onUpgrade (status, headersList, socket) {
	          if (status !== 101) {
	            return
	          }

	          const headers = new Headers();

	          for (let n = 0; n < headersList.length; n += 2) {
	            const key = headersList[n + 0].toString('latin1');
	            const val = headersList[n + 1].toString('latin1');

	            headers[kHeadersList].append(key, val);
	          }

	          resolve({
	            status,
	            statusText: STATUS_CODES[status],
	            headersList: headers[kHeadersList],
	            socket
	          });

	          return true
	        }
	      }
	    ))
	  }
	}

	fetch_1 = {
	  fetch,
	  Fetch,
	  fetching,
	  finalizeAndReportTiming
	};
	return fetch_1;
}

var symbols$2;
var hasRequiredSymbols$2;

function requireSymbols$2 () {
	if (hasRequiredSymbols$2) return symbols$2;
	hasRequiredSymbols$2 = 1;

	symbols$2 = {
	  kState: Symbol('FileReader state'),
	  kResult: Symbol('FileReader result'),
	  kError: Symbol('FileReader error'),
	  kLastProgressEventFired: Symbol('FileReader last progress event fired timestamp'),
	  kEvents: Symbol('FileReader events'),
	  kAborted: Symbol('FileReader aborted')
	};
	return symbols$2;
}

var progressevent;
var hasRequiredProgressevent;

function requireProgressevent () {
	if (hasRequiredProgressevent) return progressevent;
	hasRequiredProgressevent = 1;

	const { webidl } = requireWebidl();

	const kState = Symbol('ProgressEvent state');

	/**
	 * @see https://xhr.spec.whatwg.org/#progressevent
	 */
	class ProgressEvent extends Event {
	  constructor (type, eventInitDict = {}) {
	    type = webidl.converters.DOMString(type);
	    eventInitDict = webidl.converters.ProgressEventInit(eventInitDict ?? {});

	    super(type, eventInitDict);

	    this[kState] = {
	      lengthComputable: eventInitDict.lengthComputable,
	      loaded: eventInitDict.loaded,
	      total: eventInitDict.total
	    };
	  }

	  get lengthComputable () {
	    webidl.brandCheck(this, ProgressEvent);

	    return this[kState].lengthComputable
	  }

	  get loaded () {
	    webidl.brandCheck(this, ProgressEvent);

	    return this[kState].loaded
	  }

	  get total () {
	    webidl.brandCheck(this, ProgressEvent);

	    return this[kState].total
	  }
	}

	webidl.converters.ProgressEventInit = webidl.dictionaryConverter([
	  {
	    key: 'lengthComputable',
	    converter: webidl.converters.boolean,
	    defaultValue: false
	  },
	  {
	    key: 'loaded',
	    converter: webidl.converters['unsigned long long'],
	    defaultValue: 0
	  },
	  {
	    key: 'total',
	    converter: webidl.converters['unsigned long long'],
	    defaultValue: 0
	  },
	  {
	    key: 'bubbles',
	    converter: webidl.converters.boolean,
	    defaultValue: false
	  },
	  {
	    key: 'cancelable',
	    converter: webidl.converters.boolean,
	    defaultValue: false
	  },
	  {
	    key: 'composed',
	    converter: webidl.converters.boolean,
	    defaultValue: false
	  }
	]);

	progressevent = {
	  ProgressEvent
	};
	return progressevent;
}

var encoding;
var hasRequiredEncoding;

function requireEncoding () {
	if (hasRequiredEncoding) return encoding;
	hasRequiredEncoding = 1;

	/**
	 * @see https://encoding.spec.whatwg.org/#concept-encoding-get
	 * @param {string|undefined} label
	 */
	function getEncoding (label) {
	  if (!label) {
	    return 'failure'
	  }

	  // 1. Remove any leading and trailing ASCII whitespace from label.
	  // 2. If label is an ASCII case-insensitive match for any of the
	  //    labels listed in the table below, then return the
	  //    corresponding encoding; otherwise return failure.
	  switch (label.trim().toLowerCase()) {
	    case 'unicode-1-1-utf-8':
	    case 'unicode11utf8':
	    case 'unicode20utf8':
	    case 'utf-8':
	    case 'utf8':
	    case 'x-unicode20utf8':
	      return 'UTF-8'
	    case '866':
	    case 'cp866':
	    case 'csibm866':
	    case 'ibm866':
	      return 'IBM866'
	    case 'csisolatin2':
	    case 'iso-8859-2':
	    case 'iso-ir-101':
	    case 'iso8859-2':
	    case 'iso88592':
	    case 'iso_8859-2':
	    case 'iso_8859-2:1987':
	    case 'l2':
	    case 'latin2':
	      return 'ISO-8859-2'
	    case 'csisolatin3':
	    case 'iso-8859-3':
	    case 'iso-ir-109':
	    case 'iso8859-3':
	    case 'iso88593':
	    case 'iso_8859-3':
	    case 'iso_8859-3:1988':
	    case 'l3':
	    case 'latin3':
	      return 'ISO-8859-3'
	    case 'csisolatin4':
	    case 'iso-8859-4':
	    case 'iso-ir-110':
	    case 'iso8859-4':
	    case 'iso88594':
	    case 'iso_8859-4':
	    case 'iso_8859-4:1988':
	    case 'l4':
	    case 'latin4':
	      return 'ISO-8859-4'
	    case 'csisolatincyrillic':
	    case 'cyrillic':
	    case 'iso-8859-5':
	    case 'iso-ir-144':
	    case 'iso8859-5':
	    case 'iso88595':
	    case 'iso_8859-5':
	    case 'iso_8859-5:1988':
	      return 'ISO-8859-5'
	    case 'arabic':
	    case 'asmo-708':
	    case 'csiso88596e':
	    case 'csiso88596i':
	    case 'csisolatinarabic':
	    case 'ecma-114':
	    case 'iso-8859-6':
	    case 'iso-8859-6-e':
	    case 'iso-8859-6-i':
	    case 'iso-ir-127':
	    case 'iso8859-6':
	    case 'iso88596':
	    case 'iso_8859-6':
	    case 'iso_8859-6:1987':
	      return 'ISO-8859-6'
	    case 'csisolatingreek':
	    case 'ecma-118':
	    case 'elot_928':
	    case 'greek':
	    case 'greek8':
	    case 'iso-8859-7':
	    case 'iso-ir-126':
	    case 'iso8859-7':
	    case 'iso88597':
	    case 'iso_8859-7':
	    case 'iso_8859-7:1987':
	    case 'sun_eu_greek':
	      return 'ISO-8859-7'
	    case 'csiso88598e':
	    case 'csisolatinhebrew':
	    case 'hebrew':
	    case 'iso-8859-8':
	    case 'iso-8859-8-e':
	    case 'iso-ir-138':
	    case 'iso8859-8':
	    case 'iso88598':
	    case 'iso_8859-8':
	    case 'iso_8859-8:1988':
	    case 'visual':
	      return 'ISO-8859-8'
	    case 'csiso88598i':
	    case 'iso-8859-8-i':
	    case 'logical':
	      return 'ISO-8859-8-I'
	    case 'csisolatin6':
	    case 'iso-8859-10':
	    case 'iso-ir-157':
	    case 'iso8859-10':
	    case 'iso885910':
	    case 'l6':
	    case 'latin6':
	      return 'ISO-8859-10'
	    case 'iso-8859-13':
	    case 'iso8859-13':
	    case 'iso885913':
	      return 'ISO-8859-13'
	    case 'iso-8859-14':
	    case 'iso8859-14':
	    case 'iso885914':
	      return 'ISO-8859-14'
	    case 'csisolatin9':
	    case 'iso-8859-15':
	    case 'iso8859-15':
	    case 'iso885915':
	    case 'iso_8859-15':
	    case 'l9':
	      return 'ISO-8859-15'
	    case 'iso-8859-16':
	      return 'ISO-8859-16'
	    case 'cskoi8r':
	    case 'koi':
	    case 'koi8':
	    case 'koi8-r':
	    case 'koi8_r':
	      return 'KOI8-R'
	    case 'koi8-ru':
	    case 'koi8-u':
	      return 'KOI8-U'
	    case 'csmacintosh':
	    case 'mac':
	    case 'macintosh':
	    case 'x-mac-roman':
	      return 'macintosh'
	    case 'iso-8859-11':
	    case 'iso8859-11':
	    case 'iso885911':
	    case 'tis-620':
	    case 'windows-874':
	      return 'windows-874'
	    case 'cp1250':
	    case 'windows-1250':
	    case 'x-cp1250':
	      return 'windows-1250'
	    case 'cp1251':
	    case 'windows-1251':
	    case 'x-cp1251':
	      return 'windows-1251'
	    case 'ansi_x3.4-1968':
	    case 'ascii':
	    case 'cp1252':
	    case 'cp819':
	    case 'csisolatin1':
	    case 'ibm819':
	    case 'iso-8859-1':
	    case 'iso-ir-100':
	    case 'iso8859-1':
	    case 'iso88591':
	    case 'iso_8859-1':
	    case 'iso_8859-1:1987':
	    case 'l1':
	    case 'latin1':
	    case 'us-ascii':
	    case 'windows-1252':
	    case 'x-cp1252':
	      return 'windows-1252'
	    case 'cp1253':
	    case 'windows-1253':
	    case 'x-cp1253':
	      return 'windows-1253'
	    case 'cp1254':
	    case 'csisolatin5':
	    case 'iso-8859-9':
	    case 'iso-ir-148':
	    case 'iso8859-9':
	    case 'iso88599':
	    case 'iso_8859-9':
	    case 'iso_8859-9:1989':
	    case 'l5':
	    case 'latin5':
	    case 'windows-1254':
	    case 'x-cp1254':
	      return 'windows-1254'
	    case 'cp1255':
	    case 'windows-1255':
	    case 'x-cp1255':
	      return 'windows-1255'
	    case 'cp1256':
	    case 'windows-1256':
	    case 'x-cp1256':
	      return 'windows-1256'
	    case 'cp1257':
	    case 'windows-1257':
	    case 'x-cp1257':
	      return 'windows-1257'
	    case 'cp1258':
	    case 'windows-1258':
	    case 'x-cp1258':
	      return 'windows-1258'
	    case 'x-mac-cyrillic':
	    case 'x-mac-ukrainian':
	      return 'x-mac-cyrillic'
	    case 'chinese':
	    case 'csgb2312':
	    case 'csiso58gb231280':
	    case 'gb2312':
	    case 'gb_2312':
	    case 'gb_2312-80':
	    case 'gbk':
	    case 'iso-ir-58':
	    case 'x-gbk':
	      return 'GBK'
	    case 'gb18030':
	      return 'gb18030'
	    case 'big5':
	    case 'big5-hkscs':
	    case 'cn-big5':
	    case 'csbig5':
	    case 'x-x-big5':
	      return 'Big5'
	    case 'cseucpkdfmtjapanese':
	    case 'euc-jp':
	    case 'x-euc-jp':
	      return 'EUC-JP'
	    case 'csiso2022jp':
	    case 'iso-2022-jp':
	      return 'ISO-2022-JP'
	    case 'csshiftjis':
	    case 'ms932':
	    case 'ms_kanji':
	    case 'shift-jis':
	    case 'shift_jis':
	    case 'sjis':
	    case 'windows-31j':
	    case 'x-sjis':
	      return 'Shift_JIS'
	    case 'cseuckr':
	    case 'csksc56011987':
	    case 'euc-kr':
	    case 'iso-ir-149':
	    case 'korean':
	    case 'ks_c_5601-1987':
	    case 'ks_c_5601-1989':
	    case 'ksc5601':
	    case 'ksc_5601':
	    case 'windows-949':
	      return 'EUC-KR'
	    case 'csiso2022kr':
	    case 'hz-gb-2312':
	    case 'iso-2022-cn':
	    case 'iso-2022-cn-ext':
	    case 'iso-2022-kr':
	    case 'replacement':
	      return 'replacement'
	    case 'unicodefffe':
	    case 'utf-16be':
	      return 'UTF-16BE'
	    case 'csunicode':
	    case 'iso-10646-ucs-2':
	    case 'ucs-2':
	    case 'unicode':
	    case 'unicodefeff':
	    case 'utf-16':
	    case 'utf-16le':
	      return 'UTF-16LE'
	    case 'x-user-defined':
	      return 'x-user-defined'
	    default: return 'failure'
	  }
	}

	encoding = {
	  getEncoding
	};
	return encoding;
}

var util$3;
var hasRequiredUtil$3;

function requireUtil$3 () {
	if (hasRequiredUtil$3) return util$3;
	hasRequiredUtil$3 = 1;

	const {
	  kState,
	  kError,
	  kResult,
	  kAborted,
	  kLastProgressEventFired
	} = requireSymbols$2();
	const { ProgressEvent } = requireProgressevent();
	const { getEncoding } = requireEncoding();
	const { DOMException } = requireConstants$5();
	const { serializeAMimeType, parseMIMEType } = requireDataURL();
	const { types } = require$$0$2;
	const { StringDecoder } = require$$6;
	const { btoa } = require$$7;

	/** @type {PropertyDescriptor} */
	const staticPropertyDescriptors = {
	  enumerable: true,
	  writable: false,
	  configurable: false
	};

	/**
	 * @see https://w3c.github.io/FileAPI/#readOperation
	 * @param {import('./filereader').FileReader} fr
	 * @param {import('buffer').Blob} blob
	 * @param {string} type
	 * @param {string?} encodingName
	 */
	function readOperation (fr, blob, type, encodingName) {
	  // 1. If frs state is "loading", throw an InvalidStateError
	  //    DOMException.
	  if (fr[kState] === 'loading') {
	    throw new DOMException('Invalid state', 'InvalidStateError')
	  }

	  // 2. Set frs state to "loading".
	  fr[kState] = 'loading';

	  // 3. Set frs result to null.
	  fr[kResult] = null;

	  // 4. Set frs error to null.
	  fr[kError] = null;

	  // 5. Let stream be the result of calling get stream on blob.
	  /** @type {import('stream/web').ReadableStream} */
	  const stream = blob.stream();

	  // 6. Let reader be the result of getting a reader from stream.
	  const reader = stream.getReader();

	  // 7. Let bytes be an empty byte sequence.
	  /** @type {Uint8Array[]} */
	  const bytes = [];

	  // 8. Let chunkPromise be the result of reading a chunk from
	  //    stream with reader.
	  let chunkPromise = reader.read();

	  // 9. Let isFirstChunk be true.
	  let isFirstChunk = true

	  // 10. In parallel, while true:
	  // Note: "In parallel" just means non-blocking
	  // Note 2: readOperation itself cannot be async as double
	  // reading the body would then reject the promise, instead
	  // of throwing an error.
	  ;(async () => {
	    while (!fr[kAborted]) {
	      // 1. Wait for chunkPromise to be fulfilled or rejected.
	      try {
	        const { done, value } = await chunkPromise;

	        // 2. If chunkPromise is fulfilled, and isFirstChunk is
	        //    true, queue a task to fire a progress event called
	        //    loadstart at fr.
	        if (isFirstChunk && !fr[kAborted]) {
	          queueMicrotask(() => {
	            fireAProgressEvent('loadstart', fr);
	          });
	        }

	        // 3. Set isFirstChunk to false.
	        isFirstChunk = false;

	        // 4. If chunkPromise is fulfilled with an object whose
	        //    done property is false and whose value property is
	        //    a Uint8Array object, run these steps:
	        if (!done && types.isUint8Array(value)) {
	          // 1. Let bs be the byte sequence represented by the
	          //    Uint8Array object.

	          // 2. Append bs to bytes.
	          bytes.push(value);

	          // 3. If roughly 50ms have passed since these steps
	          //    were last invoked, queue a task to fire a
	          //    progress event called progress at fr.
	          if (
	            (
	              fr[kLastProgressEventFired] === undefined ||
	              Date.now() - fr[kLastProgressEventFired] >= 50
	            ) &&
	            !fr[kAborted]
	          ) {
	            fr[kLastProgressEventFired] = Date.now();
	            queueMicrotask(() => {
	              fireAProgressEvent('progress', fr);
	            });
	          }

	          // 4. Set chunkPromise to the result of reading a
	          //    chunk from stream with reader.
	          chunkPromise = reader.read();
	        } else if (done) {
	          // 5. Otherwise, if chunkPromise is fulfilled with an
	          //    object whose done property is true, queue a task
	          //    to run the following steps and abort this algorithm:
	          queueMicrotask(() => {
	            // 1. Set frs state to "done".
	            fr[kState] = 'done';

	            // 2. Let result be the result of package data given
	            //    bytes, type, blobs type, and encodingName.
	            try {
	              const result = packageData(bytes, type, blob.type, encodingName);

	              // 4. Else:

	              if (fr[kAborted]) {
	                return
	              }

	              // 1. Set frs result to result.
	              fr[kResult] = result;

	              // 2. Fire a progress event called load at the fr.
	              fireAProgressEvent('load', fr);
	            } catch (error) {
	              // 3. If package data threw an exception error:

	              // 1. Set frs error to error.
	              fr[kError] = error;

	              // 2. Fire a progress event called error at fr.
	              fireAProgressEvent('error', fr);
	            }

	            // 5. If frs state is not "loading", fire a progress
	            //    event called loadend at the fr.
	            if (fr[kState] !== 'loading') {
	              fireAProgressEvent('loadend', fr);
	            }
	          });

	          break
	        }
	      } catch (error) {
	        if (fr[kAborted]) {
	          return
	        }

	        // 6. Otherwise, if chunkPromise is rejected with an
	        //    error error, queue a task to run the following
	        //    steps and abort this algorithm:
	        queueMicrotask(() => {
	          // 1. Set frs state to "done".
	          fr[kState] = 'done';

	          // 2. Set frs error to error.
	          fr[kError] = error;

	          // 3. Fire a progress event called error at fr.
	          fireAProgressEvent('error', fr);

	          // 4. If frs state is not "loading", fire a progress
	          //    event called loadend at fr.
	          if (fr[kState] !== 'loading') {
	            fireAProgressEvent('loadend', fr);
	          }
	        });

	        break
	      }
	    }
	  })();
	}

	/**
	 * @see https://w3c.github.io/FileAPI/#fire-a-progress-event
	 * @see https://dom.spec.whatwg.org/#concept-event-fire
	 * @param {string} e The name of the event
	 * @param {import('./filereader').FileReader} reader
	 */
	function fireAProgressEvent (e, reader) {
	  // The progress event e does not bubble. e.bubbles must be false
	  // The progress event e is NOT cancelable. e.cancelable must be false
	  const event = new ProgressEvent(e, {
	    bubbles: false,
	    cancelable: false
	  });

	  reader.dispatchEvent(event);
	}

	/**
	 * @see https://w3c.github.io/FileAPI/#blob-package-data
	 * @param {Uint8Array[]} bytes
	 * @param {string} type
	 * @param {string?} mimeType
	 * @param {string?} encodingName
	 */
	function packageData (bytes, type, mimeType, encodingName) {
	  // 1. A Blob has an associated package data algorithm, given
	  //    bytes, a type, a optional mimeType, and a optional
	  //    encodingName, which switches on type and runs the
	  //    associated steps:

	  switch (type) {
	    case 'DataURL': {
	      // 1. Return bytes as a DataURL [RFC2397] subject to
	      //    the considerations below:
	      //  * Use mimeType as part of the Data URL if it is
	      //    available in keeping with the Data URL
	      //    specification [RFC2397].
	      //  * If mimeType is not available return a Data URL
	      //    without a media-type. [RFC2397].

	      // https://datatracker.ietf.org/doc/html/rfc2397#section-3
	      // dataurl    := "data:" [ mediatype ] [ ";base64" ] "," data
	      // mediatype  := [ type "/" subtype ] *( ";" parameter )
	      // data       := *urlchar
	      // parameter  := attribute "=" value
	      let dataURL = 'data:';

	      const parsed = parseMIMEType(mimeType || 'application/octet-stream');

	      if (parsed !== 'failure') {
	        dataURL += serializeAMimeType(parsed);
	      }

	      dataURL += ';base64,';

	      const decoder = new StringDecoder('latin1');

	      for (const chunk of bytes) {
	        dataURL += btoa(decoder.write(chunk));
	      }

	      dataURL += btoa(decoder.end());

	      return dataURL
	    }
	    case 'Text': {
	      // 1. Let encoding be failure
	      let encoding = 'failure';

	      // 2. If the encodingName is present, set encoding to the
	      //    result of getting an encoding from encodingName.
	      if (encodingName) {
	        encoding = getEncoding(encodingName);
	      }

	      // 3. If encoding is failure, and mimeType is present:
	      if (encoding === 'failure' && mimeType) {
	        // 1. Let type be the result of parse a MIME type
	        //    given mimeType.
	        const type = parseMIMEType(mimeType);

	        // 2. If type is not failure, set encoding to the result
	        //    of getting an encoding from types parameters["charset"].
	        if (type !== 'failure') {
	          encoding = getEncoding(type.parameters.get('charset'));
	        }
	      }

	      // 4. If encoding is failure, then set encoding to UTF-8.
	      if (encoding === 'failure') {
	        encoding = 'UTF-8';
	      }

	      // 5. Decode bytes using fallback encoding encoding, and
	      //    return the result.
	      return decode(bytes, encoding)
	    }
	    case 'ArrayBuffer': {
	      // Return a new ArrayBuffer whose contents are bytes.
	      const sequence = combineByteSequences(bytes);

	      return sequence.buffer
	    }
	    case 'BinaryString': {
	      // Return bytes as a binary string, in which every byte
	      //  is represented by a code unit of equal value [0..255].
	      let binaryString = '';

	      const decoder = new StringDecoder('latin1');

	      for (const chunk of bytes) {
	        binaryString += decoder.write(chunk);
	      }

	      binaryString += decoder.end();

	      return binaryString
	    }
	  }
	}

	/**
	 * @see https://encoding.spec.whatwg.org/#decode
	 * @param {Uint8Array[]} ioQueue
	 * @param {string} encoding
	 */
	function decode (ioQueue, encoding) {
	  const bytes = combineByteSequences(ioQueue);

	  // 1. Let BOMEncoding be the result of BOM sniffing ioQueue.
	  const BOMEncoding = BOMSniffing(bytes);

	  let slice = 0;

	  // 2. If BOMEncoding is non-null:
	  if (BOMEncoding !== null) {
	    // 1. Set encoding to BOMEncoding.
	    encoding = BOMEncoding;

	    // 2. Read three bytes from ioQueue, if BOMEncoding is
	    //    UTF-8; otherwise read two bytes.
	    //    (Do nothing with those bytes.)
	    slice = BOMEncoding === 'UTF-8' ? 3 : 2;
	  }

	  // 3. Process a queue with an instance of encodings
	  //    decoder, ioQueue, output, and "replacement".

	  // 4. Return output.

	  const sliced = bytes.slice(slice);
	  return new TextDecoder(encoding).decode(sliced)
	}

	/**
	 * @see https://encoding.spec.whatwg.org/#bom-sniff
	 * @param {Uint8Array} ioQueue
	 */
	function BOMSniffing (ioQueue) {
	  // 1. Let BOM be the result of peeking 3 bytes from ioQueue,
	  //    converted to a byte sequence.
	  const [a, b, c] = ioQueue;

	  // 2. For each of the rows in the table below, starting with
	  //    the first one and going down, if BOM starts with the
	  //    bytes given in the first column, then return the
	  //    encoding given in the cell in the second column of that
	  //    row. Otherwise, return null.
	  if (a === 0xEF && b === 0xBB && c === 0xBF) {
	    return 'UTF-8'
	  } else if (a === 0xFE && b === 0xFF) {
	    return 'UTF-16BE'
	  } else if (a === 0xFF && b === 0xFE) {
	    return 'UTF-16LE'
	  }

	  return null
	}

	/**
	 * @param {Uint8Array[]} sequences
	 */
	function combineByteSequences (sequences) {
	  const size = sequences.reduce((a, b) => {
	    return a + b.byteLength
	  }, 0);

	  let offset = 0;

	  return sequences.reduce((a, b) => {
	    a.set(b, offset);
	    offset += b.byteLength;
	    return a
	  }, new Uint8Array(size))
	}

	util$3 = {
	  staticPropertyDescriptors,
	  readOperation,
	  fireAProgressEvent
	};
	return util$3;
}

var filereader;
var hasRequiredFilereader;

function requireFilereader () {
	if (hasRequiredFilereader) return filereader;
	hasRequiredFilereader = 1;

	const {
	  staticPropertyDescriptors,
	  readOperation,
	  fireAProgressEvent
	} = requireUtil$3();
	const {
	  kState,
	  kError,
	  kResult,
	  kEvents,
	  kAborted
	} = requireSymbols$2();
	const { webidl } = requireWebidl();
	const { kEnumerableProperty } = requireUtil$6();

	class FileReader extends EventTarget {
	  constructor () {
	    super();

	    this[kState] = 'empty';
	    this[kResult] = null;
	    this[kError] = null;
	    this[kEvents] = {
	      loadend: null,
	      error: null,
	      abort: null,
	      load: null,
	      progress: null,
	      loadstart: null
	    };
	  }

	  /**
	   * @see https://w3c.github.io/FileAPI/#dfn-readAsArrayBuffer
	   * @param {import('buffer').Blob} blob
	   */
	  readAsArrayBuffer (blob) {
	    webidl.brandCheck(this, FileReader);

	    webidl.argumentLengthCheck(arguments, 1, { header: 'FileReader.readAsArrayBuffer' });

	    blob = webidl.converters.Blob(blob, { strict: false });

	    // The readAsArrayBuffer(blob) method, when invoked,
	    // must initiate a read operation for blob with ArrayBuffer.
	    readOperation(this, blob, 'ArrayBuffer');
	  }

	  /**
	   * @see https://w3c.github.io/FileAPI/#readAsBinaryString
	   * @param {import('buffer').Blob} blob
	   */
	  readAsBinaryString (blob) {
	    webidl.brandCheck(this, FileReader);

	    webidl.argumentLengthCheck(arguments, 1, { header: 'FileReader.readAsBinaryString' });

	    blob = webidl.converters.Blob(blob, { strict: false });

	    // The readAsBinaryString(blob) method, when invoked,
	    // must initiate a read operation for blob with BinaryString.
	    readOperation(this, blob, 'BinaryString');
	  }

	  /**
	   * @see https://w3c.github.io/FileAPI/#readAsDataText
	   * @param {import('buffer').Blob} blob
	   * @param {string?} encoding
	   */
	  readAsText (blob, encoding = undefined) {
	    webidl.brandCheck(this, FileReader);

	    webidl.argumentLengthCheck(arguments, 1, { header: 'FileReader.readAsText' });

	    blob = webidl.converters.Blob(blob, { strict: false });

	    if (encoding !== undefined) {
	      encoding = webidl.converters.DOMString(encoding);
	    }

	    // The readAsText(blob, encoding) method, when invoked,
	    // must initiate a read operation for blob with Text and encoding.
	    readOperation(this, blob, 'Text', encoding);
	  }

	  /**
	   * @see https://w3c.github.io/FileAPI/#dfn-readAsDataURL
	   * @param {import('buffer').Blob} blob
	   */
	  readAsDataURL (blob) {
	    webidl.brandCheck(this, FileReader);

	    webidl.argumentLengthCheck(arguments, 1, { header: 'FileReader.readAsDataURL' });

	    blob = webidl.converters.Blob(blob, { strict: false });

	    // The readAsDataURL(blob) method, when invoked, must
	    // initiate a read operation for blob with DataURL.
	    readOperation(this, blob, 'DataURL');
	  }

	  /**
	   * @see https://w3c.github.io/FileAPI/#dfn-abort
	   */
	  abort () {
	    // 1. If this's state is "empty" or if this's state is
	    //    "done" set this's result to null and terminate
	    //    this algorithm.
	    if (this[kState] === 'empty' || this[kState] === 'done') {
	      this[kResult] = null;
	      return
	    }

	    // 2. If this's state is "loading" set this's state to
	    //    "done" and set this's result to null.
	    if (this[kState] === 'loading') {
	      this[kState] = 'done';
	      this[kResult] = null;
	    }

	    // 3. If there are any tasks from this on the file reading
	    //    task source in an affiliated task queue, then remove
	    //    those tasks from that task queue.
	    this[kAborted] = true;

	    // 4. Terminate the algorithm for the read method being processed.
	    // TODO

	    // 5. Fire a progress event called abort at this.
	    fireAProgressEvent('abort', this);

	    // 6. If this's state is not "loading", fire a progress
	    //    event called loadend at this.
	    if (this[kState] !== 'loading') {
	      fireAProgressEvent('loadend', this);
	    }
	  }

	  /**
	   * @see https://w3c.github.io/FileAPI/#dom-filereader-readystate
	   */
	  get readyState () {
	    webidl.brandCheck(this, FileReader);

	    switch (this[kState]) {
	      case 'empty': return this.EMPTY
	      case 'loading': return this.LOADING
	      case 'done': return this.DONE
	    }
	  }

	  /**
	   * @see https://w3c.github.io/FileAPI/#dom-filereader-result
	   */
	  get result () {
	    webidl.brandCheck(this, FileReader);

	    // The result attributes getter, when invoked, must return
	    // this's result.
	    return this[kResult]
	  }

	  /**
	   * @see https://w3c.github.io/FileAPI/#dom-filereader-error
	   */
	  get error () {
	    webidl.brandCheck(this, FileReader);

	    // The error attributes getter, when invoked, must return
	    // this's error.
	    return this[kError]
	  }

	  get onloadend () {
	    webidl.brandCheck(this, FileReader);

	    return this[kEvents].loadend
	  }

	  set onloadend (fn) {
	    webidl.brandCheck(this, FileReader);

	    if (this[kEvents].loadend) {
	      this.removeEventListener('loadend', this[kEvents].loadend);
	    }

	    if (typeof fn === 'function') {
	      this[kEvents].loadend = fn;
	      this.addEventListener('loadend', fn);
	    } else {
	      this[kEvents].loadend = null;
	    }
	  }

	  get onerror () {
	    webidl.brandCheck(this, FileReader);

	    return this[kEvents].error
	  }

	  set onerror (fn) {
	    webidl.brandCheck(this, FileReader);

	    if (this[kEvents].error) {
	      this.removeEventListener('error', this[kEvents].error);
	    }

	    if (typeof fn === 'function') {
	      this[kEvents].error = fn;
	      this.addEventListener('error', fn);
	    } else {
	      this[kEvents].error = null;
	    }
	  }

	  get onloadstart () {
	    webidl.brandCheck(this, FileReader);

	    return this[kEvents].loadstart
	  }

	  set onloadstart (fn) {
	    webidl.brandCheck(this, FileReader);

	    if (this[kEvents].loadstart) {
	      this.removeEventListener('loadstart', this[kEvents].loadstart);
	    }

	    if (typeof fn === 'function') {
	      this[kEvents].loadstart = fn;
	      this.addEventListener('loadstart', fn);
	    } else {
	      this[kEvents].loadstart = null;
	    }
	  }

	  get onprogress () {
	    webidl.brandCheck(this, FileReader);

	    return this[kEvents].progress
	  }

	  set onprogress (fn) {
	    webidl.brandCheck(this, FileReader);

	    if (this[kEvents].progress) {
	      this.removeEventListener('progress', this[kEvents].progress);
	    }

	    if (typeof fn === 'function') {
	      this[kEvents].progress = fn;
	      this.addEventListener('progress', fn);
	    } else {
	      this[kEvents].progress = null;
	    }
	  }

	  get onload () {
	    webidl.brandCheck(this, FileReader);

	    return this[kEvents].load
	  }

	  set onload (fn) {
	    webidl.brandCheck(this, FileReader);

	    if (this[kEvents].load) {
	      this.removeEventListener('load', this[kEvents].load);
	    }

	    if (typeof fn === 'function') {
	      this[kEvents].load = fn;
	      this.addEventListener('load', fn);
	    } else {
	      this[kEvents].load = null;
	    }
	  }

	  get onabort () {
	    webidl.brandCheck(this, FileReader);

	    return this[kEvents].abort
	  }

	  set onabort (fn) {
	    webidl.brandCheck(this, FileReader);

	    if (this[kEvents].abort) {
	      this.removeEventListener('abort', this[kEvents].abort);
	    }

	    if (typeof fn === 'function') {
	      this[kEvents].abort = fn;
	      this.addEventListener('abort', fn);
	    } else {
	      this[kEvents].abort = null;
	    }
	  }
	}

	// https://w3c.github.io/FileAPI/#dom-filereader-empty
	FileReader.EMPTY = FileReader.prototype.EMPTY = 0;
	// https://w3c.github.io/FileAPI/#dom-filereader-loading
	FileReader.LOADING = FileReader.prototype.LOADING = 1;
	// https://w3c.github.io/FileAPI/#dom-filereader-done
	FileReader.DONE = FileReader.prototype.DONE = 2;

	Object.defineProperties(FileReader.prototype, {
	  EMPTY: staticPropertyDescriptors,
	  LOADING: staticPropertyDescriptors,
	  DONE: staticPropertyDescriptors,
	  readAsArrayBuffer: kEnumerableProperty,
	  readAsBinaryString: kEnumerableProperty,
	  readAsText: kEnumerableProperty,
	  readAsDataURL: kEnumerableProperty,
	  abort: kEnumerableProperty,
	  readyState: kEnumerableProperty,
	  result: kEnumerableProperty,
	  error: kEnumerableProperty,
	  onloadstart: kEnumerableProperty,
	  onprogress: kEnumerableProperty,
	  onload: kEnumerableProperty,
	  onabort: kEnumerableProperty,
	  onerror: kEnumerableProperty,
	  onloadend: kEnumerableProperty,
	  [Symbol.toStringTag]: {
	    value: 'FileReader',
	    writable: false,
	    enumerable: false,
	    configurable: true
	  }
	});

	Object.defineProperties(FileReader, {
	  EMPTY: staticPropertyDescriptors,
	  LOADING: staticPropertyDescriptors,
	  DONE: staticPropertyDescriptors
	});

	filereader = {
	  FileReader
	};
	return filereader;
}

var symbols$1;
var hasRequiredSymbols$1;

function requireSymbols$1 () {
	if (hasRequiredSymbols$1) return symbols$1;
	hasRequiredSymbols$1 = 1;

	symbols$1 = {
	  kConstruct: requireSymbols$4().kConstruct
	};
	return symbols$1;
}

var util$2;
var hasRequiredUtil$2;

function requireUtil$2 () {
	if (hasRequiredUtil$2) return util$2;
	hasRequiredUtil$2 = 1;

	const assert = require$$0$4;
	const { URLSerializer } = requireDataURL();
	const { isValidHeaderName } = requireUtil$5();

	/**
	 * @see https://url.spec.whatwg.org/#concept-url-equals
	 * @param {URL} A
	 * @param {URL} B
	 * @param {boolean | undefined} excludeFragment
	 * @returns {boolean}
	 */
	function urlEquals (A, B, excludeFragment = false) {
	  const serializedA = URLSerializer(A, excludeFragment);

	  const serializedB = URLSerializer(B, excludeFragment);

	  return serializedA === serializedB
	}

	/**
	 * @see https://github.com/chromium/chromium/blob/694d20d134cb553d8d89e5500b9148012b1ba299/content/browser/cache_storage/cache_storage_cache.cc#L260-L262
	 * @param {string} header
	 */
	function fieldValues (header) {
	  assert(header !== null);

	  const values = [];

	  for (let value of header.split(',')) {
	    value = value.trim();

	    if (!value.length) {
	      continue
	    } else if (!isValidHeaderName(value)) {
	      continue
	    }

	    values.push(value);
	  }

	  return values
	}

	util$2 = {
	  urlEquals,
	  fieldValues
	};
	return util$2;
}

var cache;
var hasRequiredCache;

function requireCache () {
	if (hasRequiredCache) return cache;
	hasRequiredCache = 1;

	const { kConstruct } = requireSymbols$1();
	const { urlEquals, fieldValues: getFieldValues } = requireUtil$2();
	const { kEnumerableProperty, isDisturbed } = requireUtil$6();
	const { kHeadersList } = requireSymbols$4();
	const { webidl } = requireWebidl();
	const { Response, cloneResponse } = requireResponse();
	const { Request } = requireRequest();
	const { kState, kHeaders, kGuard, kRealm } = requireSymbols$3();
	const { fetching } = requireFetch();
	const { urlIsHttpHttpsScheme, createDeferredPromise, readAllBytes } = requireUtil$5();
	const assert = require$$0$4;
	const { getGlobalDispatcher } = requireGlobal();

	/**
	 * @see https://w3c.github.io/ServiceWorker/#dfn-cache-batch-operation
	 * @typedef {Object} CacheBatchOperation
	 * @property {'delete' | 'put'} type
	 * @property {any} request
	 * @property {any} response
	 * @property {import('../../types/cache').CacheQueryOptions} options
	 */

	/**
	 * @see https://w3c.github.io/ServiceWorker/#dfn-request-response-list
	 * @typedef {[any, any][]} requestResponseList
	 */

	class Cache {
	  /**
	   * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-request-response-list
	   * @type {requestResponseList}
	   */
	  #relevantRequestResponseList

	  constructor () {
	    if (arguments[0] !== kConstruct) {
	      webidl.illegalConstructor();
	    }

	    this.#relevantRequestResponseList = arguments[1];
	  }

	  async match (request, options = {}) {
	    webidl.brandCheck(this, Cache);
	    webidl.argumentLengthCheck(arguments, 1, { header: 'Cache.match' });

	    request = webidl.converters.RequestInfo(request);
	    options = webidl.converters.CacheQueryOptions(options);

	    const p = await this.matchAll(request, options);

	    if (p.length === 0) {
	      return
	    }

	    return p[0]
	  }

	  async matchAll (request = undefined, options = {}) {
	    webidl.brandCheck(this, Cache);

	    if (request !== undefined) request = webidl.converters.RequestInfo(request);
	    options = webidl.converters.CacheQueryOptions(options);

	    // 1.
	    let r = null;

	    // 2.
	    if (request !== undefined) {
	      if (request instanceof Request) {
	        // 2.1.1
	        r = request[kState];

	        // 2.1.2
	        if (r.method !== 'GET' && !options.ignoreMethod) {
	          return []
	        }
	      } else if (typeof request === 'string') {
	        // 2.2.1
	        r = new Request(request)[kState];
	      }
	    }

	    // 5.
	    // 5.1
	    const responses = [];

	    // 5.2
	    if (request === undefined) {
	      // 5.2.1
	      for (const requestResponse of this.#relevantRequestResponseList) {
	        responses.push(requestResponse[1]);
	      }
	    } else { // 5.3
	      // 5.3.1
	      const requestResponses = this.#queryCache(r, options);

	      // 5.3.2
	      for (const requestResponse of requestResponses) {
	        responses.push(requestResponse[1]);
	      }
	    }

	    // 5.4
	    // We don't implement CORs so we don't need to loop over the responses, yay!

	    // 5.5.1
	    const responseList = [];

	    // 5.5.2
	    for (const response of responses) {
	      // 5.5.2.1
	      const responseObject = new Response(response.body?.source ?? null);
	      const body = responseObject[kState].body;
	      responseObject[kState] = response;
	      responseObject[kState].body = body;
	      responseObject[kHeaders][kHeadersList] = response.headersList;
	      responseObject[kHeaders][kGuard] = 'immutable';

	      responseList.push(responseObject);
	    }

	    // 6.
	    return Object.freeze(responseList)
	  }

	  async add (request) {
	    webidl.brandCheck(this, Cache);
	    webidl.argumentLengthCheck(arguments, 1, { header: 'Cache.add' });

	    request = webidl.converters.RequestInfo(request);

	    // 1.
	    const requests = [request];

	    // 2.
	    const responseArrayPromise = this.addAll(requests);

	    // 3.
	    return await responseArrayPromise
	  }

	  async addAll (requests) {
	    webidl.brandCheck(this, Cache);
	    webidl.argumentLengthCheck(arguments, 1, { header: 'Cache.addAll' });

	    requests = webidl.converters['sequence<RequestInfo>'](requests);

	    // 1.
	    const responsePromises = [];

	    // 2.
	    const requestList = [];

	    // 3.
	    for (const request of requests) {
	      if (typeof request === 'string') {
	        continue
	      }

	      // 3.1
	      const r = request[kState];

	      // 3.2
	      if (!urlIsHttpHttpsScheme(r.url) || r.method !== 'GET') {
	        throw webidl.errors.exception({
	          header: 'Cache.addAll',
	          message: 'Expected http/s scheme when method is not GET.'
	        })
	      }
	    }

	    // 4.
	    /** @type {ReturnType<typeof fetching>[]} */
	    const fetchControllers = [];

	    // 5.
	    for (const request of requests) {
	      // 5.1
	      const r = new Request(request)[kState];

	      // 5.2
	      if (!urlIsHttpHttpsScheme(r.url)) {
	        throw webidl.errors.exception({
	          header: 'Cache.addAll',
	          message: 'Expected http/s scheme.'
	        })
	      }

	      // 5.4
	      r.initiator = 'fetch';
	      r.destination = 'subresource';

	      // 5.5
	      requestList.push(r);

	      // 5.6
	      const responsePromise = createDeferredPromise();

	      // 5.7
	      fetchControllers.push(fetching({
	        request: r,
	        dispatcher: getGlobalDispatcher(),
	        processResponse (response) {
	          // 1.
	          if (response.type === 'error' || response.status === 206 || response.status < 200 || response.status > 299) {
	            responsePromise.reject(webidl.errors.exception({
	              header: 'Cache.addAll',
	              message: 'Received an invalid status code or the request failed.'
	            }));
	          } else if (response.headersList.contains('vary')) { // 2.
	            // 2.1
	            const fieldValues = getFieldValues(response.headersList.get('vary'));

	            // 2.2
	            for (const fieldValue of fieldValues) {
	              // 2.2.1
	              if (fieldValue === '*') {
	                responsePromise.reject(webidl.errors.exception({
	                  header: 'Cache.addAll',
	                  message: 'invalid vary field value'
	                }));

	                for (const controller of fetchControllers) {
	                  controller.abort();
	                }

	                return
	              }
	            }
	          }
	        },
	        processResponseEndOfBody (response) {
	          // 1.
	          if (response.aborted) {
	            responsePromise.reject(new DOMException('aborted', 'AbortError'));
	            return
	          }

	          // 2.
	          responsePromise.resolve(response);
	        }
	      }));

	      // 5.8
	      responsePromises.push(responsePromise.promise);
	    }

	    // 6.
	    const p = Promise.all(responsePromises);

	    // 7.
	    const responses = await p;

	    // 7.1
	    const operations = [];

	    // 7.2
	    let index = 0;

	    // 7.3
	    for (const response of responses) {
	      // 7.3.1
	      /** @type {CacheBatchOperation} */
	      const operation = {
	        type: 'put', // 7.3.2
	        request: requestList[index], // 7.3.3
	        response // 7.3.4
	      };

	      operations.push(operation); // 7.3.5

	      index++; // 7.3.6
	    }

	    // 7.5
	    const cacheJobPromise = createDeferredPromise();

	    // 7.6.1
	    let errorData = null;

	    // 7.6.2
	    try {
	      this.#batchCacheOperations(operations);
	    } catch (e) {
	      errorData = e;
	    }

	    // 7.6.3
	    queueMicrotask(() => {
	      // 7.6.3.1
	      if (errorData === null) {
	        cacheJobPromise.resolve(undefined);
	      } else {
	        // 7.6.3.2
	        cacheJobPromise.reject(errorData);
	      }
	    });

	    // 7.7
	    return cacheJobPromise.promise
	  }

	  async put (request, response) {
	    webidl.brandCheck(this, Cache);
	    webidl.argumentLengthCheck(arguments, 2, { header: 'Cache.put' });

	    request = webidl.converters.RequestInfo(request);
	    response = webidl.converters.Response(response);

	    // 1.
	    let innerRequest = null;

	    // 2.
	    if (request instanceof Request) {
	      innerRequest = request[kState];
	    } else { // 3.
	      innerRequest = new Request(request)[kState];
	    }

	    // 4.
	    if (!urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== 'GET') {
	      throw webidl.errors.exception({
	        header: 'Cache.put',
	        message: 'Expected an http/s scheme when method is not GET'
	      })
	    }

	    // 5.
	    const innerResponse = response[kState];

	    // 6.
	    if (innerResponse.status === 206) {
	      throw webidl.errors.exception({
	        header: 'Cache.put',
	        message: 'Got 206 status'
	      })
	    }

	    // 7.
	    if (innerResponse.headersList.contains('vary')) {
	      // 7.1.
	      const fieldValues = getFieldValues(innerResponse.headersList.get('vary'));

	      // 7.2.
	      for (const fieldValue of fieldValues) {
	        // 7.2.1
	        if (fieldValue === '*') {
	          throw webidl.errors.exception({
	            header: 'Cache.put',
	            message: 'Got * vary field value'
	          })
	        }
	      }
	    }

	    // 8.
	    if (innerResponse.body && (isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked)) {
	      throw webidl.errors.exception({
	        header: 'Cache.put',
	        message: 'Response body is locked or disturbed'
	      })
	    }

	    // 9.
	    const clonedResponse = cloneResponse(innerResponse);

	    // 10.
	    const bodyReadPromise = createDeferredPromise();

	    // 11.
	    if (innerResponse.body != null) {
	      // 11.1
	      const stream = innerResponse.body.stream;

	      // 11.2
	      const reader = stream.getReader();

	      // 11.3
	      readAllBytes(reader).then(bodyReadPromise.resolve, bodyReadPromise.reject);
	    } else {
	      bodyReadPromise.resolve(undefined);
	    }

	    // 12.
	    /** @type {CacheBatchOperation[]} */
	    const operations = [];

	    // 13.
	    /** @type {CacheBatchOperation} */
	    const operation = {
	      type: 'put', // 14.
	      request: innerRequest, // 15.
	      response: clonedResponse // 16.
	    };

	    // 17.
	    operations.push(operation);

	    // 19.
	    const bytes = await bodyReadPromise.promise;

	    if (clonedResponse.body != null) {
	      clonedResponse.body.source = bytes;
	    }

	    // 19.1
	    const cacheJobPromise = createDeferredPromise();

	    // 19.2.1
	    let errorData = null;

	    // 19.2.2
	    try {
	      this.#batchCacheOperations(operations);
	    } catch (e) {
	      errorData = e;
	    }

	    // 19.2.3
	    queueMicrotask(() => {
	      // 19.2.3.1
	      if (errorData === null) {
	        cacheJobPromise.resolve();
	      } else { // 19.2.3.2
	        cacheJobPromise.reject(errorData);
	      }
	    });

	    return cacheJobPromise.promise
	  }

	  async delete (request, options = {}) {
	    webidl.brandCheck(this, Cache);
	    webidl.argumentLengthCheck(arguments, 1, { header: 'Cache.delete' });

	    request = webidl.converters.RequestInfo(request);
	    options = webidl.converters.CacheQueryOptions(options);

	    /**
	     * @type {Request}
	     */
	    let r = null;

	    if (request instanceof Request) {
	      r = request[kState];

	      if (r.method !== 'GET' && !options.ignoreMethod) {
	        return false
	      }
	    } else {
	      assert(typeof request === 'string');

	      r = new Request(request)[kState];
	    }

	    /** @type {CacheBatchOperation[]} */
	    const operations = [];

	    /** @type {CacheBatchOperation} */
	    const operation = {
	      type: 'delete',
	      request: r,
	      options
	    };

	    operations.push(operation);

	    const cacheJobPromise = createDeferredPromise();

	    let errorData = null;
	    let requestResponses;

	    try {
	      requestResponses = this.#batchCacheOperations(operations);
	    } catch (e) {
	      errorData = e;
	    }

	    queueMicrotask(() => {
	      if (errorData === null) {
	        cacheJobPromise.resolve(!!requestResponses?.length);
	      } else {
	        cacheJobPromise.reject(errorData);
	      }
	    });

	    return cacheJobPromise.promise
	  }

	  /**
	   * @see https://w3c.github.io/ServiceWorker/#dom-cache-keys
	   * @param {any} request
	   * @param {import('../../types/cache').CacheQueryOptions} options
	   * @returns {readonly Request[]}
	   */
	  async keys (request = undefined, options = {}) {
	    webidl.brandCheck(this, Cache);

	    if (request !== undefined) request = webidl.converters.RequestInfo(request);
	    options = webidl.converters.CacheQueryOptions(options);

	    // 1.
	    let r = null;

	    // 2.
	    if (request !== undefined) {
	      // 2.1
	      if (request instanceof Request) {
	        // 2.1.1
	        r = request[kState];

	        // 2.1.2
	        if (r.method !== 'GET' && !options.ignoreMethod) {
	          return []
	        }
	      } else if (typeof request === 'string') { // 2.2
	        r = new Request(request)[kState];
	      }
	    }

	    // 4.
	    const promise = createDeferredPromise();

	    // 5.
	    // 5.1
	    const requests = [];

	    // 5.2
	    if (request === undefined) {
	      // 5.2.1
	      for (const requestResponse of this.#relevantRequestResponseList) {
	        // 5.2.1.1
	        requests.push(requestResponse[0]);
	      }
	    } else { // 5.3
	      // 5.3.1
	      const requestResponses = this.#queryCache(r, options);

	      // 5.3.2
	      for (const requestResponse of requestResponses) {
	        // 5.3.2.1
	        requests.push(requestResponse[0]);
	      }
	    }

	    // 5.4
	    queueMicrotask(() => {
	      // 5.4.1
	      const requestList = [];

	      // 5.4.2
	      for (const request of requests) {
	        const requestObject = new Request('https://a');
	        requestObject[kState] = request;
	        requestObject[kHeaders][kHeadersList] = request.headersList;
	        requestObject[kHeaders][kGuard] = 'immutable';
	        requestObject[kRealm] = request.client;

	        // 5.4.2.1
	        requestList.push(requestObject);
	      }

	      // 5.4.3
	      promise.resolve(Object.freeze(requestList));
	    });

	    return promise.promise
	  }

	  /**
	   * @see https://w3c.github.io/ServiceWorker/#batch-cache-operations-algorithm
	   * @param {CacheBatchOperation[]} operations
	   * @returns {requestResponseList}
	   */
	  #batchCacheOperations (operations) {
	    // 1.
	    const cache = this.#relevantRequestResponseList;

	    // 2.
	    const backupCache = [...cache];

	    // 3.
	    const addedItems = [];

	    // 4.1
	    const resultList = [];

	    try {
	      // 4.2
	      for (const operation of operations) {
	        // 4.2.1
	        if (operation.type !== 'delete' && operation.type !== 'put') {
	          throw webidl.errors.exception({
	            header: 'Cache.#batchCacheOperations',
	            message: 'operation type does not match "delete" or "put"'
	          })
	        }

	        // 4.2.2
	        if (operation.type === 'delete' && operation.response != null) {
	          throw webidl.errors.exception({
	            header: 'Cache.#batchCacheOperations',
	            message: 'delete operation should not have an associated response'
	          })
	        }

	        // 4.2.3
	        if (this.#queryCache(operation.request, operation.options, addedItems).length) {
	          throw new DOMException('???', 'InvalidStateError')
	        }

	        // 4.2.4
	        let requestResponses;

	        // 4.2.5
	        if (operation.type === 'delete') {
	          // 4.2.5.1
	          requestResponses = this.#queryCache(operation.request, operation.options);

	          // TODO: the spec is wrong, this is needed to pass WPTs
	          if (requestResponses.length === 0) {
	            return []
	          }

	          // 4.2.5.2
	          for (const requestResponse of requestResponses) {
	            const idx = cache.indexOf(requestResponse);
	            assert(idx !== -1);

	            // 4.2.5.2.1
	            cache.splice(idx, 1);
	          }
	        } else if (operation.type === 'put') { // 4.2.6
	          // 4.2.6.1
	          if (operation.response == null) {
	            throw webidl.errors.exception({
	              header: 'Cache.#batchCacheOperations',
	              message: 'put operation should have an associated response'
	            })
	          }

	          // 4.2.6.2
	          const r = operation.request;

	          // 4.2.6.3
	          if (!urlIsHttpHttpsScheme(r.url)) {
	            throw webidl.errors.exception({
	              header: 'Cache.#batchCacheOperations',
	              message: 'expected http or https scheme'
	            })
	          }

	          // 4.2.6.4
	          if (r.method !== 'GET') {
	            throw webidl.errors.exception({
	              header: 'Cache.#batchCacheOperations',
	              message: 'not get method'
	            })
	          }

	          // 4.2.6.5
	          if (operation.options != null) {
	            throw webidl.errors.exception({
	              header: 'Cache.#batchCacheOperations',
	              message: 'options must not be defined'
	            })
	          }

	          // 4.2.6.6
	          requestResponses = this.#queryCache(operation.request);

	          // 4.2.6.7
	          for (const requestResponse of requestResponses) {
	            const idx = cache.indexOf(requestResponse);
	            assert(idx !== -1);

	            // 4.2.6.7.1
	            cache.splice(idx, 1);
	          }

	          // 4.2.6.8
	          cache.push([operation.request, operation.response]);

	          // 4.2.6.10
	          addedItems.push([operation.request, operation.response]);
	        }

	        // 4.2.7
	        resultList.push([operation.request, operation.response]);
	      }

	      // 4.3
	      return resultList
	    } catch (e) { // 5.
	      // 5.1
	      this.#relevantRequestResponseList.length = 0;

	      // 5.2
	      this.#relevantRequestResponseList = backupCache;

	      // 5.3
	      throw e
	    }
	  }

	  /**
	   * @see https://w3c.github.io/ServiceWorker/#query-cache
	   * @param {any} requestQuery
	   * @param {import('../../types/cache').CacheQueryOptions} options
	   * @param {requestResponseList} targetStorage
	   * @returns {requestResponseList}
	   */
	  #queryCache (requestQuery, options, targetStorage) {
	    /** @type {requestResponseList} */
	    const resultList = [];

	    const storage = targetStorage ?? this.#relevantRequestResponseList;

	    for (const requestResponse of storage) {
	      const [cachedRequest, cachedResponse] = requestResponse;
	      if (this.#requestMatchesCachedItem(requestQuery, cachedRequest, cachedResponse, options)) {
	        resultList.push(requestResponse);
	      }
	    }

	    return resultList
	  }

	  /**
	   * @see https://w3c.github.io/ServiceWorker/#request-matches-cached-item-algorithm
	   * @param {any} requestQuery
	   * @param {any} request
	   * @param {any | null} response
	   * @param {import('../../types/cache').CacheQueryOptions | undefined} options
	   * @returns {boolean}
	   */
	  #requestMatchesCachedItem (requestQuery, request, response = null, options) {
	    // if (options?.ignoreMethod === false && request.method === 'GET') {
	    //   return false
	    // }

	    const queryURL = new URL(requestQuery.url);

	    const cachedURL = new URL(request.url);

	    if (options?.ignoreSearch) {
	      cachedURL.search = '';

	      queryURL.search = '';
	    }

	    if (!urlEquals(queryURL, cachedURL, true)) {
	      return false
	    }

	    if (
	      response == null ||
	      options?.ignoreVary ||
	      !response.headersList.contains('vary')
	    ) {
	      return true
	    }

	    const fieldValues = getFieldValues(response.headersList.get('vary'));

	    for (const fieldValue of fieldValues) {
	      if (fieldValue === '*') {
	        return false
	      }

	      const requestValue = request.headersList.get(fieldValue);
	      const queryValue = requestQuery.headersList.get(fieldValue);

	      // If one has the header and the other doesn't, or one has
	      // a different value than the other, return false
	      if (requestValue !== queryValue) {
	        return false
	      }
	    }

	    return true
	  }
	}

	Object.defineProperties(Cache.prototype, {
	  [Symbol.toStringTag]: {
	    value: 'Cache',
	    configurable: true
	  },
	  match: kEnumerableProperty,
	  matchAll: kEnumerableProperty,
	  add: kEnumerableProperty,
	  addAll: kEnumerableProperty,
	  put: kEnumerableProperty,
	  delete: kEnumerableProperty,
	  keys: kEnumerableProperty
	});

	const cacheQueryOptionConverters = [
	  {
	    key: 'ignoreSearch',
	    converter: webidl.converters.boolean,
	    defaultValue: false
	  },
	  {
	    key: 'ignoreMethod',
	    converter: webidl.converters.boolean,
	    defaultValue: false
	  },
	  {
	    key: 'ignoreVary',
	    converter: webidl.converters.boolean,
	    defaultValue: false
	  }
	];

	webidl.converters.CacheQueryOptions = webidl.dictionaryConverter(cacheQueryOptionConverters);

	webidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([
	  ...cacheQueryOptionConverters,
	  {
	    key: 'cacheName',
	    converter: webidl.converters.DOMString
	  }
	]);

	webidl.converters.Response = webidl.interfaceConverter(Response);

	webidl.converters['sequence<RequestInfo>'] = webidl.sequenceConverter(
	  webidl.converters.RequestInfo
	);

	cache = {
	  Cache
	};
	return cache;
}

var cachestorage;
var hasRequiredCachestorage;

function requireCachestorage () {
	if (hasRequiredCachestorage) return cachestorage;
	hasRequiredCachestorage = 1;

	const { kConstruct } = requireSymbols$1();
	const { Cache } = requireCache();
	const { webidl } = requireWebidl();
	const { kEnumerableProperty } = requireUtil$6();

	class CacheStorage {
	  /**
	   * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-name-to-cache-map
	   * @type {Map<string, import('./cache').requestResponseList}
	   */
	  #caches = new Map()

	  constructor () {
	    if (arguments[0] !== kConstruct) {
	      webidl.illegalConstructor();
	    }
	  }

	  async match (request, options = {}) {
	    webidl.brandCheck(this, CacheStorage);
	    webidl.argumentLengthCheck(arguments, 1, { header: 'CacheStorage.match' });

	    request = webidl.converters.RequestInfo(request);
	    options = webidl.converters.MultiCacheQueryOptions(options);

	    // 1.
	    if (options.cacheName != null) {
	      // 1.1.1.1
	      if (this.#caches.has(options.cacheName)) {
	        // 1.1.1.1.1
	        const cacheList = this.#caches.get(options.cacheName);
	        const cache = new Cache(kConstruct, cacheList);

	        return await cache.match(request, options)
	      }
	    } else { // 2.
	      // 2.2
	      for (const cacheList of this.#caches.values()) {
	        const cache = new Cache(kConstruct, cacheList);

	        // 2.2.1.2
	        const response = await cache.match(request, options);

	        if (response !== undefined) {
	          return response
	        }
	      }
	    }
	  }

	  /**
	   * @see https://w3c.github.io/ServiceWorker/#cache-storage-has
	   * @param {string} cacheName
	   * @returns {Promise<boolean>}
	   */
	  async has (cacheName) {
	    webidl.brandCheck(this, CacheStorage);
	    webidl.argumentLengthCheck(arguments, 1, { header: 'CacheStorage.has' });

	    cacheName = webidl.converters.DOMString(cacheName);

	    // 2.1.1
	    // 2.2
	    return this.#caches.has(cacheName)
	  }

	  /**
	   * @see https://w3c.github.io/ServiceWorker/#dom-cachestorage-open
	   * @param {string} cacheName
	   * @returns {Promise<Cache>}
	   */
	  async open (cacheName) {
	    webidl.brandCheck(this, CacheStorage);
	    webidl.argumentLengthCheck(arguments, 1, { header: 'CacheStorage.open' });

	    cacheName = webidl.converters.DOMString(cacheName);

	    // 2.1
	    if (this.#caches.has(cacheName)) {
	      // await caches.open('v1') !== await caches.open('v1')

	      // 2.1.1
	      const cache = this.#caches.get(cacheName);

	      // 2.1.1.1
	      return new Cache(kConstruct, cache)
	    }

	    // 2.2
	    const cache = [];

	    // 2.3
	    this.#caches.set(cacheName, cache);

	    // 2.4
	    return new Cache(kConstruct, cache)
	  }

	  /**
	   * @see https://w3c.github.io/ServiceWorker/#cache-storage-delete
	   * @param {string} cacheName
	   * @returns {Promise<boolean>}
	   */
	  async delete (cacheName) {
	    webidl.brandCheck(this, CacheStorage);
	    webidl.argumentLengthCheck(arguments, 1, { header: 'CacheStorage.delete' });

	    cacheName = webidl.converters.DOMString(cacheName);

	    return this.#caches.delete(cacheName)
	  }

	  /**
	   * @see https://w3c.github.io/ServiceWorker/#cache-storage-keys
	   * @returns {string[]}
	   */
	  async keys () {
	    webidl.brandCheck(this, CacheStorage);

	    // 2.1
	    const keys = this.#caches.keys();

	    // 2.2
	    return [...keys]
	  }
	}

	Object.defineProperties(CacheStorage.prototype, {
	  [Symbol.toStringTag]: {
	    value: 'CacheStorage',
	    configurable: true
	  },
	  match: kEnumerableProperty,
	  has: kEnumerableProperty,
	  open: kEnumerableProperty,
	  delete: kEnumerableProperty,
	  keys: kEnumerableProperty
	});

	cachestorage = {
	  CacheStorage
	};
	return cachestorage;
}

var constants$3;
var hasRequiredConstants$3;

function requireConstants$3 () {
	if (hasRequiredConstants$3) return constants$3;
	hasRequiredConstants$3 = 1;

	// https://wicg.github.io/cookie-store/#cookie-maximum-attribute-value-size
	const maxAttributeValueSize = 1024;

	// https://wicg.github.io/cookie-store/#cookie-maximum-name-value-pair-size
	const maxNameValuePairSize = 4096;

	constants$3 = {
	  maxAttributeValueSize,
	  maxNameValuePairSize
	};
	return constants$3;
}

var util$1;
var hasRequiredUtil$1;

function requireUtil$1 () {
	if (hasRequiredUtil$1) return util$1;
	hasRequiredUtil$1 = 1;

	/**
	 * @param {string} value
	 * @returns {boolean}
	 */
	function isCTLExcludingHtab (value) {
	  if (value.length === 0) {
	    return false
	  }

	  for (const char of value) {
	    const code = char.charCodeAt(0);

	    if (
	      (code >= 0x00 || code <= 0x08) ||
	      (code >= 0x0A || code <= 0x1F) ||
	      code === 0x7F
	    ) {
	      return false
	    }
	  }
	}

	/**
	 CHAR           = <any US-ASCII character (octets 0 - 127)>
	 token          = 1*<any CHAR except CTLs or separators>
	 separators     = "(" | ")" | "<" | ">" | "@"
	                | "," | ";" | ":" | "\" | <">
	                | "/" | "[" | "]" | "?" | "="
	                | "{" | "}" | SP | HT
	 * @param {string} name
	 */
	function validateCookieName (name) {
	  for (const char of name) {
	    const code = char.charCodeAt(0);

	    if (
	      (code <= 0x20 || code > 0x7F) ||
	      char === '(' ||
	      char === ')' ||
	      char === '>' ||
	      char === '<' ||
	      char === '@' ||
	      char === ',' ||
	      char === ';' ||
	      char === ':' ||
	      char === '\\' ||
	      char === '"' ||
	      char === '/' ||
	      char === '[' ||
	      char === ']' ||
	      char === '?' ||
	      char === '=' ||
	      char === '{' ||
	      char === '}'
	    ) {
	      throw new Error('Invalid cookie name')
	    }
	  }
	}

	/**
	 cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )
	 cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E
	                       ; US-ASCII characters excluding CTLs,
	                       ; whitespace DQUOTE, comma, semicolon,
	                       ; and backslash
	 * @param {string} value
	 */
	function validateCookieValue (value) {
	  for (const char of value) {
	    const code = char.charCodeAt(0);

	    if (
	      code < 0x21 || // exclude CTLs (0-31)
	      code === 0x22 ||
	      code === 0x2C ||
	      code === 0x3B ||
	      code === 0x5C ||
	      code > 0x7E // non-ascii
	    ) {
	      throw new Error('Invalid header value')
	    }
	  }
	}

	/**
	 * path-value        = <any CHAR except CTLs or ";">
	 * @param {string} path
	 */
	function validateCookiePath (path) {
	  for (const char of path) {
	    const code = char.charCodeAt(0);

	    if (code < 0x21 || char === ';') {
	      throw new Error('Invalid cookie path')
	    }
	  }
	}

	/**
	 * I have no idea why these values aren't allowed to be honest,
	 * but Deno tests these. - Khafra
	 * @param {string} domain
	 */
	function validateCookieDomain (domain) {
	  if (
	    domain.startsWith('-') ||
	    domain.endsWith('.') ||
	    domain.endsWith('-')
	  ) {
	    throw new Error('Invalid cookie domain')
	  }
	}

	/**
	 * @see https://www.rfc-editor.org/rfc/rfc7231#section-7.1.1.1
	 * @param {number|Date} date
	  IMF-fixdate  = day-name "," SP date1 SP time-of-day SP GMT
	  ; fixed length/zone/capitalization subset of the format
	  ; see Section 3.3 of [RFC5322]

	  day-name     = %x4D.6F.6E ; "Mon", case-sensitive
	              / %x54.75.65 ; "Tue", case-sensitive
	              / %x57.65.64 ; "Wed", case-sensitive
	              / %x54.68.75 ; "Thu", case-sensitive
	              / %x46.72.69 ; "Fri", case-sensitive
	              / %x53.61.74 ; "Sat", case-sensitive
	              / %x53.75.6E ; "Sun", case-sensitive
	  date1        = day SP month SP year
	                  ; e.g., 02 Jun 1982

	  day          = 2DIGIT
	  month        = %x4A.61.6E ; "Jan", case-sensitive
	              / %x46.65.62 ; "Feb", case-sensitive
	              / %x4D.61.72 ; "Mar", case-sensitive
	              / %x41.70.72 ; "Apr", case-sensitive
	              / %x4D.61.79 ; "May", case-sensitive
	              / %x4A.75.6E ; "Jun", case-sensitive
	              / %x4A.75.6C ; "Jul", case-sensitive
	              / %x41.75.67 ; "Aug", case-sensitive
	              / %x53.65.70 ; "Sep", case-sensitive
	              / %x4F.63.74 ; "Oct", case-sensitive
	              / %x4E.6F.76 ; "Nov", case-sensitive
	              / %x44.65.63 ; "Dec", case-sensitive
	  year         = 4DIGIT

	  GMT          = %x47.4D.54 ; "GMT", case-sensitive

	  time-of-day  = hour ":" minute ":" second
	              ; 00:00:00 - 23:59:60 (leap second)

	  hour         = 2DIGIT
	  minute       = 2DIGIT
	  second       = 2DIGIT
	 */
	function toIMFDate (date) {
	  if (typeof date === 'number') {
	    date = new Date(date);
	  }

	  const days = [
	    'Sun', 'Mon', 'Tue', 'Wed',
	    'Thu', 'Fri', 'Sat'
	  ];

	  const months = [
	    'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
	    'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
	  ];

	  const dayName = days[date.getUTCDay()];
	  const day = date.getUTCDate().toString().padStart(2, '0');
	  const month = months[date.getUTCMonth()];
	  const year = date.getUTCFullYear();
	  const hour = date.getUTCHours().toString().padStart(2, '0');
	  const minute = date.getUTCMinutes().toString().padStart(2, '0');
	  const second = date.getUTCSeconds().toString().padStart(2, '0');

	  return `${dayName}, ${day} ${month} ${year} ${hour}:${minute}:${second} GMT`
	}

	/**
	 max-age-av        = "Max-Age=" non-zero-digit *DIGIT
	                       ; In practice, both expires-av and max-age-av
	                       ; are limited to dates representable by the
	                       ; user agent.
	 * @param {number} maxAge
	 */
	function validateCookieMaxAge (maxAge) {
	  if (maxAge < 0) {
	    throw new Error('Invalid cookie max-age')
	  }
	}

	/**
	 * @see https://www.rfc-editor.org/rfc/rfc6265#section-4.1.1
	 * @param {import('./index').Cookie} cookie
	 */
	function stringify (cookie) {
	  if (cookie.name.length === 0) {
	    return null
	  }

	  validateCookieName(cookie.name);
	  validateCookieValue(cookie.value);

	  const out = [`${cookie.name}=${cookie.value}`];

	  // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-cookie-prefixes-00#section-3.1
	  // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-cookie-prefixes-00#section-3.2
	  if (cookie.name.startsWith('__Secure-')) {
	    cookie.secure = true;
	  }

	  if (cookie.name.startsWith('__Host-')) {
	    cookie.secure = true;
	    cookie.domain = null;
	    cookie.path = '/';
	  }

	  if (cookie.secure) {
	    out.push('Secure');
	  }

	  if (cookie.httpOnly) {
	    out.push('HttpOnly');
	  }

	  if (typeof cookie.maxAge === 'number') {
	    validateCookieMaxAge(cookie.maxAge);
	    out.push(`Max-Age=${cookie.maxAge}`);
	  }

	  if (cookie.domain) {
	    validateCookieDomain(cookie.domain);
	    out.push(`Domain=${cookie.domain}`);
	  }

	  if (cookie.path) {
	    validateCookiePath(cookie.path);
	    out.push(`Path=${cookie.path}`);
	  }

	  if (cookie.expires && cookie.expires.toString() !== 'Invalid Date') {
	    out.push(`Expires=${toIMFDate(cookie.expires)}`);
	  }

	  if (cookie.sameSite) {
	    out.push(`SameSite=${cookie.sameSite}`);
	  }

	  for (const part of cookie.unparsed) {
	    if (!part.includes('=')) {
	      throw new Error('Invalid unparsed')
	    }

	    const [key, ...value] = part.split('=');

	    out.push(`${key.trim()}=${value.join('=')}`);
	  }

	  return out.join('; ')
	}

	util$1 = {
	  isCTLExcludingHtab,
	  validateCookieName,
	  validateCookiePath,
	  validateCookieValue,
	  toIMFDate,
	  stringify
	};
	return util$1;
}

var parse$1;
var hasRequiredParse$2;

function requireParse$2 () {
	if (hasRequiredParse$2) return parse$1;
	hasRequiredParse$2 = 1;

	const { maxNameValuePairSize, maxAttributeValueSize } = requireConstants$3();
	const { isCTLExcludingHtab } = requireUtil$1();
	const { collectASequenceOfCodePointsFast } = requireDataURL();
	const assert = require$$0$4;

	/**
	 * @description Parses the field-value attributes of a set-cookie header string.
	 * @see https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4
	 * @param {string} header
	 * @returns if the header is invalid, null will be returned
	 */
	function parseSetCookie (header) {
	  // 1. If the set-cookie-string contains a %x00-08 / %x0A-1F / %x7F
	  //    character (CTL characters excluding HTAB): Abort these steps and
	  //    ignore the set-cookie-string entirely.
	  if (isCTLExcludingHtab(header)) {
	    return null
	  }

	  let nameValuePair = '';
	  let unparsedAttributes = '';
	  let name = '';
	  let value = '';

	  // 2. If the set-cookie-string contains a %x3B (";") character:
	  if (header.includes(';')) {
	    // 1. The name-value-pair string consists of the characters up to,
	    //    but not including, the first %x3B (";"), and the unparsed-
	    //    attributes consist of the remainder of the set-cookie-string
	    //    (including the %x3B (";") in question).
	    const position = { position: 0 };

	    nameValuePair = collectASequenceOfCodePointsFast(';', header, position);
	    unparsedAttributes = header.slice(position.position);
	  } else {
	    // Otherwise:

	    // 1. The name-value-pair string consists of all the characters
	    //    contained in the set-cookie-string, and the unparsed-
	    //    attributes is the empty string.
	    nameValuePair = header;
	  }

	  // 3. If the name-value-pair string lacks a %x3D ("=") character, then
	  //    the name string is empty, and the value string is the value of
	  //    name-value-pair.
	  if (!nameValuePair.includes('=')) {
	    value = nameValuePair;
	  } else {
	    //    Otherwise, the name string consists of the characters up to, but
	    //    not including, the first %x3D ("=") character, and the (possibly
	    //    empty) value string consists of the characters after the first
	    //    %x3D ("=") character.
	    const position = { position: 0 };
	    name = collectASequenceOfCodePointsFast(
	      '=',
	      nameValuePair,
	      position
	    );
	    value = nameValuePair.slice(position.position + 1);
	  }

	  // 4. Remove any leading or trailing WSP characters from the name
	  //    string and the value string.
	  name = name.trim();
	  value = value.trim();

	  // 5. If the sum of the lengths of the name string and the value string
	  //    is more than 4096 octets, abort these steps and ignore the set-
	  //    cookie-string entirely.
	  if (name.length + value.length > maxNameValuePairSize) {
	    return null
	  }

	  // 6. The cookie-name is the name string, and the cookie-value is the
	  //    value string.
	  return {
	    name, value, ...parseUnparsedAttributes(unparsedAttributes)
	  }
	}

	/**
	 * Parses the remaining attributes of a set-cookie header
	 * @see https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4
	 * @param {string} unparsedAttributes
	 * @param {[Object.<string, unknown>]={}} cookieAttributeList
	 */
	function parseUnparsedAttributes (unparsedAttributes, cookieAttributeList = {}) {
	  // 1. If the unparsed-attributes string is empty, skip the rest of
	  //    these steps.
	  if (unparsedAttributes.length === 0) {
	    return cookieAttributeList
	  }

	  // 2. Discard the first character of the unparsed-attributes (which
	  //    will be a %x3B (";") character).
	  assert(unparsedAttributes[0] === ';');
	  unparsedAttributes = unparsedAttributes.slice(1);

	  let cookieAv = '';

	  // 3. If the remaining unparsed-attributes contains a %x3B (";")
	  //    character:
	  if (unparsedAttributes.includes(';')) {
	    // 1. Consume the characters of the unparsed-attributes up to, but
	    //    not including, the first %x3B (";") character.
	    cookieAv = collectASequenceOfCodePointsFast(
	      ';',
	      unparsedAttributes,
	      { position: 0 }
	    );
	    unparsedAttributes = unparsedAttributes.slice(cookieAv.length);
	  } else {
	    // Otherwise:

	    // 1. Consume the remainder of the unparsed-attributes.
	    cookieAv = unparsedAttributes;
	    unparsedAttributes = '';
	  }

	  // Let the cookie-av string be the characters consumed in this step.

	  let attributeName = '';
	  let attributeValue = '';

	  // 4. If the cookie-av string contains a %x3D ("=") character:
	  if (cookieAv.includes('=')) {
	    // 1. The (possibly empty) attribute-name string consists of the
	    //    characters up to, but not including, the first %x3D ("=")
	    //    character, and the (possibly empty) attribute-value string
	    //    consists of the characters after the first %x3D ("=")
	    //    character.
	    const position = { position: 0 };

	    attributeName = collectASequenceOfCodePointsFast(
	      '=',
	      cookieAv,
	      position
	    );
	    attributeValue = cookieAv.slice(position.position + 1);
	  } else {
	    // Otherwise:

	    // 1. The attribute-name string consists of the entire cookie-av
	    //    string, and the attribute-value string is empty.
	    attributeName = cookieAv;
	  }

	  // 5. Remove any leading or trailing WSP characters from the attribute-
	  //    name string and the attribute-value string.
	  attributeName = attributeName.trim();
	  attributeValue = attributeValue.trim();

	  // 6. If the attribute-value is longer than 1024 octets, ignore the
	  //    cookie-av string and return to Step 1 of this algorithm.
	  if (attributeValue.length > maxAttributeValueSize) {
	    return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList)
	  }

	  // 7. Process the attribute-name and attribute-value according to the
	  //    requirements in the following subsections.  (Notice that
	  //    attributes with unrecognized attribute-names are ignored.)
	  const attributeNameLowercase = attributeName.toLowerCase();

	  // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.1
	  // If the attribute-name case-insensitively matches the string
	  // "Expires", the user agent MUST process the cookie-av as follows.
	  if (attributeNameLowercase === 'expires') {
	    // 1. Let the expiry-time be the result of parsing the attribute-value
	    //    as cookie-date (see Section 5.1.1).
	    const expiryTime = new Date(attributeValue);

	    // 2. If the attribute-value failed to parse as a cookie date, ignore
	    //    the cookie-av.

	    cookieAttributeList.expires = expiryTime;
	  } else if (attributeNameLowercase === 'max-age') {
	    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.2
	    // If the attribute-name case-insensitively matches the string "Max-
	    // Age", the user agent MUST process the cookie-av as follows.

	    // 1. If the first character of the attribute-value is not a DIGIT or a
	    //    "-" character, ignore the cookie-av.
	    const charCode = attributeValue.charCodeAt(0);

	    if ((charCode < 48 || charCode > 57) && attributeValue[0] !== '-') {
	      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList)
	    }

	    // 2. If the remainder of attribute-value contains a non-DIGIT
	    //    character, ignore the cookie-av.
	    if (!/^\d+$/.test(attributeValue)) {
	      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList)
	    }

	    // 3. Let delta-seconds be the attribute-value converted to an integer.
	    const deltaSeconds = Number(attributeValue);

	    // 4. Let cookie-age-limit be the maximum age of the cookie (which
	    //    SHOULD be 400 days or less, see Section 4.1.2.2).

	    // 5. Set delta-seconds to the smaller of its present value and cookie-
	    //    age-limit.
	    // deltaSeconds = Math.min(deltaSeconds * 1000, maxExpiresMs)

	    // 6. If delta-seconds is less than or equal to zero (0), let expiry-
	    //    time be the earliest representable date and time.  Otherwise, let
	    //    the expiry-time be the current date and time plus delta-seconds
	    //    seconds.
	    // const expiryTime = deltaSeconds <= 0 ? Date.now() : Date.now() + deltaSeconds

	    // 7. Append an attribute to the cookie-attribute-list with an
	    //    attribute-name of Max-Age and an attribute-value of expiry-time.
	    cookieAttributeList.maxAge = deltaSeconds;
	  } else if (attributeNameLowercase === 'domain') {
	    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.3
	    // If the attribute-name case-insensitively matches the string "Domain",
	    // the user agent MUST process the cookie-av as follows.

	    // 1. Let cookie-domain be the attribute-value.
	    let cookieDomain = attributeValue;

	    // 2. If cookie-domain starts with %x2E ("."), let cookie-domain be
	    //    cookie-domain without its leading %x2E (".").
	    if (cookieDomain[0] === '.') {
	      cookieDomain = cookieDomain.slice(1);
	    }

	    // 3. Convert the cookie-domain to lower case.
	    cookieDomain = cookieDomain.toLowerCase();

	    // 4. Append an attribute to the cookie-attribute-list with an
	    //    attribute-name of Domain and an attribute-value of cookie-domain.
	    cookieAttributeList.domain = cookieDomain;
	  } else if (attributeNameLowercase === 'path') {
	    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.4
	    // If the attribute-name case-insensitively matches the string "Path",
	    // the user agent MUST process the cookie-av as follows.

	    // 1. If the attribute-value is empty or if the first character of the
	    //    attribute-value is not %x2F ("/"):
	    let cookiePath = '';
	    if (attributeValue.length === 0 || attributeValue[0] !== '/') {
	      // 1. Let cookie-path be the default-path.
	      cookiePath = '/';
	    } else {
	      // Otherwise:

	      // 1. Let cookie-path be the attribute-value.
	      cookiePath = attributeValue;
	    }

	    // 2. Append an attribute to the cookie-attribute-list with an
	    //    attribute-name of Path and an attribute-value of cookie-path.
	    cookieAttributeList.path = cookiePath;
	  } else if (attributeNameLowercase === 'secure') {
	    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.5
	    // If the attribute-name case-insensitively matches the string "Secure",
	    // the user agent MUST append an attribute to the cookie-attribute-list
	    // with an attribute-name of Secure and an empty attribute-value.

	    cookieAttributeList.secure = true;
	  } else if (attributeNameLowercase === 'httponly') {
	    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.6
	    // If the attribute-name case-insensitively matches the string
	    // "HttpOnly", the user agent MUST append an attribute to the cookie-
	    // attribute-list with an attribute-name of HttpOnly and an empty
	    // attribute-value.

	    cookieAttributeList.httpOnly = true;
	  } else if (attributeNameLowercase === 'samesite') {
	    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.7
	    // If the attribute-name case-insensitively matches the string
	    // "SameSite", the user agent MUST process the cookie-av as follows:

	    // 1. Let enforcement be "Default".
	    let enforcement = 'Default';

	    const attributeValueLowercase = attributeValue.toLowerCase();
	    // 2. If cookie-av's attribute-value is a case-insensitive match for
	    //    "None", set enforcement to "None".
	    if (attributeValueLowercase.includes('none')) {
	      enforcement = 'None';
	    }

	    // 3. If cookie-av's attribute-value is a case-insensitive match for
	    //    "Strict", set enforcement to "Strict".
	    if (attributeValueLowercase.includes('strict')) {
	      enforcement = 'Strict';
	    }

	    // 4. If cookie-av's attribute-value is a case-insensitive match for
	    //    "Lax", set enforcement to "Lax".
	    if (attributeValueLowercase.includes('lax')) {
	      enforcement = 'Lax';
	    }

	    // 5. Append an attribute to the cookie-attribute-list with an
	    //    attribute-name of "SameSite" and an attribute-value of
	    //    enforcement.
	    cookieAttributeList.sameSite = enforcement;
	  } else {
	    cookieAttributeList.unparsed ??= [];

	    cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`);
	  }

	  // 8. Return to Step 1 of this algorithm.
	  return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList)
	}

	parse$1 = {
	  parseSetCookie,
	  parseUnparsedAttributes
	};
	return parse$1;
}

var cookies;
var hasRequiredCookies;

function requireCookies () {
	if (hasRequiredCookies) return cookies;
	hasRequiredCookies = 1;

	const { parseSetCookie } = requireParse$2();
	const { stringify } = requireUtil$1();
	const { webidl } = requireWebidl();
	const { Headers } = requireHeaders();

	/**
	 * @typedef {Object} Cookie
	 * @property {string} name
	 * @property {string} value
	 * @property {Date|number|undefined} expires
	 * @property {number|undefined} maxAge
	 * @property {string|undefined} domain
	 * @property {string|undefined} path
	 * @property {boolean|undefined} secure
	 * @property {boolean|undefined} httpOnly
	 * @property {'Strict'|'Lax'|'None'} sameSite
	 * @property {string[]} unparsed
	 */

	/**
	 * @param {Headers} headers
	 * @returns {Record<string, string>}
	 */
	function getCookies (headers) {
	  webidl.argumentLengthCheck(arguments, 1, { header: 'getCookies' });

	  webidl.brandCheck(headers, Headers, { strict: false });

	  const cookie = headers.get('cookie');
	  const out = {};

	  if (!cookie) {
	    return out
	  }

	  for (const piece of cookie.split(';')) {
	    const [name, ...value] = piece.split('=');

	    out[name.trim()] = value.join('=');
	  }

	  return out
	}

	/**
	 * @param {Headers} headers
	 * @param {string} name
	 * @param {{ path?: string, domain?: string }|undefined} attributes
	 * @returns {void}
	 */
	function deleteCookie (headers, name, attributes) {
	  webidl.argumentLengthCheck(arguments, 2, { header: 'deleteCookie' });

	  webidl.brandCheck(headers, Headers, { strict: false });

	  name = webidl.converters.DOMString(name);
	  attributes = webidl.converters.DeleteCookieAttributes(attributes);

	  // Matches behavior of
	  // https://github.com/denoland/deno_std/blob/63827b16330b82489a04614027c33b7904e08be5/http/cookie.ts#L278
	  setCookie(headers, {
	    name,
	    value: '',
	    expires: new Date(0),
	    ...attributes
	  });
	}

	/**
	 * @param {Headers} headers
	 * @returns {Cookie[]}
	 */
	function getSetCookies (headers) {
	  webidl.argumentLengthCheck(arguments, 1, { header: 'getSetCookies' });

	  webidl.brandCheck(headers, Headers, { strict: false });

	  const cookies = headers.getSetCookie();

	  if (!cookies) {
	    return []
	  }

	  return cookies.map((pair) => parseSetCookie(pair))
	}

	/**
	 * @param {Headers} headers
	 * @param {Cookie} cookie
	 * @returns {void}
	 */
	function setCookie (headers, cookie) {
	  webidl.argumentLengthCheck(arguments, 2, { header: 'setCookie' });

	  webidl.brandCheck(headers, Headers, { strict: false });

	  cookie = webidl.converters.Cookie(cookie);

	  const str = stringify(cookie);

	  if (str) {
	    headers.append('Set-Cookie', stringify(cookie));
	  }
	}

	webidl.converters.DeleteCookieAttributes = webidl.dictionaryConverter([
	  {
	    converter: webidl.nullableConverter(webidl.converters.DOMString),
	    key: 'path',
	    defaultValue: null
	  },
	  {
	    converter: webidl.nullableConverter(webidl.converters.DOMString),
	    key: 'domain',
	    defaultValue: null
	  }
	]);

	webidl.converters.Cookie = webidl.dictionaryConverter([
	  {
	    converter: webidl.converters.DOMString,
	    key: 'name'
	  },
	  {
	    converter: webidl.converters.DOMString,
	    key: 'value'
	  },
	  {
	    converter: webidl.nullableConverter((value) => {
	      if (typeof value === 'number') {
	        return webidl.converters['unsigned long long'](value)
	      }

	      return new Date(value)
	    }),
	    key: 'expires',
	    defaultValue: null
	  },
	  {
	    converter: webidl.nullableConverter(webidl.converters['long long']),
	    key: 'maxAge',
	    defaultValue: null
	  },
	  {
	    converter: webidl.nullableConverter(webidl.converters.DOMString),
	    key: 'domain',
	    defaultValue: null
	  },
	  {
	    converter: webidl.nullableConverter(webidl.converters.DOMString),
	    key: 'path',
	    defaultValue: null
	  },
	  {
	    converter: webidl.nullableConverter(webidl.converters.boolean),
	    key: 'secure',
	    defaultValue: null
	  },
	  {
	    converter: webidl.nullableConverter(webidl.converters.boolean),
	    key: 'httpOnly',
	    defaultValue: null
	  },
	  {
	    converter: webidl.converters.USVString,
	    key: 'sameSite',
	    allowedValues: ['Strict', 'Lax', 'None']
	  },
	  {
	    converter: webidl.sequenceConverter(webidl.converters.DOMString),
	    key: 'unparsed',
	    defaultValue: []
	  }
	]);

	cookies = {
	  getCookies,
	  deleteCookie,
	  getSetCookies,
	  setCookie
	};
	return cookies;
}

var constants$2;
var hasRequiredConstants$2;

function requireConstants$2 () {
	if (hasRequiredConstants$2) return constants$2;
	hasRequiredConstants$2 = 1;

	// This is a Globally Unique Identifier unique used
	// to validate that the endpoint accepts websocket
	// connections.
	// See https://www.rfc-editor.org/rfc/rfc6455.html#section-1.3
	const uid = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11';

	/** @type {PropertyDescriptor} */
	const staticPropertyDescriptors = {
	  enumerable: true,
	  writable: false,
	  configurable: false
	};

	const states = {
	  CONNECTING: 0,
	  OPEN: 1,
	  CLOSING: 2,
	  CLOSED: 3
	};

	const opcodes = {
	  CONTINUATION: 0x0,
	  TEXT: 0x1,
	  BINARY: 0x2,
	  CLOSE: 0x8,
	  PING: 0x9,
	  PONG: 0xA
	};

	const maxUnsigned16Bit = 2 ** 16 - 1; // 65535

	const parserStates = {
	  INFO: 0,
	  PAYLOADLENGTH_16: 2,
	  PAYLOADLENGTH_64: 3,
	  READ_DATA: 4
	};

	const emptyBuffer = Buffer.allocUnsafe(0);

	constants$2 = {
	  uid,
	  staticPropertyDescriptors,
	  states,
	  opcodes,
	  maxUnsigned16Bit,
	  parserStates,
	  emptyBuffer
	};
	return constants$2;
}

var symbols;
var hasRequiredSymbols;

function requireSymbols () {
	if (hasRequiredSymbols) return symbols;
	hasRequiredSymbols = 1;

	symbols = {
	  kWebSocketURL: Symbol('url'),
	  kReadyState: Symbol('ready state'),
	  kController: Symbol('controller'),
	  kResponse: Symbol('response'),
	  kBinaryType: Symbol('binary type'),
	  kSentClose: Symbol('sent close'),
	  kReceivedClose: Symbol('received close'),
	  kByteParser: Symbol('byte parser')
	};
	return symbols;
}

var events;
var hasRequiredEvents;

function requireEvents () {
	if (hasRequiredEvents) return events;
	hasRequiredEvents = 1;

	const { webidl } = requireWebidl();
	const { kEnumerableProperty } = requireUtil$6();
	const { MessagePort } = require$$0$8;

	/**
	 * @see https://html.spec.whatwg.org/multipage/comms.html#messageevent
	 */
	class MessageEvent extends Event {
	  #eventInit

	  constructor (type, eventInitDict = {}) {
	    webidl.argumentLengthCheck(arguments, 1, { header: 'MessageEvent constructor' });

	    type = webidl.converters.DOMString(type);
	    eventInitDict = webidl.converters.MessageEventInit(eventInitDict);

	    super(type, eventInitDict);

	    this.#eventInit = eventInitDict;
	  }

	  get data () {
	    webidl.brandCheck(this, MessageEvent);

	    return this.#eventInit.data
	  }

	  get origin () {
	    webidl.brandCheck(this, MessageEvent);

	    return this.#eventInit.origin
	  }

	  get lastEventId () {
	    webidl.brandCheck(this, MessageEvent);

	    return this.#eventInit.lastEventId
	  }

	  get source () {
	    webidl.brandCheck(this, MessageEvent);

	    return this.#eventInit.source
	  }

	  get ports () {
	    webidl.brandCheck(this, MessageEvent);

	    if (!Object.isFrozen(this.#eventInit.ports)) {
	      Object.freeze(this.#eventInit.ports);
	    }

	    return this.#eventInit.ports
	  }

	  initMessageEvent (
	    type,
	    bubbles = false,
	    cancelable = false,
	    data = null,
	    origin = '',
	    lastEventId = '',
	    source = null,
	    ports = []
	  ) {
	    webidl.brandCheck(this, MessageEvent);

	    webidl.argumentLengthCheck(arguments, 1, { header: 'MessageEvent.initMessageEvent' });

	    return new MessageEvent(type, {
	      bubbles, cancelable, data, origin, lastEventId, source, ports
	    })
	  }
	}

	/**
	 * @see https://websockets.spec.whatwg.org/#the-closeevent-interface
	 */
	class CloseEvent extends Event {
	  #eventInit

	  constructor (type, eventInitDict = {}) {
	    webidl.argumentLengthCheck(arguments, 1, { header: 'CloseEvent constructor' });

	    type = webidl.converters.DOMString(type);
	    eventInitDict = webidl.converters.CloseEventInit(eventInitDict);

	    super(type, eventInitDict);

	    this.#eventInit = eventInitDict;
	  }

	  get wasClean () {
	    webidl.brandCheck(this, CloseEvent);

	    return this.#eventInit.wasClean
	  }

	  get code () {
	    webidl.brandCheck(this, CloseEvent);

	    return this.#eventInit.code
	  }

	  get reason () {
	    webidl.brandCheck(this, CloseEvent);

	    return this.#eventInit.reason
	  }
	}

	// https://html.spec.whatwg.org/multipage/webappapis.html#the-errorevent-interface
	class ErrorEvent extends Event {
	  #eventInit

	  constructor (type, eventInitDict) {
	    webidl.argumentLengthCheck(arguments, 1, { header: 'ErrorEvent constructor' });

	    super(type, eventInitDict);

	    type = webidl.converters.DOMString(type);
	    eventInitDict = webidl.converters.ErrorEventInit(eventInitDict ?? {});

	    this.#eventInit = eventInitDict;
	  }

	  get message () {
	    webidl.brandCheck(this, ErrorEvent);

	    return this.#eventInit.message
	  }

	  get filename () {
	    webidl.brandCheck(this, ErrorEvent);

	    return this.#eventInit.filename
	  }

	  get lineno () {
	    webidl.brandCheck(this, ErrorEvent);

	    return this.#eventInit.lineno
	  }

	  get colno () {
	    webidl.brandCheck(this, ErrorEvent);

	    return this.#eventInit.colno
	  }

	  get error () {
	    webidl.brandCheck(this, ErrorEvent);

	    return this.#eventInit.error
	  }
	}

	Object.defineProperties(MessageEvent.prototype, {
	  [Symbol.toStringTag]: {
	    value: 'MessageEvent',
	    configurable: true
	  },
	  data: kEnumerableProperty,
	  origin: kEnumerableProperty,
	  lastEventId: kEnumerableProperty,
	  source: kEnumerableProperty,
	  ports: kEnumerableProperty,
	  initMessageEvent: kEnumerableProperty
	});

	Object.defineProperties(CloseEvent.prototype, {
	  [Symbol.toStringTag]: {
	    value: 'CloseEvent',
	    configurable: true
	  },
	  reason: kEnumerableProperty,
	  code: kEnumerableProperty,
	  wasClean: kEnumerableProperty
	});

	Object.defineProperties(ErrorEvent.prototype, {
	  [Symbol.toStringTag]: {
	    value: 'ErrorEvent',
	    configurable: true
	  },
	  message: kEnumerableProperty,
	  filename: kEnumerableProperty,
	  lineno: kEnumerableProperty,
	  colno: kEnumerableProperty,
	  error: kEnumerableProperty
	});

	webidl.converters.MessagePort = webidl.interfaceConverter(MessagePort);

	webidl.converters['sequence<MessagePort>'] = webidl.sequenceConverter(
	  webidl.converters.MessagePort
	);

	const eventInit = [
	  {
	    key: 'bubbles',
	    converter: webidl.converters.boolean,
	    defaultValue: false
	  },
	  {
	    key: 'cancelable',
	    converter: webidl.converters.boolean,
	    defaultValue: false
	  },
	  {
	    key: 'composed',
	    converter: webidl.converters.boolean,
	    defaultValue: false
	  }
	];

	webidl.converters.MessageEventInit = webidl.dictionaryConverter([
	  ...eventInit,
	  {
	    key: 'data',
	    converter: webidl.converters.any,
	    defaultValue: null
	  },
	  {
	    key: 'origin',
	    converter: webidl.converters.USVString,
	    defaultValue: ''
	  },
	  {
	    key: 'lastEventId',
	    converter: webidl.converters.DOMString,
	    defaultValue: ''
	  },
	  {
	    key: 'source',
	    // Node doesn't implement WindowProxy or ServiceWorker, so the only
	    // valid value for source is a MessagePort.
	    converter: webidl.nullableConverter(webidl.converters.MessagePort),
	    defaultValue: null
	  },
	  {
	    key: 'ports',
	    converter: webidl.converters['sequence<MessagePort>'],
	    get defaultValue () {
	      return []
	    }
	  }
	]);

	webidl.converters.CloseEventInit = webidl.dictionaryConverter([
	  ...eventInit,
	  {
	    key: 'wasClean',
	    converter: webidl.converters.boolean,
	    defaultValue: false
	  },
	  {
	    key: 'code',
	    converter: webidl.converters['unsigned short'],
	    defaultValue: 0
	  },
	  {
	    key: 'reason',
	    converter: webidl.converters.USVString,
	    defaultValue: ''
	  }
	]);

	webidl.converters.ErrorEventInit = webidl.dictionaryConverter([
	  ...eventInit,
	  {
	    key: 'message',
	    converter: webidl.converters.DOMString,
	    defaultValue: ''
	  },
	  {
	    key: 'filename',
	    converter: webidl.converters.USVString,
	    defaultValue: ''
	  },
	  {
	    key: 'lineno',
	    converter: webidl.converters['unsigned long'],
	    defaultValue: 0
	  },
	  {
	    key: 'colno',
	    converter: webidl.converters['unsigned long'],
	    defaultValue: 0
	  },
	  {
	    key: 'error',
	    converter: webidl.converters.any
	  }
	]);

	events = {
	  MessageEvent,
	  CloseEvent,
	  ErrorEvent
	};
	return events;
}

var util;
var hasRequiredUtil;

function requireUtil () {
	if (hasRequiredUtil) return util;
	hasRequiredUtil = 1;

	const { kReadyState, kController, kResponse, kBinaryType, kWebSocketURL } = requireSymbols();
	const { states, opcodes } = requireConstants$2();
	const { MessageEvent, ErrorEvent } = requireEvents();

	/* globals Blob */

	/**
	 * @param {import('./websocket').WebSocket} ws
	 */
	function isEstablished (ws) {
	  // If the server's response is validated as provided for above, it is
	  // said that _The WebSocket Connection is Established_ and that the
	  // WebSocket Connection is in the OPEN state.
	  return ws[kReadyState] === states.OPEN
	}

	/**
	 * @param {import('./websocket').WebSocket} ws
	 */
	function isClosing (ws) {
	  // Upon either sending or receiving a Close control frame, it is said
	  // that _The WebSocket Closing Handshake is Started_ and that the
	  // WebSocket connection is in the CLOSING state.
	  return ws[kReadyState] === states.CLOSING
	}

	/**
	 * @param {import('./websocket').WebSocket} ws
	 */
	function isClosed (ws) {
	  return ws[kReadyState] === states.CLOSED
	}

	/**
	 * @see https://dom.spec.whatwg.org/#concept-event-fire
	 * @param {string} e
	 * @param {EventTarget} target
	 * @param {EventInit | undefined} eventInitDict
	 */
	function fireEvent (e, target, eventConstructor = Event, eventInitDict) {
	  // 1. If eventConstructor is not given, then let eventConstructor be Event.

	  // 2. Let event be the result of creating an event given eventConstructor,
	  //    in the relevant realm of target.
	  // 3. Initialize events type attribute to e.
	  const event = new eventConstructor(e, eventInitDict); // eslint-disable-line new-cap

	  // 4. Initialize any other IDL attributes of event as described in the
	  //    invocation of this algorithm.

	  // 5. Return the result of dispatching event at target, with legacy target
	  //    override flag set if set.
	  target.dispatchEvent(event);
	}

	/**
	 * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
	 * @param {import('./websocket').WebSocket} ws
	 * @param {number} type Opcode
	 * @param {Buffer} data application data
	 */
	function websocketMessageReceived (ws, type, data) {
	  // 1. If ready state is not OPEN (1), then return.
	  if (ws[kReadyState] !== states.OPEN) {
	    return
	  }

	  // 2. Let dataForEvent be determined by switching on type and binary type:
	  let dataForEvent;

	  if (type === opcodes.TEXT) {
	    // -> type indicates that the data is Text
	    //      a new DOMString containing data
	    try {
	      dataForEvent = new TextDecoder('utf-8', { fatal: true }).decode(data);
	    } catch {
	      failWebsocketConnection(ws, 'Received invalid UTF-8 in text frame.');
	      return
	    }
	  } else if (type === opcodes.BINARY) {
	    if (ws[kBinaryType] === 'blob') {
	      // -> type indicates that the data is Binary and binary type is "blob"
	      //      a new Blob object, created in the relevant Realm of the WebSocket
	      //      object, that represents data as its raw data
	      dataForEvent = new Blob([data]);
	    } else {
	      // -> type indicates that the data is Binary and binary type is "arraybuffer"
	      //      a new ArrayBuffer object, created in the relevant Realm of the
	      //      WebSocket object, whose contents are data
	      dataForEvent = new Uint8Array(data).buffer;
	    }
	  }

	  // 3. Fire an event named message at the WebSocket object, using MessageEvent,
	  //    with the origin attribute initialized to the serialization of the WebSocket
	  //    objects url's origin, and the data attribute initialized to dataForEvent.
	  fireEvent('message', ws, MessageEvent, {
	    origin: ws[kWebSocketURL].origin,
	    data: dataForEvent
	  });
	}

	/**
	 * @see https://datatracker.ietf.org/doc/html/rfc6455
	 * @see https://datatracker.ietf.org/doc/html/rfc2616
	 * @see https://bugs.chromium.org/p/chromium/issues/detail?id=398407
	 * @param {string} protocol
	 */
	function isValidSubprotocol (protocol) {
	  // If present, this value indicates one
	  // or more comma-separated subprotocol the client wishes to speak,
	  // ordered by preference.  The elements that comprise this value
	  // MUST be non-empty strings with characters in the range U+0021 to
	  // U+007E not including separator characters as defined in
	  // [RFC2616] and MUST all be unique strings.
	  if (protocol.length === 0) {
	    return false
	  }

	  for (const char of protocol) {
	    const code = char.charCodeAt(0);

	    if (
	      code < 0x21 ||
	      code > 0x7E ||
	      char === '(' ||
	      char === ')' ||
	      char === '<' ||
	      char === '>' ||
	      char === '@' ||
	      char === ',' ||
	      char === ';' ||
	      char === ':' ||
	      char === '\\' ||
	      char === '"' ||
	      char === '/' ||
	      char === '[' ||
	      char === ']' ||
	      char === '?' ||
	      char === '=' ||
	      char === '{' ||
	      char === '}' ||
	      code === 32 || // SP
	      code === 9 // HT
	    ) {
	      return false
	    }
	  }

	  return true
	}

	/**
	 * @see https://datatracker.ietf.org/doc/html/rfc6455#section-7-4
	 * @param {number} code
	 */
	function isValidStatusCode (code) {
	  if (code >= 1000 && code < 1015) {
	    return (
	      code !== 1004 && // reserved
	      code !== 1005 && // "MUST NOT be set as a status code"
	      code !== 1006 // "MUST NOT be set as a status code"
	    )
	  }

	  return code >= 3000 && code <= 4999
	}

	/**
	 * @param {import('./websocket').WebSocket} ws
	 * @param {string|undefined} reason
	 */
	function failWebsocketConnection (ws, reason) {
	  const { [kController]: controller, [kResponse]: response } = ws;

	  controller.abort();

	  if (response?.socket && !response.socket.destroyed) {
	    response.socket.destroy();
	  }

	  if (reason) {
	    fireEvent('error', ws, ErrorEvent, {
	      error: new Error(reason)
	    });
	  }
	}

	util = {
	  isEstablished,
	  isClosing,
	  isClosed,
	  fireEvent,
	  isValidSubprotocol,
	  isValidStatusCode,
	  failWebsocketConnection,
	  websocketMessageReceived
	};
	return util;
}

var connection;
var hasRequiredConnection;

function requireConnection () {
	if (hasRequiredConnection) return connection;
	hasRequiredConnection = 1;

	const diagnosticsChannel = require$$0$9;
	const { uid, states } = requireConstants$2();
	const {
	  kReadyState,
	  kSentClose,
	  kByteParser,
	  kReceivedClose
	} = requireSymbols();
	const { fireEvent, failWebsocketConnection } = requireUtil();
	const { CloseEvent } = requireEvents();
	const { makeRequest } = requireRequest();
	const { fetching } = requireFetch();
	const { Headers } = requireHeaders();
	const { getGlobalDispatcher } = requireGlobal();
	const { kHeadersList } = requireSymbols$4();

	const channels = {};
	channels.open = diagnosticsChannel.channel('undici:websocket:open');
	channels.close = diagnosticsChannel.channel('undici:websocket:close');
	channels.socketError = diagnosticsChannel.channel('undici:websocket:socket_error');

	/** @type {import('crypto')} */
	let crypto;
	try {
	  crypto = require('crypto');
	} catch {

	}

	/**
	 * @see https://websockets.spec.whatwg.org/#concept-websocket-establish
	 * @param {URL} url
	 * @param {string|string[]} protocols
	 * @param {import('./websocket').WebSocket} ws
	 * @param {(response: any) => void} onEstablish
	 * @param {Partial<import('../../types/websocket').WebSocketInit>} options
	 */
	function establishWebSocketConnection (url, protocols, ws, onEstablish, options) {
	  // 1. Let requestURL be a copy of url, with its scheme set to "http", if urls
	  //    scheme is "ws", and to "https" otherwise.
	  const requestURL = url;

	  requestURL.protocol = url.protocol === 'ws:' ? 'http:' : 'https:';

	  // 2. Let request be a new request, whose URL is requestURL, client is client,
	  //    service-workers mode is "none", referrer is "no-referrer", mode is
	  //    "websocket", credentials mode is "include", cache mode is "no-store" ,
	  //    and redirect mode is "error".
	  const request = makeRequest({
	    urlList: [requestURL],
	    serviceWorkers: 'none',
	    referrer: 'no-referrer',
	    mode: 'websocket',
	    credentials: 'include',
	    cache: 'no-store',
	    redirect: 'error'
	  });

	  // Note: undici extension, allow setting custom headers.
	  if (options.headers) {
	    const headersList = new Headers(options.headers)[kHeadersList];

	    request.headersList = headersList;
	  }

	  // 3. Append (`Upgrade`, `websocket`) to requests header list.
	  // 4. Append (`Connection`, `Upgrade`) to requests header list.
	  // Note: both of these are handled by undici currently.
	  // https://github.com/nodejs/undici/blob/68c269c4144c446f3f1220951338daef4a6b5ec4/lib/client.js#L1397

	  // 5. Let keyValue be a nonce consisting of a randomly selected
	  //    16-byte value that has been forgiving-base64-encoded and
	  //    isomorphic encoded.
	  const keyValue = crypto.randomBytes(16).toString('base64');

	  // 6. Append (`Sec-WebSocket-Key`, keyValue) to requests
	  //    header list.
	  request.headersList.append('sec-websocket-key', keyValue);

	  // 7. Append (`Sec-WebSocket-Version`, `13`) to requests
	  //    header list.
	  request.headersList.append('sec-websocket-version', '13');

	  // 8. For each protocol in protocols, combine
	  //    (`Sec-WebSocket-Protocol`, protocol) in requests header
	  //    list.
	  for (const protocol of protocols) {
	    request.headersList.append('sec-websocket-protocol', protocol);
	  }

	  // 9. Let permessageDeflate be a user-agent defined
	  //    "permessage-deflate" extension header value.
	  // https://github.com/mozilla/gecko-dev/blob/ce78234f5e653a5d3916813ff990f053510227bc/netwerk/protocol/websocket/WebSocketChannel.cpp#L2673
	  // TODO: enable once permessage-deflate is supported
	  const permessageDeflate = ''; // 'permessage-deflate; 15'

	  // 10. Append (`Sec-WebSocket-Extensions`, permessageDeflate) to
	  //     requests header list.
	  // request.headersList.append('sec-websocket-extensions', permessageDeflate)

	  // 11. Fetch request with useParallelQueue set to true, and
	  //     processResponse given response being these steps:
	  const controller = fetching({
	    request,
	    useParallelQueue: true,
	    dispatcher: options.dispatcher ?? getGlobalDispatcher(),
	    processResponse (response) {
	      // 1. If response is a network error or its status is not 101,
	      //    fail the WebSocket connection.
	      if (response.type === 'error' || response.status !== 101) {
	        failWebsocketConnection(ws, 'Received network error or non-101 status code.');
	        return
	      }

	      // 2. If protocols is not the empty list and extracting header
	      //    list values given `Sec-WebSocket-Protocol` and responses
	      //    header list results in null, failure, or the empty byte
	      //    sequence, then fail the WebSocket connection.
	      if (protocols.length !== 0 && !response.headersList.get('Sec-WebSocket-Protocol')) {
	        failWebsocketConnection(ws, 'Server did not respond with sent protocols.');
	        return
	      }

	      // 3. Follow the requirements stated step 2 to step 6, inclusive,
	      //    of the last set of steps in section 4.1 of The WebSocket
	      //    Protocol to validate response. This either results in fail
	      //    the WebSocket connection or the WebSocket connection is
	      //    established.

	      // 2. If the response lacks an |Upgrade| header field or the |Upgrade|
	      //    header field contains a value that is not an ASCII case-
	      //    insensitive match for the value "websocket", the client MUST
	      //    _Fail the WebSocket Connection_.
	      if (response.headersList.get('Upgrade')?.toLowerCase() !== 'websocket') {
	        failWebsocketConnection(ws, 'Server did not set Upgrade header to "websocket".');
	        return
	      }

	      // 3. If the response lacks a |Connection| header field or the
	      //    |Connection| header field doesn't contain a token that is an
	      //    ASCII case-insensitive match for the value "Upgrade", the client
	      //    MUST _Fail the WebSocket Connection_.
	      if (response.headersList.get('Connection')?.toLowerCase() !== 'upgrade') {
	        failWebsocketConnection(ws, 'Server did not set Connection header to "upgrade".');
	        return
	      }

	      // 4. If the response lacks a |Sec-WebSocket-Accept| header field or
	      //    the |Sec-WebSocket-Accept| contains a value other than the
	      //    base64-encoded SHA-1 of the concatenation of the |Sec-WebSocket-
	      //    Key| (as a string, not base64-decoded) with the string "258EAFA5-
	      //    E914-47DA-95CA-C5AB0DC85B11" but ignoring any leading and
	      //    trailing whitespace, the client MUST _Fail the WebSocket
	      //    Connection_.
	      const secWSAccept = response.headersList.get('Sec-WebSocket-Accept');
	      const digest = crypto.createHash('sha1').update(keyValue + uid).digest('base64');
	      if (secWSAccept !== digest) {
	        failWebsocketConnection(ws, 'Incorrect hash received in Sec-WebSocket-Accept header.');
	        return
	      }

	      // 5. If the response includes a |Sec-WebSocket-Extensions| header
	      //    field and this header field indicates the use of an extension
	      //    that was not present in the client's handshake (the server has
	      //    indicated an extension not requested by the client), the client
	      //    MUST _Fail the WebSocket Connection_.  (The parsing of this
	      //    header field to determine which extensions are requested is
	      //    discussed in Section 9.1.)
	      const secExtension = response.headersList.get('Sec-WebSocket-Extensions');

	      if (secExtension !== null && secExtension !== permessageDeflate) {
	        failWebsocketConnection(ws, 'Received different permessage-deflate than the one set.');
	        return
	      }

	      // 6. If the response includes a |Sec-WebSocket-Protocol| header field
	      //    and this header field indicates the use of a subprotocol that was
	      //    not present in the client's handshake (the server has indicated a
	      //    subprotocol not requested by the client), the client MUST _Fail
	      //    the WebSocket Connection_.
	      const secProtocol = response.headersList.get('Sec-WebSocket-Protocol');

	      if (secProtocol !== null && secProtocol !== request.headersList.get('Sec-WebSocket-Protocol')) {
	        failWebsocketConnection(ws, 'Protocol was not set in the opening handshake.');
	        return
	      }

	      response.socket.on('data', onSocketData);
	      response.socket.on('close', onSocketClose);
	      response.socket.on('error', onSocketError);

	      if (channels.open.hasSubscribers) {
	        channels.open.publish({
	          address: response.socket.address(),
	          protocol: secProtocol,
	          extensions: secExtension
	        });
	      }

	      onEstablish(response);
	    }
	  });

	  return controller
	}

	/**
	 * @param {Buffer} chunk
	 */
	function onSocketData (chunk) {
	  if (!this.ws[kByteParser].write(chunk)) {
	    this.pause();
	  }
	}

	/**
	 * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
	 * @see https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.4
	 */
	function onSocketClose () {
	  const { ws } = this;

	  // If the TCP connection was closed after the
	  // WebSocket closing handshake was completed, the WebSocket connection
	  // is said to have been closed _cleanly_.
	  const wasClean = ws[kSentClose] && ws[kReceivedClose];

	  let code = 1005;
	  let reason = '';

	  const result = ws[kByteParser].closingInfo;

	  if (result) {
	    code = result.code ?? 1005;
	    reason = result.reason;
	  } else if (!ws[kSentClose]) {
	    // If _The WebSocket
	    // Connection is Closed_ and no Close control frame was received by the
	    // endpoint (such as could occur if the underlying transport connection
	    // is lost), _The WebSocket Connection Close Code_ is considered to be
	    // 1006.
	    code = 1006;
	  }

	  // 1. Change the ready state to CLOSED (3).
	  ws[kReadyState] = states.CLOSED;

	  // 2. If the user agent was required to fail the WebSocket
	  //    connection, or if the WebSocket connection was closed
	  //    after being flagged as full, fire an event named error
	  //    at the WebSocket object.
	  // TODO

	  // 3. Fire an event named close at the WebSocket object,
	  //    using CloseEvent, with the wasClean attribute
	  //    initialized to true if the connection closed cleanly
	  //    and false otherwise, the code attribute initialized to
	  //    the WebSocket connection close code, and the reason
	  //    attribute initialized to the result of applying UTF-8
	  //    decode without BOM to the WebSocket connection close
	  //    reason.
	  fireEvent('close', ws, CloseEvent, {
	    wasClean, code, reason
	  });

	  if (channels.close.hasSubscribers) {
	    channels.close.publish({
	      websocket: ws,
	      code,
	      reason
	    });
	  }
	}

	function onSocketError (error) {
	  const { ws } = this;

	  ws[kReadyState] = states.CLOSING;

	  if (channels.socketError.hasSubscribers) {
	    channels.socketError.publish(error);
	  }

	  this.destroy();
	}

	connection = {
	  establishWebSocketConnection
	};
	return connection;
}

var frame;
var hasRequiredFrame;

function requireFrame () {
	if (hasRequiredFrame) return frame;
	hasRequiredFrame = 1;

	const { maxUnsigned16Bit } = requireConstants$2();

	/** @type {import('crypto')} */
	let crypto;
	try {
	  crypto = require('crypto');
	} catch {

	}

	class WebsocketFrameSend {
	  /**
	   * @param {Buffer|undefined} data
	   */
	  constructor (data) {
	    this.frameData = data;
	    this.maskKey = crypto.randomBytes(4);
	  }

	  createFrame (opcode) {
	    const bodyLength = this.frameData?.byteLength ?? 0;

	    /** @type {number} */
	    let payloadLength = bodyLength; // 0-125
	    let offset = 6;

	    if (bodyLength > maxUnsigned16Bit) {
	      offset += 8; // payload length is next 8 bytes
	      payloadLength = 127;
	    } else if (bodyLength > 125) {
	      offset += 2; // payload length is next 2 bytes
	      payloadLength = 126;
	    }

	    const buffer = Buffer.allocUnsafe(bodyLength + offset);

	    // Clear first 2 bytes, everything else is overwritten
	    buffer[0] = buffer[1] = 0;
	    buffer[0] |= 0x80; // FIN
	    buffer[0] = (buffer[0] & 0xF0) + opcode; // opcode

	    /*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> */
	    buffer[offset - 4] = this.maskKey[0];
	    buffer[offset - 3] = this.maskKey[1];
	    buffer[offset - 2] = this.maskKey[2];
	    buffer[offset - 1] = this.maskKey[3];

	    buffer[1] = payloadLength;

	    if (payloadLength === 126) {
	      buffer.writeUInt16BE(bodyLength, 2);
	    } else if (payloadLength === 127) {
	      // Clear extended payload length
	      buffer[2] = buffer[3] = 0;
	      buffer.writeUIntBE(bodyLength, 4, 6);
	    }

	    buffer[1] |= 0x80; // MASK

	    // mask body
	    for (let i = 0; i < bodyLength; i++) {
	      buffer[offset + i] = this.frameData[i] ^ this.maskKey[i % 4];
	    }

	    return buffer
	  }
	}

	frame = {
	  WebsocketFrameSend
	};
	return frame;
}

var receiver$1;
var hasRequiredReceiver$1;

function requireReceiver$1 () {
	if (hasRequiredReceiver$1) return receiver$1;
	hasRequiredReceiver$1 = 1;

	const { Writable } = require$$0$6;
	const diagnosticsChannel = require$$0$9;
	const { parserStates, opcodes, states, emptyBuffer } = requireConstants$2();
	const { kReadyState, kSentClose, kResponse, kReceivedClose } = requireSymbols();
	const { isValidStatusCode, failWebsocketConnection, websocketMessageReceived } = requireUtil();
	const { WebsocketFrameSend } = requireFrame();

	// This code was influenced by ws released under the MIT license.
	// Copyright (c) 2011 Einar Otto Stangvik <einaros@gmail.com>
	// Copyright (c) 2013 Arnout Kazemier and contributors
	// Copyright (c) 2016 Luigi Pinca and contributors

	const channels = {};
	channels.ping = diagnosticsChannel.channel('undici:websocket:ping');
	channels.pong = diagnosticsChannel.channel('undici:websocket:pong');

	class ByteParser extends Writable {
	  #buffers = []
	  #byteOffset = 0

	  #state = parserStates.INFO

	  #info = {}
	  #fragments = []

	  constructor (ws) {
	    super();

	    this.ws = ws;
	  }

	  /**
	   * @param {Buffer} chunk
	   * @param {() => void} callback
	   */
	  _write (chunk, _, callback) {
	    this.#buffers.push(chunk);
	    this.#byteOffset += chunk.length;

	    this.run(callback);
	  }

	  /**
	   * Runs whenever a new chunk is received.
	   * Callback is called whenever there are no more chunks buffering,
	   * or not enough bytes are buffered to parse.
	   */
	  run (callback) {
	    while (true) {
	      if (this.#state === parserStates.INFO) {
	        // If there aren't enough bytes to parse the payload length, etc.
	        if (this.#byteOffset < 2) {
	          return callback()
	        }

	        const buffer = this.consume(2);

	        this.#info.fin = (buffer[0] & 0x80) !== 0;
	        this.#info.opcode = buffer[0] & 0x0F;

	        // If we receive a fragmented message, we use the type of the first
	        // frame to parse the full message as binary/text, when it's terminated
	        this.#info.originalOpcode ??= this.#info.opcode;

	        this.#info.fragmented = !this.#info.fin && this.#info.opcode !== opcodes.CONTINUATION;

	        if (this.#info.fragmented && this.#info.opcode !== opcodes.BINARY && this.#info.opcode !== opcodes.TEXT) {
	          // Only text and binary frames can be fragmented
	          failWebsocketConnection(this.ws, 'Invalid frame type was fragmented.');
	          return
	        }

	        const payloadLength = buffer[1] & 0x7F;

	        if (payloadLength <= 125) {
	          this.#info.payloadLength = payloadLength;
	          this.#state = parserStates.READ_DATA;
	        } else if (payloadLength === 126) {
	          this.#state = parserStates.PAYLOADLENGTH_16;
	        } else if (payloadLength === 127) {
	          this.#state = parserStates.PAYLOADLENGTH_64;
	        }

	        if (this.#info.fragmented && payloadLength > 125) {
	          // A fragmented frame can't be fragmented itself
	          failWebsocketConnection(this.ws, 'Fragmented frame exceeded 125 bytes.');
	          return
	        } else if (
	          (this.#info.opcode === opcodes.PING ||
	            this.#info.opcode === opcodes.PONG ||
	            this.#info.opcode === opcodes.CLOSE) &&
	          payloadLength > 125
	        ) {
	          // Control frames can have a payload length of 125 bytes MAX
	          failWebsocketConnection(this.ws, 'Payload length for control frame exceeded 125 bytes.');
	          return
	        } else if (this.#info.opcode === opcodes.CLOSE) {
	          if (payloadLength === 1) {
	            failWebsocketConnection(this.ws, 'Received close frame with a 1-byte body.');
	            return
	          }

	          const body = this.consume(payloadLength);

	          this.#info.closeInfo = this.parseCloseBody(false, body);

	          if (!this.ws[kSentClose]) {
	            // If an endpoint receives a Close frame and did not previously send a
	            // Close frame, the endpoint MUST send a Close frame in response.  (When
	            // sending a Close frame in response, the endpoint typically echos the
	            // status code it received.)
	            const body = Buffer.allocUnsafe(2);
	            body.writeUInt16BE(this.#info.closeInfo.code, 0);
	            const closeFrame = new WebsocketFrameSend(body);

	            this.ws[kResponse].socket.write(
	              closeFrame.createFrame(opcodes.CLOSE),
	              (err) => {
	                if (!err) {
	                  this.ws[kSentClose] = true;
	                }
	              }
	            );
	          }

	          // Upon either sending or receiving a Close control frame, it is said
	          // that _The WebSocket Closing Handshake is Started_ and that the
	          // WebSocket connection is in the CLOSING state.
	          this.ws[kReadyState] = states.CLOSING;
	          this.ws[kReceivedClose] = true;

	          this.end();

	          return
	        } else if (this.#info.opcode === opcodes.PING) {
	          // Upon receipt of a Ping frame, an endpoint MUST send a Pong frame in
	          // response, unless it already received a Close frame.
	          // A Pong frame sent in response to a Ping frame must have identical
	          // "Application data"

	          const body = this.consume(payloadLength);

	          if (!this.ws[kReceivedClose]) {
	            const frame = new WebsocketFrameSend(body);

	            this.ws[kResponse].socket.write(frame.createFrame(opcodes.PONG));

	            if (channels.ping.hasSubscribers) {
	              channels.ping.publish({
	                payload: body
	              });
	            }
	          }

	          this.#state = parserStates.INFO;

	          if (this.#byteOffset > 0) {
	            continue
	          } else {
	            callback();
	            return
	          }
	        } else if (this.#info.opcode === opcodes.PONG) {
	          // A Pong frame MAY be sent unsolicited.  This serves as a
	          // unidirectional heartbeat.  A response to an unsolicited Pong frame is
	          // not expected.

	          const body = this.consume(payloadLength);

	          if (channels.pong.hasSubscribers) {
	            channels.pong.publish({
	              payload: body
	            });
	          }

	          if (this.#byteOffset > 0) {
	            continue
	          } else {
	            callback();
	            return
	          }
	        }
	      } else if (this.#state === parserStates.PAYLOADLENGTH_16) {
	        if (this.#byteOffset < 2) {
	          return callback()
	        }

	        const buffer = this.consume(2);

	        this.#info.payloadLength = buffer.readUInt16BE(0);
	        this.#state = parserStates.READ_DATA;
	      } else if (this.#state === parserStates.PAYLOADLENGTH_64) {
	        if (this.#byteOffset < 8) {
	          return callback()
	        }

	        const buffer = this.consume(8);
	        const upper = buffer.readUInt32BE(0);

	        // 2^31 is the maxinimum bytes an arraybuffer can contain
	        // on 32-bit systems. Although, on 64-bit systems, this is
	        // 2^53-1 bytes.
	        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Invalid_array_length
	        // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/common/globals.h;drc=1946212ac0100668f14eb9e2843bdd846e510a1e;bpv=1;bpt=1;l=1275
	        // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/js-array-buffer.h;l=34;drc=1946212ac0100668f14eb9e2843bdd846e510a1e
	        if (upper > 2 ** 31 - 1) {
	          failWebsocketConnection(this.ws, 'Received payload length > 2^31 bytes.');
	          return
	        }

	        const lower = buffer.readUInt32BE(4);

	        this.#info.payloadLength = (upper << 8) + lower;
	        this.#state = parserStates.READ_DATA;
	      } else if (this.#state === parserStates.READ_DATA) {
	        if (this.#byteOffset < this.#info.payloadLength) {
	          // If there is still more data in this chunk that needs to be read
	          return callback()
	        } else if (this.#byteOffset >= this.#info.payloadLength) {
	          // If the server sent multiple frames in a single chunk

	          const body = this.consume(this.#info.payloadLength);

	          this.#fragments.push(body);

	          // If the frame is unfragmented, or a fragmented frame was terminated,
	          // a message was received
	          if (!this.#info.fragmented || (this.#info.fin && this.#info.opcode === opcodes.CONTINUATION)) {
	            const fullMessage = Buffer.concat(this.#fragments);

	            websocketMessageReceived(this.ws, this.#info.originalOpcode, fullMessage);

	            this.#info = {};
	            this.#fragments.length = 0;
	          }

	          this.#state = parserStates.INFO;
	        }
	      }

	      if (this.#byteOffset > 0) {
	        continue
	      } else {
	        callback();
	        break
	      }
	    }
	  }

	  /**
	   * Take n bytes from the buffered Buffers
	   * @param {number} n
	   * @returns {Buffer|null}
	   */
	  consume (n) {
	    if (n > this.#byteOffset) {
	      return null
	    } else if (n === 0) {
	      return emptyBuffer
	    }

	    if (this.#buffers[0].length === n) {
	      this.#byteOffset -= this.#buffers[0].length;
	      return this.#buffers.shift()
	    }

	    const buffer = Buffer.allocUnsafe(n);
	    let offset = 0;

	    while (offset !== n) {
	      const next = this.#buffers[0];
	      const { length } = next;

	      if (length + offset === n) {
	        buffer.set(this.#buffers.shift(), offset);
	        break
	      } else if (length + offset > n) {
	        buffer.set(next.subarray(0, n - offset), offset);
	        this.#buffers[0] = next.subarray(n - offset);
	        break
	      } else {
	        buffer.set(this.#buffers.shift(), offset);
	        offset += next.length;
	      }
	    }

	    this.#byteOffset -= n;

	    return buffer
	  }

	  parseCloseBody (onlyCode, data) {
	    // https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.5
	    /** @type {number|undefined} */
	    let code;

	    if (data.length >= 2) {
	      // _The WebSocket Connection Close Code_ is
	      // defined as the status code (Section 7.4) contained in the first Close
	      // control frame received by the application
	      code = data.readUInt16BE(0);
	    }

	    if (onlyCode) {
	      if (!isValidStatusCode(code)) {
	        return null
	      }

	      return { code }
	    }

	    // https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.6
	    /** @type {Buffer} */
	    let reason = data.subarray(2);

	    // Remove BOM
	    if (reason[0] === 0xEF && reason[1] === 0xBB && reason[2] === 0xBF) {
	      reason = reason.subarray(3);
	    }

	    if (code !== undefined && !isValidStatusCode(code)) {
	      return null
	    }

	    try {
	      // TODO: optimize this
	      reason = new TextDecoder('utf-8', { fatal: true }).decode(reason);
	    } catch {
	      return null
	    }

	    return { code, reason }
	  }

	  get closingInfo () {
	    return this.#info.closeInfo
	  }
	}

	receiver$1 = {
	  ByteParser
	};
	return receiver$1;
}

var websocket$1;
var hasRequiredWebsocket$1;

function requireWebsocket$1 () {
	if (hasRequiredWebsocket$1) return websocket$1;
	hasRequiredWebsocket$1 = 1;

	const { webidl } = requireWebidl();
	const { DOMException } = requireConstants$5();
	const { URLSerializer } = requireDataURL();
	const { getGlobalOrigin } = requireGlobal$1();
	const { staticPropertyDescriptors, states, opcodes, emptyBuffer } = requireConstants$2();
	const {
	  kWebSocketURL,
	  kReadyState,
	  kController,
	  kBinaryType,
	  kResponse,
	  kSentClose,
	  kByteParser
	} = requireSymbols();
	const { isEstablished, isClosing, isValidSubprotocol, failWebsocketConnection, fireEvent } = requireUtil();
	const { establishWebSocketConnection } = requireConnection();
	const { WebsocketFrameSend } = requireFrame();
	const { ByteParser } = requireReceiver$1();
	const { kEnumerableProperty, isBlobLike } = requireUtil$6();
	const { getGlobalDispatcher } = requireGlobal();
	const { types } = require$$0$2;

	let experimentalWarned = false;

	// https://websockets.spec.whatwg.org/#interface-definition
	class WebSocket extends EventTarget {
	  #events = {
	    open: null,
	    error: null,
	    close: null,
	    message: null
	  }

	  #bufferedAmount = 0
	  #protocol = ''
	  #extensions = ''

	  /**
	   * @param {string} url
	   * @param {string|string[]} protocols
	   */
	  constructor (url, protocols = []) {
	    super();

	    webidl.argumentLengthCheck(arguments, 1, { header: 'WebSocket constructor' });

	    if (!experimentalWarned) {
	      experimentalWarned = true;
	      process.emitWarning('WebSockets are experimental, expect them to change at any time.', {
	        code: 'UNDICI-WS'
	      });
	    }

	    const options = webidl.converters['DOMString or sequence<DOMString> or WebSocketInit'](protocols);

	    url = webidl.converters.USVString(url);
	    protocols = options.protocols;

	    // 1. Let baseURL be this's relevant settings object's API base URL.
	    const baseURL = getGlobalOrigin();

	    // 1. Let urlRecord be the result of applying the URL parser to url with baseURL.
	    let urlRecord;

	    try {
	      urlRecord = new URL(url, baseURL);
	    } catch (e) {
	      // 3. If urlRecord is failure, then throw a "SyntaxError" DOMException.
	      throw new DOMException(e, 'SyntaxError')
	    }

	    // 4. If urlRecords scheme is "http", then set urlRecords scheme to "ws".
	    if (urlRecord.protocol === 'http:') {
	      urlRecord.protocol = 'ws:';
	    } else if (urlRecord.protocol === 'https:') {
	      // 5. Otherwise, if urlRecords scheme is "https", set urlRecords scheme to "wss".
	      urlRecord.protocol = 'wss:';
	    }

	    // 6. If urlRecords scheme is not "ws" or "wss", then throw a "SyntaxError" DOMException.
	    if (urlRecord.protocol !== 'ws:' && urlRecord.protocol !== 'wss:') {
	      throw new DOMException(
	        `Expected a ws: or wss: protocol, got ${urlRecord.protocol}`,
	        'SyntaxError'
	      )
	    }

	    // 7. If urlRecords fragment is non-null, then throw a "SyntaxError"
	    //    DOMException.
	    if (urlRecord.hash || urlRecord.href.endsWith('#')) {
	      throw new DOMException('Got fragment', 'SyntaxError')
	    }

	    // 8. If protocols is a string, set protocols to a sequence consisting
	    //    of just that string.
	    if (typeof protocols === 'string') {
	      protocols = [protocols];
	    }

	    // 9. If any of the values in protocols occur more than once or otherwise
	    //    fail to match the requirements for elements that comprise the value
	    //    of `Sec-WebSocket-Protocol` fields as defined by The WebSocket
	    //    protocol, then throw a "SyntaxError" DOMException.
	    if (protocols.length !== new Set(protocols.map(p => p.toLowerCase())).size) {
	      throw new DOMException('Invalid Sec-WebSocket-Protocol value', 'SyntaxError')
	    }

	    if (protocols.length > 0 && !protocols.every(p => isValidSubprotocol(p))) {
	      throw new DOMException('Invalid Sec-WebSocket-Protocol value', 'SyntaxError')
	    }

	    // 10. Set this's url to urlRecord.
	    this[kWebSocketURL] = new URL(urlRecord.href);

	    // 11. Let client be this's relevant settings object.

	    // 12. Run this step in parallel:

	    //    1. Establish a WebSocket connection given urlRecord, protocols,
	    //       and client.
	    this[kController] = establishWebSocketConnection(
	      urlRecord,
	      protocols,
	      this,
	      (response) => this.#onConnectionEstablished(response),
	      options
	    );

	    // Each WebSocket object has an associated ready state, which is a
	    // number representing the state of the connection. Initially it must
	    // be CONNECTING (0).
	    this[kReadyState] = WebSocket.CONNECTING;

	    // The extensions attribute must initially return the empty string.

	    // The protocol attribute must initially return the empty string.

	    // Each WebSocket object has an associated binary type, which is a
	    // BinaryType. Initially it must be "blob".
	    this[kBinaryType] = 'blob';
	  }

	  /**
	   * @see https://websockets.spec.whatwg.org/#dom-websocket-close
	   * @param {number|undefined} code
	   * @param {string|undefined} reason
	   */
	  close (code = undefined, reason = undefined) {
	    webidl.brandCheck(this, WebSocket);

	    if (code !== undefined) {
	      code = webidl.converters['unsigned short'](code, { clamp: true });
	    }

	    if (reason !== undefined) {
	      reason = webidl.converters.USVString(reason);
	    }

	    // 1. If code is present, but is neither an integer equal to 1000 nor an
	    //    integer in the range 3000 to 4999, inclusive, throw an
	    //    "InvalidAccessError" DOMException.
	    if (code !== undefined) {
	      if (code !== 1000 && (code < 3000 || code > 4999)) {
	        throw new DOMException('invalid code', 'InvalidAccessError')
	      }
	    }

	    let reasonByteLength = 0;

	    // 2. If reason is present, then run these substeps:
	    if (reason !== undefined) {
	      // 1. Let reasonBytes be the result of encoding reason.
	      // 2. If reasonBytes is longer than 123 bytes, then throw a
	      //    "SyntaxError" DOMException.
	      reasonByteLength = Buffer.byteLength(reason);

	      if (reasonByteLength > 123) {
	        throw new DOMException(
	          `Reason must be less than 123 bytes; received ${reasonByteLength}`,
	          'SyntaxError'
	        )
	      }
	    }

	    // 3. Run the first matching steps from the following list:
	    if (this[kReadyState] === WebSocket.CLOSING || this[kReadyState] === WebSocket.CLOSED) ; else if (!isEstablished(this)) {
	      // If the WebSocket connection is not yet established
	      // Fail the WebSocket connection and set this's ready state
	      // to CLOSING (2).
	      failWebsocketConnection(this, 'Connection was closed before it was established.');
	      this[kReadyState] = WebSocket.CLOSING;
	    } else if (!isClosing(this)) {
	      // If the WebSocket closing handshake has not yet been started
	      // Start the WebSocket closing handshake and set this's ready
	      // state to CLOSING (2).
	      // - If neither code nor reason is present, the WebSocket Close
	      //   message must not have a body.
	      // - If code is present, then the status code to use in the
	      //   WebSocket Close message must be the integer given by code.
	      // - If reason is also present, then reasonBytes must be
	      //   provided in the Close message after the status code.

	      const frame = new WebsocketFrameSend();

	      // If neither code nor reason is present, the WebSocket Close
	      // message must not have a body.

	      // If code is present, then the status code to use in the
	      // WebSocket Close message must be the integer given by code.
	      if (code !== undefined && reason === undefined) {
	        frame.frameData = Buffer.allocUnsafe(2);
	        frame.frameData.writeUInt16BE(code, 0);
	      } else if (code !== undefined && reason !== undefined) {
	        // If reason is also present, then reasonBytes must be
	        // provided in the Close message after the status code.
	        frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength);
	        frame.frameData.writeUInt16BE(code, 0);
	        // the body MAY contain UTF-8-encoded data with value /reason/
	        frame.frameData.write(reason, 2, 'utf-8');
	      } else {
	        frame.frameData = emptyBuffer;
	      }

	      /** @type {import('stream').Duplex} */
	      const socket = this[kResponse].socket;

	      socket.write(frame.createFrame(opcodes.CLOSE), (err) => {
	        if (!err) {
	          this[kSentClose] = true;
	        }
	      });

	      // Upon either sending or receiving a Close control frame, it is said
	      // that _The WebSocket Closing Handshake is Started_ and that the
	      // WebSocket connection is in the CLOSING state.
	      this[kReadyState] = states.CLOSING;
	    } else {
	      // Otherwise
	      // Set this's ready state to CLOSING (2).
	      this[kReadyState] = WebSocket.CLOSING;
	    }
	  }

	  /**
	   * @see https://websockets.spec.whatwg.org/#dom-websocket-send
	   * @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data
	   */
	  send (data) {
	    webidl.brandCheck(this, WebSocket);

	    webidl.argumentLengthCheck(arguments, 1, { header: 'WebSocket.send' });

	    data = webidl.converters.WebSocketSendData(data);

	    // 1. If this's ready state is CONNECTING, then throw an
	    //    "InvalidStateError" DOMException.
	    if (this[kReadyState] === WebSocket.CONNECTING) {
	      throw new DOMException('Sent before connected.', 'InvalidStateError')
	    }

	    // 2. Run the appropriate set of steps from the following list:
	    // https://datatracker.ietf.org/doc/html/rfc6455#section-6.1
	    // https://datatracker.ietf.org/doc/html/rfc6455#section-5.2

	    if (!isEstablished(this) || isClosing(this)) {
	      return
	    }

	    /** @type {import('stream').Duplex} */
	    const socket = this[kResponse].socket;

	    // If data is a string
	    if (typeof data === 'string') {
	      // If the WebSocket connection is established and the WebSocket
	      // closing handshake has not yet started, then the user agent
	      // must send a WebSocket Message comprised of the data argument
	      // using a text frame opcode; if the data cannot be sent, e.g.
	      // because it would need to be buffered but the buffer is full,
	      // the user agent must flag the WebSocket as full and then close
	      // the WebSocket connection. Any invocation of this method with a
	      // string argument that does not throw an exception must increase
	      // the bufferedAmount attribute by the number of bytes needed to
	      // express the argument as UTF-8.

	      const value = Buffer.from(data);
	      const frame = new WebsocketFrameSend(value);
	      const buffer = frame.createFrame(opcodes.TEXT);

	      this.#bufferedAmount += value.byteLength;
	      socket.write(buffer, () => {
	        this.#bufferedAmount -= value.byteLength;
	      });
	    } else if (types.isArrayBuffer(data)) {
	      // If the WebSocket connection is established, and the WebSocket
	      // closing handshake has not yet started, then the user agent must
	      // send a WebSocket Message comprised of data using a binary frame
	      // opcode; if the data cannot be sent, e.g. because it would need
	      // to be buffered but the buffer is full, the user agent must flag
	      // the WebSocket as full and then close the WebSocket connection.
	      // The data to be sent is the data stored in the buffer described
	      // by the ArrayBuffer object. Any invocation of this method with an
	      // ArrayBuffer argument that does not throw an exception must
	      // increase the bufferedAmount attribute by the length of the
	      // ArrayBuffer in bytes.

	      const value = Buffer.from(data);
	      const frame = new WebsocketFrameSend(value);
	      const buffer = frame.createFrame(opcodes.BINARY);

	      this.#bufferedAmount += value.byteLength;
	      socket.write(buffer, () => {
	        this.#bufferedAmount -= value.byteLength;
	      });
	    } else if (ArrayBuffer.isView(data)) {
	      // If the WebSocket connection is established, and the WebSocket
	      // closing handshake has not yet started, then the user agent must
	      // send a WebSocket Message comprised of data using a binary frame
	      // opcode; if the data cannot be sent, e.g. because it would need to
	      // be buffered but the buffer is full, the user agent must flag the
	      // WebSocket as full and then close the WebSocket connection. The
	      // data to be sent is the data stored in the section of the buffer
	      // described by the ArrayBuffer object that data references. Any
	      // invocation of this method with this kind of argument that does
	      // not throw an exception must increase the bufferedAmount attribute
	      // by the length of datas buffer in bytes.

	      const ab = Buffer.from(data, data.byteOffset, data.byteLength);

	      const frame = new WebsocketFrameSend(ab);
	      const buffer = frame.createFrame(opcodes.BINARY);

	      this.#bufferedAmount += ab.byteLength;
	      socket.write(buffer, () => {
	        this.#bufferedAmount -= ab.byteLength;
	      });
	    } else if (isBlobLike(data)) {
	      // If the WebSocket connection is established, and the WebSocket
	      // closing handshake has not yet started, then the user agent must
	      // send a WebSocket Message comprised of data using a binary frame
	      // opcode; if the data cannot be sent, e.g. because it would need to
	      // be buffered but the buffer is full, the user agent must flag the
	      // WebSocket as full and then close the WebSocket connection. The data
	      // to be sent is the raw data represented by the Blob object. Any
	      // invocation of this method with a Blob argument that does not throw
	      // an exception must increase the bufferedAmount attribute by the size
	      // of the Blob objects raw data, in bytes.

	      const frame = new WebsocketFrameSend();

	      data.arrayBuffer().then((ab) => {
	        const value = Buffer.from(ab);
	        frame.frameData = value;
	        const buffer = frame.createFrame(opcodes.BINARY);

	        this.#bufferedAmount += value.byteLength;
	        socket.write(buffer, () => {
	          this.#bufferedAmount -= value.byteLength;
	        });
	      });
	    }
	  }

	  get readyState () {
	    webidl.brandCheck(this, WebSocket);

	    // The readyState getter steps are to return this's ready state.
	    return this[kReadyState]
	  }

	  get bufferedAmount () {
	    webidl.brandCheck(this, WebSocket);

	    return this.#bufferedAmount
	  }

	  get url () {
	    webidl.brandCheck(this, WebSocket);

	    // The url getter steps are to return this's url, serialized.
	    return URLSerializer(this[kWebSocketURL])
	  }

	  get extensions () {
	    webidl.brandCheck(this, WebSocket);

	    return this.#extensions
	  }

	  get protocol () {
	    webidl.brandCheck(this, WebSocket);

	    return this.#protocol
	  }

	  get onopen () {
	    webidl.brandCheck(this, WebSocket);

	    return this.#events.open
	  }

	  set onopen (fn) {
	    webidl.brandCheck(this, WebSocket);

	    if (this.#events.open) {
	      this.removeEventListener('open', this.#events.open);
	    }

	    if (typeof fn === 'function') {
	      this.#events.open = fn;
	      this.addEventListener('open', fn);
	    } else {
	      this.#events.open = null;
	    }
	  }

	  get onerror () {
	    webidl.brandCheck(this, WebSocket);

	    return this.#events.error
	  }

	  set onerror (fn) {
	    webidl.brandCheck(this, WebSocket);

	    if (this.#events.error) {
	      this.removeEventListener('error', this.#events.error);
	    }

	    if (typeof fn === 'function') {
	      this.#events.error = fn;
	      this.addEventListener('error', fn);
	    } else {
	      this.#events.error = null;
	    }
	  }

	  get onclose () {
	    webidl.brandCheck(this, WebSocket);

	    return this.#events.close
	  }

	  set onclose (fn) {
	    webidl.brandCheck(this, WebSocket);

	    if (this.#events.close) {
	      this.removeEventListener('close', this.#events.close);
	    }

	    if (typeof fn === 'function') {
	      this.#events.close = fn;
	      this.addEventListener('close', fn);
	    } else {
	      this.#events.close = null;
	    }
	  }

	  get onmessage () {
	    webidl.brandCheck(this, WebSocket);

	    return this.#events.message
	  }

	  set onmessage (fn) {
	    webidl.brandCheck(this, WebSocket);

	    if (this.#events.message) {
	      this.removeEventListener('message', this.#events.message);
	    }

	    if (typeof fn === 'function') {
	      this.#events.message = fn;
	      this.addEventListener('message', fn);
	    } else {
	      this.#events.message = null;
	    }
	  }

	  get binaryType () {
	    webidl.brandCheck(this, WebSocket);

	    return this[kBinaryType]
	  }

	  set binaryType (type) {
	    webidl.brandCheck(this, WebSocket);

	    if (type !== 'blob' && type !== 'arraybuffer') {
	      this[kBinaryType] = 'blob';
	    } else {
	      this[kBinaryType] = type;
	    }
	  }

	  /**
	   * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
	   */
	  #onConnectionEstablished (response) {
	    // processResponse is called when the "responses header list has been received and initialized."
	    // once this happens, the connection is open
	    this[kResponse] = response;

	    const parser = new ByteParser(this);
	    parser.on('drain', function onParserDrain () {
	      this.ws[kResponse].socket.resume();
	    });

	    response.socket.ws = this;
	    this[kByteParser] = parser;

	    // 1. Change the ready state to OPEN (1).
	    this[kReadyState] = states.OPEN;

	    // 2. Change the extensions attributes value to the extensions in use, if
	    //    it is not the null value.
	    // https://datatracker.ietf.org/doc/html/rfc6455#section-9.1
	    const extensions = response.headersList.get('sec-websocket-extensions');

	    if (extensions !== null) {
	      this.#extensions = extensions;
	    }

	    // 3. Change the protocol attributes value to the subprotocol in use, if
	    //    it is not the null value.
	    // https://datatracker.ietf.org/doc/html/rfc6455#section-1.9
	    const protocol = response.headersList.get('sec-websocket-protocol');

	    if (protocol !== null) {
	      this.#protocol = protocol;
	    }

	    // 4. Fire an event named open at the WebSocket object.
	    fireEvent('open', this);
	  }
	}

	// https://websockets.spec.whatwg.org/#dom-websocket-connecting
	WebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING;
	// https://websockets.spec.whatwg.org/#dom-websocket-open
	WebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN;
	// https://websockets.spec.whatwg.org/#dom-websocket-closing
	WebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING;
	// https://websockets.spec.whatwg.org/#dom-websocket-closed
	WebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED;

	Object.defineProperties(WebSocket.prototype, {
	  CONNECTING: staticPropertyDescriptors,
	  OPEN: staticPropertyDescriptors,
	  CLOSING: staticPropertyDescriptors,
	  CLOSED: staticPropertyDescriptors,
	  url: kEnumerableProperty,
	  readyState: kEnumerableProperty,
	  bufferedAmount: kEnumerableProperty,
	  onopen: kEnumerableProperty,
	  onerror: kEnumerableProperty,
	  onclose: kEnumerableProperty,
	  close: kEnumerableProperty,
	  onmessage: kEnumerableProperty,
	  binaryType: kEnumerableProperty,
	  send: kEnumerableProperty,
	  extensions: kEnumerableProperty,
	  protocol: kEnumerableProperty,
	  [Symbol.toStringTag]: {
	    value: 'WebSocket',
	    writable: false,
	    enumerable: false,
	    configurable: true
	  }
	});

	Object.defineProperties(WebSocket, {
	  CONNECTING: staticPropertyDescriptors,
	  OPEN: staticPropertyDescriptors,
	  CLOSING: staticPropertyDescriptors,
	  CLOSED: staticPropertyDescriptors
	});

	webidl.converters['sequence<DOMString>'] = webidl.sequenceConverter(
	  webidl.converters.DOMString
	);

	webidl.converters['DOMString or sequence<DOMString>'] = function (V) {
	  if (webidl.util.Type(V) === 'Object' && Symbol.iterator in V) {
	    return webidl.converters['sequence<DOMString>'](V)
	  }

	  return webidl.converters.DOMString(V)
	};

	// This implements the propsal made in https://github.com/whatwg/websockets/issues/42
	webidl.converters.WebSocketInit = webidl.dictionaryConverter([
	  {
	    key: 'protocols',
	    converter: webidl.converters['DOMString or sequence<DOMString>'],
	    get defaultValue () {
	      return []
	    }
	  },
	  {
	    key: 'dispatcher',
	    converter: (V) => V,
	    get defaultValue () {
	      return getGlobalDispatcher()
	    }
	  },
	  {
	    key: 'headers',
	    converter: webidl.nullableConverter(webidl.converters.HeadersInit)
	  }
	]);

	webidl.converters['DOMString or sequence<DOMString> or WebSocketInit'] = function (V) {
	  if (webidl.util.Type(V) === 'Object' && !(Symbol.iterator in V)) {
	    return webidl.converters.WebSocketInit(V)
	  }

	  return { protocols: webidl.converters['DOMString or sequence<DOMString>'](V) }
	};

	webidl.converters.WebSocketSendData = function (V) {
	  if (webidl.util.Type(V) === 'Object') {
	    if (isBlobLike(V)) {
	      return webidl.converters.Blob(V, { strict: false })
	    }

	    if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) {
	      return webidl.converters.BufferSource(V)
	    }
	  }

	  return webidl.converters.USVString(V)
	};

	websocket$1 = {
	  WebSocket
	};
	return websocket$1;
}

var hasRequiredUndici;

function requireUndici () {
	if (hasRequiredUndici) return undici;
	hasRequiredUndici = 1;

	const Client = requireClient();
	const Dispatcher = requireDispatcher();
	const errors = requireErrors();
	const Pool = requirePool();
	const BalancedPool = requireBalancedPool();
	const Agent = requireAgent();
	const util = requireUtil$6();
	const { InvalidArgumentError } = errors;
	const api = requireApi();
	const buildConnector = requireConnect();
	const MockClient = requireMockClient();
	const MockAgent = requireMockAgent();
	const MockPool = requireMockPool();
	const mockErrors = requireMockErrors();
	const ProxyAgent = requireProxyAgent();
	const RetryHandler = requireRetryHandler();
	const { getGlobalDispatcher, setGlobalDispatcher } = requireGlobal();
	const DecoratorHandler = requireDecoratorHandler();
	const RedirectHandler = requireRedirectHandler();
	const createRedirectInterceptor = requireRedirectInterceptor();

	let hasCrypto;
	try {
	  require('crypto');
	  hasCrypto = true;
	} catch {
	  hasCrypto = false;
	}

	Object.assign(Dispatcher.prototype, api);

	undici.Dispatcher = Dispatcher;
	undici.Client = Client;
	undici.Pool = Pool;
	undici.BalancedPool = BalancedPool;
	undici.Agent = Agent;
	undici.ProxyAgent = ProxyAgent;
	undici.RetryHandler = RetryHandler;

	undici.DecoratorHandler = DecoratorHandler;
	undici.RedirectHandler = RedirectHandler;
	undici.createRedirectInterceptor = createRedirectInterceptor;

	undici.buildConnector = buildConnector;
	undici.errors = errors;

	function makeDispatcher (fn) {
	  return (url, opts, handler) => {
	    if (typeof opts === 'function') {
	      handler = opts;
	      opts = null;
	    }

	    if (!url || (typeof url !== 'string' && typeof url !== 'object' && !(url instanceof URL))) {
	      throw new InvalidArgumentError('invalid url')
	    }

	    if (opts != null && typeof opts !== 'object') {
	      throw new InvalidArgumentError('invalid opts')
	    }

	    if (opts && opts.path != null) {
	      if (typeof opts.path !== 'string') {
	        throw new InvalidArgumentError('invalid opts.path')
	      }

	      let path = opts.path;
	      if (!opts.path.startsWith('/')) {
	        path = `/${path}`;
	      }

	      url = new URL(util.parseOrigin(url).origin + path);
	    } else {
	      if (!opts) {
	        opts = typeof url === 'object' ? url : {};
	      }

	      url = util.parseURL(url);
	    }

	    const { agent, dispatcher = getGlobalDispatcher() } = opts;

	    if (agent) {
	      throw new InvalidArgumentError('unsupported opts.agent. Did you mean opts.client?')
	    }

	    return fn.call(dispatcher, {
	      ...opts,
	      origin: url.origin,
	      path: url.search ? `${url.pathname}${url.search}` : url.pathname,
	      method: opts.method || (opts.body ? 'PUT' : 'GET')
	    }, handler)
	  }
	}

	undici.setGlobalDispatcher = setGlobalDispatcher;
	undici.getGlobalDispatcher = getGlobalDispatcher;

	if (util.nodeMajor > 16 || (util.nodeMajor === 16 && util.nodeMinor >= 8)) {
	  let fetchImpl = null;
	  undici.fetch = async function fetch (resource) {
	    if (!fetchImpl) {
	      fetchImpl = requireFetch().fetch;
	    }

	    try {
	      return await fetchImpl(...arguments)
	    } catch (err) {
	      if (typeof err === 'object') {
	        Error.captureStackTrace(err, this);
	      }

	      throw err
	    }
	  };
	  undici.Headers = requireHeaders().Headers;
	  undici.Response = requireResponse().Response;
	  undici.Request = requireRequest().Request;
	  undici.FormData = requireFormdata().FormData;
	  undici.File = requireFile().File;
	  undici.FileReader = requireFilereader().FileReader;

	  const { setGlobalOrigin, getGlobalOrigin } = requireGlobal$1();

	  undici.setGlobalOrigin = setGlobalOrigin;
	  undici.getGlobalOrigin = getGlobalOrigin;

	  const { CacheStorage } = requireCachestorage();
	  const { kConstruct } = requireSymbols$1();

	  // Cache & CacheStorage are tightly coupled with fetch. Even if it may run
	  // in an older version of Node, it doesn't have any use without fetch.
	  undici.caches = new CacheStorage(kConstruct);
	}

	if (util.nodeMajor >= 16) {
	  const { deleteCookie, getCookies, getSetCookies, setCookie } = requireCookies();

	  undici.deleteCookie = deleteCookie;
	  undici.getCookies = getCookies;
	  undici.getSetCookies = getSetCookies;
	  undici.setCookie = setCookie;

	  const { parseMIMEType, serializeAMimeType } = requireDataURL();

	  undici.parseMIMEType = parseMIMEType;
	  undici.serializeAMimeType = serializeAMimeType;
	}

	if (util.nodeMajor >= 18 && hasCrypto) {
	  const { WebSocket } = requireWebsocket$1();

	  undici.WebSocket = WebSocket;
	}

	undici.request = makeDispatcher(api.request);
	undici.stream = makeDispatcher(api.stream);
	undici.pipeline = makeDispatcher(api.pipeline);
	undici.connect = makeDispatcher(api.connect);
	undici.upgrade = makeDispatcher(api.upgrade);

	undici.MockClient = MockClient;
	undici.MockPool = MockPool;
	undici.MockAgent = MockAgent;
	undici.mockErrors = mockErrors;
	return undici;
}

var hasRequiredLib;

function requireLib () {
	if (hasRequiredLib) return lib;
	hasRequiredLib = 1;
	/* eslint-disable @typescript-eslint/no-explicit-any */
	var __createBinding = (lib && lib.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (lib && lib.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (lib && lib.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	var __awaiter = (lib && lib.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	Object.defineProperty(lib, "__esModule", { value: true });
	lib.HttpClient = lib.isHttps = lib.HttpClientResponse = lib.HttpClientError = lib.getProxyUrl = lib.MediaTypes = lib.Headers = lib.HttpCodes = void 0;
	const http = __importStar(require$$2);
	const https = __importStar(require$$1);
	const pm = __importStar(requireProxy());
	const tunnel = __importStar(requireTunnel());
	const undici_1 = requireUndici();
	var HttpCodes;
	(function (HttpCodes) {
	    HttpCodes[HttpCodes["OK"] = 200] = "OK";
	    HttpCodes[HttpCodes["MultipleChoices"] = 300] = "MultipleChoices";
	    HttpCodes[HttpCodes["MovedPermanently"] = 301] = "MovedPermanently";
	    HttpCodes[HttpCodes["ResourceMoved"] = 302] = "ResourceMoved";
	    HttpCodes[HttpCodes["SeeOther"] = 303] = "SeeOther";
	    HttpCodes[HttpCodes["NotModified"] = 304] = "NotModified";
	    HttpCodes[HttpCodes["UseProxy"] = 305] = "UseProxy";
	    HttpCodes[HttpCodes["SwitchProxy"] = 306] = "SwitchProxy";
	    HttpCodes[HttpCodes["TemporaryRedirect"] = 307] = "TemporaryRedirect";
	    HttpCodes[HttpCodes["PermanentRedirect"] = 308] = "PermanentRedirect";
	    HttpCodes[HttpCodes["BadRequest"] = 400] = "BadRequest";
	    HttpCodes[HttpCodes["Unauthorized"] = 401] = "Unauthorized";
	    HttpCodes[HttpCodes["PaymentRequired"] = 402] = "PaymentRequired";
	    HttpCodes[HttpCodes["Forbidden"] = 403] = "Forbidden";
	    HttpCodes[HttpCodes["NotFound"] = 404] = "NotFound";
	    HttpCodes[HttpCodes["MethodNotAllowed"] = 405] = "MethodNotAllowed";
	    HttpCodes[HttpCodes["NotAcceptable"] = 406] = "NotAcceptable";
	    HttpCodes[HttpCodes["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
	    HttpCodes[HttpCodes["RequestTimeout"] = 408] = "RequestTimeout";
	    HttpCodes[HttpCodes["Conflict"] = 409] = "Conflict";
	    HttpCodes[HttpCodes["Gone"] = 410] = "Gone";
	    HttpCodes[HttpCodes["TooManyRequests"] = 429] = "TooManyRequests";
	    HttpCodes[HttpCodes["InternalServerError"] = 500] = "InternalServerError";
	    HttpCodes[HttpCodes["NotImplemented"] = 501] = "NotImplemented";
	    HttpCodes[HttpCodes["BadGateway"] = 502] = "BadGateway";
	    HttpCodes[HttpCodes["ServiceUnavailable"] = 503] = "ServiceUnavailable";
	    HttpCodes[HttpCodes["GatewayTimeout"] = 504] = "GatewayTimeout";
	})(HttpCodes || (lib.HttpCodes = HttpCodes = {}));
	var Headers;
	(function (Headers) {
	    Headers["Accept"] = "accept";
	    Headers["ContentType"] = "content-type";
	})(Headers || (lib.Headers = Headers = {}));
	var MediaTypes;
	(function (MediaTypes) {
	    MediaTypes["ApplicationJson"] = "application/json";
	})(MediaTypes || (lib.MediaTypes = MediaTypes = {}));
	/**
	 * Returns the proxy URL, depending upon the supplied url and proxy environment variables.
	 * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
	 */
	function getProxyUrl(serverUrl) {
	    const proxyUrl = pm.getProxyUrl(new URL(serverUrl));
	    return proxyUrl ? proxyUrl.href : '';
	}
	lib.getProxyUrl = getProxyUrl;
	const HttpRedirectCodes = [
	    HttpCodes.MovedPermanently,
	    HttpCodes.ResourceMoved,
	    HttpCodes.SeeOther,
	    HttpCodes.TemporaryRedirect,
	    HttpCodes.PermanentRedirect
	];
	const HttpResponseRetryCodes = [
	    HttpCodes.BadGateway,
	    HttpCodes.ServiceUnavailable,
	    HttpCodes.GatewayTimeout
	];
	const RetryableHttpVerbs = ['OPTIONS', 'GET', 'DELETE', 'HEAD'];
	const ExponentialBackoffCeiling = 10;
	const ExponentialBackoffTimeSlice = 5;
	class HttpClientError extends Error {
	    constructor(message, statusCode) {
	        super(message);
	        this.name = 'HttpClientError';
	        this.statusCode = statusCode;
	        Object.setPrototypeOf(this, HttpClientError.prototype);
	    }
	}
	lib.HttpClientError = HttpClientError;
	class HttpClientResponse {
	    constructor(message) {
	        this.message = message;
	    }
	    readBody() {
	        return __awaiter(this, void 0, void 0, function* () {
	            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
	                let output = Buffer.alloc(0);
	                this.message.on('data', (chunk) => {
	                    output = Buffer.concat([output, chunk]);
	                });
	                this.message.on('end', () => {
	                    resolve(output.toString());
	                });
	            }));
	        });
	    }
	    readBodyBuffer() {
	        return __awaiter(this, void 0, void 0, function* () {
	            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
	                const chunks = [];
	                this.message.on('data', (chunk) => {
	                    chunks.push(chunk);
	                });
	                this.message.on('end', () => {
	                    resolve(Buffer.concat(chunks));
	                });
	            }));
	        });
	    }
	}
	lib.HttpClientResponse = HttpClientResponse;
	function isHttps(requestUrl) {
	    const parsedUrl = new URL(requestUrl);
	    return parsedUrl.protocol === 'https:';
	}
	lib.isHttps = isHttps;
	class HttpClient {
	    constructor(userAgent, handlers, requestOptions) {
	        this._ignoreSslError = false;
	        this._allowRedirects = true;
	        this._allowRedirectDowngrade = false;
	        this._maxRedirects = 50;
	        this._allowRetries = false;
	        this._maxRetries = 1;
	        this._keepAlive = false;
	        this._disposed = false;
	        this.userAgent = userAgent;
	        this.handlers = handlers || [];
	        this.requestOptions = requestOptions;
	        if (requestOptions) {
	            if (requestOptions.ignoreSslError != null) {
	                this._ignoreSslError = requestOptions.ignoreSslError;
	            }
	            this._socketTimeout = requestOptions.socketTimeout;
	            if (requestOptions.allowRedirects != null) {
	                this._allowRedirects = requestOptions.allowRedirects;
	            }
	            if (requestOptions.allowRedirectDowngrade != null) {
	                this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
	            }
	            if (requestOptions.maxRedirects != null) {
	                this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
	            }
	            if (requestOptions.keepAlive != null) {
	                this._keepAlive = requestOptions.keepAlive;
	            }
	            if (requestOptions.allowRetries != null) {
	                this._allowRetries = requestOptions.allowRetries;
	            }
	            if (requestOptions.maxRetries != null) {
	                this._maxRetries = requestOptions.maxRetries;
	            }
	        }
	    }
	    options(requestUrl, additionalHeaders) {
	        return __awaiter(this, void 0, void 0, function* () {
	            return this.request('OPTIONS', requestUrl, null, additionalHeaders || {});
	        });
	    }
	    get(requestUrl, additionalHeaders) {
	        return __awaiter(this, void 0, void 0, function* () {
	            return this.request('GET', requestUrl, null, additionalHeaders || {});
	        });
	    }
	    del(requestUrl, additionalHeaders) {
	        return __awaiter(this, void 0, void 0, function* () {
	            return this.request('DELETE', requestUrl, null, additionalHeaders || {});
	        });
	    }
	    post(requestUrl, data, additionalHeaders) {
	        return __awaiter(this, void 0, void 0, function* () {
	            return this.request('POST', requestUrl, data, additionalHeaders || {});
	        });
	    }
	    patch(requestUrl, data, additionalHeaders) {
	        return __awaiter(this, void 0, void 0, function* () {
	            return this.request('PATCH', requestUrl, data, additionalHeaders || {});
	        });
	    }
	    put(requestUrl, data, additionalHeaders) {
	        return __awaiter(this, void 0, void 0, function* () {
	            return this.request('PUT', requestUrl, data, additionalHeaders || {});
	        });
	    }
	    head(requestUrl, additionalHeaders) {
	        return __awaiter(this, void 0, void 0, function* () {
	            return this.request('HEAD', requestUrl, null, additionalHeaders || {});
	        });
	    }
	    sendStream(verb, requestUrl, stream, additionalHeaders) {
	        return __awaiter(this, void 0, void 0, function* () {
	            return this.request(verb, requestUrl, stream, additionalHeaders);
	        });
	    }
	    /**
	     * Gets a typed object from an endpoint
	     * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise
	     */
	    getJson(requestUrl, additionalHeaders = {}) {
	        return __awaiter(this, void 0, void 0, function* () {
	            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
	            const res = yield this.get(requestUrl, additionalHeaders);
	            return this._processResponse(res, this.requestOptions);
	        });
	    }
	    postJson(requestUrl, obj, additionalHeaders = {}) {
	        return __awaiter(this, void 0, void 0, function* () {
	            const data = JSON.stringify(obj, null, 2);
	            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
	            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
	            const res = yield this.post(requestUrl, data, additionalHeaders);
	            return this._processResponse(res, this.requestOptions);
	        });
	    }
	    putJson(requestUrl, obj, additionalHeaders = {}) {
	        return __awaiter(this, void 0, void 0, function* () {
	            const data = JSON.stringify(obj, null, 2);
	            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
	            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
	            const res = yield this.put(requestUrl, data, additionalHeaders);
	            return this._processResponse(res, this.requestOptions);
	        });
	    }
	    patchJson(requestUrl, obj, additionalHeaders = {}) {
	        return __awaiter(this, void 0, void 0, function* () {
	            const data = JSON.stringify(obj, null, 2);
	            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
	            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
	            const res = yield this.patch(requestUrl, data, additionalHeaders);
	            return this._processResponse(res, this.requestOptions);
	        });
	    }
	    /**
	     * Makes a raw http request.
	     * All other methods such as get, post, patch, and request ultimately call this.
	     * Prefer get, del, post and patch
	     */
	    request(verb, requestUrl, data, headers) {
	        return __awaiter(this, void 0, void 0, function* () {
	            if (this._disposed) {
	                throw new Error('Client has already been disposed.');
	            }
	            const parsedUrl = new URL(requestUrl);
	            let info = this._prepareRequest(verb, parsedUrl, headers);
	            // Only perform retries on reads since writes may not be idempotent.
	            const maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb)
	                ? this._maxRetries + 1
	                : 1;
	            let numTries = 0;
	            let response;
	            do {
	                response = yield this.requestRaw(info, data);
	                // Check if it's an authentication challenge
	                if (response &&
	                    response.message &&
	                    response.message.statusCode === HttpCodes.Unauthorized) {
	                    let authenticationHandler;
	                    for (const handler of this.handlers) {
	                        if (handler.canHandleAuthentication(response)) {
	                            authenticationHandler = handler;
	                            break;
	                        }
	                    }
	                    if (authenticationHandler) {
	                        return authenticationHandler.handleAuthentication(this, info, data);
	                    }
	                    else {
	                        // We have received an unauthorized response but have no handlers to handle it.
	                        // Let the response return to the caller.
	                        return response;
	                    }
	                }
	                let redirectsRemaining = this._maxRedirects;
	                while (response.message.statusCode &&
	                    HttpRedirectCodes.includes(response.message.statusCode) &&
	                    this._allowRedirects &&
	                    redirectsRemaining > 0) {
	                    const redirectUrl = response.message.headers['location'];
	                    if (!redirectUrl) {
	                        // if there's no location to redirect to, we won't
	                        break;
	                    }
	                    const parsedRedirectUrl = new URL(redirectUrl);
	                    if (parsedUrl.protocol === 'https:' &&
	                        parsedUrl.protocol !== parsedRedirectUrl.protocol &&
	                        !this._allowRedirectDowngrade) {
	                        throw new Error('Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.');
	                    }
	                    // we need to finish reading the response before reassigning response
	                    // which will leak the open socket.
	                    yield response.readBody();
	                    // strip authorization header if redirected to a different hostname
	                    if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {
	                        for (const header in headers) {
	                            // header names are case insensitive
	                            if (header.toLowerCase() === 'authorization') {
	                                delete headers[header];
	                            }
	                        }
	                    }
	                    // let's make the request with the new redirectUrl
	                    info = this._prepareRequest(verb, parsedRedirectUrl, headers);
	                    response = yield this.requestRaw(info, data);
	                    redirectsRemaining--;
	                }
	                if (!response.message.statusCode ||
	                    !HttpResponseRetryCodes.includes(response.message.statusCode)) {
	                    // If not a retry code, return immediately instead of retrying
	                    return response;
	                }
	                numTries += 1;
	                if (numTries < maxTries) {
	                    yield response.readBody();
	                    yield this._performExponentialBackoff(numTries);
	                }
	            } while (numTries < maxTries);
	            return response;
	        });
	    }
	    /**
	     * Needs to be called if keepAlive is set to true in request options.
	     */
	    dispose() {
	        if (this._agent) {
	            this._agent.destroy();
	        }
	        this._disposed = true;
	    }
	    /**
	     * Raw request.
	     * @param info
	     * @param data
	     */
	    requestRaw(info, data) {
	        return __awaiter(this, void 0, void 0, function* () {
	            return new Promise((resolve, reject) => {
	                function callbackForResult(err, res) {
	                    if (err) {
	                        reject(err);
	                    }
	                    else if (!res) {
	                        // If `err` is not passed, then `res` must be passed.
	                        reject(new Error('Unknown error'));
	                    }
	                    else {
	                        resolve(res);
	                    }
	                }
	                this.requestRawWithCallback(info, data, callbackForResult);
	            });
	        });
	    }
	    /**
	     * Raw request with callback.
	     * @param info
	     * @param data
	     * @param onResult
	     */
	    requestRawWithCallback(info, data, onResult) {
	        if (typeof data === 'string') {
	            if (!info.options.headers) {
	                info.options.headers = {};
	            }
	            info.options.headers['Content-Length'] = Buffer.byteLength(data, 'utf8');
	        }
	        let callbackCalled = false;
	        function handleResult(err, res) {
	            if (!callbackCalled) {
	                callbackCalled = true;
	                onResult(err, res);
	            }
	        }
	        const req = info.httpModule.request(info.options, (msg) => {
	            const res = new HttpClientResponse(msg);
	            handleResult(undefined, res);
	        });
	        let socket;
	        req.on('socket', sock => {
	            socket = sock;
	        });
	        // If we ever get disconnected, we want the socket to timeout eventually
	        req.setTimeout(this._socketTimeout || 3 * 60000, () => {
	            if (socket) {
	                socket.end();
	            }
	            handleResult(new Error(`Request timeout: ${info.options.path}`));
	        });
	        req.on('error', function (err) {
	            // err has statusCode property
	            // res should have headers
	            handleResult(err);
	        });
	        if (data && typeof data === 'string') {
	            req.write(data, 'utf8');
	        }
	        if (data && typeof data !== 'string') {
	            data.on('close', function () {
	                req.end();
	            });
	            data.pipe(req);
	        }
	        else {
	            req.end();
	        }
	    }
	    /**
	     * Gets an http agent. This function is useful when you need an http agent that handles
	     * routing through a proxy server - depending upon the url and proxy environment variables.
	     * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
	     */
	    getAgent(serverUrl) {
	        const parsedUrl = new URL(serverUrl);
	        return this._getAgent(parsedUrl);
	    }
	    getAgentDispatcher(serverUrl) {
	        const parsedUrl = new URL(serverUrl);
	        const proxyUrl = pm.getProxyUrl(parsedUrl);
	        const useProxy = proxyUrl && proxyUrl.hostname;
	        if (!useProxy) {
	            return;
	        }
	        return this._getProxyAgentDispatcher(parsedUrl, proxyUrl);
	    }
	    _prepareRequest(method, requestUrl, headers) {
	        const info = {};
	        info.parsedUrl = requestUrl;
	        const usingSsl = info.parsedUrl.protocol === 'https:';
	        info.httpModule = usingSsl ? https : http;
	        const defaultPort = usingSsl ? 443 : 80;
	        info.options = {};
	        info.options.host = info.parsedUrl.hostname;
	        info.options.port = info.parsedUrl.port
	            ? parseInt(info.parsedUrl.port)
	            : defaultPort;
	        info.options.path =
	            (info.parsedUrl.pathname || '') + (info.parsedUrl.search || '');
	        info.options.method = method;
	        info.options.headers = this._mergeHeaders(headers);
	        if (this.userAgent != null) {
	            info.options.headers['user-agent'] = this.userAgent;
	        }
	        info.options.agent = this._getAgent(info.parsedUrl);
	        // gives handlers an opportunity to participate
	        if (this.handlers) {
	            for (const handler of this.handlers) {
	                handler.prepareRequest(info.options);
	            }
	        }
	        return info;
	    }
	    _mergeHeaders(headers) {
	        if (this.requestOptions && this.requestOptions.headers) {
	            return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers || {}));
	        }
	        return lowercaseKeys(headers || {});
	    }
	    _getExistingOrDefaultHeader(additionalHeaders, header, _default) {
	        let clientHeader;
	        if (this.requestOptions && this.requestOptions.headers) {
	            clientHeader = lowercaseKeys(this.requestOptions.headers)[header];
	        }
	        return additionalHeaders[header] || clientHeader || _default;
	    }
	    _getAgent(parsedUrl) {
	        let agent;
	        const proxyUrl = pm.getProxyUrl(parsedUrl);
	        const useProxy = proxyUrl && proxyUrl.hostname;
	        if (this._keepAlive && useProxy) {
	            agent = this._proxyAgent;
	        }
	        if (!useProxy) {
	            agent = this._agent;
	        }
	        // if agent is already assigned use that agent.
	        if (agent) {
	            return agent;
	        }
	        const usingSsl = parsedUrl.protocol === 'https:';
	        let maxSockets = 100;
	        if (this.requestOptions) {
	            maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;
	        }
	        // This is `useProxy` again, but we need to check `proxyURl` directly for TypeScripts's flow analysis.
	        if (proxyUrl && proxyUrl.hostname) {
	            const agentOptions = {
	                maxSockets,
	                keepAlive: this._keepAlive,
	                proxy: Object.assign(Object.assign({}, ((proxyUrl.username || proxyUrl.password) && {
	                    proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`
	                })), { host: proxyUrl.hostname, port: proxyUrl.port })
	            };
	            let tunnelAgent;
	            const overHttps = proxyUrl.protocol === 'https:';
	            if (usingSsl) {
	                tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;
	            }
	            else {
	                tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
	            }
	            agent = tunnelAgent(agentOptions);
	            this._proxyAgent = agent;
	        }
	        // if tunneling agent isn't assigned create a new agent
	        if (!agent) {
	            const options = { keepAlive: this._keepAlive, maxSockets };
	            agent = usingSsl ? new https.Agent(options) : new http.Agent(options);
	            this._agent = agent;
	        }
	        if (usingSsl && this._ignoreSslError) {
	            // we don't want to set NODE_TLS_REJECT_UNAUTHORIZED=0 since that will affect request for entire process
	            // http.RequestOptions doesn't expose a way to modify RequestOptions.agent.options
	            // we have to cast it to any and change it directly
	            agent.options = Object.assign(agent.options || {}, {
	                rejectUnauthorized: false
	            });
	        }
	        return agent;
	    }
	    _getProxyAgentDispatcher(parsedUrl, proxyUrl) {
	        let proxyAgent;
	        if (this._keepAlive) {
	            proxyAgent = this._proxyAgentDispatcher;
	        }
	        // if agent is already assigned use that agent.
	        if (proxyAgent) {
	            return proxyAgent;
	        }
	        const usingSsl = parsedUrl.protocol === 'https:';
	        proxyAgent = new undici_1.ProxyAgent(Object.assign({ uri: proxyUrl.href, pipelining: !this._keepAlive ? 0 : 1 }, ((proxyUrl.username || proxyUrl.password) && {
	            token: `Basic ${Buffer.from(`${proxyUrl.username}:${proxyUrl.password}`).toString('base64')}`
	        })));
	        this._proxyAgentDispatcher = proxyAgent;
	        if (usingSsl && this._ignoreSslError) {
	            // we don't want to set NODE_TLS_REJECT_UNAUTHORIZED=0 since that will affect request for entire process
	            // http.RequestOptions doesn't expose a way to modify RequestOptions.agent.options
	            // we have to cast it to any and change it directly
	            proxyAgent.options = Object.assign(proxyAgent.options.requestTls || {}, {
	                rejectUnauthorized: false
	            });
	        }
	        return proxyAgent;
	    }
	    _performExponentialBackoff(retryNumber) {
	        return __awaiter(this, void 0, void 0, function* () {
	            retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
	            const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
	            return new Promise(resolve => setTimeout(() => resolve(), ms));
	        });
	    }
	    _processResponse(res, options) {
	        return __awaiter(this, void 0, void 0, function* () {
	            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
	                const statusCode = res.message.statusCode || 0;
	                const response = {
	                    statusCode,
	                    result: null,
	                    headers: {}
	                };
	                // not found leads to null obj returned
	                if (statusCode === HttpCodes.NotFound) {
	                    resolve(response);
	                }
	                // get the result from the body
	                function dateTimeDeserializer(key, value) {
	                    if (typeof value === 'string') {
	                        const a = new Date(value);
	                        if (!isNaN(a.valueOf())) {
	                            return a;
	                        }
	                    }
	                    return value;
	                }
	                let obj;
	                let contents;
	                try {
	                    contents = yield res.readBody();
	                    if (contents && contents.length > 0) {
	                        if (options && options.deserializeDates) {
	                            obj = JSON.parse(contents, dateTimeDeserializer);
	                        }
	                        else {
	                            obj = JSON.parse(contents);
	                        }
	                        response.result = obj;
	                    }
	                    response.headers = res.message.headers;
	                }
	                catch (err) {
	                    // Invalid resource (contents not json);  leaving result obj null
	                }
	                // note that 3xx redirects are handled by the http layer.
	                if (statusCode > 299) {
	                    let msg;
	                    // if exception/error in body, attempt to get better error
	                    if (obj && obj.message) {
	                        msg = obj.message;
	                    }
	                    else if (contents && contents.length > 0) {
	                        // it may be the case that the exception is in the body message as string
	                        msg = contents;
	                    }
	                    else {
	                        msg = `Failed request: (${statusCode})`;
	                    }
	                    const err = new HttpClientError(msg, statusCode);
	                    err.result = response.result;
	                    reject(err);
	                }
	                else {
	                    resolve(response);
	                }
	            }));
	        });
	    }
	}
	lib.HttpClient = HttpClient;
	const lowercaseKeys = (obj) => Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {});
	
	return lib;
}

var auth = {};

var hasRequiredAuth;

function requireAuth () {
	if (hasRequiredAuth) return auth;
	hasRequiredAuth = 1;
	var __awaiter = (auth && auth.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	Object.defineProperty(auth, "__esModule", { value: true });
	auth.PersonalAccessTokenCredentialHandler = auth.BearerCredentialHandler = auth.BasicCredentialHandler = void 0;
	class BasicCredentialHandler {
	    constructor(username, password) {
	        this.username = username;
	        this.password = password;
	    }
	    prepareRequest(options) {
	        if (!options.headers) {
	            throw Error('The request has no headers');
	        }
	        options.headers['Authorization'] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString('base64')}`;
	    }
	    // This handler cannot handle 401
	    canHandleAuthentication() {
	        return false;
	    }
	    handleAuthentication() {
	        return __awaiter(this, void 0, void 0, function* () {
	            throw new Error('not implemented');
	        });
	    }
	}
	auth.BasicCredentialHandler = BasicCredentialHandler;
	class BearerCredentialHandler {
	    constructor(token) {
	        this.token = token;
	    }
	    // currently implements pre-authorization
	    // TODO: support preAuth = false where it hooks on 401
	    prepareRequest(options) {
	        if (!options.headers) {
	            throw Error('The request has no headers');
	        }
	        options.headers['Authorization'] = `Bearer ${this.token}`;
	    }
	    // This handler cannot handle 401
	    canHandleAuthentication() {
	        return false;
	    }
	    handleAuthentication() {
	        return __awaiter(this, void 0, void 0, function* () {
	            throw new Error('not implemented');
	        });
	    }
	}
	auth.BearerCredentialHandler = BearerCredentialHandler;
	class PersonalAccessTokenCredentialHandler {
	    constructor(token) {
	        this.token = token;
	    }
	    // currently implements pre-authorization
	    // TODO: support preAuth = false where it hooks on 401
	    prepareRequest(options) {
	        if (!options.headers) {
	            throw Error('The request has no headers');
	        }
	        options.headers['Authorization'] = `Basic ${Buffer.from(`PAT:${this.token}`).toString('base64')}`;
	    }
	    // This handler cannot handle 401
	    canHandleAuthentication() {
	        return false;
	    }
	    handleAuthentication() {
	        return __awaiter(this, void 0, void 0, function* () {
	            throw new Error('not implemented');
	        });
	    }
	}
	auth.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;
	
	return auth;
}

var hasRequiredOidcUtils;

function requireOidcUtils () {
	if (hasRequiredOidcUtils) return oidcUtils;
	hasRequiredOidcUtils = 1;
	var __awaiter = (oidcUtils && oidcUtils.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	Object.defineProperty(oidcUtils, "__esModule", { value: true });
	oidcUtils.OidcClient = void 0;
	const http_client_1 = requireLib();
	const auth_1 = requireAuth();
	const core_1 = requireCore();
	class OidcClient {
	    static createHttpClient(allowRetry = true, maxRetry = 10) {
	        const requestOptions = {
	            allowRetries: allowRetry,
	            maxRetries: maxRetry
	        };
	        return new http_client_1.HttpClient('actions/oidc-client', [new auth_1.BearerCredentialHandler(OidcClient.getRequestToken())], requestOptions);
	    }
	    static getRequestToken() {
	        const token = process.env['ACTIONS_ID_TOKEN_REQUEST_TOKEN'];
	        if (!token) {
	            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable');
	        }
	        return token;
	    }
	    static getIDTokenUrl() {
	        const runtimeUrl = process.env['ACTIONS_ID_TOKEN_REQUEST_URL'];
	        if (!runtimeUrl) {
	            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable');
	        }
	        return runtimeUrl;
	    }
	    static getCall(id_token_url) {
	        var _a;
	        return __awaiter(this, void 0, void 0, function* () {
	            const httpclient = OidcClient.createHttpClient();
	            const res = yield httpclient
	                .getJson(id_token_url)
	                .catch(error => {
	                throw new Error(`Failed to get ID Token. \n 
        Error Code : ${error.statusCode}\n 
        Error Message: ${error.message}`);
	            });
	            const id_token = (_a = res.result) === null || _a === void 0 ? void 0 : _a.value;
	            if (!id_token) {
	                throw new Error('Response json body do not have ID Token field');
	            }
	            return id_token;
	        });
	    }
	    static getIDToken(audience) {
	        return __awaiter(this, void 0, void 0, function* () {
	            try {
	                // New ID Token is requested from action service
	                let id_token_url = OidcClient.getIDTokenUrl();
	                if (audience) {
	                    const encodedAudience = encodeURIComponent(audience);
	                    id_token_url = `${id_token_url}&audience=${encodedAudience}`;
	                }
	                (0, core_1.debug)(`ID token url is ${id_token_url}`);
	                const id_token = yield OidcClient.getCall(id_token_url);
	                (0, core_1.setSecret)(id_token);
	                return id_token;
	            }
	            catch (error) {
	                throw new Error(`Error message: ${error.message}`);
	            }
	        });
	    }
	}
	oidcUtils.OidcClient = OidcClient;
	
	return oidcUtils;
}

var summary = {};

var hasRequiredSummary;

function requireSummary () {
	if (hasRequiredSummary) return summary;
	hasRequiredSummary = 1;
	(function (exports) {
		var __awaiter = (summary && summary.__awaiter) || function (thisArg, _arguments, P, generator) {
		    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
		    return new (P || (P = Promise))(function (resolve, reject) {
		        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
		        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
		        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
		        step((generator = generator.apply(thisArg, _arguments || [])).next());
		    });
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.summary = exports.markdownSummary = exports.SUMMARY_DOCS_URL = exports.SUMMARY_ENV_VAR = void 0;
		const os_1 = require$$0;
		const fs_1 = require$$0$1;
		const { access, appendFile, writeFile } = fs_1.promises;
		exports.SUMMARY_ENV_VAR = 'GITHUB_STEP_SUMMARY';
		exports.SUMMARY_DOCS_URL = 'https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary';
		class Summary {
		    constructor() {
		        this._buffer = '';
		    }
		    /**
		     * Finds the summary file path from the environment, rejects if env var is not found or file does not exist
		     * Also checks r/w permissions.
		     *
		     * @returns step summary file path
		     */
		    filePath() {
		        return __awaiter(this, void 0, void 0, function* () {
		            if (this._filePath) {
		                return this._filePath;
		            }
		            const pathFromEnv = process.env[exports.SUMMARY_ENV_VAR];
		            if (!pathFromEnv) {
		                throw new Error(`Unable to find environment variable for $${exports.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);
		            }
		            try {
		                yield access(pathFromEnv, fs_1.constants.R_OK | fs_1.constants.W_OK);
		            }
		            catch (_a) {
		                throw new Error(`Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`);
		            }
		            this._filePath = pathFromEnv;
		            return this._filePath;
		        });
		    }
		    /**
		     * Wraps content in an HTML tag, adding any HTML attributes
		     *
		     * @param {string} tag HTML tag to wrap
		     * @param {string | null} content content within the tag
		     * @param {[attribute: string]: string} attrs key-value list of HTML attributes to add
		     *
		     * @returns {string} content wrapped in HTML element
		     */
		    wrap(tag, content, attrs = {}) {
		        const htmlAttrs = Object.entries(attrs)
		            .map(([key, value]) => ` ${key}="${value}"`)
		            .join('');
		        if (!content) {
		            return `<${tag}${htmlAttrs}>`;
		        }
		        return `<${tag}${htmlAttrs}>${content}</${tag}>`;
		    }
		    /**
		     * Writes text in the buffer to the summary buffer file and empties buffer. Will append by default.
		     *
		     * @param {SummaryWriteOptions} [options] (optional) options for write operation
		     *
		     * @returns {Promise<Summary>} summary instance
		     */
		    write(options) {
		        return __awaiter(this, void 0, void 0, function* () {
		            const overwrite = !!(options === null || options === void 0 ? void 0 : options.overwrite);
		            const filePath = yield this.filePath();
		            const writeFunc = overwrite ? writeFile : appendFile;
		            yield writeFunc(filePath, this._buffer, { encoding: 'utf8' });
		            return this.emptyBuffer();
		        });
		    }
		    /**
		     * Clears the summary buffer and wipes the summary file
		     *
		     * @returns {Summary} summary instance
		     */
		    clear() {
		        return __awaiter(this, void 0, void 0, function* () {
		            return this.emptyBuffer().write({ overwrite: true });
		        });
		    }
		    /**
		     * Returns the current summary buffer as a string
		     *
		     * @returns {string} string of summary buffer
		     */
		    stringify() {
		        return this._buffer;
		    }
		    /**
		     * If the summary buffer is empty
		     *
		     * @returns {boolen} true if the buffer is empty
		     */
		    isEmptyBuffer() {
		        return this._buffer.length === 0;
		    }
		    /**
		     * Resets the summary buffer without writing to summary file
		     *
		     * @returns {Summary} summary instance
		     */
		    emptyBuffer() {
		        this._buffer = '';
		        return this;
		    }
		    /**
		     * Adds raw text to the summary buffer
		     *
		     * @param {string} text content to add
		     * @param {boolean} [addEOL=false] (optional) append an EOL to the raw text (default: false)
		     *
		     * @returns {Summary} summary instance
		     */
		    addRaw(text, addEOL = false) {
		        this._buffer += text;
		        return addEOL ? this.addEOL() : this;
		    }
		    /**
		     * Adds the operating system-specific end-of-line marker to the buffer
		     *
		     * @returns {Summary} summary instance
		     */
		    addEOL() {
		        return this.addRaw(os_1.EOL);
		    }
		    /**
		     * Adds an HTML codeblock to the summary buffer
		     *
		     * @param {string} code content to render within fenced code block
		     * @param {string} lang (optional) language to syntax highlight code
		     *
		     * @returns {Summary} summary instance
		     */
		    addCodeBlock(code, lang) {
		        const attrs = Object.assign({}, (lang && { lang }));
		        const element = this.wrap('pre', this.wrap('code', code), attrs);
		        return this.addRaw(element).addEOL();
		    }
		    /**
		     * Adds an HTML list to the summary buffer
		     *
		     * @param {string[]} items list of items to render
		     * @param {boolean} [ordered=false] (optional) if the rendered list should be ordered or not (default: false)
		     *
		     * @returns {Summary} summary instance
		     */
		    addList(items, ordered = false) {
		        const tag = ordered ? 'ol' : 'ul';
		        const listItems = items.map(item => this.wrap('li', item)).join('');
		        const element = this.wrap(tag, listItems);
		        return this.addRaw(element).addEOL();
		    }
		    /**
		     * Adds an HTML table to the summary buffer
		     *
		     * @param {SummaryTableCell[]} rows table rows
		     *
		     * @returns {Summary} summary instance
		     */
		    addTable(rows) {
		        const tableBody = rows
		            .map(row => {
		            const cells = row
		                .map(cell => {
		                if (typeof cell === 'string') {
		                    return this.wrap('td', cell);
		                }
		                const { header, data, colspan, rowspan } = cell;
		                const tag = header ? 'th' : 'td';
		                const attrs = Object.assign(Object.assign({}, (colspan && { colspan })), (rowspan && { rowspan }));
		                return this.wrap(tag, data, attrs);
		            })
		                .join('');
		            return this.wrap('tr', cells);
		        })
		            .join('');
		        const element = this.wrap('table', tableBody);
		        return this.addRaw(element).addEOL();
		    }
		    /**
		     * Adds a collapsable HTML details element to the summary buffer
		     *
		     * @param {string} label text for the closed state
		     * @param {string} content collapsable content
		     *
		     * @returns {Summary} summary instance
		     */
		    addDetails(label, content) {
		        const element = this.wrap('details', this.wrap('summary', label) + content);
		        return this.addRaw(element).addEOL();
		    }
		    /**
		     * Adds an HTML image tag to the summary buffer
		     *
		     * @param {string} src path to the image you to embed
		     * @param {string} alt text description of the image
		     * @param {SummaryImageOptions} options (optional) addition image attributes
		     *
		     * @returns {Summary} summary instance
		     */
		    addImage(src, alt, options) {
		        const { width, height } = options || {};
		        const attrs = Object.assign(Object.assign({}, (width && { width })), (height && { height }));
		        const element = this.wrap('img', null, Object.assign({ src, alt }, attrs));
		        return this.addRaw(element).addEOL();
		    }
		    /**
		     * Adds an HTML section heading element
		     *
		     * @param {string} text heading text
		     * @param {number | string} [level=1] (optional) the heading level, default: 1
		     *
		     * @returns {Summary} summary instance
		     */
		    addHeading(text, level) {
		        const tag = `h${level}`;
		        const allowedTag = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(tag)
		            ? tag
		            : 'h1';
		        const element = this.wrap(allowedTag, text);
		        return this.addRaw(element).addEOL();
		    }
		    /**
		     * Adds an HTML thematic break (<hr>) to the summary buffer
		     *
		     * @returns {Summary} summary instance
		     */
		    addSeparator() {
		        const element = this.wrap('hr', null);
		        return this.addRaw(element).addEOL();
		    }
		    /**
		     * Adds an HTML line break (<br>) to the summary buffer
		     *
		     * @returns {Summary} summary instance
		     */
		    addBreak() {
		        const element = this.wrap('br', null);
		        return this.addRaw(element).addEOL();
		    }
		    /**
		     * Adds an HTML blockquote to the summary buffer
		     *
		     * @param {string} text quote text
		     * @param {string} cite (optional) citation url
		     *
		     * @returns {Summary} summary instance
		     */
		    addQuote(text, cite) {
		        const attrs = Object.assign({}, (cite && { cite }));
		        const element = this.wrap('blockquote', text, attrs);
		        return this.addRaw(element).addEOL();
		    }
		    /**
		     * Adds an HTML anchor tag to the summary buffer
		     *
		     * @param {string} text link text/content
		     * @param {string} href hyperlink
		     *
		     * @returns {Summary} summary instance
		     */
		    addLink(text, href) {
		        const element = this.wrap('a', text, { href });
		        return this.addRaw(element).addEOL();
		    }
		}
		const _summary = new Summary();
		/**
		 * @deprecated use `core.summary`
		 */
		exports.markdownSummary = _summary;
		exports.summary = _summary;
		
	} (summary));
	return summary;
}

var pathUtils = {};

var hasRequiredPathUtils;

function requirePathUtils () {
	if (hasRequiredPathUtils) return pathUtils;
	hasRequiredPathUtils = 1;
	var __createBinding = (pathUtils && pathUtils.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (pathUtils && pathUtils.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (pathUtils && pathUtils.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(pathUtils, "__esModule", { value: true });
	pathUtils.toPlatformPath = pathUtils.toWin32Path = pathUtils.toPosixPath = void 0;
	const path = __importStar(sysPath__default);
	/**
	 * toPosixPath converts the given path to the posix form. On Windows, \\ will be
	 * replaced with /.
	 *
	 * @param pth. Path to transform.
	 * @return string Posix path.
	 */
	function toPosixPath(pth) {
	    return pth.replace(/[\\]/g, '/');
	}
	pathUtils.toPosixPath = toPosixPath;
	/**
	 * toWin32Path converts the given path to the win32 form. On Linux, / will be
	 * replaced with \\.
	 *
	 * @param pth. Path to transform.
	 * @return string Win32 path.
	 */
	function toWin32Path(pth) {
	    return pth.replace(/[/]/g, '\\');
	}
	pathUtils.toWin32Path = toWin32Path;
	/**
	 * toPlatformPath converts the given path to a platform-specific path. It does
	 * this by replacing instances of / and \ with the platform-specific path
	 * separator.
	 *
	 * @param pth The path to platformize.
	 * @return string The platform-specific path.
	 */
	function toPlatformPath(pth) {
	    return pth.replace(/[/\\]/g, path.sep);
	}
	pathUtils.toPlatformPath = toPlatformPath;
	
	return pathUtils;
}

var platform$1 = {};

var exec = {};

var toolrunner = {};

var io = {};

var ioUtil = {};

var hasRequiredIoUtil;

function requireIoUtil () {
	if (hasRequiredIoUtil) return ioUtil;
	hasRequiredIoUtil = 1;
	(function (exports) {
		var __createBinding = (ioUtil && ioUtil.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __setModuleDefault = (ioUtil && ioUtil.__setModuleDefault) || (Object.create ? (function(o, v) {
		    Object.defineProperty(o, "default", { enumerable: true, value: v });
		}) : function(o, v) {
		    o["default"] = v;
		});
		var __importStar = (ioUtil && ioUtil.__importStar) || function (mod) {
		    if (mod && mod.__esModule) return mod;
		    var result = {};
		    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		    __setModuleDefault(result, mod);
		    return result;
		};
		var __awaiter = (ioUtil && ioUtil.__awaiter) || function (thisArg, _arguments, P, generator) {
		    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
		    return new (P || (P = Promise))(function (resolve, reject) {
		        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
		        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
		        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
		        step((generator = generator.apply(thisArg, _arguments || [])).next());
		    });
		};
		var _a;
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.getCmdPath = exports.tryGetExecutablePath = exports.isRooted = exports.isDirectory = exports.exists = exports.READONLY = exports.UV_FS_O_EXLOCK = exports.IS_WINDOWS = exports.unlink = exports.symlink = exports.stat = exports.rmdir = exports.rm = exports.rename = exports.readlink = exports.readdir = exports.open = exports.mkdir = exports.lstat = exports.copyFile = exports.chmod = void 0;
		const fs = __importStar(require$$0$1);
		const path = __importStar(sysPath__default);
		_a = fs.promises
		// export const {open} = 'fs'
		, exports.chmod = _a.chmod, exports.copyFile = _a.copyFile, exports.lstat = _a.lstat, exports.mkdir = _a.mkdir, exports.open = _a.open, exports.readdir = _a.readdir, exports.readlink = _a.readlink, exports.rename = _a.rename, exports.rm = _a.rm, exports.rmdir = _a.rmdir, exports.stat = _a.stat, exports.symlink = _a.symlink, exports.unlink = _a.unlink;
		// export const {open} = 'fs'
		exports.IS_WINDOWS = process.platform === 'win32';
		// See https://github.com/nodejs/node/blob/d0153aee367422d0858105abec186da4dff0a0c5/deps/uv/include/uv/win.h#L691
		exports.UV_FS_O_EXLOCK = 0x10000000;
		exports.READONLY = fs.constants.O_RDONLY;
		function exists(fsPath) {
		    return __awaiter(this, void 0, void 0, function* () {
		        try {
		            yield exports.stat(fsPath);
		        }
		        catch (err) {
		            if (err.code === 'ENOENT') {
		                return false;
		            }
		            throw err;
		        }
		        return true;
		    });
		}
		exports.exists = exists;
		function isDirectory(fsPath, useStat = false) {
		    return __awaiter(this, void 0, void 0, function* () {
		        const stats = useStat ? yield exports.stat(fsPath) : yield exports.lstat(fsPath);
		        return stats.isDirectory();
		    });
		}
		exports.isDirectory = isDirectory;
		/**
		 * On OSX/Linux, true if path starts with '/'. On Windows, true for paths like:
		 * \, \hello, \\hello\share, C:, and C:\hello (and corresponding alternate separator cases).
		 */
		function isRooted(p) {
		    p = normalizeSeparators(p);
		    if (!p) {
		        throw new Error('isRooted() parameter "p" cannot be empty');
		    }
		    if (exports.IS_WINDOWS) {
		        return (p.startsWith('\\') || /^[A-Z]:/i.test(p) // e.g. \ or \hello or \\hello
		        ); // e.g. C: or C:\hello
		    }
		    return p.startsWith('/');
		}
		exports.isRooted = isRooted;
		/**
		 * Best effort attempt to determine whether a file exists and is executable.
		 * @param filePath    file path to check
		 * @param extensions  additional file extensions to try
		 * @return if file exists and is executable, returns the file path. otherwise empty string.
		 */
		function tryGetExecutablePath(filePath, extensions) {
		    return __awaiter(this, void 0, void 0, function* () {
		        let stats = undefined;
		        try {
		            // test file exists
		            stats = yield exports.stat(filePath);
		        }
		        catch (err) {
		            if (err.code !== 'ENOENT') {
		                // eslint-disable-next-line no-console
		                console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
		            }
		        }
		        if (stats && stats.isFile()) {
		            if (exports.IS_WINDOWS) {
		                // on Windows, test for valid extension
		                const upperExt = path.extname(filePath).toUpperCase();
		                if (extensions.some(validExt => validExt.toUpperCase() === upperExt)) {
		                    return filePath;
		                }
		            }
		            else {
		                if (isUnixExecutable(stats)) {
		                    return filePath;
		                }
		            }
		        }
		        // try each extension
		        const originalFilePath = filePath;
		        for (const extension of extensions) {
		            filePath = originalFilePath + extension;
		            stats = undefined;
		            try {
		                stats = yield exports.stat(filePath);
		            }
		            catch (err) {
		                if (err.code !== 'ENOENT') {
		                    // eslint-disable-next-line no-console
		                    console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
		                }
		            }
		            if (stats && stats.isFile()) {
		                if (exports.IS_WINDOWS) {
		                    // preserve the case of the actual file (since an extension was appended)
		                    try {
		                        const directory = path.dirname(filePath);
		                        const upperName = path.basename(filePath).toUpperCase();
		                        for (const actualName of yield exports.readdir(directory)) {
		                            if (upperName === actualName.toUpperCase()) {
		                                filePath = path.join(directory, actualName);
		                                break;
		                            }
		                        }
		                    }
		                    catch (err) {
		                        // eslint-disable-next-line no-console
		                        console.log(`Unexpected error attempting to determine the actual case of the file '${filePath}': ${err}`);
		                    }
		                    return filePath;
		                }
		                else {
		                    if (isUnixExecutable(stats)) {
		                        return filePath;
		                    }
		                }
		            }
		        }
		        return '';
		    });
		}
		exports.tryGetExecutablePath = tryGetExecutablePath;
		function normalizeSeparators(p) {
		    p = p || '';
		    if (exports.IS_WINDOWS) {
		        // convert slashes on Windows
		        p = p.replace(/\//g, '\\');
		        // remove redundant slashes
		        return p.replace(/\\\\+/g, '\\');
		    }
		    // remove redundant slashes
		    return p.replace(/\/\/+/g, '/');
		}
		// on Mac/Linux, test the execute bit
		//     R   W  X  R  W X R W X
		//   256 128 64 32 16 8 4 2 1
		function isUnixExecutable(stats) {
		    return ((stats.mode & 1) > 0 ||
		        ((stats.mode & 8) > 0 && stats.gid === process.getgid()) ||
		        ((stats.mode & 64) > 0 && stats.uid === process.getuid()));
		}
		// Get the path of cmd.exe in windows
		function getCmdPath() {
		    var _a;
		    return (_a = process.env['COMSPEC']) !== null && _a !== void 0 ? _a : `cmd.exe`;
		}
		exports.getCmdPath = getCmdPath;
		
	} (ioUtil));
	return ioUtil;
}

var hasRequiredIo;

function requireIo () {
	if (hasRequiredIo) return io;
	hasRequiredIo = 1;
	var __createBinding = (io && io.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (io && io.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (io && io.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	var __awaiter = (io && io.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	Object.defineProperty(io, "__esModule", { value: true });
	io.findInPath = io.which = io.mkdirP = io.rmRF = io.mv = io.cp = void 0;
	const assert_1 = require$$0$4;
	const path = __importStar(sysPath__default);
	const ioUtil = __importStar(requireIoUtil());
	/**
	 * Copies a file or folder.
	 * Based off of shelljs - https://github.com/shelljs/shelljs/blob/9237f66c52e5daa40458f94f9565e18e8132f5a6/src/cp.js
	 *
	 * @param     source    source path
	 * @param     dest      destination path
	 * @param     options   optional. See CopyOptions.
	 */
	function cp(source, dest, options = {}) {
	    return __awaiter(this, void 0, void 0, function* () {
	        const { force, recursive, copySourceDirectory } = readCopyOptions(options);
	        const destStat = (yield ioUtil.exists(dest)) ? yield ioUtil.stat(dest) : null;
	        // Dest is an existing file, but not forcing
	        if (destStat && destStat.isFile() && !force) {
	            return;
	        }
	        // If dest is an existing directory, should copy inside.
	        const newDest = destStat && destStat.isDirectory() && copySourceDirectory
	            ? path.join(dest, path.basename(source))
	            : dest;
	        if (!(yield ioUtil.exists(source))) {
	            throw new Error(`no such file or directory: ${source}`);
	        }
	        const sourceStat = yield ioUtil.stat(source);
	        if (sourceStat.isDirectory()) {
	            if (!recursive) {
	                throw new Error(`Failed to copy. ${source} is a directory, but tried to copy without recursive flag.`);
	            }
	            else {
	                yield cpDirRecursive(source, newDest, 0, force);
	            }
	        }
	        else {
	            if (path.relative(source, newDest) === '') {
	                // a file cannot be copied to itself
	                throw new Error(`'${newDest}' and '${source}' are the same file`);
	            }
	            yield copyFile(source, newDest, force);
	        }
	    });
	}
	io.cp = cp;
	/**
	 * Moves a path.
	 *
	 * @param     source    source path
	 * @param     dest      destination path
	 * @param     options   optional. See MoveOptions.
	 */
	function mv(source, dest, options = {}) {
	    return __awaiter(this, void 0, void 0, function* () {
	        if (yield ioUtil.exists(dest)) {
	            let destExists = true;
	            if (yield ioUtil.isDirectory(dest)) {
	                // If dest is directory copy src into dest
	                dest = path.join(dest, path.basename(source));
	                destExists = yield ioUtil.exists(dest);
	            }
	            if (destExists) {
	                if (options.force == null || options.force) {
	                    yield rmRF(dest);
	                }
	                else {
	                    throw new Error('Destination already exists');
	                }
	            }
	        }
	        yield mkdirP(path.dirname(dest));
	        yield ioUtil.rename(source, dest);
	    });
	}
	io.mv = mv;
	/**
	 * Remove a path recursively with force
	 *
	 * @param inputPath path to remove
	 */
	function rmRF(inputPath) {
	    return __awaiter(this, void 0, void 0, function* () {
	        if (ioUtil.IS_WINDOWS) {
	            // Check for invalid characters
	            // https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file
	            if (/[*"<>|]/.test(inputPath)) {
	                throw new Error('File path must not contain `*`, `"`, `<`, `>` or `|` on Windows');
	            }
	        }
	        try {
	            // note if path does not exist, error is silent
	            yield ioUtil.rm(inputPath, {
	                force: true,
	                maxRetries: 3,
	                recursive: true,
	                retryDelay: 300
	            });
	        }
	        catch (err) {
	            throw new Error(`File was unable to be removed ${err}`);
	        }
	    });
	}
	io.rmRF = rmRF;
	/**
	 * Make a directory.  Creates the full path with folders in between
	 * Will throw if it fails
	 *
	 * @param   fsPath        path to create
	 * @returns Promise<void>
	 */
	function mkdirP(fsPath) {
	    return __awaiter(this, void 0, void 0, function* () {
	        assert_1.ok(fsPath, 'a path argument must be provided');
	        yield ioUtil.mkdir(fsPath, { recursive: true });
	    });
	}
	io.mkdirP = mkdirP;
	/**
	 * Returns path of a tool had the tool actually been invoked.  Resolves via paths.
	 * If you check and the tool does not exist, it will throw.
	 *
	 * @param     tool              name of the tool
	 * @param     check             whether to check if tool exists
	 * @returns   Promise<string>   path to tool
	 */
	function which(tool, check) {
	    return __awaiter(this, void 0, void 0, function* () {
	        if (!tool) {
	            throw new Error("parameter 'tool' is required");
	        }
	        // recursive when check=true
	        if (check) {
	            const result = yield which(tool, false);
	            if (!result) {
	                if (ioUtil.IS_WINDOWS) {
	                    throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also verify the file has a valid extension for an executable file.`);
	                }
	                else {
	                    throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also check the file mode to verify the file is executable.`);
	                }
	            }
	            return result;
	        }
	        const matches = yield findInPath(tool);
	        if (matches && matches.length > 0) {
	            return matches[0];
	        }
	        return '';
	    });
	}
	io.which = which;
	/**
	 * Returns a list of all occurrences of the given tool on the system path.
	 *
	 * @returns   Promise<string[]>  the paths of the tool
	 */
	function findInPath(tool) {
	    return __awaiter(this, void 0, void 0, function* () {
	        if (!tool) {
	            throw new Error("parameter 'tool' is required");
	        }
	        // build the list of extensions to try
	        const extensions = [];
	        if (ioUtil.IS_WINDOWS && process.env['PATHEXT']) {
	            for (const extension of process.env['PATHEXT'].split(path.delimiter)) {
	                if (extension) {
	                    extensions.push(extension);
	                }
	            }
	        }
	        // if it's rooted, return it if exists. otherwise return empty.
	        if (ioUtil.isRooted(tool)) {
	            const filePath = yield ioUtil.tryGetExecutablePath(tool, extensions);
	            if (filePath) {
	                return [filePath];
	            }
	            return [];
	        }
	        // if any path separators, return empty
	        if (tool.includes(path.sep)) {
	            return [];
	        }
	        // build the list of directories
	        //
	        // Note, technically "where" checks the current directory on Windows. From a toolkit perspective,
	        // it feels like we should not do this. Checking the current directory seems like more of a use
	        // case of a shell, and the which() function exposed by the toolkit should strive for consistency
	        // across platforms.
	        const directories = [];
	        if (process.env.PATH) {
	            for (const p of process.env.PATH.split(path.delimiter)) {
	                if (p) {
	                    directories.push(p);
	                }
	            }
	        }
	        // find all matches
	        const matches = [];
	        for (const directory of directories) {
	            const filePath = yield ioUtil.tryGetExecutablePath(path.join(directory, tool), extensions);
	            if (filePath) {
	                matches.push(filePath);
	            }
	        }
	        return matches;
	    });
	}
	io.findInPath = findInPath;
	function readCopyOptions(options) {
	    const force = options.force == null ? true : options.force;
	    const recursive = Boolean(options.recursive);
	    const copySourceDirectory = options.copySourceDirectory == null
	        ? true
	        : Boolean(options.copySourceDirectory);
	    return { force, recursive, copySourceDirectory };
	}
	function cpDirRecursive(sourceDir, destDir, currentDepth, force) {
	    return __awaiter(this, void 0, void 0, function* () {
	        // Ensure there is not a run away recursive copy
	        if (currentDepth >= 255)
	            return;
	        currentDepth++;
	        yield mkdirP(destDir);
	        const files = yield ioUtil.readdir(sourceDir);
	        for (const fileName of files) {
	            const srcFile = `${sourceDir}/${fileName}`;
	            const destFile = `${destDir}/${fileName}`;
	            const srcFileStat = yield ioUtil.lstat(srcFile);
	            if (srcFileStat.isDirectory()) {
	                // Recurse
	                yield cpDirRecursive(srcFile, destFile, currentDepth, force);
	            }
	            else {
	                yield copyFile(srcFile, destFile, force);
	            }
	        }
	        // Change the mode for the newly created directory
	        yield ioUtil.chmod(destDir, (yield ioUtil.stat(sourceDir)).mode);
	    });
	}
	// Buffered file copy
	function copyFile(srcFile, destFile, force) {
	    return __awaiter(this, void 0, void 0, function* () {
	        if ((yield ioUtil.lstat(srcFile)).isSymbolicLink()) {
	            // unlink/re-link it
	            try {
	                yield ioUtil.lstat(destFile);
	                yield ioUtil.unlink(destFile);
	            }
	            catch (e) {
	                // Try to override file permission
	                if (e.code === 'EPERM') {
	                    yield ioUtil.chmod(destFile, '0666');
	                    yield ioUtil.unlink(destFile);
	                }
	                // other errors = it doesn't exist, no work to do
	            }
	            // Copy over symlink
	            const symlinkFull = yield ioUtil.readlink(srcFile);
	            yield ioUtil.symlink(symlinkFull, destFile, ioUtil.IS_WINDOWS ? 'junction' : null);
	        }
	        else if (!(yield ioUtil.exists(destFile)) || force) {
	            yield ioUtil.copyFile(srcFile, destFile);
	        }
	    });
	}
	
	return io;
}

var hasRequiredToolrunner;

function requireToolrunner () {
	if (hasRequiredToolrunner) return toolrunner;
	hasRequiredToolrunner = 1;
	var __createBinding = (toolrunner && toolrunner.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (toolrunner && toolrunner.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (toolrunner && toolrunner.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	var __awaiter = (toolrunner && toolrunner.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	Object.defineProperty(toolrunner, "__esModule", { value: true });
	toolrunner.argStringToArray = toolrunner.ToolRunner = void 0;
	const os = __importStar(require$$0);
	const events = __importStar(require$$0$3);
	const child = __importStar(require$$2$2);
	const path = __importStar(sysPath__default);
	const io = __importStar(requireIo());
	const ioUtil = __importStar(requireIoUtil());
	const timers_1 = require$$6$1;
	/* eslint-disable @typescript-eslint/unbound-method */
	const IS_WINDOWS = process.platform === 'win32';
	/*
	 * Class for running command line tools. Handles quoting and arg parsing in a platform agnostic way.
	 */
	class ToolRunner extends events.EventEmitter {
	    constructor(toolPath, args, options) {
	        super();
	        if (!toolPath) {
	            throw new Error("Parameter 'toolPath' cannot be null or empty.");
	        }
	        this.toolPath = toolPath;
	        this.args = args || [];
	        this.options = options || {};
	    }
	    _debug(message) {
	        if (this.options.listeners && this.options.listeners.debug) {
	            this.options.listeners.debug(message);
	        }
	    }
	    _getCommandString(options, noPrefix) {
	        const toolPath = this._getSpawnFileName();
	        const args = this._getSpawnArgs(options);
	        let cmd = noPrefix ? '' : '[command]'; // omit prefix when piped to a second tool
	        if (IS_WINDOWS) {
	            // Windows + cmd file
	            if (this._isCmdFile()) {
	                cmd += toolPath;
	                for (const a of args) {
	                    cmd += ` ${a}`;
	                }
	            }
	            // Windows + verbatim
	            else if (options.windowsVerbatimArguments) {
	                cmd += `"${toolPath}"`;
	                for (const a of args) {
	                    cmd += ` ${a}`;
	                }
	            }
	            // Windows (regular)
	            else {
	                cmd += this._windowsQuoteCmdArg(toolPath);
	                for (const a of args) {
	                    cmd += ` ${this._windowsQuoteCmdArg(a)}`;
	                }
	            }
	        }
	        else {
	            // OSX/Linux - this can likely be improved with some form of quoting.
	            // creating processes on Unix is fundamentally different than Windows.
	            // on Unix, execvp() takes an arg array.
	            cmd += toolPath;
	            for (const a of args) {
	                cmd += ` ${a}`;
	            }
	        }
	        return cmd;
	    }
	    _processLineBuffer(data, strBuffer, onLine) {
	        try {
	            let s = strBuffer + data.toString();
	            let n = s.indexOf(os.EOL);
	            while (n > -1) {
	                const line = s.substring(0, n);
	                onLine(line);
	                // the rest of the string ...
	                s = s.substring(n + os.EOL.length);
	                n = s.indexOf(os.EOL);
	            }
	            return s;
	        }
	        catch (err) {
	            // streaming lines to console is best effort.  Don't fail a build.
	            this._debug(`error processing line. Failed with error ${err}`);
	            return '';
	        }
	    }
	    _getSpawnFileName() {
	        if (IS_WINDOWS) {
	            if (this._isCmdFile()) {
	                return process.env['COMSPEC'] || 'cmd.exe';
	            }
	        }
	        return this.toolPath;
	    }
	    _getSpawnArgs(options) {
	        if (IS_WINDOWS) {
	            if (this._isCmdFile()) {
	                let argline = `/D /S /C "${this._windowsQuoteCmdArg(this.toolPath)}`;
	                for (const a of this.args) {
	                    argline += ' ';
	                    argline += options.windowsVerbatimArguments
	                        ? a
	                        : this._windowsQuoteCmdArg(a);
	                }
	                argline += '"';
	                return [argline];
	            }
	        }
	        return this.args;
	    }
	    _endsWith(str, end) {
	        return str.endsWith(end);
	    }
	    _isCmdFile() {
	        const upperToolPath = this.toolPath.toUpperCase();
	        return (this._endsWith(upperToolPath, '.CMD') ||
	            this._endsWith(upperToolPath, '.BAT'));
	    }
	    _windowsQuoteCmdArg(arg) {
	        // for .exe, apply the normal quoting rules that libuv applies
	        if (!this._isCmdFile()) {
	            return this._uvQuoteCmdArg(arg);
	        }
	        // otherwise apply quoting rules specific to the cmd.exe command line parser.
	        // the libuv rules are generic and are not designed specifically for cmd.exe
	        // command line parser.
	        //
	        // for a detailed description of the cmd.exe command line parser, refer to
	        // http://stackoverflow.com/questions/4094699/how-does-the-windows-command-interpreter-cmd-exe-parse-scripts/7970912#7970912
	        // need quotes for empty arg
	        if (!arg) {
	            return '""';
	        }
	        // determine whether the arg needs to be quoted
	        const cmdSpecialChars = [
	            ' ',
	            '\t',
	            '&',
	            '(',
	            ')',
	            '[',
	            ']',
	            '{',
	            '}',
	            '^',
	            '=',
	            ';',
	            '!',
	            "'",
	            '+',
	            ',',
	            '`',
	            '~',
	            '|',
	            '<',
	            '>',
	            '"'
	        ];
	        let needsQuotes = false;
	        for (const char of arg) {
	            if (cmdSpecialChars.some(x => x === char)) {
	                needsQuotes = true;
	                break;
	            }
	        }
	        // short-circuit if quotes not needed
	        if (!needsQuotes) {
	            return arg;
	        }
	        // the following quoting rules are very similar to the rules that by libuv applies.
	        //
	        // 1) wrap the string in quotes
	        //
	        // 2) double-up quotes - i.e. " => ""
	        //
	        //    this is different from the libuv quoting rules. libuv replaces " with \", which unfortunately
	        //    doesn't work well with a cmd.exe command line.
	        //
	        //    note, replacing " with "" also works well if the arg is passed to a downstream .NET console app.
	        //    for example, the command line:
	        //          foo.exe "myarg:""my val"""
	        //    is parsed by a .NET console app into an arg array:
	        //          [ "myarg:\"my val\"" ]
	        //    which is the same end result when applying libuv quoting rules. although the actual
	        //    command line from libuv quoting rules would look like:
	        //          foo.exe "myarg:\"my val\""
	        //
	        // 3) double-up slashes that precede a quote,
	        //    e.g.  hello \world    => "hello \world"
	        //          hello\"world    => "hello\\""world"
	        //          hello\\"world   => "hello\\\\""world"
	        //          hello world\    => "hello world\\"
	        //
	        //    technically this is not required for a cmd.exe command line, or the batch argument parser.
	        //    the reasons for including this as a .cmd quoting rule are:
	        //
	        //    a) this is optimized for the scenario where the argument is passed from the .cmd file to an
	        //       external program. many programs (e.g. .NET console apps) rely on the slash-doubling rule.
	        //
	        //    b) it's what we've been doing previously (by deferring to node default behavior) and we
	        //       haven't heard any complaints about that aspect.
	        //
	        // note, a weakness of the quoting rules chosen here, is that % is not escaped. in fact, % cannot be
	        // escaped when used on the command line directly - even though within a .cmd file % can be escaped
	        // by using %%.
	        //
	        // the saving grace is, on the command line, %var% is left as-is if var is not defined. this contrasts
	        // the line parsing rules within a .cmd file, where if var is not defined it is replaced with nothing.
	        //
	        // one option that was explored was replacing % with ^% - i.e. %var% => ^%var^%. this hack would
	        // often work, since it is unlikely that var^ would exist, and the ^ character is removed when the
	        // variable is used. the problem, however, is that ^ is not removed when %* is used to pass the args
	        // to an external program.
	        //
	        // an unexplored potential solution for the % escaping problem, is to create a wrapper .cmd file.
	        // % can be escaped within a .cmd file.
	        let reverse = '"';
	        let quoteHit = true;
	        for (let i = arg.length; i > 0; i--) {
	            // walk the string in reverse
	            reverse += arg[i - 1];
	            if (quoteHit && arg[i - 1] === '\\') {
	                reverse += '\\'; // double the slash
	            }
	            else if (arg[i - 1] === '"') {
	                quoteHit = true;
	                reverse += '"'; // double the quote
	            }
	            else {
	                quoteHit = false;
	            }
	        }
	        reverse += '"';
	        return reverse
	            .split('')
	            .reverse()
	            .join('');
	    }
	    _uvQuoteCmdArg(arg) {
	        // Tool runner wraps child_process.spawn() and needs to apply the same quoting as
	        // Node in certain cases where the undocumented spawn option windowsVerbatimArguments
	        // is used.
	        //
	        // Since this function is a port of quote_cmd_arg from Node 4.x (technically, lib UV,
	        // see https://github.com/nodejs/node/blob/v4.x/deps/uv/src/win/process.c for details),
	        // pasting copyright notice from Node within this function:
	        //
	        //      Copyright Joyent, Inc. and other Node contributors. All rights reserved.
	        //
	        //      Permission is hereby granted, free of charge, to any person obtaining a copy
	        //      of this software and associated documentation files (the "Software"), to
	        //      deal in the Software without restriction, including without limitation the
	        //      rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
	        //      sell copies of the Software, and to permit persons to whom the Software is
	        //      furnished to do so, subject to the following conditions:
	        //
	        //      The above copyright notice and this permission notice shall be included in
	        //      all copies or substantial portions of the Software.
	        //
	        //      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	        //      IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	        //      FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	        //      AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	        //      LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	        //      FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
	        //      IN THE SOFTWARE.
	        if (!arg) {
	            // Need double quotation for empty argument
	            return '""';
	        }
	        if (!arg.includes(' ') && !arg.includes('\t') && !arg.includes('"')) {
	            // No quotation needed
	            return arg;
	        }
	        if (!arg.includes('"') && !arg.includes('\\')) {
	            // No embedded double quotes or backslashes, so I can just wrap
	            // quote marks around the whole thing.
	            return `"${arg}"`;
	        }
	        // Expected input/output:
	        //   input : hello"world
	        //   output: "hello\"world"
	        //   input : hello""world
	        //   output: "hello\"\"world"
	        //   input : hello\world
	        //   output: hello\world
	        //   input : hello\\world
	        //   output: hello\\world
	        //   input : hello\"world
	        //   output: "hello\\\"world"
	        //   input : hello\\"world
	        //   output: "hello\\\\\"world"
	        //   input : hello world\
	        //   output: "hello world\\" - note the comment in libuv actually reads "hello world\"
	        //                             but it appears the comment is wrong, it should be "hello world\\"
	        let reverse = '"';
	        let quoteHit = true;
	        for (let i = arg.length; i > 0; i--) {
	            // walk the string in reverse
	            reverse += arg[i - 1];
	            if (quoteHit && arg[i - 1] === '\\') {
	                reverse += '\\';
	            }
	            else if (arg[i - 1] === '"') {
	                quoteHit = true;
	                reverse += '\\';
	            }
	            else {
	                quoteHit = false;
	            }
	        }
	        reverse += '"';
	        return reverse
	            .split('')
	            .reverse()
	            .join('');
	    }
	    _cloneExecOptions(options) {
	        options = options || {};
	        const result = {
	            cwd: options.cwd || process.cwd(),
	            env: options.env || process.env,
	            silent: options.silent || false,
	            windowsVerbatimArguments: options.windowsVerbatimArguments || false,
	            failOnStdErr: options.failOnStdErr || false,
	            ignoreReturnCode: options.ignoreReturnCode || false,
	            delay: options.delay || 10000
	        };
	        result.outStream = options.outStream || process.stdout;
	        result.errStream = options.errStream || process.stderr;
	        return result;
	    }
	    _getSpawnOptions(options, toolPath) {
	        options = options || {};
	        const result = {};
	        result.cwd = options.cwd;
	        result.env = options.env;
	        result['windowsVerbatimArguments'] =
	            options.windowsVerbatimArguments || this._isCmdFile();
	        if (options.windowsVerbatimArguments) {
	            result.argv0 = `"${toolPath}"`;
	        }
	        return result;
	    }
	    /**
	     * Exec a tool.
	     * Output will be streamed to the live console.
	     * Returns promise with return code
	     *
	     * @param     tool     path to tool to exec
	     * @param     options  optional exec options.  See ExecOptions
	     * @returns   number
	     */
	    exec() {
	        return __awaiter(this, void 0, void 0, function* () {
	            // root the tool path if it is unrooted and contains relative pathing
	            if (!ioUtil.isRooted(this.toolPath) &&
	                (this.toolPath.includes('/') ||
	                    (IS_WINDOWS && this.toolPath.includes('\\')))) {
	                // prefer options.cwd if it is specified, however options.cwd may also need to be rooted
	                this.toolPath = path.resolve(process.cwd(), this.options.cwd || process.cwd(), this.toolPath);
	            }
	            // if the tool is only a file name, then resolve it from the PATH
	            // otherwise verify it exists (add extension on Windows if necessary)
	            this.toolPath = yield io.which(this.toolPath, true);
	            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
	                this._debug(`exec tool: ${this.toolPath}`);
	                this._debug('arguments:');
	                for (const arg of this.args) {
	                    this._debug(`   ${arg}`);
	                }
	                const optionsNonNull = this._cloneExecOptions(this.options);
	                if (!optionsNonNull.silent && optionsNonNull.outStream) {
	                    optionsNonNull.outStream.write(this._getCommandString(optionsNonNull) + os.EOL);
	                }
	                const state = new ExecState(optionsNonNull, this.toolPath);
	                state.on('debug', (message) => {
	                    this._debug(message);
	                });
	                if (this.options.cwd && !(yield ioUtil.exists(this.options.cwd))) {
	                    return reject(new Error(`The cwd: ${this.options.cwd} does not exist!`));
	                }
	                const fileName = this._getSpawnFileName();
	                const cp = child.spawn(fileName, this._getSpawnArgs(optionsNonNull), this._getSpawnOptions(this.options, fileName));
	                let stdbuffer = '';
	                if (cp.stdout) {
	                    cp.stdout.on('data', (data) => {
	                        if (this.options.listeners && this.options.listeners.stdout) {
	                            this.options.listeners.stdout(data);
	                        }
	                        if (!optionsNonNull.silent && optionsNonNull.outStream) {
	                            optionsNonNull.outStream.write(data);
	                        }
	                        stdbuffer = this._processLineBuffer(data, stdbuffer, (line) => {
	                            if (this.options.listeners && this.options.listeners.stdline) {
	                                this.options.listeners.stdline(line);
	                            }
	                        });
	                    });
	                }
	                let errbuffer = '';
	                if (cp.stderr) {
	                    cp.stderr.on('data', (data) => {
	                        state.processStderr = true;
	                        if (this.options.listeners && this.options.listeners.stderr) {
	                            this.options.listeners.stderr(data);
	                        }
	                        if (!optionsNonNull.silent &&
	                            optionsNonNull.errStream &&
	                            optionsNonNull.outStream) {
	                            const s = optionsNonNull.failOnStdErr
	                                ? optionsNonNull.errStream
	                                : optionsNonNull.outStream;
	                            s.write(data);
	                        }
	                        errbuffer = this._processLineBuffer(data, errbuffer, (line) => {
	                            if (this.options.listeners && this.options.listeners.errline) {
	                                this.options.listeners.errline(line);
	                            }
	                        });
	                    });
	                }
	                cp.on('error', (err) => {
	                    state.processError = err.message;
	                    state.processExited = true;
	                    state.processClosed = true;
	                    state.CheckComplete();
	                });
	                cp.on('exit', (code) => {
	                    state.processExitCode = code;
	                    state.processExited = true;
	                    this._debug(`Exit code ${code} received from tool '${this.toolPath}'`);
	                    state.CheckComplete();
	                });
	                cp.on('close', (code) => {
	                    state.processExitCode = code;
	                    state.processExited = true;
	                    state.processClosed = true;
	                    this._debug(`STDIO streams have closed for tool '${this.toolPath}'`);
	                    state.CheckComplete();
	                });
	                state.on('done', (error, exitCode) => {
	                    if (stdbuffer.length > 0) {
	                        this.emit('stdline', stdbuffer);
	                    }
	                    if (errbuffer.length > 0) {
	                        this.emit('errline', errbuffer);
	                    }
	                    cp.removeAllListeners();
	                    if (error) {
	                        reject(error);
	                    }
	                    else {
	                        resolve(exitCode);
	                    }
	                });
	                if (this.options.input) {
	                    if (!cp.stdin) {
	                        throw new Error('child process missing stdin');
	                    }
	                    cp.stdin.end(this.options.input);
	                }
	            }));
	        });
	    }
	}
	toolrunner.ToolRunner = ToolRunner;
	/**
	 * Convert an arg string to an array of args. Handles escaping
	 *
	 * @param    argString   string of arguments
	 * @returns  string[]    array of arguments
	 */
	function argStringToArray(argString) {
	    const args = [];
	    let inQuotes = false;
	    let escaped = false;
	    let arg = '';
	    function append(c) {
	        // we only escape double quotes.
	        if (escaped && c !== '"') {
	            arg += '\\';
	        }
	        arg += c;
	        escaped = false;
	    }
	    for (let i = 0; i < argString.length; i++) {
	        const c = argString.charAt(i);
	        if (c === '"') {
	            if (!escaped) {
	                inQuotes = !inQuotes;
	            }
	            else {
	                append(c);
	            }
	            continue;
	        }
	        if (c === '\\' && escaped) {
	            append(c);
	            continue;
	        }
	        if (c === '\\' && inQuotes) {
	            escaped = true;
	            continue;
	        }
	        if (c === ' ' && !inQuotes) {
	            if (arg.length > 0) {
	                args.push(arg);
	                arg = '';
	            }
	            continue;
	        }
	        append(c);
	    }
	    if (arg.length > 0) {
	        args.push(arg.trim());
	    }
	    return args;
	}
	toolrunner.argStringToArray = argStringToArray;
	class ExecState extends events.EventEmitter {
	    constructor(options, toolPath) {
	        super();
	        this.processClosed = false; // tracks whether the process has exited and stdio is closed
	        this.processError = '';
	        this.processExitCode = 0;
	        this.processExited = false; // tracks whether the process has exited
	        this.processStderr = false; // tracks whether stderr was written to
	        this.delay = 10000; // 10 seconds
	        this.done = false;
	        this.timeout = null;
	        if (!toolPath) {
	            throw new Error('toolPath must not be empty');
	        }
	        this.options = options;
	        this.toolPath = toolPath;
	        if (options.delay) {
	            this.delay = options.delay;
	        }
	    }
	    CheckComplete() {
	        if (this.done) {
	            return;
	        }
	        if (this.processClosed) {
	            this._setResult();
	        }
	        else if (this.processExited) {
	            this.timeout = timers_1.setTimeout(ExecState.HandleTimeout, this.delay, this);
	        }
	    }
	    _debug(message) {
	        this.emit('debug', message);
	    }
	    _setResult() {
	        // determine whether there is an error
	        let error;
	        if (this.processExited) {
	            if (this.processError) {
	                error = new Error(`There was an error when attempting to execute the process '${this.toolPath}'. This may indicate the process failed to start. Error: ${this.processError}`);
	            }
	            else if (this.processExitCode !== 0 && !this.options.ignoreReturnCode) {
	                error = new Error(`The process '${this.toolPath}' failed with exit code ${this.processExitCode}`);
	            }
	            else if (this.processStderr && this.options.failOnStdErr) {
	                error = new Error(`The process '${this.toolPath}' failed because one or more lines were written to the STDERR stream`);
	            }
	        }
	        // clear the timeout
	        if (this.timeout) {
	            clearTimeout(this.timeout);
	            this.timeout = null;
	        }
	        this.done = true;
	        this.emit('done', error, this.processExitCode);
	    }
	    static HandleTimeout(state) {
	        if (state.done) {
	            return;
	        }
	        if (!state.processClosed && state.processExited) {
	            const message = `The STDIO streams did not close within ${state.delay /
	                1000} seconds of the exit event from process '${state.toolPath}'. This may indicate a child process inherited the STDIO streams and has not yet exited.`;
	            state._debug(message);
	        }
	        state._setResult();
	    }
	}
	
	return toolrunner;
}

var hasRequiredExec;

function requireExec () {
	if (hasRequiredExec) return exec;
	hasRequiredExec = 1;
	var __createBinding = (exec && exec.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (exec && exec.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (exec && exec.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	var __awaiter = (exec && exec.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	Object.defineProperty(exec, "__esModule", { value: true });
	exec.getExecOutput = exec.exec = void 0;
	const string_decoder_1 = require$$6;
	const tr = __importStar(requireToolrunner());
	/**
	 * Exec a command.
	 * Output will be streamed to the live console.
	 * Returns promise with return code
	 *
	 * @param     commandLine        command to execute (can include additional args). Must be correctly escaped.
	 * @param     args               optional arguments for tool. Escaping is handled by the lib.
	 * @param     options            optional exec options.  See ExecOptions
	 * @returns   Promise<number>    exit code
	 */
	function exec$1(commandLine, args, options) {
	    return __awaiter(this, void 0, void 0, function* () {
	        const commandArgs = tr.argStringToArray(commandLine);
	        if (commandArgs.length === 0) {
	            throw new Error(`Parameter 'commandLine' cannot be null or empty.`);
	        }
	        // Path to tool to execute should be first arg
	        const toolPath = commandArgs[0];
	        args = commandArgs.slice(1).concat(args || []);
	        const runner = new tr.ToolRunner(toolPath, args, options);
	        return runner.exec();
	    });
	}
	exec.exec = exec$1;
	/**
	 * Exec a command and get the output.
	 * Output will be streamed to the live console.
	 * Returns promise with the exit code and collected stdout and stderr
	 *
	 * @param     commandLine           command to execute (can include additional args). Must be correctly escaped.
	 * @param     args                  optional arguments for tool. Escaping is handled by the lib.
	 * @param     options               optional exec options.  See ExecOptions
	 * @returns   Promise<ExecOutput>   exit code, stdout, and stderr
	 */
	function getExecOutput(commandLine, args, options) {
	    var _a, _b;
	    return __awaiter(this, void 0, void 0, function* () {
	        let stdout = '';
	        let stderr = '';
	        //Using string decoder covers the case where a mult-byte character is split
	        const stdoutDecoder = new string_decoder_1.StringDecoder('utf8');
	        const stderrDecoder = new string_decoder_1.StringDecoder('utf8');
	        const originalStdoutListener = (_a = options === null || options === void 0 ? void 0 : options.listeners) === null || _a === void 0 ? void 0 : _a.stdout;
	        const originalStdErrListener = (_b = options === null || options === void 0 ? void 0 : options.listeners) === null || _b === void 0 ? void 0 : _b.stderr;
	        const stdErrListener = (data) => {
	            stderr += stderrDecoder.write(data);
	            if (originalStdErrListener) {
	                originalStdErrListener(data);
	            }
	        };
	        const stdOutListener = (data) => {
	            stdout += stdoutDecoder.write(data);
	            if (originalStdoutListener) {
	                originalStdoutListener(data);
	            }
	        };
	        const listeners = Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.listeners), { stdout: stdOutListener, stderr: stdErrListener });
	        const exitCode = yield exec$1(commandLine, args, Object.assign(Object.assign({}, options), { listeners }));
	        //flush any remaining characters
	        stdout += stdoutDecoder.end();
	        stderr += stderrDecoder.end();
	        return {
	            exitCode,
	            stdout,
	            stderr
	        };
	    });
	}
	exec.getExecOutput = getExecOutput;
	
	return exec;
}

var hasRequiredPlatform;

function requirePlatform () {
	if (hasRequiredPlatform) return platform$1;
	hasRequiredPlatform = 1;
	(function (exports) {
		var __createBinding = (platform$1 && platform$1.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __setModuleDefault = (platform$1 && platform$1.__setModuleDefault) || (Object.create ? (function(o, v) {
		    Object.defineProperty(o, "default", { enumerable: true, value: v });
		}) : function(o, v) {
		    o["default"] = v;
		});
		var __importStar = (platform$1 && platform$1.__importStar) || function (mod) {
		    if (mod && mod.__esModule) return mod;
		    var result = {};
		    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		    __setModuleDefault(result, mod);
		    return result;
		};
		var __awaiter = (platform$1 && platform$1.__awaiter) || function (thisArg, _arguments, P, generator) {
		    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
		    return new (P || (P = Promise))(function (resolve, reject) {
		        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
		        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
		        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
		        step((generator = generator.apply(thisArg, _arguments || [])).next());
		    });
		};
		var __importDefault = (platform$1 && platform$1.__importDefault) || function (mod) {
		    return (mod && mod.__esModule) ? mod : { "default": mod };
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.getDetails = exports.isLinux = exports.isMacOS = exports.isWindows = exports.arch = exports.platform = void 0;
		const os_1 = __importDefault(require$$0);
		const exec = __importStar(requireExec());
		const getWindowsInfo = () => __awaiter(void 0, void 0, void 0, function* () {
		    const { stdout: version } = yield exec.getExecOutput('powershell -command "(Get-CimInstance -ClassName Win32_OperatingSystem).Version"', undefined, {
		        silent: true
		    });
		    const { stdout: name } = yield exec.getExecOutput('powershell -command "(Get-CimInstance -ClassName Win32_OperatingSystem).Caption"', undefined, {
		        silent: true
		    });
		    return {
		        name: name.trim(),
		        version: version.trim()
		    };
		});
		const getMacOsInfo = () => __awaiter(void 0, void 0, void 0, function* () {
		    var _a, _b, _c, _d;
		    const { stdout } = yield exec.getExecOutput('sw_vers', undefined, {
		        silent: true
		    });
		    const version = (_b = (_a = stdout.match(/ProductVersion:\s*(.+)/)) === null || _a === void 0 ? void 0 : _a[1]) !== null && _b !== void 0 ? _b : '';
		    const name = (_d = (_c = stdout.match(/ProductName:\s*(.+)/)) === null || _c === void 0 ? void 0 : _c[1]) !== null && _d !== void 0 ? _d : '';
		    return {
		        name,
		        version
		    };
		});
		const getLinuxInfo = () => __awaiter(void 0, void 0, void 0, function* () {
		    const { stdout } = yield exec.getExecOutput('lsb_release', ['-i', '-r', '-s'], {
		        silent: true
		    });
		    const [name, version] = stdout.trim().split('\n');
		    return {
		        name,
		        version
		    };
		});
		exports.platform = os_1.default.platform();
		exports.arch = os_1.default.arch();
		exports.isWindows = exports.platform === 'win32';
		exports.isMacOS = exports.platform === 'darwin';
		exports.isLinux = exports.platform === 'linux';
		function getDetails() {
		    return __awaiter(this, void 0, void 0, function* () {
		        return Object.assign(Object.assign({}, (yield (exports.isWindows
		            ? getWindowsInfo()
		            : exports.isMacOS
		                ? getMacOsInfo()
		                : getLinuxInfo()))), { platform: exports.platform,
		            arch: exports.arch,
		            isWindows: exports.isWindows,
		            isMacOS: exports.isMacOS,
		            isLinux: exports.isLinux });
		    });
		}
		exports.getDetails = getDetails;
		
	} (platform$1));
	return platform$1;
}

var hasRequiredCore;

function requireCore () {
	if (hasRequiredCore) return core;
	hasRequiredCore = 1;
	(function (exports) {
		var __createBinding = (core && core.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __setModuleDefault = (core && core.__setModuleDefault) || (Object.create ? (function(o, v) {
		    Object.defineProperty(o, "default", { enumerable: true, value: v });
		}) : function(o, v) {
		    o["default"] = v;
		});
		var __importStar = (core && core.__importStar) || function (mod) {
		    if (mod && mod.__esModule) return mod;
		    var result = {};
		    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		    __setModuleDefault(result, mod);
		    return result;
		};
		var __awaiter = (core && core.__awaiter) || function (thisArg, _arguments, P, generator) {
		    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
		    return new (P || (P = Promise))(function (resolve, reject) {
		        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
		        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
		        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
		        step((generator = generator.apply(thisArg, _arguments || [])).next());
		    });
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.platform = exports.toPlatformPath = exports.toWin32Path = exports.toPosixPath = exports.markdownSummary = exports.summary = exports.getIDToken = exports.getState = exports.saveState = exports.group = exports.endGroup = exports.startGroup = exports.info = exports.notice = exports.warning = exports.error = exports.debug = exports.isDebug = exports.setFailed = exports.setCommandEcho = exports.setOutput = exports.getBooleanInput = exports.getMultilineInput = exports.getInput = exports.addPath = exports.setSecret = exports.exportVariable = exports.ExitCode = void 0;
		const command_1 = requireCommand();
		const file_command_1 = requireFileCommand();
		const utils_1 = requireUtils$2();
		const os = __importStar(require$$0);
		const path = __importStar(sysPath__default);
		const oidc_utils_1 = requireOidcUtils();
		/**
		 * The code to exit an action
		 */
		var ExitCode;
		(function (ExitCode) {
		    /**
		     * A code indicating that the action was successful
		     */
		    ExitCode[ExitCode["Success"] = 0] = "Success";
		    /**
		     * A code indicating that the action was a failure
		     */
		    ExitCode[ExitCode["Failure"] = 1] = "Failure";
		})(ExitCode || (exports.ExitCode = ExitCode = {}));
		//-----------------------------------------------------------------------
		// Variables
		//-----------------------------------------------------------------------
		/**
		 * Sets env variable for this action and future actions in the job
		 * @param name the name of the variable to set
		 * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify
		 */
		// eslint-disable-next-line @typescript-eslint/no-explicit-any
		function exportVariable(name, val) {
		    const convertedVal = (0, utils_1.toCommandValue)(val);
		    process.env[name] = convertedVal;
		    const filePath = process.env['GITHUB_ENV'] || '';
		    if (filePath) {
		        return (0, file_command_1.issueFileCommand)('ENV', (0, file_command_1.prepareKeyValueMessage)(name, val));
		    }
		    (0, command_1.issueCommand)('set-env', { name }, convertedVal);
		}
		exports.exportVariable = exportVariable;
		/**
		 * Registers a secret which will get masked from logs
		 * @param secret value of the secret
		 */
		function setSecret(secret) {
		    (0, command_1.issueCommand)('add-mask', {}, secret);
		}
		exports.setSecret = setSecret;
		/**
		 * Prepends inputPath to the PATH (for this action and future actions)
		 * @param inputPath
		 */
		function addPath(inputPath) {
		    const filePath = process.env['GITHUB_PATH'] || '';
		    if (filePath) {
		        (0, file_command_1.issueFileCommand)('PATH', inputPath);
		    }
		    else {
		        (0, command_1.issueCommand)('add-path', {}, inputPath);
		    }
		    process.env['PATH'] = `${inputPath}${path.delimiter}${process.env['PATH']}`;
		}
		exports.addPath = addPath;
		/**
		 * Gets the value of an input.
		 * Unless trimWhitespace is set to false in InputOptions, the value is also trimmed.
		 * Returns an empty string if the value is not defined.
		 *
		 * @param     name     name of the input to get
		 * @param     options  optional. See InputOptions.
		 * @returns   string
		 */
		function getInput(name, options) {
		    const val = process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || '';
		    if (options && options.required && !val) {
		        throw new Error(`Input required and not supplied: ${name}`);
		    }
		    if (options && options.trimWhitespace === false) {
		        return val;
		    }
		    return val.trim();
		}
		exports.getInput = getInput;
		/**
		 * Gets the values of an multiline input.  Each value is also trimmed.
		 *
		 * @param     name     name of the input to get
		 * @param     options  optional. See InputOptions.
		 * @returns   string[]
		 *
		 */
		function getMultilineInput(name, options) {
		    const inputs = getInput(name, options)
		        .split('\n')
		        .filter(x => x !== '');
		    if (options && options.trimWhitespace === false) {
		        return inputs;
		    }
		    return inputs.map(input => input.trim());
		}
		exports.getMultilineInput = getMultilineInput;
		/**
		 * Gets the input value of the boolean type in the YAML 1.2 "core schema" specification.
		 * Support boolean input list: `true | True | TRUE | false | False | FALSE` .
		 * The return value is also in boolean type.
		 * ref: https://yaml.org/spec/1.2/spec.html#id2804923
		 *
		 * @param     name     name of the input to get
		 * @param     options  optional. See InputOptions.
		 * @returns   boolean
		 */
		function getBooleanInput(name, options) {
		    const trueValue = ['true', 'True', 'TRUE'];
		    const falseValue = ['false', 'False', 'FALSE'];
		    const val = getInput(name, options);
		    if (trueValue.includes(val))
		        return true;
		    if (falseValue.includes(val))
		        return false;
		    throw new TypeError(`Input does not meet YAML 1.2 "Core Schema" specification: ${name}\n` +
		        `Support boolean input list: \`true | True | TRUE | false | False | FALSE\``);
		}
		exports.getBooleanInput = getBooleanInput;
		/**
		 * Sets the value of an output.
		 *
		 * @param     name     name of the output to set
		 * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
		 */
		// eslint-disable-next-line @typescript-eslint/no-explicit-any
		function setOutput(name, value) {
		    const filePath = process.env['GITHUB_OUTPUT'] || '';
		    if (filePath) {
		        return (0, file_command_1.issueFileCommand)('OUTPUT', (0, file_command_1.prepareKeyValueMessage)(name, value));
		    }
		    process.stdout.write(os.EOL);
		    (0, command_1.issueCommand)('set-output', { name }, (0, utils_1.toCommandValue)(value));
		}
		exports.setOutput = setOutput;
		/**
		 * Enables or disables the echoing of commands into stdout for the rest of the step.
		 * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.
		 *
		 */
		function setCommandEcho(enabled) {
		    (0, command_1.issue)('echo', enabled ? 'on' : 'off');
		}
		exports.setCommandEcho = setCommandEcho;
		//-----------------------------------------------------------------------
		// Results
		//-----------------------------------------------------------------------
		/**
		 * Sets the action status to failed.
		 * When the action exits it will be with an exit code of 1
		 * @param message add error issue message
		 */
		function setFailed(message) {
		    process.exitCode = ExitCode.Failure;
		    error(message);
		}
		exports.setFailed = setFailed;
		//-----------------------------------------------------------------------
		// Logging Commands
		//-----------------------------------------------------------------------
		/**
		 * Gets whether Actions Step Debug is on or not
		 */
		function isDebug() {
		    return process.env['RUNNER_DEBUG'] === '1';
		}
		exports.isDebug = isDebug;
		/**
		 * Writes debug message to user log
		 * @param message debug message
		 */
		function debug(message) {
		    (0, command_1.issueCommand)('debug', {}, message);
		}
		exports.debug = debug;
		/**
		 * Adds an error issue
		 * @param message error issue message. Errors will be converted to string via toString()
		 * @param properties optional properties to add to the annotation.
		 */
		function error(message, properties = {}) {
		    (0, command_1.issueCommand)('error', (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
		}
		exports.error = error;
		/**
		 * Adds a warning issue
		 * @param message warning issue message. Errors will be converted to string via toString()
		 * @param properties optional properties to add to the annotation.
		 */
		function warning(message, properties = {}) {
		    (0, command_1.issueCommand)('warning', (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
		}
		exports.warning = warning;
		/**
		 * Adds a notice issue
		 * @param message notice issue message. Errors will be converted to string via toString()
		 * @param properties optional properties to add to the annotation.
		 */
		function notice(message, properties = {}) {
		    (0, command_1.issueCommand)('notice', (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
		}
		exports.notice = notice;
		/**
		 * Writes info to log with console.log.
		 * @param message info message
		 */
		function info(message) {
		    process.stdout.write(message + os.EOL);
		}
		exports.info = info;
		/**
		 * Begin an output group.
		 *
		 * Output until the next `groupEnd` will be foldable in this group
		 *
		 * @param name The name of the output group
		 */
		function startGroup(name) {
		    (0, command_1.issue)('group', name);
		}
		exports.startGroup = startGroup;
		/**
		 * End an output group.
		 */
		function endGroup() {
		    (0, command_1.issue)('endgroup');
		}
		exports.endGroup = endGroup;
		/**
		 * Wrap an asynchronous function call in a group.
		 *
		 * Returns the same type as the function itself.
		 *
		 * @param name The name of the group
		 * @param fn The function to wrap in the group
		 */
		function group(name, fn) {
		    return __awaiter(this, void 0, void 0, function* () {
		        startGroup(name);
		        let result;
		        try {
		            result = yield fn();
		        }
		        finally {
		            endGroup();
		        }
		        return result;
		    });
		}
		exports.group = group;
		//-----------------------------------------------------------------------
		// Wrapper action state
		//-----------------------------------------------------------------------
		/**
		 * Saves state for current action, the state can only be retrieved by this action's post job execution.
		 *
		 * @param     name     name of the state to store
		 * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
		 */
		// eslint-disable-next-line @typescript-eslint/no-explicit-any
		function saveState(name, value) {
		    const filePath = process.env['GITHUB_STATE'] || '';
		    if (filePath) {
		        return (0, file_command_1.issueFileCommand)('STATE', (0, file_command_1.prepareKeyValueMessage)(name, value));
		    }
		    (0, command_1.issueCommand)('save-state', { name }, (0, utils_1.toCommandValue)(value));
		}
		exports.saveState = saveState;
		/**
		 * Gets the value of an state set by this action's main execution.
		 *
		 * @param     name     name of the state to get
		 * @returns   string
		 */
		function getState(name) {
		    return process.env[`STATE_${name}`] || '';
		}
		exports.getState = getState;
		function getIDToken(aud) {
		    return __awaiter(this, void 0, void 0, function* () {
		        return yield oidc_utils_1.OidcClient.getIDToken(aud);
		    });
		}
		exports.getIDToken = getIDToken;
		/**
		 * Summary exports
		 */
		var summary_1 = requireSummary();
		Object.defineProperty(exports, "summary", { enumerable: true, get: function () { return summary_1.summary; } });
		/**
		 * @deprecated use core.summary
		 */
		var summary_2 = requireSummary();
		Object.defineProperty(exports, "markdownSummary", { enumerable: true, get: function () { return summary_2.markdownSummary; } });
		/**
		 * Path exports
		 */
		var path_utils_1 = requirePathUtils();
		Object.defineProperty(exports, "toPosixPath", { enumerable: true, get: function () { return path_utils_1.toPosixPath; } });
		Object.defineProperty(exports, "toWin32Path", { enumerable: true, get: function () { return path_utils_1.toWin32Path; } });
		Object.defineProperty(exports, "toPlatformPath", { enumerable: true, get: function () { return path_utils_1.toPlatformPath; } });
		/**
		 * Platform utilities exports
		 */
		exports.platform = __importStar(requirePlatform());
		
	} (core));
	return core;
}

var coreExports = requireCore();

const _DRIVE_LETTER_START_RE = /^[A-Za-z]:\//;
function normalizeWindowsPath(input = "") {
  if (!input) {
    return input;
  }
  return input.replace(/\\/g, "/").replace(_DRIVE_LETTER_START_RE, (r) => r.toUpperCase());
}
const _EXTNAME_RE = /.(\.[^./]+|\.)$/;
const extname = function(p) {
  if (p === "..") return "";
  const match = _EXTNAME_RE.exec(normalizeWindowsPath(p));
  return match && match[1] || "";
};

function wrapToPromise(value) {
  if (!value || typeof value.then !== "function") {
    return Promise.resolve(value);
  }
  return value;
}
function asyncCall(function_, ...arguments_) {
  try {
    return wrapToPromise(function_(...arguments_));
  } catch (error) {
    return Promise.reject(error);
  }
}
function isPrimitive(value) {
  const type = typeof value;
  return value === null || type !== "object" && type !== "function";
}
function isPureObject(value) {
  const proto = Object.getPrototypeOf(value);
  return !proto || proto.isPrototypeOf(Object);
}
function stringify(value) {
  if (isPrimitive(value)) {
    return String(value);
  }
  if (isPureObject(value) || Array.isArray(value)) {
    return JSON.stringify(value);
  }
  if (typeof value.toJSON === "function") {
    return stringify(value.toJSON());
  }
  throw new Error("[unstorage] Cannot stringify value!");
}
const BASE64_PREFIX = "base64:";
function serializeRaw(value) {
  if (typeof value === "string") {
    return value;
  }
  return BASE64_PREFIX + base64Encode(value);
}
function deserializeRaw(value) {
  if (typeof value !== "string") {
    return value;
  }
  if (!value.startsWith(BASE64_PREFIX)) {
    return value;
  }
  return base64Decode(value.slice(BASE64_PREFIX.length));
}
function base64Decode(input) {
  if (globalThis.Buffer) {
    return Buffer.from(input, "base64");
  }
  return Uint8Array.from(
    globalThis.atob(input),
    (c) => c.codePointAt(0)
  );
}
function base64Encode(input) {
  if (globalThis.Buffer) {
    return Buffer.from(input).toString("base64");
  }
  return globalThis.btoa(String.fromCodePoint(...input));
}
function normalizeKey(key) {
  if (!key) {
    return "";
  }
  return key.split("?")[0]?.replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "") || "";
}
function joinKeys(...keys) {
  return normalizeKey(keys.join(":"));
}
function normalizeBaseKey(base) {
  base = normalizeKey(base);
  return base ? base + ":" : "";
}
function filterKeyByDepth(key, depth) {
  if (depth === void 0) {
    return true;
  }
  let substrCount = 0;
  let index = key.indexOf(":");
  while (index > -1) {
    substrCount++;
    index = key.indexOf(":", index + 1);
  }
  return substrCount <= depth;
}
function filterKeyByBase(key, base) {
  if (base) {
    return key.startsWith(base) && key[key.length - 1] !== "$";
  }
  return key[key.length - 1] !== "$";
}

function defineDriver$1(factory) {
  return factory;
}

const DRIVER_NAME$1 = "memory";
const memory = defineDriver$1(() => {
  const data = /* @__PURE__ */ new Map();
  return {
    name: DRIVER_NAME$1,
    getInstance: () => data,
    hasItem(key) {
      return data.has(key);
    },
    getItem(key) {
      return data.get(key) ?? null;
    },
    getItemRaw(key) {
      return data.get(key) ?? null;
    },
    setItem(key, value) {
      data.set(key, value);
    },
    setItemRaw(key, value) {
      data.set(key, value);
    },
    removeItem(key) {
      data.delete(key);
    },
    getKeys() {
      return [...data.keys()];
    },
    clear() {
      data.clear();
    },
    dispose() {
      data.clear();
    }
  };
});

function createStorage(options = {}) {
  const context = {
    mounts: { "": options.driver || memory() },
    mountpoints: [""],
    watching: false,
    watchListeners: [],
    unwatch: {}
  };
  const getMount = (key) => {
    for (const base of context.mountpoints) {
      if (key.startsWith(base)) {
        return {
          base,
          relativeKey: key.slice(base.length),
          driver: context.mounts[base]
        };
      }
    }
    return {
      base: "",
      relativeKey: key,
      driver: context.mounts[""]
    };
  };
  const getMounts = (base, includeParent) => {
    return context.mountpoints.filter(
      (mountpoint) => mountpoint.startsWith(base) || includeParent && base.startsWith(mountpoint)
    ).map((mountpoint) => ({
      relativeBase: base.length > mountpoint.length ? base.slice(mountpoint.length) : void 0,
      mountpoint,
      driver: context.mounts[mountpoint]
    }));
  };
  const onChange = (event, key) => {
    if (!context.watching) {
      return;
    }
    key = normalizeKey(key);
    for (const listener of context.watchListeners) {
      listener(event, key);
    }
  };
  const startWatch = async () => {
    if (context.watching) {
      return;
    }
    context.watching = true;
    for (const mountpoint in context.mounts) {
      context.unwatch[mountpoint] = await watch$1(
        context.mounts[mountpoint],
        onChange,
        mountpoint
      );
    }
  };
  const stopWatch = async () => {
    if (!context.watching) {
      return;
    }
    for (const mountpoint in context.unwatch) {
      await context.unwatch[mountpoint]();
    }
    context.unwatch = {};
    context.watching = false;
  };
  const runBatch = (items, commonOptions, cb) => {
    const batches = /* @__PURE__ */ new Map();
    const getBatch = (mount) => {
      let batch = batches.get(mount.base);
      if (!batch) {
        batch = {
          driver: mount.driver,
          base: mount.base,
          items: []
        };
        batches.set(mount.base, batch);
      }
      return batch;
    };
    for (const item of items) {
      const isStringItem = typeof item === "string";
      const key = normalizeKey(isStringItem ? item : item.key);
      const value = isStringItem ? void 0 : item.value;
      const options2 = isStringItem || !item.options ? commonOptions : { ...commonOptions, ...item.options };
      const mount = getMount(key);
      getBatch(mount).items.push({
        key,
        value,
        relativeKey: mount.relativeKey,
        options: options2
      });
    }
    return Promise.all([...batches.values()].map((batch) => cb(batch))).then(
      (r) => r.flat()
    );
  };
  const storage = {
    // Item
    hasItem(key, opts = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      return asyncCall(driver.hasItem, relativeKey, opts);
    },
    getItem(key, opts = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      return asyncCall(driver.getItem, relativeKey, opts).then(
        (value) => destr(value)
      );
    },
    getItems(items, commonOptions = {}) {
      return runBatch(items, commonOptions, (batch) => {
        if (batch.driver.getItems) {
          return asyncCall(
            batch.driver.getItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              options: item.options
            })),
            commonOptions
          ).then(
            (r) => r.map((item) => ({
              key: joinKeys(batch.base, item.key),
              value: destr(item.value)
            }))
          );
        }
        return Promise.all(
          batch.items.map((item) => {
            return asyncCall(
              batch.driver.getItem,
              item.relativeKey,
              item.options
            ).then((value) => ({
              key: item.key,
              value: destr(value)
            }));
          })
        );
      });
    },
    getItemRaw(key, opts = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (driver.getItemRaw) {
        return asyncCall(driver.getItemRaw, relativeKey, opts);
      }
      return asyncCall(driver.getItem, relativeKey, opts).then(
        (value) => deserializeRaw(value)
      );
    },
    async setItem(key, value, opts = {}) {
      if (value === void 0) {
        return storage.removeItem(key);
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (!driver.setItem) {
        return;
      }
      await asyncCall(driver.setItem, relativeKey, stringify(value), opts);
      if (!driver.watch) {
        onChange("update", key);
      }
    },
    async setItems(items, commonOptions) {
      await runBatch(items, commonOptions, async (batch) => {
        if (batch.driver.setItems) {
          return asyncCall(
            batch.driver.setItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              value: stringify(item.value),
              options: item.options
            })),
            commonOptions
          );
        }
        if (!batch.driver.setItem) {
          return;
        }
        await Promise.all(
          batch.items.map((item) => {
            return asyncCall(
              batch.driver.setItem,
              item.relativeKey,
              stringify(item.value),
              item.options
            );
          })
        );
      });
    },
    async setItemRaw(key, value, opts = {}) {
      if (value === void 0) {
        return storage.removeItem(key, opts);
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (driver.setItemRaw) {
        await asyncCall(driver.setItemRaw, relativeKey, value, opts);
      } else if (driver.setItem) {
        await asyncCall(driver.setItem, relativeKey, serializeRaw(value), opts);
      } else {
        return;
      }
      if (!driver.watch) {
        onChange("update", key);
      }
    },
    async removeItem(key, opts = {}) {
      if (typeof opts === "boolean") {
        opts = { removeMeta: opts };
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (!driver.removeItem) {
        return;
      }
      await asyncCall(driver.removeItem, relativeKey, opts);
      if (opts.removeMeta || opts.removeMata) {
        await asyncCall(driver.removeItem, relativeKey + "$", opts);
      }
      if (!driver.watch) {
        onChange("remove", key);
      }
    },
    // Meta
    async getMeta(key, opts = {}) {
      if (typeof opts === "boolean") {
        opts = { nativeOnly: opts };
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      const meta = /* @__PURE__ */ Object.create(null);
      if (driver.getMeta) {
        Object.assign(meta, await asyncCall(driver.getMeta, relativeKey, opts));
      }
      if (!opts.nativeOnly) {
        const value = await asyncCall(
          driver.getItem,
          relativeKey + "$",
          opts
        ).then((value_) => destr(value_));
        if (value && typeof value === "object") {
          if (typeof value.atime === "string") {
            value.atime = new Date(value.atime);
          }
          if (typeof value.mtime === "string") {
            value.mtime = new Date(value.mtime);
          }
          Object.assign(meta, value);
        }
      }
      return meta;
    },
    setMeta(key, value, opts = {}) {
      return this.setItem(key + "$", value, opts);
    },
    removeMeta(key, opts = {}) {
      return this.removeItem(key + "$", opts);
    },
    // Keys
    async getKeys(base, opts = {}) {
      base = normalizeBaseKey(base);
      const mounts = getMounts(base, true);
      let maskedMounts = [];
      const allKeys = [];
      let allMountsSupportMaxDepth = true;
      for (const mount of mounts) {
        if (!mount.driver.flags?.maxDepth) {
          allMountsSupportMaxDepth = false;
        }
        const rawKeys = await asyncCall(
          mount.driver.getKeys,
          mount.relativeBase,
          opts
        );
        for (const key of rawKeys) {
          const fullKey = mount.mountpoint + normalizeKey(key);
          if (!maskedMounts.some((p) => fullKey.startsWith(p))) {
            allKeys.push(fullKey);
          }
        }
        maskedMounts = [
          mount.mountpoint,
          ...maskedMounts.filter((p) => !p.startsWith(mount.mountpoint))
        ];
      }
      const shouldFilterByDepth = opts.maxDepth !== void 0 && !allMountsSupportMaxDepth;
      return allKeys.filter(
        (key) => (!shouldFilterByDepth || filterKeyByDepth(key, opts.maxDepth)) && filterKeyByBase(key, base)
      );
    },
    // Utils
    async clear(base, opts = {}) {
      base = normalizeBaseKey(base);
      await Promise.all(
        getMounts(base, false).map(async (m) => {
          if (m.driver.clear) {
            return asyncCall(m.driver.clear, m.relativeBase, opts);
          }
          if (m.driver.removeItem) {
            const keys = await m.driver.getKeys(m.relativeBase || "", opts);
            return Promise.all(
              keys.map((key) => m.driver.removeItem(key, opts))
            );
          }
        })
      );
    },
    async dispose() {
      await Promise.all(
        Object.values(context.mounts).map((driver) => dispose(driver))
      );
    },
    async watch(callback) {
      await startWatch();
      context.watchListeners.push(callback);
      return async () => {
        context.watchListeners = context.watchListeners.filter(
          (listener) => listener !== callback
        );
        if (context.watchListeners.length === 0) {
          await stopWatch();
        }
      };
    },
    async unwatch() {
      context.watchListeners = [];
      await stopWatch();
    },
    // Mount
    mount(base, driver) {
      base = normalizeBaseKey(base);
      if (base && context.mounts[base]) {
        throw new Error(`already mounted at ${base}`);
      }
      if (base) {
        context.mountpoints.push(base);
        context.mountpoints.sort((a, b) => b.length - a.length);
      }
      context.mounts[base] = driver;
      if (context.watching) {
        Promise.resolve(watch$1(driver, onChange, base)).then((unwatcher) => {
          context.unwatch[base] = unwatcher;
        }).catch(console.error);
      }
      return storage;
    },
    async unmount(base, _dispose = true) {
      base = normalizeBaseKey(base);
      if (!base || !context.mounts[base]) {
        return;
      }
      if (context.watching && base in context.unwatch) {
        context.unwatch[base]?.();
        delete context.unwatch[base];
      }
      if (_dispose) {
        await dispose(context.mounts[base]);
      }
      context.mountpoints = context.mountpoints.filter((key) => key !== base);
      delete context.mounts[base];
    },
    getMount(key = "") {
      key = normalizeKey(key) + ":";
      const m = getMount(key);
      return {
        driver: m.driver,
        base: m.base
      };
    },
    getMounts(base = "", opts = {}) {
      base = normalizeKey(base);
      const mounts = getMounts(base, opts.parents);
      return mounts.map((m) => ({
        driver: m.driver,
        base: m.mountpoint
      }));
    },
    // Aliases
    keys: (base, opts = {}) => storage.getKeys(base, opts),
    get: (key, opts = {}) => storage.getItem(key, opts),
    set: (key, value, opts = {}) => storage.setItem(key, value, opts),
    has: (key, opts = {}) => storage.hasItem(key, opts),
    del: (key, opts = {}) => storage.removeItem(key, opts),
    remove: (key, opts = {}) => storage.removeItem(key, opts)
  };
  return storage;
}
function watch$1(driver, onChange, base) {
  return driver.watch ? driver.watch((event, key) => onChange(event, base + key)) : () => {
  };
}
async function dispose(driver) {
  if (typeof driver.dispose === "function") {
    await asyncCall(driver.dispose);
  }
}

const EntryTypes = {
    FILE_TYPE: 'files',
    DIR_TYPE: 'directories',
    FILE_DIR_TYPE: 'files_directories',
    EVERYTHING_TYPE: 'all',
};
const defaultOptions = {
    root: '.',
    fileFilter: (_entryInfo) => true,
    directoryFilter: (_entryInfo) => true,
    type: EntryTypes.FILE_TYPE,
    lstat: false,
    depth: 2147483648,
    alwaysStat: false,
    highWaterMark: 4096,
};
Object.freeze(defaultOptions);
const RECURSIVE_ERROR_CODE = 'READDIRP_RECURSIVE_ERROR';
const NORMAL_FLOW_ERRORS = new Set(['ENOENT', 'EPERM', 'EACCES', 'ELOOP', RECURSIVE_ERROR_CODE]);
const ALL_TYPES = [
    EntryTypes.DIR_TYPE,
    EntryTypes.EVERYTHING_TYPE,
    EntryTypes.FILE_DIR_TYPE,
    EntryTypes.FILE_TYPE,
];
const DIR_TYPES = new Set([
    EntryTypes.DIR_TYPE,
    EntryTypes.EVERYTHING_TYPE,
    EntryTypes.FILE_DIR_TYPE,
]);
const FILE_TYPES$1 = new Set([
    EntryTypes.EVERYTHING_TYPE,
    EntryTypes.FILE_DIR_TYPE,
    EntryTypes.FILE_TYPE,
]);
const isNormalFlowError = (error) => NORMAL_FLOW_ERRORS.has(error.code);
const wantBigintFsStats = process.platform === 'win32';
const emptyFn = (_entryInfo) => true;
const normalizeFilter = (filter) => {
    if (filter === undefined)
        return emptyFn;
    if (typeof filter === 'function')
        return filter;
    if (typeof filter === 'string') {
        const fl = filter.trim();
        return (entry) => entry.basename === fl;
    }
    if (Array.isArray(filter)) {
        const trItems = filter.map((item) => item.trim());
        return (entry) => trItems.some((f) => entry.basename === f);
    }
    return emptyFn;
};
/** Readable readdir stream, emitting new files as they're being listed. */
class ReaddirpStream extends Readable {
    constructor(options = {}) {
        super({
            objectMode: true,
            autoDestroy: true,
            highWaterMark: options.highWaterMark,
        });
        const opts = { ...defaultOptions, ...options };
        const { root, type } = opts;
        this._fileFilter = normalizeFilter(opts.fileFilter);
        this._directoryFilter = normalizeFilter(opts.directoryFilter);
        const statMethod = opts.lstat ? lstat : stat;
        // Use bigint stats if it's windows and stat() supports options (node 10+).
        if (wantBigintFsStats) {
            this._stat = (path) => statMethod(path, { bigint: true });
        }
        else {
            this._stat = statMethod;
        }
        this._maxDepth = opts.depth ?? defaultOptions.depth;
        this._wantsDir = type ? DIR_TYPES.has(type) : false;
        this._wantsFile = type ? FILE_TYPES$1.has(type) : false;
        this._wantsEverything = type === EntryTypes.EVERYTHING_TYPE;
        this._root = resolve(root);
        this._isDirent = !opts.alwaysStat;
        this._statsProp = this._isDirent ? 'dirent' : 'stats';
        this._rdOptions = { encoding: 'utf8', withFileTypes: this._isDirent };
        // Launch stream with one parent, the root dir.
        this.parents = [this._exploreDir(root, 1)];
        this.reading = false;
        this.parent = undefined;
    }
    async _read(batch) {
        if (this.reading)
            return;
        this.reading = true;
        try {
            while (!this.destroyed && batch > 0) {
                const par = this.parent;
                const fil = par && par.files;
                if (fil && fil.length > 0) {
                    const { path, depth } = par;
                    const slice = fil.splice(0, batch).map((dirent) => this._formatEntry(dirent, path));
                    const awaited = await Promise.all(slice);
                    for (const entry of awaited) {
                        if (!entry)
                            continue;
                        if (this.destroyed)
                            return;
                        const entryType = await this._getEntryType(entry);
                        if (entryType === 'directory' && this._directoryFilter(entry)) {
                            if (depth <= this._maxDepth) {
                                this.parents.push(this._exploreDir(entry.fullPath, depth + 1));
                            }
                            if (this._wantsDir) {
                                this.push(entry);
                                batch--;
                            }
                        }
                        else if ((entryType === 'file' || this._includeAsFile(entry)) &&
                            this._fileFilter(entry)) {
                            if (this._wantsFile) {
                                this.push(entry);
                                batch--;
                            }
                        }
                    }
                }
                else {
                    const parent = this.parents.pop();
                    if (!parent) {
                        this.push(null);
                        break;
                    }
                    this.parent = await parent;
                    if (this.destroyed)
                        return;
                }
            }
        }
        catch (error) {
            this.destroy(error);
        }
        finally {
            this.reading = false;
        }
    }
    async _exploreDir(path, depth) {
        let files;
        try {
            files = await readdir$1(path, this._rdOptions);
        }
        catch (error) {
            this._onError(error);
        }
        return { files, depth, path };
    }
    async _formatEntry(dirent, path) {
        let entry;
        const basename = this._isDirent ? dirent.name : dirent;
        try {
            const fullPath = resolve(join(path, basename));
            entry = { path: relative(this._root, fullPath), fullPath, basename };
            entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);
        }
        catch (err) {
            this._onError(err);
            return;
        }
        return entry;
    }
    _onError(err) {
        if (isNormalFlowError(err) && !this.destroyed) {
            this.emit('warn', err);
        }
        else {
            this.destroy(err);
        }
    }
    async _getEntryType(entry) {
        // entry may be undefined, because a warning or an error were emitted
        // and the statsProp is undefined
        if (!entry && this._statsProp in entry) {
            return '';
        }
        const stats = entry[this._statsProp];
        if (stats.isFile())
            return 'file';
        if (stats.isDirectory())
            return 'directory';
        if (stats && stats.isSymbolicLink()) {
            const full = entry.fullPath;
            try {
                const entryRealPath = await realpath(full);
                const entryRealPathStats = await lstat(entryRealPath);
                if (entryRealPathStats.isFile()) {
                    return 'file';
                }
                if (entryRealPathStats.isDirectory()) {
                    const len = entryRealPath.length;
                    if (full.startsWith(entryRealPath) && full.substr(len, 1) === sep) {
                        const recursiveError = new Error(`Circular symlink detected: "${full}" points to "${entryRealPath}"`);
                        // @ts-ignore
                        recursiveError.code = RECURSIVE_ERROR_CODE;
                        return this._onError(recursiveError);
                    }
                    return 'directory';
                }
            }
            catch (error) {
                this._onError(error);
                return '';
            }
        }
    }
    _includeAsFile(entry) {
        const stats = entry && entry[this._statsProp];
        return stats && this._wantsEverything && !stats.isDirectory();
    }
}
/**
 * Streaming version: Reads all files and directories in given root recursively.
 * Consumes ~constant small amount of RAM.
 * @param root Root directory
 * @param options Options to specify root (start directory), filters and recursion depth
 */
function readdirp(root, options = {}) {
    // @ts-ignore
    let type = options.entryType || options.type;
    if (type === 'both')
        type = EntryTypes.FILE_DIR_TYPE; // backwards-compatibility
    if (type)
        options.type = type;
    if (!root) {
        throw new Error('readdirp: root argument is required. Usage: readdirp(root, options)');
    }
    else if (typeof root !== 'string') {
        throw new TypeError('readdirp: root argument must be a string. Usage: readdirp(root, options)');
    }
    else if (type && !ALL_TYPES.includes(type)) {
        throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(', ')}`);
    }
    options.root = root;
    return new ReaddirpStream(options);
}

const STR_DATA = 'data';
const STR_END = 'end';
const STR_CLOSE = 'close';
const EMPTY_FN = () => { };
const pl = process.platform;
const isWindows$1 = pl === 'win32';
const isMacos = pl === 'darwin';
const isLinux = pl === 'linux';
const isFreeBSD = pl === 'freebsd';
const isIBMi = type() === 'OS400';
const EVENTS = {
    ALL: 'all',
    READY: 'ready',
    ADD: 'add',
    CHANGE: 'change',
    ADD_DIR: 'addDir',
    UNLINK: 'unlink',
    UNLINK_DIR: 'unlinkDir',
    RAW: 'raw',
    ERROR: 'error',
};
const EV = EVENTS;
const THROTTLE_MODE_WATCH = 'watch';
const statMethods = { lstat: lstat$1, stat: stat$1 };
const KEY_LISTENERS = 'listeners';
const KEY_ERR = 'errHandlers';
const KEY_RAW = 'rawEmitters';
const HANDLER_KEYS = [KEY_LISTENERS, KEY_ERR, KEY_RAW];
// prettier-ignore
const binaryExtensions = new Set([
    '3dm', '3ds', '3g2', '3gp', '7z', 'a', 'aac', 'adp', 'afdesign', 'afphoto', 'afpub', 'ai',
    'aif', 'aiff', 'alz', 'ape', 'apk', 'appimage', 'ar', 'arj', 'asf', 'au', 'avi',
    'bak', 'baml', 'bh', 'bin', 'bk', 'bmp', 'btif', 'bz2', 'bzip2',
    'cab', 'caf', 'cgm', 'class', 'cmx', 'cpio', 'cr2', 'cur', 'dat', 'dcm', 'deb', 'dex', 'djvu',
    'dll', 'dmg', 'dng', 'doc', 'docm', 'docx', 'dot', 'dotm', 'dra', 'DS_Store', 'dsk', 'dts',
    'dtshd', 'dvb', 'dwg', 'dxf',
    'ecelp4800', 'ecelp7470', 'ecelp9600', 'egg', 'eol', 'eot', 'epub', 'exe',
    'f4v', 'fbs', 'fh', 'fla', 'flac', 'flatpak', 'fli', 'flv', 'fpx', 'fst', 'fvt',
    'g3', 'gh', 'gif', 'graffle', 'gz', 'gzip',
    'h261', 'h263', 'h264', 'icns', 'ico', 'ief', 'img', 'ipa', 'iso',
    'jar', 'jpeg', 'jpg', 'jpgv', 'jpm', 'jxr', 'key', 'ktx',
    'lha', 'lib', 'lvp', 'lz', 'lzh', 'lzma', 'lzo',
    'm3u', 'm4a', 'm4v', 'mar', 'mdi', 'mht', 'mid', 'midi', 'mj2', 'mka', 'mkv', 'mmr', 'mng',
    'mobi', 'mov', 'movie', 'mp3',
    'mp4', 'mp4a', 'mpeg', 'mpg', 'mpga', 'mxu',
    'nef', 'npx', 'numbers', 'nupkg',
    'o', 'odp', 'ods', 'odt', 'oga', 'ogg', 'ogv', 'otf', 'ott',
    'pages', 'pbm', 'pcx', 'pdb', 'pdf', 'pea', 'pgm', 'pic', 'png', 'pnm', 'pot', 'potm',
    'potx', 'ppa', 'ppam',
    'ppm', 'pps', 'ppsm', 'ppsx', 'ppt', 'pptm', 'pptx', 'psd', 'pya', 'pyc', 'pyo', 'pyv',
    'qt',
    'rar', 'ras', 'raw', 'resources', 'rgb', 'rip', 'rlc', 'rmf', 'rmvb', 'rpm', 'rtf', 'rz',
    's3m', 's7z', 'scpt', 'sgi', 'shar', 'snap', 'sil', 'sketch', 'slk', 'smv', 'snk', 'so',
    'stl', 'suo', 'sub', 'swf',
    'tar', 'tbz', 'tbz2', 'tga', 'tgz', 'thmx', 'tif', 'tiff', 'tlz', 'ttc', 'ttf', 'txz',
    'udf', 'uvh', 'uvi', 'uvm', 'uvp', 'uvs', 'uvu',
    'viv', 'vob',
    'war', 'wav', 'wax', 'wbmp', 'wdp', 'weba', 'webm', 'webp', 'whl', 'wim', 'wm', 'wma',
    'wmv', 'wmx', 'woff', 'woff2', 'wrm', 'wvx',
    'xbm', 'xif', 'xla', 'xlam', 'xls', 'xlsb', 'xlsm', 'xlsx', 'xlt', 'xltm', 'xltx', 'xm',
    'xmind', 'xpi', 'xpm', 'xwd', 'xz',
    'z', 'zip', 'zipx',
]);
const isBinaryPath = (filePath) => binaryExtensions.has(sysPath.extname(filePath).slice(1).toLowerCase());
// TODO: emit errors properly. Example: EMFILE on Macos.
const foreach = (val, fn) => {
    if (val instanceof Set) {
        val.forEach(fn);
    }
    else {
        fn(val);
    }
};
const addAndConvert = (main, prop, item) => {
    let container = main[prop];
    if (!(container instanceof Set)) {
        main[prop] = container = new Set([container]);
    }
    container.add(item);
};
const clearItem = (cont) => (key) => {
    const set = cont[key];
    if (set instanceof Set) {
        set.clear();
    }
    else {
        delete cont[key];
    }
};
const delFromSet = (main, prop, item) => {
    const container = main[prop];
    if (container instanceof Set) {
        container.delete(item);
    }
    else if (container === item) {
        delete main[prop];
    }
};
const isEmptySet = (val) => (val instanceof Set ? val.size === 0 : !val);
const FsWatchInstances = new Map();
/**
 * Instantiates the fs_watch interface
 * @param path to be watched
 * @param options to be passed to fs_watch
 * @param listener main event handler
 * @param errHandler emits info about errors
 * @param emitRaw emits raw event data
 * @returns {NativeFsWatcher}
 */
function createFsWatchInstance(path, options, listener, errHandler, emitRaw) {
    const handleEvent = (rawEvent, evPath) => {
        listener(path);
        emitRaw(rawEvent, evPath, { watchedPath: path });
        // emit based on events occurring for files from a directory's watcher in
        // case the file's watcher misses it (and rely on throttling to de-dupe)
        if (evPath && path !== evPath) {
            fsWatchBroadcast(sysPath.resolve(path, evPath), KEY_LISTENERS, sysPath.join(path, evPath));
        }
    };
    try {
        return watch$2(path, {
            persistent: options.persistent,
        }, handleEvent);
    }
    catch (error) {
        errHandler(error);
        return undefined;
    }
}
/**
 * Helper for passing fs_watch event data to a collection of listeners
 * @param fullPath absolute path bound to fs_watch instance
 */
const fsWatchBroadcast = (fullPath, listenerType, val1, val2, val3) => {
    const cont = FsWatchInstances.get(fullPath);
    if (!cont)
        return;
    foreach(cont[listenerType], (listener) => {
        listener(val1, val2, val3);
    });
};
/**
 * Instantiates the fs_watch interface or binds listeners
 * to an existing one covering the same file system entry
 * @param path
 * @param fullPath absolute path
 * @param options to be passed to fs_watch
 * @param handlers container for event listener functions
 */
const setFsWatchListener = (path, fullPath, options, handlers) => {
    const { listener, errHandler, rawEmitter } = handlers;
    let cont = FsWatchInstances.get(fullPath);
    let watcher;
    if (!options.persistent) {
        watcher = createFsWatchInstance(path, options, listener, errHandler, rawEmitter);
        if (!watcher)
            return;
        return watcher.close.bind(watcher);
    }
    if (cont) {
        addAndConvert(cont, KEY_LISTENERS, listener);
        addAndConvert(cont, KEY_ERR, errHandler);
        addAndConvert(cont, KEY_RAW, rawEmitter);
    }
    else {
        watcher = createFsWatchInstance(path, options, fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS), errHandler, // no need to use broadcast here
        fsWatchBroadcast.bind(null, fullPath, KEY_RAW));
        if (!watcher)
            return;
        watcher.on(EV.ERROR, async (error) => {
            const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);
            if (cont)
                cont.watcherUnusable = true; // documented since Node 10.4.1
            // Workaround for https://github.com/joyent/node/issues/4337
            if (isWindows$1 && error.code === 'EPERM') {
                try {
                    const fd = await open(path, 'r');
                    await fd.close();
                    broadcastErr(error);
                }
                catch (err) {
                    // do nothing
                }
            }
            else {
                broadcastErr(error);
            }
        });
        cont = {
            listeners: listener,
            errHandlers: errHandler,
            rawEmitters: rawEmitter,
            watcher,
        };
        FsWatchInstances.set(fullPath, cont);
    }
    // const index = cont.listeners.indexOf(listener);
    // removes this instance's listeners and closes the underlying fs_watch
    // instance if there are no more listeners left
    return () => {
        delFromSet(cont, KEY_LISTENERS, listener);
        delFromSet(cont, KEY_ERR, errHandler);
        delFromSet(cont, KEY_RAW, rawEmitter);
        if (isEmptySet(cont.listeners)) {
            // Check to protect against issue gh-730.
            // if (cont.watcherUnusable) {
            cont.watcher.close();
            // }
            FsWatchInstances.delete(fullPath);
            HANDLER_KEYS.forEach(clearItem(cont));
            // @ts-ignore
            cont.watcher = undefined;
            Object.freeze(cont);
        }
    };
};
// fs_watchFile helpers
// object to hold per-process fs_watchFile instances
// (may be shared across chokidar FSWatcher instances)
const FsWatchFileInstances = new Map();
/**
 * Instantiates the fs_watchFile interface or binds listeners
 * to an existing one covering the same file system entry
 * @param path to be watched
 * @param fullPath absolute path
 * @param options options to be passed to fs_watchFile
 * @param handlers container for event listener functions
 * @returns closer
 */
const setFsWatchFileListener = (path, fullPath, options, handlers) => {
    const { listener, rawEmitter } = handlers;
    let cont = FsWatchFileInstances.get(fullPath);
    // let listeners = new Set();
    // let rawEmitters = new Set();
    const copts = cont && cont.options;
    if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {
        // "Upgrade" the watcher to persistence or a quicker interval.
        // This creates some unlikely edge case issues if the user mixes
        // settings in a very weird way, but solving for those cases
        // doesn't seem worthwhile for the added complexity.
        // listeners = cont.listeners;
        // rawEmitters = cont.rawEmitters;
        unwatchFile(fullPath);
        cont = undefined;
    }
    if (cont) {
        addAndConvert(cont, KEY_LISTENERS, listener);
        addAndConvert(cont, KEY_RAW, rawEmitter);
    }
    else {
        // TODO
        // listeners.add(listener);
        // rawEmitters.add(rawEmitter);
        cont = {
            listeners: listener,
            rawEmitters: rawEmitter,
            options,
            watcher: watchFile(fullPath, options, (curr, prev) => {
                foreach(cont.rawEmitters, (rawEmitter) => {
                    rawEmitter(EV.CHANGE, fullPath, { curr, prev });
                });
                const currmtime = curr.mtimeMs;
                if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {
                    foreach(cont.listeners, (listener) => listener(path, curr));
                }
            }),
        };
        FsWatchFileInstances.set(fullPath, cont);
    }
    // const index = cont.listeners.indexOf(listener);
    // Removes this instance's listeners and closes the underlying fs_watchFile
    // instance if there are no more listeners left.
    return () => {
        delFromSet(cont, KEY_LISTENERS, listener);
        delFromSet(cont, KEY_RAW, rawEmitter);
        if (isEmptySet(cont.listeners)) {
            FsWatchFileInstances.delete(fullPath);
            unwatchFile(fullPath);
            cont.options = cont.watcher = undefined;
            Object.freeze(cont);
        }
    };
};
/**
 * @mixin
 */
class NodeFsHandler {
    constructor(fsW) {
        this.fsw = fsW;
        this._boundHandleError = (error) => fsW._handleError(error);
    }
    /**
     * Watch file for changes with fs_watchFile or fs_watch.
     * @param path to file or dir
     * @param listener on fs change
     * @returns closer for the watcher instance
     */
    _watchWithNodeFs(path, listener) {
        const opts = this.fsw.options;
        const directory = sysPath.dirname(path);
        const basename = sysPath.basename(path);
        const parent = this.fsw._getWatchedDir(directory);
        parent.add(basename);
        const absolutePath = sysPath.resolve(path);
        const options = {
            persistent: opts.persistent,
        };
        if (!listener)
            listener = EMPTY_FN;
        let closer;
        if (opts.usePolling) {
            const enableBin = opts.interval !== opts.binaryInterval;
            options.interval = enableBin && isBinaryPath(basename) ? opts.binaryInterval : opts.interval;
            closer = setFsWatchFileListener(path, absolutePath, options, {
                listener,
                rawEmitter: this.fsw._emitRaw,
            });
        }
        else {
            closer = setFsWatchListener(path, absolutePath, options, {
                listener,
                errHandler: this._boundHandleError,
                rawEmitter: this.fsw._emitRaw,
            });
        }
        return closer;
    }
    /**
     * Watch a file and emit add event if warranted.
     * @returns closer for the watcher instance
     */
    _handleFile(file, stats, initialAdd) {
        if (this.fsw.closed) {
            return;
        }
        const dirname = sysPath.dirname(file);
        const basename = sysPath.basename(file);
        const parent = this.fsw._getWatchedDir(dirname);
        // stats is always present
        let prevStats = stats;
        // if the file is already being watched, do nothing
        if (parent.has(basename))
            return;
        const listener = async (path, newStats) => {
            if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5))
                return;
            if (!newStats || newStats.mtimeMs === 0) {
                try {
                    const newStats = await stat$1(file);
                    if (this.fsw.closed)
                        return;
                    // Check that change event was not fired because of changed only accessTime.
                    const at = newStats.atimeMs;
                    const mt = newStats.mtimeMs;
                    if (!at || at <= mt || mt !== prevStats.mtimeMs) {
                        this.fsw._emit(EV.CHANGE, file, newStats);
                    }
                    if ((isMacos || isLinux || isFreeBSD) && prevStats.ino !== newStats.ino) {
                        this.fsw._closeFile(path);
                        prevStats = newStats;
                        const closer = this._watchWithNodeFs(file, listener);
                        if (closer)
                            this.fsw._addPathCloser(path, closer);
                    }
                    else {
                        prevStats = newStats;
                    }
                }
                catch (error) {
                    // Fix issues where mtime is null but file is still present
                    this.fsw._remove(dirname, basename);
                }
                // add is about to be emitted if file not already tracked in parent
            }
            else if (parent.has(basename)) {
                // Check that change event was not fired because of changed only accessTime.
                const at = newStats.atimeMs;
                const mt = newStats.mtimeMs;
                if (!at || at <= mt || mt !== prevStats.mtimeMs) {
                    this.fsw._emit(EV.CHANGE, file, newStats);
                }
                prevStats = newStats;
            }
        };
        // kick off the watcher
        const closer = this._watchWithNodeFs(file, listener);
        // emit an add event if we're supposed to
        if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {
            if (!this.fsw._throttle(EV.ADD, file, 0))
                return;
            this.fsw._emit(EV.ADD, file, stats);
        }
        return closer;
    }
    /**
     * Handle symlinks encountered while reading a dir.
     * @param entry returned by readdirp
     * @param directory path of dir being read
     * @param path of this item
     * @param item basename of this item
     * @returns true if no more processing is needed for this entry.
     */
    async _handleSymlink(entry, directory, path, item) {
        if (this.fsw.closed) {
            return;
        }
        const full = entry.fullPath;
        const dir = this.fsw._getWatchedDir(directory);
        if (!this.fsw.options.followSymlinks) {
            // watch symlink directly (don't follow) and detect changes
            this.fsw._incrReadyCount();
            let linkPath;
            try {
                linkPath = await realpath$1(path);
            }
            catch (e) {
                this.fsw._emitReady();
                return true;
            }
            if (this.fsw.closed)
                return;
            if (dir.has(item)) {
                if (this.fsw._symlinkPaths.get(full) !== linkPath) {
                    this.fsw._symlinkPaths.set(full, linkPath);
                    this.fsw._emit(EV.CHANGE, path, entry.stats);
                }
            }
            else {
                dir.add(item);
                this.fsw._symlinkPaths.set(full, linkPath);
                this.fsw._emit(EV.ADD, path, entry.stats);
            }
            this.fsw._emitReady();
            return true;
        }
        // don't follow the same symlink more than once
        if (this.fsw._symlinkPaths.has(full)) {
            return true;
        }
        this.fsw._symlinkPaths.set(full, true);
    }
    _handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {
        // Normalize the directory name on Windows
        directory = sysPath.join(directory, '');
        throttler = this.fsw._throttle('readdir', directory, 1000);
        if (!throttler)
            return;
        const previous = this.fsw._getWatchedDir(wh.path);
        const current = new Set();
        let stream = this.fsw._readdirp(directory, {
            fileFilter: (entry) => wh.filterPath(entry),
            directoryFilter: (entry) => wh.filterDir(entry),
        });
        if (!stream)
            return;
        stream
            .on(STR_DATA, async (entry) => {
            if (this.fsw.closed) {
                stream = undefined;
                return;
            }
            const item = entry.path;
            let path = sysPath.join(directory, item);
            current.add(item);
            if (entry.stats.isSymbolicLink() &&
                (await this._handleSymlink(entry, directory, path, item))) {
                return;
            }
            if (this.fsw.closed) {
                stream = undefined;
                return;
            }
            // Files that present in current directory snapshot
            // but absent in previous are added to watch list and
            // emit `add` event.
            if (item === target || (!target && !previous.has(item))) {
                this.fsw._incrReadyCount();
                // ensure relativeness of path is preserved in case of watcher reuse
                path = sysPath.join(dir, sysPath.relative(dir, path));
                this._addToNodeFs(path, initialAdd, wh, depth + 1);
            }
        })
            .on(EV.ERROR, this._boundHandleError);
        return new Promise((resolve, reject) => {
            if (!stream)
                return reject();
            stream.once(STR_END, () => {
                if (this.fsw.closed) {
                    stream = undefined;
                    return;
                }
                const wasThrottled = throttler ? throttler.clear() : false;
                resolve(undefined);
                // Files that absent in current directory snapshot
                // but present in previous emit `remove` event
                // and are removed from @watched[directory].
                previous
                    .getChildren()
                    .filter((item) => {
                    return item !== directory && !current.has(item);
                })
                    .forEach((item) => {
                    this.fsw._remove(directory, item);
                });
                stream = undefined;
                // one more time for any missed in case changes came in extremely quickly
                if (wasThrottled)
                    this._handleRead(directory, false, wh, target, dir, depth, throttler);
            });
        });
    }
    /**
     * Read directory to add / remove files from `@watched` list and re-read it on change.
     * @param dir fs path
     * @param stats
     * @param initialAdd
     * @param depth relative to user-supplied path
     * @param target child path targeted for watch
     * @param wh Common watch helpers for this path
     * @param realpath
     * @returns closer for the watcher instance.
     */
    async _handleDir(dir, stats, initialAdd, depth, target, wh, realpath) {
        const parentDir = this.fsw._getWatchedDir(sysPath.dirname(dir));
        const tracked = parentDir.has(sysPath.basename(dir));
        if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {
            this.fsw._emit(EV.ADD_DIR, dir, stats);
        }
        // ensure dir is tracked (harmless if redundant)
        parentDir.add(sysPath.basename(dir));
        this.fsw._getWatchedDir(dir);
        let throttler;
        let closer;
        const oDepth = this.fsw.options.depth;
        if ((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath)) {
            if (!target) {
                await this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);
                if (this.fsw.closed)
                    return;
            }
            closer = this._watchWithNodeFs(dir, (dirPath, stats) => {
                // if current directory is removed, do nothing
                if (stats && stats.mtimeMs === 0)
                    return;
                this._handleRead(dirPath, false, wh, target, dir, depth, throttler);
            });
        }
        return closer;
    }
    /**
     * Handle added file, directory, or glob pattern.
     * Delegates call to _handleFile / _handleDir after checks.
     * @param path to file or ir
     * @param initialAdd was the file added at watch instantiation?
     * @param priorWh depth relative to user-supplied path
     * @param depth Child path actually targeted for watch
     * @param target Child path actually targeted for watch
     */
    async _addToNodeFs(path, initialAdd, priorWh, depth, target) {
        const ready = this.fsw._emitReady;
        if (this.fsw._isIgnored(path) || this.fsw.closed) {
            ready();
            return false;
        }
        const wh = this.fsw._getWatchHelpers(path);
        if (priorWh) {
            wh.filterPath = (entry) => priorWh.filterPath(entry);
            wh.filterDir = (entry) => priorWh.filterDir(entry);
        }
        // evaluate what is at the path we're being asked to watch
        try {
            const stats = await statMethods[wh.statMethod](wh.watchPath);
            if (this.fsw.closed)
                return;
            if (this.fsw._isIgnored(wh.watchPath, stats)) {
                ready();
                return false;
            }
            const follow = this.fsw.options.followSymlinks;
            let closer;
            if (stats.isDirectory()) {
                const absPath = sysPath.resolve(path);
                const targetPath = follow ? await realpath$1(path) : path;
                if (this.fsw.closed)
                    return;
                closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);
                if (this.fsw.closed)
                    return;
                // preserve this symlink's target path
                if (absPath !== targetPath && targetPath !== undefined) {
                    this.fsw._symlinkPaths.set(absPath, targetPath);
                }
            }
            else if (stats.isSymbolicLink()) {
                const targetPath = follow ? await realpath$1(path) : path;
                if (this.fsw.closed)
                    return;
                const parent = sysPath.dirname(wh.watchPath);
                this.fsw._getWatchedDir(parent).add(wh.watchPath);
                this.fsw._emit(EV.ADD, wh.watchPath, stats);
                closer = await this._handleDir(parent, stats, initialAdd, depth, path, wh, targetPath);
                if (this.fsw.closed)
                    return;
                // preserve this symlink's target path
                if (targetPath !== undefined) {
                    this.fsw._symlinkPaths.set(sysPath.resolve(path), targetPath);
                }
            }
            else {
                closer = this._handleFile(wh.watchPath, stats, initialAdd);
            }
            ready();
            if (closer)
                this.fsw._addPathCloser(path, closer);
            return false;
        }
        catch (error) {
            if (this.fsw._handleError(error)) {
                ready();
                return path;
            }
        }
    }
}

/*! chokidar - MIT License (c) 2012 Paul Miller (paulmillr.com) */
const SLASH = '/';
const SLASH_SLASH = '//';
const ONE_DOT = '.';
const TWO_DOTS = '..';
const STRING_TYPE = 'string';
const BACK_SLASH_RE = /\\/g;
const DOUBLE_SLASH_RE = /\/\//;
const DOT_RE = /\..*\.(sw[px])$|~$|\.subl.*\.tmp/;
const REPLACER_RE = /^\.[/\\]/;
function arrify(item) {
    return Array.isArray(item) ? item : [item];
}
const isMatcherObject = (matcher) => typeof matcher === 'object' && matcher !== null && !(matcher instanceof RegExp);
function createPattern(matcher) {
    if (typeof matcher === 'function')
        return matcher;
    if (typeof matcher === 'string')
        return (string) => matcher === string;
    if (matcher instanceof RegExp)
        return (string) => matcher.test(string);
    if (typeof matcher === 'object' && matcher !== null) {
        return (string) => {
            if (matcher.path === string)
                return true;
            if (matcher.recursive) {
                const relative = sysPath.relative(matcher.path, string);
                if (!relative) {
                    return false;
                }
                return !relative.startsWith('..') && !sysPath.isAbsolute(relative);
            }
            return false;
        };
    }
    return () => false;
}
function normalizePath$1(path) {
    if (typeof path !== 'string')
        throw new Error('string expected');
    path = sysPath.normalize(path);
    path = path.replace(/\\/g, '/');
    let prepend = false;
    if (path.startsWith('//'))
        prepend = true;
    const DOUBLE_SLASH_RE = /\/\//;
    while (path.match(DOUBLE_SLASH_RE))
        path = path.replace(DOUBLE_SLASH_RE, '/');
    if (prepend)
        path = '/' + path;
    return path;
}
function matchPatterns(patterns, testString, stats) {
    const path = normalizePath$1(testString);
    for (let index = 0; index < patterns.length; index++) {
        const pattern = patterns[index];
        if (pattern(path, stats)) {
            return true;
        }
    }
    return false;
}
function anymatch$2(matchers, testString) {
    if (matchers == null) {
        throw new TypeError('anymatch: specify first argument');
    }
    // Early cache for matchers.
    const matchersArray = arrify(matchers);
    const patterns = matchersArray.map((matcher) => createPattern(matcher));
    {
        return (testString, stats) => {
            return matchPatterns(patterns, testString, stats);
        };
    }
}
const unifyPaths = (paths_) => {
    const paths = arrify(paths_).flat();
    if (!paths.every((p) => typeof p === STRING_TYPE)) {
        throw new TypeError(`Non-string provided as watch path: ${paths}`);
    }
    return paths.map(normalizePathToUnix);
};
// If SLASH_SLASH occurs at the beginning of path, it is not replaced
//     because "//StoragePC/DrivePool/Movies" is a valid network path
const toUnix = (string) => {
    let str = string.replace(BACK_SLASH_RE, SLASH);
    let prepend = false;
    if (str.startsWith(SLASH_SLASH)) {
        prepend = true;
    }
    while (str.match(DOUBLE_SLASH_RE)) {
        str = str.replace(DOUBLE_SLASH_RE, SLASH);
    }
    if (prepend) {
        str = SLASH + str;
    }
    return str;
};
// Our version of upath.normalize
// TODO: this is not equal to path-normalize module - investigate why
const normalizePathToUnix = (path) => toUnix(sysPath.normalize(toUnix(path)));
// TODO: refactor
const normalizeIgnored = (cwd = '') => (path) => {
    if (typeof path === 'string') {
        return normalizePathToUnix(sysPath.isAbsolute(path) ? path : sysPath.join(cwd, path));
    }
    else {
        return path;
    }
};
const getAbsolutePath = (path, cwd) => {
    if (sysPath.isAbsolute(path)) {
        return path;
    }
    return sysPath.join(cwd, path);
};
const EMPTY_SET = Object.freeze(new Set());
/**
 * Directory entry.
 */
class DirEntry {
    constructor(dir, removeWatcher) {
        this.path = dir;
        this._removeWatcher = removeWatcher;
        this.items = new Set();
    }
    add(item) {
        const { items } = this;
        if (!items)
            return;
        if (item !== ONE_DOT && item !== TWO_DOTS)
            items.add(item);
    }
    async remove(item) {
        const { items } = this;
        if (!items)
            return;
        items.delete(item);
        if (items.size > 0)
            return;
        const dir = this.path;
        try {
            await readdir$2(dir);
        }
        catch (err) {
            if (this._removeWatcher) {
                this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));
            }
        }
    }
    has(item) {
        const { items } = this;
        if (!items)
            return;
        return items.has(item);
    }
    getChildren() {
        const { items } = this;
        if (!items)
            return [];
        return [...items.values()];
    }
    dispose() {
        this.items.clear();
        this.path = '';
        this._removeWatcher = EMPTY_FN;
        this.items = EMPTY_SET;
        Object.freeze(this);
    }
}
const STAT_METHOD_F = 'stat';
const STAT_METHOD_L = 'lstat';
class WatchHelper {
    constructor(path, follow, fsw) {
        this.fsw = fsw;
        const watchPath = path;
        this.path = path = path.replace(REPLACER_RE, '');
        this.watchPath = watchPath;
        this.fullWatchPath = sysPath.resolve(watchPath);
        this.dirParts = [];
        this.dirParts.forEach((parts) => {
            if (parts.length > 1)
                parts.pop();
        });
        this.followSymlinks = follow;
        this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;
    }
    entryPath(entry) {
        return sysPath.join(this.watchPath, sysPath.relative(this.watchPath, entry.fullPath));
    }
    filterPath(entry) {
        const { stats } = entry;
        if (stats && stats.isSymbolicLink())
            return this.filterDir(entry);
        const resolvedPath = this.entryPath(entry);
        // TODO: what if stats is undefined? remove !
        return this.fsw._isntIgnored(resolvedPath, stats) && this.fsw._hasReadPermissions(stats);
    }
    filterDir(entry) {
        return this.fsw._isntIgnored(this.entryPath(entry), entry.stats);
    }
}
/**
 * Watches files & directories for changes. Emitted events:
 * `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`
 *
 *     new FSWatcher()
 *       .add(directories)
 *       .on('add', path => log('File', path, 'was added'))
 */
class FSWatcher extends EventEmitter {
    // Not indenting methods for history sake; for now.
    constructor(_opts = {}) {
        super();
        this.closed = false;
        this._closers = new Map();
        this._ignoredPaths = new Set();
        this._throttled = new Map();
        this._streams = new Set();
        this._symlinkPaths = new Map();
        this._watched = new Map();
        this._pendingWrites = new Map();
        this._pendingUnlinks = new Map();
        this._readyCount = 0;
        this._readyEmitted = false;
        const awf = _opts.awaitWriteFinish;
        const DEF_AWF = { stabilityThreshold: 2000, pollInterval: 100 };
        const opts = {
            // Defaults
            persistent: true,
            ignoreInitial: false,
            ignorePermissionErrors: false,
            interval: 100,
            binaryInterval: 300,
            followSymlinks: true,
            usePolling: false,
            // useAsync: false,
            atomic: true, // NOTE: overwritten later (depends on usePolling)
            ..._opts,
            // Change format
            ignored: _opts.ignored ? arrify(_opts.ignored) : arrify([]),
            awaitWriteFinish: awf === true ? DEF_AWF : typeof awf === 'object' ? { ...DEF_AWF, ...awf } : false,
        };
        // Always default to polling on IBM i because fs.watch() is not available on IBM i.
        if (isIBMi)
            opts.usePolling = true;
        // Editor atomic write normalization enabled by default with fs.watch
        if (opts.atomic === undefined)
            opts.atomic = !opts.usePolling;
        // opts.atomic = typeof _opts.atomic === 'number' ? _opts.atomic : 100;
        // Global override. Useful for developers, who need to force polling for all
        // instances of chokidar, regardless of usage / dependency depth
        const envPoll = process.env.CHOKIDAR_USEPOLLING;
        if (envPoll !== undefined) {
            const envLower = envPoll.toLowerCase();
            if (envLower === 'false' || envLower === '0')
                opts.usePolling = false;
            else if (envLower === 'true' || envLower === '1')
                opts.usePolling = true;
            else
                opts.usePolling = !!envLower;
        }
        const envInterval = process.env.CHOKIDAR_INTERVAL;
        if (envInterval)
            opts.interval = Number.parseInt(envInterval, 10);
        // This is done to emit ready only once, but each 'add' will increase that?
        let readyCalls = 0;
        this._emitReady = () => {
            readyCalls++;
            if (readyCalls >= this._readyCount) {
                this._emitReady = EMPTY_FN;
                this._readyEmitted = true;
                // use process.nextTick to allow time for listener to be bound
                process.nextTick(() => this.emit(EVENTS.READY));
            }
        };
        this._emitRaw = (...args) => this.emit(EVENTS.RAW, ...args);
        this._boundRemove = this._remove.bind(this);
        this.options = opts;
        this._nodeFsHandler = new NodeFsHandler(this);
        // Youre frozen when your hearts not open.
        Object.freeze(opts);
    }
    _addIgnoredPath(matcher) {
        if (isMatcherObject(matcher)) {
            // return early if we already have a deeply equal matcher object
            for (const ignored of this._ignoredPaths) {
                if (isMatcherObject(ignored) &&
                    ignored.path === matcher.path &&
                    ignored.recursive === matcher.recursive) {
                    return;
                }
            }
        }
        this._ignoredPaths.add(matcher);
    }
    _removeIgnoredPath(matcher) {
        this._ignoredPaths.delete(matcher);
        // now find any matcher objects with the matcher as path
        if (typeof matcher === 'string') {
            for (const ignored of this._ignoredPaths) {
                // TODO (43081j): make this more efficient.
                // probably just make a `this._ignoredDirectories` or some
                // such thing.
                if (isMatcherObject(ignored) && ignored.path === matcher) {
                    this._ignoredPaths.delete(ignored);
                }
            }
        }
    }
    // Public methods
    /**
     * Adds paths to be watched on an existing FSWatcher instance.
     * @param paths_ file or file list. Other arguments are unused
     */
    add(paths_, _origAdd, _internal) {
        const { cwd } = this.options;
        this.closed = false;
        this._closePromise = undefined;
        let paths = unifyPaths(paths_);
        if (cwd) {
            paths = paths.map((path) => {
                const absPath = getAbsolutePath(path, cwd);
                // Check `path` instead of `absPath` because the cwd portion can't be a glob
                return absPath;
            });
        }
        paths.forEach((path) => {
            this._removeIgnoredPath(path);
        });
        this._userIgnored = undefined;
        if (!this._readyCount)
            this._readyCount = 0;
        this._readyCount += paths.length;
        Promise.all(paths.map(async (path) => {
            const res = await this._nodeFsHandler._addToNodeFs(path, !_internal, undefined, 0, _origAdd);
            if (res)
                this._emitReady();
            return res;
        })).then((results) => {
            if (this.closed)
                return;
            results.forEach((item) => {
                if (item)
                    this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));
            });
        });
        return this;
    }
    /**
     * Close watchers or start ignoring events from specified paths.
     */
    unwatch(paths_) {
        if (this.closed)
            return this;
        const paths = unifyPaths(paths_);
        const { cwd } = this.options;
        paths.forEach((path) => {
            // convert to absolute path unless relative path already matches
            if (!sysPath.isAbsolute(path) && !this._closers.has(path)) {
                if (cwd)
                    path = sysPath.join(cwd, path);
                path = sysPath.resolve(path);
            }
            this._closePath(path);
            this._addIgnoredPath(path);
            if (this._watched.has(path)) {
                this._addIgnoredPath({
                    path,
                    recursive: true,
                });
            }
            // reset the cached userIgnored anymatch fn
            // to make ignoredPaths changes effective
            this._userIgnored = undefined;
        });
        return this;
    }
    /**
     * Close watchers and remove all listeners from watched paths.
     */
    close() {
        if (this._closePromise) {
            return this._closePromise;
        }
        this.closed = true;
        // Memory management.
        this.removeAllListeners();
        const closers = [];
        this._closers.forEach((closerList) => closerList.forEach((closer) => {
            const promise = closer();
            if (promise instanceof Promise)
                closers.push(promise);
        }));
        this._streams.forEach((stream) => stream.destroy());
        this._userIgnored = undefined;
        this._readyCount = 0;
        this._readyEmitted = false;
        this._watched.forEach((dirent) => dirent.dispose());
        this._closers.clear();
        this._watched.clear();
        this._streams.clear();
        this._symlinkPaths.clear();
        this._throttled.clear();
        this._closePromise = closers.length
            ? Promise.all(closers).then(() => undefined)
            : Promise.resolve();
        return this._closePromise;
    }
    /**
     * Expose list of watched paths
     * @returns for chaining
     */
    getWatched() {
        const watchList = {};
        this._watched.forEach((entry, dir) => {
            const key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;
            const index = key || ONE_DOT;
            watchList[index] = entry.getChildren().sort();
        });
        return watchList;
    }
    emitWithAll(event, args) {
        this.emit(event, ...args);
        if (event !== EVENTS.ERROR)
            this.emit(EVENTS.ALL, event, ...args);
    }
    // Common helpers
    // --------------
    /**
     * Normalize and emit events.
     * Calling _emit DOES NOT MEAN emit() would be called!
     * @param event Type of event
     * @param path File or directory path
     * @param stats arguments to be passed with event
     * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag
     */
    async _emit(event, path, stats) {
        if (this.closed)
            return;
        const opts = this.options;
        if (isWindows$1)
            path = sysPath.normalize(path);
        if (opts.cwd)
            path = sysPath.relative(opts.cwd, path);
        const args = [path];
        if (stats != null)
            args.push(stats);
        const awf = opts.awaitWriteFinish;
        let pw;
        if (awf && (pw = this._pendingWrites.get(path))) {
            pw.lastChange = new Date();
            return this;
        }
        if (opts.atomic) {
            if (event === EVENTS.UNLINK) {
                this._pendingUnlinks.set(path, [event, ...args]);
                setTimeout(() => {
                    this._pendingUnlinks.forEach((entry, path) => {
                        this.emit(...entry);
                        this.emit(EVENTS.ALL, ...entry);
                        this._pendingUnlinks.delete(path);
                    });
                }, typeof opts.atomic === 'number' ? opts.atomic : 100);
                return this;
            }
            if (event === EVENTS.ADD && this._pendingUnlinks.has(path)) {
                event = EVENTS.CHANGE;
                this._pendingUnlinks.delete(path);
            }
        }
        if (awf && (event === EVENTS.ADD || event === EVENTS.CHANGE) && this._readyEmitted) {
            const awfEmit = (err, stats) => {
                if (err) {
                    event = EVENTS.ERROR;
                    args[0] = err;
                    this.emitWithAll(event, args);
                }
                else if (stats) {
                    // if stats doesn't exist the file must have been deleted
                    if (args.length > 1) {
                        args[1] = stats;
                    }
                    else {
                        args.push(stats);
                    }
                    this.emitWithAll(event, args);
                }
            };
            this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);
            return this;
        }
        if (event === EVENTS.CHANGE) {
            const isThrottled = !this._throttle(EVENTS.CHANGE, path, 50);
            if (isThrottled)
                return this;
        }
        if (opts.alwaysStat &&
            stats === undefined &&
            (event === EVENTS.ADD || event === EVENTS.ADD_DIR || event === EVENTS.CHANGE)) {
            const fullPath = opts.cwd ? sysPath.join(opts.cwd, path) : path;
            let stats;
            try {
                stats = await stat$1(fullPath);
            }
            catch (err) {
                // do nothing
            }
            // Suppress event when fs_stat fails, to avoid sending undefined 'stat'
            if (!stats || this.closed)
                return;
            args.push(stats);
        }
        this.emitWithAll(event, args);
        return this;
    }
    /**
     * Common handler for errors
     * @returns The error if defined, otherwise the value of the FSWatcher instance's `closed` flag
     */
    _handleError(error) {
        const code = error && error.code;
        if (error &&
            code !== 'ENOENT' &&
            code !== 'ENOTDIR' &&
            (!this.options.ignorePermissionErrors || (code !== 'EPERM' && code !== 'EACCES'))) {
            this.emit(EVENTS.ERROR, error);
        }
        return error || this.closed;
    }
    /**
     * Helper utility for throttling
     * @param actionType type being throttled
     * @param path being acted upon
     * @param timeout duration of time to suppress duplicate actions
     * @returns tracking object or false if action should be suppressed
     */
    _throttle(actionType, path, timeout) {
        if (!this._throttled.has(actionType)) {
            this._throttled.set(actionType, new Map());
        }
        const action = this._throttled.get(actionType);
        if (!action)
            throw new Error('invalid throttle');
        const actionPath = action.get(path);
        if (actionPath) {
            actionPath.count++;
            return false;
        }
        // eslint-disable-next-line prefer-const
        let timeoutObject;
        const clear = () => {
            const item = action.get(path);
            const count = item ? item.count : 0;
            action.delete(path);
            clearTimeout(timeoutObject);
            if (item)
                clearTimeout(item.timeoutObject);
            return count;
        };
        timeoutObject = setTimeout(clear, timeout);
        const thr = { timeoutObject, clear, count: 0 };
        action.set(path, thr);
        return thr;
    }
    _incrReadyCount() {
        return this._readyCount++;
    }
    /**
     * Awaits write operation to finish.
     * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.
     * @param path being acted upon
     * @param threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished
     * @param event
     * @param awfEmit Callback to be called when ready for event to be emitted.
     */
    _awaitWriteFinish(path, threshold, event, awfEmit) {
        const awf = this.options.awaitWriteFinish;
        if (typeof awf !== 'object')
            return;
        const pollInterval = awf.pollInterval;
        let timeoutHandler;
        let fullPath = path;
        if (this.options.cwd && !sysPath.isAbsolute(path)) {
            fullPath = sysPath.join(this.options.cwd, path);
        }
        const now = new Date();
        const writes = this._pendingWrites;
        function awaitWriteFinishFn(prevStat) {
            stat$2(fullPath, (err, curStat) => {
                if (err || !writes.has(path)) {
                    if (err && err.code !== 'ENOENT')
                        awfEmit(err);
                    return;
                }
                const now = Number(new Date());
                if (prevStat && curStat.size !== prevStat.size) {
                    writes.get(path).lastChange = now;
                }
                const pw = writes.get(path);
                const df = now - pw.lastChange;
                if (df >= threshold) {
                    writes.delete(path);
                    awfEmit(undefined, curStat);
                }
                else {
                    timeoutHandler = setTimeout(awaitWriteFinishFn, pollInterval, curStat);
                }
            });
        }
        if (!writes.has(path)) {
            writes.set(path, {
                lastChange: now,
                cancelWait: () => {
                    writes.delete(path);
                    clearTimeout(timeoutHandler);
                    return event;
                },
            });
            timeoutHandler = setTimeout(awaitWriteFinishFn, pollInterval);
        }
    }
    /**
     * Determines whether user has asked to ignore this path.
     */
    _isIgnored(path, stats) {
        if (this.options.atomic && DOT_RE.test(path))
            return true;
        if (!this._userIgnored) {
            const { cwd } = this.options;
            const ign = this.options.ignored;
            const ignored = (ign || []).map(normalizeIgnored(cwd));
            const ignoredPaths = [...this._ignoredPaths];
            const list = [...ignoredPaths.map(normalizeIgnored(cwd)), ...ignored];
            this._userIgnored = anymatch$2(list);
        }
        return this._userIgnored(path, stats);
    }
    _isntIgnored(path, stat) {
        return !this._isIgnored(path, stat);
    }
    /**
     * Provides a set of common helpers and properties relating to symlink handling.
     * @param path file or directory pattern being watched
     */
    _getWatchHelpers(path) {
        return new WatchHelper(path, this.options.followSymlinks, this);
    }
    // Directory helpers
    // -----------------
    /**
     * Provides directory tracking objects
     * @param directory path of the directory
     */
    _getWatchedDir(directory) {
        const dir = sysPath.resolve(directory);
        if (!this._watched.has(dir))
            this._watched.set(dir, new DirEntry(dir, this._boundRemove));
        return this._watched.get(dir);
    }
    // File helpers
    // ------------
    /**
     * Check for read permissions: https://stackoverflow.com/a/11781404/1358405
     */
    _hasReadPermissions(stats) {
        if (this.options.ignorePermissionErrors)
            return true;
        return Boolean(Number(stats.mode) & 0o400);
    }
    /**
     * Handles emitting unlink events for
     * files and directories, and via recursion, for
     * files and directories within directories that are unlinked
     * @param directory within which the following item is located
     * @param item      base path of item/directory
     */
    _remove(directory, item, isDirectory) {
        // if what is being deleted is a directory, get that directory's paths
        // for recursive deleting and cleaning of watched object
        // if it is not a directory, nestedDirectoryChildren will be empty array
        const path = sysPath.join(directory, item);
        const fullPath = sysPath.resolve(path);
        isDirectory =
            isDirectory != null ? isDirectory : this._watched.has(path) || this._watched.has(fullPath);
        // prevent duplicate handling in case of arriving here nearly simultaneously
        // via multiple paths (such as _handleFile and _handleDir)
        if (!this._throttle('remove', path, 100))
            return;
        // if the only watched file is removed, watch for its return
        if (!isDirectory && this._watched.size === 1) {
            this.add(directory, item, true);
        }
        // This will create a new entry in the watched object in either case
        // so we got to do the directory check beforehand
        const wp = this._getWatchedDir(path);
        const nestedDirectoryChildren = wp.getChildren();
        // Recursively remove children directories / files.
        nestedDirectoryChildren.forEach((nested) => this._remove(path, nested));
        // Check if item was on the watched list and remove it
        const parent = this._getWatchedDir(directory);
        const wasTracked = parent.has(item);
        parent.remove(item);
        // Fixes issue #1042 -> Relative paths were detected and added as symlinks
        // (https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L612),
        // but never removed from the map in case the path was deleted.
        // This leads to an incorrect state if the path was recreated:
        // https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L553
        if (this._symlinkPaths.has(fullPath)) {
            this._symlinkPaths.delete(fullPath);
        }
        // If we wait for this file to be fully written, cancel the wait.
        let relPath = path;
        if (this.options.cwd)
            relPath = sysPath.relative(this.options.cwd, path);
        if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {
            const event = this._pendingWrites.get(relPath).cancelWait();
            if (event === EVENTS.ADD)
                return;
        }
        // The Entry will either be a directory that just got removed
        // or a bogus entry to a file, in either case we have to remove it
        this._watched.delete(path);
        this._watched.delete(fullPath);
        const eventName = isDirectory ? EVENTS.UNLINK_DIR : EVENTS.UNLINK;
        if (wasTracked && !this._isIgnored(path))
            this._emit(eventName, path);
        // Avoid conflicts if we later create another file with the same name
        this._closePath(path);
    }
    /**
     * Closes all watchers for a path
     */
    _closePath(path) {
        this._closeFile(path);
        const dir = sysPath.dirname(path);
        this._getWatchedDir(dir).remove(sysPath.basename(path));
    }
    /**
     * Closes only file-specific watchers
     */
    _closeFile(path) {
        const closers = this._closers.get(path);
        if (!closers)
            return;
        closers.forEach((closer) => closer());
        this._closers.delete(path);
    }
    _addPathCloser(path, closer) {
        if (!closer)
            return;
        let list = this._closers.get(path);
        if (!list) {
            list = [];
            this._closers.set(path, list);
        }
        list.push(closer);
    }
    _readdirp(root, opts) {
        if (this.closed)
            return;
        const options = { type: EVENTS.ALL, alwaysStat: true, lstat: true, ...opts, depth: 0 };
        let stream = readdirp(root, options);
        this._streams.add(stream);
        stream.once(STR_CLOSE, () => {
            stream = undefined;
        });
        stream.once(STR_END, () => {
            if (stream) {
                this._streams.delete(stream);
                stream = undefined;
            }
        });
        return stream;
    }
}
/**
 * Instantiates watcher with paths to be tracked.
 * @param paths file / directory paths
 * @param options opts, such as `atomic`, `awaitWriteFinish`, `ignored`, and others
 * @returns an instance of FSWatcher for chaining.
 * @example
 * const watcher = watch('.').on('all', (event, path) => { console.log(event, path); });
 * watch('.', { atomic: true, awaitWriteFinish: true, ignored: (f, stats) => stats?.isFile() && !f.endsWith('.js') })
 */
function watch(paths, options = {}) {
    const watcher = new FSWatcher(options);
    watcher.add(paths);
    return watcher;
}

var anymatch$1 = {exports: {}};

var utils = {};

var constants$1;
var hasRequiredConstants$1;

function requireConstants$1 () {
	if (hasRequiredConstants$1) return constants$1;
	hasRequiredConstants$1 = 1;

	const path = sysPath__default;
	const WIN_SLASH = '\\\\/';
	const WIN_NO_SLASH = `[^${WIN_SLASH}]`;

	/**
	 * Posix glob regex
	 */

	const DOT_LITERAL = '\\.';
	const PLUS_LITERAL = '\\+';
	const QMARK_LITERAL = '\\?';
	const SLASH_LITERAL = '\\/';
	const ONE_CHAR = '(?=.)';
	const QMARK = '[^/]';
	const END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
	const START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
	const DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
	const NO_DOT = `(?!${DOT_LITERAL})`;
	const NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
	const NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
	const NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
	const QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
	const STAR = `${QMARK}*?`;

	const POSIX_CHARS = {
	  DOT_LITERAL,
	  PLUS_LITERAL,
	  QMARK_LITERAL,
	  SLASH_LITERAL,
	  ONE_CHAR,
	  QMARK,
	  END_ANCHOR,
	  DOTS_SLASH,
	  NO_DOT,
	  NO_DOTS,
	  NO_DOT_SLASH,
	  NO_DOTS_SLASH,
	  QMARK_NO_DOT,
	  STAR,
	  START_ANCHOR
	};

	/**
	 * Windows glob regex
	 */

	const WINDOWS_CHARS = {
	  ...POSIX_CHARS,

	  SLASH_LITERAL: `[${WIN_SLASH}]`,
	  QMARK: WIN_NO_SLASH,
	  STAR: `${WIN_NO_SLASH}*?`,
	  DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
	  NO_DOT: `(?!${DOT_LITERAL})`,
	  NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
	  NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
	  NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
	  QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
	  START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
	  END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
	};

	/**
	 * POSIX Bracket Regex
	 */

	const POSIX_REGEX_SOURCE = {
	  alnum: 'a-zA-Z0-9',
	  alpha: 'a-zA-Z',
	  ascii: '\\x00-\\x7F',
	  blank: ' \\t',
	  cntrl: '\\x00-\\x1F\\x7F',
	  digit: '0-9',
	  graph: '\\x21-\\x7E',
	  lower: 'a-z',
	  print: '\\x20-\\x7E ',
	  punct: '\\-!"#$%&\'()\\*+,./:;<=>?@[\\]^_`{|}~',
	  space: ' \\t\\r\\n\\v\\f',
	  upper: 'A-Z',
	  word: 'A-Za-z0-9_',
	  xdigit: 'A-Fa-f0-9'
	};

	constants$1 = {
	  MAX_LENGTH: 1024 * 64,
	  POSIX_REGEX_SOURCE,

	  // regular expressions
	  REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
	  REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
	  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
	  REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
	  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
	  REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,

	  // Replace globs with equivalent patterns to reduce parsing time.
	  REPLACEMENTS: {
	    '***': '*',
	    '**/**': '**',
	    '**/**/**': '**'
	  },

	  // Digits
	  CHAR_0: 48, /* 0 */
	  CHAR_9: 57, /* 9 */

	  // Alphabet chars.
	  CHAR_UPPERCASE_A: 65, /* A */
	  CHAR_LOWERCASE_A: 97, /* a */
	  CHAR_UPPERCASE_Z: 90, /* Z */
	  CHAR_LOWERCASE_Z: 122, /* z */

	  CHAR_LEFT_PARENTHESES: 40, /* ( */
	  CHAR_RIGHT_PARENTHESES: 41, /* ) */

	  CHAR_ASTERISK: 42, /* * */

	  // Non-alphabetic chars.
	  CHAR_AMPERSAND: 38, /* & */
	  CHAR_AT: 64, /* @ */
	  CHAR_BACKWARD_SLASH: 92, /* \ */
	  CHAR_CARRIAGE_RETURN: 13, /* \r */
	  CHAR_CIRCUMFLEX_ACCENT: 94, /* ^ */
	  CHAR_COLON: 58, /* : */
	  CHAR_COMMA: 44, /* , */
	  CHAR_DOT: 46, /* . */
	  CHAR_DOUBLE_QUOTE: 34, /* " */
	  CHAR_EQUAL: 61, /* = */
	  CHAR_EXCLAMATION_MARK: 33, /* ! */
	  CHAR_FORM_FEED: 12, /* \f */
	  CHAR_FORWARD_SLASH: 47, /* / */
	  CHAR_GRAVE_ACCENT: 96, /* ` */
	  CHAR_HASH: 35, /* # */
	  CHAR_HYPHEN_MINUS: 45, /* - */
	  CHAR_LEFT_ANGLE_BRACKET: 60, /* < */
	  CHAR_LEFT_CURLY_BRACE: 123, /* { */
	  CHAR_LEFT_SQUARE_BRACKET: 91, /* [ */
	  CHAR_LINE_FEED: 10, /* \n */
	  CHAR_NO_BREAK_SPACE: 160, /* \u00A0 */
	  CHAR_PERCENT: 37, /* % */
	  CHAR_PLUS: 43, /* + */
	  CHAR_QUESTION_MARK: 63, /* ? */
	  CHAR_RIGHT_ANGLE_BRACKET: 62, /* > */
	  CHAR_RIGHT_CURLY_BRACE: 125, /* } */
	  CHAR_RIGHT_SQUARE_BRACKET: 93, /* ] */
	  CHAR_SEMICOLON: 59, /* ; */
	  CHAR_SINGLE_QUOTE: 39, /* ' */
	  CHAR_SPACE: 32, /*   */
	  CHAR_TAB: 9, /* \t */
	  CHAR_UNDERSCORE: 95, /* _ */
	  CHAR_VERTICAL_LINE: 124, /* | */
	  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279, /* \uFEFF */

	  SEP: path.sep,

	  /**
	   * Create EXTGLOB_CHARS
	   */

	  extglobChars(chars) {
	    return {
	      '!': { type: 'negate', open: '(?:(?!(?:', close: `))${chars.STAR})` },
	      '?': { type: 'qmark', open: '(?:', close: ')?' },
	      '+': { type: 'plus', open: '(?:', close: ')+' },
	      '*': { type: 'star', open: '(?:', close: ')*' },
	      '@': { type: 'at', open: '(?:', close: ')' }
	    };
	  },

	  /**
	   * Create GLOB_CHARS
	   */

	  globChars(win32) {
	    return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
	  }
	};
	return constants$1;
}

var hasRequiredUtils;

function requireUtils () {
	if (hasRequiredUtils) return utils;
	hasRequiredUtils = 1;
	(function (exports) {

		const path = sysPath__default;
		const win32 = process.platform === 'win32';
		const {
		  REGEX_BACKSLASH,
		  REGEX_REMOVE_BACKSLASH,
		  REGEX_SPECIAL_CHARS,
		  REGEX_SPECIAL_CHARS_GLOBAL
		} = requireConstants$1();

		exports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);
		exports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);
		exports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);
		exports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\$1');
		exports.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/');

		exports.removeBackslashes = str => {
		  return str.replace(REGEX_REMOVE_BACKSLASH, match => {
		    return match === '\\' ? '' : match;
		  });
		};

		exports.supportsLookbehinds = () => {
		  const segs = process.version.slice(1).split('.').map(Number);
		  if (segs.length === 3 && segs[0] >= 9 || (segs[0] === 8 && segs[1] >= 10)) {
		    return true;
		  }
		  return false;
		};

		exports.isWindows = options => {
		  if (options && typeof options.windows === 'boolean') {
		    return options.windows;
		  }
		  return win32 === true || path.sep === '\\';
		};

		exports.escapeLast = (input, char, lastIdx) => {
		  const idx = input.lastIndexOf(char, lastIdx);
		  if (idx === -1) return input;
		  if (input[idx - 1] === '\\') return exports.escapeLast(input, char, idx - 1);
		  return `${input.slice(0, idx)}\\${input.slice(idx)}`;
		};

		exports.removePrefix = (input, state = {}) => {
		  let output = input;
		  if (output.startsWith('./')) {
		    output = output.slice(2);
		    state.prefix = './';
		  }
		  return output;
		};

		exports.wrapOutput = (input, state = {}, options = {}) => {
		  const prepend = options.contains ? '' : '^';
		  const append = options.contains ? '' : '$';

		  let output = `${prepend}(?:${input})${append}`;
		  if (state.negated === true) {
		    output = `(?:^(?!${output}).*$)`;
		  }
		  return output;
		}; 
	} (utils));
	return utils;
}

var scan_1;
var hasRequiredScan;

function requireScan () {
	if (hasRequiredScan) return scan_1;
	hasRequiredScan = 1;

	const utils = requireUtils();
	const {
	  CHAR_ASTERISK,             /* * */
	  CHAR_AT,                   /* @ */
	  CHAR_BACKWARD_SLASH,       /* \ */
	  CHAR_COMMA,                /* , */
	  CHAR_DOT,                  /* . */
	  CHAR_EXCLAMATION_MARK,     /* ! */
	  CHAR_FORWARD_SLASH,        /* / */
	  CHAR_LEFT_CURLY_BRACE,     /* { */
	  CHAR_LEFT_PARENTHESES,     /* ( */
	  CHAR_LEFT_SQUARE_BRACKET,  /* [ */
	  CHAR_PLUS,                 /* + */
	  CHAR_QUESTION_MARK,        /* ? */
	  CHAR_RIGHT_CURLY_BRACE,    /* } */
	  CHAR_RIGHT_PARENTHESES,    /* ) */
	  CHAR_RIGHT_SQUARE_BRACKET  /* ] */
	} = requireConstants$1();

	const isPathSeparator = code => {
	  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
	};

	const depth = token => {
	  if (token.isPrefix !== true) {
	    token.depth = token.isGlobstar ? Infinity : 1;
	  }
	};

	/**
	 * Quickly scans a glob pattern and returns an object with a handful of
	 * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),
	 * `glob` (the actual pattern), `negated` (true if the path starts with `!` but not
	 * with `!(`) and `negatedExtglob` (true if the path starts with `!(`).
	 *
	 * ```js
	 * const pm = require('picomatch');
	 * console.log(pm.scan('foo/bar/*.js'));
	 * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }
	 * ```
	 * @param {String} `str`
	 * @param {Object} `options`
	 * @return {Object} Returns an object with tokens and regex source string.
	 * @api public
	 */

	const scan = (input, options) => {
	  const opts = options || {};

	  const length = input.length - 1;
	  const scanToEnd = opts.parts === true || opts.scanToEnd === true;
	  const slashes = [];
	  const tokens = [];
	  const parts = [];

	  let str = input;
	  let index = -1;
	  let start = 0;
	  let lastIndex = 0;
	  let isBrace = false;
	  let isBracket = false;
	  let isGlob = false;
	  let isExtglob = false;
	  let isGlobstar = false;
	  let braceEscaped = false;
	  let backslashes = false;
	  let negated = false;
	  let negatedExtglob = false;
	  let finished = false;
	  let braces = 0;
	  let prev;
	  let code;
	  let token = { value: '', depth: 0, isGlob: false };

	  const eos = () => index >= length;
	  const peek = () => str.charCodeAt(index + 1);
	  const advance = () => {
	    prev = code;
	    return str.charCodeAt(++index);
	  };

	  while (index < length) {
	    code = advance();
	    let next;

	    if (code === CHAR_BACKWARD_SLASH) {
	      backslashes = token.backslashes = true;
	      code = advance();

	      if (code === CHAR_LEFT_CURLY_BRACE) {
	        braceEscaped = true;
	      }
	      continue;
	    }

	    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
	      braces++;

	      while (eos() !== true && (code = advance())) {
	        if (code === CHAR_BACKWARD_SLASH) {
	          backslashes = token.backslashes = true;
	          advance();
	          continue;
	        }

	        if (code === CHAR_LEFT_CURLY_BRACE) {
	          braces++;
	          continue;
	        }

	        if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
	          isBrace = token.isBrace = true;
	          isGlob = token.isGlob = true;
	          finished = true;

	          if (scanToEnd === true) {
	            continue;
	          }

	          break;
	        }

	        if (braceEscaped !== true && code === CHAR_COMMA) {
	          isBrace = token.isBrace = true;
	          isGlob = token.isGlob = true;
	          finished = true;

	          if (scanToEnd === true) {
	            continue;
	          }

	          break;
	        }

	        if (code === CHAR_RIGHT_CURLY_BRACE) {
	          braces--;

	          if (braces === 0) {
	            braceEscaped = false;
	            isBrace = token.isBrace = true;
	            finished = true;
	            break;
	          }
	        }
	      }

	      if (scanToEnd === true) {
	        continue;
	      }

	      break;
	    }

	    if (code === CHAR_FORWARD_SLASH) {
	      slashes.push(index);
	      tokens.push(token);
	      token = { value: '', depth: 0, isGlob: false };

	      if (finished === true) continue;
	      if (prev === CHAR_DOT && index === (start + 1)) {
	        start += 2;
	        continue;
	      }

	      lastIndex = index + 1;
	      continue;
	    }

	    if (opts.noext !== true) {
	      const isExtglobChar = code === CHAR_PLUS
	        || code === CHAR_AT
	        || code === CHAR_ASTERISK
	        || code === CHAR_QUESTION_MARK
	        || code === CHAR_EXCLAMATION_MARK;

	      if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
	        isGlob = token.isGlob = true;
	        isExtglob = token.isExtglob = true;
	        finished = true;
	        if (code === CHAR_EXCLAMATION_MARK && index === start) {
	          negatedExtglob = true;
	        }

	        if (scanToEnd === true) {
	          while (eos() !== true && (code = advance())) {
	            if (code === CHAR_BACKWARD_SLASH) {
	              backslashes = token.backslashes = true;
	              code = advance();
	              continue;
	            }

	            if (code === CHAR_RIGHT_PARENTHESES) {
	              isGlob = token.isGlob = true;
	              finished = true;
	              break;
	            }
	          }
	          continue;
	        }
	        break;
	      }
	    }

	    if (code === CHAR_ASTERISK) {
	      if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;
	      isGlob = token.isGlob = true;
	      finished = true;

	      if (scanToEnd === true) {
	        continue;
	      }
	      break;
	    }

	    if (code === CHAR_QUESTION_MARK) {
	      isGlob = token.isGlob = true;
	      finished = true;

	      if (scanToEnd === true) {
	        continue;
	      }
	      break;
	    }

	    if (code === CHAR_LEFT_SQUARE_BRACKET) {
	      while (eos() !== true && (next = advance())) {
	        if (next === CHAR_BACKWARD_SLASH) {
	          backslashes = token.backslashes = true;
	          advance();
	          continue;
	        }

	        if (next === CHAR_RIGHT_SQUARE_BRACKET) {
	          isBracket = token.isBracket = true;
	          isGlob = token.isGlob = true;
	          finished = true;
	          break;
	        }
	      }

	      if (scanToEnd === true) {
	        continue;
	      }

	      break;
	    }

	    if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
	      negated = token.negated = true;
	      start++;
	      continue;
	    }

	    if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
	      isGlob = token.isGlob = true;

	      if (scanToEnd === true) {
	        while (eos() !== true && (code = advance())) {
	          if (code === CHAR_LEFT_PARENTHESES) {
	            backslashes = token.backslashes = true;
	            code = advance();
	            continue;
	          }

	          if (code === CHAR_RIGHT_PARENTHESES) {
	            finished = true;
	            break;
	          }
	        }
	        continue;
	      }
	      break;
	    }

	    if (isGlob === true) {
	      finished = true;

	      if (scanToEnd === true) {
	        continue;
	      }

	      break;
	    }
	  }

	  if (opts.noext === true) {
	    isExtglob = false;
	    isGlob = false;
	  }

	  let base = str;
	  let prefix = '';
	  let glob = '';

	  if (start > 0) {
	    prefix = str.slice(0, start);
	    str = str.slice(start);
	    lastIndex -= start;
	  }

	  if (base && isGlob === true && lastIndex > 0) {
	    base = str.slice(0, lastIndex);
	    glob = str.slice(lastIndex);
	  } else if (isGlob === true) {
	    base = '';
	    glob = str;
	  } else {
	    base = str;
	  }

	  if (base && base !== '' && base !== '/' && base !== str) {
	    if (isPathSeparator(base.charCodeAt(base.length - 1))) {
	      base = base.slice(0, -1);
	    }
	  }

	  if (opts.unescape === true) {
	    if (glob) glob = utils.removeBackslashes(glob);

	    if (base && backslashes === true) {
	      base = utils.removeBackslashes(base);
	    }
	  }

	  const state = {
	    prefix,
	    input,
	    start,
	    base,
	    glob,
	    isBrace,
	    isBracket,
	    isGlob,
	    isExtglob,
	    isGlobstar,
	    negated,
	    negatedExtglob
	  };

	  if (opts.tokens === true) {
	    state.maxDepth = 0;
	    if (!isPathSeparator(code)) {
	      tokens.push(token);
	    }
	    state.tokens = tokens;
	  }

	  if (opts.parts === true || opts.tokens === true) {
	    let prevIndex;

	    for (let idx = 0; idx < slashes.length; idx++) {
	      const n = prevIndex ? prevIndex + 1 : start;
	      const i = slashes[idx];
	      const value = input.slice(n, i);
	      if (opts.tokens) {
	        if (idx === 0 && start !== 0) {
	          tokens[idx].isPrefix = true;
	          tokens[idx].value = prefix;
	        } else {
	          tokens[idx].value = value;
	        }
	        depth(tokens[idx]);
	        state.maxDepth += tokens[idx].depth;
	      }
	      if (idx !== 0 || value !== '') {
	        parts.push(value);
	      }
	      prevIndex = i;
	    }

	    if (prevIndex && prevIndex + 1 < input.length) {
	      const value = input.slice(prevIndex + 1);
	      parts.push(value);

	      if (opts.tokens) {
	        tokens[tokens.length - 1].value = value;
	        depth(tokens[tokens.length - 1]);
	        state.maxDepth += tokens[tokens.length - 1].depth;
	      }
	    }

	    state.slashes = slashes;
	    state.parts = parts;
	  }

	  return state;
	};

	scan_1 = scan;
	return scan_1;
}

var parse_1$1;
var hasRequiredParse$1;

function requireParse$1 () {
	if (hasRequiredParse$1) return parse_1$1;
	hasRequiredParse$1 = 1;

	const constants = requireConstants$1();
	const utils = requireUtils();

	/**
	 * Constants
	 */

	const {
	  MAX_LENGTH,
	  POSIX_REGEX_SOURCE,
	  REGEX_NON_SPECIAL_CHARS,
	  REGEX_SPECIAL_CHARS_BACKREF,
	  REPLACEMENTS
	} = constants;

	/**
	 * Helpers
	 */

	const expandRange = (args, options) => {
	  if (typeof options.expandRange === 'function') {
	    return options.expandRange(...args, options);
	  }

	  args.sort();
	  const value = `[${args.join('-')}]`;

	  try {
	    /* eslint-disable-next-line no-new */
	    new RegExp(value);
	  } catch (ex) {
	    return args.map(v => utils.escapeRegex(v)).join('..');
	  }

	  return value;
	};

	/**
	 * Create the message for a syntax error
	 */

	const syntaxError = (type, char) => {
	  return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
	};

	/**
	 * Parse the given input string.
	 * @param {String} input
	 * @param {Object} options
	 * @return {Object}
	 */

	const parse = (input, options) => {
	  if (typeof input !== 'string') {
	    throw new TypeError('Expected a string');
	  }

	  input = REPLACEMENTS[input] || input;

	  const opts = { ...options };
	  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;

	  let len = input.length;
	  if (len > max) {
	    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
	  }

	  const bos = { type: 'bos', value: '', output: opts.prepend || '' };
	  const tokens = [bos];

	  const capture = opts.capture ? '' : '?:';
	  const win32 = utils.isWindows(options);

	  // create constants based on platform, for windows or posix
	  const PLATFORM_CHARS = constants.globChars(win32);
	  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);

	  const {
	    DOT_LITERAL,
	    PLUS_LITERAL,
	    SLASH_LITERAL,
	    ONE_CHAR,
	    DOTS_SLASH,
	    NO_DOT,
	    NO_DOT_SLASH,
	    NO_DOTS_SLASH,
	    QMARK,
	    QMARK_NO_DOT,
	    STAR,
	    START_ANCHOR
	  } = PLATFORM_CHARS;

	  const globstar = opts => {
	    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
	  };

	  const nodot = opts.dot ? '' : NO_DOT;
	  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
	  let star = opts.bash === true ? globstar(opts) : STAR;

	  if (opts.capture) {
	    star = `(${star})`;
	  }

	  // minimatch options support
	  if (typeof opts.noext === 'boolean') {
	    opts.noextglob = opts.noext;
	  }

	  const state = {
	    input,
	    index: -1,
	    start: 0,
	    dot: opts.dot === true,
	    consumed: '',
	    output: '',
	    prefix: '',
	    backtrack: false,
	    negated: false,
	    brackets: 0,
	    braces: 0,
	    parens: 0,
	    quotes: 0,
	    globstar: false,
	    tokens
	  };

	  input = utils.removePrefix(input, state);
	  len = input.length;

	  const extglobs = [];
	  const braces = [];
	  const stack = [];
	  let prev = bos;
	  let value;

	  /**
	   * Tokenizing helpers
	   */

	  const eos = () => state.index === len - 1;
	  const peek = state.peek = (n = 1) => input[state.index + n];
	  const advance = state.advance = () => input[++state.index] || '';
	  const remaining = () => input.slice(state.index + 1);
	  const consume = (value = '', num = 0) => {
	    state.consumed += value;
	    state.index += num;
	  };

	  const append = token => {
	    state.output += token.output != null ? token.output : token.value;
	    consume(token.value);
	  };

	  const negate = () => {
	    let count = 1;

	    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {
	      advance();
	      state.start++;
	      count++;
	    }

	    if (count % 2 === 0) {
	      return false;
	    }

	    state.negated = true;
	    state.start++;
	    return true;
	  };

	  const increment = type => {
	    state[type]++;
	    stack.push(type);
	  };

	  const decrement = type => {
	    state[type]--;
	    stack.pop();
	  };

	  /**
	   * Push tokens onto the tokens array. This helper speeds up
	   * tokenizing by 1) helping us avoid backtracking as much as possible,
	   * and 2) helping us avoid creating extra tokens when consecutive
	   * characters are plain text. This improves performance and simplifies
	   * lookbehinds.
	   */

	  const push = tok => {
	    if (prev.type === 'globstar') {
	      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');
	      const isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));

	      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {
	        state.output = state.output.slice(0, -prev.output.length);
	        prev.type = 'star';
	        prev.value = '*';
	        prev.output = star;
	        state.output += prev.output;
	      }
	    }

	    if (extglobs.length && tok.type !== 'paren') {
	      extglobs[extglobs.length - 1].inner += tok.value;
	    }

	    if (tok.value || tok.output) append(tok);
	    if (prev && prev.type === 'text' && tok.type === 'text') {
	      prev.value += tok.value;
	      prev.output = (prev.output || '') + tok.value;
	      return;
	    }

	    tok.prev = prev;
	    tokens.push(tok);
	    prev = tok;
	  };

	  const extglobOpen = (type, value) => {
	    const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };

	    token.prev = prev;
	    token.parens = state.parens;
	    token.output = state.output;
	    const output = (opts.capture ? '(' : '') + token.open;

	    increment('parens');
	    push({ type, value, output: state.output ? '' : ONE_CHAR });
	    push({ type: 'paren', extglob: true, value: advance(), output });
	    extglobs.push(token);
	  };

	  const extglobClose = token => {
	    let output = token.close + (opts.capture ? ')' : '');
	    let rest;

	    if (token.type === 'negate') {
	      let extglobStar = star;

	      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {
	        extglobStar = globstar(opts);
	      }

	      if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
	        output = token.close = `)$))${extglobStar}`;
	      }

	      if (token.inner.includes('*') && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
	        // Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.
	        // In this case, we need to parse the string and use it in the output of the original pattern.
	        // Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.
	        //
	        // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.
	        const expression = parse(rest, { ...options, fastpaths: false }).output;

	        output = token.close = `)${expression})${extglobStar})`;
	      }

	      if (token.prev.type === 'bos') {
	        state.negatedExtglob = true;
	      }
	    }

	    push({ type: 'paren', extglob: true, value, output });
	    decrement('parens');
	  };

	  /**
	   * Fast paths
	   */

	  if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
	    let backslashes = false;

	    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
	      if (first === '\\') {
	        backslashes = true;
	        return m;
	      }

	      if (first === '?') {
	        if (esc) {
	          return esc + first + (rest ? QMARK.repeat(rest.length) : '');
	        }
	        if (index === 0) {
	          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');
	        }
	        return QMARK.repeat(chars.length);
	      }

	      if (first === '.') {
	        return DOT_LITERAL.repeat(chars.length);
	      }

	      if (first === '*') {
	        if (esc) {
	          return esc + first + (rest ? star : '');
	        }
	        return star;
	      }
	      return esc ? m : `\\${m}`;
	    });

	    if (backslashes === true) {
	      if (opts.unescape === true) {
	        output = output.replace(/\\/g, '');
	      } else {
	        output = output.replace(/\\+/g, m => {
	          return m.length % 2 === 0 ? '\\\\' : (m ? '\\' : '');
	        });
	      }
	    }

	    if (output === input && opts.contains === true) {
	      state.output = input;
	      return state;
	    }

	    state.output = utils.wrapOutput(output, state, options);
	    return state;
	  }

	  /**
	   * Tokenize input until we reach end-of-string
	   */

	  while (!eos()) {
	    value = advance();

	    if (value === '\u0000') {
	      continue;
	    }

	    /**
	     * Escaped characters
	     */

	    if (value === '\\') {
	      const next = peek();

	      if (next === '/' && opts.bash !== true) {
	        continue;
	      }

	      if (next === '.' || next === ';') {
	        continue;
	      }

	      if (!next) {
	        value += '\\';
	        push({ type: 'text', value });
	        continue;
	      }

	      // collapse slashes to reduce potential for exploits
	      const match = /^\\+/.exec(remaining());
	      let slashes = 0;

	      if (match && match[0].length > 2) {
	        slashes = match[0].length;
	        state.index += slashes;
	        if (slashes % 2 !== 0) {
	          value += '\\';
	        }
	      }

	      if (opts.unescape === true) {
	        value = advance();
	      } else {
	        value += advance();
	      }

	      if (state.brackets === 0) {
	        push({ type: 'text', value });
	        continue;
	      }
	    }

	    /**
	     * If we're inside a regex character class, continue
	     * until we reach the closing bracket.
	     */

	    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {
	      if (opts.posix !== false && value === ':') {
	        const inner = prev.value.slice(1);
	        if (inner.includes('[')) {
	          prev.posix = true;

	          if (inner.includes(':')) {
	            const idx = prev.value.lastIndexOf('[');
	            const pre = prev.value.slice(0, idx);
	            const rest = prev.value.slice(idx + 2);
	            const posix = POSIX_REGEX_SOURCE[rest];
	            if (posix) {
	              prev.value = pre + posix;
	              state.backtrack = true;
	              advance();

	              if (!bos.output && tokens.indexOf(prev) === 1) {
	                bos.output = ONE_CHAR;
	              }
	              continue;
	            }
	          }
	        }
	      }

	      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {
	        value = `\\${value}`;
	      }

	      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {
	        value = `\\${value}`;
	      }

	      if (opts.posix === true && value === '!' && prev.value === '[') {
	        value = '^';
	      }

	      prev.value += value;
	      append({ value });
	      continue;
	    }

	    /**
	     * If we're inside a quoted string, continue
	     * until we reach the closing double quote.
	     */

	    if (state.quotes === 1 && value !== '"') {
	      value = utils.escapeRegex(value);
	      prev.value += value;
	      append({ value });
	      continue;
	    }

	    /**
	     * Double quotes
	     */

	    if (value === '"') {
	      state.quotes = state.quotes === 1 ? 0 : 1;
	      if (opts.keepQuotes === true) {
	        push({ type: 'text', value });
	      }
	      continue;
	    }

	    /**
	     * Parentheses
	     */

	    if (value === '(') {
	      increment('parens');
	      push({ type: 'paren', value });
	      continue;
	    }

	    if (value === ')') {
	      if (state.parens === 0 && opts.strictBrackets === true) {
	        throw new SyntaxError(syntaxError('opening', '('));
	      }

	      const extglob = extglobs[extglobs.length - 1];
	      if (extglob && state.parens === extglob.parens + 1) {
	        extglobClose(extglobs.pop());
	        continue;
	      }

	      push({ type: 'paren', value, output: state.parens ? ')' : '\\)' });
	      decrement('parens');
	      continue;
	    }

	    /**
	     * Square brackets
	     */

	    if (value === '[') {
	      if (opts.nobracket === true || !remaining().includes(']')) {
	        if (opts.nobracket !== true && opts.strictBrackets === true) {
	          throw new SyntaxError(syntaxError('closing', ']'));
	        }

	        value = `\\${value}`;
	      } else {
	        increment('brackets');
	      }

	      push({ type: 'bracket', value });
	      continue;
	    }

	    if (value === ']') {
	      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {
	        push({ type: 'text', value, output: `\\${value}` });
	        continue;
	      }

	      if (state.brackets === 0) {
	        if (opts.strictBrackets === true) {
	          throw new SyntaxError(syntaxError('opening', '['));
	        }

	        push({ type: 'text', value, output: `\\${value}` });
	        continue;
	      }

	      decrement('brackets');

	      const prevValue = prev.value.slice(1);
	      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {
	        value = `/${value}`;
	      }

	      prev.value += value;
	      append({ value });

	      // when literal brackets are explicitly disabled
	      // assume we should match with a regex character class
	      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
	        continue;
	      }

	      const escaped = utils.escapeRegex(prev.value);
	      state.output = state.output.slice(0, -prev.value.length);

	      // when literal brackets are explicitly enabled
	      // assume we should escape the brackets to match literal characters
	      if (opts.literalBrackets === true) {
	        state.output += escaped;
	        prev.value = escaped;
	        continue;
	      }

	      // when the user specifies nothing, try to match both
	      prev.value = `(${capture}${escaped}|${prev.value})`;
	      state.output += prev.value;
	      continue;
	    }

	    /**
	     * Braces
	     */

	    if (value === '{' && opts.nobrace !== true) {
	      increment('braces');

	      const open = {
	        type: 'brace',
	        value,
	        output: '(',
	        outputIndex: state.output.length,
	        tokensIndex: state.tokens.length
	      };

	      braces.push(open);
	      push(open);
	      continue;
	    }

	    if (value === '}') {
	      const brace = braces[braces.length - 1];

	      if (opts.nobrace === true || !brace) {
	        push({ type: 'text', value, output: value });
	        continue;
	      }

	      let output = ')';

	      if (brace.dots === true) {
	        const arr = tokens.slice();
	        const range = [];

	        for (let i = arr.length - 1; i >= 0; i--) {
	          tokens.pop();
	          if (arr[i].type === 'brace') {
	            break;
	          }
	          if (arr[i].type !== 'dots') {
	            range.unshift(arr[i].value);
	          }
	        }

	        output = expandRange(range, opts);
	        state.backtrack = true;
	      }

	      if (brace.comma !== true && brace.dots !== true) {
	        const out = state.output.slice(0, brace.outputIndex);
	        const toks = state.tokens.slice(brace.tokensIndex);
	        brace.value = brace.output = '\\{';
	        value = output = '\\}';
	        state.output = out;
	        for (const t of toks) {
	          state.output += (t.output || t.value);
	        }
	      }

	      push({ type: 'brace', value, output });
	      decrement('braces');
	      braces.pop();
	      continue;
	    }

	    /**
	     * Pipes
	     */

	    if (value === '|') {
	      if (extglobs.length > 0) {
	        extglobs[extglobs.length - 1].conditions++;
	      }
	      push({ type: 'text', value });
	      continue;
	    }

	    /**
	     * Commas
	     */

	    if (value === ',') {
	      let output = value;

	      const brace = braces[braces.length - 1];
	      if (brace && stack[stack.length - 1] === 'braces') {
	        brace.comma = true;
	        output = '|';
	      }

	      push({ type: 'comma', value, output });
	      continue;
	    }

	    /**
	     * Slashes
	     */

	    if (value === '/') {
	      // if the beginning of the glob is "./", advance the start
	      // to the current index, and don't add the "./" characters
	      // to the state. This greatly simplifies lookbehinds when
	      // checking for BOS characters like "!" and "." (not "./")
	      if (prev.type === 'dot' && state.index === state.start + 1) {
	        state.start = state.index + 1;
	        state.consumed = '';
	        state.output = '';
	        tokens.pop();
	        prev = bos; // reset "prev" to the first token
	        continue;
	      }

	      push({ type: 'slash', value, output: SLASH_LITERAL });
	      continue;
	    }

	    /**
	     * Dots
	     */

	    if (value === '.') {
	      if (state.braces > 0 && prev.type === 'dot') {
	        if (prev.value === '.') prev.output = DOT_LITERAL;
	        const brace = braces[braces.length - 1];
	        prev.type = 'dots';
	        prev.output += value;
	        prev.value += value;
	        brace.dots = true;
	        continue;
	      }

	      if ((state.braces + state.parens) === 0 && prev.type !== 'bos' && prev.type !== 'slash') {
	        push({ type: 'text', value, output: DOT_LITERAL });
	        continue;
	      }

	      push({ type: 'dot', value, output: DOT_LITERAL });
	      continue;
	    }

	    /**
	     * Question marks
	     */

	    if (value === '?') {
	      const isGroup = prev && prev.value === '(';
	      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
	        extglobOpen('qmark', value);
	        continue;
	      }

	      if (prev && prev.type === 'paren') {
	        const next = peek();
	        let output = value;

	        if (next === '<' && !utils.supportsLookbehinds()) {
	          throw new Error('Node.js v10 or higher is required for regex lookbehinds');
	        }

	        if ((prev.value === '(' && !/[!=<:]/.test(next)) || (next === '<' && !/<([!=]|\w+>)/.test(remaining()))) {
	          output = `\\${value}`;
	        }

	        push({ type: 'text', value, output });
	        continue;
	      }

	      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {
	        push({ type: 'qmark', value, output: QMARK_NO_DOT });
	        continue;
	      }

	      push({ type: 'qmark', value, output: QMARK });
	      continue;
	    }

	    /**
	     * Exclamation
	     */

	    if (value === '!') {
	      if (opts.noextglob !== true && peek() === '(') {
	        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {
	          extglobOpen('negate', value);
	          continue;
	        }
	      }

	      if (opts.nonegate !== true && state.index === 0) {
	        negate();
	        continue;
	      }
	    }

	    /**
	     * Plus
	     */

	    if (value === '+') {
	      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
	        extglobOpen('plus', value);
	        continue;
	      }

	      if ((prev && prev.value === '(') || opts.regex === false) {
	        push({ type: 'plus', value, output: PLUS_LITERAL });
	        continue;
	      }

	      if ((prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) || state.parens > 0) {
	        push({ type: 'plus', value });
	        continue;
	      }

	      push({ type: 'plus', value: PLUS_LITERAL });
	      continue;
	    }

	    /**
	     * Plain text
	     */

	    if (value === '@') {
	      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
	        push({ type: 'at', extglob: true, value, output: '' });
	        continue;
	      }

	      push({ type: 'text', value });
	      continue;
	    }

	    /**
	     * Plain text
	     */

	    if (value !== '*') {
	      if (value === '$' || value === '^') {
	        value = `\\${value}`;
	      }

	      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
	      if (match) {
	        value += match[0];
	        state.index += match[0].length;
	      }

	      push({ type: 'text', value });
	      continue;
	    }

	    /**
	     * Stars
	     */

	    if (prev && (prev.type === 'globstar' || prev.star === true)) {
	      prev.type = 'star';
	      prev.star = true;
	      prev.value += value;
	      prev.output = star;
	      state.backtrack = true;
	      state.globstar = true;
	      consume(value);
	      continue;
	    }

	    let rest = remaining();
	    if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
	      extglobOpen('star', value);
	      continue;
	    }

	    if (prev.type === 'star') {
	      if (opts.noglobstar === true) {
	        consume(value);
	        continue;
	      }

	      const prior = prev.prev;
	      const before = prior.prev;
	      const isStart = prior.type === 'slash' || prior.type === 'bos';
	      const afterStar = before && (before.type === 'star' || before.type === 'globstar');

	      if (opts.bash === true && (!isStart || (rest[0] && rest[0] !== '/'))) {
	        push({ type: 'star', value, output: '' });
	        continue;
	      }

	      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');
	      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');
	      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {
	        push({ type: 'star', value, output: '' });
	        continue;
	      }

	      // strip consecutive `/**/`
	      while (rest.slice(0, 3) === '/**') {
	        const after = input[state.index + 4];
	        if (after && after !== '/') {
	          break;
	        }
	        rest = rest.slice(3);
	        consume('/**', 3);
	      }

	      if (prior.type === 'bos' && eos()) {
	        prev.type = 'globstar';
	        prev.value += value;
	        prev.output = globstar(opts);
	        state.output = prev.output;
	        state.globstar = true;
	        consume(value);
	        continue;
	      }

	      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {
	        state.output = state.output.slice(0, -(prior.output + prev.output).length);
	        prior.output = `(?:${prior.output}`;

	        prev.type = 'globstar';
	        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');
	        prev.value += value;
	        state.globstar = true;
	        state.output += prior.output + prev.output;
	        consume(value);
	        continue;
	      }

	      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {
	        const end = rest[1] !== void 0 ? '|$' : '';

	        state.output = state.output.slice(0, -(prior.output + prev.output).length);
	        prior.output = `(?:${prior.output}`;

	        prev.type = 'globstar';
	        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
	        prev.value += value;

	        state.output += prior.output + prev.output;
	        state.globstar = true;

	        consume(value + advance());

	        push({ type: 'slash', value: '/', output: '' });
	        continue;
	      }

	      if (prior.type === 'bos' && rest[0] === '/') {
	        prev.type = 'globstar';
	        prev.value += value;
	        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
	        state.output = prev.output;
	        state.globstar = true;
	        consume(value + advance());
	        push({ type: 'slash', value: '/', output: '' });
	        continue;
	      }

	      // remove single star from output
	      state.output = state.output.slice(0, -prev.output.length);

	      // reset previous token to globstar
	      prev.type = 'globstar';
	      prev.output = globstar(opts);
	      prev.value += value;

	      // reset output with globstar
	      state.output += prev.output;
	      state.globstar = true;
	      consume(value);
	      continue;
	    }

	    const token = { type: 'star', value, output: star };

	    if (opts.bash === true) {
	      token.output = '.*?';
	      if (prev.type === 'bos' || prev.type === 'slash') {
	        token.output = nodot + token.output;
	      }
	      push(token);
	      continue;
	    }

	    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {
	      token.output = value;
	      push(token);
	      continue;
	    }

	    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {
	      if (prev.type === 'dot') {
	        state.output += NO_DOT_SLASH;
	        prev.output += NO_DOT_SLASH;

	      } else if (opts.dot === true) {
	        state.output += NO_DOTS_SLASH;
	        prev.output += NO_DOTS_SLASH;

	      } else {
	        state.output += nodot;
	        prev.output += nodot;
	      }

	      if (peek() !== '*') {
	        state.output += ONE_CHAR;
	        prev.output += ONE_CHAR;
	      }
	    }

	    push(token);
	  }

	  while (state.brackets > 0) {
	    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));
	    state.output = utils.escapeLast(state.output, '[');
	    decrement('brackets');
	  }

	  while (state.parens > 0) {
	    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));
	    state.output = utils.escapeLast(state.output, '(');
	    decrement('parens');
	  }

	  while (state.braces > 0) {
	    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));
	    state.output = utils.escapeLast(state.output, '{');
	    decrement('braces');
	  }

	  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {
	    push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });
	  }

	  // rebuild the output if we had to backtrack at any point
	  if (state.backtrack === true) {
	    state.output = '';

	    for (const token of state.tokens) {
	      state.output += token.output != null ? token.output : token.value;

	      if (token.suffix) {
	        state.output += token.suffix;
	      }
	    }
	  }

	  return state;
	};

	/**
	 * Fast paths for creating regular expressions for common glob patterns.
	 * This can significantly speed up processing and has very little downside
	 * impact when none of the fast paths match.
	 */

	parse.fastpaths = (input, options) => {
	  const opts = { ...options };
	  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
	  const len = input.length;
	  if (len > max) {
	    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
	  }

	  input = REPLACEMENTS[input] || input;
	  const win32 = utils.isWindows(options);

	  // create constants based on platform, for windows or posix
	  const {
	    DOT_LITERAL,
	    SLASH_LITERAL,
	    ONE_CHAR,
	    DOTS_SLASH,
	    NO_DOT,
	    NO_DOTS,
	    NO_DOTS_SLASH,
	    STAR,
	    START_ANCHOR
	  } = constants.globChars(win32);

	  const nodot = opts.dot ? NO_DOTS : NO_DOT;
	  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
	  const capture = opts.capture ? '' : '?:';
	  const state = { negated: false, prefix: '' };
	  let star = opts.bash === true ? '.*?' : STAR;

	  if (opts.capture) {
	    star = `(${star})`;
	  }

	  const globstar = opts => {
	    if (opts.noglobstar === true) return star;
	    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
	  };

	  const create = str => {
	    switch (str) {
	      case '*':
	        return `${nodot}${ONE_CHAR}${star}`;

	      case '.*':
	        return `${DOT_LITERAL}${ONE_CHAR}${star}`;

	      case '*.*':
	        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;

	      case '*/*':
	        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;

	      case '**':
	        return nodot + globstar(opts);

	      case '**/*':
	        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;

	      case '**/*.*':
	        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;

	      case '**/.*':
	        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;

	      default: {
	        const match = /^(.*?)\.(\w+)$/.exec(str);
	        if (!match) return;

	        const source = create(match[1]);
	        if (!source) return;

	        return source + DOT_LITERAL + match[2];
	      }
	    }
	  };

	  const output = utils.removePrefix(input, state);
	  let source = create(output);

	  if (source && opts.strictSlashes !== true) {
	    source += `${SLASH_LITERAL}?`;
	  }

	  return source;
	};

	parse_1$1 = parse;
	return parse_1$1;
}

var picomatch_1;
var hasRequiredPicomatch$1;

function requirePicomatch$1 () {
	if (hasRequiredPicomatch$1) return picomatch_1;
	hasRequiredPicomatch$1 = 1;

	const path = sysPath__default;
	const scan = requireScan();
	const parse = requireParse$1();
	const utils = requireUtils();
	const constants = requireConstants$1();
	const isObject = val => val && typeof val === 'object' && !Array.isArray(val);

	/**
	 * Creates a matcher function from one or more glob patterns. The
	 * returned function takes a string to match as its first argument,
	 * and returns true if the string is a match. The returned matcher
	 * function also takes a boolean as the second argument that, when true,
	 * returns an object with additional information.
	 *
	 * ```js
	 * const picomatch = require('picomatch');
	 * // picomatch(glob[, options]);
	 *
	 * const isMatch = picomatch('*.!(*a)');
	 * console.log(isMatch('a.a')); //=> false
	 * console.log(isMatch('a.b')); //=> true
	 * ```
	 * @name picomatch
	 * @param {String|Array} `globs` One or more glob patterns.
	 * @param {Object=} `options`
	 * @return {Function=} Returns a matcher function.
	 * @api public
	 */

	const picomatch = (glob, options, returnState = false) => {
	  if (Array.isArray(glob)) {
	    const fns = glob.map(input => picomatch(input, options, returnState));
	    const arrayMatcher = str => {
	      for (const isMatch of fns) {
	        const state = isMatch(str);
	        if (state) return state;
	      }
	      return false;
	    };
	    return arrayMatcher;
	  }

	  const isState = isObject(glob) && glob.tokens && glob.input;

	  if (glob === '' || (typeof glob !== 'string' && !isState)) {
	    throw new TypeError('Expected pattern to be a non-empty string');
	  }

	  const opts = options || {};
	  const posix = utils.isWindows(options);
	  const regex = isState
	    ? picomatch.compileRe(glob, options)
	    : picomatch.makeRe(glob, options, false, true);

	  const state = regex.state;
	  delete regex.state;

	  let isIgnored = () => false;
	  if (opts.ignore) {
	    const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
	    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
	  }

	  const matcher = (input, returnObject = false) => {
	    const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });
	    const result = { glob, state, regex, posix, input, output, match, isMatch };

	    if (typeof opts.onResult === 'function') {
	      opts.onResult(result);
	    }

	    if (isMatch === false) {
	      result.isMatch = false;
	      return returnObject ? result : false;
	    }

	    if (isIgnored(input)) {
	      if (typeof opts.onIgnore === 'function') {
	        opts.onIgnore(result);
	      }
	      result.isMatch = false;
	      return returnObject ? result : false;
	    }

	    if (typeof opts.onMatch === 'function') {
	      opts.onMatch(result);
	    }
	    return returnObject ? result : true;
	  };

	  if (returnState) {
	    matcher.state = state;
	  }

	  return matcher;
	};

	/**
	 * Test `input` with the given `regex`. This is used by the main
	 * `picomatch()` function to test the input string.
	 *
	 * ```js
	 * const picomatch = require('picomatch');
	 * // picomatch.test(input, regex[, options]);
	 *
	 * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\/([^/]*?))$/));
	 * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }
	 * ```
	 * @param {String} `input` String to test.
	 * @param {RegExp} `regex`
	 * @return {Object} Returns an object with matching info.
	 * @api public
	 */

	picomatch.test = (input, regex, options, { glob, posix } = {}) => {
	  if (typeof input !== 'string') {
	    throw new TypeError('Expected input to be a string');
	  }

	  if (input === '') {
	    return { isMatch: false, output: '' };
	  }

	  const opts = options || {};
	  const format = opts.format || (posix ? utils.toPosixSlashes : null);
	  let match = input === glob;
	  let output = (match && format) ? format(input) : input;

	  if (match === false) {
	    output = format ? format(input) : input;
	    match = output === glob;
	  }

	  if (match === false || opts.capture === true) {
	    if (opts.matchBase === true || opts.basename === true) {
	      match = picomatch.matchBase(input, regex, options, posix);
	    } else {
	      match = regex.exec(output);
	    }
	  }

	  return { isMatch: Boolean(match), match, output };
	};

	/**
	 * Match the basename of a filepath.
	 *
	 * ```js
	 * const picomatch = require('picomatch');
	 * // picomatch.matchBase(input, glob[, options]);
	 * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true
	 * ```
	 * @param {String} `input` String to test.
	 * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).
	 * @return {Boolean}
	 * @api public
	 */

	picomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {
	  const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
	  return regex.test(path.basename(input));
	};

	/**
	 * Returns true if **any** of the given glob `patterns` match the specified `string`.
	 *
	 * ```js
	 * const picomatch = require('picomatch');
	 * // picomatch.isMatch(string, patterns[, options]);
	 *
	 * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true
	 * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false
	 * ```
	 * @param {String|Array} str The string to test.
	 * @param {String|Array} patterns One or more glob patterns to use for matching.
	 * @param {Object} [options] See available [options](#options).
	 * @return {Boolean} Returns true if any patterns match `str`
	 * @api public
	 */

	picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);

	/**
	 * Parse a glob pattern to create the source string for a regular
	 * expression.
	 *
	 * ```js
	 * const picomatch = require('picomatch');
	 * const result = picomatch.parse(pattern[, options]);
	 * ```
	 * @param {String} `pattern`
	 * @param {Object} `options`
	 * @return {Object} Returns an object with useful properties and output to be used as a regex source string.
	 * @api public
	 */

	picomatch.parse = (pattern, options) => {
	  if (Array.isArray(pattern)) return pattern.map(p => picomatch.parse(p, options));
	  return parse(pattern, { ...options, fastpaths: false });
	};

	/**
	 * Scan a glob pattern to separate the pattern into segments.
	 *
	 * ```js
	 * const picomatch = require('picomatch');
	 * // picomatch.scan(input[, options]);
	 *
	 * const result = picomatch.scan('!./foo/*.js');
	 * console.log(result);
	 * { prefix: '!./',
	 *   input: '!./foo/*.js',
	 *   start: 3,
	 *   base: 'foo',
	 *   glob: '*.js',
	 *   isBrace: false,
	 *   isBracket: false,
	 *   isGlob: true,
	 *   isExtglob: false,
	 *   isGlobstar: false,
	 *   negated: true }
	 * ```
	 * @param {String} `input` Glob pattern to scan.
	 * @param {Object} `options`
	 * @return {Object} Returns an object with
	 * @api public
	 */

	picomatch.scan = (input, options) => scan(input, options);

	/**
	 * Compile a regular expression from the `state` object returned by the
	 * [parse()](#parse) method.
	 *
	 * @param {Object} `state`
	 * @param {Object} `options`
	 * @param {Boolean} `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.
	 * @param {Boolean} `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.
	 * @return {RegExp}
	 * @api public
	 */

	picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
	  if (returnOutput === true) {
	    return state.output;
	  }

	  const opts = options || {};
	  const prepend = opts.contains ? '' : '^';
	  const append = opts.contains ? '' : '$';

	  let source = `${prepend}(?:${state.output})${append}`;
	  if (state && state.negated === true) {
	    source = `^(?!${source}).*$`;
	  }

	  const regex = picomatch.toRegex(source, options);
	  if (returnState === true) {
	    regex.state = state;
	  }

	  return regex;
	};

	/**
	 * Create a regular expression from a parsed glob pattern.
	 *
	 * ```js
	 * const picomatch = require('picomatch');
	 * const state = picomatch.parse('*.js');
	 * // picomatch.compileRe(state[, options]);
	 *
	 * console.log(picomatch.compileRe(state));
	 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
	 * ```
	 * @param {String} `state` The object returned from the `.parse` method.
	 * @param {Object} `options`
	 * @param {Boolean} `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.
	 * @param {Boolean} `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.
	 * @return {RegExp} Returns a regex created from the given pattern.
	 * @api public
	 */

	picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
	  if (!input || typeof input !== 'string') {
	    throw new TypeError('Expected a non-empty string');
	  }

	  let parsed = { negated: false, fastpaths: true };

	  if (options.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {
	    parsed.output = parse.fastpaths(input, options);
	  }

	  if (!parsed.output) {
	    parsed = parse(input, options);
	  }

	  return picomatch.compileRe(parsed, options, returnOutput, returnState);
	};

	/**
	 * Create a regular expression from the given regex source string.
	 *
	 * ```js
	 * const picomatch = require('picomatch');
	 * // picomatch.toRegex(source[, options]);
	 *
	 * const { output } = picomatch.parse('*.js');
	 * console.log(picomatch.toRegex(output));
	 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
	 * ```
	 * @param {String} `source` Regular expression source string.
	 * @param {Object} `options`
	 * @return {RegExp}
	 * @api public
	 */

	picomatch.toRegex = (source, options) => {
	  try {
	    const opts = options || {};
	    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));
	  } catch (err) {
	    if (options && options.debug === true) throw err;
	    return /$^/;
	  }
	};

	/**
	 * Picomatch constants.
	 * @return {Object}
	 */

	picomatch.constants = constants;

	/**
	 * Expose "picomatch"
	 */

	picomatch_1 = picomatch;
	return picomatch_1;
}

var picomatch;
var hasRequiredPicomatch;

function requirePicomatch () {
	if (hasRequiredPicomatch) return picomatch;
	hasRequiredPicomatch = 1;

	picomatch = requirePicomatch$1();
	return picomatch;
}

/*!
 * normalize-path <https://github.com/jonschlinkert/normalize-path>
 *
 * Copyright (c) 2014-2018, Jon Schlinkert.
 * Released under the MIT License.
 */

var normalizePath;
var hasRequiredNormalizePath;

function requireNormalizePath () {
	if (hasRequiredNormalizePath) return normalizePath;
	hasRequiredNormalizePath = 1;
	normalizePath = function(path, stripTrailing) {
	  if (typeof path !== 'string') {
	    throw new TypeError('expected path to be a string');
	  }

	  if (path === '\\' || path === '/') return '/';

	  var len = path.length;
	  if (len <= 1) return path;

	  // ensure that win32 namespaces has two leading slashes, so that the path is
	  // handled properly by the win32 version of path.parse() after being normalized
	  // https://msdn.microsoft.com/library/windows/desktop/aa365247(v=vs.85).aspx#namespaces
	  var prefix = '';
	  if (len > 4 && path[3] === '\\') {
	    var ch = path[2];
	    if ((ch === '?' || ch === '.') && path.slice(0, 2) === '\\\\') {
	      path = path.slice(2);
	      prefix = '//';
	    }
	  }

	  var segs = path.split(/[/\\]+/);
	  if (stripTrailing !== false && segs[segs.length - 1] === '') {
	    segs.pop();
	  }
	  return prefix + segs.join('/');
	};
	return normalizePath;
}

var anymatch_1 = anymatch$1.exports;

var hasRequiredAnymatch;

function requireAnymatch () {
	if (hasRequiredAnymatch) return anymatch$1.exports;
	hasRequiredAnymatch = 1;

	Object.defineProperty(anymatch_1, "__esModule", { value: true });

	const picomatch = requirePicomatch();
	const normalizePath = requireNormalizePath();

	/**
	 * @typedef {(testString: string) => boolean} AnymatchFn
	 * @typedef {string|RegExp|AnymatchFn} AnymatchPattern
	 * @typedef {AnymatchPattern|AnymatchPattern[]} AnymatchMatcher
	 */
	const BANG = '!';
	const DEFAULT_OPTIONS = {returnIndex: false};
	const arrify = (item) => Array.isArray(item) ? item : [item];

	/**
	 * @param {AnymatchPattern} matcher
	 * @param {object} options
	 * @returns {AnymatchFn}
	 */
	const createPattern = (matcher, options) => {
	  if (typeof matcher === 'function') {
	    return matcher;
	  }
	  if (typeof matcher === 'string') {
	    const glob = picomatch(matcher, options);
	    return (string) => matcher === string || glob(string);
	  }
	  if (matcher instanceof RegExp) {
	    return (string) => matcher.test(string);
	  }
	  return (string) => false;
	};

	/**
	 * @param {Array<Function>} patterns
	 * @param {Array<Function>} negPatterns
	 * @param {String|Array} args
	 * @param {Boolean} returnIndex
	 * @returns {boolean|number}
	 */
	const matchPatterns = (patterns, negPatterns, args, returnIndex) => {
	  const isList = Array.isArray(args);
	  const _path = isList ? args[0] : args;
	  if (!isList && typeof _path !== 'string') {
	    throw new TypeError('anymatch: second argument must be a string: got ' +
	      Object.prototype.toString.call(_path))
	  }
	  const path = normalizePath(_path, false);

	  for (let index = 0; index < negPatterns.length; index++) {
	    const nglob = negPatterns[index];
	    if (nglob(path)) {
	      return returnIndex ? -1 : false;
	    }
	  }

	  const applied = isList && [path].concat(args.slice(1));
	  for (let index = 0; index < patterns.length; index++) {
	    const pattern = patterns[index];
	    if (isList ? pattern(...applied) : pattern(path)) {
	      return returnIndex ? index : true;
	    }
	  }

	  return returnIndex ? -1 : false;
	};

	/**
	 * @param {AnymatchMatcher} matchers
	 * @param {Array|string} testString
	 * @param {object} options
	 * @returns {boolean|number|Function}
	 */
	const anymatch = (matchers, testString, options = DEFAULT_OPTIONS) => {
	  if (matchers == null) {
	    throw new TypeError('anymatch: specify first argument');
	  }
	  const opts = typeof options === 'boolean' ? {returnIndex: options} : options;
	  const returnIndex = opts.returnIndex || false;

	  // Early cache for matchers.
	  const mtchers = arrify(matchers);
	  const negatedGlobs = mtchers
	    .filter(item => typeof item === 'string' && item.charAt(0) === BANG)
	    .map(item => item.slice(1))
	    .map(item => picomatch(item, opts));
	  const patterns = mtchers
	    .filter(item => typeof item !== 'string' || (typeof item === 'string' && item.charAt(0) !== BANG))
	    .map(matcher => createPattern(matcher, opts));

	  if (testString == null) {
	    return (testString, ri = false) => {
	      const returnIndex = typeof ri === 'boolean' ? ri : false;
	      return matchPatterns(patterns, negatedGlobs, testString, returnIndex);
	    }
	  }

	  return matchPatterns(patterns, negatedGlobs, testString, returnIndex);
	};

	anymatch.default = anymatch;
	anymatch$1.exports = anymatch;
	return anymatch$1.exports;
}

var anymatchExports = requireAnymatch();
const anymatch = /*@__PURE__*/getDefaultExportFromCjs(anymatchExports);

function defineDriver(factory) {
  return factory;
}
function createError(driver, message, opts) {
  const err = new Error(`[unstorage] [${driver}] ${message}`, opts);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(err, createError);
  }
  return err;
}
function createRequiredError(driver, name) {
  if (Array.isArray(name)) {
    return createError(
      driver,
      `Missing some of the required options ${name.map((n) => "`" + n + "`").join(", ")}`
    );
  }
  return createError(driver, `Missing required option \`${name}\`.`);
}

function ignoreNotfound(err) {
  return err.code === "ENOENT" || err.code === "EISDIR" ? null : err;
}
function ignoreExists(err) {
  return err.code === "EEXIST" ? null : err;
}
async function writeFile(path, data, encoding) {
  await ensuredir(dirname(path));
  return promises.writeFile(path, data, encoding);
}
function readFile(path, encoding) {
  return promises.readFile(path, encoding).catch(ignoreNotfound);
}
function unlink(path) {
  return promises.unlink(path).catch(ignoreNotfound);
}
function readdir(dir) {
  return promises.readdir(dir, { withFileTypes: true }).catch(ignoreNotfound).then((r) => r || []);
}
async function ensuredir(dir) {
  if (existsSync(dir)) {
    return;
  }
  await ensuredir(dirname(dir)).catch(ignoreExists);
  await promises.mkdir(dir).catch(ignoreExists);
}
async function readdirRecursive(dir, ignore, maxDepth) {
  if (ignore && ignore(dir)) {
    return [];
  }
  const entries = await readdir(dir);
  const files = [];
  await Promise.all(
    entries.map(async (entry) => {
      const entryPath = resolve(dir, entry.name);
      if (entry.isDirectory()) {
        if (maxDepth === void 0 || maxDepth > 0) {
          const dirFiles = await readdirRecursive(
            entryPath,
            ignore,
            maxDepth === void 0 ? void 0 : maxDepth - 1
          );
          files.push(...dirFiles.map((f) => entry.name + "/" + f));
        }
      } else {
        if (!(ignore && ignore(entry.name))) {
          files.push(entry.name);
        }
      }
    })
  );
  return files;
}
async function rmRecursive(dir) {
  const entries = await readdir(dir);
  await Promise.all(
    entries.map((entry) => {
      const entryPath = resolve(dir, entry.name);
      if (entry.isDirectory()) {
        return rmRecursive(entryPath).then(() => promises.rmdir(entryPath));
      } else {
        return promises.unlink(entryPath);
      }
    })
  );
}

const PATH_TRAVERSE_RE = /\.\.:|\.\.$/;
const DRIVER_NAME = "fs";
const fsDriver = defineDriver((userOptions = {}) => {
  if (!userOptions.base) {
    throw createRequiredError(DRIVER_NAME, "base");
  }
  const base = resolve(userOptions.base);
  const ignore = anymatch(
    userOptions.ignore || ["**/node_modules/**", "**/.git/**"]
  );
  const r = (key) => {
    if (PATH_TRAVERSE_RE.test(key)) {
      throw createError(
        DRIVER_NAME,
        `Invalid key: ${JSON.stringify(key)}. It should not contain .. segments`
      );
    }
    const resolved = join(base, key.replace(/:/g, "/"));
    return resolved;
  };
  let _watcher;
  const _unwatch = async () => {
    if (_watcher) {
      await _watcher.close();
      _watcher = void 0;
    }
  };
  return {
    name: DRIVER_NAME,
    options: userOptions,
    flags: {
      maxDepth: true
    },
    hasItem(key) {
      return existsSync(r(key));
    },
    getItem(key) {
      return readFile(r(key), "utf8");
    },
    getItemRaw(key) {
      return readFile(r(key));
    },
    async getMeta(key) {
      const { atime, mtime, size, birthtime, ctime } = await promises.stat(r(key)).catch(() => ({}));
      return { atime, mtime, size, birthtime, ctime };
    },
    setItem(key, value) {
      if (userOptions.readOnly) {
        return;
      }
      return writeFile(r(key), value, "utf8");
    },
    setItemRaw(key, value) {
      if (userOptions.readOnly) {
        return;
      }
      return writeFile(r(key), value);
    },
    removeItem(key) {
      if (userOptions.readOnly) {
        return;
      }
      return unlink(r(key));
    },
    getKeys(_base, topts) {
      return readdirRecursive(r("."), ignore, topts?.maxDepth);
    },
    async clear() {
      if (userOptions.readOnly || userOptions.noClear) {
        return;
      }
      await rmRecursive(r("."));
    },
    async dispose() {
      if (_watcher) {
        await _watcher.close();
      }
    },
    async watch(callback) {
      if (_watcher) {
        return _unwatch;
      }
      await new Promise((resolve2, reject) => {
        const watchOptions = {
          ignoreInitial: true,
          ...userOptions.watchOptions
        };
        if (!watchOptions.ignored) {
          watchOptions.ignored = [];
        } else if (Array.isArray(watchOptions.ignored)) {
          watchOptions.ignored = [...watchOptions.ignored];
        } else {
          watchOptions.ignored = [watchOptions.ignored];
        }
        watchOptions.ignored.push(ignore);
        _watcher = watch(base, watchOptions).on("ready", () => {
          resolve2();
        }).on("error", reject).on("all", (eventName, path) => {
          path = relative(base, path);
          if (eventName === "change" || eventName === "add") {
            callback("update", path);
          } else if (eventName === "unlink") {
            callback("remove", path);
          }
        });
      });
      return _unwatch;
    }
  };
});

const types$2 = {
    'application/prs.cww': ['cww'],
    'application/prs.xsf+xml': ['xsf'],
    'application/vnd.1000minds.decision-model+xml': ['1km'],
    'application/vnd.3gpp.pic-bw-large': ['plb'],
    'application/vnd.3gpp.pic-bw-small': ['psb'],
    'application/vnd.3gpp.pic-bw-var': ['pvb'],
    'application/vnd.3gpp2.tcap': ['tcap'],
    'application/vnd.3m.post-it-notes': ['pwn'],
    'application/vnd.accpac.simply.aso': ['aso'],
    'application/vnd.accpac.simply.imp': ['imp'],
    'application/vnd.acucobol': ['acu'],
    'application/vnd.acucorp': ['atc', 'acutc'],
    'application/vnd.adobe.air-application-installer-package+zip': ['air'],
    'application/vnd.adobe.formscentral.fcdt': ['fcdt'],
    'application/vnd.adobe.fxp': ['fxp', 'fxpl'],
    'application/vnd.adobe.xdp+xml': ['xdp'],
    'application/vnd.adobe.xfdf': ['*xfdf'],
    'application/vnd.age': ['age'],
    'application/vnd.ahead.space': ['ahead'],
    'application/vnd.airzip.filesecure.azf': ['azf'],
    'application/vnd.airzip.filesecure.azs': ['azs'],
    'application/vnd.amazon.ebook': ['azw'],
    'application/vnd.americandynamics.acc': ['acc'],
    'application/vnd.amiga.ami': ['ami'],
    'application/vnd.android.package-archive': ['apk'],
    'application/vnd.anser-web-certificate-issue-initiation': ['cii'],
    'application/vnd.anser-web-funds-transfer-initiation': ['fti'],
    'application/vnd.antix.game-component': ['atx'],
    'application/vnd.apple.installer+xml': ['mpkg'],
    'application/vnd.apple.keynote': ['key'],
    'application/vnd.apple.mpegurl': ['m3u8'],
    'application/vnd.apple.numbers': ['numbers'],
    'application/vnd.apple.pages': ['pages'],
    'application/vnd.apple.pkpass': ['pkpass'],
    'application/vnd.aristanetworks.swi': ['swi'],
    'application/vnd.astraea-software.iota': ['iota'],
    'application/vnd.audiograph': ['aep'],
    'application/vnd.autodesk.fbx': ['fbx'],
    'application/vnd.balsamiq.bmml+xml': ['bmml'],
    'application/vnd.blueice.multipass': ['mpm'],
    'application/vnd.bmi': ['bmi'],
    'application/vnd.businessobjects': ['rep'],
    'application/vnd.chemdraw+xml': ['cdxml'],
    'application/vnd.chipnuts.karaoke-mmd': ['mmd'],
    'application/vnd.cinderella': ['cdy'],
    'application/vnd.citationstyles.style+xml': ['csl'],
    'application/vnd.claymore': ['cla'],
    'application/vnd.cloanto.rp9': ['rp9'],
    'application/vnd.clonk.c4group': ['c4g', 'c4d', 'c4f', 'c4p', 'c4u'],
    'application/vnd.cluetrust.cartomobile-config': ['c11amc'],
    'application/vnd.cluetrust.cartomobile-config-pkg': ['c11amz'],
    'application/vnd.commonspace': ['csp'],
    'application/vnd.contact.cmsg': ['cdbcmsg'],
    'application/vnd.cosmocaller': ['cmc'],
    'application/vnd.crick.clicker': ['clkx'],
    'application/vnd.crick.clicker.keyboard': ['clkk'],
    'application/vnd.crick.clicker.palette': ['clkp'],
    'application/vnd.crick.clicker.template': ['clkt'],
    'application/vnd.crick.clicker.wordbank': ['clkw'],
    'application/vnd.criticaltools.wbs+xml': ['wbs'],
    'application/vnd.ctc-posml': ['pml'],
    'application/vnd.cups-ppd': ['ppd'],
    'application/vnd.curl.car': ['car'],
    'application/vnd.curl.pcurl': ['pcurl'],
    'application/vnd.dart': ['dart'],
    'application/vnd.data-vision.rdz': ['rdz'],
    'application/vnd.dbf': ['dbf'],
    'application/vnd.dcmp+xml': ['dcmp'],
    'application/vnd.dece.data': ['uvf', 'uvvf', 'uvd', 'uvvd'],
    'application/vnd.dece.ttml+xml': ['uvt', 'uvvt'],
    'application/vnd.dece.unspecified': ['uvx', 'uvvx'],
    'application/vnd.dece.zip': ['uvz', 'uvvz'],
    'application/vnd.denovo.fcselayout-link': ['fe_launch'],
    'application/vnd.dna': ['dna'],
    'application/vnd.dolby.mlp': ['mlp'],
    'application/vnd.dpgraph': ['dpg'],
    'application/vnd.dreamfactory': ['dfac'],
    'application/vnd.ds-keypoint': ['kpxx'],
    'application/vnd.dvb.ait': ['ait'],
    'application/vnd.dvb.service': ['svc'],
    'application/vnd.dynageo': ['geo'],
    'application/vnd.ecowin.chart': ['mag'],
    'application/vnd.enliven': ['nml'],
    'application/vnd.epson.esf': ['esf'],
    'application/vnd.epson.msf': ['msf'],
    'application/vnd.epson.quickanime': ['qam'],
    'application/vnd.epson.salt': ['slt'],
    'application/vnd.epson.ssf': ['ssf'],
    'application/vnd.eszigno3+xml': ['es3', 'et3'],
    'application/vnd.ezpix-album': ['ez2'],
    'application/vnd.ezpix-package': ['ez3'],
    'application/vnd.fdf': ['*fdf'],
    'application/vnd.fdsn.mseed': ['mseed'],
    'application/vnd.fdsn.seed': ['seed', 'dataless'],
    'application/vnd.flographit': ['gph'],
    'application/vnd.fluxtime.clip': ['ftc'],
    'application/vnd.framemaker': ['fm', 'frame', 'maker', 'book'],
    'application/vnd.frogans.fnc': ['fnc'],
    'application/vnd.frogans.ltf': ['ltf'],
    'application/vnd.fsc.weblaunch': ['fsc'],
    'application/vnd.fujitsu.oasys': ['oas'],
    'application/vnd.fujitsu.oasys2': ['oa2'],
    'application/vnd.fujitsu.oasys3': ['oa3'],
    'application/vnd.fujitsu.oasysgp': ['fg5'],
    'application/vnd.fujitsu.oasysprs': ['bh2'],
    'application/vnd.fujixerox.ddd': ['ddd'],
    'application/vnd.fujixerox.docuworks': ['xdw'],
    'application/vnd.fujixerox.docuworks.binder': ['xbd'],
    'application/vnd.fuzzysheet': ['fzs'],
    'application/vnd.genomatix.tuxedo': ['txd'],
    'application/vnd.geogebra.file': ['ggb'],
    'application/vnd.geogebra.slides': ['ggs'],
    'application/vnd.geogebra.tool': ['ggt'],
    'application/vnd.geometry-explorer': ['gex', 'gre'],
    'application/vnd.geonext': ['gxt'],
    'application/vnd.geoplan': ['g2w'],
    'application/vnd.geospace': ['g3w'],
    'application/vnd.gmx': ['gmx'],
    'application/vnd.google-apps.document': ['gdoc'],
    'application/vnd.google-apps.drawing': ['gdraw'],
    'application/vnd.google-apps.form': ['gform'],
    'application/vnd.google-apps.jam': ['gjam'],
    'application/vnd.google-apps.map': ['gmap'],
    'application/vnd.google-apps.presentation': ['gslides'],
    'application/vnd.google-apps.script': ['gscript'],
    'application/vnd.google-apps.site': ['gsite'],
    'application/vnd.google-apps.spreadsheet': ['gsheet'],
    'application/vnd.google-earth.kml+xml': ['kml'],
    'application/vnd.google-earth.kmz': ['kmz'],
    'application/vnd.gov.sk.xmldatacontainer+xml': ['xdcf'],
    'application/vnd.grafeq': ['gqf', 'gqs'],
    'application/vnd.groove-account': ['gac'],
    'application/vnd.groove-help': ['ghf'],
    'application/vnd.groove-identity-message': ['gim'],
    'application/vnd.groove-injector': ['grv'],
    'application/vnd.groove-tool-message': ['gtm'],
    'application/vnd.groove-tool-template': ['tpl'],
    'application/vnd.groove-vcard': ['vcg'],
    'application/vnd.hal+xml': ['hal'],
    'application/vnd.handheld-entertainment+xml': ['zmm'],
    'application/vnd.hbci': ['hbci'],
    'application/vnd.hhe.lesson-player': ['les'],
    'application/vnd.hp-hpgl': ['hpgl'],
    'application/vnd.hp-hpid': ['hpid'],
    'application/vnd.hp-hps': ['hps'],
    'application/vnd.hp-jlyt': ['jlt'],
    'application/vnd.hp-pcl': ['pcl'],
    'application/vnd.hp-pclxl': ['pclxl'],
    'application/vnd.hydrostatix.sof-data': ['sfd-hdstx'],
    'application/vnd.ibm.minipay': ['mpy'],
    'application/vnd.ibm.modcap': ['afp', 'listafp', 'list3820'],
    'application/vnd.ibm.rights-management': ['irm'],
    'application/vnd.ibm.secure-container': ['sc'],
    'application/vnd.iccprofile': ['icc', 'icm'],
    'application/vnd.igloader': ['igl'],
    'application/vnd.immervision-ivp': ['ivp'],
    'application/vnd.immervision-ivu': ['ivu'],
    'application/vnd.insors.igm': ['igm'],
    'application/vnd.intercon.formnet': ['xpw', 'xpx'],
    'application/vnd.intergeo': ['i2g'],
    'application/vnd.intu.qbo': ['qbo'],
    'application/vnd.intu.qfx': ['qfx'],
    'application/vnd.ipunplugged.rcprofile': ['rcprofile'],
    'application/vnd.irepository.package+xml': ['irp'],
    'application/vnd.is-xpr': ['xpr'],
    'application/vnd.isac.fcs': ['fcs'],
    'application/vnd.jam': ['jam'],
    'application/vnd.jcp.javame.midlet-rms': ['rms'],
    'application/vnd.jisp': ['jisp'],
    'application/vnd.joost.joda-archive': ['joda'],
    'application/vnd.kahootz': ['ktz', 'ktr'],
    'application/vnd.kde.karbon': ['karbon'],
    'application/vnd.kde.kchart': ['chrt'],
    'application/vnd.kde.kformula': ['kfo'],
    'application/vnd.kde.kivio': ['flw'],
    'application/vnd.kde.kontour': ['kon'],
    'application/vnd.kde.kpresenter': ['kpr', 'kpt'],
    'application/vnd.kde.kspread': ['ksp'],
    'application/vnd.kde.kword': ['kwd', 'kwt'],
    'application/vnd.kenameaapp': ['htke'],
    'application/vnd.kidspiration': ['kia'],
    'application/vnd.kinar': ['kne', 'knp'],
    'application/vnd.koan': ['skp', 'skd', 'skt', 'skm'],
    'application/vnd.kodak-descriptor': ['sse'],
    'application/vnd.las.las+xml': ['lasxml'],
    'application/vnd.llamagraphics.life-balance.desktop': ['lbd'],
    'application/vnd.llamagraphics.life-balance.exchange+xml': ['lbe'],
    'application/vnd.lotus-1-2-3': ['123'],
    'application/vnd.lotus-approach': ['apr'],
    'application/vnd.lotus-freelance': ['pre'],
    'application/vnd.lotus-notes': ['nsf'],
    'application/vnd.lotus-organizer': ['org'],
    'application/vnd.lotus-screencam': ['scm'],
    'application/vnd.lotus-wordpro': ['lwp'],
    'application/vnd.macports.portpkg': ['portpkg'],
    'application/vnd.mapbox-vector-tile': ['mvt'],
    'application/vnd.mcd': ['mcd'],
    'application/vnd.medcalcdata': ['mc1'],
    'application/vnd.mediastation.cdkey': ['cdkey'],
    'application/vnd.mfer': ['mwf'],
    'application/vnd.mfmp': ['mfm'],
    'application/vnd.micrografx.flo': ['flo'],
    'application/vnd.micrografx.igx': ['igx'],
    'application/vnd.mif': ['mif'],
    'application/vnd.mobius.daf': ['daf'],
    'application/vnd.mobius.dis': ['dis'],
    'application/vnd.mobius.mbk': ['mbk'],
    'application/vnd.mobius.mqy': ['mqy'],
    'application/vnd.mobius.msl': ['msl'],
    'application/vnd.mobius.plc': ['plc'],
    'application/vnd.mobius.txf': ['txf'],
    'application/vnd.mophun.application': ['mpn'],
    'application/vnd.mophun.certificate': ['mpc'],
    'application/vnd.mozilla.xul+xml': ['xul'],
    'application/vnd.ms-artgalry': ['cil'],
    'application/vnd.ms-cab-compressed': ['cab'],
    'application/vnd.ms-excel': ['xls', 'xlm', 'xla', 'xlc', 'xlt', 'xlw'],
    'application/vnd.ms-excel.addin.macroenabled.12': ['xlam'],
    'application/vnd.ms-excel.sheet.binary.macroenabled.12': ['xlsb'],
    'application/vnd.ms-excel.sheet.macroenabled.12': ['xlsm'],
    'application/vnd.ms-excel.template.macroenabled.12': ['xltm'],
    'application/vnd.ms-fontobject': ['eot'],
    'application/vnd.ms-htmlhelp': ['chm'],
    'application/vnd.ms-ims': ['ims'],
    'application/vnd.ms-lrm': ['lrm'],
    'application/vnd.ms-officetheme': ['thmx'],
    'application/vnd.ms-outlook': ['msg'],
    'application/vnd.ms-pki.seccat': ['cat'],
    'application/vnd.ms-pki.stl': ['*stl'],
    'application/vnd.ms-powerpoint': ['ppt', 'pps', 'pot'],
    'application/vnd.ms-powerpoint.addin.macroenabled.12': ['ppam'],
    'application/vnd.ms-powerpoint.presentation.macroenabled.12': ['pptm'],
    'application/vnd.ms-powerpoint.slide.macroenabled.12': ['sldm'],
    'application/vnd.ms-powerpoint.slideshow.macroenabled.12': ['ppsm'],
    'application/vnd.ms-powerpoint.template.macroenabled.12': ['potm'],
    'application/vnd.ms-project': ['*mpp', 'mpt'],
    'application/vnd.ms-visio.viewer': ['vdx'],
    'application/vnd.ms-word.document.macroenabled.12': ['docm'],
    'application/vnd.ms-word.template.macroenabled.12': ['dotm'],
    'application/vnd.ms-works': ['wps', 'wks', 'wcm', 'wdb'],
    'application/vnd.ms-wpl': ['wpl'],
    'application/vnd.ms-xpsdocument': ['xps'],
    'application/vnd.mseq': ['mseq'],
    'application/vnd.musician': ['mus'],
    'application/vnd.muvee.style': ['msty'],
    'application/vnd.mynfc': ['taglet'],
    'application/vnd.nato.bindingdataobject+xml': ['bdo'],
    'application/vnd.neurolanguage.nlu': ['nlu'],
    'application/vnd.nitf': ['ntf', 'nitf'],
    'application/vnd.noblenet-directory': ['nnd'],
    'application/vnd.noblenet-sealer': ['nns'],
    'application/vnd.noblenet-web': ['nnw'],
    'application/vnd.nokia.n-gage.ac+xml': ['*ac'],
    'application/vnd.nokia.n-gage.data': ['ngdat'],
    'application/vnd.nokia.n-gage.symbian.install': ['n-gage'],
    'application/vnd.nokia.radio-preset': ['rpst'],
    'application/vnd.nokia.radio-presets': ['rpss'],
    'application/vnd.novadigm.edm': ['edm'],
    'application/vnd.novadigm.edx': ['edx'],
    'application/vnd.novadigm.ext': ['ext'],
    'application/vnd.oasis.opendocument.chart': ['odc'],
    'application/vnd.oasis.opendocument.chart-template': ['otc'],
    'application/vnd.oasis.opendocument.database': ['odb'],
    'application/vnd.oasis.opendocument.formula': ['odf'],
    'application/vnd.oasis.opendocument.formula-template': ['odft'],
    'application/vnd.oasis.opendocument.graphics': ['odg'],
    'application/vnd.oasis.opendocument.graphics-template': ['otg'],
    'application/vnd.oasis.opendocument.image': ['odi'],
    'application/vnd.oasis.opendocument.image-template': ['oti'],
    'application/vnd.oasis.opendocument.presentation': ['odp'],
    'application/vnd.oasis.opendocument.presentation-template': ['otp'],
    'application/vnd.oasis.opendocument.spreadsheet': ['ods'],
    'application/vnd.oasis.opendocument.spreadsheet-template': ['ots'],
    'application/vnd.oasis.opendocument.text': ['odt'],
    'application/vnd.oasis.opendocument.text-master': ['odm'],
    'application/vnd.oasis.opendocument.text-template': ['ott'],
    'application/vnd.oasis.opendocument.text-web': ['oth'],
    'application/vnd.olpc-sugar': ['xo'],
    'application/vnd.oma.dd2+xml': ['dd2'],
    'application/vnd.openblox.game+xml': ['obgx'],
    'application/vnd.openofficeorg.extension': ['oxt'],
    'application/vnd.openstreetmap.data+xml': ['osm'],
    'application/vnd.openxmlformats-officedocument.presentationml.presentation': [
        'pptx',
    ],
    'application/vnd.openxmlformats-officedocument.presentationml.slide': [
        'sldx',
    ],
    'application/vnd.openxmlformats-officedocument.presentationml.slideshow': [
        'ppsx',
    ],
    'application/vnd.openxmlformats-officedocument.presentationml.template': [
        'potx',
    ],
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': ['xlsx'],
    'application/vnd.openxmlformats-officedocument.spreadsheetml.template': [
        'xltx',
    ],
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document': [
        'docx',
    ],
    'application/vnd.openxmlformats-officedocument.wordprocessingml.template': [
        'dotx',
    ],
    'application/vnd.osgeo.mapguide.package': ['mgp'],
    'application/vnd.osgi.dp': ['dp'],
    'application/vnd.osgi.subsystem': ['esa'],
    'application/vnd.palm': ['pdb', 'pqa', 'oprc'],
    'application/vnd.pawaafile': ['paw'],
    'application/vnd.pg.format': ['str'],
    'application/vnd.pg.osasli': ['ei6'],
    'application/vnd.picsel': ['efif'],
    'application/vnd.pmi.widget': ['wg'],
    'application/vnd.pocketlearn': ['plf'],
    'application/vnd.powerbuilder6': ['pbd'],
    'application/vnd.previewsystems.box': ['box'],
    'application/vnd.procrate.brushset': ['brushset'],
    'application/vnd.procreate.brush': ['brush'],
    'application/vnd.procreate.dream': ['drm'],
    'application/vnd.proteus.magazine': ['mgz'],
    'application/vnd.publishare-delta-tree': ['qps'],
    'application/vnd.pvi.ptid1': ['ptid'],
    'application/vnd.pwg-xhtml-print+xml': ['xhtm'],
    'application/vnd.quark.quarkxpress': [
        'qxd',
        'qxt',
        'qwd',
        'qwt',
        'qxl',
        'qxb',
    ],
    'application/vnd.rar': ['rar'],
    'application/vnd.realvnc.bed': ['bed'],
    'application/vnd.recordare.musicxml': ['mxl'],
    'application/vnd.recordare.musicxml+xml': ['musicxml'],
    'application/vnd.rig.cryptonote': ['cryptonote'],
    'application/vnd.rim.cod': ['cod'],
    'application/vnd.rn-realmedia': ['rm'],
    'application/vnd.rn-realmedia-vbr': ['rmvb'],
    'application/vnd.route66.link66+xml': ['link66'],
    'application/vnd.sailingtracker.track': ['st'],
    'application/vnd.seemail': ['see'],
    'application/vnd.sema': ['sema'],
    'application/vnd.semd': ['semd'],
    'application/vnd.semf': ['semf'],
    'application/vnd.shana.informed.formdata': ['ifm'],
    'application/vnd.shana.informed.formtemplate': ['itp'],
    'application/vnd.shana.informed.interchange': ['iif'],
    'application/vnd.shana.informed.package': ['ipk'],
    'application/vnd.simtech-mindmapper': ['twd', 'twds'],
    'application/vnd.smaf': ['mmf'],
    'application/vnd.smart.teacher': ['teacher'],
    'application/vnd.software602.filler.form+xml': ['fo'],
    'application/vnd.solent.sdkm+xml': ['sdkm', 'sdkd'],
    'application/vnd.spotfire.dxp': ['dxp'],
    'application/vnd.spotfire.sfs': ['sfs'],
    'application/vnd.stardivision.calc': ['sdc'],
    'application/vnd.stardivision.draw': ['sda'],
    'application/vnd.stardivision.impress': ['sdd'],
    'application/vnd.stardivision.math': ['smf'],
    'application/vnd.stardivision.writer': ['sdw', 'vor'],
    'application/vnd.stardivision.writer-global': ['sgl'],
    'application/vnd.stepmania.package': ['smzip'],
    'application/vnd.stepmania.stepchart': ['sm'],
    'application/vnd.sun.wadl+xml': ['wadl'],
    'application/vnd.sun.xml.calc': ['sxc'],
    'application/vnd.sun.xml.calc.template': ['stc'],
    'application/vnd.sun.xml.draw': ['sxd'],
    'application/vnd.sun.xml.draw.template': ['std'],
    'application/vnd.sun.xml.impress': ['sxi'],
    'application/vnd.sun.xml.impress.template': ['sti'],
    'application/vnd.sun.xml.math': ['sxm'],
    'application/vnd.sun.xml.writer': ['sxw'],
    'application/vnd.sun.xml.writer.global': ['sxg'],
    'application/vnd.sun.xml.writer.template': ['stw'],
    'application/vnd.sus-calendar': ['sus', 'susp'],
    'application/vnd.svd': ['svd'],
    'application/vnd.symbian.install': ['sis', 'sisx'],
    'application/vnd.syncml+xml': ['xsm'],
    'application/vnd.syncml.dm+wbxml': ['bdm'],
    'application/vnd.syncml.dm+xml': ['xdm'],
    'application/vnd.syncml.dmddf+xml': ['ddf'],
    'application/vnd.tao.intent-module-archive': ['tao'],
    'application/vnd.tcpdump.pcap': ['pcap', 'cap', 'dmp'],
    'application/vnd.tmobile-livetv': ['tmo'],
    'application/vnd.trid.tpt': ['tpt'],
    'application/vnd.triscape.mxs': ['mxs'],
    'application/vnd.trueapp': ['tra'],
    'application/vnd.ufdl': ['ufd', 'ufdl'],
    'application/vnd.uiq.theme': ['utz'],
    'application/vnd.umajin': ['umj'],
    'application/vnd.unity': ['unityweb'],
    'application/vnd.uoml+xml': ['uoml', 'uo'],
    'application/vnd.vcx': ['vcx'],
    'application/vnd.visio': ['vsd', 'vst', 'vss', 'vsw', 'vsdx', 'vtx'],
    'application/vnd.visionary': ['vis'],
    'application/vnd.vsf': ['vsf'],
    'application/vnd.wap.wbxml': ['wbxml'],
    'application/vnd.wap.wmlc': ['wmlc'],
    'application/vnd.wap.wmlscriptc': ['wmlsc'],
    'application/vnd.webturbo': ['wtb'],
    'application/vnd.wolfram.player': ['nbp'],
    'application/vnd.wordperfect': ['wpd'],
    'application/vnd.wqd': ['wqd'],
    'application/vnd.wt.stf': ['stf'],
    'application/vnd.xara': ['xar'],
    'application/vnd.xfdl': ['xfdl'],
    'application/vnd.yamaha.hv-dic': ['hvd'],
    'application/vnd.yamaha.hv-script': ['hvs'],
    'application/vnd.yamaha.hv-voice': ['hvp'],
    'application/vnd.yamaha.openscoreformat': ['osf'],
    'application/vnd.yamaha.openscoreformat.osfpvg+xml': ['osfpvg'],
    'application/vnd.yamaha.smaf-audio': ['saf'],
    'application/vnd.yamaha.smaf-phrase': ['spf'],
    'application/vnd.yellowriver-custom-menu': ['cmp'],
    'application/vnd.zul': ['zir', 'zirz'],
    'application/vnd.zzazz.deck+xml': ['zaz'],
    'application/x-7z-compressed': ['7z'],
    'application/x-abiword': ['abw'],
    'application/x-ace-compressed': ['ace'],
    'application/x-apple-diskimage': ['*dmg'],
    'application/x-arj': ['arj'],
    'application/x-authorware-bin': ['aab', 'x32', 'u32', 'vox'],
    'application/x-authorware-map': ['aam'],
    'application/x-authorware-seg': ['aas'],
    'application/x-bcpio': ['bcpio'],
    'application/x-bdoc': ['*bdoc'],
    'application/x-bittorrent': ['torrent'],
    'application/x-blender': ['blend'],
    'application/x-blorb': ['blb', 'blorb'],
    'application/x-bzip': ['bz'],
    'application/x-bzip2': ['bz2', 'boz'],
    'application/x-cbr': ['cbr', 'cba', 'cbt', 'cbz', 'cb7'],
    'application/x-cdlink': ['vcd'],
    'application/x-cfs-compressed': ['cfs'],
    'application/x-chat': ['chat'],
    'application/x-chess-pgn': ['pgn'],
    'application/x-chrome-extension': ['crx'],
    'application/x-cocoa': ['cco'],
    'application/x-compressed': ['*rar'],
    'application/x-conference': ['nsc'],
    'application/x-cpio': ['cpio'],
    'application/x-csh': ['csh'],
    'application/x-debian-package': ['*deb', 'udeb'],
    'application/x-dgc-compressed': ['dgc'],
    'application/x-director': [
        'dir',
        'dcr',
        'dxr',
        'cst',
        'cct',
        'cxt',
        'w3d',
        'fgd',
        'swa',
    ],
    'application/x-doom': ['wad'],
    'application/x-dtbncx+xml': ['ncx'],
    'application/x-dtbook+xml': ['dtb'],
    'application/x-dtbresource+xml': ['res'],
    'application/x-dvi': ['dvi'],
    'application/x-envoy': ['evy'],
    'application/x-eva': ['eva'],
    'application/x-font-bdf': ['bdf'],
    'application/x-font-ghostscript': ['gsf'],
    'application/x-font-linux-psf': ['psf'],
    'application/x-font-pcf': ['pcf'],
    'application/x-font-snf': ['snf'],
    'application/x-font-type1': ['pfa', 'pfb', 'pfm', 'afm'],
    'application/x-freearc': ['arc'],
    'application/x-futuresplash': ['spl'],
    'application/x-gca-compressed': ['gca'],
    'application/x-glulx': ['ulx'],
    'application/x-gnumeric': ['gnumeric'],
    'application/x-gramps-xml': ['gramps'],
    'application/x-gtar': ['gtar'],
    'application/x-hdf': ['hdf'],
    'application/x-httpd-php': ['php'],
    'application/x-install-instructions': ['install'],
    'application/x-ipynb+json': ['ipynb'],
    'application/x-iso9660-image': ['*iso'],
    'application/x-iwork-keynote-sffkey': ['*key'],
    'application/x-iwork-numbers-sffnumbers': ['*numbers'],
    'application/x-iwork-pages-sffpages': ['*pages'],
    'application/x-java-archive-diff': ['jardiff'],
    'application/x-java-jnlp-file': ['jnlp'],
    'application/x-keepass2': ['kdbx'],
    'application/x-latex': ['latex'],
    'application/x-lua-bytecode': ['luac'],
    'application/x-lzh-compressed': ['lzh', 'lha'],
    'application/x-makeself': ['run'],
    'application/x-mie': ['mie'],
    'application/x-mobipocket-ebook': ['*prc', 'mobi'],
    'application/x-ms-application': ['application'],
    'application/x-ms-shortcut': ['lnk'],
    'application/x-ms-wmd': ['wmd'],
    'application/x-ms-wmz': ['wmz'],
    'application/x-ms-xbap': ['xbap'],
    'application/x-msaccess': ['mdb'],
    'application/x-msbinder': ['obd'],
    'application/x-mscardfile': ['crd'],
    'application/x-msclip': ['clp'],
    'application/x-msdos-program': ['*exe'],
    'application/x-msdownload': ['*exe', '*dll', 'com', 'bat', '*msi'],
    'application/x-msmediaview': ['mvb', 'm13', 'm14'],
    'application/x-msmetafile': ['*wmf', '*wmz', '*emf', 'emz'],
    'application/x-msmoney': ['mny'],
    'application/x-mspublisher': ['pub'],
    'application/x-msschedule': ['scd'],
    'application/x-msterminal': ['trm'],
    'application/x-mswrite': ['wri'],
    'application/x-netcdf': ['nc', 'cdf'],
    'application/x-ns-proxy-autoconfig': ['pac'],
    'application/x-nzb': ['nzb'],
    'application/x-perl': ['pl', 'pm'],
    'application/x-pilot': ['*prc', '*pdb'],
    'application/x-pkcs12': ['p12', 'pfx'],
    'application/x-pkcs7-certificates': ['p7b', 'spc'],
    'application/x-pkcs7-certreqresp': ['p7r'],
    'application/x-rar-compressed': ['*rar'],
    'application/x-redhat-package-manager': ['rpm'],
    'application/x-research-info-systems': ['ris'],
    'application/x-sea': ['sea'],
    'application/x-sh': ['sh'],
    'application/x-shar': ['shar'],
    'application/x-shockwave-flash': ['swf'],
    'application/x-silverlight-app': ['xap'],
    'application/x-sql': ['*sql'],
    'application/x-stuffit': ['sit'],
    'application/x-stuffitx': ['sitx'],
    'application/x-subrip': ['srt'],
    'application/x-sv4cpio': ['sv4cpio'],
    'application/x-sv4crc': ['sv4crc'],
    'application/x-t3vm-image': ['t3'],
    'application/x-tads': ['gam'],
    'application/x-tar': ['tar'],
    'application/x-tcl': ['tcl', 'tk'],
    'application/x-tex': ['tex'],
    'application/x-tex-tfm': ['tfm'],
    'application/x-texinfo': ['texinfo', 'texi'],
    'application/x-tgif': ['*obj'],
    'application/x-ustar': ['ustar'],
    'application/x-virtualbox-hdd': ['hdd'],
    'application/x-virtualbox-ova': ['ova'],
    'application/x-virtualbox-ovf': ['ovf'],
    'application/x-virtualbox-vbox': ['vbox'],
    'application/x-virtualbox-vbox-extpack': ['vbox-extpack'],
    'application/x-virtualbox-vdi': ['vdi'],
    'application/x-virtualbox-vhd': ['vhd'],
    'application/x-virtualbox-vmdk': ['vmdk'],
    'application/x-wais-source': ['src'],
    'application/x-web-app-manifest+json': ['webapp'],
    'application/x-x509-ca-cert': ['der', 'crt', 'pem'],
    'application/x-xfig': ['fig'],
    'application/x-xliff+xml': ['*xlf'],
    'application/x-xpinstall': ['xpi'],
    'application/x-xz': ['xz'],
    'application/x-zip-compressed': ['*zip'],
    'application/x-zmachine': ['z1', 'z2', 'z3', 'z4', 'z5', 'z6', 'z7', 'z8'],
    'audio/vnd.dece.audio': ['uva', 'uvva'],
    'audio/vnd.digital-winds': ['eol'],
    'audio/vnd.dra': ['dra'],
    'audio/vnd.dts': ['dts'],
    'audio/vnd.dts.hd': ['dtshd'],
    'audio/vnd.lucent.voice': ['lvp'],
    'audio/vnd.ms-playready.media.pya': ['pya'],
    'audio/vnd.nuera.ecelp4800': ['ecelp4800'],
    'audio/vnd.nuera.ecelp7470': ['ecelp7470'],
    'audio/vnd.nuera.ecelp9600': ['ecelp9600'],
    'audio/vnd.rip': ['rip'],
    'audio/x-aac': ['*aac'],
    'audio/x-aiff': ['aif', 'aiff', 'aifc'],
    'audio/x-caf': ['caf'],
    'audio/x-flac': ['flac'],
    'audio/x-m4a': ['*m4a'],
    'audio/x-matroska': ['mka'],
    'audio/x-mpegurl': ['m3u'],
    'audio/x-ms-wax': ['wax'],
    'audio/x-ms-wma': ['wma'],
    'audio/x-pn-realaudio': ['ram', 'ra'],
    'audio/x-pn-realaudio-plugin': ['rmp'],
    'audio/x-realaudio': ['*ra'],
    'audio/x-wav': ['*wav'],
    'chemical/x-cdx': ['cdx'],
    'chemical/x-cif': ['cif'],
    'chemical/x-cmdf': ['cmdf'],
    'chemical/x-cml': ['cml'],
    'chemical/x-csml': ['csml'],
    'chemical/x-xyz': ['xyz'],
    'image/prs.btif': ['btif', 'btf'],
    'image/prs.pti': ['pti'],
    'image/vnd.adobe.photoshop': ['psd'],
    'image/vnd.airzip.accelerator.azv': ['azv'],
    'image/vnd.dece.graphic': ['uvi', 'uvvi', 'uvg', 'uvvg'],
    'image/vnd.djvu': ['djvu', 'djv'],
    'image/vnd.dvb.subtitle': ['*sub'],
    'image/vnd.dwg': ['dwg'],
    'image/vnd.dxf': ['dxf'],
    'image/vnd.fastbidsheet': ['fbs'],
    'image/vnd.fpx': ['fpx'],
    'image/vnd.fst': ['fst'],
    'image/vnd.fujixerox.edmics-mmr': ['mmr'],
    'image/vnd.fujixerox.edmics-rlc': ['rlc'],
    'image/vnd.microsoft.icon': ['ico'],
    'image/vnd.ms-dds': ['dds'],
    'image/vnd.ms-modi': ['mdi'],
    'image/vnd.ms-photo': ['wdp'],
    'image/vnd.net-fpx': ['npx'],
    'image/vnd.pco.b16': ['b16'],
    'image/vnd.tencent.tap': ['tap'],
    'image/vnd.valve.source.texture': ['vtf'],
    'image/vnd.wap.wbmp': ['wbmp'],
    'image/vnd.xiff': ['xif'],
    'image/vnd.zbrush.pcx': ['pcx'],
    'image/x-3ds': ['3ds'],
    'image/x-adobe-dng': ['dng'],
    'image/x-cmu-raster': ['ras'],
    'image/x-cmx': ['cmx'],
    'image/x-freehand': ['fh', 'fhc', 'fh4', 'fh5', 'fh7'],
    'image/x-icon': ['*ico'],
    'image/x-jng': ['jng'],
    'image/x-mrsid-image': ['sid'],
    'image/x-ms-bmp': ['*bmp'],
    'image/x-pcx': ['*pcx'],
    'image/x-pict': ['pic', 'pct'],
    'image/x-portable-anymap': ['pnm'],
    'image/x-portable-bitmap': ['pbm'],
    'image/x-portable-graymap': ['pgm'],
    'image/x-portable-pixmap': ['ppm'],
    'image/x-rgb': ['rgb'],
    'image/x-tga': ['tga'],
    'image/x-xbitmap': ['xbm'],
    'image/x-xpixmap': ['xpm'],
    'image/x-xwindowdump': ['xwd'],
    'message/vnd.wfa.wsc': ['wsc'],
    'model/vnd.bary': ['bary'],
    'model/vnd.cld': ['cld'],
    'model/vnd.collada+xml': ['dae'],
    'model/vnd.dwf': ['dwf'],
    'model/vnd.gdl': ['gdl'],
    'model/vnd.gtw': ['gtw'],
    'model/vnd.mts': ['*mts'],
    'model/vnd.opengex': ['ogex'],
    'model/vnd.parasolid.transmit.binary': ['x_b'],
    'model/vnd.parasolid.transmit.text': ['x_t'],
    'model/vnd.pytha.pyox': ['pyo', 'pyox'],
    'model/vnd.sap.vds': ['vds'],
    'model/vnd.usda': ['usda'],
    'model/vnd.usdz+zip': ['usdz'],
    'model/vnd.valve.source.compiled-map': ['bsp'],
    'model/vnd.vtu': ['vtu'],
    'text/prs.lines.tag': ['dsc'],
    'text/vnd.curl': ['curl'],
    'text/vnd.curl.dcurl': ['dcurl'],
    'text/vnd.curl.mcurl': ['mcurl'],
    'text/vnd.curl.scurl': ['scurl'],
    'text/vnd.dvb.subtitle': ['sub'],
    'text/vnd.familysearch.gedcom': ['ged'],
    'text/vnd.fly': ['fly'],
    'text/vnd.fmi.flexstor': ['flx'],
    'text/vnd.graphviz': ['gv'],
    'text/vnd.in3d.3dml': ['3dml'],
    'text/vnd.in3d.spot': ['spot'],
    'text/vnd.sun.j2me.app-descriptor': ['jad'],
    'text/vnd.wap.wml': ['wml'],
    'text/vnd.wap.wmlscript': ['wmls'],
    'text/x-asm': ['s', 'asm'],
    'text/x-c': ['c', 'cc', 'cxx', 'cpp', 'h', 'hh', 'dic'],
    'text/x-component': ['htc'],
    'text/x-fortran': ['f', 'for', 'f77', 'f90'],
    'text/x-handlebars-template': ['hbs'],
    'text/x-java-source': ['java'],
    'text/x-lua': ['lua'],
    'text/x-markdown': ['mkd'],
    'text/x-nfo': ['nfo'],
    'text/x-opml': ['opml'],
    'text/x-org': ['*org'],
    'text/x-pascal': ['p', 'pas'],
    'text/x-processing': ['pde'],
    'text/x-sass': ['sass'],
    'text/x-scss': ['scss'],
    'text/x-setext': ['etx'],
    'text/x-sfv': ['sfv'],
    'text/x-suse-ymp': ['ymp'],
    'text/x-uuencode': ['uu'],
    'text/x-vcalendar': ['vcs'],
    'text/x-vcard': ['vcf'],
    'video/vnd.dece.hd': ['uvh', 'uvvh'],
    'video/vnd.dece.mobile': ['uvm', 'uvvm'],
    'video/vnd.dece.pd': ['uvp', 'uvvp'],
    'video/vnd.dece.sd': ['uvs', 'uvvs'],
    'video/vnd.dece.video': ['uvv', 'uvvv'],
    'video/vnd.dvb.file': ['dvb'],
    'video/vnd.fvt': ['fvt'],
    'video/vnd.mpegurl': ['mxu', 'm4u'],
    'video/vnd.ms-playready.media.pyv': ['pyv'],
    'video/vnd.uvvu.mp4': ['uvu', 'uvvu'],
    'video/vnd.vivo': ['viv'],
    'video/x-f4v': ['f4v'],
    'video/x-fli': ['fli'],
    'video/x-flv': ['flv'],
    'video/x-m4v': ['m4v'],
    'video/x-matroska': ['mkv', 'mk3d', 'mks'],
    'video/x-mng': ['mng'],
    'video/x-ms-asf': ['asf', 'asx'],
    'video/x-ms-vob': ['vob'],
    'video/x-ms-wm': ['wm'],
    'video/x-ms-wmv': ['wmv'],
    'video/x-ms-wmx': ['wmx'],
    'video/x-ms-wvx': ['wvx'],
    'video/x-msvideo': ['avi'],
    'video/x-sgi-movie': ['movie'],
    'video/x-smv': ['smv'],
    'x-conference/x-cooltalk': ['ice'],
};
Object.freeze(types$2);

const types$1 = {
    'application/andrew-inset': ['ez'],
    'application/appinstaller': ['appinstaller'],
    'application/applixware': ['aw'],
    'application/appx': ['appx'],
    'application/appxbundle': ['appxbundle'],
    'application/atom+xml': ['atom'],
    'application/atomcat+xml': ['atomcat'],
    'application/atomdeleted+xml': ['atomdeleted'],
    'application/atomsvc+xml': ['atomsvc'],
    'application/atsc-dwd+xml': ['dwd'],
    'application/atsc-held+xml': ['held'],
    'application/atsc-rsat+xml': ['rsat'],
    'application/automationml-aml+xml': ['aml'],
    'application/automationml-amlx+zip': ['amlx'],
    'application/bdoc': ['bdoc'],
    'application/calendar+xml': ['xcs'],
    'application/ccxml+xml': ['ccxml'],
    'application/cdfx+xml': ['cdfx'],
    'application/cdmi-capability': ['cdmia'],
    'application/cdmi-container': ['cdmic'],
    'application/cdmi-domain': ['cdmid'],
    'application/cdmi-object': ['cdmio'],
    'application/cdmi-queue': ['cdmiq'],
    'application/cpl+xml': ['cpl'],
    'application/cu-seeme': ['cu'],
    'application/cwl': ['cwl'],
    'application/dash+xml': ['mpd'],
    'application/dash-patch+xml': ['mpp'],
    'application/davmount+xml': ['davmount'],
    'application/dicom': ['dcm'],
    'application/docbook+xml': ['dbk'],
    'application/dssc+der': ['dssc'],
    'application/dssc+xml': ['xdssc'],
    'application/ecmascript': ['ecma'],
    'application/emma+xml': ['emma'],
    'application/emotionml+xml': ['emotionml'],
    'application/epub+zip': ['epub'],
    'application/exi': ['exi'],
    'application/express': ['exp'],
    'application/fdf': ['fdf'],
    'application/fdt+xml': ['fdt'],
    'application/font-tdpfr': ['pfr'],
    'application/geo+json': ['geojson'],
    'application/gml+xml': ['gml'],
    'application/gpx+xml': ['gpx'],
    'application/gxf': ['gxf'],
    'application/gzip': ['gz'],
    'application/hjson': ['hjson'],
    'application/hyperstudio': ['stk'],
    'application/inkml+xml': ['ink', 'inkml'],
    'application/ipfix': ['ipfix'],
    'application/its+xml': ['its'],
    'application/java-archive': ['jar', 'war', 'ear'],
    'application/java-serialized-object': ['ser'],
    'application/java-vm': ['class'],
    'application/javascript': ['*js'],
    'application/json': ['json', 'map'],
    'application/json5': ['json5'],
    'application/jsonml+json': ['jsonml'],
    'application/ld+json': ['jsonld'],
    'application/lgr+xml': ['lgr'],
    'application/lost+xml': ['lostxml'],
    'application/mac-binhex40': ['hqx'],
    'application/mac-compactpro': ['cpt'],
    'application/mads+xml': ['mads'],
    'application/manifest+json': ['webmanifest'],
    'application/marc': ['mrc'],
    'application/marcxml+xml': ['mrcx'],
    'application/mathematica': ['ma', 'nb', 'mb'],
    'application/mathml+xml': ['mathml'],
    'application/mbox': ['mbox'],
    'application/media-policy-dataset+xml': ['mpf'],
    'application/mediaservercontrol+xml': ['mscml'],
    'application/metalink+xml': ['metalink'],
    'application/metalink4+xml': ['meta4'],
    'application/mets+xml': ['mets'],
    'application/mmt-aei+xml': ['maei'],
    'application/mmt-usd+xml': ['musd'],
    'application/mods+xml': ['mods'],
    'application/mp21': ['m21', 'mp21'],
    'application/mp4': ['*mp4', '*mpg4', 'mp4s', 'm4p'],
    'application/msix': ['msix'],
    'application/msixbundle': ['msixbundle'],
    'application/msword': ['doc', 'dot'],
    'application/mxf': ['mxf'],
    'application/n-quads': ['nq'],
    'application/n-triples': ['nt'],
    'application/node': ['cjs'],
    'application/octet-stream': [
        'bin',
        'dms',
        'lrf',
        'mar',
        'so',
        'dist',
        'distz',
        'pkg',
        'bpk',
        'dump',
        'elc',
        'deploy',
        'exe',
        'dll',
        'deb',
        'dmg',
        'iso',
        'img',
        'msi',
        'msp',
        'msm',
        'buffer',
    ],
    'application/oda': ['oda'],
    'application/oebps-package+xml': ['opf'],
    'application/ogg': ['ogx'],
    'application/omdoc+xml': ['omdoc'],
    'application/onenote': [
        'onetoc',
        'onetoc2',
        'onetmp',
        'onepkg',
        'one',
        'onea',
    ],
    'application/oxps': ['oxps'],
    'application/p2p-overlay+xml': ['relo'],
    'application/patch-ops-error+xml': ['xer'],
    'application/pdf': ['pdf'],
    'application/pgp-encrypted': ['pgp'],
    'application/pgp-keys': ['asc'],
    'application/pgp-signature': ['sig', '*asc'],
    'application/pics-rules': ['prf'],
    'application/pkcs10': ['p10'],
    'application/pkcs7-mime': ['p7m', 'p7c'],
    'application/pkcs7-signature': ['p7s'],
    'application/pkcs8': ['p8'],
    'application/pkix-attr-cert': ['ac'],
    'application/pkix-cert': ['cer'],
    'application/pkix-crl': ['crl'],
    'application/pkix-pkipath': ['pkipath'],
    'application/pkixcmp': ['pki'],
    'application/pls+xml': ['pls'],
    'application/postscript': ['ai', 'eps', 'ps'],
    'application/provenance+xml': ['provx'],
    'application/pskc+xml': ['pskcxml'],
    'application/raml+yaml': ['raml'],
    'application/rdf+xml': ['rdf', 'owl'],
    'application/reginfo+xml': ['rif'],
    'application/relax-ng-compact-syntax': ['rnc'],
    'application/resource-lists+xml': ['rl'],
    'application/resource-lists-diff+xml': ['rld'],
    'application/rls-services+xml': ['rs'],
    'application/route-apd+xml': ['rapd'],
    'application/route-s-tsid+xml': ['sls'],
    'application/route-usd+xml': ['rusd'],
    'application/rpki-ghostbusters': ['gbr'],
    'application/rpki-manifest': ['mft'],
    'application/rpki-roa': ['roa'],
    'application/rsd+xml': ['rsd'],
    'application/rss+xml': ['rss'],
    'application/rtf': ['rtf'],
    'application/sbml+xml': ['sbml'],
    'application/scvp-cv-request': ['scq'],
    'application/scvp-cv-response': ['scs'],
    'application/scvp-vp-request': ['spq'],
    'application/scvp-vp-response': ['spp'],
    'application/sdp': ['sdp'],
    'application/senml+xml': ['senmlx'],
    'application/sensml+xml': ['sensmlx'],
    'application/set-payment-initiation': ['setpay'],
    'application/set-registration-initiation': ['setreg'],
    'application/shf+xml': ['shf'],
    'application/sieve': ['siv', 'sieve'],
    'application/smil+xml': ['smi', 'smil'],
    'application/sparql-query': ['rq'],
    'application/sparql-results+xml': ['srx'],
    'application/sql': ['sql'],
    'application/srgs': ['gram'],
    'application/srgs+xml': ['grxml'],
    'application/sru+xml': ['sru'],
    'application/ssdl+xml': ['ssdl'],
    'application/ssml+xml': ['ssml'],
    'application/swid+xml': ['swidtag'],
    'application/tei+xml': ['tei', 'teicorpus'],
    'application/thraud+xml': ['tfi'],
    'application/timestamped-data': ['tsd'],
    'application/toml': ['toml'],
    'application/trig': ['trig'],
    'application/ttml+xml': ['ttml'],
    'application/ubjson': ['ubj'],
    'application/urc-ressheet+xml': ['rsheet'],
    'application/urc-targetdesc+xml': ['td'],
    'application/voicexml+xml': ['vxml'],
    'application/wasm': ['wasm'],
    'application/watcherinfo+xml': ['wif'],
    'application/widget': ['wgt'],
    'application/winhlp': ['hlp'],
    'application/wsdl+xml': ['wsdl'],
    'application/wspolicy+xml': ['wspolicy'],
    'application/xaml+xml': ['xaml'],
    'application/xcap-att+xml': ['xav'],
    'application/xcap-caps+xml': ['xca'],
    'application/xcap-diff+xml': ['xdf'],
    'application/xcap-el+xml': ['xel'],
    'application/xcap-ns+xml': ['xns'],
    'application/xenc+xml': ['xenc'],
    'application/xfdf': ['xfdf'],
    'application/xhtml+xml': ['xhtml', 'xht'],
    'application/xliff+xml': ['xlf'],
    'application/xml': ['xml', 'xsl', 'xsd', 'rng'],
    'application/xml-dtd': ['dtd'],
    'application/xop+xml': ['xop'],
    'application/xproc+xml': ['xpl'],
    'application/xslt+xml': ['*xsl', 'xslt'],
    'application/xspf+xml': ['xspf'],
    'application/xv+xml': ['mxml', 'xhvml', 'xvml', 'xvm'],
    'application/yang': ['yang'],
    'application/yin+xml': ['yin'],
    'application/zip': ['zip'],
    'application/zip+dotlottie': ['lottie'],
    'audio/3gpp': ['*3gpp'],
    'audio/aac': ['adts', 'aac'],
    'audio/adpcm': ['adp'],
    'audio/amr': ['amr'],
    'audio/basic': ['au', 'snd'],
    'audio/midi': ['mid', 'midi', 'kar', 'rmi'],
    'audio/mobile-xmf': ['mxmf'],
    'audio/mp3': ['*mp3'],
    'audio/mp4': ['m4a', 'mp4a', 'm4b'],
    'audio/mpeg': ['mpga', 'mp2', 'mp2a', 'mp3', 'm2a', 'm3a'],
    'audio/ogg': ['oga', 'ogg', 'spx', 'opus'],
    'audio/s3m': ['s3m'],
    'audio/silk': ['sil'],
    'audio/wav': ['wav'],
    'audio/wave': ['*wav'],
    'audio/webm': ['weba'],
    'audio/xm': ['xm'],
    'font/collection': ['ttc'],
    'font/otf': ['otf'],
    'font/ttf': ['ttf'],
    'font/woff': ['woff'],
    'font/woff2': ['woff2'],
    'image/aces': ['exr'],
    'image/apng': ['apng'],
    'image/avci': ['avci'],
    'image/avcs': ['avcs'],
    'image/avif': ['avif'],
    'image/bmp': ['bmp', 'dib'],
    'image/cgm': ['cgm'],
    'image/dicom-rle': ['drle'],
    'image/dpx': ['dpx'],
    'image/emf': ['emf'],
    'image/fits': ['fits'],
    'image/g3fax': ['g3'],
    'image/gif': ['gif'],
    'image/heic': ['heic'],
    'image/heic-sequence': ['heics'],
    'image/heif': ['heif'],
    'image/heif-sequence': ['heifs'],
    'image/hej2k': ['hej2'],
    'image/ief': ['ief'],
    'image/jaii': ['jaii'],
    'image/jais': ['jais'],
    'image/jls': ['jls'],
    'image/jp2': ['jp2', 'jpg2'],
    'image/jpeg': ['jpg', 'jpeg', 'jpe'],
    'image/jph': ['jph'],
    'image/jphc': ['jhc'],
    'image/jpm': ['jpm', 'jpgm'],
    'image/jpx': ['jpx', 'jpf'],
    'image/jxl': ['jxl'],
    'image/jxr': ['jxr'],
    'image/jxra': ['jxra'],
    'image/jxrs': ['jxrs'],
    'image/jxs': ['jxs'],
    'image/jxsc': ['jxsc'],
    'image/jxsi': ['jxsi'],
    'image/jxss': ['jxss'],
    'image/ktx': ['ktx'],
    'image/ktx2': ['ktx2'],
    'image/pjpeg': ['jfif'],
    'image/png': ['png'],
    'image/sgi': ['sgi'],
    'image/svg+xml': ['svg', 'svgz'],
    'image/t38': ['t38'],
    'image/tiff': ['tif', 'tiff'],
    'image/tiff-fx': ['tfx'],
    'image/webp': ['webp'],
    'image/wmf': ['wmf'],
    'message/disposition-notification': ['disposition-notification'],
    'message/global': ['u8msg'],
    'message/global-delivery-status': ['u8dsn'],
    'message/global-disposition-notification': ['u8mdn'],
    'message/global-headers': ['u8hdr'],
    'message/rfc822': ['eml', 'mime', 'mht', 'mhtml'],
    'model/3mf': ['3mf'],
    'model/gltf+json': ['gltf'],
    'model/gltf-binary': ['glb'],
    'model/iges': ['igs', 'iges'],
    'model/jt': ['jt'],
    'model/mesh': ['msh', 'mesh', 'silo'],
    'model/mtl': ['mtl'],
    'model/obj': ['obj'],
    'model/prc': ['prc'],
    'model/step': ['step', 'stp', 'stpnc', 'p21', '210'],
    'model/step+xml': ['stpx'],
    'model/step+zip': ['stpz'],
    'model/step-xml+zip': ['stpxz'],
    'model/stl': ['stl'],
    'model/u3d': ['u3d'],
    'model/vrml': ['wrl', 'vrml'],
    'model/x3d+binary': ['*x3db', 'x3dbz'],
    'model/x3d+fastinfoset': ['x3db'],
    'model/x3d+vrml': ['*x3dv', 'x3dvz'],
    'model/x3d+xml': ['x3d', 'x3dz'],
    'model/x3d-vrml': ['x3dv'],
    'text/cache-manifest': ['appcache', 'manifest'],
    'text/calendar': ['ics', 'ifb'],
    'text/coffeescript': ['coffee', 'litcoffee'],
    'text/css': ['css'],
    'text/csv': ['csv'],
    'text/html': ['html', 'htm', 'shtml'],
    'text/jade': ['jade'],
    'text/javascript': ['js', 'mjs'],
    'text/jsx': ['jsx'],
    'text/less': ['less'],
    'text/markdown': ['md', 'markdown'],
    'text/mathml': ['mml'],
    'text/mdx': ['mdx'],
    'text/n3': ['n3'],
    'text/plain': ['txt', 'text', 'conf', 'def', 'list', 'log', 'in', 'ini'],
    'text/richtext': ['rtx'],
    'text/rtf': ['*rtf'],
    'text/sgml': ['sgml', 'sgm'],
    'text/shex': ['shex'],
    'text/slim': ['slim', 'slm'],
    'text/spdx': ['spdx'],
    'text/stylus': ['stylus', 'styl'],
    'text/tab-separated-values': ['tsv'],
    'text/troff': ['t', 'tr', 'roff', 'man', 'me', 'ms'],
    'text/turtle': ['ttl'],
    'text/uri-list': ['uri', 'uris', 'urls'],
    'text/vcard': ['vcard'],
    'text/vtt': ['vtt'],
    'text/wgsl': ['wgsl'],
    'text/xml': ['*xml'],
    'text/yaml': ['yaml', 'yml'],
    'video/3gpp': ['3gp', '3gpp'],
    'video/3gpp2': ['3g2'],
    'video/h261': ['h261'],
    'video/h263': ['h263'],
    'video/h264': ['h264'],
    'video/iso.segment': ['m4s'],
    'video/jpeg': ['jpgv'],
    'video/jpm': ['*jpm', '*jpgm'],
    'video/mj2': ['mj2', 'mjp2'],
    'video/mp2t': ['ts', 'm2t', 'm2ts', 'mts'],
    'video/mp4': ['mp4', 'mp4v', 'mpg4'],
    'video/mpeg': ['mpeg', 'mpg', 'mpe', 'm1v', 'm2v'],
    'video/ogg': ['ogv'],
    'video/quicktime': ['qt', 'mov'],
    'video/webm': ['webm'],
};
Object.freeze(types$1);

var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Mime_extensionToType, _Mime_typeToExtension, _Mime_typeToExtensions;
class Mime {
    constructor(...args) {
        _Mime_extensionToType.set(this, new Map());
        _Mime_typeToExtension.set(this, new Map());
        _Mime_typeToExtensions.set(this, new Map());
        for (const arg of args) {
            this.define(arg);
        }
    }
    define(typeMap, force = false) {
        for (let [type, extensions] of Object.entries(typeMap)) {
            type = type.toLowerCase();
            extensions = extensions.map((ext) => ext.toLowerCase());
            if (!__classPrivateFieldGet(this, _Mime_typeToExtensions, "f").has(type)) {
                __classPrivateFieldGet(this, _Mime_typeToExtensions, "f").set(type, new Set());
            }
            const allExtensions = __classPrivateFieldGet(this, _Mime_typeToExtensions, "f").get(type);
            let first = true;
            for (let extension of extensions) {
                const starred = extension.startsWith('*');
                extension = starred ? extension.slice(1) : extension;
                allExtensions?.add(extension);
                if (first) {
                    __classPrivateFieldGet(this, _Mime_typeToExtension, "f").set(type, extension);
                }
                first = false;
                if (starred)
                    continue;
                const currentType = __classPrivateFieldGet(this, _Mime_extensionToType, "f").get(extension);
                if (currentType && currentType != type && !force) {
                    throw new Error(`"${type} -> ${extension}" conflicts with "${currentType} -> ${extension}". Pass \`force=true\` to override this definition.`);
                }
                __classPrivateFieldGet(this, _Mime_extensionToType, "f").set(extension, type);
            }
        }
        return this;
    }
    getType(path) {
        if (typeof path !== 'string')
            return null;
        const last = path.replace(/^.*[/\\]/s, '').toLowerCase();
        const ext = last.replace(/^.*\./s, '').toLowerCase();
        const hasPath = last.length < path.length;
        const hasDot = ext.length < last.length - 1;
        if (!hasDot && hasPath)
            return null;
        return __classPrivateFieldGet(this, _Mime_extensionToType, "f").get(ext) ?? null;
    }
    getExtension(type) {
        if (typeof type !== 'string')
            return null;
        type = type?.split?.(';')[0];
        return ((type && __classPrivateFieldGet(this, _Mime_typeToExtension, "f").get(type.trim().toLowerCase())) ?? null);
    }
    getAllExtensions(type) {
        if (typeof type !== 'string')
            return null;
        return __classPrivateFieldGet(this, _Mime_typeToExtensions, "f").get(type.toLowerCase()) ?? null;
    }
    _freeze() {
        this.define = () => {
            throw new Error('define() not allowed for built-in Mime objects. See https://github.com/broofa/mime/blob/main/README.md#custom-mime-instances');
        };
        Object.freeze(this);
        for (const extensions of __classPrivateFieldGet(this, _Mime_typeToExtensions, "f").values()) {
            Object.freeze(extensions);
        }
        return this;
    }
    _getTestState() {
        return {
            types: __classPrivateFieldGet(this, _Mime_extensionToType, "f"),
            extensions: __classPrivateFieldGet(this, _Mime_typeToExtension, "f"),
        };
    }
}
_Mime_extensionToType = new WeakMap(), _Mime_typeToExtension = new WeakMap(), _Mime_typeToExtensions = new WeakMap();

const mime = new Mime(types$1, types$2)._freeze();

var ciInfo = {};

var vendors;
var hasRequiredVendors;

function requireVendors () {
	if (hasRequiredVendors) return vendors;
	hasRequiredVendors = 1;
	vendors = [
		{
			name: "Agola CI",
			constant: "AGOLA",
			env: "AGOLA_GIT_REF",
			pr: "AGOLA_PULL_REQUEST_ID"
		},
		{
			name: "Appcircle",
			constant: "APPCIRCLE",
			env: "AC_APPCIRCLE",
			pr: {
				env: "AC_GIT_PR",
				ne: "false"
			}
		},
		{
			name: "AppVeyor",
			constant: "APPVEYOR",
			env: "APPVEYOR",
			pr: "APPVEYOR_PULL_REQUEST_NUMBER"
		},
		{
			name: "AWS CodeBuild",
			constant: "CODEBUILD",
			env: "CODEBUILD_BUILD_ARN",
			pr: {
				env: "CODEBUILD_WEBHOOK_EVENT",
				any: [
					"PULL_REQUEST_CREATED",
					"PULL_REQUEST_UPDATED",
					"PULL_REQUEST_REOPENED"
				]
			}
		},
		{
			name: "Azure Pipelines",
			constant: "AZURE_PIPELINES",
			env: "TF_BUILD",
			pr: {
				BUILD_REASON: "PullRequest"
			}
		},
		{
			name: "Bamboo",
			constant: "BAMBOO",
			env: "bamboo_planKey"
		},
		{
			name: "Bitbucket Pipelines",
			constant: "BITBUCKET",
			env: "BITBUCKET_COMMIT",
			pr: "BITBUCKET_PR_ID"
		},
		{
			name: "Bitrise",
			constant: "BITRISE",
			env: "BITRISE_IO",
			pr: "BITRISE_PULL_REQUEST"
		},
		{
			name: "Buddy",
			constant: "BUDDY",
			env: "BUDDY_WORKSPACE_ID",
			pr: "BUDDY_EXECUTION_PULL_REQUEST_ID"
		},
		{
			name: "Buildkite",
			constant: "BUILDKITE",
			env: "BUILDKITE",
			pr: {
				env: "BUILDKITE_PULL_REQUEST",
				ne: "false"
			}
		},
		{
			name: "CircleCI",
			constant: "CIRCLE",
			env: "CIRCLECI",
			pr: "CIRCLE_PULL_REQUEST"
		},
		{
			name: "Cirrus CI",
			constant: "CIRRUS",
			env: "CIRRUS_CI",
			pr: "CIRRUS_PR"
		},
		{
			name: "Cloudflare Pages",
			constant: "CLOUDFLARE_PAGES",
			env: "CF_PAGES"
		},
		{
			name: "Codefresh",
			constant: "CODEFRESH",
			env: "CF_BUILD_ID",
			pr: {
				any: [
					"CF_PULL_REQUEST_NUMBER",
					"CF_PULL_REQUEST_ID"
				]
			}
		},
		{
			name: "Codemagic",
			constant: "CODEMAGIC",
			env: "CM_BUILD_ID",
			pr: "CM_PULL_REQUEST"
		},
		{
			name: "Codeship",
			constant: "CODESHIP",
			env: {
				CI_NAME: "codeship"
			}
		},
		{
			name: "Drone",
			constant: "DRONE",
			env: "DRONE",
			pr: {
				DRONE_BUILD_EVENT: "pull_request"
			}
		},
		{
			name: "dsari",
			constant: "DSARI",
			env: "DSARI"
		},
		{
			name: "Earthly",
			constant: "EARTHLY",
			env: "EARTHLY_CI"
		},
		{
			name: "Expo Application Services",
			constant: "EAS",
			env: "EAS_BUILD"
		},
		{
			name: "Gerrit",
			constant: "GERRIT",
			env: "GERRIT_PROJECT"
		},
		{
			name: "Gitea Actions",
			constant: "GITEA_ACTIONS",
			env: "GITEA_ACTIONS"
		},
		{
			name: "GitHub Actions",
			constant: "GITHUB_ACTIONS",
			env: "GITHUB_ACTIONS",
			pr: {
				GITHUB_EVENT_NAME: "pull_request"
			}
		},
		{
			name: "GitLab CI",
			constant: "GITLAB",
			env: "GITLAB_CI",
			pr: "CI_MERGE_REQUEST_ID"
		},
		{
			name: "GoCD",
			constant: "GOCD",
			env: "GO_PIPELINE_LABEL"
		},
		{
			name: "Google Cloud Build",
			constant: "GOOGLE_CLOUD_BUILD",
			env: "BUILDER_OUTPUT"
		},
		{
			name: "Harness CI",
			constant: "HARNESS",
			env: "HARNESS_BUILD_ID"
		},
		{
			name: "Heroku",
			constant: "HEROKU",
			env: {
				env: "NODE",
				includes: "/app/.heroku/node/bin/node"
			}
		},
		{
			name: "Hudson",
			constant: "HUDSON",
			env: "HUDSON_URL"
		},
		{
			name: "Jenkins",
			constant: "JENKINS",
			env: [
				"JENKINS_URL",
				"BUILD_ID"
			],
			pr: {
				any: [
					"ghprbPullId",
					"CHANGE_ID"
				]
			}
		},
		{
			name: "LayerCI",
			constant: "LAYERCI",
			env: "LAYERCI",
			pr: "LAYERCI_PULL_REQUEST"
		},
		{
			name: "Magnum CI",
			constant: "MAGNUM",
			env: "MAGNUM"
		},
		{
			name: "Netlify CI",
			constant: "NETLIFY",
			env: "NETLIFY",
			pr: {
				env: "PULL_REQUEST",
				ne: "false"
			}
		},
		{
			name: "Nevercode",
			constant: "NEVERCODE",
			env: "NEVERCODE",
			pr: {
				env: "NEVERCODE_PULL_REQUEST",
				ne: "false"
			}
		},
		{
			name: "Prow",
			constant: "PROW",
			env: "PROW_JOB_ID"
		},
		{
			name: "ReleaseHub",
			constant: "RELEASEHUB",
			env: "RELEASE_BUILD_ID"
		},
		{
			name: "Render",
			constant: "RENDER",
			env: "RENDER",
			pr: {
				IS_PULL_REQUEST: "true"
			}
		},
		{
			name: "Sail CI",
			constant: "SAIL",
			env: "SAILCI",
			pr: "SAIL_PULL_REQUEST_NUMBER"
		},
		{
			name: "Screwdriver",
			constant: "SCREWDRIVER",
			env: "SCREWDRIVER",
			pr: {
				env: "SD_PULL_REQUEST",
				ne: "false"
			}
		},
		{
			name: "Semaphore",
			constant: "SEMAPHORE",
			env: "SEMAPHORE",
			pr: "PULL_REQUEST_NUMBER"
		},
		{
			name: "Sourcehut",
			constant: "SOURCEHUT",
			env: {
				CI_NAME: "sourcehut"
			}
		},
		{
			name: "Strider CD",
			constant: "STRIDER",
			env: "STRIDER"
		},
		{
			name: "TaskCluster",
			constant: "TASKCLUSTER",
			env: [
				"TASK_ID",
				"RUN_ID"
			]
		},
		{
			name: "TeamCity",
			constant: "TEAMCITY",
			env: "TEAMCITY_VERSION"
		},
		{
			name: "Travis CI",
			constant: "TRAVIS",
			env: "TRAVIS",
			pr: {
				env: "TRAVIS_PULL_REQUEST",
				ne: "false"
			}
		},
		{
			name: "Vela",
			constant: "VELA",
			env: "VELA",
			pr: {
				VELA_PULL_REQUEST: "1"
			}
		},
		{
			name: "Vercel",
			constant: "VERCEL",
			env: {
				any: [
					"NOW_BUILDER",
					"VERCEL"
				]
			},
			pr: "VERCEL_GIT_PULL_REQUEST_ID"
		},
		{
			name: "Visual Studio App Center",
			constant: "APPCENTER",
			env: "APPCENTER_BUILD_ID"
		},
		{
			name: "Woodpecker",
			constant: "WOODPECKER",
			env: {
				CI: "woodpecker"
			},
			pr: {
				CI_BUILD_EVENT: "pull_request"
			}
		},
		{
			name: "Xcode Cloud",
			constant: "XCODE_CLOUD",
			env: "CI_XCODE_PROJECT",
			pr: "CI_PULL_REQUEST_NUMBER"
		},
		{
			name: "Xcode Server",
			constant: "XCODE_SERVER",
			env: "XCS"
		}
	];
	return vendors;
}

var hasRequiredCiInfo;

function requireCiInfo () {
	if (hasRequiredCiInfo) return ciInfo;
	hasRequiredCiInfo = 1;
	(function (exports) {

		const vendors = requireVendors();

		const env = process.env;

		// Used for testing only
		Object.defineProperty(exports, '_vendors', {
		  value: vendors.map(function (v) {
		    return v.constant
		  })
		});

		exports.name = null;
		exports.isPR = null;
		exports.id = null;

		vendors.forEach(function (vendor) {
		  const envs = Array.isArray(vendor.env) ? vendor.env : [vendor.env];
		  const isCI = envs.every(function (obj) {
		    return checkEnv(obj)
		  });

		  exports[vendor.constant] = isCI;

		  if (!isCI) {
		    return
		  }

		  exports.name = vendor.name;
		  exports.isPR = checkPR(vendor);
		  exports.id = vendor.constant;
		});

		exports.isCI = !!(
		  env.CI !== 'false' && // Bypass all checks if CI env is explicitly set to 'false'
		  (env.BUILD_ID || // Jenkins, Cloudbees
		    env.BUILD_NUMBER || // Jenkins, TeamCity
		    env.CI || // Travis CI, CircleCI, Cirrus CI, Gitlab CI, Appveyor, CodeShip, dsari, Cloudflare Pages
		    env.CI_APP_ID || // Appflow
		    env.CI_BUILD_ID || // Appflow
		    env.CI_BUILD_NUMBER || // Appflow
		    env.CI_NAME || // Codeship and others
		    env.CONTINUOUS_INTEGRATION || // Travis CI, Cirrus CI
		    env.RUN_ID || // TaskCluster, dsari
		    exports.name ||
		    false)
		);

		function checkEnv (obj) {
		  // "env": "CIRRUS"
		  if (typeof obj === 'string') return !!env[obj]

		  // "env": { "env": "NODE", "includes": "/app/.heroku/node/bin/node" }
		  if ('env' in obj) {
		    // Currently there are no other types, uncomment when there are
		    // if ('includes' in obj) {
		    return env[obj.env] && env[obj.env].includes(obj.includes)
		    // }
		  }

		  if ('any' in obj) {
		    return obj.any.some(function (k) {
		      return !!env[k]
		    })
		  }

		  return Object.keys(obj).every(function (k) {
		    return env[k] === obj[k]
		  })
		}

		function checkPR (vendor) {
		  switch (typeof vendor.pr) {
		    case 'string':
		      // "pr": "CIRRUS_PR"
		      return !!env[vendor.pr]
		    case 'object':
		      if ('env' in vendor.pr) {
		        if ('any' in vendor.pr) {
		          // "pr": { "env": "CODEBUILD_WEBHOOK_EVENT", "any": ["PULL_REQUEST_CREATED", "PULL_REQUEST_UPDATED"] }
		          return vendor.pr.any.some(function (key) {
		            return env[vendor.pr.env] === key
		          })
		        } else {
		          // "pr": { "env": "BUILDKITE_PULL_REQUEST", "ne": "false" }
		          return vendor.pr.env in env && env[vendor.pr.env] !== vendor.pr.ne
		        }
		      } else if ('any' in vendor.pr) {
		        // "pr": { "any": ["ghprbPullId", "CHANGE_ID"] }
		        return vendor.pr.any.some(function (key) {
		          return !!env[key]
		        })
		      } else {
		        // "pr": { "DRONE_BUILD_EVENT": "pull_request" }
		        return checkEnv(vendor.pr)
		      }
		    default:
		      // PR detection not supported for this vendor
		      return null
		  }
		} 
	} (ciInfo));
	return ciInfo;
}

requireCiInfo();

function isBuffer (obj) {
  return obj &&
    obj.constructor &&
    (typeof obj.constructor.isBuffer === 'function') &&
    obj.constructor.isBuffer(obj)
}

function keyIdentity (key) {
  return key
}

function flatten (target, opts) {
  opts = opts || {};

  const delimiter = opts.delimiter || '.';
  const maxDepth = opts.maxDepth;
  const transformKey = opts.transformKey || keyIdentity;
  const output = {};

  function step (object, prev, currentDepth) {
    currentDepth = currentDepth || 1;
    Object.keys(object).forEach(function (key) {
      const value = object[key];
      const isarray = opts.safe && Array.isArray(value);
      const type = Object.prototype.toString.call(value);
      const isbuffer = isBuffer(value);
      const isobject = (
        type === '[object Object]' ||
        type === '[object Array]'
      );

      const newKey = prev
        ? prev + delimiter + transformKey(key)
        : transformKey(key);

      if (!isarray && !isbuffer && isobject && Object.keys(value).length &&
        (!opts.maxDepth || currentDepth < maxDepth)) {
        return step(value, newKey, currentDepth + 1)
      }

      output[newKey] = value;
    });
  }

  step(target);

  return output
}

function unflatten (target, opts) {
  opts = opts || {};

  const delimiter = opts.delimiter || '.';
  const overwrite = opts.overwrite || false;
  const transformKey = opts.transformKey || keyIdentity;
  const result = {};

  const isbuffer = isBuffer(target);
  if (isbuffer || Object.prototype.toString.call(target) !== '[object Object]') {
    return target
  }

  // safely ensure that the key is
  // an integer.
  function getkey (key) {
    const parsedKey = Number(key);

    return (
      isNaN(parsedKey) ||
      key.indexOf('.') !== -1 ||
      opts.object
    )
      ? key
      : parsedKey
  }

  function addKeys (keyPrefix, recipient, target) {
    return Object.keys(target).reduce(function (result, key) {
      result[keyPrefix + delimiter + key] = target[key];

      return result
    }, recipient)
  }

  function isEmpty (val) {
    const type = Object.prototype.toString.call(val);
    const isArray = type === '[object Array]';
    const isObject = type === '[object Object]';

    if (!val) {
      return true
    } else if (isArray) {
      return !val.length
    } else if (isObject) {
      return !Object.keys(val).length
    }
  }

  target = Object.keys(target).reduce(function (result, key) {
    const type = Object.prototype.toString.call(target[key]);
    const isObject = (type === '[object Object]' || type === '[object Array]');
    if (!isObject || isEmpty(target[key])) {
      result[key] = target[key];
      return result
    } else {
      return addKeys(
        key,
        result,
        flatten(target[key], opts)
      )
    }
  }, {});

  Object.keys(target).forEach(function (key) {
    const split = key.split(delimiter).map(transformKey);
    let key1 = getkey(split.shift());
    let key2 = getkey(split[0]);
    let recipient = result;

    while (key2 !== undefined) {
      if (key1 === '__proto__') {
        return
      }

      const type = Object.prototype.toString.call(recipient[key1]);
      const isobject = (
        type === '[object Object]' ||
        type === '[object Array]'
      );

      // do not write over falsey, non-undefined values if overwrite is false
      if (!overwrite && !isobject && typeof recipient[key1] !== 'undefined') {
        return
      }

      if ((overwrite && !isobject) || (!overwrite && recipient[key1] == null)) {
        recipient[key1] = (
          typeof key2 === 'number' &&
          !opts.object
            ? []
            : {}
        );
      }

      recipient = recipient[key1];
      if (split.length > 0) {
        key1 = getkey(split.shift());
        key2 = getkey(split[0]);
      }
    }

    // unflatten again for 'messy objects'
    recipient[key1] = unflatten(target[key], opts);
  });

  return result
}

const RE_KEY_VAL = /^\s*([^\s=]+)\s*=\s*(.*)?\s*$/;
const RE_LINES = /\n|\r|\r\n/;
const defaults = {
  name: ".conf",
  dir: process.cwd(),
  flat: false
};
function withDefaults(options) {
  if (typeof options === "string") {
    options = { name: options };
  }
  return { ...defaults, ...options };
}
function parse(contents, options = {}) {
  const config = {};
  const lines = contents.split(RE_LINES);
  for (const line of lines) {
    const match = line.match(RE_KEY_VAL);
    if (!match) {
      continue;
    }
    const key = match[1];
    if (!key || key === "__proto__" || key === "constructor") {
      continue;
    }
    const value = destr(
      (match[2] || "").trim()
      /* val */
    );
    if (key.endsWith("[]")) {
      const nkey = key.slice(0, Math.max(0, key.length - 2));
      config[nkey] = (config[nkey] || []).concat(value);
      continue;
    }
    config[key] = value;
  }
  return options.flat ? config : unflatten(config, { overwrite: true });
}
function parseFile(path, options) {
  if (!existsSync(path)) {
    return {};
  }
  return parse(readFileSync(path, "utf8"), options);
}
function read(options) {
  options = withDefaults(options);
  return parseFile(resolve(options.dir, options.name), options);
}
function readUser(options) {
  options = withDefaults(options);
  options.dir = process.env.XDG_CONFIG_HOME || homedir();
  return read(options);
}

var main$1 = {exports: {}};

const name = "dotenv";
const version = "16.5.0";
const description = "Loads environment variables from .env file";
const main = "lib/main.js";
const types = "lib/main.d.ts";
const exports = {
	".": {
		types: "./lib/main.d.ts",
		require: "./lib/main.js",
		"default": "./lib/main.js"
	},
	"./config": "./config.js",
	"./config.js": "./config.js",
	"./lib/env-options": "./lib/env-options.js",
	"./lib/env-options.js": "./lib/env-options.js",
	"./lib/cli-options": "./lib/cli-options.js",
	"./lib/cli-options.js": "./lib/cli-options.js",
	"./package.json": "./package.json"
};
const scripts = {
	"dts-check": "tsc --project tests/types/tsconfig.json",
	lint: "standard",
	pretest: "npm run lint && npm run dts-check",
	test: "tap run --allow-empty-coverage --disable-coverage --timeout=60000",
	"test:coverage": "tap run --show-full-coverage --timeout=60000 --coverage-report=lcov",
	prerelease: "npm test",
	release: "standard-version"
};
const repository = {
	type: "git",
	url: "git://github.com/motdotla/dotenv.git"
};
const homepage = "https://github.com/motdotla/dotenv#readme";
const funding = "https://dotenvx.com";
const keywords = [
	"dotenv",
	"env",
	".env",
	"environment",
	"variables",
	"config",
	"settings"
];
const readmeFilename = "README.md";
const license = "BSD-2-Clause";
const devDependencies = {
	"@types/node": "^18.11.3",
	decache: "^4.6.2",
	sinon: "^14.0.1",
	standard: "^17.0.0",
	"standard-version": "^9.5.0",
	tap: "^19.2.0",
	typescript: "^4.8.4"
};
const engines = {
	node: ">=12"
};
const browser = {
	fs: false
};
const _package = {
	name: name,
	version: version,
	description: description,
	main: main,
	types: types,
	exports: exports,
	scripts: scripts,
	repository: repository,
	homepage: homepage,
	funding: funding,
	keywords: keywords,
	readmeFilename: readmeFilename,
	license: license,
	devDependencies: devDependencies,
	engines: engines,
	browser: browser
};

const _package$1 = {
  __proto__: null,
  browser: browser,
  default: _package,
  description: description,
  devDependencies: devDependencies,
  engines: engines,
  exports: exports,
  funding: funding,
  homepage: homepage,
  keywords: keywords,
  license: license,
  main: main,
  name: name,
  readmeFilename: readmeFilename,
  repository: repository,
  scripts: scripts,
  types: types,
  version: version
};

const require$$4 = /*@__PURE__*/getAugmentedNamespace(_package$1);

var hasRequiredMain;

function requireMain () {
	if (hasRequiredMain) return main$1.exports;
	hasRequiredMain = 1;
	const fs = require$$0$1;
	const path = sysPath__default;
	const os = require$$0;
	const crypto = require$$3;
	const packageJson = require$$4;

	const version = packageJson.version;

	const LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;

	// Parse src into an Object
	function parse (src) {
	  const obj = {};

	  // Convert buffer to string
	  let lines = src.toString();

	  // Convert line breaks to same format
	  lines = lines.replace(/\r\n?/mg, '\n');

	  let match;
	  while ((match = LINE.exec(lines)) != null) {
	    const key = match[1];

	    // Default undefined or null to empty string
	    let value = (match[2] || '');

	    // Remove whitespace
	    value = value.trim();

	    // Check if double quoted
	    const maybeQuote = value[0];

	    // Remove surrounding quotes
	    value = value.replace(/^(['"`])([\s\S]*)\1$/mg, '$2');

	    // Expand newlines if double quoted
	    if (maybeQuote === '"') {
	      value = value.replace(/\\n/g, '\n');
	      value = value.replace(/\\r/g, '\r');
	    }

	    // Add to object
	    obj[key] = value;
	  }

	  return obj
	}

	function _parseVault (options) {
	  const vaultPath = _vaultPath(options);

	  // Parse .env.vault
	  const result = DotenvModule.configDotenv({ path: vaultPath });
	  if (!result.parsed) {
	    const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
	    err.code = 'MISSING_DATA';
	    throw err
	  }

	  // handle scenario for comma separated keys - for use with key rotation
	  // example: DOTENV_KEY="dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=prod,dotenv://:key_7890@dotenvx.com/vault/.env.vault?environment=prod"
	  const keys = _dotenvKey(options).split(',');
	  const length = keys.length;

	  let decrypted;
	  for (let i = 0; i < length; i++) {
	    try {
	      // Get full key
	      const key = keys[i].trim();

	      // Get instructions for decrypt
	      const attrs = _instructions(result, key);

	      // Decrypt
	      decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);

	      break
	    } catch (error) {
	      // last key
	      if (i + 1 >= length) {
	        throw error
	      }
	      // try next key
	    }
	  }

	  // Parse decrypted .env string
	  return DotenvModule.parse(decrypted)
	}

	function _warn (message) {
	  console.log(`[dotenv@${version}][WARN] ${message}`);
	}

	function _debug (message) {
	  console.log(`[dotenv@${version}][DEBUG] ${message}`);
	}

	function _dotenvKey (options) {
	  // prioritize developer directly setting options.DOTENV_KEY
	  if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {
	    return options.DOTENV_KEY
	  }

	  // secondary infra already contains a DOTENV_KEY environment variable
	  if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
	    return process.env.DOTENV_KEY
	  }

	  // fallback to empty string
	  return ''
	}

	function _instructions (result, dotenvKey) {
	  // Parse DOTENV_KEY. Format is a URI
	  let uri;
	  try {
	    uri = new URL(dotenvKey);
	  } catch (error) {
	    if (error.code === 'ERR_INVALID_URL') {
	      const err = new Error('INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development');
	      err.code = 'INVALID_DOTENV_KEY';
	      throw err
	    }

	    throw error
	  }

	  // Get decrypt key
	  const key = uri.password;
	  if (!key) {
	    const err = new Error('INVALID_DOTENV_KEY: Missing key part');
	    err.code = 'INVALID_DOTENV_KEY';
	    throw err
	  }

	  // Get environment
	  const environment = uri.searchParams.get('environment');
	  if (!environment) {
	    const err = new Error('INVALID_DOTENV_KEY: Missing environment part');
	    err.code = 'INVALID_DOTENV_KEY';
	    throw err
	  }

	  // Get ciphertext payload
	  const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
	  const ciphertext = result.parsed[environmentKey]; // DOTENV_VAULT_PRODUCTION
	  if (!ciphertext) {
	    const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
	    err.code = 'NOT_FOUND_DOTENV_ENVIRONMENT';
	    throw err
	  }

	  return { ciphertext, key }
	}

	function _vaultPath (options) {
	  let possibleVaultPath = null;

	  if (options && options.path && options.path.length > 0) {
	    if (Array.isArray(options.path)) {
	      for (const filepath of options.path) {
	        if (fs.existsSync(filepath)) {
	          possibleVaultPath = filepath.endsWith('.vault') ? filepath : `${filepath}.vault`;
	        }
	      }
	    } else {
	      possibleVaultPath = options.path.endsWith('.vault') ? options.path : `${options.path}.vault`;
	    }
	  } else {
	    possibleVaultPath = path.resolve(process.cwd(), '.env.vault');
	  }

	  if (fs.existsSync(possibleVaultPath)) {
	    return possibleVaultPath
	  }

	  return null
	}

	function _resolveHome (envPath) {
	  return envPath[0] === '~' ? path.join(os.homedir(), envPath.slice(1)) : envPath
	}

	function _configVault (options) {
	  const debug = Boolean(options && options.debug);
	  if (debug) {
	    _debug('Loading env from encrypted .env.vault');
	  }

	  const parsed = DotenvModule._parseVault(options);

	  let processEnv = process.env;
	  if (options && options.processEnv != null) {
	    processEnv = options.processEnv;
	  }

	  DotenvModule.populate(processEnv, parsed, options);

	  return { parsed }
	}

	function configDotenv (options) {
	  const dotenvPath = path.resolve(process.cwd(), '.env');
	  let encoding = 'utf8';
	  const debug = Boolean(options && options.debug);

	  if (options && options.encoding) {
	    encoding = options.encoding;
	  } else {
	    if (debug) {
	      _debug('No encoding is specified. UTF-8 is used by default');
	    }
	  }

	  let optionPaths = [dotenvPath]; // default, look for .env
	  if (options && options.path) {
	    if (!Array.isArray(options.path)) {
	      optionPaths = [_resolveHome(options.path)];
	    } else {
	      optionPaths = []; // reset default
	      for (const filepath of options.path) {
	        optionPaths.push(_resolveHome(filepath));
	      }
	    }
	  }

	  // Build the parsed data in a temporary object (because we need to return it).  Once we have the final
	  // parsed data, we will combine it with process.env (or options.processEnv if provided).
	  let lastError;
	  const parsedAll = {};
	  for (const path of optionPaths) {
	    try {
	      // Specifying an encoding returns a string instead of a buffer
	      const parsed = DotenvModule.parse(fs.readFileSync(path, { encoding }));

	      DotenvModule.populate(parsedAll, parsed, options);
	    } catch (e) {
	      if (debug) {
	        _debug(`Failed to load ${path} ${e.message}`);
	      }
	      lastError = e;
	    }
	  }

	  let processEnv = process.env;
	  if (options && options.processEnv != null) {
	    processEnv = options.processEnv;
	  }

	  DotenvModule.populate(processEnv, parsedAll, options);

	  if (lastError) {
	    return { parsed: parsedAll, error: lastError }
	  } else {
	    return { parsed: parsedAll }
	  }
	}

	// Populates process.env from .env file
	function config (options) {
	  // fallback to original dotenv if DOTENV_KEY is not set
	  if (_dotenvKey(options).length === 0) {
	    return DotenvModule.configDotenv(options)
	  }

	  const vaultPath = _vaultPath(options);

	  // dotenvKey exists but .env.vault file does not exist
	  if (!vaultPath) {
	    _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);

	    return DotenvModule.configDotenv(options)
	  }

	  return DotenvModule._configVault(options)
	}

	function decrypt (encrypted, keyStr) {
	  const key = Buffer.from(keyStr.slice(-64), 'hex');
	  let ciphertext = Buffer.from(encrypted, 'base64');

	  const nonce = ciphertext.subarray(0, 12);
	  const authTag = ciphertext.subarray(-16);
	  ciphertext = ciphertext.subarray(12, -16);

	  try {
	    const aesgcm = crypto.createDecipheriv('aes-256-gcm', key, nonce);
	    aesgcm.setAuthTag(authTag);
	    return `${aesgcm.update(ciphertext)}${aesgcm.final()}`
	  } catch (error) {
	    const isRange = error instanceof RangeError;
	    const invalidKeyLength = error.message === 'Invalid key length';
	    const decryptionFailed = error.message === 'Unsupported state or unable to authenticate data';

	    if (isRange || invalidKeyLength) {
	      const err = new Error('INVALID_DOTENV_KEY: It must be 64 characters long (or more)');
	      err.code = 'INVALID_DOTENV_KEY';
	      throw err
	    } else if (decryptionFailed) {
	      const err = new Error('DECRYPTION_FAILED: Please check your DOTENV_KEY');
	      err.code = 'DECRYPTION_FAILED';
	      throw err
	    } else {
	      throw error
	    }
	  }
	}

	// Populate process.env with parsed values
	function populate (processEnv, parsed, options = {}) {
	  const debug = Boolean(options && options.debug);
	  const override = Boolean(options && options.override);

	  if (typeof parsed !== 'object') {
	    const err = new Error('OBJECT_REQUIRED: Please check the processEnv argument being passed to populate');
	    err.code = 'OBJECT_REQUIRED';
	    throw err
	  }

	  // Set process.env
	  for (const key of Object.keys(parsed)) {
	    if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
	      if (override === true) {
	        processEnv[key] = parsed[key];
	      }

	      if (debug) {
	        if (override === true) {
	          _debug(`"${key}" is already defined and WAS overwritten`);
	        } else {
	          _debug(`"${key}" is already defined and was NOT overwritten`);
	        }
	      }
	    } else {
	      processEnv[key] = parsed[key];
	    }
	  }
	}

	const DotenvModule = {
	  configDotenv,
	  _configVault,
	  _parseVault,
	  config,
	  decrypt,
	  parse,
	  populate
	};

	main$1.exports.configDotenv = DotenvModule.configDotenv;
	main$1.exports._configVault = DotenvModule._configVault;
	main$1.exports._parseVault = DotenvModule._parseVault;
	main$1.exports.config = DotenvModule.config;
	main$1.exports.decrypt = DotenvModule.decrypt;
	main$1.exports.parse = DotenvModule.parse;
	main$1.exports.populate = DotenvModule.populate;

	main$1.exports = DotenvModule;
	return main$1.exports;
}

var mainExports = requireMain();

var jiti = {exports: {}};

var hasRequiredJiti;

function requireJiti () {
	if (hasRequiredJiti) return jiti.exports;
	hasRequiredJiti = 1;
	(()=>{var __webpack_modules__={"./node_modules/.pnpm/mlly@1.7.3/node_modules/mlly/dist lazy recursive":module=>{function webpackEmptyAsyncContext(req){return Promise.resolve().then((()=>{var e=new Error("Cannot find module '"+req+"'");throw e.code="MODULE_NOT_FOUND",e}))}webpackEmptyAsyncContext.keys=()=>[],webpackEmptyAsyncContext.resolve=webpackEmptyAsyncContext,webpackEmptyAsyncContext.id="./node_modules/.pnpm/mlly@1.7.3/node_modules/mlly/dist lazy recursive",module.exports=webpackEmptyAsyncContext;}},__webpack_module_cache__={};function __webpack_require__(moduleId){var cachedModule=__webpack_module_cache__[moduleId];if(void 0!==cachedModule)return cachedModule.exports;var module=__webpack_module_cache__[moduleId]={exports:{}};return __webpack_modules__[moduleId](module,module.exports,__webpack_require__),module.exports}__webpack_require__.n=module=>{var getter=module&&module.__esModule?()=>module.default:()=>module;return __webpack_require__.d(getter,{a:getter}),getter},__webpack_require__.d=(exports,definition)=>{for(var key in definition)__webpack_require__.o(definition,key)&&!__webpack_require__.o(exports,key)&&Object.defineProperty(exports,key,{enumerable:true,get:definition[key]});},__webpack_require__.o=(obj,prop)=>Object.prototype.hasOwnProperty.call(obj,prop);var __webpack_exports__={};(()=>{__webpack_require__.d(__webpack_exports__,{default:()=>createJiti});const external_node_os_namespaceObject=require$$0$a;var astralIdentifierCodes=[509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,7,9,32,4,318,1,80,3,71,10,50,3,123,2,54,14,32,10,3,1,11,3,46,10,8,0,46,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,2,11,83,11,7,0,3,0,158,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,68,8,2,0,3,0,2,3,2,4,2,0,15,1,83,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,7,19,58,14,5,9,243,14,166,9,71,5,2,1,3,3,2,0,2,1,13,9,120,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,343,9,54,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,10,1,2,0,49,6,4,4,14,10,5350,0,7,14,11465,27,2343,9,87,9,39,4,60,6,26,9,535,9,470,0,2,54,8,3,82,0,12,1,19628,1,4178,9,519,45,3,22,543,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,101,0,161,6,10,9,357,0,62,13,499,13,245,1,2,9,726,6,110,6,6,9,4759,9,787719,239],astralIdentifierStartCodes=[0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,13,10,2,14,2,6,2,1,2,10,2,14,2,6,2,1,4,51,13,310,10,21,11,7,25,5,2,41,2,8,70,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,39,27,10,22,251,41,7,1,17,2,60,28,11,0,9,21,43,17,47,20,28,22,13,52,58,1,3,0,14,44,33,24,27,35,30,0,3,0,9,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,20,1,64,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,31,9,2,0,3,0,2,37,2,0,26,0,2,0,45,52,19,3,21,2,31,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,38,6,186,43,117,63,32,7,3,0,3,7,2,1,2,23,16,0,2,0,95,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,19,72,200,32,32,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,16,0,2,12,2,33,125,0,80,921,103,110,18,195,2637,96,16,1071,18,5,26,3994,6,582,6842,29,1763,568,8,30,18,78,18,29,19,47,17,3,32,20,6,18,433,44,212,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,1237,42,9,8936,3,2,6,2,1,2,290,16,0,30,2,3,0,15,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,1845,30,7,5,262,61,147,44,11,6,17,0,322,29,19,43,485,27,229,29,3,0,496,6,2,3,2,1,2,14,2,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42719,33,4153,7,221,3,5761,15,7472,16,621,2467,541,1507,4938,6,4191],nonASCIIidentifierStartChars="------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------",reservedWords={3:"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",5:"class enum extends super const export import",6:"enum",strict:"implements interface let package private protected public static yield",strictBind:"eval arguments"},ecma5AndLessKeywords="break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this",keywords$1={5:ecma5AndLessKeywords,"5module":ecma5AndLessKeywords+" export import",6:ecma5AndLessKeywords+" const class extends export import super"},keywordRelationalOperator=/^in(stanceof)?$/,nonASCIIidentifierStart=new RegExp("["+nonASCIIidentifierStartChars+"]"),nonASCIIidentifier=new RegExp("["+nonASCIIidentifierStartChars+"-----------------------------------------------------------------------------------------------------------------------------------------------------]");function isInAstralSet(code,set){for(var pos=65536,i=0;i<set.length;i+=2){if((pos+=set[i])>code)return  false;if((pos+=set[i+1])>=code)return  true}return  false}function isIdentifierStart(code,astral){return code<65?36===code:code<91||(code<97?95===code:code<123||(code<=65535?code>=170&&nonASCIIidentifierStart.test(String.fromCharCode(code)):false!==astral&&isInAstralSet(code,astralIdentifierStartCodes)))}function isIdentifierChar(code,astral){return code<48?36===code:code<58||!(code<65)&&(code<91||(code<97?95===code:code<123||(code<=65535?code>=170&&nonASCIIidentifier.test(String.fromCharCode(code)):false!==astral&&(isInAstralSet(code,astralIdentifierStartCodes)||isInAstralSet(code,astralIdentifierCodes)))))}var TokenType=function(label,conf){ void 0===conf&&(conf={}),this.label=label,this.keyword=conf.keyword,this.beforeExpr=!!conf.beforeExpr,this.startsExpr=!!conf.startsExpr,this.isLoop=!!conf.isLoop,this.isAssign=!!conf.isAssign,this.prefix=!!conf.prefix,this.postfix=!!conf.postfix,this.binop=conf.binop||null,this.updateContext=null;};function binop(name,prec){return new TokenType(name,{beforeExpr:true,binop:prec})}var beforeExpr={beforeExpr:true},startsExpr={startsExpr:true},keywords={};function kw(name,options){return void 0===options&&(options={}),options.keyword=name,keywords[name]=new TokenType(name,options)}var types$1={num:new TokenType("num",startsExpr),regexp:new TokenType("regexp",startsExpr),string:new TokenType("string",startsExpr),name:new TokenType("name",startsExpr),privateId:new TokenType("privateId",startsExpr),eof:new TokenType("eof"),bracketL:new TokenType("[",{beforeExpr:true,startsExpr:true}),bracketR:new TokenType("]"),braceL:new TokenType("{",{beforeExpr:true,startsExpr:true}),braceR:new TokenType("}"),parenL:new TokenType("(",{beforeExpr:true,startsExpr:true}),parenR:new TokenType(")"),comma:new TokenType(",",beforeExpr),semi:new TokenType(";",beforeExpr),colon:new TokenType(":",beforeExpr),dot:new TokenType("."),question:new TokenType("?",beforeExpr),questionDot:new TokenType("?."),arrow:new TokenType("=>",beforeExpr),template:new TokenType("template"),invalidTemplate:new TokenType("invalidTemplate"),ellipsis:new TokenType("...",beforeExpr),backQuote:new TokenType("`",startsExpr),dollarBraceL:new TokenType("${",{beforeExpr:true,startsExpr:true}),eq:new TokenType("=",{beforeExpr:true,isAssign:true}),assign:new TokenType("_=",{beforeExpr:true,isAssign:true}),incDec:new TokenType("++/--",{prefix:true,postfix:true,startsExpr:true}),prefix:new TokenType("!/~",{beforeExpr:true,prefix:true,startsExpr:true}),logicalOR:binop("||",1),logicalAND:binop("&&",2),bitwiseOR:binop("|",3),bitwiseXOR:binop("^",4),bitwiseAND:binop("&",5),equality:binop("==/!=/===/!==",6),relational:binop("</>/<=/>=",7),bitShift:binop("<</>>/>>>",8),plusMin:new TokenType("+/-",{beforeExpr:true,binop:9,prefix:true,startsExpr:true}),modulo:binop("%",10),star:binop("*",10),slash:binop("/",10),starstar:new TokenType("**",{beforeExpr:true}),coalesce:binop("??",1),_break:kw("break"),_case:kw("case",beforeExpr),_catch:kw("catch"),_continue:kw("continue"),_debugger:kw("debugger"),_default:kw("default",beforeExpr),_do:kw("do",{isLoop:true,beforeExpr:true}),_else:kw("else",beforeExpr),_finally:kw("finally"),_for:kw("for",{isLoop:true}),_function:kw("function",startsExpr),_if:kw("if"),_return:kw("return",beforeExpr),_switch:kw("switch"),_throw:kw("throw",beforeExpr),_try:kw("try"),_var:kw("var"),_const:kw("const"),_while:kw("while",{isLoop:true}),_with:kw("with"),_new:kw("new",{beforeExpr:true,startsExpr:true}),_this:kw("this",startsExpr),_super:kw("super",startsExpr),_class:kw("class",startsExpr),_extends:kw("extends",beforeExpr),_export:kw("export"),_import:kw("import",startsExpr),_null:kw("null",startsExpr),_true:kw("true",startsExpr),_false:kw("false",startsExpr),_in:kw("in",{beforeExpr:true,binop:7}),_instanceof:kw("instanceof",{beforeExpr:true,binop:7}),_typeof:kw("typeof",{beforeExpr:true,prefix:true,startsExpr:true}),_void:kw("void",{beforeExpr:true,prefix:true,startsExpr:true}),_delete:kw("delete",{beforeExpr:true,prefix:true,startsExpr:true})},lineBreak=/\r\n?|\n|\u2028|\u2029/,lineBreakG=new RegExp(lineBreak.source,"g");function isNewLine(code){return 10===code||13===code||8232===code||8233===code}function nextLineBreak(code,from,end){ void 0===end&&(end=code.length);for(var i=from;i<end;i++){var next=code.charCodeAt(i);if(isNewLine(next))return i<end-1&&13===next&&10===code.charCodeAt(i+1)?i+2:i+1}return  -1}var nonASCIIwhitespace=/[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/,skipWhiteSpace=/(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g,ref=Object.prototype,acorn_hasOwnProperty=ref.hasOwnProperty,acorn_toString=ref.toString,hasOwn=Object.hasOwn||function(obj,propName){return acorn_hasOwnProperty.call(obj,propName)},isArray=Array.isArray||function(obj){return "[object Array]"===acorn_toString.call(obj)},regexpCache=Object.create(null);function wordsRegexp(words){return regexpCache[words]||(regexpCache[words]=new RegExp("^(?:"+words.replace(/ /g,"|")+")$"))}function codePointToString(code){return code<=65535?String.fromCharCode(code):(code-=65536,String.fromCharCode(55296+(code>>10),56320+(1023&code)))}var loneSurrogate=/(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/,Position=function(line,col){this.line=line,this.column=col;};Position.prototype.offset=function(n){return new Position(this.line,this.column+n)};var SourceLocation=function(p,start,end){this.start=start,this.end=end,null!==p.sourceFile&&(this.source=p.sourceFile);};function getLineInfo(input,offset){for(var line=1,cur=0;;){var nextBreak=nextLineBreak(input,cur,offset);if(nextBreak<0)return new Position(line,offset-cur);++line,cur=nextBreak;}}var defaultOptions={ecmaVersion:null,sourceType:"script",onInsertedSemicolon:null,onTrailingComma:null,allowReserved:null,allowReturnOutsideFunction:false,allowImportExportEverywhere:false,allowAwaitOutsideFunction:null,allowSuperOutsideMethod:null,allowHashBang:false,checkPrivateFields:true,locations:false,onToken:null,onComment:null,ranges:false,program:null,sourceFile:null,directSourceFile:null,preserveParens:false},warnedAboutEcmaVersion=false;function getOptions(opts){var options={};for(var opt in defaultOptions)options[opt]=opts&&hasOwn(opts,opt)?opts[opt]:defaultOptions[opt];if("latest"===options.ecmaVersion?options.ecmaVersion=1e8:null==options.ecmaVersion?(!warnedAboutEcmaVersion&&"object"==typeof console&&console.warn&&(warnedAboutEcmaVersion=true,console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.")),options.ecmaVersion=11):options.ecmaVersion>=2015&&(options.ecmaVersion-=2009),null==options.allowReserved&&(options.allowReserved=options.ecmaVersion<5),opts&&null!=opts.allowHashBang||(options.allowHashBang=options.ecmaVersion>=14),isArray(options.onToken)){var tokens=options.onToken;options.onToken=function(token){return tokens.push(token)};}return isArray(options.onComment)&&(options.onComment=function(options,array){return function(block,text,start,end,startLoc,endLoc){var comment={type:block?"Block":"Line",value:text,start,end};options.locations&&(comment.loc=new SourceLocation(this,startLoc,endLoc)),options.ranges&&(comment.range=[start,end]),array.push(comment);}}(options,options.onComment)),options}function functionFlags(async,generator){return 2|(async?4:0)|(generator?8:0)}var Parser=function(options,input,startPos){this.options=options=getOptions(options),this.sourceFile=options.sourceFile,this.keywords=wordsRegexp(keywords$1[options.ecmaVersion>=6?6:"module"===options.sourceType?"5module":5]);var reserved="";true!==options.allowReserved&&(reserved=reservedWords[options.ecmaVersion>=6?6:5===options.ecmaVersion?5:3],"module"===options.sourceType&&(reserved+=" await")),this.reservedWords=wordsRegexp(reserved);var reservedStrict=(reserved?reserved+" ":"")+reservedWords.strict;this.reservedWordsStrict=wordsRegexp(reservedStrict),this.reservedWordsStrictBind=wordsRegexp(reservedStrict+" "+reservedWords.strictBind),this.input=String(input),this.containsEsc=false,startPos?(this.pos=startPos,this.lineStart=this.input.lastIndexOf("\n",startPos-1)+1,this.curLine=this.input.slice(0,this.lineStart).split(lineBreak).length):(this.pos=this.lineStart=0,this.curLine=1),this.type=types$1.eof,this.value=null,this.start=this.end=this.pos,this.startLoc=this.endLoc=this.curPosition(),this.lastTokEndLoc=this.lastTokStartLoc=null,this.lastTokStart=this.lastTokEnd=this.pos,this.context=this.initialContext(),this.exprAllowed=true,this.inModule="module"===options.sourceType,this.strict=this.inModule||this.strictDirective(this.pos),this.potentialArrowAt=-1,this.potentialArrowInForAwait=false,this.yieldPos=this.awaitPos=this.awaitIdentPos=0,this.labels=[],this.undefinedExports=Object.create(null),0===this.pos&&options.allowHashBang&&"#!"===this.input.slice(0,2)&&this.skipLineComment(2),this.scopeStack=[],this.enterScope(1),this.regexpState=null,this.privateNameStack=[];},prototypeAccessors={inFunction:{configurable:true},inGenerator:{configurable:true},inAsync:{configurable:true},canAwait:{configurable:true},allowSuper:{configurable:true},allowDirectSuper:{configurable:true},treatFunctionsAsVar:{configurable:true},allowNewDotTarget:{configurable:true},inClassStaticBlock:{configurable:true}};Parser.prototype.parse=function(){var node=this.options.program||this.startNode();return this.nextToken(),this.parseTopLevel(node)},prototypeAccessors.inFunction.get=function(){return (2&this.currentVarScope().flags)>0},prototypeAccessors.inGenerator.get=function(){return (8&this.currentVarScope().flags)>0&&!this.currentVarScope().inClassFieldInit},prototypeAccessors.inAsync.get=function(){return (4&this.currentVarScope().flags)>0&&!this.currentVarScope().inClassFieldInit},prototypeAccessors.canAwait.get=function(){for(var i=this.scopeStack.length-1;i>=0;i--){var scope=this.scopeStack[i];if(scope.inClassFieldInit||256&scope.flags)return  false;if(2&scope.flags)return (4&scope.flags)>0}return this.inModule&&this.options.ecmaVersion>=13||this.options.allowAwaitOutsideFunction},prototypeAccessors.allowSuper.get=function(){var ref=this.currentThisScope(),flags=ref.flags,inClassFieldInit=ref.inClassFieldInit;return (64&flags)>0||inClassFieldInit||this.options.allowSuperOutsideMethod},prototypeAccessors.allowDirectSuper.get=function(){return (128&this.currentThisScope().flags)>0},prototypeAccessors.treatFunctionsAsVar.get=function(){return this.treatFunctionsAsVarInScope(this.currentScope())},prototypeAccessors.allowNewDotTarget.get=function(){var ref=this.currentThisScope(),flags=ref.flags,inClassFieldInit=ref.inClassFieldInit;return (258&flags)>0||inClassFieldInit},prototypeAccessors.inClassStaticBlock.get=function(){return (256&this.currentVarScope().flags)>0},Parser.extend=function(){for(var plugins=[],len=arguments.length;len--;)plugins[len]=arguments[len];for(var cls=this,i=0;i<plugins.length;i++)cls=plugins[i](cls);return cls},Parser.parse=function(input,options){return new this(options,input).parse()},Parser.parseExpressionAt=function(input,pos,options){var parser=new this(options,input,pos);return parser.nextToken(),parser.parseExpression()},Parser.tokenizer=function(input,options){return new this(options,input)},Object.defineProperties(Parser.prototype,prototypeAccessors);var pp$9=Parser.prototype,literal=/^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;pp$9.strictDirective=function(start){if(this.options.ecmaVersion<5)return  false;for(;;){skipWhiteSpace.lastIndex=start,start+=skipWhiteSpace.exec(this.input)[0].length;var match=literal.exec(this.input.slice(start));if(!match)return  false;if("use strict"===(match[1]||match[2])){skipWhiteSpace.lastIndex=start+match[0].length;var spaceAfter=skipWhiteSpace.exec(this.input),end=spaceAfter.index+spaceAfter[0].length,next=this.input.charAt(end);return ";"===next||"}"===next||lineBreak.test(spaceAfter[0])&&!(/[(`.[+\-/*%<>=,?^&]/.test(next)||"!"===next&&"="===this.input.charAt(end+1))}start+=match[0].length,skipWhiteSpace.lastIndex=start,start+=skipWhiteSpace.exec(this.input)[0].length,";"===this.input[start]&&start++;}},pp$9.eat=function(type){return this.type===type&&(this.next(),true)},pp$9.isContextual=function(name){return this.type===types$1.name&&this.value===name&&!this.containsEsc},pp$9.eatContextual=function(name){return !!this.isContextual(name)&&(this.next(),true)},pp$9.expectContextual=function(name){this.eatContextual(name)||this.unexpected();},pp$9.canInsertSemicolon=function(){return this.type===types$1.eof||this.type===types$1.braceR||lineBreak.test(this.input.slice(this.lastTokEnd,this.start))},pp$9.insertSemicolon=function(){if(this.canInsertSemicolon())return this.options.onInsertedSemicolon&&this.options.onInsertedSemicolon(this.lastTokEnd,this.lastTokEndLoc),true},pp$9.semicolon=function(){this.eat(types$1.semi)||this.insertSemicolon()||this.unexpected();},pp$9.afterTrailingComma=function(tokType,notNext){if(this.type===tokType)return this.options.onTrailingComma&&this.options.onTrailingComma(this.lastTokStart,this.lastTokStartLoc),notNext||this.next(),true},pp$9.expect=function(type){this.eat(type)||this.unexpected();},pp$9.unexpected=function(pos){this.raise(null!=pos?pos:this.start,"Unexpected token");};var DestructuringErrors=function(){this.shorthandAssign=this.trailingComma=this.parenthesizedAssign=this.parenthesizedBind=this.doubleProto=-1;};pp$9.checkPatternErrors=function(refDestructuringErrors,isAssign){if(refDestructuringErrors){refDestructuringErrors.trailingComma>-1&&this.raiseRecoverable(refDestructuringErrors.trailingComma,"Comma is not permitted after the rest element");var parens=isAssign?refDestructuringErrors.parenthesizedAssign:refDestructuringErrors.parenthesizedBind;parens>-1&&this.raiseRecoverable(parens,isAssign?"Assigning to rvalue":"Parenthesized pattern");}},pp$9.checkExpressionErrors=function(refDestructuringErrors,andThrow){if(!refDestructuringErrors)return  false;var shorthandAssign=refDestructuringErrors.shorthandAssign,doubleProto=refDestructuringErrors.doubleProto;if(!andThrow)return shorthandAssign>=0||doubleProto>=0;shorthandAssign>=0&&this.raise(shorthandAssign,"Shorthand property assignments are valid only in destructuring patterns"),doubleProto>=0&&this.raiseRecoverable(doubleProto,"Redefinition of __proto__ property");},pp$9.checkYieldAwaitInDefaultParams=function(){this.yieldPos&&(!this.awaitPos||this.yieldPos<this.awaitPos)&&this.raise(this.yieldPos,"Yield expression cannot be a default value"),this.awaitPos&&this.raise(this.awaitPos,"Await expression cannot be a default value");},pp$9.isSimpleAssignTarget=function(expr){return "ParenthesizedExpression"===expr.type?this.isSimpleAssignTarget(expr.expression):"Identifier"===expr.type||"MemberExpression"===expr.type};var pp$8=Parser.prototype;pp$8.parseTopLevel=function(node){var exports=Object.create(null);for(node.body||(node.body=[]);this.type!==types$1.eof;){var stmt=this.parseStatement(null,true,exports);node.body.push(stmt);}if(this.inModule)for(var i=0,list=Object.keys(this.undefinedExports);i<list.length;i+=1){var name=list[i];this.raiseRecoverable(this.undefinedExports[name].start,"Export '"+name+"' is not defined");}return this.adaptDirectivePrologue(node.body),this.next(),node.sourceType=this.options.sourceType,this.finishNode(node,"Program")};var loopLabel={kind:"loop"},switchLabel={kind:"switch"};pp$8.isLet=function(context){if(this.options.ecmaVersion<6||!this.isContextual("let"))return  false;skipWhiteSpace.lastIndex=this.pos;var skip=skipWhiteSpace.exec(this.input),next=this.pos+skip[0].length,nextCh=this.input.charCodeAt(next);if(91===nextCh||92===nextCh)return  true;if(context)return  false;if(123===nextCh||nextCh>55295&&nextCh<56320)return  true;if(isIdentifierStart(nextCh,true)){for(var pos=next+1;isIdentifierChar(nextCh=this.input.charCodeAt(pos),true);)++pos;if(92===nextCh||nextCh>55295&&nextCh<56320)return  true;var ident=this.input.slice(next,pos);if(!keywordRelationalOperator.test(ident))return  true}return  false},pp$8.isAsyncFunction=function(){if(this.options.ecmaVersion<8||!this.isContextual("async"))return  false;skipWhiteSpace.lastIndex=this.pos;var after,skip=skipWhiteSpace.exec(this.input),next=this.pos+skip[0].length;return !(lineBreak.test(this.input.slice(this.pos,next))||"function"!==this.input.slice(next,next+8)||next+8!==this.input.length&&(isIdentifierChar(after=this.input.charCodeAt(next+8))||after>55295&&after<56320))},pp$8.parseStatement=function(context,topLevel,exports){var kind,starttype=this.type,node=this.startNode();switch(this.isLet(context)&&(starttype=types$1._var,kind="let"),starttype){case types$1._break:case types$1._continue:return this.parseBreakContinueStatement(node,starttype.keyword);case types$1._debugger:return this.parseDebuggerStatement(node);case types$1._do:return this.parseDoStatement(node);case types$1._for:return this.parseForStatement(node);case types$1._function:return context&&(this.strict||"if"!==context&&"label"!==context)&&this.options.ecmaVersion>=6&&this.unexpected(),this.parseFunctionStatement(node,false,!context);case types$1._class:return context&&this.unexpected(),this.parseClass(node,true);case types$1._if:return this.parseIfStatement(node);case types$1._return:return this.parseReturnStatement(node);case types$1._switch:return this.parseSwitchStatement(node);case types$1._throw:return this.parseThrowStatement(node);case types$1._try:return this.parseTryStatement(node);case types$1._const:case types$1._var:return kind=kind||this.value,context&&"var"!==kind&&this.unexpected(),this.parseVarStatement(node,kind);case types$1._while:return this.parseWhileStatement(node);case types$1._with:return this.parseWithStatement(node);case types$1.braceL:return this.parseBlock(true,node);case types$1.semi:return this.parseEmptyStatement(node);case types$1._export:case types$1._import:if(this.options.ecmaVersion>10&&starttype===types$1._import){skipWhiteSpace.lastIndex=this.pos;var skip=skipWhiteSpace.exec(this.input),next=this.pos+skip[0].length,nextCh=this.input.charCodeAt(next);if(40===nextCh||46===nextCh)return this.parseExpressionStatement(node,this.parseExpression())}return this.options.allowImportExportEverywhere||(topLevel||this.raise(this.start,"'import' and 'export' may only appear at the top level"),this.inModule||this.raise(this.start,"'import' and 'export' may appear only with 'sourceType: module'")),starttype===types$1._import?this.parseImport(node):this.parseExport(node,exports);default:if(this.isAsyncFunction())return context&&this.unexpected(),this.next(),this.parseFunctionStatement(node,true,!context);var maybeName=this.value,expr=this.parseExpression();return starttype===types$1.name&&"Identifier"===expr.type&&this.eat(types$1.colon)?this.parseLabeledStatement(node,maybeName,expr,context):this.parseExpressionStatement(node,expr)}},pp$8.parseBreakContinueStatement=function(node,keyword){var isBreak="break"===keyword;this.next(),this.eat(types$1.semi)||this.insertSemicolon()?node.label=null:this.type!==types$1.name?this.unexpected():(node.label=this.parseIdent(),this.semicolon());for(var i=0;i<this.labels.length;++i){var lab=this.labels[i];if(null==node.label||lab.name===node.label.name){if(null!=lab.kind&&(isBreak||"loop"===lab.kind))break;if(node.label&&isBreak)break}}return i===this.labels.length&&this.raise(node.start,"Unsyntactic "+keyword),this.finishNode(node,isBreak?"BreakStatement":"ContinueStatement")},pp$8.parseDebuggerStatement=function(node){return this.next(),this.semicolon(),this.finishNode(node,"DebuggerStatement")},pp$8.parseDoStatement=function(node){return this.next(),this.labels.push(loopLabel),node.body=this.parseStatement("do"),this.labels.pop(),this.expect(types$1._while),node.test=this.parseParenExpression(),this.options.ecmaVersion>=6?this.eat(types$1.semi):this.semicolon(),this.finishNode(node,"DoWhileStatement")},pp$8.parseForStatement=function(node){this.next();var awaitAt=this.options.ecmaVersion>=9&&this.canAwait&&this.eatContextual("await")?this.lastTokStart:-1;if(this.labels.push(loopLabel),this.enterScope(0),this.expect(types$1.parenL),this.type===types$1.semi)return awaitAt>-1&&this.unexpected(awaitAt),this.parseFor(node,null);var isLet=this.isLet();if(this.type===types$1._var||this.type===types$1._const||isLet){var init$1=this.startNode(),kind=isLet?"let":this.value;return this.next(),this.parseVar(init$1,true,kind),this.finishNode(init$1,"VariableDeclaration"),(this.type===types$1._in||this.options.ecmaVersion>=6&&this.isContextual("of"))&&1===init$1.declarations.length?(this.options.ecmaVersion>=9&&(this.type===types$1._in?awaitAt>-1&&this.unexpected(awaitAt):node.await=awaitAt>-1),this.parseForIn(node,init$1)):(awaitAt>-1&&this.unexpected(awaitAt),this.parseFor(node,init$1))}var startsWithLet=this.isContextual("let"),isForOf=false,containsEsc=this.containsEsc,refDestructuringErrors=new DestructuringErrors,initPos=this.start,init=awaitAt>-1?this.parseExprSubscripts(refDestructuringErrors,"await"):this.parseExpression(true,refDestructuringErrors);return this.type===types$1._in||(isForOf=this.options.ecmaVersion>=6&&this.isContextual("of"))?(awaitAt>-1?(this.type===types$1._in&&this.unexpected(awaitAt),node.await=true):isForOf&&this.options.ecmaVersion>=8&&(init.start!==initPos||containsEsc||"Identifier"!==init.type||"async"!==init.name?this.options.ecmaVersion>=9&&(node.await=false):this.unexpected()),startsWithLet&&isForOf&&this.raise(init.start,"The left-hand side of a for-of loop may not start with 'let'."),this.toAssignable(init,false,refDestructuringErrors),this.checkLValPattern(init),this.parseForIn(node,init)):(this.checkExpressionErrors(refDestructuringErrors,true),awaitAt>-1&&this.unexpected(awaitAt),this.parseFor(node,init))},pp$8.parseFunctionStatement=function(node,isAsync,declarationPosition){return this.next(),this.parseFunction(node,FUNC_STATEMENT|(declarationPosition?0:FUNC_HANGING_STATEMENT),false,isAsync)},pp$8.parseIfStatement=function(node){return this.next(),node.test=this.parseParenExpression(),node.consequent=this.parseStatement("if"),node.alternate=this.eat(types$1._else)?this.parseStatement("if"):null,this.finishNode(node,"IfStatement")},pp$8.parseReturnStatement=function(node){return this.inFunction||this.options.allowReturnOutsideFunction||this.raise(this.start,"'return' outside of function"),this.next(),this.eat(types$1.semi)||this.insertSemicolon()?node.argument=null:(node.argument=this.parseExpression(),this.semicolon()),this.finishNode(node,"ReturnStatement")},pp$8.parseSwitchStatement=function(node){var cur;this.next(),node.discriminant=this.parseParenExpression(),node.cases=[],this.expect(types$1.braceL),this.labels.push(switchLabel),this.enterScope(0);for(var sawDefault=false;this.type!==types$1.braceR;)if(this.type===types$1._case||this.type===types$1._default){var isCase=this.type===types$1._case;cur&&this.finishNode(cur,"SwitchCase"),node.cases.push(cur=this.startNode()),cur.consequent=[],this.next(),isCase?cur.test=this.parseExpression():(sawDefault&&this.raiseRecoverable(this.lastTokStart,"Multiple default clauses"),sawDefault=true,cur.test=null),this.expect(types$1.colon);}else cur||this.unexpected(),cur.consequent.push(this.parseStatement(null));return this.exitScope(),cur&&this.finishNode(cur,"SwitchCase"),this.next(),this.labels.pop(),this.finishNode(node,"SwitchStatement")},pp$8.parseThrowStatement=function(node){return this.next(),lineBreak.test(this.input.slice(this.lastTokEnd,this.start))&&this.raise(this.lastTokEnd,"Illegal newline after throw"),node.argument=this.parseExpression(),this.semicolon(),this.finishNode(node,"ThrowStatement")};var empty$1=[];pp$8.parseCatchClauseParam=function(){var param=this.parseBindingAtom(),simple="Identifier"===param.type;return this.enterScope(simple?32:0),this.checkLValPattern(param,simple?4:2),this.expect(types$1.parenR),param},pp$8.parseTryStatement=function(node){if(this.next(),node.block=this.parseBlock(),node.handler=null,this.type===types$1._catch){var clause=this.startNode();this.next(),this.eat(types$1.parenL)?clause.param=this.parseCatchClauseParam():(this.options.ecmaVersion<10&&this.unexpected(),clause.param=null,this.enterScope(0)),clause.body=this.parseBlock(false),this.exitScope(),node.handler=this.finishNode(clause,"CatchClause");}return node.finalizer=this.eat(types$1._finally)?this.parseBlock():null,node.handler||node.finalizer||this.raise(node.start,"Missing catch or finally clause"),this.finishNode(node,"TryStatement")},pp$8.parseVarStatement=function(node,kind,allowMissingInitializer){return this.next(),this.parseVar(node,false,kind,allowMissingInitializer),this.semicolon(),this.finishNode(node,"VariableDeclaration")},pp$8.parseWhileStatement=function(node){return this.next(),node.test=this.parseParenExpression(),this.labels.push(loopLabel),node.body=this.parseStatement("while"),this.labels.pop(),this.finishNode(node,"WhileStatement")},pp$8.parseWithStatement=function(node){return this.strict&&this.raise(this.start,"'with' in strict mode"),this.next(),node.object=this.parseParenExpression(),node.body=this.parseStatement("with"),this.finishNode(node,"WithStatement")},pp$8.parseEmptyStatement=function(node){return this.next(),this.finishNode(node,"EmptyStatement")},pp$8.parseLabeledStatement=function(node,maybeName,expr,context){for(var i$1=0,list=this.labels;i$1<list.length;i$1+=1){list[i$1].name===maybeName&&this.raise(expr.start,"Label '"+maybeName+"' is already declared");}for(var kind=this.type.isLoop?"loop":this.type===types$1._switch?"switch":null,i=this.labels.length-1;i>=0;i--){var label$1=this.labels[i];if(label$1.statementStart!==node.start)break;label$1.statementStart=this.start,label$1.kind=kind;}return this.labels.push({name:maybeName,kind,statementStart:this.start}),node.body=this.parseStatement(context?-1===context.indexOf("label")?context+"label":context:"label"),this.labels.pop(),node.label=expr,this.finishNode(node,"LabeledStatement")},pp$8.parseExpressionStatement=function(node,expr){return node.expression=expr,this.semicolon(),this.finishNode(node,"ExpressionStatement")},pp$8.parseBlock=function(createNewLexicalScope,node,exitStrict){for(void 0===createNewLexicalScope&&(createNewLexicalScope=true),void 0===node&&(node=this.startNode()),node.body=[],this.expect(types$1.braceL),createNewLexicalScope&&this.enterScope(0);this.type!==types$1.braceR;){var stmt=this.parseStatement(null);node.body.push(stmt);}return exitStrict&&(this.strict=false),this.next(),createNewLexicalScope&&this.exitScope(),this.finishNode(node,"BlockStatement")},pp$8.parseFor=function(node,init){return node.init=init,this.expect(types$1.semi),node.test=this.type===types$1.semi?null:this.parseExpression(),this.expect(types$1.semi),node.update=this.type===types$1.parenR?null:this.parseExpression(),this.expect(types$1.parenR),node.body=this.parseStatement("for"),this.exitScope(),this.labels.pop(),this.finishNode(node,"ForStatement")},pp$8.parseForIn=function(node,init){var isForIn=this.type===types$1._in;return this.next(),"VariableDeclaration"===init.type&&null!=init.declarations[0].init&&(!isForIn||this.options.ecmaVersion<8||this.strict||"var"!==init.kind||"Identifier"!==init.declarations[0].id.type)&&this.raise(init.start,(isForIn?"for-in":"for-of")+" loop variable declaration may not have an initializer"),node.left=init,node.right=isForIn?this.parseExpression():this.parseMaybeAssign(),this.expect(types$1.parenR),node.body=this.parseStatement("for"),this.exitScope(),this.labels.pop(),this.finishNode(node,isForIn?"ForInStatement":"ForOfStatement")},pp$8.parseVar=function(node,isFor,kind,allowMissingInitializer){for(node.declarations=[],node.kind=kind;;){var decl=this.startNode();if(this.parseVarId(decl,kind),this.eat(types$1.eq)?decl.init=this.parseMaybeAssign(isFor):allowMissingInitializer||"const"!==kind||this.type===types$1._in||this.options.ecmaVersion>=6&&this.isContextual("of")?allowMissingInitializer||"Identifier"===decl.id.type||isFor&&(this.type===types$1._in||this.isContextual("of"))?decl.init=null:this.raise(this.lastTokEnd,"Complex binding patterns require an initialization value"):this.unexpected(),node.declarations.push(this.finishNode(decl,"VariableDeclarator")),!this.eat(types$1.comma))break}return node},pp$8.parseVarId=function(decl,kind){decl.id=this.parseBindingAtom(),this.checkLValPattern(decl.id,"var"===kind?1:2,false);};var FUNC_STATEMENT=1,FUNC_HANGING_STATEMENT=2;function isPrivateNameConflicted(privateNameMap,element){var name=element.key.name,curr=privateNameMap[name],next="true";return "MethodDefinition"!==element.type||"get"!==element.kind&&"set"!==element.kind||(next=(element.static?"s":"i")+element.kind),"iget"===curr&&"iset"===next||"iset"===curr&&"iget"===next||"sget"===curr&&"sset"===next||"sset"===curr&&"sget"===next?(privateNameMap[name]="true",false):!!curr||(privateNameMap[name]=next,false)}function checkKeyName(node,name){var computed=node.computed,key=node.key;return !computed&&("Identifier"===key.type&&key.name===name||"Literal"===key.type&&key.value===name)}pp$8.parseFunction=function(node,statement,allowExpressionBody,isAsync,forInit){this.initFunction(node),(this.options.ecmaVersion>=9||this.options.ecmaVersion>=6&&!isAsync)&&(this.type===types$1.star&&statement&FUNC_HANGING_STATEMENT&&this.unexpected(),node.generator=this.eat(types$1.star)),this.options.ecmaVersion>=8&&(node.async=!!isAsync),statement&FUNC_STATEMENT&&(node.id=4&statement&&this.type!==types$1.name?null:this.parseIdent(),!node.id||statement&FUNC_HANGING_STATEMENT||this.checkLValSimple(node.id,this.strict||node.generator||node.async?this.treatFunctionsAsVar?1:2:3));var oldYieldPos=this.yieldPos,oldAwaitPos=this.awaitPos,oldAwaitIdentPos=this.awaitIdentPos;return this.yieldPos=0,this.awaitPos=0,this.awaitIdentPos=0,this.enterScope(functionFlags(node.async,node.generator)),statement&FUNC_STATEMENT||(node.id=this.type===types$1.name?this.parseIdent():null),this.parseFunctionParams(node),this.parseFunctionBody(node,allowExpressionBody,false,forInit),this.yieldPos=oldYieldPos,this.awaitPos=oldAwaitPos,this.awaitIdentPos=oldAwaitIdentPos,this.finishNode(node,statement&FUNC_STATEMENT?"FunctionDeclaration":"FunctionExpression")},pp$8.parseFunctionParams=function(node){this.expect(types$1.parenL),node.params=this.parseBindingList(types$1.parenR,false,this.options.ecmaVersion>=8),this.checkYieldAwaitInDefaultParams();},pp$8.parseClass=function(node,isStatement){this.next();var oldStrict=this.strict;this.strict=true,this.parseClassId(node,isStatement),this.parseClassSuper(node);var privateNameMap=this.enterClassBody(),classBody=this.startNode(),hadConstructor=false;for(classBody.body=[],this.expect(types$1.braceL);this.type!==types$1.braceR;){var element=this.parseClassElement(null!==node.superClass);element&&(classBody.body.push(element),"MethodDefinition"===element.type&&"constructor"===element.kind?(hadConstructor&&this.raiseRecoverable(element.start,"Duplicate constructor in the same class"),hadConstructor=true):element.key&&"PrivateIdentifier"===element.key.type&&isPrivateNameConflicted(privateNameMap,element)&&this.raiseRecoverable(element.key.start,"Identifier '#"+element.key.name+"' has already been declared"));}return this.strict=oldStrict,this.next(),node.body=this.finishNode(classBody,"ClassBody"),this.exitClassBody(),this.finishNode(node,isStatement?"ClassDeclaration":"ClassExpression")},pp$8.parseClassElement=function(constructorAllowsSuper){if(this.eat(types$1.semi))return null;var ecmaVersion=this.options.ecmaVersion,node=this.startNode(),keyName="",isGenerator=false,isAsync=false,kind="method",isStatic=false;if(this.eatContextual("static")){if(ecmaVersion>=13&&this.eat(types$1.braceL))return this.parseClassStaticBlock(node),node;this.isClassElementNameStart()||this.type===types$1.star?isStatic=true:keyName="static";}if(node.static=isStatic,!keyName&&ecmaVersion>=8&&this.eatContextual("async")&&(!this.isClassElementNameStart()&&this.type!==types$1.star||this.canInsertSemicolon()?keyName="async":isAsync=true),!keyName&&(ecmaVersion>=9||!isAsync)&&this.eat(types$1.star)&&(isGenerator=true),!keyName&&!isAsync&&!isGenerator){var lastValue=this.value;(this.eatContextual("get")||this.eatContextual("set"))&&(this.isClassElementNameStart()?kind=lastValue:keyName=lastValue);}if(keyName?(node.computed=false,node.key=this.startNodeAt(this.lastTokStart,this.lastTokStartLoc),node.key.name=keyName,this.finishNode(node.key,"Identifier")):this.parseClassElementName(node),ecmaVersion<13||this.type===types$1.parenL||"method"!==kind||isGenerator||isAsync){var isConstructor=!node.static&&checkKeyName(node,"constructor"),allowsDirectSuper=isConstructor&&constructorAllowsSuper;isConstructor&&"method"!==kind&&this.raise(node.key.start,"Constructor can't have get/set modifier"),node.kind=isConstructor?"constructor":kind,this.parseClassMethod(node,isGenerator,isAsync,allowsDirectSuper);}else this.parseClassField(node);return node},pp$8.isClassElementNameStart=function(){return this.type===types$1.name||this.type===types$1.privateId||this.type===types$1.num||this.type===types$1.string||this.type===types$1.bracketL||this.type.keyword},pp$8.parseClassElementName=function(element){this.type===types$1.privateId?("constructor"===this.value&&this.raise(this.start,"Classes can't have an element named '#constructor'"),element.computed=false,element.key=this.parsePrivateIdent()):this.parsePropertyName(element);},pp$8.parseClassMethod=function(method,isGenerator,isAsync,allowsDirectSuper){var key=method.key;"constructor"===method.kind?(isGenerator&&this.raise(key.start,"Constructor can't be a generator"),isAsync&&this.raise(key.start,"Constructor can't be an async method")):method.static&&checkKeyName(method,"prototype")&&this.raise(key.start,"Classes may not have a static property named prototype");var value=method.value=this.parseMethod(isGenerator,isAsync,allowsDirectSuper);return "get"===method.kind&&0!==value.params.length&&this.raiseRecoverable(value.start,"getter should have no params"),"set"===method.kind&&1!==value.params.length&&this.raiseRecoverable(value.start,"setter should have exactly one param"),"set"===method.kind&&"RestElement"===value.params[0].type&&this.raiseRecoverable(value.params[0].start,"Setter cannot use rest params"),this.finishNode(method,"MethodDefinition")},pp$8.parseClassField=function(field){if(checkKeyName(field,"constructor")?this.raise(field.key.start,"Classes can't have a field named 'constructor'"):field.static&&checkKeyName(field,"prototype")&&this.raise(field.key.start,"Classes can't have a static field named 'prototype'"),this.eat(types$1.eq)){var scope=this.currentThisScope(),inClassFieldInit=scope.inClassFieldInit;scope.inClassFieldInit=true,field.value=this.parseMaybeAssign(),scope.inClassFieldInit=inClassFieldInit;}else field.value=null;return this.semicolon(),this.finishNode(field,"PropertyDefinition")},pp$8.parseClassStaticBlock=function(node){node.body=[];var oldLabels=this.labels;for(this.labels=[],this.enterScope(320);this.type!==types$1.braceR;){var stmt=this.parseStatement(null);node.body.push(stmt);}return this.next(),this.exitScope(),this.labels=oldLabels,this.finishNode(node,"StaticBlock")},pp$8.parseClassId=function(node,isStatement){this.type===types$1.name?(node.id=this.parseIdent(),isStatement&&this.checkLValSimple(node.id,2,false)):(true===isStatement&&this.unexpected(),node.id=null);},pp$8.parseClassSuper=function(node){node.superClass=this.eat(types$1._extends)?this.parseExprSubscripts(null,false):null;},pp$8.enterClassBody=function(){var element={declared:Object.create(null),used:[]};return this.privateNameStack.push(element),element.declared},pp$8.exitClassBody=function(){var ref=this.privateNameStack.pop(),declared=ref.declared,used=ref.used;if(this.options.checkPrivateFields)for(var len=this.privateNameStack.length,parent=0===len?null:this.privateNameStack[len-1],i=0;i<used.length;++i){var id=used[i];hasOwn(declared,id.name)||(parent?parent.used.push(id):this.raiseRecoverable(id.start,"Private field '#"+id.name+"' must be declared in an enclosing class"));}},pp$8.parseExportAllDeclaration=function(node,exports){return this.options.ecmaVersion>=11&&(this.eatContextual("as")?(node.exported=this.parseModuleExportName(),this.checkExport(exports,node.exported,this.lastTokStart)):node.exported=null),this.expectContextual("from"),this.type!==types$1.string&&this.unexpected(),node.source=this.parseExprAtom(),this.options.ecmaVersion>=16&&(node.attributes=this.parseWithClause()),this.semicolon(),this.finishNode(node,"ExportAllDeclaration")},pp$8.parseExport=function(node,exports){if(this.next(),this.eat(types$1.star))return this.parseExportAllDeclaration(node,exports);if(this.eat(types$1._default))return this.checkExport(exports,"default",this.lastTokStart),node.declaration=this.parseExportDefaultDeclaration(),this.finishNode(node,"ExportDefaultDeclaration");if(this.shouldParseExportStatement())node.declaration=this.parseExportDeclaration(node),"VariableDeclaration"===node.declaration.type?this.checkVariableExport(exports,node.declaration.declarations):this.checkExport(exports,node.declaration.id,node.declaration.id.start),node.specifiers=[],node.source=null;else {if(node.declaration=null,node.specifiers=this.parseExportSpecifiers(exports),this.eatContextual("from"))this.type!==types$1.string&&this.unexpected(),node.source=this.parseExprAtom(),this.options.ecmaVersion>=16&&(node.attributes=this.parseWithClause());else {for(var i=0,list=node.specifiers;i<list.length;i+=1){var spec=list[i];this.checkUnreserved(spec.local),this.checkLocalExport(spec.local),"Literal"===spec.local.type&&this.raise(spec.local.start,"A string literal cannot be used as an exported binding without `from`.");}node.source=null;}this.semicolon();}return this.finishNode(node,"ExportNamedDeclaration")},pp$8.parseExportDeclaration=function(node){return this.parseStatement(null)},pp$8.parseExportDefaultDeclaration=function(){var isAsync;if(this.type===types$1._function||(isAsync=this.isAsyncFunction())){var fNode=this.startNode();return this.next(),isAsync&&this.next(),this.parseFunction(fNode,4|FUNC_STATEMENT,false,isAsync)}if(this.type===types$1._class){var cNode=this.startNode();return this.parseClass(cNode,"nullableID")}var declaration=this.parseMaybeAssign();return this.semicolon(),declaration},pp$8.checkExport=function(exports,name,pos){exports&&("string"!=typeof name&&(name="Identifier"===name.type?name.name:name.value),hasOwn(exports,name)&&this.raiseRecoverable(pos,"Duplicate export '"+name+"'"),exports[name]=true);},pp$8.checkPatternExport=function(exports,pat){var type=pat.type;if("Identifier"===type)this.checkExport(exports,pat,pat.start);else if("ObjectPattern"===type)for(var i=0,list=pat.properties;i<list.length;i+=1){var prop=list[i];this.checkPatternExport(exports,prop);}else if("ArrayPattern"===type)for(var i$1=0,list$1=pat.elements;i$1<list$1.length;i$1+=1){var elt=list$1[i$1];elt&&this.checkPatternExport(exports,elt);}else "Property"===type?this.checkPatternExport(exports,pat.value):"AssignmentPattern"===type?this.checkPatternExport(exports,pat.left):"RestElement"===type&&this.checkPatternExport(exports,pat.argument);},pp$8.checkVariableExport=function(exports,decls){if(exports)for(var i=0,list=decls;i<list.length;i+=1){var decl=list[i];this.checkPatternExport(exports,decl.id);}},pp$8.shouldParseExportStatement=function(){return "var"===this.type.keyword||"const"===this.type.keyword||"class"===this.type.keyword||"function"===this.type.keyword||this.isLet()||this.isAsyncFunction()},pp$8.parseExportSpecifier=function(exports){var node=this.startNode();return node.local=this.parseModuleExportName(),node.exported=this.eatContextual("as")?this.parseModuleExportName():node.local,this.checkExport(exports,node.exported,node.exported.start),this.finishNode(node,"ExportSpecifier")},pp$8.parseExportSpecifiers=function(exports){var nodes=[],first=true;for(this.expect(types$1.braceL);!this.eat(types$1.braceR);){if(first)first=false;else if(this.expect(types$1.comma),this.afterTrailingComma(types$1.braceR))break;nodes.push(this.parseExportSpecifier(exports));}return nodes},pp$8.parseImport=function(node){return this.next(),this.type===types$1.string?(node.specifiers=empty$1,node.source=this.parseExprAtom()):(node.specifiers=this.parseImportSpecifiers(),this.expectContextual("from"),node.source=this.type===types$1.string?this.parseExprAtom():this.unexpected()),this.options.ecmaVersion>=16&&(node.attributes=this.parseWithClause()),this.semicolon(),this.finishNode(node,"ImportDeclaration")},pp$8.parseImportSpecifier=function(){var node=this.startNode();return node.imported=this.parseModuleExportName(),this.eatContextual("as")?node.local=this.parseIdent():(this.checkUnreserved(node.imported),node.local=node.imported),this.checkLValSimple(node.local,2),this.finishNode(node,"ImportSpecifier")},pp$8.parseImportDefaultSpecifier=function(){var node=this.startNode();return node.local=this.parseIdent(),this.checkLValSimple(node.local,2),this.finishNode(node,"ImportDefaultSpecifier")},pp$8.parseImportNamespaceSpecifier=function(){var node=this.startNode();return this.next(),this.expectContextual("as"),node.local=this.parseIdent(),this.checkLValSimple(node.local,2),this.finishNode(node,"ImportNamespaceSpecifier")},pp$8.parseImportSpecifiers=function(){var nodes=[],first=true;if(this.type===types$1.name&&(nodes.push(this.parseImportDefaultSpecifier()),!this.eat(types$1.comma)))return nodes;if(this.type===types$1.star)return nodes.push(this.parseImportNamespaceSpecifier()),nodes;for(this.expect(types$1.braceL);!this.eat(types$1.braceR);){if(first)first=false;else if(this.expect(types$1.comma),this.afterTrailingComma(types$1.braceR))break;nodes.push(this.parseImportSpecifier());}return nodes},pp$8.parseWithClause=function(){var nodes=[];if(!this.eat(types$1._with))return nodes;this.expect(types$1.braceL);for(var attributeKeys={},first=true;!this.eat(types$1.braceR);){if(first)first=false;else if(this.expect(types$1.comma),this.afterTrailingComma(types$1.braceR))break;var attr=this.parseImportAttribute(),keyName="Identifier"===attr.key.type?attr.key.name:attr.key.value;hasOwn(attributeKeys,keyName)&&this.raiseRecoverable(attr.key.start,"Duplicate attribute key '"+keyName+"'"),attributeKeys[keyName]=true,nodes.push(attr);}return nodes},pp$8.parseImportAttribute=function(){var node=this.startNode();return node.key=this.type===types$1.string?this.parseExprAtom():this.parseIdent("never"!==this.options.allowReserved),this.expect(types$1.colon),this.type!==types$1.string&&this.unexpected(),node.value=this.parseExprAtom(),this.finishNode(node,"ImportAttribute")},pp$8.parseModuleExportName=function(){if(this.options.ecmaVersion>=13&&this.type===types$1.string){var stringLiteral=this.parseLiteral(this.value);return loneSurrogate.test(stringLiteral.value)&&this.raise(stringLiteral.start,"An export name cannot include a lone surrogate."),stringLiteral}return this.parseIdent(true)},pp$8.adaptDirectivePrologue=function(statements){for(var i=0;i<statements.length&&this.isDirectiveCandidate(statements[i]);++i)statements[i].directive=statements[i].expression.raw.slice(1,-1);},pp$8.isDirectiveCandidate=function(statement){return this.options.ecmaVersion>=5&&"ExpressionStatement"===statement.type&&"Literal"===statement.expression.type&&"string"==typeof statement.expression.value&&('"'===this.input[statement.start]||"'"===this.input[statement.start])};var pp$7=Parser.prototype;pp$7.toAssignable=function(node,isBinding,refDestructuringErrors){if(this.options.ecmaVersion>=6&&node)switch(node.type){case "Identifier":this.inAsync&&"await"===node.name&&this.raise(node.start,"Cannot use 'await' as identifier inside an async function");break;case "ObjectPattern":case "ArrayPattern":case "AssignmentPattern":case "RestElement":break;case "ObjectExpression":node.type="ObjectPattern",refDestructuringErrors&&this.checkPatternErrors(refDestructuringErrors,true);for(var i=0,list=node.properties;i<list.length;i+=1){var prop=list[i];this.toAssignable(prop,isBinding),"RestElement"!==prop.type||"ArrayPattern"!==prop.argument.type&&"ObjectPattern"!==prop.argument.type||this.raise(prop.argument.start,"Unexpected token");}break;case "Property":"init"!==node.kind&&this.raise(node.key.start,"Object pattern can't contain getter or setter"),this.toAssignable(node.value,isBinding);break;case "ArrayExpression":node.type="ArrayPattern",refDestructuringErrors&&this.checkPatternErrors(refDestructuringErrors,true),this.toAssignableList(node.elements,isBinding);break;case "SpreadElement":node.type="RestElement",this.toAssignable(node.argument,isBinding),"AssignmentPattern"===node.argument.type&&this.raise(node.argument.start,"Rest elements cannot have a default value");break;case "AssignmentExpression":"="!==node.operator&&this.raise(node.left.end,"Only '=' operator can be used for specifying default value."),node.type="AssignmentPattern",delete node.operator,this.toAssignable(node.left,isBinding);break;case "ParenthesizedExpression":this.toAssignable(node.expression,isBinding,refDestructuringErrors);break;case "ChainExpression":this.raiseRecoverable(node.start,"Optional chaining cannot appear in left-hand side");break;case "MemberExpression":if(!isBinding)break;default:this.raise(node.start,"Assigning to rvalue");}else refDestructuringErrors&&this.checkPatternErrors(refDestructuringErrors,true);return node},pp$7.toAssignableList=function(exprList,isBinding){for(var end=exprList.length,i=0;i<end;i++){var elt=exprList[i];elt&&this.toAssignable(elt,isBinding);}if(end){var last=exprList[end-1];6===this.options.ecmaVersion&&isBinding&&last&&"RestElement"===last.type&&"Identifier"!==last.argument.type&&this.unexpected(last.argument.start);}return exprList},pp$7.parseSpread=function(refDestructuringErrors){var node=this.startNode();return this.next(),node.argument=this.parseMaybeAssign(false,refDestructuringErrors),this.finishNode(node,"SpreadElement")},pp$7.parseRestBinding=function(){var node=this.startNode();return this.next(),6===this.options.ecmaVersion&&this.type!==types$1.name&&this.unexpected(),node.argument=this.parseBindingAtom(),this.finishNode(node,"RestElement")},pp$7.parseBindingAtom=function(){if(this.options.ecmaVersion>=6)switch(this.type){case types$1.bracketL:var node=this.startNode();return this.next(),node.elements=this.parseBindingList(types$1.bracketR,true,true),this.finishNode(node,"ArrayPattern");case types$1.braceL:return this.parseObj(true)}return this.parseIdent()},pp$7.parseBindingList=function(close,allowEmpty,allowTrailingComma,allowModifiers){for(var elts=[],first=true;!this.eat(close);)if(first?first=false:this.expect(types$1.comma),allowEmpty&&this.type===types$1.comma)elts.push(null);else {if(allowTrailingComma&&this.afterTrailingComma(close))break;if(this.type===types$1.ellipsis){var rest=this.parseRestBinding();this.parseBindingListItem(rest),elts.push(rest),this.type===types$1.comma&&this.raiseRecoverable(this.start,"Comma is not permitted after the rest element"),this.expect(close);break}elts.push(this.parseAssignableListItem(allowModifiers));}return elts},pp$7.parseAssignableListItem=function(allowModifiers){var elem=this.parseMaybeDefault(this.start,this.startLoc);return this.parseBindingListItem(elem),elem},pp$7.parseBindingListItem=function(param){return param},pp$7.parseMaybeDefault=function(startPos,startLoc,left){if(left=left||this.parseBindingAtom(),this.options.ecmaVersion<6||!this.eat(types$1.eq))return left;var node=this.startNodeAt(startPos,startLoc);return node.left=left,node.right=this.parseMaybeAssign(),this.finishNode(node,"AssignmentPattern")},pp$7.checkLValSimple=function(expr,bindingType,checkClashes){ void 0===bindingType&&(bindingType=0);var isBind=0!==bindingType;switch(expr.type){case "Identifier":this.strict&&this.reservedWordsStrictBind.test(expr.name)&&this.raiseRecoverable(expr.start,(isBind?"Binding ":"Assigning to ")+expr.name+" in strict mode"),isBind&&(2===bindingType&&"let"===expr.name&&this.raiseRecoverable(expr.start,"let is disallowed as a lexically bound name"),checkClashes&&(hasOwn(checkClashes,expr.name)&&this.raiseRecoverable(expr.start,"Argument name clash"),checkClashes[expr.name]=true),5!==bindingType&&this.declareName(expr.name,bindingType,expr.start));break;case "ChainExpression":this.raiseRecoverable(expr.start,"Optional chaining cannot appear in left-hand side");break;case "MemberExpression":isBind&&this.raiseRecoverable(expr.start,"Binding member expression");break;case "ParenthesizedExpression":return isBind&&this.raiseRecoverable(expr.start,"Binding parenthesized expression"),this.checkLValSimple(expr.expression,bindingType,checkClashes);default:this.raise(expr.start,(isBind?"Binding":"Assigning to")+" rvalue");}},pp$7.checkLValPattern=function(expr,bindingType,checkClashes){switch(void 0===bindingType&&(bindingType=0),expr.type){case "ObjectPattern":for(var i=0,list=expr.properties;i<list.length;i+=1){var prop=list[i];this.checkLValInnerPattern(prop,bindingType,checkClashes);}break;case "ArrayPattern":for(var i$1=0,list$1=expr.elements;i$1<list$1.length;i$1+=1){var elem=list$1[i$1];elem&&this.checkLValInnerPattern(elem,bindingType,checkClashes);}break;default:this.checkLValSimple(expr,bindingType,checkClashes);}},pp$7.checkLValInnerPattern=function(expr,bindingType,checkClashes){switch(void 0===bindingType&&(bindingType=0),expr.type){case "Property":this.checkLValInnerPattern(expr.value,bindingType,checkClashes);break;case "AssignmentPattern":this.checkLValPattern(expr.left,bindingType,checkClashes);break;case "RestElement":this.checkLValPattern(expr.argument,bindingType,checkClashes);break;default:this.checkLValPattern(expr,bindingType,checkClashes);}};var TokContext=function(token,isExpr,preserveSpace,override,generator){this.token=token,this.isExpr=!!isExpr,this.preserveSpace=!!preserveSpace,this.override=override,this.generator=!!generator;},types={b_stat:new TokContext("{",false),b_expr:new TokContext("{",true),b_tmpl:new TokContext("${",false),p_stat:new TokContext("(",false),p_expr:new TokContext("(",true),q_tmpl:new TokContext("`",true,true,(function(p){return p.tryReadTemplateToken()})),f_stat:new TokContext("function",false),f_expr:new TokContext("function",true),f_expr_gen:new TokContext("function",true,false,null,true),f_gen:new TokContext("function",false,false,null,true)},pp$6=Parser.prototype;pp$6.initialContext=function(){return [types.b_stat]},pp$6.curContext=function(){return this.context[this.context.length-1]},pp$6.braceIsBlock=function(prevType){var parent=this.curContext();return parent===types.f_expr||parent===types.f_stat||(prevType!==types$1.colon||parent!==types.b_stat&&parent!==types.b_expr?prevType===types$1._return||prevType===types$1.name&&this.exprAllowed?lineBreak.test(this.input.slice(this.lastTokEnd,this.start)):prevType===types$1._else||prevType===types$1.semi||prevType===types$1.eof||prevType===types$1.parenR||prevType===types$1.arrow||(prevType===types$1.braceL?parent===types.b_stat:prevType!==types$1._var&&prevType!==types$1._const&&prevType!==types$1.name&&!this.exprAllowed):!parent.isExpr)},pp$6.inGeneratorContext=function(){for(var i=this.context.length-1;i>=1;i--){var context=this.context[i];if("function"===context.token)return context.generator}return  false},pp$6.updateContext=function(prevType){var update,type=this.type;type.keyword&&prevType===types$1.dot?this.exprAllowed=false:(update=type.updateContext)?update.call(this,prevType):this.exprAllowed=type.beforeExpr;},pp$6.overrideContext=function(tokenCtx){this.curContext()!==tokenCtx&&(this.context[this.context.length-1]=tokenCtx);},types$1.parenR.updateContext=types$1.braceR.updateContext=function(){if(1!==this.context.length){var out=this.context.pop();out===types.b_stat&&"function"===this.curContext().token&&(out=this.context.pop()),this.exprAllowed=!out.isExpr;}else this.exprAllowed=true;},types$1.braceL.updateContext=function(prevType){this.context.push(this.braceIsBlock(prevType)?types.b_stat:types.b_expr),this.exprAllowed=true;},types$1.dollarBraceL.updateContext=function(){this.context.push(types.b_tmpl),this.exprAllowed=true;},types$1.parenL.updateContext=function(prevType){var statementParens=prevType===types$1._if||prevType===types$1._for||prevType===types$1._with||prevType===types$1._while;this.context.push(statementParens?types.p_stat:types.p_expr),this.exprAllowed=true;},types$1.incDec.updateContext=function(){},types$1._function.updateContext=types$1._class.updateContext=function(prevType){!prevType.beforeExpr||prevType===types$1._else||prevType===types$1.semi&&this.curContext()!==types.p_stat||prevType===types$1._return&&lineBreak.test(this.input.slice(this.lastTokEnd,this.start))||(prevType===types$1.colon||prevType===types$1.braceL)&&this.curContext()===types.b_stat?this.context.push(types.f_stat):this.context.push(types.f_expr),this.exprAllowed=false;},types$1.colon.updateContext=function(){"function"===this.curContext().token&&this.context.pop(),this.exprAllowed=true;},types$1.backQuote.updateContext=function(){this.curContext()===types.q_tmpl?this.context.pop():this.context.push(types.q_tmpl),this.exprAllowed=false;},types$1.star.updateContext=function(prevType){if(prevType===types$1._function){var index=this.context.length-1;this.context[index]===types.f_expr?this.context[index]=types.f_expr_gen:this.context[index]=types.f_gen;}this.exprAllowed=true;},types$1.name.updateContext=function(prevType){var allowed=false;this.options.ecmaVersion>=6&&prevType!==types$1.dot&&("of"===this.value&&!this.exprAllowed||"yield"===this.value&&this.inGeneratorContext())&&(allowed=true),this.exprAllowed=allowed;};var pp$5=Parser.prototype;function isLocalVariableAccess(node){return "Identifier"===node.type||"ParenthesizedExpression"===node.type&&isLocalVariableAccess(node.expression)}function isPrivateFieldAccess(node){return "MemberExpression"===node.type&&"PrivateIdentifier"===node.property.type||"ChainExpression"===node.type&&isPrivateFieldAccess(node.expression)||"ParenthesizedExpression"===node.type&&isPrivateFieldAccess(node.expression)}pp$5.checkPropClash=function(prop,propHash,refDestructuringErrors){if(!(this.options.ecmaVersion>=9&&"SpreadElement"===prop.type||this.options.ecmaVersion>=6&&(prop.computed||prop.method||prop.shorthand))){var name,key=prop.key;switch(key.type){case "Identifier":name=key.name;break;case "Literal":name=String(key.value);break;default:return}var kind=prop.kind;if(this.options.ecmaVersion>=6)"__proto__"===name&&"init"===kind&&(propHash.proto&&(refDestructuringErrors?refDestructuringErrors.doubleProto<0&&(refDestructuringErrors.doubleProto=key.start):this.raiseRecoverable(key.start,"Redefinition of __proto__ property")),propHash.proto=true);else {var other=propHash[name="$"+name];if(other)("init"===kind?this.strict&&other.init||other.get||other.set:other.init||other[kind])&&this.raiseRecoverable(key.start,"Redefinition of property");else other=propHash[name]={init:false,get:false,set:false};other[kind]=true;}}},pp$5.parseExpression=function(forInit,refDestructuringErrors){var startPos=this.start,startLoc=this.startLoc,expr=this.parseMaybeAssign(forInit,refDestructuringErrors);if(this.type===types$1.comma){var node=this.startNodeAt(startPos,startLoc);for(node.expressions=[expr];this.eat(types$1.comma);)node.expressions.push(this.parseMaybeAssign(forInit,refDestructuringErrors));return this.finishNode(node,"SequenceExpression")}return expr},pp$5.parseMaybeAssign=function(forInit,refDestructuringErrors,afterLeftParse){if(this.isContextual("yield")){if(this.inGenerator)return this.parseYield(forInit);this.exprAllowed=false;}var ownDestructuringErrors=false,oldParenAssign=-1,oldTrailingComma=-1,oldDoubleProto=-1;refDestructuringErrors?(oldParenAssign=refDestructuringErrors.parenthesizedAssign,oldTrailingComma=refDestructuringErrors.trailingComma,oldDoubleProto=refDestructuringErrors.doubleProto,refDestructuringErrors.parenthesizedAssign=refDestructuringErrors.trailingComma=-1):(refDestructuringErrors=new DestructuringErrors,ownDestructuringErrors=true);var startPos=this.start,startLoc=this.startLoc;this.type!==types$1.parenL&&this.type!==types$1.name||(this.potentialArrowAt=this.start,this.potentialArrowInForAwait="await"===forInit);var left=this.parseMaybeConditional(forInit,refDestructuringErrors);if(afterLeftParse&&(left=afterLeftParse.call(this,left,startPos,startLoc)),this.type.isAssign){var node=this.startNodeAt(startPos,startLoc);return node.operator=this.value,this.type===types$1.eq&&(left=this.toAssignable(left,false,refDestructuringErrors)),ownDestructuringErrors||(refDestructuringErrors.parenthesizedAssign=refDestructuringErrors.trailingComma=refDestructuringErrors.doubleProto=-1),refDestructuringErrors.shorthandAssign>=left.start&&(refDestructuringErrors.shorthandAssign=-1),this.type===types$1.eq?this.checkLValPattern(left):this.checkLValSimple(left),node.left=left,this.next(),node.right=this.parseMaybeAssign(forInit),oldDoubleProto>-1&&(refDestructuringErrors.doubleProto=oldDoubleProto),this.finishNode(node,"AssignmentExpression")}return ownDestructuringErrors&&this.checkExpressionErrors(refDestructuringErrors,true),oldParenAssign>-1&&(refDestructuringErrors.parenthesizedAssign=oldParenAssign),oldTrailingComma>-1&&(refDestructuringErrors.trailingComma=oldTrailingComma),left},pp$5.parseMaybeConditional=function(forInit,refDestructuringErrors){var startPos=this.start,startLoc=this.startLoc,expr=this.parseExprOps(forInit,refDestructuringErrors);if(this.checkExpressionErrors(refDestructuringErrors))return expr;if(this.eat(types$1.question)){var node=this.startNodeAt(startPos,startLoc);return node.test=expr,node.consequent=this.parseMaybeAssign(),this.expect(types$1.colon),node.alternate=this.parseMaybeAssign(forInit),this.finishNode(node,"ConditionalExpression")}return expr},pp$5.parseExprOps=function(forInit,refDestructuringErrors){var startPos=this.start,startLoc=this.startLoc,expr=this.parseMaybeUnary(refDestructuringErrors,false,false,forInit);return this.checkExpressionErrors(refDestructuringErrors)||expr.start===startPos&&"ArrowFunctionExpression"===expr.type?expr:this.parseExprOp(expr,startPos,startLoc,-1,forInit)},pp$5.parseExprOp=function(left,leftStartPos,leftStartLoc,minPrec,forInit){var prec=this.type.binop;if(null!=prec&&(!forInit||this.type!==types$1._in)&&prec>minPrec){var logical=this.type===types$1.logicalOR||this.type===types$1.logicalAND,coalesce=this.type===types$1.coalesce;coalesce&&(prec=types$1.logicalAND.binop);var op=this.value;this.next();var startPos=this.start,startLoc=this.startLoc,right=this.parseExprOp(this.parseMaybeUnary(null,false,false,forInit),startPos,startLoc,prec,forInit),node=this.buildBinary(leftStartPos,leftStartLoc,left,right,op,logical||coalesce);return (logical&&this.type===types$1.coalesce||coalesce&&(this.type===types$1.logicalOR||this.type===types$1.logicalAND))&&this.raiseRecoverable(this.start,"Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses"),this.parseExprOp(node,leftStartPos,leftStartLoc,minPrec,forInit)}return left},pp$5.buildBinary=function(startPos,startLoc,left,right,op,logical){"PrivateIdentifier"===right.type&&this.raise(right.start,"Private identifier can only be left side of binary expression");var node=this.startNodeAt(startPos,startLoc);return node.left=left,node.operator=op,node.right=right,this.finishNode(node,logical?"LogicalExpression":"BinaryExpression")},pp$5.parseMaybeUnary=function(refDestructuringErrors,sawUnary,incDec,forInit){var expr,startPos=this.start,startLoc=this.startLoc;if(this.isContextual("await")&&this.canAwait)expr=this.parseAwait(forInit),sawUnary=true;else if(this.type.prefix){var node=this.startNode(),update=this.type===types$1.incDec;node.operator=this.value,node.prefix=true,this.next(),node.argument=this.parseMaybeUnary(null,true,update,forInit),this.checkExpressionErrors(refDestructuringErrors,true),update?this.checkLValSimple(node.argument):this.strict&&"delete"===node.operator&&isLocalVariableAccess(node.argument)?this.raiseRecoverable(node.start,"Deleting local variable in strict mode"):"delete"===node.operator&&isPrivateFieldAccess(node.argument)?this.raiseRecoverable(node.start,"Private fields can not be deleted"):sawUnary=true,expr=this.finishNode(node,update?"UpdateExpression":"UnaryExpression");}else if(sawUnary||this.type!==types$1.privateId){if(expr=this.parseExprSubscripts(refDestructuringErrors,forInit),this.checkExpressionErrors(refDestructuringErrors))return expr;for(;this.type.postfix&&!this.canInsertSemicolon();){var node$1=this.startNodeAt(startPos,startLoc);node$1.operator=this.value,node$1.prefix=false,node$1.argument=expr,this.checkLValSimple(expr),this.next(),expr=this.finishNode(node$1,"UpdateExpression");}}else (forInit||0===this.privateNameStack.length)&&this.options.checkPrivateFields&&this.unexpected(),expr=this.parsePrivateIdent(),this.type!==types$1._in&&this.unexpected();return incDec||!this.eat(types$1.starstar)?expr:sawUnary?void this.unexpected(this.lastTokStart):this.buildBinary(startPos,startLoc,expr,this.parseMaybeUnary(null,false,false,forInit),"**",false)},pp$5.parseExprSubscripts=function(refDestructuringErrors,forInit){var startPos=this.start,startLoc=this.startLoc,expr=this.parseExprAtom(refDestructuringErrors,forInit);if("ArrowFunctionExpression"===expr.type&&")"!==this.input.slice(this.lastTokStart,this.lastTokEnd))return expr;var result=this.parseSubscripts(expr,startPos,startLoc,false,forInit);return refDestructuringErrors&&"MemberExpression"===result.type&&(refDestructuringErrors.parenthesizedAssign>=result.start&&(refDestructuringErrors.parenthesizedAssign=-1),refDestructuringErrors.parenthesizedBind>=result.start&&(refDestructuringErrors.parenthesizedBind=-1),refDestructuringErrors.trailingComma>=result.start&&(refDestructuringErrors.trailingComma=-1)),result},pp$5.parseSubscripts=function(base,startPos,startLoc,noCalls,forInit){for(var maybeAsyncArrow=this.options.ecmaVersion>=8&&"Identifier"===base.type&&"async"===base.name&&this.lastTokEnd===base.end&&!this.canInsertSemicolon()&&base.end-base.start==5&&this.potentialArrowAt===base.start,optionalChained=false;;){var element=this.parseSubscript(base,startPos,startLoc,noCalls,maybeAsyncArrow,optionalChained,forInit);if(element.optional&&(optionalChained=true),element===base||"ArrowFunctionExpression"===element.type){if(optionalChained){var chainNode=this.startNodeAt(startPos,startLoc);chainNode.expression=element,element=this.finishNode(chainNode,"ChainExpression");}return element}base=element;}},pp$5.shouldParseAsyncArrow=function(){return !this.canInsertSemicolon()&&this.eat(types$1.arrow)},pp$5.parseSubscriptAsyncArrow=function(startPos,startLoc,exprList,forInit){return this.parseArrowExpression(this.startNodeAt(startPos,startLoc),exprList,true,forInit)},pp$5.parseSubscript=function(base,startPos,startLoc,noCalls,maybeAsyncArrow,optionalChained,forInit){var optionalSupported=this.options.ecmaVersion>=11,optional=optionalSupported&&this.eat(types$1.questionDot);noCalls&&optional&&this.raise(this.lastTokStart,"Optional chaining cannot appear in the callee of new expressions");var computed=this.eat(types$1.bracketL);if(computed||optional&&this.type!==types$1.parenL&&this.type!==types$1.backQuote||this.eat(types$1.dot)){var node=this.startNodeAt(startPos,startLoc);node.object=base,computed?(node.property=this.parseExpression(),this.expect(types$1.bracketR)):this.type===types$1.privateId&&"Super"!==base.type?node.property=this.parsePrivateIdent():node.property=this.parseIdent("never"!==this.options.allowReserved),node.computed=!!computed,optionalSupported&&(node.optional=optional),base=this.finishNode(node,"MemberExpression");}else if(!noCalls&&this.eat(types$1.parenL)){var refDestructuringErrors=new DestructuringErrors,oldYieldPos=this.yieldPos,oldAwaitPos=this.awaitPos,oldAwaitIdentPos=this.awaitIdentPos;this.yieldPos=0,this.awaitPos=0,this.awaitIdentPos=0;var exprList=this.parseExprList(types$1.parenR,this.options.ecmaVersion>=8,false,refDestructuringErrors);if(maybeAsyncArrow&&!optional&&this.shouldParseAsyncArrow())return this.checkPatternErrors(refDestructuringErrors,false),this.checkYieldAwaitInDefaultParams(),this.awaitIdentPos>0&&this.raise(this.awaitIdentPos,"Cannot use 'await' as identifier inside an async function"),this.yieldPos=oldYieldPos,this.awaitPos=oldAwaitPos,this.awaitIdentPos=oldAwaitIdentPos,this.parseSubscriptAsyncArrow(startPos,startLoc,exprList,forInit);this.checkExpressionErrors(refDestructuringErrors,true),this.yieldPos=oldYieldPos||this.yieldPos,this.awaitPos=oldAwaitPos||this.awaitPos,this.awaitIdentPos=oldAwaitIdentPos||this.awaitIdentPos;var node$1=this.startNodeAt(startPos,startLoc);node$1.callee=base,node$1.arguments=exprList,optionalSupported&&(node$1.optional=optional),base=this.finishNode(node$1,"CallExpression");}else if(this.type===types$1.backQuote){(optional||optionalChained)&&this.raise(this.start,"Optional chaining cannot appear in the tag of tagged template expressions");var node$2=this.startNodeAt(startPos,startLoc);node$2.tag=base,node$2.quasi=this.parseTemplate({isTagged:true}),base=this.finishNode(node$2,"TaggedTemplateExpression");}return base},pp$5.parseExprAtom=function(refDestructuringErrors,forInit,forNew){this.type===types$1.slash&&this.readRegexp();var node,canBeArrow=this.potentialArrowAt===this.start;switch(this.type){case types$1._super:return this.allowSuper||this.raise(this.start,"'super' keyword outside a method"),node=this.startNode(),this.next(),this.type!==types$1.parenL||this.allowDirectSuper||this.raise(node.start,"super() call outside constructor of a subclass"),this.type!==types$1.dot&&this.type!==types$1.bracketL&&this.type!==types$1.parenL&&this.unexpected(),this.finishNode(node,"Super");case types$1._this:return node=this.startNode(),this.next(),this.finishNode(node,"ThisExpression");case types$1.name:var startPos=this.start,startLoc=this.startLoc,containsEsc=this.containsEsc,id=this.parseIdent(false);if(this.options.ecmaVersion>=8&&!containsEsc&&"async"===id.name&&!this.canInsertSemicolon()&&this.eat(types$1._function))return this.overrideContext(types.f_expr),this.parseFunction(this.startNodeAt(startPos,startLoc),0,false,true,forInit);if(canBeArrow&&!this.canInsertSemicolon()){if(this.eat(types$1.arrow))return this.parseArrowExpression(this.startNodeAt(startPos,startLoc),[id],false,forInit);if(this.options.ecmaVersion>=8&&"async"===id.name&&this.type===types$1.name&&!containsEsc&&(!this.potentialArrowInForAwait||"of"!==this.value||this.containsEsc))return id=this.parseIdent(false),!this.canInsertSemicolon()&&this.eat(types$1.arrow)||this.unexpected(),this.parseArrowExpression(this.startNodeAt(startPos,startLoc),[id],true,forInit)}return id;case types$1.regexp:var value=this.value;return (node=this.parseLiteral(value.value)).regex={pattern:value.pattern,flags:value.flags},node;case types$1.num:case types$1.string:return this.parseLiteral(this.value);case types$1._null:case types$1._true:case types$1._false:return (node=this.startNode()).value=this.type===types$1._null?null:this.type===types$1._true,node.raw=this.type.keyword,this.next(),this.finishNode(node,"Literal");case types$1.parenL:var start=this.start,expr=this.parseParenAndDistinguishExpression(canBeArrow,forInit);return refDestructuringErrors&&(refDestructuringErrors.parenthesizedAssign<0&&!this.isSimpleAssignTarget(expr)&&(refDestructuringErrors.parenthesizedAssign=start),refDestructuringErrors.parenthesizedBind<0&&(refDestructuringErrors.parenthesizedBind=start)),expr;case types$1.bracketL:return node=this.startNode(),this.next(),node.elements=this.parseExprList(types$1.bracketR,true,true,refDestructuringErrors),this.finishNode(node,"ArrayExpression");case types$1.braceL:return this.overrideContext(types.b_expr),this.parseObj(false,refDestructuringErrors);case types$1._function:return node=this.startNode(),this.next(),this.parseFunction(node,0);case types$1._class:return this.parseClass(this.startNode(),false);case types$1._new:return this.parseNew();case types$1.backQuote:return this.parseTemplate();case types$1._import:return this.options.ecmaVersion>=11?this.parseExprImport(forNew):this.unexpected();default:return this.parseExprAtomDefault()}},pp$5.parseExprAtomDefault=function(){this.unexpected();},pp$5.parseExprImport=function(forNew){var node=this.startNode();if(this.containsEsc&&this.raiseRecoverable(this.start,"Escape sequence in keyword import"),this.next(),this.type===types$1.parenL&&!forNew)return this.parseDynamicImport(node);if(this.type===types$1.dot){var meta=this.startNodeAt(node.start,node.loc&&node.loc.start);return meta.name="import",node.meta=this.finishNode(meta,"Identifier"),this.parseImportMeta(node)}this.unexpected();},pp$5.parseDynamicImport=function(node){if(this.next(),node.source=this.parseMaybeAssign(),this.options.ecmaVersion>=16)this.eat(types$1.parenR)?node.options=null:(this.expect(types$1.comma),this.afterTrailingComma(types$1.parenR)?node.options=null:(node.options=this.parseMaybeAssign(),this.eat(types$1.parenR)||(this.expect(types$1.comma),this.afterTrailingComma(types$1.parenR)||this.unexpected())));else if(!this.eat(types$1.parenR)){var errorPos=this.start;this.eat(types$1.comma)&&this.eat(types$1.parenR)?this.raiseRecoverable(errorPos,"Trailing comma is not allowed in import()"):this.unexpected(errorPos);}return this.finishNode(node,"ImportExpression")},pp$5.parseImportMeta=function(node){this.next();var containsEsc=this.containsEsc;return node.property=this.parseIdent(true),"meta"!==node.property.name&&this.raiseRecoverable(node.property.start,"The only valid meta property for import is 'import.meta'"),containsEsc&&this.raiseRecoverable(node.start,"'import.meta' must not contain escaped characters"),"module"===this.options.sourceType||this.options.allowImportExportEverywhere||this.raiseRecoverable(node.start,"Cannot use 'import.meta' outside a module"),this.finishNode(node,"MetaProperty")},pp$5.parseLiteral=function(value){var node=this.startNode();return node.value=value,node.raw=this.input.slice(this.start,this.end),110===node.raw.charCodeAt(node.raw.length-1)&&(node.bigint=node.raw.slice(0,-1).replace(/_/g,"")),this.next(),this.finishNode(node,"Literal")},pp$5.parseParenExpression=function(){this.expect(types$1.parenL);var val=this.parseExpression();return this.expect(types$1.parenR),val},pp$5.shouldParseArrow=function(exprList){return !this.canInsertSemicolon()},pp$5.parseParenAndDistinguishExpression=function(canBeArrow,forInit){var val,startPos=this.start,startLoc=this.startLoc,allowTrailingComma=this.options.ecmaVersion>=8;if(this.options.ecmaVersion>=6){this.next();var spreadStart,innerStartPos=this.start,innerStartLoc=this.startLoc,exprList=[],first=true,lastIsComma=false,refDestructuringErrors=new DestructuringErrors,oldYieldPos=this.yieldPos,oldAwaitPos=this.awaitPos;for(this.yieldPos=0,this.awaitPos=0;this.type!==types$1.parenR;){if(first?first=false:this.expect(types$1.comma),allowTrailingComma&&this.afterTrailingComma(types$1.parenR,true)){lastIsComma=true;break}if(this.type===types$1.ellipsis){spreadStart=this.start,exprList.push(this.parseParenItem(this.parseRestBinding())),this.type===types$1.comma&&this.raiseRecoverable(this.start,"Comma is not permitted after the rest element");break}exprList.push(this.parseMaybeAssign(false,refDestructuringErrors,this.parseParenItem));}var innerEndPos=this.lastTokEnd,innerEndLoc=this.lastTokEndLoc;if(this.expect(types$1.parenR),canBeArrow&&this.shouldParseArrow(exprList)&&this.eat(types$1.arrow))return this.checkPatternErrors(refDestructuringErrors,false),this.checkYieldAwaitInDefaultParams(),this.yieldPos=oldYieldPos,this.awaitPos=oldAwaitPos,this.parseParenArrowList(startPos,startLoc,exprList,forInit);exprList.length&&!lastIsComma||this.unexpected(this.lastTokStart),spreadStart&&this.unexpected(spreadStart),this.checkExpressionErrors(refDestructuringErrors,true),this.yieldPos=oldYieldPos||this.yieldPos,this.awaitPos=oldAwaitPos||this.awaitPos,exprList.length>1?((val=this.startNodeAt(innerStartPos,innerStartLoc)).expressions=exprList,this.finishNodeAt(val,"SequenceExpression",innerEndPos,innerEndLoc)):val=exprList[0];}else val=this.parseParenExpression();if(this.options.preserveParens){var par=this.startNodeAt(startPos,startLoc);return par.expression=val,this.finishNode(par,"ParenthesizedExpression")}return val},pp$5.parseParenItem=function(item){return item},pp$5.parseParenArrowList=function(startPos,startLoc,exprList,forInit){return this.parseArrowExpression(this.startNodeAt(startPos,startLoc),exprList,false,forInit)};var empty=[];pp$5.parseNew=function(){this.containsEsc&&this.raiseRecoverable(this.start,"Escape sequence in keyword new");var node=this.startNode();if(this.next(),this.options.ecmaVersion>=6&&this.type===types$1.dot){var meta=this.startNodeAt(node.start,node.loc&&node.loc.start);meta.name="new",node.meta=this.finishNode(meta,"Identifier"),this.next();var containsEsc=this.containsEsc;return node.property=this.parseIdent(true),"target"!==node.property.name&&this.raiseRecoverable(node.property.start,"The only valid meta property for new is 'new.target'"),containsEsc&&this.raiseRecoverable(node.start,"'new.target' must not contain escaped characters"),this.allowNewDotTarget||this.raiseRecoverable(node.start,"'new.target' can only be used in functions and class static block"),this.finishNode(node,"MetaProperty")}var startPos=this.start,startLoc=this.startLoc;return node.callee=this.parseSubscripts(this.parseExprAtom(null,false,true),startPos,startLoc,true,false),this.eat(types$1.parenL)?node.arguments=this.parseExprList(types$1.parenR,this.options.ecmaVersion>=8,false):node.arguments=empty,this.finishNode(node,"NewExpression")},pp$5.parseTemplateElement=function(ref){var isTagged=ref.isTagged,elem=this.startNode();return this.type===types$1.invalidTemplate?(isTagged||this.raiseRecoverable(this.start,"Bad escape sequence in untagged template literal"),elem.value={raw:this.value.replace(/\r\n?/g,"\n"),cooked:null}):elem.value={raw:this.input.slice(this.start,this.end).replace(/\r\n?/g,"\n"),cooked:this.value},this.next(),elem.tail=this.type===types$1.backQuote,this.finishNode(elem,"TemplateElement")},pp$5.parseTemplate=function(ref){ void 0===ref&&(ref={});var isTagged=ref.isTagged;void 0===isTagged&&(isTagged=false);var node=this.startNode();this.next(),node.expressions=[];var curElt=this.parseTemplateElement({isTagged});for(node.quasis=[curElt];!curElt.tail;)this.type===types$1.eof&&this.raise(this.pos,"Unterminated template literal"),this.expect(types$1.dollarBraceL),node.expressions.push(this.parseExpression()),this.expect(types$1.braceR),node.quasis.push(curElt=this.parseTemplateElement({isTagged}));return this.next(),this.finishNode(node,"TemplateLiteral")},pp$5.isAsyncProp=function(prop){return !prop.computed&&"Identifier"===prop.key.type&&"async"===prop.key.name&&(this.type===types$1.name||this.type===types$1.num||this.type===types$1.string||this.type===types$1.bracketL||this.type.keyword||this.options.ecmaVersion>=9&&this.type===types$1.star)&&!lineBreak.test(this.input.slice(this.lastTokEnd,this.start))},pp$5.parseObj=function(isPattern,refDestructuringErrors){var node=this.startNode(),first=true,propHash={};for(node.properties=[],this.next();!this.eat(types$1.braceR);){if(first)first=false;else if(this.expect(types$1.comma),this.options.ecmaVersion>=5&&this.afterTrailingComma(types$1.braceR))break;var prop=this.parseProperty(isPattern,refDestructuringErrors);isPattern||this.checkPropClash(prop,propHash,refDestructuringErrors),node.properties.push(prop);}return this.finishNode(node,isPattern?"ObjectPattern":"ObjectExpression")},pp$5.parseProperty=function(isPattern,refDestructuringErrors){var isGenerator,isAsync,startPos,startLoc,prop=this.startNode();if(this.options.ecmaVersion>=9&&this.eat(types$1.ellipsis))return isPattern?(prop.argument=this.parseIdent(false),this.type===types$1.comma&&this.raiseRecoverable(this.start,"Comma is not permitted after the rest element"),this.finishNode(prop,"RestElement")):(prop.argument=this.parseMaybeAssign(false,refDestructuringErrors),this.type===types$1.comma&&refDestructuringErrors&&refDestructuringErrors.trailingComma<0&&(refDestructuringErrors.trailingComma=this.start),this.finishNode(prop,"SpreadElement"));this.options.ecmaVersion>=6&&(prop.method=false,prop.shorthand=false,(isPattern||refDestructuringErrors)&&(startPos=this.start,startLoc=this.startLoc),isPattern||(isGenerator=this.eat(types$1.star)));var containsEsc=this.containsEsc;return this.parsePropertyName(prop),!isPattern&&!containsEsc&&this.options.ecmaVersion>=8&&!isGenerator&&this.isAsyncProp(prop)?(isAsync=true,isGenerator=this.options.ecmaVersion>=9&&this.eat(types$1.star),this.parsePropertyName(prop)):isAsync=false,this.parsePropertyValue(prop,isPattern,isGenerator,isAsync,startPos,startLoc,refDestructuringErrors,containsEsc),this.finishNode(prop,"Property")},pp$5.parseGetterSetter=function(prop){prop.kind=prop.key.name,this.parsePropertyName(prop),prop.value=this.parseMethod(false);var paramCount="get"===prop.kind?0:1;if(prop.value.params.length!==paramCount){var start=prop.value.start;"get"===prop.kind?this.raiseRecoverable(start,"getter should have no params"):this.raiseRecoverable(start,"setter should have exactly one param");}else "set"===prop.kind&&"RestElement"===prop.value.params[0].type&&this.raiseRecoverable(prop.value.params[0].start,"Setter cannot use rest params");},pp$5.parsePropertyValue=function(prop,isPattern,isGenerator,isAsync,startPos,startLoc,refDestructuringErrors,containsEsc){(isGenerator||isAsync)&&this.type===types$1.colon&&this.unexpected(),this.eat(types$1.colon)?(prop.value=isPattern?this.parseMaybeDefault(this.start,this.startLoc):this.parseMaybeAssign(false,refDestructuringErrors),prop.kind="init"):this.options.ecmaVersion>=6&&this.type===types$1.parenL?(isPattern&&this.unexpected(),prop.kind="init",prop.method=true,prop.value=this.parseMethod(isGenerator,isAsync)):isPattern||containsEsc||!(this.options.ecmaVersion>=5)||prop.computed||"Identifier"!==prop.key.type||"get"!==prop.key.name&&"set"!==prop.key.name||this.type===types$1.comma||this.type===types$1.braceR||this.type===types$1.eq?this.options.ecmaVersion>=6&&!prop.computed&&"Identifier"===prop.key.type?((isGenerator||isAsync)&&this.unexpected(),this.checkUnreserved(prop.key),"await"!==prop.key.name||this.awaitIdentPos||(this.awaitIdentPos=startPos),prop.kind="init",isPattern?prop.value=this.parseMaybeDefault(startPos,startLoc,this.copyNode(prop.key)):this.type===types$1.eq&&refDestructuringErrors?(refDestructuringErrors.shorthandAssign<0&&(refDestructuringErrors.shorthandAssign=this.start),prop.value=this.parseMaybeDefault(startPos,startLoc,this.copyNode(prop.key))):prop.value=this.copyNode(prop.key),prop.shorthand=true):this.unexpected():((isGenerator||isAsync)&&this.unexpected(),this.parseGetterSetter(prop));},pp$5.parsePropertyName=function(prop){if(this.options.ecmaVersion>=6){if(this.eat(types$1.bracketL))return prop.computed=true,prop.key=this.parseMaybeAssign(),this.expect(types$1.bracketR),prop.key;prop.computed=false;}return prop.key=this.type===types$1.num||this.type===types$1.string?this.parseExprAtom():this.parseIdent("never"!==this.options.allowReserved)},pp$5.initFunction=function(node){node.id=null,this.options.ecmaVersion>=6&&(node.generator=node.expression=false),this.options.ecmaVersion>=8&&(node.async=false);},pp$5.parseMethod=function(isGenerator,isAsync,allowDirectSuper){var node=this.startNode(),oldYieldPos=this.yieldPos,oldAwaitPos=this.awaitPos,oldAwaitIdentPos=this.awaitIdentPos;return this.initFunction(node),this.options.ecmaVersion>=6&&(node.generator=isGenerator),this.options.ecmaVersion>=8&&(node.async=!!isAsync),this.yieldPos=0,this.awaitPos=0,this.awaitIdentPos=0,this.enterScope(64|functionFlags(isAsync,node.generator)|(allowDirectSuper?128:0)),this.expect(types$1.parenL),node.params=this.parseBindingList(types$1.parenR,false,this.options.ecmaVersion>=8),this.checkYieldAwaitInDefaultParams(),this.parseFunctionBody(node,false,true,false),this.yieldPos=oldYieldPos,this.awaitPos=oldAwaitPos,this.awaitIdentPos=oldAwaitIdentPos,this.finishNode(node,"FunctionExpression")},pp$5.parseArrowExpression=function(node,params,isAsync,forInit){var oldYieldPos=this.yieldPos,oldAwaitPos=this.awaitPos,oldAwaitIdentPos=this.awaitIdentPos;return this.enterScope(16|functionFlags(isAsync,false)),this.initFunction(node),this.options.ecmaVersion>=8&&(node.async=!!isAsync),this.yieldPos=0,this.awaitPos=0,this.awaitIdentPos=0,node.params=this.toAssignableList(params,true),this.parseFunctionBody(node,true,false,forInit),this.yieldPos=oldYieldPos,this.awaitPos=oldAwaitPos,this.awaitIdentPos=oldAwaitIdentPos,this.finishNode(node,"ArrowFunctionExpression")},pp$5.parseFunctionBody=function(node,isArrowFunction,isMethod,forInit){var isExpression=isArrowFunction&&this.type!==types$1.braceL,oldStrict=this.strict,useStrict=false;if(isExpression)node.body=this.parseMaybeAssign(forInit),node.expression=true,this.checkParams(node,false);else {var nonSimple=this.options.ecmaVersion>=7&&!this.isSimpleParamList(node.params);oldStrict&&!nonSimple||(useStrict=this.strictDirective(this.end))&&nonSimple&&this.raiseRecoverable(node.start,"Illegal 'use strict' directive in function with non-simple parameter list");var oldLabels=this.labels;this.labels=[],useStrict&&(this.strict=true),this.checkParams(node,!oldStrict&&!useStrict&&!isArrowFunction&&!isMethod&&this.isSimpleParamList(node.params)),this.strict&&node.id&&this.checkLValSimple(node.id,5),node.body=this.parseBlock(false,void 0,useStrict&&!oldStrict),node.expression=false,this.adaptDirectivePrologue(node.body.body),this.labels=oldLabels;}this.exitScope();},pp$5.isSimpleParamList=function(params){for(var i=0,list=params;i<list.length;i+=1){if("Identifier"!==list[i].type)return  false}return  true},pp$5.checkParams=function(node,allowDuplicates){for(var nameHash=Object.create(null),i=0,list=node.params;i<list.length;i+=1){var param=list[i];this.checkLValInnerPattern(param,1,allowDuplicates?null:nameHash);}},pp$5.parseExprList=function(close,allowTrailingComma,allowEmpty,refDestructuringErrors){for(var elts=[],first=true;!this.eat(close);){if(first)first=false;else if(this.expect(types$1.comma),allowTrailingComma&&this.afterTrailingComma(close))break;var elt=void 0;allowEmpty&&this.type===types$1.comma?elt=null:this.type===types$1.ellipsis?(elt=this.parseSpread(refDestructuringErrors),refDestructuringErrors&&this.type===types$1.comma&&refDestructuringErrors.trailingComma<0&&(refDestructuringErrors.trailingComma=this.start)):elt=this.parseMaybeAssign(false,refDestructuringErrors),elts.push(elt);}return elts},pp$5.checkUnreserved=function(ref){var start=ref.start,end=ref.end,name=ref.name;(this.inGenerator&&"yield"===name&&this.raiseRecoverable(start,"Cannot use 'yield' as identifier inside a generator"),this.inAsync&&"await"===name&&this.raiseRecoverable(start,"Cannot use 'await' as identifier inside an async function"),this.currentThisScope().inClassFieldInit&&"arguments"===name&&this.raiseRecoverable(start,"Cannot use 'arguments' in class field initializer"),!this.inClassStaticBlock||"arguments"!==name&&"await"!==name||this.raise(start,"Cannot use "+name+" in class static initialization block"),this.keywords.test(name)&&this.raise(start,"Unexpected keyword '"+name+"'"),this.options.ecmaVersion<6&&-1!==this.input.slice(start,end).indexOf("\\"))||(this.strict?this.reservedWordsStrict:this.reservedWords).test(name)&&(this.inAsync||"await"!==name||this.raiseRecoverable(start,"Cannot use keyword 'await' outside an async function"),this.raiseRecoverable(start,"The keyword '"+name+"' is reserved"));},pp$5.parseIdent=function(liberal){var node=this.parseIdentNode();return this.next(!!liberal),this.finishNode(node,"Identifier"),liberal||(this.checkUnreserved(node),"await"!==node.name||this.awaitIdentPos||(this.awaitIdentPos=node.start)),node},pp$5.parseIdentNode=function(){var node=this.startNode();return this.type===types$1.name?node.name=this.value:this.type.keyword?(node.name=this.type.keyword,"class"!==node.name&&"function"!==node.name||this.lastTokEnd===this.lastTokStart+1&&46===this.input.charCodeAt(this.lastTokStart)||this.context.pop(),this.type=types$1.name):this.unexpected(),node},pp$5.parsePrivateIdent=function(){var node=this.startNode();return this.type===types$1.privateId?node.name=this.value:this.unexpected(),this.next(),this.finishNode(node,"PrivateIdentifier"),this.options.checkPrivateFields&&(0===this.privateNameStack.length?this.raise(node.start,"Private field '#"+node.name+"' must be declared in an enclosing class"):this.privateNameStack[this.privateNameStack.length-1].used.push(node)),node},pp$5.parseYield=function(forInit){this.yieldPos||(this.yieldPos=this.start);var node=this.startNode();return this.next(),this.type===types$1.semi||this.canInsertSemicolon()||this.type!==types$1.star&&!this.type.startsExpr?(node.delegate=false,node.argument=null):(node.delegate=this.eat(types$1.star),node.argument=this.parseMaybeAssign(forInit)),this.finishNode(node,"YieldExpression")},pp$5.parseAwait=function(forInit){this.awaitPos||(this.awaitPos=this.start);var node=this.startNode();return this.next(),node.argument=this.parseMaybeUnary(null,true,false,forInit),this.finishNode(node,"AwaitExpression")};var pp$4=Parser.prototype;pp$4.raise=function(pos,message){var loc=getLineInfo(this.input,pos);message+=" ("+loc.line+":"+loc.column+")";var err=new SyntaxError(message);throw err.pos=pos,err.loc=loc,err.raisedAt=this.pos,err},pp$4.raiseRecoverable=pp$4.raise,pp$4.curPosition=function(){if(this.options.locations)return new Position(this.curLine,this.pos-this.lineStart)};var pp$3=Parser.prototype,Scope=function(flags){this.flags=flags,this.var=[],this.lexical=[],this.functions=[],this.inClassFieldInit=false;};pp$3.enterScope=function(flags){this.scopeStack.push(new Scope(flags));},pp$3.exitScope=function(){this.scopeStack.pop();},pp$3.treatFunctionsAsVarInScope=function(scope){return 2&scope.flags||!this.inModule&&1&scope.flags},pp$3.declareName=function(name,bindingType,pos){var redeclared=false;if(2===bindingType){var scope=this.currentScope();redeclared=scope.lexical.indexOf(name)>-1||scope.functions.indexOf(name)>-1||scope.var.indexOf(name)>-1,scope.lexical.push(name),this.inModule&&1&scope.flags&&delete this.undefinedExports[name];}else if(4===bindingType){this.currentScope().lexical.push(name);}else if(3===bindingType){var scope$2=this.currentScope();redeclared=this.treatFunctionsAsVar?scope$2.lexical.indexOf(name)>-1:scope$2.lexical.indexOf(name)>-1||scope$2.var.indexOf(name)>-1,scope$2.functions.push(name);}else for(var i=this.scopeStack.length-1;i>=0;--i){var scope$3=this.scopeStack[i];if(scope$3.lexical.indexOf(name)>-1&&!(32&scope$3.flags&&scope$3.lexical[0]===name)||!this.treatFunctionsAsVarInScope(scope$3)&&scope$3.functions.indexOf(name)>-1){redeclared=true;break}if(scope$3.var.push(name),this.inModule&&1&scope$3.flags&&delete this.undefinedExports[name],259&scope$3.flags)break}redeclared&&this.raiseRecoverable(pos,"Identifier '"+name+"' has already been declared");},pp$3.checkLocalExport=function(id){ -1===this.scopeStack[0].lexical.indexOf(id.name)&&-1===this.scopeStack[0].var.indexOf(id.name)&&(this.undefinedExports[id.name]=id);},pp$3.currentScope=function(){return this.scopeStack[this.scopeStack.length-1]},pp$3.currentVarScope=function(){for(var i=this.scopeStack.length-1;;i--){var scope=this.scopeStack[i];if(259&scope.flags)return scope}},pp$3.currentThisScope=function(){for(var i=this.scopeStack.length-1;;i--){var scope=this.scopeStack[i];if(259&scope.flags&&!(16&scope.flags))return scope}};var Node=function(parser,pos,loc){this.type="",this.start=pos,this.end=0,parser.options.locations&&(this.loc=new SourceLocation(parser,loc)),parser.options.directSourceFile&&(this.sourceFile=parser.options.directSourceFile),parser.options.ranges&&(this.range=[pos,0]);},pp$2=Parser.prototype;function finishNodeAt(node,type,pos,loc){return node.type=type,node.end=pos,this.options.locations&&(node.loc.end=loc),this.options.ranges&&(node.range[1]=pos),node}pp$2.startNode=function(){return new Node(this,this.start,this.startLoc)},pp$2.startNodeAt=function(pos,loc){return new Node(this,pos,loc)},pp$2.finishNode=function(node,type){return finishNodeAt.call(this,node,type,this.lastTokEnd,this.lastTokEndLoc)},pp$2.finishNodeAt=function(node,type,pos,loc){return finishNodeAt.call(this,node,type,pos,loc)},pp$2.copyNode=function(node){var newNode=new Node(this,node.start,this.startLoc);for(var prop in node)newNode[prop]=node[prop];return newNode};var ecma9BinaryProperties="ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS",ecma10BinaryProperties=ecma9BinaryProperties+" Extended_Pictographic",ecma12BinaryProperties=ecma10BinaryProperties+" EBase EComp EMod EPres ExtPict",unicodeBinaryProperties={9:ecma9BinaryProperties,10:ecma10BinaryProperties,11:ecma10BinaryProperties,12:ecma12BinaryProperties,13:ecma12BinaryProperties,14:ecma12BinaryProperties},unicodeBinaryPropertiesOfStrings={9:"",10:"",11:"",12:"",13:"",14:"Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji"},unicodeGeneralCategoryValues="Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu",ecma9ScriptValues="Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb",ecma10ScriptValues=ecma9ScriptValues+" Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd",ecma11ScriptValues=ecma10ScriptValues+" Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho",ecma12ScriptValues=ecma11ScriptValues+" Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi",ecma13ScriptValues=ecma12ScriptValues+" Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith",unicodeScriptValues={9:ecma9ScriptValues,10:ecma10ScriptValues,11:ecma11ScriptValues,12:ecma12ScriptValues,13:ecma13ScriptValues,14:ecma13ScriptValues+" Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz"},data={};function buildUnicodeData(ecmaVersion){var d=data[ecmaVersion]={binary:wordsRegexp(unicodeBinaryProperties[ecmaVersion]+" "+unicodeGeneralCategoryValues),binaryOfStrings:wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion]),nonBinary:{General_Category:wordsRegexp(unicodeGeneralCategoryValues),Script:wordsRegexp(unicodeScriptValues[ecmaVersion])}};d.nonBinary.Script_Extensions=d.nonBinary.Script,d.nonBinary.gc=d.nonBinary.General_Category,d.nonBinary.sc=d.nonBinary.Script,d.nonBinary.scx=d.nonBinary.Script_Extensions;}for(var i=0,list=[9,10,11,12,13,14];i<list.length;i+=1){buildUnicodeData(list[i]);}var pp$1=Parser.prototype,BranchID=function(parent,base){this.parent=parent,this.base=base||this;};BranchID.prototype.separatedFrom=function(alt){for(var self=this;self;self=self.parent)for(var other=alt;other;other=other.parent)if(self.base===other.base&&self!==other)return  true;return  false},BranchID.prototype.sibling=function(){return new BranchID(this.parent,this.base)};var RegExpValidationState=function(parser){this.parser=parser,this.validFlags="gim"+(parser.options.ecmaVersion>=6?"uy":"")+(parser.options.ecmaVersion>=9?"s":"")+(parser.options.ecmaVersion>=13?"d":"")+(parser.options.ecmaVersion>=15?"v":""),this.unicodeProperties=data[parser.options.ecmaVersion>=14?14:parser.options.ecmaVersion],this.source="",this.flags="",this.start=0,this.switchU=false,this.switchV=false,this.switchN=false,this.pos=0,this.lastIntValue=0,this.lastStringValue="",this.lastAssertionIsQuantifiable=false,this.numCapturingParens=0,this.maxBackReference=0,this.groupNames=Object.create(null),this.backReferenceNames=[],this.branchID=null;};function isRegularExpressionModifier(ch){return 105===ch||109===ch||115===ch}function isSyntaxCharacter(ch){return 36===ch||ch>=40&&ch<=43||46===ch||63===ch||ch>=91&&ch<=94||ch>=123&&ch<=125}function isControlLetter(ch){return ch>=65&&ch<=90||ch>=97&&ch<=122}RegExpValidationState.prototype.reset=function(start,pattern,flags){var unicodeSets=-1!==flags.indexOf("v"),unicode=-1!==flags.indexOf("u");this.start=0|start,this.source=pattern+"",this.flags=flags,unicodeSets&&this.parser.options.ecmaVersion>=15?(this.switchU=true,this.switchV=true,this.switchN=true):(this.switchU=unicode&&this.parser.options.ecmaVersion>=6,this.switchV=false,this.switchN=unicode&&this.parser.options.ecmaVersion>=9);},RegExpValidationState.prototype.raise=function(message){this.parser.raiseRecoverable(this.start,"Invalid regular expression: /"+this.source+"/: "+message);},RegExpValidationState.prototype.at=function(i,forceU){ void 0===forceU&&(forceU=false);var s=this.source,l=s.length;if(i>=l)return  -1;var c=s.charCodeAt(i);if(!forceU&&!this.switchU||c<=55295||c>=57344||i+1>=l)return c;var next=s.charCodeAt(i+1);return next>=56320&&next<=57343?(c<<10)+next-56613888:c},RegExpValidationState.prototype.nextIndex=function(i,forceU){ void 0===forceU&&(forceU=false);var s=this.source,l=s.length;if(i>=l)return l;var next,c=s.charCodeAt(i);return !forceU&&!this.switchU||c<=55295||c>=57344||i+1>=l||(next=s.charCodeAt(i+1))<56320||next>57343?i+1:i+2},RegExpValidationState.prototype.current=function(forceU){return void 0===forceU&&(forceU=false),this.at(this.pos,forceU)},RegExpValidationState.prototype.lookahead=function(forceU){return void 0===forceU&&(forceU=false),this.at(this.nextIndex(this.pos,forceU),forceU)},RegExpValidationState.prototype.advance=function(forceU){ void 0===forceU&&(forceU=false),this.pos=this.nextIndex(this.pos,forceU);},RegExpValidationState.prototype.eat=function(ch,forceU){return void 0===forceU&&(forceU=false),this.current(forceU)===ch&&(this.advance(forceU),true)},RegExpValidationState.prototype.eatChars=function(chs,forceU){ void 0===forceU&&(forceU=false);for(var pos=this.pos,i=0,list=chs;i<list.length;i+=1){var ch=list[i],current=this.at(pos,forceU);if(-1===current||current!==ch)return  false;pos=this.nextIndex(pos,forceU);}return this.pos=pos,true},pp$1.validateRegExpFlags=function(state){for(var validFlags=state.validFlags,flags=state.flags,u=false,v=false,i=0;i<flags.length;i++){var flag=flags.charAt(i);-1===validFlags.indexOf(flag)&&this.raise(state.start,"Invalid regular expression flag"),flags.indexOf(flag,i+1)>-1&&this.raise(state.start,"Duplicate regular expression flag"),"u"===flag&&(u=true),"v"===flag&&(v=true);}this.options.ecmaVersion>=15&&u&&v&&this.raise(state.start,"Invalid regular expression flag");},pp$1.validateRegExpPattern=function(state){this.regexp_pattern(state),!state.switchN&&this.options.ecmaVersion>=9&&function(obj){for(var _ in obj)return  true;return  false}(state.groupNames)&&(state.switchN=true,this.regexp_pattern(state));},pp$1.regexp_pattern=function(state){state.pos=0,state.lastIntValue=0,state.lastStringValue="",state.lastAssertionIsQuantifiable=false,state.numCapturingParens=0,state.maxBackReference=0,state.groupNames=Object.create(null),state.backReferenceNames.length=0,state.branchID=null,this.regexp_disjunction(state),state.pos!==state.source.length&&(state.eat(41)&&state.raise("Unmatched ')'"),(state.eat(93)||state.eat(125))&&state.raise("Lone quantifier brackets")),state.maxBackReference>state.numCapturingParens&&state.raise("Invalid escape");for(var i=0,list=state.backReferenceNames;i<list.length;i+=1){var name=list[i];state.groupNames[name]||state.raise("Invalid named capture referenced");}},pp$1.regexp_disjunction=function(state){var trackDisjunction=this.options.ecmaVersion>=16;for(trackDisjunction&&(state.branchID=new BranchID(state.branchID,null)),this.regexp_alternative(state);state.eat(124);)trackDisjunction&&(state.branchID=state.branchID.sibling()),this.regexp_alternative(state);trackDisjunction&&(state.branchID=state.branchID.parent),this.regexp_eatQuantifier(state,true)&&state.raise("Nothing to repeat"),state.eat(123)&&state.raise("Lone quantifier brackets");},pp$1.regexp_alternative=function(state){for(;state.pos<state.source.length&&this.regexp_eatTerm(state););},pp$1.regexp_eatTerm=function(state){return this.regexp_eatAssertion(state)?(state.lastAssertionIsQuantifiable&&this.regexp_eatQuantifier(state)&&state.switchU&&state.raise("Invalid quantifier"),true):!!(state.switchU?this.regexp_eatAtom(state):this.regexp_eatExtendedAtom(state))&&(this.regexp_eatQuantifier(state),true)},pp$1.regexp_eatAssertion=function(state){var start=state.pos;if(state.lastAssertionIsQuantifiable=false,state.eat(94)||state.eat(36))return  true;if(state.eat(92)){if(state.eat(66)||state.eat(98))return  true;state.pos=start;}if(state.eat(40)&&state.eat(63)){var lookbehind=false;if(this.options.ecmaVersion>=9&&(lookbehind=state.eat(60)),state.eat(61)||state.eat(33))return this.regexp_disjunction(state),state.eat(41)||state.raise("Unterminated group"),state.lastAssertionIsQuantifiable=!lookbehind,true}return state.pos=start,false},pp$1.regexp_eatQuantifier=function(state,noError){return void 0===noError&&(noError=false),!!this.regexp_eatQuantifierPrefix(state,noError)&&(state.eat(63),true)},pp$1.regexp_eatQuantifierPrefix=function(state,noError){return state.eat(42)||state.eat(43)||state.eat(63)||this.regexp_eatBracedQuantifier(state,noError)},pp$1.regexp_eatBracedQuantifier=function(state,noError){var start=state.pos;if(state.eat(123)){var min=0,max=-1;if(this.regexp_eatDecimalDigits(state)&&(min=state.lastIntValue,state.eat(44)&&this.regexp_eatDecimalDigits(state)&&(max=state.lastIntValue),state.eat(125)))return  -1!==max&&max<min&&!noError&&state.raise("numbers out of order in {} quantifier"),true;state.switchU&&!noError&&state.raise("Incomplete quantifier"),state.pos=start;}return  false},pp$1.regexp_eatAtom=function(state){return this.regexp_eatPatternCharacters(state)||state.eat(46)||this.regexp_eatReverseSolidusAtomEscape(state)||this.regexp_eatCharacterClass(state)||this.regexp_eatUncapturingGroup(state)||this.regexp_eatCapturingGroup(state)},pp$1.regexp_eatReverseSolidusAtomEscape=function(state){var start=state.pos;if(state.eat(92)){if(this.regexp_eatAtomEscape(state))return  true;state.pos=start;}return  false},pp$1.regexp_eatUncapturingGroup=function(state){var start=state.pos;if(state.eat(40)){if(state.eat(63)){if(this.options.ecmaVersion>=16){var addModifiers=this.regexp_eatModifiers(state),hasHyphen=state.eat(45);if(addModifiers||hasHyphen){for(var i=0;i<addModifiers.length;i++){var modifier=addModifiers.charAt(i);addModifiers.indexOf(modifier,i+1)>-1&&state.raise("Duplicate regular expression modifiers");}if(hasHyphen){var removeModifiers=this.regexp_eatModifiers(state);addModifiers||removeModifiers||58!==state.current()||state.raise("Invalid regular expression modifiers");for(var i$1=0;i$1<removeModifiers.length;i$1++){var modifier$1=removeModifiers.charAt(i$1);(removeModifiers.indexOf(modifier$1,i$1+1)>-1||addModifiers.indexOf(modifier$1)>-1)&&state.raise("Duplicate regular expression modifiers");}}}}if(state.eat(58)){if(this.regexp_disjunction(state),state.eat(41))return  true;state.raise("Unterminated group");}}state.pos=start;}return  false},pp$1.regexp_eatCapturingGroup=function(state){if(state.eat(40)){if(this.options.ecmaVersion>=9?this.regexp_groupSpecifier(state):63===state.current()&&state.raise("Invalid group"),this.regexp_disjunction(state),state.eat(41))return state.numCapturingParens+=1,true;state.raise("Unterminated group");}return  false},pp$1.regexp_eatModifiers=function(state){for(var modifiers="",ch=0;-1!==(ch=state.current())&&isRegularExpressionModifier(ch);)modifiers+=codePointToString(ch),state.advance();return modifiers},pp$1.regexp_eatExtendedAtom=function(state){return state.eat(46)||this.regexp_eatReverseSolidusAtomEscape(state)||this.regexp_eatCharacterClass(state)||this.regexp_eatUncapturingGroup(state)||this.regexp_eatCapturingGroup(state)||this.regexp_eatInvalidBracedQuantifier(state)||this.regexp_eatExtendedPatternCharacter(state)},pp$1.regexp_eatInvalidBracedQuantifier=function(state){return this.regexp_eatBracedQuantifier(state,true)&&state.raise("Nothing to repeat"),false},pp$1.regexp_eatSyntaxCharacter=function(state){var ch=state.current();return !!isSyntaxCharacter(ch)&&(state.lastIntValue=ch,state.advance(),true)},pp$1.regexp_eatPatternCharacters=function(state){for(var start=state.pos,ch=0;-1!==(ch=state.current())&&!isSyntaxCharacter(ch);)state.advance();return state.pos!==start},pp$1.regexp_eatExtendedPatternCharacter=function(state){var ch=state.current();return !(-1===ch||36===ch||ch>=40&&ch<=43||46===ch||63===ch||91===ch||94===ch||124===ch)&&(state.advance(),true)},pp$1.regexp_groupSpecifier=function(state){if(state.eat(63)){this.regexp_eatGroupName(state)||state.raise("Invalid group");var trackDisjunction=this.options.ecmaVersion>=16,known=state.groupNames[state.lastStringValue];if(known)if(trackDisjunction)for(var i=0,list=known;i<list.length;i+=1){list[i].separatedFrom(state.branchID)||state.raise("Duplicate capture group name");}else state.raise("Duplicate capture group name");trackDisjunction?(known||(state.groupNames[state.lastStringValue]=[])).push(state.branchID):state.groupNames[state.lastStringValue]=true;}},pp$1.regexp_eatGroupName=function(state){if(state.lastStringValue="",state.eat(60)){if(this.regexp_eatRegExpIdentifierName(state)&&state.eat(62))return  true;state.raise("Invalid capture group name");}return  false},pp$1.regexp_eatRegExpIdentifierName=function(state){if(state.lastStringValue="",this.regexp_eatRegExpIdentifierStart(state)){for(state.lastStringValue+=codePointToString(state.lastIntValue);this.regexp_eatRegExpIdentifierPart(state);)state.lastStringValue+=codePointToString(state.lastIntValue);return  true}return  false},pp$1.regexp_eatRegExpIdentifierStart=function(state){var start=state.pos,forceU=this.options.ecmaVersion>=11,ch=state.current(forceU);return state.advance(forceU),92===ch&&this.regexp_eatRegExpUnicodeEscapeSequence(state,forceU)&&(ch=state.lastIntValue),function(ch){return isIdentifierStart(ch,true)||36===ch||95===ch}(ch)?(state.lastIntValue=ch,true):(state.pos=start,false)},pp$1.regexp_eatRegExpIdentifierPart=function(state){var start=state.pos,forceU=this.options.ecmaVersion>=11,ch=state.current(forceU);return state.advance(forceU),92===ch&&this.regexp_eatRegExpUnicodeEscapeSequence(state,forceU)&&(ch=state.lastIntValue),function(ch){return isIdentifierChar(ch,true)||36===ch||95===ch||8204===ch||8205===ch}(ch)?(state.lastIntValue=ch,true):(state.pos=start,false)},pp$1.regexp_eatAtomEscape=function(state){return !!(this.regexp_eatBackReference(state)||this.regexp_eatCharacterClassEscape(state)||this.regexp_eatCharacterEscape(state)||state.switchN&&this.regexp_eatKGroupName(state))||(state.switchU&&(99===state.current()&&state.raise("Invalid unicode escape"),state.raise("Invalid escape")),false)},pp$1.regexp_eatBackReference=function(state){var start=state.pos;if(this.regexp_eatDecimalEscape(state)){var n=state.lastIntValue;if(state.switchU)return n>state.maxBackReference&&(state.maxBackReference=n),true;if(n<=state.numCapturingParens)return  true;state.pos=start;}return  false},pp$1.regexp_eatKGroupName=function(state){if(state.eat(107)){if(this.regexp_eatGroupName(state))return state.backReferenceNames.push(state.lastStringValue),true;state.raise("Invalid named reference");}return  false},pp$1.regexp_eatCharacterEscape=function(state){return this.regexp_eatControlEscape(state)||this.regexp_eatCControlLetter(state)||this.regexp_eatZero(state)||this.regexp_eatHexEscapeSequence(state)||this.regexp_eatRegExpUnicodeEscapeSequence(state,false)||!state.switchU&&this.regexp_eatLegacyOctalEscapeSequence(state)||this.regexp_eatIdentityEscape(state)},pp$1.regexp_eatCControlLetter=function(state){var start=state.pos;if(state.eat(99)){if(this.regexp_eatControlLetter(state))return  true;state.pos=start;}return  false},pp$1.regexp_eatZero=function(state){return 48===state.current()&&!isDecimalDigit(state.lookahead())&&(state.lastIntValue=0,state.advance(),true)},pp$1.regexp_eatControlEscape=function(state){var ch=state.current();return 116===ch?(state.lastIntValue=9,state.advance(),true):110===ch?(state.lastIntValue=10,state.advance(),true):118===ch?(state.lastIntValue=11,state.advance(),true):102===ch?(state.lastIntValue=12,state.advance(),true):114===ch&&(state.lastIntValue=13,state.advance(),true)},pp$1.regexp_eatControlLetter=function(state){var ch=state.current();return !!isControlLetter(ch)&&(state.lastIntValue=ch%32,state.advance(),true)},pp$1.regexp_eatRegExpUnicodeEscapeSequence=function(state,forceU){ void 0===forceU&&(forceU=false);var ch,start=state.pos,switchU=forceU||state.switchU;if(state.eat(117)){if(this.regexp_eatFixedHexDigits(state,4)){var lead=state.lastIntValue;if(switchU&&lead>=55296&&lead<=56319){var leadSurrogateEnd=state.pos;if(state.eat(92)&&state.eat(117)&&this.regexp_eatFixedHexDigits(state,4)){var trail=state.lastIntValue;if(trail>=56320&&trail<=57343)return state.lastIntValue=1024*(lead-55296)+(trail-56320)+65536,true}state.pos=leadSurrogateEnd,state.lastIntValue=lead;}return  true}if(switchU&&state.eat(123)&&this.regexp_eatHexDigits(state)&&state.eat(125)&&((ch=state.lastIntValue)>=0&&ch<=1114111))return  true;switchU&&state.raise("Invalid unicode escape"),state.pos=start;}return  false},pp$1.regexp_eatIdentityEscape=function(state){if(state.switchU)return !!this.regexp_eatSyntaxCharacter(state)||!!state.eat(47)&&(state.lastIntValue=47,true);var ch=state.current();return !(99===ch||state.switchN&&107===ch)&&(state.lastIntValue=ch,state.advance(),true)},pp$1.regexp_eatDecimalEscape=function(state){state.lastIntValue=0;var ch=state.current();if(ch>=49&&ch<=57){do{state.lastIntValue=10*state.lastIntValue+(ch-48),state.advance();}while((ch=state.current())>=48&&ch<=57);return  true}return  false};function isUnicodePropertyNameCharacter(ch){return isControlLetter(ch)||95===ch}function isUnicodePropertyValueCharacter(ch){return isUnicodePropertyNameCharacter(ch)||isDecimalDigit(ch)}function isDecimalDigit(ch){return ch>=48&&ch<=57}function isHexDigit(ch){return ch>=48&&ch<=57||ch>=65&&ch<=70||ch>=97&&ch<=102}function hexToInt(ch){return ch>=65&&ch<=70?ch-65+10:ch>=97&&ch<=102?ch-97+10:ch-48}function isOctalDigit(ch){return ch>=48&&ch<=55}pp$1.regexp_eatCharacterClassEscape=function(state){var ch=state.current();if(function(ch){return 100===ch||68===ch||115===ch||83===ch||119===ch||87===ch}(ch))return state.lastIntValue=-1,state.advance(),1;var negate=false;if(state.switchU&&this.options.ecmaVersion>=9&&((negate=80===ch)||112===ch)){var result;if(state.lastIntValue=-1,state.advance(),state.eat(123)&&(result=this.regexp_eatUnicodePropertyValueExpression(state))&&state.eat(125))return negate&&2===result&&state.raise("Invalid property name"),result;state.raise("Invalid property name");}return 0},pp$1.regexp_eatUnicodePropertyValueExpression=function(state){var start=state.pos;if(this.regexp_eatUnicodePropertyName(state)&&state.eat(61)){var name=state.lastStringValue;if(this.regexp_eatUnicodePropertyValue(state)){var value=state.lastStringValue;return this.regexp_validateUnicodePropertyNameAndValue(state,name,value),1}}if(state.pos=start,this.regexp_eatLoneUnicodePropertyNameOrValue(state)){var nameOrValue=state.lastStringValue;return this.regexp_validateUnicodePropertyNameOrValue(state,nameOrValue)}return 0},pp$1.regexp_validateUnicodePropertyNameAndValue=function(state,name,value){hasOwn(state.unicodeProperties.nonBinary,name)||state.raise("Invalid property name"),state.unicodeProperties.nonBinary[name].test(value)||state.raise("Invalid property value");},pp$1.regexp_validateUnicodePropertyNameOrValue=function(state,nameOrValue){return state.unicodeProperties.binary.test(nameOrValue)?1:state.switchV&&state.unicodeProperties.binaryOfStrings.test(nameOrValue)?2:void state.raise("Invalid property name")},pp$1.regexp_eatUnicodePropertyName=function(state){var ch=0;for(state.lastStringValue="";isUnicodePropertyNameCharacter(ch=state.current());)state.lastStringValue+=codePointToString(ch),state.advance();return ""!==state.lastStringValue},pp$1.regexp_eatUnicodePropertyValue=function(state){var ch=0;for(state.lastStringValue="";isUnicodePropertyValueCharacter(ch=state.current());)state.lastStringValue+=codePointToString(ch),state.advance();return ""!==state.lastStringValue},pp$1.regexp_eatLoneUnicodePropertyNameOrValue=function(state){return this.regexp_eatUnicodePropertyValue(state)},pp$1.regexp_eatCharacterClass=function(state){if(state.eat(91)){var negate=state.eat(94),result=this.regexp_classContents(state);return state.eat(93)||state.raise("Unterminated character class"),negate&&2===result&&state.raise("Negated character class may contain strings"),true}return  false},pp$1.regexp_classContents=function(state){return 93===state.current()?1:state.switchV?this.regexp_classSetExpression(state):(this.regexp_nonEmptyClassRanges(state),1)},pp$1.regexp_nonEmptyClassRanges=function(state){for(;this.regexp_eatClassAtom(state);){var left=state.lastIntValue;if(state.eat(45)&&this.regexp_eatClassAtom(state)){var right=state.lastIntValue;!state.switchU||-1!==left&&-1!==right||state.raise("Invalid character class"),-1!==left&&-1!==right&&left>right&&state.raise("Range out of order in character class");}}},pp$1.regexp_eatClassAtom=function(state){var start=state.pos;if(state.eat(92)){if(this.regexp_eatClassEscape(state))return  true;if(state.switchU){var ch$1=state.current();(99===ch$1||isOctalDigit(ch$1))&&state.raise("Invalid class escape"),state.raise("Invalid escape");}state.pos=start;}var ch=state.current();return 93!==ch&&(state.lastIntValue=ch,state.advance(),true)},pp$1.regexp_eatClassEscape=function(state){var start=state.pos;if(state.eat(98))return state.lastIntValue=8,true;if(state.switchU&&state.eat(45))return state.lastIntValue=45,true;if(!state.switchU&&state.eat(99)){if(this.regexp_eatClassControlLetter(state))return  true;state.pos=start;}return this.regexp_eatCharacterClassEscape(state)||this.regexp_eatCharacterEscape(state)},pp$1.regexp_classSetExpression=function(state){var subResult,result=1;if(this.regexp_eatClassSetRange(state));else if(subResult=this.regexp_eatClassSetOperand(state)){2===subResult&&(result=2);for(var start=state.pos;state.eatChars([38,38]);)38!==state.current()&&(subResult=this.regexp_eatClassSetOperand(state))?2!==subResult&&(result=1):state.raise("Invalid character in character class");if(start!==state.pos)return result;for(;state.eatChars([45,45]);)this.regexp_eatClassSetOperand(state)||state.raise("Invalid character in character class");if(start!==state.pos)return result}else state.raise("Invalid character in character class");for(;;)if(!this.regexp_eatClassSetRange(state)){if(!(subResult=this.regexp_eatClassSetOperand(state)))return result;2===subResult&&(result=2);}},pp$1.regexp_eatClassSetRange=function(state){var start=state.pos;if(this.regexp_eatClassSetCharacter(state)){var left=state.lastIntValue;if(state.eat(45)&&this.regexp_eatClassSetCharacter(state)){var right=state.lastIntValue;return  -1!==left&&-1!==right&&left>right&&state.raise("Range out of order in character class"),true}state.pos=start;}return  false},pp$1.regexp_eatClassSetOperand=function(state){return this.regexp_eatClassSetCharacter(state)?1:this.regexp_eatClassStringDisjunction(state)||this.regexp_eatNestedClass(state)},pp$1.regexp_eatNestedClass=function(state){var start=state.pos;if(state.eat(91)){var negate=state.eat(94),result=this.regexp_classContents(state);if(state.eat(93))return negate&&2===result&&state.raise("Negated character class may contain strings"),result;state.pos=start;}if(state.eat(92)){var result$1=this.regexp_eatCharacterClassEscape(state);if(result$1)return result$1;state.pos=start;}return null},pp$1.regexp_eatClassStringDisjunction=function(state){var start=state.pos;if(state.eatChars([92,113])){if(state.eat(123)){var result=this.regexp_classStringDisjunctionContents(state);if(state.eat(125))return result}else state.raise("Invalid escape");state.pos=start;}return null},pp$1.regexp_classStringDisjunctionContents=function(state){for(var result=this.regexp_classString(state);state.eat(124);)2===this.regexp_classString(state)&&(result=2);return result},pp$1.regexp_classString=function(state){for(var count=0;this.regexp_eatClassSetCharacter(state);)count++;return 1===count?1:2},pp$1.regexp_eatClassSetCharacter=function(state){var start=state.pos;if(state.eat(92))return !(!this.regexp_eatCharacterEscape(state)&&!this.regexp_eatClassSetReservedPunctuator(state))||(state.eat(98)?(state.lastIntValue=8,true):(state.pos=start,false));var ch=state.current();return !(ch<0||ch===state.lookahead()&&function(ch){return 33===ch||ch>=35&&ch<=38||ch>=42&&ch<=44||46===ch||ch>=58&&ch<=64||94===ch||96===ch||126===ch}(ch))&&(!function(ch){return 40===ch||41===ch||45===ch||47===ch||ch>=91&&ch<=93||ch>=123&&ch<=125}(ch)&&(state.advance(),state.lastIntValue=ch,true))},pp$1.regexp_eatClassSetReservedPunctuator=function(state){var ch=state.current();return !!function(ch){return 33===ch||35===ch||37===ch||38===ch||44===ch||45===ch||ch>=58&&ch<=62||64===ch||96===ch||126===ch}(ch)&&(state.lastIntValue=ch,state.advance(),true)},pp$1.regexp_eatClassControlLetter=function(state){var ch=state.current();return !(!isDecimalDigit(ch)&&95!==ch)&&(state.lastIntValue=ch%32,state.advance(),true)},pp$1.regexp_eatHexEscapeSequence=function(state){var start=state.pos;if(state.eat(120)){if(this.regexp_eatFixedHexDigits(state,2))return  true;state.switchU&&state.raise("Invalid escape"),state.pos=start;}return  false},pp$1.regexp_eatDecimalDigits=function(state){var start=state.pos,ch=0;for(state.lastIntValue=0;isDecimalDigit(ch=state.current());)state.lastIntValue=10*state.lastIntValue+(ch-48),state.advance();return state.pos!==start},pp$1.regexp_eatHexDigits=function(state){var start=state.pos,ch=0;for(state.lastIntValue=0;isHexDigit(ch=state.current());)state.lastIntValue=16*state.lastIntValue+hexToInt(ch),state.advance();return state.pos!==start},pp$1.regexp_eatLegacyOctalEscapeSequence=function(state){if(this.regexp_eatOctalDigit(state)){var n1=state.lastIntValue;if(this.regexp_eatOctalDigit(state)){var n2=state.lastIntValue;n1<=3&&this.regexp_eatOctalDigit(state)?state.lastIntValue=64*n1+8*n2+state.lastIntValue:state.lastIntValue=8*n1+n2;}else state.lastIntValue=n1;return  true}return  false},pp$1.regexp_eatOctalDigit=function(state){var ch=state.current();return isOctalDigit(ch)?(state.lastIntValue=ch-48,state.advance(),true):(state.lastIntValue=0,false)},pp$1.regexp_eatFixedHexDigits=function(state,length){var start=state.pos;state.lastIntValue=0;for(var i=0;i<length;++i){var ch=state.current();if(!isHexDigit(ch))return state.pos=start,false;state.lastIntValue=16*state.lastIntValue+hexToInt(ch),state.advance();}return  true};var Token=function(p){this.type=p.type,this.value=p.value,this.start=p.start,this.end=p.end,p.options.locations&&(this.loc=new SourceLocation(p,p.startLoc,p.endLoc)),p.options.ranges&&(this.range=[p.start,p.end]);},pp=Parser.prototype;function stringToBigInt(str){return "function"!=typeof BigInt?null:BigInt(str.replace(/_/g,""))}pp.next=function(ignoreEscapeSequenceInKeyword){!ignoreEscapeSequenceInKeyword&&this.type.keyword&&this.containsEsc&&this.raiseRecoverable(this.start,"Escape sequence in keyword "+this.type.keyword),this.options.onToken&&this.options.onToken(new Token(this)),this.lastTokEnd=this.end,this.lastTokStart=this.start,this.lastTokEndLoc=this.endLoc,this.lastTokStartLoc=this.startLoc,this.nextToken();},pp.getToken=function(){return this.next(),new Token(this)},"undefined"!=typeof Symbol&&(pp[Symbol.iterator]=function(){var this$1$1=this;return {next:function(){var token=this$1$1.getToken();return {done:token.type===types$1.eof,value:token}}}}),pp.nextToken=function(){var curContext=this.curContext();return curContext&&curContext.preserveSpace||this.skipSpace(),this.start=this.pos,this.options.locations&&(this.startLoc=this.curPosition()),this.pos>=this.input.length?this.finishToken(types$1.eof):curContext.override?curContext.override(this):void this.readToken(this.fullCharCodeAtPos())},pp.readToken=function(code){return isIdentifierStart(code,this.options.ecmaVersion>=6)||92===code?this.readWord():this.getTokenFromCode(code)},pp.fullCharCodeAtPos=function(){var code=this.input.charCodeAt(this.pos);if(code<=55295||code>=56320)return code;var next=this.input.charCodeAt(this.pos+1);return next<=56319||next>=57344?code:(code<<10)+next-56613888},pp.skipBlockComment=function(){var startLoc=this.options.onComment&&this.curPosition(),start=this.pos,end=this.input.indexOf("*/",this.pos+=2);if(-1===end&&this.raise(this.pos-2,"Unterminated comment"),this.pos=end+2,this.options.locations)for(var nextBreak=void 0,pos=start;(nextBreak=nextLineBreak(this.input,pos,this.pos))>-1;)++this.curLine,pos=this.lineStart=nextBreak;this.options.onComment&&this.options.onComment(true,this.input.slice(start+2,end),start,this.pos,startLoc,this.curPosition());},pp.skipLineComment=function(startSkip){for(var start=this.pos,startLoc=this.options.onComment&&this.curPosition(),ch=this.input.charCodeAt(this.pos+=startSkip);this.pos<this.input.length&&!isNewLine(ch);)ch=this.input.charCodeAt(++this.pos);this.options.onComment&&this.options.onComment(false,this.input.slice(start+startSkip,this.pos),start,this.pos,startLoc,this.curPosition());},pp.skipSpace=function(){loop:for(;this.pos<this.input.length;){var ch=this.input.charCodeAt(this.pos);switch(ch){case 32:case 160:++this.pos;break;case 13:10===this.input.charCodeAt(this.pos+1)&&++this.pos;case 10:case 8232:case 8233:++this.pos,this.options.locations&&(++this.curLine,this.lineStart=this.pos);break;case 47:switch(this.input.charCodeAt(this.pos+1)){case 42:this.skipBlockComment();break;case 47:this.skipLineComment(2);break;default:break loop}break;default:if(!(ch>8&&ch<14||ch>=5760&&nonASCIIwhitespace.test(String.fromCharCode(ch))))break loop;++this.pos;}}},pp.finishToken=function(type,val){this.end=this.pos,this.options.locations&&(this.endLoc=this.curPosition());var prevType=this.type;this.type=type,this.value=val,this.updateContext(prevType);},pp.readToken_dot=function(){var next=this.input.charCodeAt(this.pos+1);if(next>=48&&next<=57)return this.readNumber(true);var next2=this.input.charCodeAt(this.pos+2);return this.options.ecmaVersion>=6&&46===next&&46===next2?(this.pos+=3,this.finishToken(types$1.ellipsis)):(++this.pos,this.finishToken(types$1.dot))},pp.readToken_slash=function(){var next=this.input.charCodeAt(this.pos+1);return this.exprAllowed?(++this.pos,this.readRegexp()):61===next?this.finishOp(types$1.assign,2):this.finishOp(types$1.slash,1)},pp.readToken_mult_modulo_exp=function(code){var next=this.input.charCodeAt(this.pos+1),size=1,tokentype=42===code?types$1.star:types$1.modulo;return this.options.ecmaVersion>=7&&42===code&&42===next&&(++size,tokentype=types$1.starstar,next=this.input.charCodeAt(this.pos+2)),61===next?this.finishOp(types$1.assign,size+1):this.finishOp(tokentype,size)},pp.readToken_pipe_amp=function(code){var next=this.input.charCodeAt(this.pos+1);if(next===code){if(this.options.ecmaVersion>=12)if(61===this.input.charCodeAt(this.pos+2))return this.finishOp(types$1.assign,3);return this.finishOp(124===code?types$1.logicalOR:types$1.logicalAND,2)}return 61===next?this.finishOp(types$1.assign,2):this.finishOp(124===code?types$1.bitwiseOR:types$1.bitwiseAND,1)},pp.readToken_caret=function(){return 61===this.input.charCodeAt(this.pos+1)?this.finishOp(types$1.assign,2):this.finishOp(types$1.bitwiseXOR,1)},pp.readToken_plus_min=function(code){var next=this.input.charCodeAt(this.pos+1);return next===code?45!==next||this.inModule||62!==this.input.charCodeAt(this.pos+2)||0!==this.lastTokEnd&&!lineBreak.test(this.input.slice(this.lastTokEnd,this.pos))?this.finishOp(types$1.incDec,2):(this.skipLineComment(3),this.skipSpace(),this.nextToken()):61===next?this.finishOp(types$1.assign,2):this.finishOp(types$1.plusMin,1)},pp.readToken_lt_gt=function(code){var next=this.input.charCodeAt(this.pos+1),size=1;return next===code?(size=62===code&&62===this.input.charCodeAt(this.pos+2)?3:2,61===this.input.charCodeAt(this.pos+size)?this.finishOp(types$1.assign,size+1):this.finishOp(types$1.bitShift,size)):33!==next||60!==code||this.inModule||45!==this.input.charCodeAt(this.pos+2)||45!==this.input.charCodeAt(this.pos+3)?(61===next&&(size=2),this.finishOp(types$1.relational,size)):(this.skipLineComment(4),this.skipSpace(),this.nextToken())},pp.readToken_eq_excl=function(code){var next=this.input.charCodeAt(this.pos+1);return 61===next?this.finishOp(types$1.equality,61===this.input.charCodeAt(this.pos+2)?3:2):61===code&&62===next&&this.options.ecmaVersion>=6?(this.pos+=2,this.finishToken(types$1.arrow)):this.finishOp(61===code?types$1.eq:types$1.prefix,1)},pp.readToken_question=function(){var ecmaVersion=this.options.ecmaVersion;if(ecmaVersion>=11){var next=this.input.charCodeAt(this.pos+1);if(46===next){var next2=this.input.charCodeAt(this.pos+2);if(next2<48||next2>57)return this.finishOp(types$1.questionDot,2)}if(63===next){if(ecmaVersion>=12)if(61===this.input.charCodeAt(this.pos+2))return this.finishOp(types$1.assign,3);return this.finishOp(types$1.coalesce,2)}}return this.finishOp(types$1.question,1)},pp.readToken_numberSign=function(){var code=35;if(this.options.ecmaVersion>=13&&(++this.pos,isIdentifierStart(code=this.fullCharCodeAtPos(),true)||92===code))return this.finishToken(types$1.privateId,this.readWord1());this.raise(this.pos,"Unexpected character '"+codePointToString(code)+"'");},pp.getTokenFromCode=function(code){switch(code){case 46:return this.readToken_dot();case 40:return ++this.pos,this.finishToken(types$1.parenL);case 41:return ++this.pos,this.finishToken(types$1.parenR);case 59:return ++this.pos,this.finishToken(types$1.semi);case 44:return ++this.pos,this.finishToken(types$1.comma);case 91:return ++this.pos,this.finishToken(types$1.bracketL);case 93:return ++this.pos,this.finishToken(types$1.bracketR);case 123:return ++this.pos,this.finishToken(types$1.braceL);case 125:return ++this.pos,this.finishToken(types$1.braceR);case 58:return ++this.pos,this.finishToken(types$1.colon);case 96:if(this.options.ecmaVersion<6)break;return ++this.pos,this.finishToken(types$1.backQuote);case 48:var next=this.input.charCodeAt(this.pos+1);if(120===next||88===next)return this.readRadixNumber(16);if(this.options.ecmaVersion>=6){if(111===next||79===next)return this.readRadixNumber(8);if(98===next||66===next)return this.readRadixNumber(2)}case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:return this.readNumber(false);case 34:case 39:return this.readString(code);case 47:return this.readToken_slash();case 37:case 42:return this.readToken_mult_modulo_exp(code);case 124:case 38:return this.readToken_pipe_amp(code);case 94:return this.readToken_caret();case 43:case 45:return this.readToken_plus_min(code);case 60:case 62:return this.readToken_lt_gt(code);case 61:case 33:return this.readToken_eq_excl(code);case 63:return this.readToken_question();case 126:return this.finishOp(types$1.prefix,1);case 35:return this.readToken_numberSign()}this.raise(this.pos,"Unexpected character '"+codePointToString(code)+"'");},pp.finishOp=function(type,size){var str=this.input.slice(this.pos,this.pos+size);return this.pos+=size,this.finishToken(type,str)},pp.readRegexp=function(){for(var escaped,inClass,start=this.pos;;){this.pos>=this.input.length&&this.raise(start,"Unterminated regular expression");var ch=this.input.charAt(this.pos);if(lineBreak.test(ch)&&this.raise(start,"Unterminated regular expression"),escaped)escaped=false;else {if("["===ch)inClass=true;else if("]"===ch&&inClass)inClass=false;else if("/"===ch&&!inClass)break;escaped="\\"===ch;}++this.pos;}var pattern=this.input.slice(start,this.pos);++this.pos;var flagsStart=this.pos,flags=this.readWord1();this.containsEsc&&this.unexpected(flagsStart);var state=this.regexpState||(this.regexpState=new RegExpValidationState(this));state.reset(start,pattern,flags),this.validateRegExpFlags(state),this.validateRegExpPattern(state);var value=null;try{value=new RegExp(pattern,flags);}catch(e){}return this.finishToken(types$1.regexp,{pattern,flags,value})},pp.readInt=function(radix,len,maybeLegacyOctalNumericLiteral){for(var allowSeparators=this.options.ecmaVersion>=12&&void 0===len,isLegacyOctalNumericLiteral=maybeLegacyOctalNumericLiteral&&48===this.input.charCodeAt(this.pos),start=this.pos,total=0,lastCode=0,i=0,e=null==len?1/0:len;i<e;++i,++this.pos){var code=this.input.charCodeAt(this.pos),val=void 0;if(allowSeparators&&95===code)isLegacyOctalNumericLiteral&&this.raiseRecoverable(this.pos,"Numeric separator is not allowed in legacy octal numeric literals"),95===lastCode&&this.raiseRecoverable(this.pos,"Numeric separator must be exactly one underscore"),0===i&&this.raiseRecoverable(this.pos,"Numeric separator is not allowed at the first of digits"),lastCode=code;else {if((val=code>=97?code-97+10:code>=65?code-65+10:code>=48&&code<=57?code-48:1/0)>=radix)break;lastCode=code,total=total*radix+val;}}return allowSeparators&&95===lastCode&&this.raiseRecoverable(this.pos-1,"Numeric separator is not allowed at the last of digits"),this.pos===start||null!=len&&this.pos-start!==len?null:total},pp.readRadixNumber=function(radix){var start=this.pos;this.pos+=2;var val=this.readInt(radix);return null==val&&this.raise(this.start+2,"Expected number in radix "+radix),this.options.ecmaVersion>=11&&110===this.input.charCodeAt(this.pos)?(val=stringToBigInt(this.input.slice(start,this.pos)),++this.pos):isIdentifierStart(this.fullCharCodeAtPos())&&this.raise(this.pos,"Identifier directly after number"),this.finishToken(types$1.num,val)},pp.readNumber=function(startsWithDot){var start=this.pos;startsWithDot||null!==this.readInt(10,void 0,true)||this.raise(start,"Invalid number");var octal=this.pos-start>=2&&48===this.input.charCodeAt(start);octal&&this.strict&&this.raise(start,"Invalid number");var next=this.input.charCodeAt(this.pos);if(!octal&&!startsWithDot&&this.options.ecmaVersion>=11&&110===next){var val$1=stringToBigInt(this.input.slice(start,this.pos));return ++this.pos,isIdentifierStart(this.fullCharCodeAtPos())&&this.raise(this.pos,"Identifier directly after number"),this.finishToken(types$1.num,val$1)}octal&&/[89]/.test(this.input.slice(start,this.pos))&&(octal=false),46!==next||octal||(++this.pos,this.readInt(10),next=this.input.charCodeAt(this.pos)),69!==next&&101!==next||octal||(43!==(next=this.input.charCodeAt(++this.pos))&&45!==next||++this.pos,null===this.readInt(10)&&this.raise(start,"Invalid number")),isIdentifierStart(this.fullCharCodeAtPos())&&this.raise(this.pos,"Identifier directly after number");var str,val=(str=this.input.slice(start,this.pos),octal?parseInt(str,8):parseFloat(str.replace(/_/g,"")));return this.finishToken(types$1.num,val)},pp.readCodePoint=function(){var code;if(123===this.input.charCodeAt(this.pos)){this.options.ecmaVersion<6&&this.unexpected();var codePos=++this.pos;code=this.readHexChar(this.input.indexOf("}",this.pos)-this.pos),++this.pos,code>1114111&&this.invalidStringToken(codePos,"Code point out of bounds");}else code=this.readHexChar(4);return code},pp.readString=function(quote){for(var out="",chunkStart=++this.pos;;){this.pos>=this.input.length&&this.raise(this.start,"Unterminated string constant");var ch=this.input.charCodeAt(this.pos);if(ch===quote)break;92===ch?(out+=this.input.slice(chunkStart,this.pos),out+=this.readEscapedChar(false),chunkStart=this.pos):8232===ch||8233===ch?(this.options.ecmaVersion<10&&this.raise(this.start,"Unterminated string constant"),++this.pos,this.options.locations&&(this.curLine++,this.lineStart=this.pos)):(isNewLine(ch)&&this.raise(this.start,"Unterminated string constant"),++this.pos);}return out+=this.input.slice(chunkStart,this.pos++),this.finishToken(types$1.string,out)};var INVALID_TEMPLATE_ESCAPE_ERROR={};pp.tryReadTemplateToken=function(){this.inTemplateElement=true;try{this.readTmplToken();}catch(err){if(err!==INVALID_TEMPLATE_ESCAPE_ERROR)throw err;this.readInvalidTemplateToken();}this.inTemplateElement=false;},pp.invalidStringToken=function(position,message){if(this.inTemplateElement&&this.options.ecmaVersion>=9)throw INVALID_TEMPLATE_ESCAPE_ERROR;this.raise(position,message);},pp.readTmplToken=function(){for(var out="",chunkStart=this.pos;;){this.pos>=this.input.length&&this.raise(this.start,"Unterminated template");var ch=this.input.charCodeAt(this.pos);if(96===ch||36===ch&&123===this.input.charCodeAt(this.pos+1))return this.pos!==this.start||this.type!==types$1.template&&this.type!==types$1.invalidTemplate?(out+=this.input.slice(chunkStart,this.pos),this.finishToken(types$1.template,out)):36===ch?(this.pos+=2,this.finishToken(types$1.dollarBraceL)):(++this.pos,this.finishToken(types$1.backQuote));if(92===ch)out+=this.input.slice(chunkStart,this.pos),out+=this.readEscapedChar(true),chunkStart=this.pos;else if(isNewLine(ch)){switch(out+=this.input.slice(chunkStart,this.pos),++this.pos,ch){case 13:10===this.input.charCodeAt(this.pos)&&++this.pos;case 10:out+="\n";break;default:out+=String.fromCharCode(ch);}this.options.locations&&(++this.curLine,this.lineStart=this.pos),chunkStart=this.pos;}else ++this.pos;}},pp.readInvalidTemplateToken=function(){for(;this.pos<this.input.length;this.pos++)switch(this.input[this.pos]){case "\\":++this.pos;break;case "$":if("{"!==this.input[this.pos+1])break;case "`":return this.finishToken(types$1.invalidTemplate,this.input.slice(this.start,this.pos));case "\r":"\n"===this.input[this.pos+1]&&++this.pos;case "\n":case "\u2028":case "\u2029":++this.curLine,this.lineStart=this.pos+1;}this.raise(this.start,"Unterminated template");},pp.readEscapedChar=function(inTemplate){var ch=this.input.charCodeAt(++this.pos);switch(++this.pos,ch){case 110:return "\n";case 114:return "\r";case 120:return String.fromCharCode(this.readHexChar(2));case 117:return codePointToString(this.readCodePoint());case 116:return "\t";case 98:return "\b";case 118:return "\v";case 102:return "\f";case 13:10===this.input.charCodeAt(this.pos)&&++this.pos;case 10:return this.options.locations&&(this.lineStart=this.pos,++this.curLine),"";case 56:case 57:if(this.strict&&this.invalidStringToken(this.pos-1,"Invalid escape sequence"),inTemplate){var codePos=this.pos-1;this.invalidStringToken(codePos,"Invalid escape sequence in template string");}default:if(ch>=48&&ch<=55){var octalStr=this.input.substr(this.pos-1,3).match(/^[0-7]+/)[0],octal=parseInt(octalStr,8);return octal>255&&(octalStr=octalStr.slice(0,-1),octal=parseInt(octalStr,8)),this.pos+=octalStr.length-1,ch=this.input.charCodeAt(this.pos),"0"===octalStr&&56!==ch&&57!==ch||!this.strict&&!inTemplate||this.invalidStringToken(this.pos-1-octalStr.length,inTemplate?"Octal literal in template string":"Octal literal in strict mode"),String.fromCharCode(octal)}return isNewLine(ch)?(this.options.locations&&(this.lineStart=this.pos,++this.curLine),""):String.fromCharCode(ch)}},pp.readHexChar=function(len){var codePos=this.pos,n=this.readInt(16,len);return null===n&&this.invalidStringToken(codePos,"Bad character escape sequence"),n},pp.readWord1=function(){this.containsEsc=false;for(var word="",first=true,chunkStart=this.pos,astral=this.options.ecmaVersion>=6;this.pos<this.input.length;){var ch=this.fullCharCodeAtPos();if(isIdentifierChar(ch,astral))this.pos+=ch<=65535?1:2;else {if(92!==ch)break;this.containsEsc=true,word+=this.input.slice(chunkStart,this.pos);var escStart=this.pos;117!==this.input.charCodeAt(++this.pos)&&this.invalidStringToken(this.pos,"Expecting Unicode escape sequence \\uXXXX"),++this.pos;var esc=this.readCodePoint();(first?isIdentifierStart:isIdentifierChar)(esc,astral)||this.invalidStringToken(escStart,"Invalid Unicode escape"),word+=codePointToString(esc),chunkStart=this.pos;}first=false;}return word+this.input.slice(chunkStart,this.pos)},pp.readWord=function(){var word=this.readWord1(),type=types$1.name;return this.keywords.test(word)&&(type=keywords[word]),this.finishToken(type,word)};Parser.acorn={Parser,version:"8.14.0",defaultOptions,Position,SourceLocation,getLineInfo,Node,TokenType,tokTypes:types$1,keywordTypes:keywords,TokContext,tokContexts:types,isIdentifierChar,isIdentifierStart,Token,isNewLine,lineBreak,lineBreakG,nonASCIIwhitespace};const external_node_module_namespaceObject=require$$1$3,external_node_fs_namespaceObject=fs$1;const JOIN_LEADING_SLASH_RE=/^\.?\//;function withTrailingSlash(input="",respectQueryAndFragment){return input.endsWith("/")?input:input+"/";}function isNonEmptyURL(url){return url&&"/"!==url}function dist_joinURL(base,...input){let url=base||"";for(const segment of input.filter((url2=>isNonEmptyURL(url2))))if(url){const _segment=segment.replace(JOIN_LEADING_SLASH_RE,"");url=withTrailingSlash(url)+_segment;}else url=segment;return url}const _DRIVE_LETTER_START_RE=/^[A-Za-z]:\//;function normalizeWindowsPath(input=""){return input?input.replace(/\\/g,"/").replace(_DRIVE_LETTER_START_RE,(r=>r.toUpperCase())):input}const _UNC_REGEX=/^[/\\]{2}/,_IS_ABSOLUTE_RE=/^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Za-z]:[/\\]/,_DRIVE_LETTER_RE=/^[A-Za-z]:$/,pathe_ff20891b_normalize=function(path){if(0===path.length)return ".";const isUNCPath=(path=normalizeWindowsPath(path)).match(_UNC_REGEX),isPathAbsolute=isAbsolute(path),trailingSeparator="/"===path[path.length-1];return 0===(path=normalizeString(path,!isPathAbsolute)).length?isPathAbsolute?"/":trailingSeparator?"./":".":(trailingSeparator&&(path+="/"),_DRIVE_LETTER_RE.test(path)&&(path+="/"),isUNCPath?isPathAbsolute?`//${path}`:`//./${path}`:isPathAbsolute&&!isAbsolute(path)?`/${path}`:path)},join=function(...arguments_){if(0===arguments_.length)return ".";let joined;for(const argument of arguments_)argument&&argument.length>0&&(void 0===joined?joined=argument:joined+=`/${argument}`);return void 0===joined?".":pathe_ff20891b_normalize(joined.replace(/\/\/+/g,"/"))};const resolve=function(...arguments_){let resolvedPath="",resolvedAbsolute=false;for(let index=(arguments_=arguments_.map((argument=>normalizeWindowsPath(argument)))).length-1;index>=-1&&!resolvedAbsolute;index--){const path=index>=0?arguments_[index]:"undefined"!=typeof process&&"function"==typeof process.cwd?process.cwd().replace(/\\/g,"/"):"/";path&&0!==path.length&&(resolvedPath=`${path}/${resolvedPath}`,resolvedAbsolute=isAbsolute(path));}return resolvedPath=normalizeString(resolvedPath,!resolvedAbsolute),resolvedAbsolute&&!isAbsolute(resolvedPath)?`/${resolvedPath}`:resolvedPath.length>0?resolvedPath:"."};function normalizeString(path,allowAboveRoot){let res="",lastSegmentLength=0,lastSlash=-1,dots=0,char=null;for(let index=0;index<=path.length;++index){if(index<path.length)char=path[index];else {if("/"===char)break;char="/";}if("/"===char){if(lastSlash===index-1||1===dots);else if(2===dots){if(res.length<2||2!==lastSegmentLength||"."!==res[res.length-1]||"."!==res[res.length-2]){if(res.length>2){const lastSlashIndex=res.lastIndexOf("/");-1===lastSlashIndex?(res="",lastSegmentLength=0):(res=res.slice(0,lastSlashIndex),lastSegmentLength=res.length-1-res.lastIndexOf("/")),lastSlash=index,dots=0;continue}if(res.length>0){res="",lastSegmentLength=0,lastSlash=index,dots=0;continue}}allowAboveRoot&&(res+=res.length>0?"/..":"..",lastSegmentLength=2);}else res.length>0?res+=`/${path.slice(lastSlash+1,index)}`:res=path.slice(lastSlash+1,index),lastSegmentLength=index-lastSlash-1;lastSlash=index,dots=0;}else "."===char&&-1!==dots?++dots:dots=-1;}return res}const isAbsolute=function(p){return _IS_ABSOLUTE_RE.test(p)},_EXTNAME_RE=/.(\.[^./]+)$/,extname=function(p){const match=_EXTNAME_RE.exec(normalizeWindowsPath(p));return match&&match[1]||""},pathe_ff20891b_dirname=function(p){const segments=normalizeWindowsPath(p).replace(/\/$/,"").split("/").slice(0,-1);return 1===segments.length&&_DRIVE_LETTER_RE.test(segments[0])&&(segments[0]+="/"),segments.join("/")||(isAbsolute(p)?"/":".")},basename=function(p,extension){const lastSegment=normalizeWindowsPath(p).split("/").pop();return lastSegment},external_node_url_namespaceObject=require$$3$2,external_node_assert_namespaceObject=require$$4$3,external_node_process_namespaceObject=process$2,external_node_path_namespaceObject=path,external_node_v8_namespaceObject=require$$7$2,external_node_util_namespaceObject=require$$1$1,BUILTIN_MODULES=new Set(external_node_module_namespaceObject.builtinModules);function normalizeSlash(path){return path.replace(/\\/g,"/")}const own$1={}.hasOwnProperty,classRegExp=/^([A-Z][a-z\d]*)+$/,kTypes=new Set(["string","function","number","object","Function","Object","boolean","bigint","symbol"]),codes={};function formatList(array,type="and"){return array.length<3?array.join(` ${type} `):`${array.slice(0,-1).join(", ")}, ${type} ${array[array.length-1]}`}const messages=new Map;let userStackTraceLimit;function createError(sym,value,constructor){return messages.set(sym,value),function(Base,key){return NodeError;function NodeError(...parameters){const limit=Error.stackTraceLimit;isErrorStackTraceLimitWritable()&&(Error.stackTraceLimit=0);const error=new Base;isErrorStackTraceLimitWritable()&&(Error.stackTraceLimit=limit);const message=function(key,parameters,self){const message=messages.get(key);if(external_node_assert_namespaceObject(void 0!==message,"expected `message` to be found"),"function"==typeof message)return external_node_assert_namespaceObject(message.length<=parameters.length,`Code: ${key}; The provided arguments length (${parameters.length}) does not match the required ones (${message.length}).`),Reflect.apply(message,self,parameters);const regex=/%[dfijoOs]/g;let expectedLength=0;for(;null!==regex.exec(message);)expectedLength++;return external_node_assert_namespaceObject(expectedLength===parameters.length,`Code: ${key}; The provided arguments length (${parameters.length}) does not match the required ones (${expectedLength}).`),0===parameters.length?message:(parameters.unshift(message),Reflect.apply(external_node_util_namespaceObject.format,null,parameters))}(key,parameters,error);return Object.defineProperties(error,{message:{value:message,enumerable:false,writable:true,configurable:true},toString:{value(){return `${this.name} [${key}]: ${this.message}`},enumerable:false,writable:true,configurable:true}}),captureLargerStackTrace(error),error.code=key,error}}(constructor,sym)}function isErrorStackTraceLimitWritable(){try{if(external_node_v8_namespaceObject.startupSnapshot.isBuildingSnapshot())return !1}catch{}const desc=Object.getOwnPropertyDescriptor(Error,"stackTraceLimit");return void 0===desc?Object.isExtensible(Error):own$1.call(desc,"writable")&&void 0!==desc.writable?desc.writable:void 0!==desc.set}codes.ERR_INVALID_ARG_TYPE=createError("ERR_INVALID_ARG_TYPE",((name,expected,actual)=>{external_node_assert_namespaceObject("string"==typeof name,"'name' must be a string"),Array.isArray(expected)||(expected=[expected]);let message="The ";if(name.endsWith(" argument"))message+=`${name} `;else {const type=name.includes(".")?"property":"argument";message+=`"${name}" ${type} `;}message+="must be ";const types=[],instances=[],other=[];for(const value of expected)external_node_assert_namespaceObject("string"==typeof value,"All expected entries have to be of type string"),kTypes.has(value)?types.push(value.toLowerCase()):null===classRegExp.exec(value)?(external_node_assert_namespaceObject("object"!==value,'The value "object" should be written as "Object"'),other.push(value)):instances.push(value);if(instances.length>0){const pos=types.indexOf("object");-1!==pos&&(types.slice(pos,1),instances.push("Object"));}return types.length>0&&(message+=`${types.length>1?"one of type":"of type"} ${formatList(types,"or")}`,(instances.length>0||other.length>0)&&(message+=" or ")),instances.length>0&&(message+=`an instance of ${formatList(instances,"or")}`,other.length>0&&(message+=" or ")),other.length>0&&(other.length>1?message+=`one of ${formatList(other,"or")}`:(other[0].toLowerCase()!==other[0]&&(message+="an "),message+=`${other[0]}`)),message+=`. Received ${function(value){if(null==value)return String(value);if("function"==typeof value&&value.name)return `function ${value.name}`;if("object"==typeof value)return value.constructor&&value.constructor.name?`an instance of ${value.constructor.name}`:`${(0, external_node_util_namespaceObject.inspect)(value,{depth:-1})}`;let inspected=(0, external_node_util_namespaceObject.inspect)(value,{colors:false});inspected.length>28&&(inspected=`${inspected.slice(0,25)}...`);return `type ${typeof value} (${inspected})`}(actual)}`,message}),TypeError),codes.ERR_INVALID_MODULE_SPECIFIER=createError("ERR_INVALID_MODULE_SPECIFIER",((request,reason,base=void 0)=>`Invalid module "${request}" ${reason}${base?` imported from ${base}`:""}`),TypeError),codes.ERR_INVALID_PACKAGE_CONFIG=createError("ERR_INVALID_PACKAGE_CONFIG",((path,base,message)=>`Invalid package config ${path}${base?` while importing ${base}`:""}${message?`. ${message}`:""}`),Error),codes.ERR_INVALID_PACKAGE_TARGET=createError("ERR_INVALID_PACKAGE_TARGET",((packagePath,key,target,isImport=false,base=void 0)=>{const relatedError="string"==typeof target&&!isImport&&target.length>0&&!target.startsWith("./");return "."===key?(external_node_assert_namespaceObject(false===isImport),`Invalid "exports" main target ${JSON.stringify(target)} defined in the package config ${packagePath}package.json${base?` imported from ${base}`:""}${relatedError?'; targets must start with "./"':""}`):`Invalid "${isImport?"imports":"exports"}" target ${JSON.stringify(target)} defined for '${key}' in the package config ${packagePath}package.json${base?` imported from ${base}`:""}${relatedError?'; targets must start with "./"':""}`}),Error),codes.ERR_MODULE_NOT_FOUND=createError("ERR_MODULE_NOT_FOUND",((path,base,exactUrl=false)=>`Cannot find ${exactUrl?"module":"package"} '${path}' imported from ${base}`),Error),codes.ERR_NETWORK_IMPORT_DISALLOWED=createError("ERR_NETWORK_IMPORT_DISALLOWED","import of '%s' by %s is not supported: %s",Error),codes.ERR_PACKAGE_IMPORT_NOT_DEFINED=createError("ERR_PACKAGE_IMPORT_NOT_DEFINED",((specifier,packagePath,base)=>`Package import specifier "${specifier}" is not defined${packagePath?` in package ${packagePath}package.json`:""} imported from ${base}`),TypeError),codes.ERR_PACKAGE_PATH_NOT_EXPORTED=createError("ERR_PACKAGE_PATH_NOT_EXPORTED",((packagePath,subpath,base=void 0)=>"."===subpath?`No "exports" main defined in ${packagePath}package.json${base?` imported from ${base}`:""}`:`Package subpath '${subpath}' is not defined by "exports" in ${packagePath}package.json${base?` imported from ${base}`:""}`),Error),codes.ERR_UNSUPPORTED_DIR_IMPORT=createError("ERR_UNSUPPORTED_DIR_IMPORT","Directory import '%s' is not supported resolving ES modules imported from %s",Error),codes.ERR_UNSUPPORTED_RESOLVE_REQUEST=createError("ERR_UNSUPPORTED_RESOLVE_REQUEST",'Failed to resolve module specifier "%s" from "%s": Invalid relative URL or base scheme is not hierarchical.',TypeError),codes.ERR_UNKNOWN_FILE_EXTENSION=createError("ERR_UNKNOWN_FILE_EXTENSION",((extension,path)=>`Unknown file extension "${extension}" for ${path}`),TypeError),codes.ERR_INVALID_ARG_VALUE=createError("ERR_INVALID_ARG_VALUE",((name,value,reason="is invalid")=>{let inspected=(0, external_node_util_namespaceObject.inspect)(value);inspected.length>128&&(inspected=`${inspected.slice(0,128)}...`);return `The ${name.includes(".")?"property":"argument"} '${name}' ${reason}. Received ${inspected}`}),TypeError);const captureLargerStackTrace=function(wrappedFunction){const hidden="__node_internal_"+wrappedFunction.name;return Object.defineProperty(wrappedFunction,"name",{value:hidden}),wrappedFunction}((function(error){const stackTraceLimitIsWritable=isErrorStackTraceLimitWritable();return stackTraceLimitIsWritable&&(userStackTraceLimit=Error.stackTraceLimit,Error.stackTraceLimit=Number.POSITIVE_INFINITY),Error.captureStackTrace(error),stackTraceLimitIsWritable&&(Error.stackTraceLimit=userStackTraceLimit),error}));const hasOwnProperty$1={}.hasOwnProperty,{ERR_INVALID_PACKAGE_CONFIG:ERR_INVALID_PACKAGE_CONFIG$1}=codes,cache=new Map;function read(jsonPath,{base,specifier}){const existing=cache.get(jsonPath);if(existing)return existing;let string;try{string=external_node_fs_namespaceObject.readFileSync(external_node_path_namespaceObject.toNamespacedPath(jsonPath),"utf8");}catch(error){const exception=error;if("ENOENT"!==exception.code)throw exception}const result={exists:false,pjsonPath:jsonPath,main:void 0,name:void 0,type:"none",exports:void 0,imports:void 0};if(void 0!==string){let parsed;try{parsed=JSON.parse(string);}catch(error_){const cause=error_,error=new ERR_INVALID_PACKAGE_CONFIG$1(jsonPath,(base?`"${specifier}" from `:"")+(0, external_node_url_namespaceObject.fileURLToPath)(base||specifier),cause.message);throw error.cause=cause,error}result.exists=true,hasOwnProperty$1.call(parsed,"name")&&"string"==typeof parsed.name&&(result.name=parsed.name),hasOwnProperty$1.call(parsed,"main")&&"string"==typeof parsed.main&&(result.main=parsed.main),hasOwnProperty$1.call(parsed,"exports")&&(result.exports=parsed.exports),hasOwnProperty$1.call(parsed,"imports")&&(result.imports=parsed.imports),!hasOwnProperty$1.call(parsed,"type")||"commonjs"!==parsed.type&&"module"!==parsed.type||(result.type=parsed.type);}return cache.set(jsonPath,result),result}function getPackageScopeConfig(resolved){let packageJSONUrl=new URL("package.json",resolved);for(;;){if(packageJSONUrl.pathname.endsWith("node_modules/package.json"))break;const packageConfig=read((0, external_node_url_namespaceObject.fileURLToPath)(packageJSONUrl),{specifier:resolved});if(packageConfig.exists)return packageConfig;const lastPackageJSONUrl=packageJSONUrl;if(packageJSONUrl=new URL("../package.json",packageJSONUrl),packageJSONUrl.pathname===lastPackageJSONUrl.pathname)break}return {pjsonPath:(0, external_node_url_namespaceObject.fileURLToPath)(packageJSONUrl),exists:false,type:"none"}}function getPackageType(url){return getPackageScopeConfig(url).type}const{ERR_UNKNOWN_FILE_EXTENSION}=codes,dist_hasOwnProperty={}.hasOwnProperty,extensionFormatMap={__proto__:null,".cjs":"commonjs",".js":"module",".json":"json",".mjs":"module"};const protocolHandlers={__proto__:null,"data:":function(parsed){const{1:mime}=/^([^/]+\/[^;,]+)[^,]*?(;base64)?,/.exec(parsed.pathname)||[null,null,null];return function(mime){return mime&&/\s*(text|application)\/javascript\s*(;\s*charset=utf-?8\s*)?/i.test(mime)?"module":"application/json"===mime?"json":null}(mime)},"file:":function(url,_context,ignoreErrors){const value=function(url){const pathname=url.pathname;let index=pathname.length;for(;index--;){const code=pathname.codePointAt(index);if(47===code)return "";if(46===code)return 47===pathname.codePointAt(index-1)?"":pathname.slice(index)}return ""}(url);if(".js"===value){const packageType=getPackageType(url);return "none"!==packageType?packageType:"commonjs"}if(""===value){const packageType=getPackageType(url);return "none"===packageType||"commonjs"===packageType?"commonjs":"module"}const format=extensionFormatMap[value];if(format)return format;if(ignoreErrors)return;const filepath=(0, external_node_url_namespaceObject.fileURLToPath)(url);throw new ERR_UNKNOWN_FILE_EXTENSION(value,filepath)},"http:":getHttpProtocolModuleFormat,"https:":getHttpProtocolModuleFormat,"node:":()=>"builtin"};function getHttpProtocolModuleFormat(){}const RegExpPrototypeSymbolReplace=RegExp.prototype[Symbol.replace],{ERR_INVALID_MODULE_SPECIFIER,ERR_INVALID_PACKAGE_CONFIG,ERR_INVALID_PACKAGE_TARGET,ERR_MODULE_NOT_FOUND,ERR_PACKAGE_IMPORT_NOT_DEFINED,ERR_PACKAGE_PATH_NOT_EXPORTED,ERR_UNSUPPORTED_DIR_IMPORT,ERR_UNSUPPORTED_RESOLVE_REQUEST}=codes,own={}.hasOwnProperty,invalidSegmentRegEx=/(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))?(\\|\/|$)/i,deprecatedInvalidSegmentRegEx=/(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i,invalidPackageNameRegEx=/^\.|%|\\/,patternRegEx=/\*/g,encodedSeparatorRegEx=/%2f|%5c/i,emittedPackageWarnings=new Set,doubleSlashRegEx=/[/\\]{2}/;function emitInvalidSegmentDeprecation(target,request,match,packageJsonUrl,internal,base,isTarget){if(external_node_process_namespaceObject.noDeprecation)return;const pjsonPath=(0, external_node_url_namespaceObject.fileURLToPath)(packageJsonUrl),double=null!==doubleSlashRegEx.exec(isTarget?target:request);external_node_process_namespaceObject.emitWarning(`Use of deprecated ${double?"double slash":"leading or trailing slash matching"} resolving "${target}" for module request "${request}" ${request===match?"":`matched to "${match}" `}in the "${internal?"imports":"exports"}" field module resolution of the package at ${pjsonPath}${base?` imported from ${(0, external_node_url_namespaceObject.fileURLToPath)(base)}`:""}.`,"DeprecationWarning","DEP0166");}function emitLegacyIndexDeprecation(url,packageJsonUrl,base,main){if(external_node_process_namespaceObject.noDeprecation)return;const format=function(url,context){const protocol=url.protocol;return dist_hasOwnProperty.call(protocolHandlers,protocol)&&protocolHandlers[protocol](url,context,true)||null}(url,{parentURL:base.href});if("module"!==format)return;const urlPath=(0, external_node_url_namespaceObject.fileURLToPath)(url.href),packagePath=(0, external_node_url_namespaceObject.fileURLToPath)(new external_node_url_namespaceObject.URL(".",packageJsonUrl)),basePath=(0, external_node_url_namespaceObject.fileURLToPath)(base);main?external_node_path_namespaceObject.resolve(packagePath,main)!==urlPath&&external_node_process_namespaceObject.emitWarning(`Package ${packagePath} has a "main" field set to "${main}", excluding the full filename and extension to the resolved file at "${urlPath.slice(packagePath.length)}", imported from ${basePath}.\n Automatic extension resolution of the "main" field is deprecated for ES modules.`,"DeprecationWarning","DEP0151"):external_node_process_namespaceObject.emitWarning(`No "main" or "exports" field defined in the package.json for ${packagePath} resolving the main entry point "${urlPath.slice(packagePath.length)}", imported from ${basePath}.\nDefault "index" lookups for the main are deprecated for ES modules.`,"DeprecationWarning","DEP0151");}function tryStatSync(path){try{return (0,external_node_fs_namespaceObject.statSync)(path)}catch{}}function fileExists(url){const stats=(0, external_node_fs_namespaceObject.statSync)(url,{throwIfNoEntry:false}),isFile=stats?stats.isFile():void 0;return null!=isFile&&isFile}function legacyMainResolve(packageJsonUrl,packageConfig,base){let guess;if(void 0!==packageConfig.main){if(guess=new external_node_url_namespaceObject.URL(packageConfig.main,packageJsonUrl),fileExists(guess))return guess;const tries=[`./${packageConfig.main}.js`,`./${packageConfig.main}.json`,`./${packageConfig.main}.node`,`./${packageConfig.main}/index.js`,`./${packageConfig.main}/index.json`,`./${packageConfig.main}/index.node`];let i=-1;for(;++i<tries.length&&(guess=new external_node_url_namespaceObject.URL(tries[i],packageJsonUrl),!fileExists(guess));)guess=void 0;if(guess)return emitLegacyIndexDeprecation(guess,packageJsonUrl,base,packageConfig.main),guess}const tries=["./index.js","./index.json","./index.node"];let i=-1;for(;++i<tries.length&&(guess=new external_node_url_namespaceObject.URL(tries[i],packageJsonUrl),!fileExists(guess));)guess=void 0;if(guess)return emitLegacyIndexDeprecation(guess,packageJsonUrl,base,packageConfig.main),guess;throw new ERR_MODULE_NOT_FOUND((0, external_node_url_namespaceObject.fileURLToPath)(new external_node_url_namespaceObject.URL(".",packageJsonUrl)),(0, external_node_url_namespaceObject.fileURLToPath)(base))}function exportsNotFound(subpath,packageJsonUrl,base){return new ERR_PACKAGE_PATH_NOT_EXPORTED((0, external_node_url_namespaceObject.fileURLToPath)(new external_node_url_namespaceObject.URL(".",packageJsonUrl)),subpath,base&&(0, external_node_url_namespaceObject.fileURLToPath)(base))}function invalidPackageTarget(subpath,target,packageJsonUrl,internal,base){return target="object"==typeof target&&null!==target?JSON.stringify(target,null,""):`${target}`,new ERR_INVALID_PACKAGE_TARGET((0, external_node_url_namespaceObject.fileURLToPath)(new external_node_url_namespaceObject.URL(".",packageJsonUrl)),subpath,target,internal,base&&(0, external_node_url_namespaceObject.fileURLToPath)(base))}function resolvePackageTargetString(target,subpath,match,packageJsonUrl,base,pattern,internal,isPathMap,conditions){if(""!==subpath&&!pattern&&"/"!==target[target.length-1])throw invalidPackageTarget(match,target,packageJsonUrl,internal,base);if(!target.startsWith("./")){if(internal&&!target.startsWith("../")&&!target.startsWith("/")){let isURL=false;try{new external_node_url_namespaceObject.URL(target),isURL=!0;}catch{}if(!isURL){return packageResolve(pattern?RegExpPrototypeSymbolReplace.call(patternRegEx,target,(()=>subpath)):target+subpath,packageJsonUrl,conditions)}}throw invalidPackageTarget(match,target,packageJsonUrl,internal,base)}if(null!==invalidSegmentRegEx.exec(target.slice(2))){if(null!==deprecatedInvalidSegmentRegEx.exec(target.slice(2)))throw invalidPackageTarget(match,target,packageJsonUrl,internal,base);if(!isPathMap){const request=pattern?match.replace("*",(()=>subpath)):match+subpath;emitInvalidSegmentDeprecation(pattern?RegExpPrototypeSymbolReplace.call(patternRegEx,target,(()=>subpath)):target,request,match,packageJsonUrl,internal,base,true);}}const resolved=new external_node_url_namespaceObject.URL(target,packageJsonUrl),resolvedPath=resolved.pathname,packagePath=new external_node_url_namespaceObject.URL(".",packageJsonUrl).pathname;if(!resolvedPath.startsWith(packagePath))throw invalidPackageTarget(match,target,packageJsonUrl,internal,base);if(""===subpath)return resolved;if(null!==invalidSegmentRegEx.exec(subpath)){const request=pattern?match.replace("*",(()=>subpath)):match+subpath;if(null===deprecatedInvalidSegmentRegEx.exec(subpath)){if(!isPathMap){emitInvalidSegmentDeprecation(pattern?RegExpPrototypeSymbolReplace.call(patternRegEx,target,(()=>subpath)):target,request,match,packageJsonUrl,internal,base,false);}}else !function(request,match,packageJsonUrl,internal,base){const reason=`request is not a valid match in pattern "${match}" for the "${internal?"imports":"exports"}" resolution of ${(0, external_node_url_namespaceObject.fileURLToPath)(packageJsonUrl)}`;throw new ERR_INVALID_MODULE_SPECIFIER(request,reason,base&&(0, external_node_url_namespaceObject.fileURLToPath)(base))}(request,match,packageJsonUrl,internal,base);}return pattern?new external_node_url_namespaceObject.URL(RegExpPrototypeSymbolReplace.call(patternRegEx,resolved.href,(()=>subpath))):new external_node_url_namespaceObject.URL(subpath,resolved)}function isArrayIndex(key){const keyNumber=Number(key);return `${keyNumber}`===key&&(keyNumber>=0&&keyNumber<4294967295)}function resolvePackageTarget(packageJsonUrl,target,subpath,packageSubpath,base,pattern,internal,isPathMap,conditions){if("string"==typeof target)return resolvePackageTargetString(target,subpath,packageSubpath,packageJsonUrl,base,pattern,internal,isPathMap,conditions);if(Array.isArray(target)){const targetList=target;if(0===targetList.length)return null;let lastException,i=-1;for(;++i<targetList.length;){const targetItem=targetList[i];let resolveResult;try{resolveResult=resolvePackageTarget(packageJsonUrl,targetItem,subpath,packageSubpath,base,pattern,internal,isPathMap,conditions);}catch(error){if(lastException=error,"ERR_INVALID_PACKAGE_TARGET"===error.code)continue;throw error}if(void 0!==resolveResult){if(null!==resolveResult)return resolveResult;lastException=null;}}if(null==lastException)return null;throw lastException}if("object"==typeof target&&null!==target){const keys=Object.getOwnPropertyNames(target);let i=-1;for(;++i<keys.length;){if(isArrayIndex(keys[i]))throw new ERR_INVALID_PACKAGE_CONFIG((0, external_node_url_namespaceObject.fileURLToPath)(packageJsonUrl),base,'"exports" cannot contain numeric property keys.')}for(i=-1;++i<keys.length;){const key=keys[i];if("default"===key||conditions&&conditions.has(key)){const resolveResult=resolvePackageTarget(packageJsonUrl,target[key],subpath,packageSubpath,base,pattern,internal,isPathMap,conditions);if(void 0===resolveResult)continue;return resolveResult}}return null}if(null===target)return null;throw invalidPackageTarget(packageSubpath,target,packageJsonUrl,internal,base)}function emitTrailingSlashPatternDeprecation(match,pjsonUrl,base){if(external_node_process_namespaceObject.noDeprecation)return;const pjsonPath=(0, external_node_url_namespaceObject.fileURLToPath)(pjsonUrl);emittedPackageWarnings.has(pjsonPath+"|"+match)||(emittedPackageWarnings.add(pjsonPath+"|"+match),external_node_process_namespaceObject.emitWarning(`Use of deprecated trailing slash pattern mapping "${match}" in the "exports" field module resolution of the package at ${pjsonPath}${base?` imported from ${(0, external_node_url_namespaceObject.fileURLToPath)(base)}`:""}. Mapping specifiers ending in "/" is no longer supported.`,"DeprecationWarning","DEP0155"));}function packageExportsResolve(packageJsonUrl,packageSubpath,packageConfig,base,conditions){let exports=packageConfig.exports;if(function(exports,packageJsonUrl,base){if("string"==typeof exports||Array.isArray(exports))return  true;if("object"!=typeof exports||null===exports)return  false;const keys=Object.getOwnPropertyNames(exports);let isConditionalSugar=false,i=0,keyIndex=-1;for(;++keyIndex<keys.length;){const key=keys[keyIndex],currentIsConditionalSugar=""===key||"."!==key[0];if(0==i++)isConditionalSugar=currentIsConditionalSugar;else if(isConditionalSugar!==currentIsConditionalSugar)throw new ERR_INVALID_PACKAGE_CONFIG((0, external_node_url_namespaceObject.fileURLToPath)(packageJsonUrl),base,"\"exports\" cannot contain some keys starting with '.' and some not. The exports object must either be an object of package subpath keys or an object of main entry condition name keys only.")}return isConditionalSugar}(exports,packageJsonUrl,base)&&(exports={".":exports}),own.call(exports,packageSubpath)&&!packageSubpath.includes("*")&&!packageSubpath.endsWith("/")){const resolveResult=resolvePackageTarget(packageJsonUrl,exports[packageSubpath],"",packageSubpath,base,false,false,false,conditions);if(null==resolveResult)throw exportsNotFound(packageSubpath,packageJsonUrl,base);return resolveResult}let bestMatch="",bestMatchSubpath="";const keys=Object.getOwnPropertyNames(exports);let i=-1;for(;++i<keys.length;){const key=keys[i],patternIndex=key.indexOf("*");if(-1!==patternIndex&&packageSubpath.startsWith(key.slice(0,patternIndex))){packageSubpath.endsWith("/")&&emitTrailingSlashPatternDeprecation(packageSubpath,packageJsonUrl,base);const patternTrailer=key.slice(patternIndex+1);packageSubpath.length>=key.length&&packageSubpath.endsWith(patternTrailer)&&1===patternKeyCompare(bestMatch,key)&&key.lastIndexOf("*")===patternIndex&&(bestMatch=key,bestMatchSubpath=packageSubpath.slice(patternIndex,packageSubpath.length-patternTrailer.length));}}if(bestMatch){const resolveResult=resolvePackageTarget(packageJsonUrl,exports[bestMatch],bestMatchSubpath,bestMatch,base,true,false,packageSubpath.endsWith("/"),conditions);if(null==resolveResult)throw exportsNotFound(packageSubpath,packageJsonUrl,base);return resolveResult}throw exportsNotFound(packageSubpath,packageJsonUrl,base)}function patternKeyCompare(a,b){const aPatternIndex=a.indexOf("*"),bPatternIndex=b.indexOf("*"),baseLengthA=-1===aPatternIndex?a.length:aPatternIndex+1,baseLengthB=-1===bPatternIndex?b.length:bPatternIndex+1;return baseLengthA>baseLengthB?-1:baseLengthB>baseLengthA||-1===aPatternIndex?1:-1===bPatternIndex||a.length>b.length?-1:b.length>a.length?1:0}function packageImportsResolve(name,base,conditions){if("#"===name||name.startsWith("#/")||name.endsWith("/")){throw new ERR_INVALID_MODULE_SPECIFIER(name,"is not a valid internal imports specifier name",(0, external_node_url_namespaceObject.fileURLToPath)(base))}let packageJsonUrl;const packageConfig=getPackageScopeConfig(base);if(packageConfig.exists){packageJsonUrl=(0, external_node_url_namespaceObject.pathToFileURL)(packageConfig.pjsonPath);const imports=packageConfig.imports;if(imports)if(own.call(imports,name)&&!name.includes("*")){const resolveResult=resolvePackageTarget(packageJsonUrl,imports[name],"",name,base,false,true,false,conditions);if(null!=resolveResult)return resolveResult}else {let bestMatch="",bestMatchSubpath="";const keys=Object.getOwnPropertyNames(imports);let i=-1;for(;++i<keys.length;){const key=keys[i],patternIndex=key.indexOf("*");if(-1!==patternIndex&&name.startsWith(key.slice(0,-1))){const patternTrailer=key.slice(patternIndex+1);name.length>=key.length&&name.endsWith(patternTrailer)&&1===patternKeyCompare(bestMatch,key)&&key.lastIndexOf("*")===patternIndex&&(bestMatch=key,bestMatchSubpath=name.slice(patternIndex,name.length-patternTrailer.length));}}if(bestMatch){const resolveResult=resolvePackageTarget(packageJsonUrl,imports[bestMatch],bestMatchSubpath,bestMatch,base,true,true,false,conditions);if(null!=resolveResult)return resolveResult}}}throw function(specifier,packageJsonUrl,base){return new ERR_PACKAGE_IMPORT_NOT_DEFINED(specifier,packageJsonUrl&&(0, external_node_url_namespaceObject.fileURLToPath)(new external_node_url_namespaceObject.URL(".",packageJsonUrl)),(0, external_node_url_namespaceObject.fileURLToPath)(base))}(name,packageJsonUrl,base)}function packageResolve(specifier,base,conditions){if(external_node_module_namespaceObject.builtinModules.includes(specifier))return new external_node_url_namespaceObject.URL("node:"+specifier);const{packageName,packageSubpath,isScoped}=function(specifier,base){let separatorIndex=specifier.indexOf("/"),validPackageName=true,isScoped=false;"@"===specifier[0]&&(isScoped=true,-1===separatorIndex||0===specifier.length?validPackageName=false:separatorIndex=specifier.indexOf("/",separatorIndex+1));const packageName=-1===separatorIndex?specifier:specifier.slice(0,separatorIndex);if(null!==invalidPackageNameRegEx.exec(packageName)&&(validPackageName=false),!validPackageName)throw new ERR_INVALID_MODULE_SPECIFIER(specifier,"is not a valid package name",(0, external_node_url_namespaceObject.fileURLToPath)(base));return {packageName,packageSubpath:"."+(-1===separatorIndex?"":specifier.slice(separatorIndex)),isScoped}}(specifier,base),packageConfig=getPackageScopeConfig(base);if(packageConfig.exists){const packageJsonUrl=(0, external_node_url_namespaceObject.pathToFileURL)(packageConfig.pjsonPath);if(packageConfig.name===packageName&&void 0!==packageConfig.exports&&null!==packageConfig.exports)return packageExportsResolve(packageJsonUrl,packageSubpath,packageConfig,base,conditions)}let lastPath,packageJsonUrl=new external_node_url_namespaceObject.URL("./node_modules/"+packageName+"/package.json",base),packageJsonPath=(0, external_node_url_namespaceObject.fileURLToPath)(packageJsonUrl);do{const stat=tryStatSync(packageJsonPath.slice(0,-13));if(!stat||!stat.isDirectory()){lastPath=packageJsonPath,packageJsonUrl=new external_node_url_namespaceObject.URL((isScoped?"../../../../node_modules/":"../../../node_modules/")+packageName+"/package.json",packageJsonUrl),packageJsonPath=(0, external_node_url_namespaceObject.fileURLToPath)(packageJsonUrl);continue}const packageConfig=read(packageJsonPath,{base,specifier});return void 0!==packageConfig.exports&&null!==packageConfig.exports?packageExportsResolve(packageJsonUrl,packageSubpath,packageConfig,base,conditions):"."===packageSubpath?legacyMainResolve(packageJsonUrl,packageConfig,base):new external_node_url_namespaceObject.URL(packageSubpath,packageJsonUrl)}while(packageJsonPath.length!==lastPath.length);throw new ERR_MODULE_NOT_FOUND(packageName,(0, external_node_url_namespaceObject.fileURLToPath)(base),false)}function moduleResolve(specifier,base,conditions,preserveSymlinks){const protocol=base.protocol,isRemote="data:"===protocol||"http:"===protocol||"https:"===protocol;let resolved;if(function(specifier){return ""!==specifier&&("/"===specifier[0]||function(specifier){if("."===specifier[0]){if(1===specifier.length||"/"===specifier[1])return  true;if("."===specifier[1]&&(2===specifier.length||"/"===specifier[2]))return  true}return  false}(specifier))}(specifier))try{resolved=new external_node_url_namespaceObject.URL(specifier,base);}catch(error_){const error=new ERR_UNSUPPORTED_RESOLVE_REQUEST(specifier,base);throw error.cause=error_,error}else if("file:"===protocol&&"#"===specifier[0])resolved=packageImportsResolve(specifier,base,conditions);else try{resolved=new external_node_url_namespaceObject.URL(specifier);}catch(error_){if(isRemote&&!external_node_module_namespaceObject.builtinModules.includes(specifier)){const error=new ERR_UNSUPPORTED_RESOLVE_REQUEST(specifier,base);throw error.cause=error_,error}resolved=packageResolve(specifier,base,conditions);}return external_node_assert_namespaceObject(void 0!==resolved,"expected to be defined"),"file:"!==resolved.protocol?resolved:function(resolved,base,preserveSymlinks){if(null!==encodedSeparatorRegEx.exec(resolved.pathname))throw new ERR_INVALID_MODULE_SPECIFIER(resolved.pathname,'must not include encoded "/" or "\\" characters',(0, external_node_url_namespaceObject.fileURLToPath)(base));let filePath;try{filePath=(0,external_node_url_namespaceObject.fileURLToPath)(resolved);}catch(error){const cause=error;throw Object.defineProperty(cause,"input",{value:String(resolved)}),Object.defineProperty(cause,"module",{value:String(base)}),cause}const stats=tryStatSync(filePath.endsWith("/")?filePath.slice(-1):filePath);if(stats&&stats.isDirectory()){const error=new ERR_UNSUPPORTED_DIR_IMPORT(filePath,(0, external_node_url_namespaceObject.fileURLToPath)(base));throw error.url=String(resolved),error}if(!stats||!stats.isFile()){const error=new ERR_MODULE_NOT_FOUND(filePath||resolved.pathname,base&&(0, external_node_url_namespaceObject.fileURLToPath)(base),true);throw error.url=String(resolved),error}{const real=(0, external_node_fs_namespaceObject.realpathSync)(filePath),{search,hash}=resolved;(resolved=(0, external_node_url_namespaceObject.pathToFileURL)(real+(filePath.endsWith(external_node_path_namespaceObject.sep)?"/":""))).search=search,resolved.hash=hash;}return resolved}(resolved,base)}function fileURLToPath(id){return "string"!=typeof id||id.startsWith("file://")?normalizeSlash((0, external_node_url_namespaceObject.fileURLToPath)(id)):normalizeSlash(id)}function pathToFileURL(id){return (0, external_node_url_namespaceObject.pathToFileURL)(fileURLToPath(id)).toString()}const DEFAULT_CONDITIONS_SET=new Set(["node","import"]),DEFAULT_EXTENSIONS=[".mjs",".cjs",".js",".json"],NOT_FOUND_ERRORS=new Set(["ERR_MODULE_NOT_FOUND","ERR_UNSUPPORTED_DIR_IMPORT","MODULE_NOT_FOUND","ERR_PACKAGE_PATH_NOT_EXPORTED"]);function _tryModuleResolve(id,url,conditions){try{return moduleResolve(id,url,conditions)}catch(error){if(!NOT_FOUND_ERRORS.has(error?.code))throw error}}function _resolve(id,options={}){if("string"!=typeof id){if(!(id instanceof URL))throw new TypeError("input must be a `string` or `URL`");id=fileURLToPath(id);}if(/(node|data|http|https):/.test(id))return id;if(BUILTIN_MODULES.has(id))return "node:"+id;if(id.startsWith("file://")&&(id=fileURLToPath(id)),isAbsolute(id))try{if((0,external_node_fs_namespaceObject.statSync)(id).isFile())return pathToFileURL(id)}catch(error){if("ENOENT"!==error?.code)throw error}const conditionsSet=options.conditions?new Set(options.conditions):DEFAULT_CONDITIONS_SET,_urls=(Array.isArray(options.url)?options.url:[options.url]).filter(Boolean).map((url=>new URL(function(id){return "string"!=typeof id&&(id=id.toString()),/(node|data|http|https|file):/.test(id)?id:BUILTIN_MODULES.has(id)?"node:"+id:"file://"+encodeURI(normalizeSlash(id))}(url.toString()))));0===_urls.length&&_urls.push(new URL(pathToFileURL(process.cwd())));const urls=[..._urls];for(const url of _urls)"file:"===url.protocol&&urls.push(new URL("./",url),new URL(dist_joinURL(url.pathname,"_index.js"),url),new URL("node_modules",url));let resolved;for(const url of urls){if(resolved=_tryModuleResolve(id,url,conditionsSet),resolved)break;for(const prefix of ["","/index"]){for(const extension of options.extensions||DEFAULT_EXTENSIONS)if(resolved=_tryModuleResolve(dist_joinURL(id,prefix)+extension,url,conditionsSet),resolved)break;if(resolved)break}if(resolved)break}if(!resolved){const error=new Error(`Cannot find module ${id} imported from ${urls.join(", ")}`);throw error.code="ERR_MODULE_NOT_FOUND",error}return pathToFileURL(resolved)}function resolveSync(id,options){return _resolve(id,options)}function resolvePathSync(id,options){return fileURLToPath(resolveSync(id,options))}const ESM_RE=/([\s;]|^)(import[\s\w*,{}]*from|import\s*["'*{]|export\b\s*(?:[*{]|default|class|type|function|const|var|let|async function)|import\.meta\b)/m,COMMENT_RE=/\/\*.+?\*\/|\/\/.*(?=[nr])/g;function hasESMSyntax(code,opts={}){return opts.stripComments&&(code=code.replace(COMMENT_RE,"")),ESM_RE.test(code)}function escapeStringRegexp(string){if("string"!=typeof string)throw new TypeError("Expected a string");return string.replace(/[|\\{}()[\]^$+*?.]/g,"\\$&").replace(/-/g,"\\x2d")}const pathSeparators=new Set(["/","\\",void 0]),normalizedAliasSymbol=Symbol.for("pathe:normalizedAlias");function normalizeAliases(_aliases){if(_aliases[normalizedAliasSymbol])return _aliases;const aliases=Object.fromEntries(Object.entries(_aliases).sort((([a],[b])=>function(a,b){return b.split("/").length-a.split("/").length}(a,b))));for(const key in aliases)for(const alias in aliases)alias===key||key.startsWith(alias)||aliases[key].startsWith(alias)&&pathSeparators.has(aliases[key][alias.length])&&(aliases[key]=aliases[alias]+aliases[key].slice(alias.length));return Object.defineProperty(aliases,normalizedAliasSymbol,{value:true,enumerable:false}),aliases}const FILENAME_RE=/(^|[/\\])([^/\\]+?)(?=(\.[^.]+)?$)/;function utils_hasTrailingSlash(path="/"){const lastChar=path[path.length-1];return "/"===lastChar||"\\"===lastChar}const package_namespaceObject={rE:"2.4.2"},external_node_crypto_namespaceObject=require$$9,dist_r=Object.create(null),dist_i=e=>globalThis.process?.env||globalThis.Deno?.env.toObject()||globalThis.__env__||(e?dist_r:globalThis),dist_s=new Proxy(dist_r,{get:(e,o)=>dist_i()[o]??dist_r[o],has:(e,o)=>o in dist_i()||o in dist_r,set:(e,o,E)=>(dist_i(true)[o]=E,true),deleteProperty(e,o){if(!o)return  false;return delete dist_i(true)[o],true},ownKeys(){const e=dist_i(true);return Object.keys(e)}}),dist_t=typeof process<"u"&&process.env&&process.env.NODE_ENV||"",B=[["APPVEYOR"],["AWS_AMPLIFY","AWS_APP_ID",{ci:true}],["AZURE_PIPELINES","SYSTEM_TEAMFOUNDATIONCOLLECTIONURI"],["AZURE_STATIC","INPUT_AZURE_STATIC_WEB_APPS_API_TOKEN"],["APPCIRCLE","AC_APPCIRCLE"],["BAMBOO","bamboo_planKey"],["BITBUCKET","BITBUCKET_COMMIT"],["BITRISE","BITRISE_IO"],["BUDDY","BUDDY_WORKSPACE_ID"],["BUILDKITE"],["CIRCLE","CIRCLECI"],["CIRRUS","CIRRUS_CI"],["CLOUDFLARE_PAGES","CF_PAGES",{ci:true}],["CODEBUILD","CODEBUILD_BUILD_ARN"],["CODEFRESH","CF_BUILD_ID"],["DRONE"],["DRONE","DRONE_BUILD_EVENT"],["DSARI"],["GITHUB_ACTIONS"],["GITLAB","GITLAB_CI"],["GITLAB","CI_MERGE_REQUEST_ID"],["GOCD","GO_PIPELINE_LABEL"],["LAYERCI"],["HUDSON","HUDSON_URL"],["JENKINS","JENKINS_URL"],["MAGNUM"],["NETLIFY"],["NETLIFY","NETLIFY_LOCAL",{ci:false}],["NEVERCODE"],["RENDER"],["SAIL","SAILCI"],["SEMAPHORE"],["SCREWDRIVER"],["SHIPPABLE"],["SOLANO","TDDIUM"],["STRIDER"],["TEAMCITY","TEAMCITY_VERSION"],["TRAVIS"],["VERCEL","NOW_BUILDER"],["VERCEL","VERCEL",{ci:false}],["VERCEL","VERCEL_ENV",{ci:false}],["APPCENTER","APPCENTER_BUILD_ID"],["CODESANDBOX","CODESANDBOX_SSE",{ci:false}],["STACKBLITZ"],["STORMKIT"],["CLEAVR"],["ZEABUR"],["CODESPHERE","CODESPHERE_APP_ID",{ci:true}],["RAILWAY","RAILWAY_PROJECT_ID"],["RAILWAY","RAILWAY_SERVICE_ID"],["DENO-DEPLOY","DENO_DEPLOYMENT_ID"],["FIREBASE_APP_HOSTING","FIREBASE_APP_HOSTING",{ci:true}]];const l=function(){if(globalThis.process?.env)for(const e of B){const o=e[1]||e[0];if(globalThis.process?.env[o])return {name:e[0].toLowerCase(),...e[2]}}return "/bin/jsh"===globalThis.process?.env?.SHELL&&globalThis.process?.versions?.webcontainer?{name:"stackblitz",ci:false}:{name:"",ci:false}}();l.name;function dist_n(e){return !!e&&"false"!==e}const I=globalThis.process?.platform||"";dist_n(dist_s.CI)||false!==l.ci;const R=dist_n(globalThis.process?.stdout&&globalThis.process?.stdout.isTTY);(dist_n(dist_s.DEBUG),"test"===dist_t||dist_n(dist_s.TEST));const _=(dist_n(dist_s.MINIMAL),/^win/i.test(I)),C=(!dist_n(dist_s.NO_COLOR)&&(dist_n(dist_s.FORCE_COLOR)||(R||_)&&dist_s.TERM),(globalThis.process?.versions?.node||"").replace(/^v/,"")||null),y=(Number(C?.split(".")[0]),globalThis.process||Object.create(null)),dist_c={versions:{}},L=(new Proxy(y,{get:(e,o)=>"env"===o?dist_s:o in e?e[o]:o in dist_c?dist_c[o]:void 0}),"node"===globalThis.process?.release?.name),a=!!globalThis.Bun||!!globalThis.process?.versions?.bun,D=!!globalThis.Deno,O=!!globalThis.fastly,F=[[!!globalThis.Netlify,"netlify"],[!!globalThis.EdgeRuntime,"edge-light"],["Cloudflare-Workers"===globalThis.navigator?.userAgent,"workerd"],[O,"fastly"],[D,"deno"],[a,"bun"],[L,"node"]];!function(){const e=F.find((o=>o[0]));if(e)e[1];}();const external_node_tty_namespaceObject=tty__default,hasColors=external_node_tty_namespaceObject?.WriteStream?.prototype?.hasColors?.()??false,base_format=(open,close)=>{if(!hasColors)return input=>input;const openCode=`[${open}m`,closeCode=`[${close}m`;return input=>{const string=input+"";let index=string.indexOf(closeCode);if(-1===index)return openCode+string+closeCode;let result=openCode,lastIndex=0;for(;-1!==index;)result+=string.slice(lastIndex,index)+openCode,lastIndex=index+closeCode.length,index=string.indexOf(closeCode,lastIndex);return result+=string.slice(lastIndex)+closeCode,result}},red=(base_format(31,39)),green=base_format(32,39),yellow=base_format(33,39),blue=base_format(34,39),cyan=(base_format(36,39)),gray=(base_format(90,39));function isDir(filename){if("string"!=typeof filename||filename.startsWith("file://"))return  false;try{return (0,external_node_fs_namespaceObject.lstatSync)(filename).isDirectory()}catch{return  false}}function md5(content,len=8){return (0, external_node_crypto_namespaceObject.createHash)("md5").update(content).digest("hex").slice(0,len)}const debugMap={true:green("true"),false:yellow("false"),"[esm]":blue("[esm]"),"[cjs]":green("[cjs]"),"[import]":blue("[import]"),"[require]":green("[require]"),"[native]":cyan("[native]"),"[transpile]":yellow("[transpile]"),"[fallback]":red("[fallback]"),"[unknown]":red("[unknown]"),"[hit]":green("[hit]"),"[miss]":yellow("[miss]"),"[json]":green("[json]"),"[data]":green("[data]")};function debug(ctx,...args){if(!ctx.opts.debug)return;const cwd=process.cwd();console.log(gray(["[jiti]",...args.map((arg=>arg in debugMap?debugMap[arg]:"string"!=typeof arg?JSON.stringify(arg):arg.replace(cwd,".")))].join(" ")));}function jitiInteropDefault(ctx,mod){return ctx.opts.interopDefault?function(mod){const modType=typeof mod;if(null===mod||"object"!==modType&&"function"!==modType)return mod;const def=mod.default,defType=typeof def;if(null==def)return mod;const defIsObj="object"===defType||"function"===defType;return new Proxy(mod,{get(target,prop,receiver){if("__esModule"===prop)return  true;if("default"===prop)return def;if(Reflect.has(target,prop))return Reflect.get(target,prop,receiver);if(defIsObj){let fallback=Reflect.get(def,prop,receiver);return "function"==typeof fallback&&(fallback=fallback.bind(def)),fallback}},apply:(target,thisArg,args)=>"function"==typeof target?Reflect.apply(target,thisArg,args):"function"===defType?Reflect.apply(def,thisArg,args):void 0})}(mod):mod}function _booleanEnv(name,defaultValue){const val=_jsonEnv(name,defaultValue);return Boolean(val)}function _jsonEnv(name,defaultValue){const envValue=process.env[name];if(!(name in process.env))return defaultValue;try{return JSON.parse(envValue)}catch{return defaultValue}}const JS_EXT_RE=/\.(c|m)?j(sx?)$/,TS_EXT_RE=/\.(c|m)?t(sx?)$/;function jitiResolve(ctx,id,options){let resolved,lastError;if(ctx.isNativeRe.test(id))return id;ctx.alias&&(id=function(path,aliases){const _path=normalizeWindowsPath(path);aliases=normalizeAliases(aliases);for(const[alias,to]of Object.entries(aliases)){if(!_path.startsWith(alias))continue;const _alias=utils_hasTrailingSlash(alias)?alias.slice(0,-1):alias;if(utils_hasTrailingSlash(_path[_alias.length]))return join(to,_path.slice(alias.length))}return _path}(id,ctx.alias));let parentURL=options?.parentURL||ctx.url;isDir(parentURL)&&(parentURL=join(parentURL,"_index.js"));const conditionSets=(options?.async?[options?.conditions,["node","import"],["node","require"]]:[options?.conditions,["node","require"],["node","import"]]).filter(Boolean);for(const conditions of conditionSets){try{resolved=resolvePathSync(id,{url:parentURL,conditions,extensions:ctx.opts.extensions});}catch(error){lastError=error;}if(resolved)return resolved}try{return ctx.nativeRequire.resolve(id,{paths:options.paths})}catch(error){lastError=error;}for(const ext of ctx.additionalExts){if(resolved=tryNativeRequireResolve(ctx,id+ext,parentURL,options)||tryNativeRequireResolve(ctx,id+"/index"+ext,parentURL,options),resolved)return resolved;if((TS_EXT_RE.test(ctx.filename)||TS_EXT_RE.test(ctx.parentModule?.filename||"")||JS_EXT_RE.test(id))&&(resolved=tryNativeRequireResolve(ctx,id.replace(JS_EXT_RE,".$1t$2"),parentURL,options),resolved))return resolved}if(!options?.try)throw lastError}function tryNativeRequireResolve(ctx,id,parentURL,options){try{return ctx.nativeRequire.resolve(id,{...options,paths:[pathe_ff20891b_dirname(fileURLToPath(parentURL)),...options?.paths||[]]})}catch{}}const external_node_perf_hooks_namespaceObject=require$$11,external_node_vm_namespaceObject=require$$12;var external_node_vm_default=__webpack_require__.n(external_node_vm_namespaceObject);function jitiRequire(ctx,id,opts){const cache=ctx.parentCache||{};if(id.startsWith("node:"))id=id.slice(5);else if(id.startsWith("file:"))id=(0, external_node_url_namespaceObject.fileURLToPath)(id);else if(id.startsWith("data:")){if(!opts.async)throw new Error("`data:` URLs are only supported in ESM context. Use `import` or `jiti.import` instead.");return debug(ctx,"[native]","[data]","[import]",id),nativeImportOrRequire(ctx,id,true)}if(external_node_module_namespaceObject.builtinModules.includes(id)||".pnp.js"===id)return nativeImportOrRequire(ctx,id,opts.async);if(ctx.opts.tryNative&&!ctx.opts.transformOptions)try{if(!(id=jitiResolve(ctx,id,opts))&&opts.try)return;if(debug(ctx,"[try-native]",opts.async&&ctx.nativeImport?"[import]":"[require]",id),opts.async&&ctx.nativeImport)return ctx.nativeImport(id).then((m=>(!1===ctx.opts.moduleCache&&delete ctx.nativeRequire.cache[id],jitiInteropDefault(ctx,m))));{const _mod=ctx.nativeRequire(id);return !1===ctx.opts.moduleCache&&delete ctx.nativeRequire.cache[id],jitiInteropDefault(ctx,_mod)}}catch(error){debug(ctx,`[try-native] Using fallback for ${id} because of an error:`,error);}const filename=jitiResolve(ctx,id,opts);if(!filename&&opts.try)return;const ext=extname(filename);if(".json"===ext){debug(ctx,"[json]",filename);const jsonModule=ctx.nativeRequire(filename);return jsonModule&&!("default"in jsonModule)&&Object.defineProperty(jsonModule,"default",{value:jsonModule,enumerable:false}),jsonModule}if(ext&&!ctx.opts.extensions.includes(ext))return debug(ctx,"[native]","[unknown]",opts.async?"[import]":"[require]",filename),nativeImportOrRequire(ctx,filename,opts.async);if(ctx.isNativeRe.test(filename))return debug(ctx,"[native]",opts.async?"[import]":"[require]",filename),nativeImportOrRequire(ctx,filename,opts.async);if(cache[filename])return jitiInteropDefault(ctx,cache[filename]?.exports);if(ctx.opts.moduleCache){const cacheEntry=ctx.nativeRequire.cache[filename];if(cacheEntry?.loaded)return jitiInteropDefault(ctx,cacheEntry.exports)}const source=(0, external_node_fs_namespaceObject.readFileSync)(filename,"utf8");return eval_evalModule(ctx,source,{id,filename,ext,cache,async:opts.async})}function nativeImportOrRequire(ctx,id,async){return async&&ctx.nativeImport?ctx.nativeImport(function(id){return _&&isAbsolute(id)?pathToFileURL(id):id}(id)).then((m=>jitiInteropDefault(ctx,m))):jitiInteropDefault(ctx,ctx.nativeRequire(id))}const CACHE_VERSION="9";function getCache(ctx,topts,get){if(!ctx.opts.fsCache||!topts.filename)return get();const sourceHash=` /* v${CACHE_VERSION}-${md5(topts.source,16)} */\n`;let cacheName=`${basename(pathe_ff20891b_dirname(topts.filename))}-${function(path){return path.match(FILENAME_RE)?.[2]}(topts.filename)}`+(ctx.opts.sourceMaps?"+map":"")+(topts.interopDefault?".i":"")+`.${md5(topts.filename)}`+(topts.async?".mjs":".cjs");topts.jsx&&topts.filename.endsWith("x")&&(cacheName+="x");const cacheDir=ctx.opts.fsCache,cacheFilePath=join(cacheDir,cacheName);if((0, external_node_fs_namespaceObject.existsSync)(cacheFilePath)){const cacheSource=(0, external_node_fs_namespaceObject.readFileSync)(cacheFilePath,"utf8");if(cacheSource.endsWith(sourceHash))return debug(ctx,"[cache]","[hit]",topts.filename,"~>",cacheFilePath),cacheSource}debug(ctx,"[cache]","[miss]",topts.filename);const result=get();return result.includes("__JITI_ERROR__")||((0, external_node_fs_namespaceObject.writeFileSync)(cacheFilePath,result+sourceHash,"utf8"),debug(ctx,"[cache]","[store]",topts.filename,"~>",cacheFilePath)),result}function prepareCacheDir(ctx){if(true===ctx.opts.fsCache&&(ctx.opts.fsCache=function(ctx){const nmDir=ctx.filename&&resolve(ctx.filename,"../node_modules");if(nmDir&&(0, external_node_fs_namespaceObject.existsSync)(nmDir))return join(nmDir,".cache/jiti");let _tmpDir=(0, external_node_os_namespaceObject.tmpdir)();if(process.env.TMPDIR&&_tmpDir===process.cwd()&&!process.env.JITI_RESPECT_TMPDIR_ENV){const _env=process.env.TMPDIR;delete process.env.TMPDIR,_tmpDir=(0, external_node_os_namespaceObject.tmpdir)(),process.env.TMPDIR=_env;}return join(_tmpDir,"jiti")}(ctx)),ctx.opts.fsCache)try{if((0,external_node_fs_namespaceObject.mkdirSync)(ctx.opts.fsCache,{recursive:!0}),!function(filename){try{return (0,external_node_fs_namespaceObject.accessSync)(filename,external_node_fs_namespaceObject.constants.W_OK),!0}catch{return !1}}(ctx.opts.fsCache))throw new Error("directory is not writable!")}catch(error){debug(ctx,"Error creating cache directory at ",ctx.opts.fsCache,error),ctx.opts.fsCache=false;}}function transform(ctx,topts){let code=getCache(ctx,topts,(()=>{const res=ctx.opts.transform({...ctx.opts.transformOptions,babel:{...ctx.opts.sourceMaps?{sourceFileName:topts.filename,sourceMaps:"inline"}:{},...ctx.opts.transformOptions?.babel},interopDefault:ctx.opts.interopDefault,...topts});return res.error&&ctx.opts.debug&&debug(ctx,res.error),res.code}));return code.startsWith("#!")&&(code="// "+code),code}function eval_evalModule(ctx,source,evalOptions={}){const id=evalOptions.id||(evalOptions.filename?basename(evalOptions.filename):`_jitiEval.${evalOptions.ext||(evalOptions.async?"mjs":"js")}`),filename=evalOptions.filename||jitiResolve(ctx,id,{async:evalOptions.async}),ext=evalOptions.ext||extname(filename),cache=evalOptions.cache||ctx.parentCache||{},isTypescript=/\.[cm]?tsx?$/.test(ext),isESM=".mjs"===ext||".js"===ext&&"module"===function(path){for(;path&&"."!==path&&"/"!==path;){path=join(path,"..");try{const pkg=(0,external_node_fs_namespaceObject.readFileSync)(join(path,"package.json"),"utf8");try{return JSON.parse(pkg)}catch{}break}catch{}}}(filename)?.type,isCommonJS=".cjs"===ext,needsTranspile=evalOptions.forceTranspile??(!isCommonJS&&!(isESM&&evalOptions.async)&&(isTypescript||isESM||ctx.isTransformRe.test(filename)||hasESMSyntax(source))),start=external_node_perf_hooks_namespaceObject.performance.now();if(needsTranspile){source=transform(ctx,{filename,source,ts:isTypescript,async:evalOptions.async??false,jsx:ctx.opts.jsx});const time=Math.round(1e3*(external_node_perf_hooks_namespaceObject.performance.now()-start))/1e3;debug(ctx,"[transpile]",evalOptions.async?"[esm]":"[cjs]",filename,`(${time}ms)`);}else {if(debug(ctx,"[native]",evalOptions.async?"[import]":"[require]",filename),evalOptions.async)return Promise.resolve(nativeImportOrRequire(ctx,filename,evalOptions.async)).catch((error=>(debug(ctx,"Native import error:",error),debug(ctx,"[fallback]",filename),eval_evalModule(ctx,source,{...evalOptions,forceTranspile:true}))));try{return nativeImportOrRequire(ctx,filename,evalOptions.async)}catch(error){debug(ctx,"Native require error:",error),debug(ctx,"[fallback]",filename),source=transform(ctx,{filename,source,ts:isTypescript,async:evalOptions.async??false,jsx:ctx.opts.jsx});}}const mod=new external_node_module_namespaceObject.Module(filename);mod.filename=filename,ctx.parentModule&&(mod.parent=ctx.parentModule,Array.isArray(ctx.parentModule.children)&&!ctx.parentModule.children.includes(mod)&&ctx.parentModule.children.push(mod));const _jiti=createJiti(filename,ctx.opts,{parentModule:mod,parentCache:cache,nativeImport:ctx.nativeImport,onError:ctx.onError,createRequire:ctx.createRequire},true);let compiled;mod.require=_jiti,mod.path=pathe_ff20891b_dirname(filename),mod.paths=external_node_module_namespaceObject.Module._nodeModulePaths(mod.path),cache[filename]=mod,ctx.opts.moduleCache&&(ctx.nativeRequire.cache[filename]=mod);const wrapped=function(source,opts){return `(${opts?.async?"async ":""}function (exports, require, module, __filename, __dirname, jitiImport, jitiESMResolve) { ${source}\n});`}(source,{async:evalOptions.async});try{compiled=external_node_vm_default().runInThisContext(wrapped,{filename,lineOffset:0,displayErrors:!1});}catch(error){"SyntaxError"===error.name&&evalOptions.async&&ctx.nativeImport?(debug(ctx,"[esm]","[import]","[fallback]",filename),compiled=function(code,nativeImport){const uri=`data:text/javascript;base64,${Buffer.from(`export default ${code}`).toString("base64")}`;return (...args)=>nativeImport(uri).then((mod=>mod.default(...args)))}(wrapped,ctx.nativeImport)):(ctx.opts.moduleCache&&delete ctx.nativeRequire.cache[filename],ctx.onError(error));}let evalResult;try{evalResult=compiled(mod.exports,mod.require,mod,mod.filename,pathe_ff20891b_dirname(mod.filename),_jiti.import,_jiti.esmResolve);}catch(error){ctx.opts.moduleCache&&delete ctx.nativeRequire.cache[filename],ctx.onError(error);}function next(){if(mod.exports&&mod.exports.__JITI_ERROR__){const{filename,line,column,code,message}=mod.exports.__JITI_ERROR__,err=new Error(`${code}: ${message} \n ${`${filename}:${line}:${column}`}`);Error.captureStackTrace(err,jitiRequire),ctx.onError(err);}mod.loaded=true;return jitiInteropDefault(ctx,mod.exports)}return evalOptions.async?Promise.resolve(evalResult).then(next):next()}const isWindows="win32"===(0, external_node_os_namespaceObject.platform)();function createJiti(filename,userOptions={},parentContext,isNested=false){const opts=isNested?userOptions:function(userOptions){const jitiDefaults={fsCache:_booleanEnv("JITI_FS_CACHE",_booleanEnv("JITI_CACHE",true)),moduleCache:_booleanEnv("JITI_MODULE_CACHE",_booleanEnv("JITI_REQUIRE_CACHE",true)),debug:_booleanEnv("JITI_DEBUG",false),sourceMaps:_booleanEnv("JITI_SOURCE_MAPS",false),interopDefault:_booleanEnv("JITI_INTEROP_DEFAULT",true),extensions:_jsonEnv("JITI_EXTENSIONS",[".js",".mjs",".cjs",".ts",".tsx",".mts",".cts",".mtsx",".ctsx"]),alias:_jsonEnv("JITI_ALIAS",{}),nativeModules:_jsonEnv("JITI_NATIVE_MODULES",[]),transformModules:_jsonEnv("JITI_TRANSFORM_MODULES",[]),tryNative:_jsonEnv("JITI_TRY_NATIVE","Bun"in globalThis),jsx:_booleanEnv("JITI_JSX",false)};jitiDefaults.jsx&&jitiDefaults.extensions.push(".jsx",".tsx");const deprecatOverrides={};return void 0!==userOptions.cache&&(deprecatOverrides.fsCache=userOptions.cache),void 0!==userOptions.requireCache&&(deprecatOverrides.moduleCache=userOptions.requireCache),{...jitiDefaults,...deprecatOverrides,...userOptions}}(userOptions),alias=opts.alias&&Object.keys(opts.alias).length>0?normalizeAliases(opts.alias||{}):void 0,nativeModules=["typescript","jiti",...opts.nativeModules||[]],isNativeRe=new RegExp(`node_modules/(${nativeModules.map((m=>escapeStringRegexp(m))).join("|")})/`),transformModules=[...opts.transformModules||[]],isTransformRe=new RegExp(`node_modules/(${transformModules.map((m=>escapeStringRegexp(m))).join("|")})/`);filename||(filename=process.cwd()),!isNested&&isDir(filename)&&(filename=join(filename,"_index.js"));const url=pathToFileURL(filename),additionalExts=[...opts.extensions].filter((ext=>".js"!==ext)),nativeRequire=parentContext.createRequire(isWindows?filename.replace(/\//g,"\\"):filename),ctx={filename,url,opts,alias,nativeModules,transformModules,isNativeRe,isTransformRe,additionalExts,nativeRequire,onError:parentContext.onError,parentModule:parentContext.parentModule,parentCache:parentContext.parentCache,nativeImport:parentContext.nativeImport,createRequire:parentContext.createRequire};isNested||debug(ctx,"[init]",...[["version:",package_namespaceObject.rE],["module-cache:",opts.moduleCache],["fs-cache:",opts.fsCache],["interop-defaults:",opts.interopDefault]].flat()),isNested||prepareCacheDir(ctx);const jiti=Object.assign((function(id){return jitiRequire(ctx,id,{async:false})}),{cache:opts.moduleCache?nativeRequire.cache:Object.create(null),extensions:nativeRequire.extensions,main:nativeRequire.main,options:opts,resolve:Object.assign((function(path){return jitiResolve(ctx,path,{async:false})}),{paths:nativeRequire.resolve.paths}),transform:opts=>transform(ctx,opts),evalModule:(source,options)=>eval_evalModule(ctx,source,options),async import(id,opts){const mod=await jitiRequire(ctx,id,{...opts,async:true});return opts?.default?mod?.default??mod:mod},esmResolve(id,opts){"string"==typeof opts&&(opts={parentURL:opts});const resolved=jitiResolve(ctx,id,{parentURL:url,...opts,async:true});return !resolved||"string"!=typeof resolved||resolved.startsWith("file://")?resolved:pathToFileURL(resolved)}});return jiti}})(),jiti.exports=__webpack_exports__.default;})();
	return jiti.exports;
}

requireJiti();

var babel = {exports: {}};

var hasRequiredBabel;

function requireBabel () {
	if (hasRequiredBabel) return babel.exports;
	hasRequiredBabel = 1;
	(function (module) {
		(()=>{var __webpack_modules__={"./node_modules/.pnpm/@ampproject+remapping@2.3.0/node_modules/@ampproject/remapping/dist/remapping.umd.js":function(module,__unused_webpack_exports,__webpack_require__){module.exports=function(traceMapping,genMapping){const SOURCELESS_MAPPING=SegmentObject("",-1,-1,"",null,false),EMPTY_SOURCES=[];function SegmentObject(source,line,column,name,content,ignore){return {source,line,column,name,content,ignore}}function Source(map,sources,source,content,ignore){return {map,sources,source,content,ignore}}function MapSource(map,sources){return Source(map,sources,"",null,false)}function OriginalSource(source,content,ignore){return Source(null,EMPTY_SOURCES,source,content,ignore)}function traceMappings(tree){const gen=new genMapping.GenMapping({file:tree.map.file}),{sources:rootSources,map}=tree,rootNames=map.names,rootMappings=traceMapping.decodedMappings(map);for(let i=0;i<rootMappings.length;i++){const segments=rootMappings[i];for(let j=0;j<segments.length;j++){const segment=segments[j],genCol=segment[0];let traced=SOURCELESS_MAPPING;if(1!==segment.length&&(traced=originalPositionFor(rootSources[segment[1]],segment[2],segment[3],5===segment.length?rootNames[segment[4]]:""),null==traced))continue;const{column,line,name,content,source,ignore}=traced;genMapping.maybeAddSegment(gen,i,genCol,source,line,column,name),source&&null!=content&&genMapping.setSourceContent(gen,source,content),ignore&&genMapping.setIgnore(gen,source,true);}}return gen}function originalPositionFor(source,line,column,name){if(!source.map)return SegmentObject(source.source,line,column,name,source.content,source.ignore);const segment=traceMapping.traceSegment(source.map,line,column);return null==segment?null:1===segment.length?SOURCELESS_MAPPING:originalPositionFor(source.sources[segment[1]],segment[2],segment[3],5===segment.length?source.map.names[segment[4]]:name)}function asArray(value){return Array.isArray(value)?value:[value]}function buildSourceMapTree(input,loader){const maps=asArray(input).map((m=>new traceMapping.TraceMap(m,""))),map=maps.pop();for(let i=0;i<maps.length;i++)if(maps[i].sources.length>1)throw new Error(`Transformation map ${i} must have exactly one source file.\nDid you specify these with the most recent transformation maps first?`);let tree=build(map,loader,"",0);for(let i=maps.length-1;i>=0;i--)tree=MapSource(maps[i],[tree]);return tree}function build(map,loader,importer,importerDepth){const{resolvedSources,sourcesContent,ignoreList}=map,depth=importerDepth+1;return MapSource(map,resolvedSources.map(((sourceFile,i)=>{const ctx={importer,depth,source:sourceFile||"",content:void 0,ignore:void 0},sourceMap=loader(ctx.source,ctx),{source,content,ignore}=ctx;return sourceMap?build(new traceMapping.TraceMap(sourceMap,source),loader,source,depth):OriginalSource(source,void 0!==content?content:sourcesContent?sourcesContent[i]:null,void 0!==ignore?ignore:!!ignoreList&&ignoreList.includes(i))})))}class SourceMap{constructor(map,options){const out=options.decodedMappings?genMapping.toDecodedMap(map):genMapping.toEncodedMap(map);this.version=out.version,this.file=out.file,this.mappings=out.mappings,this.names=out.names,this.ignoreList=out.ignoreList,this.sourceRoot=out.sourceRoot,this.sources=out.sources,options.excludeContent||(this.sourcesContent=out.sourcesContent);}toString(){return JSON.stringify(this)}}function remapping(input,loader,options){const opts="object"==typeof options?options:{excludeContent:!!options,decodedMappings:false},tree=buildSourceMapTree(input,loader);return new SourceMap(traceMappings(tree),opts)}return remapping}(__webpack_require__("./node_modules/.pnpm/@jridgewell+trace-mapping@0.3.25/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js"),__webpack_require__("./node_modules/.pnpm/@jridgewell+gen-mapping@0.3.8/node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js"));},"./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files lazy recursive":module=>{function webpackEmptyAsyncContext(req){return Promise.resolve().then((()=>{var e=new Error("Cannot find module '"+req+"'");throw e.code="MODULE_NOT_FOUND",e}))}webpackEmptyAsyncContext.keys=()=>[],webpackEmptyAsyncContext.resolve=webpackEmptyAsyncContext,webpackEmptyAsyncContext.id="./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files lazy recursive",module.exports=webpackEmptyAsyncContext;},"./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files sync recursive":module=>{function webpackEmptyContext(req){var e=new Error("Cannot find module '"+req+"'");throw e.code="MODULE_NOT_FOUND",e}webpackEmptyContext.keys=()=>[],webpackEmptyContext.resolve=webpackEmptyContext,webpackEmptyContext.id="./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files sync recursive",module.exports=webpackEmptyContext;},"./node_modules/.pnpm/@babel+plugin-syntax-class-properties@7.12.13_@babel+core@7.26.0/node_modules/@babel/plugin-syntax-class-properties/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{exports.A=void 0;var _default=(0, __webpack_require__("./node_modules/.pnpm/@babel+helper-plugin-utils@7.25.9/node_modules/@babel/helper-plugin-utils/lib/index.js").declare)((api=>(api.assertVersion(7),{name:"syntax-class-properties",manipulateOptions(opts,parserOpts){parserOpts.plugins.push("classProperties","classPrivateProperties","classPrivateMethods");}})));exports.A=_default;},"./node_modules/.pnpm/@jridgewell+gen-mapping@0.3.8/node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js":function(__unused_webpack_module,exports,__webpack_require__){!function(exports,setArray,sourcemapCodec,traceMapping){const COLUMN=0,SOURCES_INDEX=1,SOURCE_LINE=2,SOURCE_COLUMN=3,NAMES_INDEX=4,NO_NAME=-1;class GenMapping{constructor({file,sourceRoot}={}){this._names=new setArray.SetArray,this._sources=new setArray.SetArray,this._sourcesContent=[],this._mappings=[],this.file=file,this.sourceRoot=sourceRoot,this._ignoreList=new setArray.SetArray;}}function cast(map){return map}function addSegment(map,genLine,genColumn,source,sourceLine,sourceColumn,name,content){return addSegmentInternal(false,map,genLine,genColumn,source,sourceLine,sourceColumn,name,content)}function addMapping(map,mapping){return addMappingInternal(false,map,mapping)}const maybeAddSegment=(map,genLine,genColumn,source,sourceLine,sourceColumn,name,content)=>addSegmentInternal(true,map,genLine,genColumn,source,sourceLine,sourceColumn,name,content),maybeAddMapping=(map,mapping)=>addMappingInternal(true,map,mapping);function setSourceContent(map,source,content){const{_sources:sources,_sourcesContent:sourcesContent}=cast(map);sourcesContent[setArray.put(sources,source)]=content;}function setIgnore(map,source,ignore=true){const{_sources:sources,_sourcesContent:sourcesContent,_ignoreList:ignoreList}=cast(map),index=setArray.put(sources,source);index===sourcesContent.length&&(sourcesContent[index]=null),ignore?setArray.put(ignoreList,index):setArray.remove(ignoreList,index);}function toDecodedMap(map){const{_mappings:mappings,_sources:sources,_sourcesContent:sourcesContent,_names:names,_ignoreList:ignoreList}=cast(map);return removeEmptyFinalLines(mappings),{version:3,file:map.file||void 0,names:names.array,sourceRoot:map.sourceRoot||void 0,sources:sources.array,sourcesContent,mappings,ignoreList:ignoreList.array}}function toEncodedMap(map){const decoded=toDecodedMap(map);return Object.assign(Object.assign({},decoded),{mappings:sourcemapCodec.encode(decoded.mappings)})}function fromMap(input){const map=new traceMapping.TraceMap(input),gen=new GenMapping({file:map.file,sourceRoot:map.sourceRoot});return putAll(cast(gen)._names,map.names),putAll(cast(gen)._sources,map.sources),cast(gen)._sourcesContent=map.sourcesContent||map.sources.map((()=>null)),cast(gen)._mappings=traceMapping.decodedMappings(map),map.ignoreList&&putAll(cast(gen)._ignoreList,map.ignoreList),gen}function allMappings(map){const out=[],{_mappings:mappings,_sources:sources,_names:names}=cast(map);for(let i=0;i<mappings.length;i++){const line=mappings[i];for(let j=0;j<line.length;j++){const seg=line[j],generated={line:i+1,column:seg[COLUMN]};let source,original,name;1!==seg.length&&(source=sources.array[seg[SOURCES_INDEX]],original={line:seg[SOURCE_LINE]+1,column:seg[SOURCE_COLUMN]},5===seg.length&&(name=names.array[seg[NAMES_INDEX]])),out.push({generated,source,original,name});}}return out}function addSegmentInternal(skipable,map,genLine,genColumn,source,sourceLine,sourceColumn,name,content){const{_mappings:mappings,_sources:sources,_sourcesContent:sourcesContent,_names:names}=cast(map),line=getLine(mappings,genLine),index=getColumnIndex(line,genColumn);if(!source){if(skipable&&skipSourceless(line,index))return;return insert(line,index,[genColumn])}const sourcesIndex=setArray.put(sources,source),namesIndex=name?setArray.put(names,name):NO_NAME;if(sourcesIndex===sourcesContent.length&&(sourcesContent[sourcesIndex]=null!=content?content:null),!skipable||!skipSource(line,index,sourcesIndex,sourceLine,sourceColumn,namesIndex))return insert(line,index,name?[genColumn,sourcesIndex,sourceLine,sourceColumn,namesIndex]:[genColumn,sourcesIndex,sourceLine,sourceColumn])}function getLine(mappings,index){for(let i=mappings.length;i<=index;i++)mappings[i]=[];return mappings[index]}function getColumnIndex(line,genColumn){let index=line.length;for(let i=index-1;i>=0&&!(genColumn>=line[i][COLUMN]);index=i--);return index}function insert(array,index,value){for(let i=array.length;i>index;i--)array[i]=array[i-1];array[index]=value;}function removeEmptyFinalLines(mappings){const{length}=mappings;let len=length;for(let i=len-1;i>=0&&!(mappings[i].length>0);len=i,i--);len<length&&(mappings.length=len);}function putAll(setarr,array){for(let i=0;i<array.length;i++)setArray.put(setarr,array[i]);}function skipSourceless(line,index){return 0===index||1===line[index-1].length}function skipSource(line,index,sourcesIndex,sourceLine,sourceColumn,namesIndex){if(0===index)return  false;const prev=line[index-1];return 1!==prev.length&&sourcesIndex===prev[SOURCES_INDEX]&&sourceLine===prev[SOURCE_LINE]&&sourceColumn===prev[SOURCE_COLUMN]&&namesIndex===(5===prev.length?prev[NAMES_INDEX]:NO_NAME)}function addMappingInternal(skipable,map,mapping){const{generated,source,original,name,content}=mapping;return source?addSegmentInternal(skipable,map,generated.line-1,generated.column,source,original.line-1,original.column,name,content):addSegmentInternal(skipable,map,generated.line-1,generated.column,null,null,null,null,null)}exports.GenMapping=GenMapping,exports.addMapping=addMapping,exports.addSegment=addSegment,exports.allMappings=allMappings,exports.fromMap=fromMap,exports.maybeAddMapping=maybeAddMapping,exports.maybeAddSegment=maybeAddSegment,exports.setIgnore=setIgnore,exports.setSourceContent=setSourceContent,exports.toDecodedMap=toDecodedMap,exports.toEncodedMap=toEncodedMap,Object.defineProperty(exports,"__esModule",{value:true});}(exports,__webpack_require__("./node_modules/.pnpm/@jridgewell+set-array@1.2.1/node_modules/@jridgewell/set-array/dist/set-array.umd.js"),__webpack_require__("./node_modules/.pnpm/@jridgewell+sourcemap-codec@1.5.0/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js"),__webpack_require__("./node_modules/.pnpm/@jridgewell+trace-mapping@0.3.25/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js"));},"./node_modules/.pnpm/@jridgewell+resolve-uri@3.1.2/node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js":function(module){module.exports=function(){const schemeRegex=/^[\w+.-]+:\/\//,urlRegex=/^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/,fileRegex=/^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;function isAbsoluteUrl(input){return schemeRegex.test(input)}function isSchemeRelativeUrl(input){return input.startsWith("//")}function isAbsolutePath(input){return input.startsWith("/")}function isFileUrl(input){return input.startsWith("file:")}function isRelative(input){return /^[.?#]/.test(input)}function parseAbsoluteUrl(input){const match=urlRegex.exec(input);return makeUrl(match[1],match[2]||"",match[3],match[4]||"",match[5]||"/",match[6]||"",match[7]||"")}function parseFileUrl(input){const match=fileRegex.exec(input),path=match[2];return makeUrl("file:","",match[1]||"","",isAbsolutePath(path)?path:"/"+path,match[3]||"",match[4]||"")}function makeUrl(scheme,user,host,port,path,query,hash){return {scheme,user,host,port,path,query,hash,type:7}}function parseUrl(input){if(isSchemeRelativeUrl(input)){const url=parseAbsoluteUrl("http:"+input);return url.scheme="",url.type=6,url}if(isAbsolutePath(input)){const url=parseAbsoluteUrl("http://foo.com"+input);return url.scheme="",url.host="",url.type=5,url}if(isFileUrl(input))return parseFileUrl(input);if(isAbsoluteUrl(input))return parseAbsoluteUrl(input);const url=parseAbsoluteUrl("http://foo.com/"+input);return url.scheme="",url.host="",url.type=input?input.startsWith("?")?3:input.startsWith("#")?2:4:1,url}function stripPathFilename(path){if(path.endsWith("/.."))return path;const index=path.lastIndexOf("/");return path.slice(0,index+1)}function mergePaths(url,base){normalizePath(base,base.type),"/"===url.path?url.path=base.path:url.path=stripPathFilename(base.path)+url.path;}function normalizePath(url,type){const rel=type<=4,pieces=url.path.split("/");let pointer=1,positive=0,addTrailingSlash=false;for(let i=1;i<pieces.length;i++){const piece=pieces[i];piece?(addTrailingSlash=false,"."!==piece&&(".."!==piece?(pieces[pointer++]=piece,positive++):positive?(addTrailingSlash=true,positive--,pointer--):rel&&(pieces[pointer++]=piece))):addTrailingSlash=true;}let path="";for(let i=1;i<pointer;i++)path+="/"+pieces[i];(!path||addTrailingSlash&&!path.endsWith("/.."))&&(path+="/"),url.path=path;}function resolve(input,base){if(!input&&!base)return "";const url=parseUrl(input);let inputType=url.type;if(base&&7!==inputType){const baseUrl=parseUrl(base),baseType=baseUrl.type;switch(inputType){case 1:url.hash=baseUrl.hash;case 2:url.query=baseUrl.query;case 3:case 4:mergePaths(url,baseUrl);case 5:url.user=baseUrl.user,url.host=baseUrl.host,url.port=baseUrl.port;case 6:url.scheme=baseUrl.scheme;}baseType>inputType&&(inputType=baseType);}normalizePath(url,inputType);const queryHash=url.query+url.hash;switch(inputType){case 2:case 3:return queryHash;case 4:{const path=url.path.slice(1);return path?isRelative(base||input)&&!isRelative(path)?"./"+path+queryHash:path+queryHash:queryHash||"."}case 5:return url.path+queryHash;default:return url.scheme+"//"+url.user+url.host+url.port+url.path+queryHash}}return resolve}();},"./node_modules/.pnpm/@jridgewell+set-array@1.2.1/node_modules/@jridgewell/set-array/dist/set-array.umd.js":function(__unused_webpack_module,exports){!function(exports){class SetArray{constructor(){this._indexes={__proto__:null},this.array=[];}}function cast(set){return set}function get(setarr,key){return cast(setarr)._indexes[key]}function put(setarr,key){const index=get(setarr,key);if(void 0!==index)return index;const{array,_indexes:indexes}=cast(setarr),length=array.push(key);return indexes[key]=length-1}function pop(setarr){const{array,_indexes:indexes}=cast(setarr);0!==array.length&&(indexes[array.pop()]=void 0);}function remove(setarr,key){const index=get(setarr,key);if(void 0===index)return;const{array,_indexes:indexes}=cast(setarr);for(let i=index+1;i<array.length;i++){const k=array[i];array[i-1]=k,indexes[k]--;}indexes[key]=void 0,array.pop();}exports.SetArray=SetArray,exports.get=get,exports.pop=pop,exports.put=put,exports.remove=remove,Object.defineProperty(exports,"__esModule",{value:true});}(exports);},"./node_modules/.pnpm/@jridgewell+sourcemap-codec@1.5.0/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js":function(__unused_webpack_module,exports){!function(exports){const comma=",".charCodeAt(0),semicolon=";".charCodeAt(0),chars="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",intToChar=new Uint8Array(64),charToInt=new Uint8Array(128);for(let i=0;i<chars.length;i++){const c=chars.charCodeAt(i);intToChar[i]=c,charToInt[c]=i;}function decodeInteger(reader,relative){let value=0,shift=0,integer=0;do{const c=reader.next();integer=charToInt[c],value|=(31&integer)<<shift,shift+=5;}while(32&integer);const shouldNegate=1&value;return value>>>=1,shouldNegate&&(value=-2147483648|-value),relative+value}function encodeInteger(builder,num,relative){let delta=num-relative;delta=delta<0?-delta<<1|1:delta<<1;do{let clamped=31&delta;delta>>>=5,delta>0&&(clamped|=32),builder.write(intToChar[clamped]);}while(delta>0);return num}function hasMoreVlq(reader,max){return !(reader.pos>=max)&&reader.peek()!==comma}const bufLength=16384,td="undefined"!=typeof TextDecoder?new TextDecoder:"undefined"!=typeof Buffer?{decode:buf=>Buffer.from(buf.buffer,buf.byteOffset,buf.byteLength).toString()}:{decode(buf){let out="";for(let i=0;i<buf.length;i++)out+=String.fromCharCode(buf[i]);return out}};class StringWriter{constructor(){this.pos=0,this.out="",this.buffer=new Uint8Array(bufLength);}write(v){const{buffer}=this;buffer[this.pos++]=v,this.pos===bufLength&&(this.out+=td.decode(buffer),this.pos=0);}flush(){const{buffer,out,pos}=this;return pos>0?out+td.decode(buffer.subarray(0,pos)):out}}class StringReader{constructor(buffer){this.pos=0,this.buffer=buffer;}next(){return this.buffer.charCodeAt(this.pos++)}peek(){return this.buffer.charCodeAt(this.pos)}indexOf(char){const{buffer,pos}=this,idx=buffer.indexOf(char,pos);return  -1===idx?buffer.length:idx}}const EMPTY=[];function decodeOriginalScopes(input){const{length}=input,reader=new StringReader(input),scopes=[],stack=[];let line=0;for(;reader.pos<length;reader.pos++){line=decodeInteger(reader,line);const column=decodeInteger(reader,0);if(!hasMoreVlq(reader,length)){const last=stack.pop();last[2]=line,last[3]=column;continue}const kind=decodeInteger(reader,0),scope=1&decodeInteger(reader,0)?[line,column,0,0,kind,decodeInteger(reader,0)]:[line,column,0,0,kind];let vars=EMPTY;if(hasMoreVlq(reader,length)){vars=[];do{const varsIndex=decodeInteger(reader,0);vars.push(varsIndex);}while(hasMoreVlq(reader,length))}scope.vars=vars,scopes.push(scope),stack.push(scope);}return scopes}function encodeOriginalScopes(scopes){const writer=new StringWriter;for(let i=0;i<scopes.length;)i=_encodeOriginalScopes(scopes,i,writer,[0]);return writer.flush()}function _encodeOriginalScopes(scopes,index,writer,state){const scope=scopes[index],{0:startLine,1:startColumn,2:endLine,3:endColumn,4:kind,vars}=scope;index>0&&writer.write(comma),state[0]=encodeInteger(writer,startLine,state[0]),encodeInteger(writer,startColumn,0),encodeInteger(writer,kind,0),encodeInteger(writer,6===scope.length?1:0,0),6===scope.length&&encodeInteger(writer,scope[5],0);for(const v of vars)encodeInteger(writer,v,0);for(index++;index<scopes.length;){const next=scopes[index],{0:l,1:c}=next;if(l>endLine||l===endLine&&c>=endColumn)break;index=_encodeOriginalScopes(scopes,index,writer,state);}return writer.write(comma),state[0]=encodeInteger(writer,endLine,state[0]),encodeInteger(writer,endColumn,0),index}function decodeGeneratedRanges(input){const{length}=input,reader=new StringReader(input),ranges=[],stack=[];let genLine=0,definitionSourcesIndex=0,definitionScopeIndex=0,callsiteSourcesIndex=0,callsiteLine=0,callsiteColumn=0,bindingLine=0,bindingColumn=0;do{const semi=reader.indexOf(";");let genColumn=0;for(;reader.pos<semi;reader.pos++){if(genColumn=decodeInteger(reader,genColumn),!hasMoreVlq(reader,semi)){const last=stack.pop();last[2]=genLine,last[3]=genColumn;continue}const fields=decodeInteger(reader,0),hasCallsite=2&fields,hasScope=4&fields;let range,callsite=null,bindings=EMPTY;if(1&fields){const defSourcesIndex=decodeInteger(reader,definitionSourcesIndex);definitionScopeIndex=decodeInteger(reader,definitionSourcesIndex===defSourcesIndex?definitionScopeIndex:0),definitionSourcesIndex=defSourcesIndex,range=[genLine,genColumn,0,0,defSourcesIndex,definitionScopeIndex];}else range=[genLine,genColumn,0,0];if(range.isScope=!!hasScope,hasCallsite){const prevCsi=callsiteSourcesIndex,prevLine=callsiteLine;callsiteSourcesIndex=decodeInteger(reader,callsiteSourcesIndex);const sameSource=prevCsi===callsiteSourcesIndex;callsiteLine=decodeInteger(reader,sameSource?callsiteLine:0),callsiteColumn=decodeInteger(reader,sameSource&&prevLine===callsiteLine?callsiteColumn:0),callsite=[callsiteSourcesIndex,callsiteLine,callsiteColumn];}if(range.callsite=callsite,hasMoreVlq(reader,semi)){bindings=[];do{bindingLine=genLine,bindingColumn=genColumn;const expressionsCount=decodeInteger(reader,0);let expressionRanges;if(expressionsCount<-1){expressionRanges=[[decodeInteger(reader,0)]];for(let i=-1;i>expressionsCount;i--){const prevBl=bindingLine;bindingLine=decodeInteger(reader,bindingLine),bindingColumn=decodeInteger(reader,bindingLine===prevBl?bindingColumn:0);const expression=decodeInteger(reader,0);expressionRanges.push([expression,bindingLine,bindingColumn]);}}else expressionRanges=[[expressionsCount]];bindings.push(expressionRanges);}while(hasMoreVlq(reader,semi))}range.bindings=bindings,ranges.push(range),stack.push(range);}genLine++,reader.pos=semi+1;}while(reader.pos<length);return ranges}function encodeGeneratedRanges(ranges){if(0===ranges.length)return "";const writer=new StringWriter;for(let i=0;i<ranges.length;)i=_encodeGeneratedRanges(ranges,i,writer,[0,0,0,0,0,0,0]);return writer.flush()}function _encodeGeneratedRanges(ranges,index,writer,state){const range=ranges[index],{0:startLine,1:startColumn,2:endLine,3:endColumn,isScope,callsite,bindings}=range;if(state[0]<startLine?(catchupLine(writer,state[0],startLine),state[0]=startLine,state[1]=0):index>0&&writer.write(comma),state[1]=encodeInteger(writer,range[1],state[1]),encodeInteger(writer,(6===range.length?1:0)|(callsite?2:0)|(isScope?4:0),0),6===range.length){const{4:sourcesIndex,5:scopesIndex}=range;sourcesIndex!==state[2]&&(state[3]=0),state[2]=encodeInteger(writer,sourcesIndex,state[2]),state[3]=encodeInteger(writer,scopesIndex,state[3]);}if(callsite){const{0:sourcesIndex,1:callLine,2:callColumn}=range.callsite;sourcesIndex!==state[4]?(state[5]=0,state[6]=0):callLine!==state[5]&&(state[6]=0),state[4]=encodeInteger(writer,sourcesIndex,state[4]),state[5]=encodeInteger(writer,callLine,state[5]),state[6]=encodeInteger(writer,callColumn,state[6]);}if(bindings)for(const binding of bindings){binding.length>1&&encodeInteger(writer,-binding.length,0),encodeInteger(writer,binding[0][0],0);let bindingStartLine=startLine,bindingStartColumn=startColumn;for(let i=1;i<binding.length;i++){const expRange=binding[i];bindingStartLine=encodeInteger(writer,expRange[1],bindingStartLine),bindingStartColumn=encodeInteger(writer,expRange[2],bindingStartColumn),encodeInteger(writer,expRange[0],0);}}for(index++;index<ranges.length;){const next=ranges[index],{0:l,1:c}=next;if(l>endLine||l===endLine&&c>=endColumn)break;index=_encodeGeneratedRanges(ranges,index,writer,state);}return state[0]<endLine?(catchupLine(writer,state[0],endLine),state[0]=endLine,state[1]=0):writer.write(comma),state[1]=encodeInteger(writer,endColumn,state[1]),index}function catchupLine(writer,lastLine,line){do{writer.write(semicolon);}while(++lastLine<line)}function decode(mappings){const{length}=mappings,reader=new StringReader(mappings),decoded=[];let genColumn=0,sourcesIndex=0,sourceLine=0,sourceColumn=0,namesIndex=0;do{const semi=reader.indexOf(";"),line=[];let sorted=true,lastCol=0;for(genColumn=0;reader.pos<semi;){let seg;genColumn=decodeInteger(reader,genColumn),genColumn<lastCol&&(sorted=false),lastCol=genColumn,hasMoreVlq(reader,semi)?(sourcesIndex=decodeInteger(reader,sourcesIndex),sourceLine=decodeInteger(reader,sourceLine),sourceColumn=decodeInteger(reader,sourceColumn),hasMoreVlq(reader,semi)?(namesIndex=decodeInteger(reader,namesIndex),seg=[genColumn,sourcesIndex,sourceLine,sourceColumn,namesIndex]):seg=[genColumn,sourcesIndex,sourceLine,sourceColumn]):seg=[genColumn],line.push(seg),reader.pos++;}sorted||sort(line),decoded.push(line),reader.pos=semi+1;}while(reader.pos<=length);return decoded}function sort(line){line.sort(sortComparator);}function sortComparator(a,b){return a[0]-b[0]}function encode(decoded){const writer=new StringWriter;let sourcesIndex=0,sourceLine=0,sourceColumn=0,namesIndex=0;for(let i=0;i<decoded.length;i++){const line=decoded[i];if(i>0&&writer.write(semicolon),0===line.length)continue;let genColumn=0;for(let j=0;j<line.length;j++){const segment=line[j];j>0&&writer.write(comma),genColumn=encodeInteger(writer,segment[0],genColumn),1!==segment.length&&(sourcesIndex=encodeInteger(writer,segment[1],sourcesIndex),sourceLine=encodeInteger(writer,segment[2],sourceLine),sourceColumn=encodeInteger(writer,segment[3],sourceColumn),4!==segment.length&&(namesIndex=encodeInteger(writer,segment[4],namesIndex)));}}return writer.flush()}exports.decode=decode,exports.decodeGeneratedRanges=decodeGeneratedRanges,exports.decodeOriginalScopes=decodeOriginalScopes,exports.encode=encode,exports.encodeGeneratedRanges=encodeGeneratedRanges,exports.encodeOriginalScopes=encodeOriginalScopes,Object.defineProperty(exports,"__esModule",{value:true});}(exports);},"./node_modules/.pnpm/@jridgewell+trace-mapping@0.3.25/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js":function(__unused_webpack_module,exports,__webpack_require__){!function(exports,sourcemapCodec,resolveUri){function resolve(input,base){return base&&!base.endsWith("/")&&(base+="/"),resolveUri(input,base)}function stripFilename(path){if(!path)return "";const index=path.lastIndexOf("/");return path.slice(0,index+1)}const COLUMN=0,SOURCES_INDEX=1,SOURCE_LINE=2,SOURCE_COLUMN=3,NAMES_INDEX=4,REV_GENERATED_LINE=1,REV_GENERATED_COLUMN=2;function maybeSort(mappings,owned){const unsortedIndex=nextUnsortedSegmentLine(mappings,0);if(unsortedIndex===mappings.length)return mappings;owned||(mappings=mappings.slice());for(let i=unsortedIndex;i<mappings.length;i=nextUnsortedSegmentLine(mappings,i+1))mappings[i]=sortSegments(mappings[i],owned);return mappings}function nextUnsortedSegmentLine(mappings,start){for(let i=start;i<mappings.length;i++)if(!isSorted(mappings[i]))return i;return mappings.length}function isSorted(line){for(let j=1;j<line.length;j++)if(line[j][COLUMN]<line[j-1][COLUMN])return  false;return  true}function sortSegments(line,owned){return owned||(line=line.slice()),line.sort(sortComparator)}function sortComparator(a,b){return a[COLUMN]-b[COLUMN]}let found=false;function binarySearch(haystack,needle,low,high){for(;low<=high;){const mid=low+(high-low>>1),cmp=haystack[mid][COLUMN]-needle;if(0===cmp)return found=true,mid;cmp<0?low=mid+1:high=mid-1;}return found=false,low-1}function upperBound(haystack,needle,index){for(let i=index+1;i<haystack.length&&haystack[i][COLUMN]===needle;index=i++);return index}function lowerBound(haystack,needle,index){for(let i=index-1;i>=0&&haystack[i][COLUMN]===needle;index=i--);return index}function memoizedState(){return {lastKey:-1,lastNeedle:-1,lastIndex:-1}}function memoizedBinarySearch(haystack,needle,state,key){const{lastKey,lastNeedle,lastIndex}=state;let low=0,high=haystack.length-1;if(key===lastKey){if(needle===lastNeedle)return found=-1!==lastIndex&&haystack[lastIndex][COLUMN]===needle,lastIndex;needle>=lastNeedle?low=-1===lastIndex?0:lastIndex:high=lastIndex;}return state.lastKey=key,state.lastNeedle=needle,state.lastIndex=binarySearch(haystack,needle,low,high)}function buildBySources(decoded,memos){const sources=memos.map(buildNullArray);for(let i=0;i<decoded.length;i++){const line=decoded[i];for(let j=0;j<line.length;j++){const seg=line[j];if(1===seg.length)continue;const sourceIndex=seg[SOURCES_INDEX],sourceLine=seg[SOURCE_LINE],sourceColumn=seg[SOURCE_COLUMN],originalSource=sources[sourceIndex],originalLine=originalSource[sourceLine]||(originalSource[sourceLine]=[]),memo=memos[sourceIndex];let index=upperBound(originalLine,sourceColumn,memoizedBinarySearch(originalLine,sourceColumn,memo,sourceLine));memo.lastIndex=++index,insert(originalLine,index,[sourceColumn,i,seg[COLUMN]]);}}return sources}function insert(array,index,value){for(let i=array.length;i>index;i--)array[i]=array[i-1];array[index]=value;}function buildNullArray(){return {__proto__:null}}const AnyMap=function(map,mapUrl){const parsed=parse(map);if(!("sections"in parsed))return new TraceMap(parsed,mapUrl);const mappings=[],sources=[],sourcesContent=[],names=[],ignoreList=[];return recurse(parsed,mapUrl,mappings,sources,sourcesContent,names,ignoreList,0,0,1/0,1/0),presortedDecodedMap({version:3,file:parsed.file,names,sources,sourcesContent,mappings,ignoreList})};function parse(map){return "string"==typeof map?JSON.parse(map):map}function recurse(input,mapUrl,mappings,sources,sourcesContent,names,ignoreList,lineOffset,columnOffset,stopLine,stopColumn){const{sections}=input;for(let i=0;i<sections.length;i++){const{map,offset}=sections[i];let sl=stopLine,sc=stopColumn;if(i+1<sections.length){const nextOffset=sections[i+1].offset;sl=Math.min(stopLine,lineOffset+nextOffset.line),sl===stopLine?sc=Math.min(stopColumn,columnOffset+nextOffset.column):sl<stopLine&&(sc=columnOffset+nextOffset.column);}addSection(map,mapUrl,mappings,sources,sourcesContent,names,ignoreList,lineOffset+offset.line,columnOffset+offset.column,sl,sc);}}function addSection(input,mapUrl,mappings,sources,sourcesContent,names,ignoreList,lineOffset,columnOffset,stopLine,stopColumn){const parsed=parse(input);if("sections"in parsed)return recurse(...arguments);const map=new TraceMap(parsed,mapUrl),sourcesOffset=sources.length,namesOffset=names.length,decoded=decodedMappings(map),{resolvedSources,sourcesContent:contents,ignoreList:ignores}=map;if(append(sources,resolvedSources),append(names,map.names),contents)append(sourcesContent,contents);else for(let i=0;i<resolvedSources.length;i++)sourcesContent.push(null);if(ignores)for(let i=0;i<ignores.length;i++)ignoreList.push(ignores[i]+sourcesOffset);for(let i=0;i<decoded.length;i++){const lineI=lineOffset+i;if(lineI>stopLine)return;const out=getLine(mappings,lineI),cOffset=0===i?columnOffset:0,line=decoded[i];for(let j=0;j<line.length;j++){const seg=line[j],column=cOffset+seg[COLUMN];if(lineI===stopLine&&column>=stopColumn)return;if(1===seg.length){out.push([column]);continue}const sourcesIndex=sourcesOffset+seg[SOURCES_INDEX],sourceLine=seg[SOURCE_LINE],sourceColumn=seg[SOURCE_COLUMN];out.push(4===seg.length?[column,sourcesIndex,sourceLine,sourceColumn]:[column,sourcesIndex,sourceLine,sourceColumn,namesOffset+seg[NAMES_INDEX]]);}}}function append(arr,other){for(let i=0;i<other.length;i++)arr.push(other[i]);}function getLine(arr,index){for(let i=arr.length;i<=index;i++)arr[i]=[];return arr[index]}const LINE_GTR_ZERO="`line` must be greater than 0 (lines start at line 1)",COL_GTR_EQ_ZERO="`column` must be greater than or equal to 0 (columns start at column 0)",LEAST_UPPER_BOUND=-1,GREATEST_LOWER_BOUND=1;class TraceMap{constructor(map,mapUrl){const isString="string"==typeof map;if(!isString&&map._decodedMemo)return map;const parsed=isString?JSON.parse(map):map,{version,file,names,sourceRoot,sources,sourcesContent}=parsed;this.version=version,this.file=file,this.names=names||[],this.sourceRoot=sourceRoot,this.sources=sources,this.sourcesContent=sourcesContent,this.ignoreList=parsed.ignoreList||parsed.x_google_ignoreList||void 0;const from=resolve(sourceRoot||"",stripFilename(mapUrl));this.resolvedSources=sources.map((s=>resolve(s||"",from)));const{mappings}=parsed;"string"==typeof mappings?(this._encoded=mappings,this._decoded=void 0):(this._encoded=void 0,this._decoded=maybeSort(mappings,isString)),this._decodedMemo=memoizedState(),this._bySources=void 0,this._bySourceMemos=void 0;}}function cast(map){return map}function encodedMappings(map){var _a,_b;return null!==(_a=(_b=cast(map))._encoded)&&void 0!==_a?_a:_b._encoded=sourcemapCodec.encode(cast(map)._decoded)}function decodedMappings(map){var _a;return (_a=cast(map))._decoded||(_a._decoded=sourcemapCodec.decode(cast(map)._encoded))}function traceSegment(map,line,column){const decoded=decodedMappings(map);if(line>=decoded.length)return null;const segments=decoded[line],index=traceSegmentInternal(segments,cast(map)._decodedMemo,line,column,GREATEST_LOWER_BOUND);return  -1===index?null:segments[index]}function originalPositionFor(map,needle){let{line,column,bias}=needle;if(line--,line<0)throw new Error(LINE_GTR_ZERO);if(column<0)throw new Error(COL_GTR_EQ_ZERO);const decoded=decodedMappings(map);if(line>=decoded.length)return OMapping(null,null,null,null);const segments=decoded[line],index=traceSegmentInternal(segments,cast(map)._decodedMemo,line,column,bias||GREATEST_LOWER_BOUND);if(-1===index)return OMapping(null,null,null,null);const segment=segments[index];if(1===segment.length)return OMapping(null,null,null,null);const{names,resolvedSources}=map;return OMapping(resolvedSources[segment[SOURCES_INDEX]],segment[SOURCE_LINE]+1,segment[SOURCE_COLUMN],5===segment.length?names[segment[NAMES_INDEX]]:null)}function generatedPositionFor(map,needle){const{source,line,column,bias}=needle;return generatedPosition(map,source,line,column,bias||GREATEST_LOWER_BOUND,false)}function allGeneratedPositionsFor(map,needle){const{source,line,column,bias}=needle;return generatedPosition(map,source,line,column,bias||LEAST_UPPER_BOUND,true)}function eachMapping(map,cb){const decoded=decodedMappings(map),{names,resolvedSources}=map;for(let i=0;i<decoded.length;i++){const line=decoded[i];for(let j=0;j<line.length;j++){const seg=line[j],generatedLine=i+1,generatedColumn=seg[0];let source=null,originalLine=null,originalColumn=null,name=null;1!==seg.length&&(source=resolvedSources[seg[1]],originalLine=seg[2]+1,originalColumn=seg[3]),5===seg.length&&(name=names[seg[4]]),cb({generatedLine,generatedColumn,source,originalLine,originalColumn,name});}}}function sourceIndex(map,source){const{sources,resolvedSources}=map;let index=sources.indexOf(source);return  -1===index&&(index=resolvedSources.indexOf(source)),index}function sourceContentFor(map,source){const{sourcesContent}=map;if(null==sourcesContent)return null;const index=sourceIndex(map,source);return  -1===index?null:sourcesContent[index]}function isIgnored(map,source){const{ignoreList}=map;if(null==ignoreList)return  false;const index=sourceIndex(map,source);return  -1!==index&&ignoreList.includes(index)}function presortedDecodedMap(map,mapUrl){const tracer=new TraceMap(clone(map,[]),mapUrl);return cast(tracer)._decoded=map.mappings,tracer}function decodedMap(map){return clone(map,decodedMappings(map))}function encodedMap(map){return clone(map,encodedMappings(map))}function clone(map,mappings){return {version:map.version,file:map.file,names:map.names,sourceRoot:map.sourceRoot,sources:map.sources,sourcesContent:map.sourcesContent,mappings,ignoreList:map.ignoreList||map.x_google_ignoreList}}function OMapping(source,line,column,name){return {source,line,column,name}}function GMapping(line,column){return {line,column}}function traceSegmentInternal(segments,memo,line,column,bias){let index=memoizedBinarySearch(segments,column,memo,line);return found?index=(bias===LEAST_UPPER_BOUND?upperBound:lowerBound)(segments,column,index):bias===LEAST_UPPER_BOUND&&index++,-1===index||index===segments.length?-1:index}function sliceGeneratedPositions(segments,memo,line,column,bias){let min=traceSegmentInternal(segments,memo,line,column,GREATEST_LOWER_BOUND);if(found||bias!==LEAST_UPPER_BOUND||min++,-1===min||min===segments.length)return [];const matchedColumn=found?column:segments[min][COLUMN];found||(min=lowerBound(segments,matchedColumn,min));const max=upperBound(segments,matchedColumn,min),result=[];for(;min<=max;min++){const segment=segments[min];result.push(GMapping(segment[REV_GENERATED_LINE]+1,segment[REV_GENERATED_COLUMN]));}return result}function generatedPosition(map,source,line,column,bias,all){var _a;if(--line<0)throw new Error(LINE_GTR_ZERO);if(column<0)throw new Error(COL_GTR_EQ_ZERO);const{sources,resolvedSources}=map;let sourceIndex=sources.indexOf(source);if(-1===sourceIndex&&(sourceIndex=resolvedSources.indexOf(source)),-1===sourceIndex)return all?[]:GMapping(null,null);const segments=((_a=cast(map))._bySources||(_a._bySources=buildBySources(decodedMappings(map),cast(map)._bySourceMemos=sources.map(memoizedState))))[sourceIndex][line];if(null==segments)return all?[]:GMapping(null,null);const memo=cast(map)._bySourceMemos[sourceIndex];if(all)return sliceGeneratedPositions(segments,memo,line,column,bias);const index=traceSegmentInternal(segments,memo,line,column,bias);if(-1===index)return GMapping(null,null);const segment=segments[index];return GMapping(segment[REV_GENERATED_LINE]+1,segment[REV_GENERATED_COLUMN])}exports.AnyMap=AnyMap,exports.GREATEST_LOWER_BOUND=GREATEST_LOWER_BOUND,exports.LEAST_UPPER_BOUND=LEAST_UPPER_BOUND,exports.TraceMap=TraceMap,exports.allGeneratedPositionsFor=allGeneratedPositionsFor,exports.decodedMap=decodedMap,exports.decodedMappings=decodedMappings,exports.eachMapping=eachMapping,exports.encodedMap=encodedMap,exports.encodedMappings=encodedMappings,exports.generatedPositionFor=generatedPositionFor,exports.isIgnored=isIgnored,exports.originalPositionFor=originalPositionFor,exports.presortedDecodedMap=presortedDecodedMap,exports.sourceContentFor=sourceContentFor,exports.traceSegment=traceSegment;}(exports,__webpack_require__("./node_modules/.pnpm/@jridgewell+sourcemap-codec@1.5.0/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js"),__webpack_require__("./node_modules/.pnpm/@jridgewell+resolve-uri@3.1.2/node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js"));},"./node_modules/.pnpm/babel-plugin-parameter-decorator@1.0.16/node_modules/babel-plugin-parameter-decorator/lib/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{var _path=__webpack_require__("path");function isInType(path){switch(path.parent.type){case "TSTypeReference":case "TSQualifiedName":case "TSExpressionWithTypeArguments":case "TSTypeQuery":return  true;default:return  false}}module.exports=function(_ref){var types=_ref.types,decoratorExpressionForConstructor=function(decorator,param){return function(className){var resultantDecorator=types.callExpression(decorator.expression,[types.Identifier(className),types.Identifier("undefined"),types.NumericLiteral(param.key)]),resultantDecoratorWithFallback=types.logicalExpression("||",resultantDecorator,types.Identifier(className)),assignment=types.assignmentExpression("=",types.Identifier(className),resultantDecoratorWithFallback);return types.expressionStatement(assignment)}},decoratorExpressionForMethod=function(decorator,param){return function(className,functionName){var resultantDecorator=types.callExpression(decorator.expression,[types.Identifier("".concat(className,".prototype")),types.StringLiteral(functionName),types.NumericLiteral(param.key)]);return types.expressionStatement(resultantDecorator)}};return {visitor:{Program:function(path,state){var extension=(0, _path.extname)(state.file.opts.filename);".ts"!==extension&&".tsx"!==extension||function(){var decorators=Object.create(null);path.node.body.filter((function(it){var type=it.type,declaration=it.declaration;switch(type){case "ClassDeclaration":return  true;case "ExportNamedDeclaration":case "ExportDefaultDeclaration":return declaration&&"ClassDeclaration"===declaration.type;default:return  false}})).map((function(it){return "ClassDeclaration"===it.type?it:it.declaration})).forEach((function(clazz){clazz.body.body.forEach((function(body){(body.params||[]).forEach((function(param){(param.decorators||[]).forEach((function(decorator){decorator.expression.callee?decorators[decorator.expression.callee.name]=decorator:decorators[decorator.expression.name]=decorator;}));}));}));}));var _iteratorNormalCompletion=true,_didIteratorError=false,_iteratorError=void 0;try{for(var _step,_iterator=path.get("body")[Symbol.iterator]();!(_iteratorNormalCompletion=(_step=_iterator.next()).done);_iteratorNormalCompletion=!0){var stmt=_step.value;if("ImportDeclaration"===stmt.node.type){if(0===stmt.node.specifiers.length)continue;var _iteratorNormalCompletion2=!0,_didIteratorError2=!1,_iteratorError2=void 0;try{for(var _step2,_loop=function(){var specifier=_step2.value,binding=stmt.scope.getBinding(specifier.local.name);binding.referencePaths.length?binding.referencePaths.reduce((function(prev,next){return prev||isInType(next)}),!1)&&Object.keys(decorators).forEach((function(k){var decorator=decorators[k];(decorator.expression.arguments||[]).forEach((function(arg){arg.name===specifier.local.name&&binding.referencePaths.push({parent:decorator.expression});}));})):decorators[specifier.local.name]&&binding.referencePaths.push({parent:decorators[specifier.local.name]});},_iterator2=stmt.node.specifiers[Symbol.iterator]();!(_iteratorNormalCompletion2=(_step2=_iterator2.next()).done);_iteratorNormalCompletion2=!0)_loop();}catch(err){_didIteratorError2=!0,_iteratorError2=err;}finally{try{_iteratorNormalCompletion2||null==_iterator2.return||_iterator2.return();}finally{if(_didIteratorError2)throw _iteratorError2}}}}}catch(err){_didIteratorError=true,_iteratorError=err;}finally{try{_iteratorNormalCompletion||null==_iterator.return||_iterator.return();}finally{if(_didIteratorError)throw _iteratorError}}}();},Function:function(path){var functionName="";path.node.id?functionName=path.node.id.name:path.node.key&&(functionName=path.node.key.name),(path.get("params")||[]).slice().forEach((function(param){var decorators=param.node.decorators||[],transformable=decorators.length;if(decorators.slice().forEach((function(decorator){if("ClassMethod"===path.type){var classIdentifier,parentNode=path.parentPath.parentPath,classDeclaration=path.findParent((function(p){return "ClassDeclaration"===p.type}));if(classDeclaration?classIdentifier=classDeclaration.node.id.name:(parentNode.insertAfter(null),classIdentifier=function(path){var assignment=path.findParent((function(p){return "AssignmentExpression"===p.node.type}));return "SequenceExpression"===assignment.node.right.type?assignment.node.right.expressions[1].name:"ClassExpression"===assignment.node.right.type?assignment.node.left.name:null}(path)),"constructor"===functionName){var expression=decoratorExpressionForConstructor(decorator,param)(classIdentifier);parentNode.insertAfter(expression);}else {var _expression=decoratorExpressionForMethod(decorator,param)(classIdentifier,functionName);parentNode.insertAfter(_expression);}}else {var className=path.findParent((function(p){return "VariableDeclarator"===p.node.type})).node.id.name;if(functionName===className){var _expression2=decoratorExpressionForConstructor(decorator,param)(className);if("body"===path.parentKey)path.insertAfter(_expression2);else path.findParent((function(p){return "body"===p.parentKey})).insertAfter(_expression2);}else {var classParent=path.findParent((function(p){return "CallExpression"===p.node.type})),_expression3=decoratorExpressionForMethod(decorator,param)(className,functionName);classParent.insertAfter(_expression3);}}})),transformable){var replacement=function(path){switch(path.node.type){case "ObjectPattern":return types.ObjectPattern(path.node.properties);case "AssignmentPattern":return types.AssignmentPattern(path.node.left,path.node.right);case "TSParameterProperty":return types.Identifier(path.node.parameter.name);default:return types.Identifier(path.node.name)}}(param);param.replaceWith(replacement);}}));}}}};},"./node_modules/.pnpm/convert-source-map@2.0.0/node_modules/convert-source-map/index.js":(__unused_webpack_module,exports)=>{var decodeBase64;function Converter(sm,opts){(opts=opts||{}).hasComment&&(sm=function(sm){return sm.split(",").pop()}(sm)),"base64"===opts.encoding?sm=decodeBase64(sm):"uri"===opts.encoding&&(sm=decodeURIComponent(sm)),(opts.isJSON||opts.encoding)&&(sm=JSON.parse(sm)),this.sourcemap=sm;}function makeConverter(sm){return new Converter(sm,{isJSON:true})}Object.defineProperty(exports,"commentRegex",{get:function(){return /^\s*?\/[\/\*][@#]\s+?sourceMappingURL=data:(((?:application|text)\/json)(?:;charset=([^;,]+?)?)?)?(?:;(base64))?,(.*?)$/gm}}),Object.defineProperty(exports,"mapFileCommentRegex",{get:function(){return /(?:\/\/[@#][ \t]+?sourceMappingURL=([^\s'"`]+?)[ \t]*?$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^*]+?)[ \t]*?(?:\*\/){1}[ \t]*?$)/gm}}),decodeBase64="undefined"!=typeof Buffer?"function"==typeof Buffer.from?function(base64){return Buffer.from(base64,"base64").toString()}:function(base64){if("number"==typeof value)throw new TypeError("The value to decode must not be of type number.");return new Buffer(base64,"base64").toString()}:function(base64){return decodeURIComponent(escape(atob(base64)))},Converter.prototype.toJSON=function(space){return JSON.stringify(this.sourcemap,null,space)},"undefined"!=typeof Buffer?"function"==typeof Buffer.from?Converter.prototype.toBase64=function(){var json=this.toJSON();return Buffer.from(json,"utf8").toString("base64")}:Converter.prototype.toBase64=function(){var json=this.toJSON();if("number"==typeof json)throw new TypeError("The json to encode must not be of type number.");return new Buffer(json,"utf8").toString("base64")}:Converter.prototype.toBase64=function(){var json=this.toJSON();return btoa(unescape(encodeURIComponent(json)))},Converter.prototype.toURI=function(){var json=this.toJSON();return encodeURIComponent(json)},Converter.prototype.toComment=function(options){var encoding,content,data;return null!=options&&"uri"===options.encoding?(encoding="",content=this.toURI()):(encoding=";base64",content=this.toBase64()),data="sourceMappingURL=data:application/json;charset=utf-8"+encoding+","+content,null!=options&&options.multiline?"/*# "+data+" */":"//# "+data},Converter.prototype.toObject=function(){return JSON.parse(this.toJSON())},Converter.prototype.addProperty=function(key,value){if(this.sourcemap.hasOwnProperty(key))throw new Error('property "'+key+'" already exists on the sourcemap, use set property instead');return this.setProperty(key,value)},Converter.prototype.setProperty=function(key,value){return this.sourcemap[key]=value,this},Converter.prototype.getProperty=function(key){return this.sourcemap[key]},exports.fromObject=function(obj){return new Converter(obj)},exports.fromJSON=function(json){return new Converter(json,{isJSON:true})},exports.fromURI=function(uri){return new Converter(uri,{encoding:"uri"})},exports.fromBase64=function(base64){return new Converter(base64,{encoding:"base64"})},exports.fromComment=function(comment){var m;return new Converter(comment=comment.replace(/^\/\*/g,"//").replace(/\*\/$/g,""),{encoding:(m=exports.commentRegex.exec(comment))&&m[4]||"uri",hasComment:true})},exports.fromMapFileComment=function(comment,read){if("string"==typeof read)throw new Error("String directory paths are no longer supported with `fromMapFileComment`\nPlease review the Upgrading documentation at https://github.com/thlorenz/convert-source-map#upgrading");var sm=function(sm,read){var r=exports.mapFileCommentRegex.exec(sm),filename=r[1]||r[2];try{return null!=(sm=read(filename))&&"function"==typeof sm.catch?sm.catch(throwError):sm}catch(e){throwError(e);}function throwError(e){throw new Error("An error occurred while trying to read the map file at "+filename+"\n"+e.stack)}}(comment,read);return null!=sm&&"function"==typeof sm.then?sm.then(makeConverter):makeConverter(sm)},exports.fromSource=function(content){var m=content.match(exports.commentRegex);return m?exports.fromComment(m.pop()):null},exports.fromMapFileSource=function(content,read){if("string"==typeof read)throw new Error("String directory paths are no longer supported with `fromMapFileSource`\nPlease review the Upgrading documentation at https://github.com/thlorenz/convert-source-map#upgrading");var m=content.match(exports.mapFileCommentRegex);return m?exports.fromMapFileComment(m.pop(),read):null},exports.removeComments=function(src){return src.replace(exports.commentRegex,"")},exports.removeMapFileComments=function(src){return src.replace(exports.mapFileCommentRegex,"")},exports.generateMapFileComment=function(file,options){var data="sourceMappingURL="+file;return options&&options.multiline?"/*# "+data+" */":"//# "+data};},"./node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/browser.js":(module,exports,__webpack_require__)=>{exports.formatArgs=function(args){if(args[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+args[0]+(this.useColors?"%c ":" ")+"+"+module.exports.humanize(this.diff),!this.useColors)return;const c="color: "+this.color;args.splice(1,0,c,"color: inherit");let index=0,lastC=0;args[0].replace(/%[a-zA-Z%]/g,(match=>{"%%"!==match&&(index++,"%c"===match&&(lastC=index));})),args.splice(lastC,0,c);},exports.save=function(namespaces){try{namespaces?exports.storage.setItem("debug",namespaces):exports.storage.removeItem("debug");}catch(error){}},exports.load=function(){let r;try{r=exports.storage.getItem("debug");}catch(error){}!r&&"undefined"!=typeof process&&"env"in process&&(r=process.env.DEBUG);return r},exports.useColors=function(){if("undefined"!=typeof window&&window.process&&("renderer"===window.process.type||window.process.__nwjs))return  true;if("undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))return  false;let m;return "undefined"!=typeof document&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||"undefined"!=typeof window&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||"undefined"!=typeof navigator&&navigator.userAgent&&(m=navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/))&&parseInt(m[1],10)>=31||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)},exports.storage=function(){try{return localStorage}catch(error){}}(),exports.destroy=(()=>{let warned=false;return ()=>{warned||(warned=true,console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));}})(),exports.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"],exports.log=console.debug||console.log||(()=>{}),module.exports=__webpack_require__("./node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/common.js")(exports);const{formatters}=module.exports;formatters.j=function(v){try{return JSON.stringify(v)}catch(error){return "[UnexpectedJSONParseError]: "+error.message}};},"./node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/common.js":(module,__unused_webpack_exports,__webpack_require__)=>{module.exports=function(env){function createDebug(namespace){let prevTime,namespacesCache,enabledCache,enableOverride=null;function debug(...args){if(!debug.enabled)return;const self=debug,curr=Number(new Date),ms=curr-(prevTime||curr);self.diff=ms,self.prev=prevTime,self.curr=curr,prevTime=curr,args[0]=createDebug.coerce(args[0]),"string"!=typeof args[0]&&args.unshift("%O");let index=0;args[0]=args[0].replace(/%([a-zA-Z%])/g,((match,format)=>{if("%%"===match)return "%";index++;const formatter=createDebug.formatters[format];if("function"==typeof formatter){const val=args[index];match=formatter.call(self,val),args.splice(index,1),index--;}return match})),createDebug.formatArgs.call(self,args);(self.log||createDebug.log).apply(self,args);}return debug.namespace=namespace,debug.useColors=createDebug.useColors(),debug.color=createDebug.selectColor(namespace),debug.extend=extend,debug.destroy=createDebug.destroy,Object.defineProperty(debug,"enabled",{enumerable:true,configurable:false,get:()=>null!==enableOverride?enableOverride:(namespacesCache!==createDebug.namespaces&&(namespacesCache=createDebug.namespaces,enabledCache=createDebug.enabled(namespace)),enabledCache),set:v=>{enableOverride=v;}}),"function"==typeof createDebug.init&&createDebug.init(debug),debug}function extend(namespace,delimiter){const newDebug=createDebug(this.namespace+(void 0===delimiter?":":delimiter)+namespace);return newDebug.log=this.log,newDebug}function matchesTemplate(search,template){let searchIndex=0,templateIndex=0,starIndex=-1,matchIndex=0;for(;searchIndex<search.length;)if(templateIndex<template.length&&(template[templateIndex]===search[searchIndex]||"*"===template[templateIndex]))"*"===template[templateIndex]?(starIndex=templateIndex,matchIndex=searchIndex,templateIndex++):(searchIndex++,templateIndex++);else {if(-1===starIndex)return  false;templateIndex=starIndex+1,matchIndex++,searchIndex=matchIndex;}for(;templateIndex<template.length&&"*"===template[templateIndex];)templateIndex++;return templateIndex===template.length}return createDebug.debug=createDebug,createDebug.default=createDebug,createDebug.coerce=function(val){if(val instanceof Error)return val.stack||val.message;return val},createDebug.disable=function(){const namespaces=[...createDebug.names,...createDebug.skips.map((namespace=>"-"+namespace))].join(",");return createDebug.enable(""),namespaces},createDebug.enable=function(namespaces){createDebug.save(namespaces),createDebug.namespaces=namespaces,createDebug.names=[],createDebug.skips=[];const split=("string"==typeof namespaces?namespaces:"").trim().replace(" ",",").split(",").filter(Boolean);for(const ns of split)"-"===ns[0]?createDebug.skips.push(ns.slice(1)):createDebug.names.push(ns);},createDebug.enabled=function(name){for(const skip of createDebug.skips)if(matchesTemplate(name,skip))return  false;for(const ns of createDebug.names)if(matchesTemplate(name,ns))return  true;return  false},createDebug.humanize=__webpack_require__("./node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js"),createDebug.destroy=function(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");},Object.keys(env).forEach((key=>{createDebug[key]=env[key];})),createDebug.names=[],createDebug.skips=[],createDebug.formatters={},createDebug.selectColor=function(namespace){let hash=0;for(let i=0;i<namespace.length;i++)hash=(hash<<5)-hash+namespace.charCodeAt(i),hash|=0;return createDebug.colors[Math.abs(hash)%createDebug.colors.length]},createDebug.enable(createDebug.load()),createDebug};},"./node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{"undefined"==typeof process||"renderer"===process.type||true===process.browser||process.__nwjs?module.exports=__webpack_require__("./node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/browser.js"):module.exports=__webpack_require__("./node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/node.js");},"./node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/node.js":(module,exports,__webpack_require__)=>{const tty=__webpack_require__("tty"),util=__webpack_require__("util");exports.init=function(debug){debug.inspectOpts={};const keys=Object.keys(exports.inspectOpts);for(let i=0;i<keys.length;i++)debug.inspectOpts[keys[i]]=exports.inspectOpts[keys[i]];},exports.log=function(...args){return process.stderr.write(util.formatWithOptions(exports.inspectOpts,...args)+"\n")},exports.formatArgs=function(args){const{namespace:name,useColors}=this;if(useColors){const c=this.color,colorCode="[3"+(c<8?c:"8;5;"+c),prefix=`  ${colorCode};1m${name} [0m`;args[0]=prefix+args[0].split("\n").join("\n"+prefix),args.push(colorCode+"m+"+module.exports.humanize(this.diff)+"[0m");}else args[0]=function(){if(exports.inspectOpts.hideDate)return "";return (new Date).toISOString()+" "}()+name+" "+args[0];},exports.save=function(namespaces){namespaces?process.env.DEBUG=namespaces:delete process.env.DEBUG;},exports.load=function(){return process.env.DEBUG},exports.useColors=function(){return "colors"in exports.inspectOpts?Boolean(exports.inspectOpts.colors):tty.isatty(process.stderr.fd)},exports.destroy=util.deprecate((()=>{}),"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."),exports.colors=[6,2,3,4,5,1];try{const supportsColor=__webpack_require__("./node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js");supportsColor&&(supportsColor.stderr||supportsColor).level>=2&&(exports.colors=[20,21,26,27,32,33,38,39,40,41,42,43,44,45,56,57,62,63,68,69,74,75,76,77,78,79,80,81,92,93,98,99,112,113,128,129,134,135,148,149,160,161,162,163,164,165,166,167,168,169,170,171,172,173,178,179,184,185,196,197,198,199,200,201,202,203,204,205,206,207,208,209,214,215,220,221]);}catch(error){}exports.inspectOpts=Object.keys(process.env).filter((key=>/^debug_/i.test(key))).reduce(((obj,key)=>{const prop=key.substring(6).toLowerCase().replace(/_([a-z])/g,((_,k)=>k.toUpperCase()));let val=process.env[key];return val=!!/^(yes|on|true|enabled)$/i.test(val)||!/^(no|off|false|disabled)$/i.test(val)&&("null"===val?null:Number(val)),obj[prop]=val,obj}),{}),module.exports=__webpack_require__("./node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/common.js")(exports);const{formatters}=module.exports;formatters.o=function(v){return this.inspectOpts.colors=this.useColors,util.inspect(v,this.inspectOpts).split("\n").map((str=>str.trim())).join(" ")},formatters.O=function(v){return this.inspectOpts.colors=this.useColors,util.inspect(v,this.inspectOpts)};},"./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js":module=>{const GENSYNC_START=Symbol.for("gensync:v1:start"),GENSYNC_SUSPEND=Symbol.for("gensync:v1:suspend");function assertTypeof(type,name,value,allowUndefined){if(typeof value===type||allowUndefined&&void 0===value)return;let msg;throw msg=allowUndefined?`Expected opts.${name} to be either a ${type}, or undefined.`:`Expected opts.${name} to be a ${type}.`,makeError(msg,"GENSYNC_OPTIONS_ERROR")}function makeError(msg,code){return Object.assign(new Error(msg),{code})}function buildOperation({name,arity,sync,async}){return setFunctionMetadata(name,arity,(function*(...args){const resume=yield GENSYNC_START;if(!resume){return sync.call(this,args)}let result;try{async.call(this,args,(value=>{result||(result={value},resume());}),(err=>{result||(result={err},resume());}));}catch(err){result={err},resume();}if(yield GENSYNC_SUSPEND,result.hasOwnProperty("err"))throw result.err;return result.value}))}function evaluateSync(gen){let value;for(;!({value}=gen.next()).done;)assertStart(value,gen);return value}function evaluateAsync(gen,resolve,reject){!function step(){try{let value;for(;!({value}=gen.next()).done;){assertStart(value,gen);let sync=!0,didSyncResume=!1;const out=gen.next((()=>{sync?didSyncResume=!0:step();}));if(sync=!1,assertSuspend(out,gen),!didSyncResume)return}return resolve(value)}catch(err){return reject(err)}}();}function assertStart(value,gen){value!==GENSYNC_START&&throwError(gen,makeError(`Got unexpected yielded value in gensync generator: ${JSON.stringify(value)}. Did you perhaps mean to use 'yield*' instead of 'yield'?`,"GENSYNC_EXPECTED_START"));}function assertSuspend({value,done},gen){(done||value!==GENSYNC_SUSPEND)&&throwError(gen,makeError(done?"Unexpected generator completion. If you get this, it is probably a gensync bug.":`Expected GENSYNC_SUSPEND, got ${JSON.stringify(value)}. If you get this, it is probably a gensync bug.`,"GENSYNC_EXPECTED_SUSPEND"));}function throwError(gen,err){throw gen.throw&&gen.throw(err),err}function setFunctionMetadata(name,arity,fn){if("string"==typeof name){const nameDesc=Object.getOwnPropertyDescriptor(fn,"name");nameDesc&&!nameDesc.configurable||Object.defineProperty(fn,"name",Object.assign(nameDesc||{},{configurable:true,value:name}));}if("number"==typeof arity){const lengthDesc=Object.getOwnPropertyDescriptor(fn,"length");lengthDesc&&!lengthDesc.configurable||Object.defineProperty(fn,"length",Object.assign(lengthDesc||{},{configurable:true,value:arity}));}return fn}module.exports=Object.assign((function(optsOrFn){let genFn=optsOrFn;return genFn="function"!=typeof optsOrFn?function({name,arity,sync,async,errback}){if(assertTypeof("string","name",name,true),assertTypeof("number","arity",arity,true),assertTypeof("function","sync",sync),assertTypeof("function","async",async,true),assertTypeof("function","errback",errback,true),async&&errback)throw makeError("Expected one of either opts.async or opts.errback, but got _both_.","GENSYNC_OPTIONS_ERROR");if("string"!=typeof name){let fnName;errback&&errback.name&&"errback"!==errback.name&&(fnName=errback.name),async&&async.name&&"async"!==async.name&&(fnName=async.name.replace(/Async$/,"")),sync&&sync.name&&"sync"!==sync.name&&(fnName=sync.name.replace(/Sync$/,"")),"string"==typeof fnName&&(name=fnName);}"number"!=typeof arity&&(arity=sync.length);return buildOperation({name,arity,sync:function(args){return sync.apply(this,args)},async:function(args,resolve,reject){async?async.apply(this,args).then(resolve,reject):errback?errback.call(this,...args,((err,value)=>{null==err?resolve(value):reject(err);})):resolve(sync.apply(this,args));}})}(optsOrFn):function(genFn){return setFunctionMetadata(genFn.name,genFn.length,(function(...args){return genFn.apply(this,args)}))}(optsOrFn),Object.assign(genFn,function(genFn){const fns={sync:function(...args){return evaluateSync(genFn.apply(this,args))},async:function(...args){return new Promise(((resolve,reject)=>{evaluateAsync(genFn.apply(this,args),resolve,reject);}))},errback:function(...args){const cb=args.pop();if("function"!=typeof cb)throw makeError("Asynchronous function called without callback","GENSYNC_ERRBACK_NO_CALLBACK");let gen;try{gen=genFn.apply(this,args);}catch(err){return void cb(err)}evaluateAsync(gen,(val=>cb(void 0,val)),(err=>cb(err)));}};return fns}(genFn))}),{all:buildOperation({name:"all",arity:1,sync:function(args){return Array.from(args[0]).map((item=>evaluateSync(item)))},async:function(args,resolve,reject){const items=Array.from(args[0]);if(0===items.length)return void Promise.resolve().then((()=>resolve([])));let count=0;const results=items.map((()=>{}));items.forEach(((item,i)=>{evaluateAsync(item,(val=>{results[i]=val,count+=1,count===results.length&&resolve(results);}),reject);}));}}),race:buildOperation({name:"race",arity:1,sync:function(args){const items=Array.from(args[0]);if(0===items.length)throw makeError("Must race at least 1 item","GENSYNC_RACE_NONEMPTY");return evaluateSync(items[0])},async:function(args,resolve,reject){const items=Array.from(args[0]);if(0===items.length)throw makeError("Must race at least 1 item","GENSYNC_RACE_NONEMPTY");for(const item of items)evaluateAsync(item,resolve,reject);}})});},"./node_modules/.pnpm/globals@11.12.0/node_modules/globals/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{module.exports=__webpack_require__("./node_modules/.pnpm/globals@11.12.0/node_modules/globals/globals.json");},"./node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js":module=>{module.exports=(flag,argv=process.argv)=>{const prefix=flag.startsWith("-")?"":1===flag.length?"-":"--",position=argv.indexOf(prefix+flag),terminatorPosition=argv.indexOf("--");return  -1!==position&&(-1===terminatorPosition||position<terminatorPosition)};},"./node_modules/.pnpm/jsesc@3.1.0/node_modules/jsesc/jsesc.js":module=>{const object={},hasOwnProperty=object.hasOwnProperty,forOwn=(object,callback)=>{for(const key in object)hasOwnProperty.call(object,key)&&callback(key,object[key]);},fourHexEscape=hex=>"\\u"+("0000"+hex).slice(-4),hexadecimal=(code,lowercase)=>{let hexadecimal=code.toString(16);return lowercase?hexadecimal:hexadecimal.toUpperCase()},toString=object.toString,isArray=Array.isArray,isBigInt=value=>"bigint"==typeof value,singleEscapes={"\\":"\\\\","\b":"\\b","\f":"\\f","\n":"\\n","\r":"\\r","\t":"\\t"},regexSingleEscape=/[\\\b\f\n\r\t]/,regexDigit=/[0-9]/,regexWhitespace=/[\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/,escapeEverythingRegex=/([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^]/g,escapeNonAsciiRegex=/([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^ !#-&\(-\[\]-_a-~]/g,jsesc=(argument,options)=>{const increaseIndentation=()=>{oldIndent=indent,++options.indentLevel,indent=options.indent.repeat(options.indentLevel);},defaults={escapeEverything:false,minimal:false,isScriptContext:false,quotes:"single",wrap:false,es6:false,json:false,compact:true,lowercaseHex:false,numbers:"decimal",indent:"\t",indentLevel:0,__inline1__:false,__inline2__:false},json=options&&options.json;var destination,source;json&&(defaults.quotes="double",defaults.wrap=true),destination=defaults,"single"!=(options=(source=options)?(forOwn(source,((key,value)=>{destination[key]=value;})),destination):destination).quotes&&"double"!=options.quotes&&"backtick"!=options.quotes&&(options.quotes="single");const quote="double"==options.quotes?'"':"backtick"==options.quotes?"`":"'",compact=options.compact,lowercaseHex=options.lowercaseHex;let indent=options.indent.repeat(options.indentLevel),oldIndent="";const inline1=options.__inline1__,inline2=options.__inline2__,newLine=compact?"":"\n";let result,isEmpty=true;const useBinNumbers="binary"==options.numbers,useOctNumbers="octal"==options.numbers,useDecNumbers="decimal"==options.numbers,useHexNumbers="hexadecimal"==options.numbers;if(json&&argument&&(value=>"function"==typeof value)(argument.toJSON)&&(argument=argument.toJSON()),!(value=>"string"==typeof value||"[object String]"==toString.call(value))(argument)){if((value=>"[object Map]"==toString.call(value))(argument))return 0==argument.size?"new Map()":(compact||(options.__inline1__=true,options.__inline2__=false),"new Map("+jsesc(Array.from(argument),options)+")");if((value=>"[object Set]"==toString.call(value))(argument))return 0==argument.size?"new Set()":"new Set("+jsesc(Array.from(argument),options)+")";if((value=>"function"==typeof Buffer&&Buffer.isBuffer(value))(argument))return 0==argument.length?"Buffer.from([])":"Buffer.from("+jsesc(Array.from(argument),options)+")";if(isArray(argument))return result=[],options.wrap=true,inline1&&(options.__inline1__=false,options.__inline2__=true),inline2||increaseIndentation(),((array,callback)=>{const length=array.length;let index=-1;for(;++index<length;)callback(array[index]);})(argument,(value=>{isEmpty=false,inline2&&(options.__inline2__=false),result.push((compact||inline2?"":indent)+jsesc(value,options));})),isEmpty?"[]":inline2?"["+result.join(", ")+"]":"["+newLine+result.join(","+newLine)+newLine+(compact?"":oldIndent)+"]";if((value=>"number"==typeof value||"[object Number]"==toString.call(value))(argument)||isBigInt(argument)){if(json)return JSON.stringify(Number(argument));let result;if(useDecNumbers)result=String(argument);else if(useHexNumbers){let hexadecimal=argument.toString(16);lowercaseHex||(hexadecimal=hexadecimal.toUpperCase()),result="0x"+hexadecimal;}else useBinNumbers?result="0b"+argument.toString(2):useOctNumbers&&(result="0o"+argument.toString(8));return isBigInt(argument)?result+"n":result}return isBigInt(argument)?json?JSON.stringify(Number(argument)):argument+"n":(value=>"[object Object]"==toString.call(value))(argument)?(result=[],options.wrap=true,increaseIndentation(),forOwn(argument,((key,value)=>{isEmpty=false,result.push((compact?"":indent)+jsesc(key,options)+":"+(compact?"":" ")+jsesc(value,options));})),isEmpty?"{}":"{"+newLine+result.join(","+newLine)+newLine+(compact?"":oldIndent)+"}"):json?JSON.stringify(argument)||"null":String(argument)}const regex=options.escapeEverything?escapeEverythingRegex:escapeNonAsciiRegex;return result=argument.replace(regex,((char,pair,lone,quoteChar,index,string)=>{if(pair){if(options.minimal)return pair;const first=pair.charCodeAt(0),second=pair.charCodeAt(1);if(options.es6){return "\\u{"+hexadecimal(1024*(first-55296)+second-56320+65536,lowercaseHex)+"}"}return fourHexEscape(hexadecimal(first,lowercaseHex))+fourHexEscape(hexadecimal(second,lowercaseHex))}if(lone)return fourHexEscape(hexadecimal(lone.charCodeAt(0),lowercaseHex));if("\0"==char&&!json&&!regexDigit.test(string.charAt(index+1)))return "\\0";if(quoteChar)return quoteChar==quote||options.escapeEverything?"\\"+quoteChar:quoteChar;if(regexSingleEscape.test(char))return singleEscapes[char];if(options.minimal&&!regexWhitespace.test(char))return char;const hex=hexadecimal(char.charCodeAt(0),lowercaseHex);return json||hex.length>2?fourHexEscape(hex):"\\x"+("00"+hex).slice(-2)})),"`"==quote&&(result=result.replace(/\$\{/g,"\\${")),options.isScriptContext&&(result=result.replace(/<\/(script|style)/gi,"<\\/$1").replace(/<!--/g,json?"\\u003C!--":"\\x3C!--")),options.wrap&&(result=quote+result+quote),result};jsesc.version="3.0.2",module.exports=jsesc;},"./node_modules/.pnpm/mlly@1.7.3/node_modules/mlly/dist lazy recursive":module=>{function webpackEmptyAsyncContext(req){return Promise.resolve().then((()=>{var e=new Error("Cannot find module '"+req+"'");throw e.code="MODULE_NOT_FOUND",e}))}webpackEmptyAsyncContext.keys=()=>[],webpackEmptyAsyncContext.resolve=webpackEmptyAsyncContext,webpackEmptyAsyncContext.id="./node_modules/.pnpm/mlly@1.7.3/node_modules/mlly/dist lazy recursive",module.exports=webpackEmptyAsyncContext;},"./node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js":module=>{var s=1e3,m=60*s,h=60*m,d=24*h,w=7*d,y=365.25*d;function plural(ms,msAbs,n,name){var isPlural=msAbs>=1.5*n;return Math.round(ms/n)+" "+name+(isPlural?"s":"")}module.exports=function(val,options){options=options||{};var type=typeof val;if("string"===type&&val.length>0)return function(str){if((str=String(str)).length>100)return;var match=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);if(!match)return;var n=parseFloat(match[1]);switch((match[2]||"ms").toLowerCase()){case "years":case "year":case "yrs":case "yr":case "y":return n*y;case "weeks":case "week":case "w":return n*w;case "days":case "day":case "d":return n*d;case "hours":case "hour":case "hrs":case "hr":case "h":return n*h;case "minutes":case "minute":case "mins":case "min":case "m":return n*m;case "seconds":case "second":case "secs":case "sec":case "s":return n*s;case "milliseconds":case "millisecond":case "msecs":case "msec":case "ms":return n;default:return}}(val);if("number"===type&&isFinite(val))return options.long?function(ms){var msAbs=Math.abs(ms);if(msAbs>=d)return plural(ms,msAbs,d,"day");if(msAbs>=h)return plural(ms,msAbs,h,"hour");if(msAbs>=m)return plural(ms,msAbs,m,"minute");if(msAbs>=s)return plural(ms,msAbs,s,"second");return ms+" ms"}(val):function(ms){var msAbs=Math.abs(ms);if(msAbs>=d)return Math.round(ms/d)+"d";if(msAbs>=h)return Math.round(ms/h)+"h";if(msAbs>=m)return Math.round(ms/m)+"m";if(msAbs>=s)return Math.round(ms/s)+"s";return ms+"ms"}(val);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(val))};},"./node_modules/.pnpm/semver@6.3.1/node_modules/semver/semver.js":(module,exports)=>{var debug;exports=module.exports=SemVer,debug="object"==typeof process&&process.env&&process.env.NODE_DEBUG&&/\bsemver\b/i.test(process.env.NODE_DEBUG)?function(){var args=Array.prototype.slice.call(arguments,0);args.unshift("SEMVER"),console.log.apply(console,args);}:function(){},exports.SEMVER_SPEC_VERSION="2.0.0";var MAX_LENGTH=256,MAX_SAFE_INTEGER=Number.MAX_SAFE_INTEGER||9007199254740991,MAX_SAFE_BUILD_LENGTH=MAX_LENGTH-6,re=exports.re=[],safeRe=exports.safeRe=[],src=exports.src=[],t=exports.tokens={},R=0;function tok(n){t[n]=R++;}var safeRegexReplacements=[["\\s",1],["\\d",MAX_LENGTH],["[a-zA-Z0-9-]",MAX_SAFE_BUILD_LENGTH]];function makeSafeRe(value){for(var i=0;i<safeRegexReplacements.length;i++){var token=safeRegexReplacements[i][0],max=safeRegexReplacements[i][1];value=value.split(token+"*").join(token+"{0,"+max+"}").split(token+"+").join(token+"{1,"+max+"}");}return value}tok("NUMERICIDENTIFIER"),src[t.NUMERICIDENTIFIER]="0|[1-9]\\d*",tok("NUMERICIDENTIFIERLOOSE"),src[t.NUMERICIDENTIFIERLOOSE]="\\d+",tok("NONNUMERICIDENTIFIER"),src[t.NONNUMERICIDENTIFIER]="\\d*[a-zA-Z-][a-zA-Z0-9-]*",tok("MAINVERSION"),src[t.MAINVERSION]="("+src[t.NUMERICIDENTIFIER]+")\\.("+src[t.NUMERICIDENTIFIER]+")\\.("+src[t.NUMERICIDENTIFIER]+")",tok("MAINVERSIONLOOSE"),src[t.MAINVERSIONLOOSE]="("+src[t.NUMERICIDENTIFIERLOOSE]+")\\.("+src[t.NUMERICIDENTIFIERLOOSE]+")\\.("+src[t.NUMERICIDENTIFIERLOOSE]+")",tok("PRERELEASEIDENTIFIER"),src[t.PRERELEASEIDENTIFIER]="(?:"+src[t.NUMERICIDENTIFIER]+"|"+src[t.NONNUMERICIDENTIFIER]+")",tok("PRERELEASEIDENTIFIERLOOSE"),src[t.PRERELEASEIDENTIFIERLOOSE]="(?:"+src[t.NUMERICIDENTIFIERLOOSE]+"|"+src[t.NONNUMERICIDENTIFIER]+")",tok("PRERELEASE"),src[t.PRERELEASE]="(?:-("+src[t.PRERELEASEIDENTIFIER]+"(?:\\."+src[t.PRERELEASEIDENTIFIER]+")*))",tok("PRERELEASELOOSE"),src[t.PRERELEASELOOSE]="(?:-?("+src[t.PRERELEASEIDENTIFIERLOOSE]+"(?:\\."+src[t.PRERELEASEIDENTIFIERLOOSE]+")*))",tok("BUILDIDENTIFIER"),src[t.BUILDIDENTIFIER]="[a-zA-Z0-9-]+",tok("BUILD"),src[t.BUILD]="(?:\\+("+src[t.BUILDIDENTIFIER]+"(?:\\."+src[t.BUILDIDENTIFIER]+")*))",tok("FULL"),tok("FULLPLAIN"),src[t.FULLPLAIN]="v?"+src[t.MAINVERSION]+src[t.PRERELEASE]+"?"+src[t.BUILD]+"?",src[t.FULL]="^"+src[t.FULLPLAIN]+"$",tok("LOOSEPLAIN"),src[t.LOOSEPLAIN]="[v=\\s]*"+src[t.MAINVERSIONLOOSE]+src[t.PRERELEASELOOSE]+"?"+src[t.BUILD]+"?",tok("LOOSE"),src[t.LOOSE]="^"+src[t.LOOSEPLAIN]+"$",tok("GTLT"),src[t.GTLT]="((?:<|>)?=?)",tok("XRANGEIDENTIFIERLOOSE"),src[t.XRANGEIDENTIFIERLOOSE]=src[t.NUMERICIDENTIFIERLOOSE]+"|x|X|\\*",tok("XRANGEIDENTIFIER"),src[t.XRANGEIDENTIFIER]=src[t.NUMERICIDENTIFIER]+"|x|X|\\*",tok("XRANGEPLAIN"),src[t.XRANGEPLAIN]="[v=\\s]*("+src[t.XRANGEIDENTIFIER]+")(?:\\.("+src[t.XRANGEIDENTIFIER]+")(?:\\.("+src[t.XRANGEIDENTIFIER]+")(?:"+src[t.PRERELEASE]+")?"+src[t.BUILD]+"?)?)?",tok("XRANGEPLAINLOOSE"),src[t.XRANGEPLAINLOOSE]="[v=\\s]*("+src[t.XRANGEIDENTIFIERLOOSE]+")(?:\\.("+src[t.XRANGEIDENTIFIERLOOSE]+")(?:\\.("+src[t.XRANGEIDENTIFIERLOOSE]+")(?:"+src[t.PRERELEASELOOSE]+")?"+src[t.BUILD]+"?)?)?",tok("XRANGE"),src[t.XRANGE]="^"+src[t.GTLT]+"\\s*"+src[t.XRANGEPLAIN]+"$",tok("XRANGELOOSE"),src[t.XRANGELOOSE]="^"+src[t.GTLT]+"\\s*"+src[t.XRANGEPLAINLOOSE]+"$",tok("COERCE"),src[t.COERCE]="(^|[^\\d])(\\d{1,16})(?:\\.(\\d{1,16}))?(?:\\.(\\d{1,16}))?(?:$|[^\\d])",tok("COERCERTL"),re[t.COERCERTL]=new RegExp(src[t.COERCE],"g"),safeRe[t.COERCERTL]=new RegExp(makeSafeRe(src[t.COERCE]),"g"),tok("LONETILDE"),src[t.LONETILDE]="(?:~>?)",tok("TILDETRIM"),src[t.TILDETRIM]="(\\s*)"+src[t.LONETILDE]+"\\s+",re[t.TILDETRIM]=new RegExp(src[t.TILDETRIM],"g"),safeRe[t.TILDETRIM]=new RegExp(makeSafeRe(src[t.TILDETRIM]),"g");tok("TILDE"),src[t.TILDE]="^"+src[t.LONETILDE]+src[t.XRANGEPLAIN]+"$",tok("TILDELOOSE"),src[t.TILDELOOSE]="^"+src[t.LONETILDE]+src[t.XRANGEPLAINLOOSE]+"$",tok("LONECARET"),src[t.LONECARET]="(?:\\^)",tok("CARETTRIM"),src[t.CARETTRIM]="(\\s*)"+src[t.LONECARET]+"\\s+",re[t.CARETTRIM]=new RegExp(src[t.CARETTRIM],"g"),safeRe[t.CARETTRIM]=new RegExp(makeSafeRe(src[t.CARETTRIM]),"g");tok("CARET"),src[t.CARET]="^"+src[t.LONECARET]+src[t.XRANGEPLAIN]+"$",tok("CARETLOOSE"),src[t.CARETLOOSE]="^"+src[t.LONECARET]+src[t.XRANGEPLAINLOOSE]+"$",tok("COMPARATORLOOSE"),src[t.COMPARATORLOOSE]="^"+src[t.GTLT]+"\\s*("+src[t.LOOSEPLAIN]+")$|^$",tok("COMPARATOR"),src[t.COMPARATOR]="^"+src[t.GTLT]+"\\s*("+src[t.FULLPLAIN]+")$|^$",tok("COMPARATORTRIM"),src[t.COMPARATORTRIM]="(\\s*)"+src[t.GTLT]+"\\s*("+src[t.LOOSEPLAIN]+"|"+src[t.XRANGEPLAIN]+")",re[t.COMPARATORTRIM]=new RegExp(src[t.COMPARATORTRIM],"g"),safeRe[t.COMPARATORTRIM]=new RegExp(makeSafeRe(src[t.COMPARATORTRIM]),"g");tok("HYPHENRANGE"),src[t.HYPHENRANGE]="^\\s*("+src[t.XRANGEPLAIN]+")\\s+-\\s+("+src[t.XRANGEPLAIN]+")\\s*$",tok("HYPHENRANGELOOSE"),src[t.HYPHENRANGELOOSE]="^\\s*("+src[t.XRANGEPLAINLOOSE]+")\\s+-\\s+("+src[t.XRANGEPLAINLOOSE]+")\\s*$",tok("STAR"),src[t.STAR]="(<|>)?=?\\s*\\*";for(var i=0;i<R;i++)debug(i,src[i]),re[i]||(re[i]=new RegExp(src[i]),safeRe[i]=new RegExp(makeSafeRe(src[i])));function parse(version,options){if(options&&"object"==typeof options||(options={loose:!!options,includePrerelease:false}),version instanceof SemVer)return version;if("string"!=typeof version)return null;if(version.length>MAX_LENGTH)return null;if(!(options.loose?safeRe[t.LOOSE]:safeRe[t.FULL]).test(version))return null;try{return new SemVer(version,options)}catch(er){return null}}function SemVer(version,options){if(options&&"object"==typeof options||(options={loose:!!options,includePrerelease:false}),version instanceof SemVer){if(version.loose===options.loose)return version;version=version.version;}else if("string"!=typeof version)throw new TypeError("Invalid Version: "+version);if(version.length>MAX_LENGTH)throw new TypeError("version is longer than "+MAX_LENGTH+" characters");if(!(this instanceof SemVer))return new SemVer(version,options);debug("SemVer",version,options),this.options=options,this.loose=!!options.loose;var m=version.trim().match(options.loose?safeRe[t.LOOSE]:safeRe[t.FULL]);if(!m)throw new TypeError("Invalid Version: "+version);if(this.raw=version,this.major=+m[1],this.minor=+m[2],this.patch=+m[3],this.major>MAX_SAFE_INTEGER||this.major<0)throw new TypeError("Invalid major version");if(this.minor>MAX_SAFE_INTEGER||this.minor<0)throw new TypeError("Invalid minor version");if(this.patch>MAX_SAFE_INTEGER||this.patch<0)throw new TypeError("Invalid patch version");m[4]?this.prerelease=m[4].split(".").map((function(id){if(/^[0-9]+$/.test(id)){var num=+id;if(num>=0&&num<MAX_SAFE_INTEGER)return num}return id})):this.prerelease=[],this.build=m[5]?m[5].split("."):[],this.format();}exports.parse=parse,exports.valid=function(version,options){var v=parse(version,options);return v?v.version:null},exports.clean=function(version,options){var s=parse(version.trim().replace(/^[=v]+/,""),options);return s?s.version:null},exports.SemVer=SemVer,SemVer.prototype.format=function(){return this.version=this.major+"."+this.minor+"."+this.patch,this.prerelease.length&&(this.version+="-"+this.prerelease.join(".")),this.version},SemVer.prototype.toString=function(){return this.version},SemVer.prototype.compare=function(other){return debug("SemVer.compare",this.version,this.options,other),other instanceof SemVer||(other=new SemVer(other,this.options)),this.compareMain(other)||this.comparePre(other)},SemVer.prototype.compareMain=function(other){return other instanceof SemVer||(other=new SemVer(other,this.options)),compareIdentifiers(this.major,other.major)||compareIdentifiers(this.minor,other.minor)||compareIdentifiers(this.patch,other.patch)},SemVer.prototype.comparePre=function(other){if(other instanceof SemVer||(other=new SemVer(other,this.options)),this.prerelease.length&&!other.prerelease.length)return  -1;if(!this.prerelease.length&&other.prerelease.length)return 1;if(!this.prerelease.length&&!other.prerelease.length)return 0;var i=0;do{var a=this.prerelease[i],b=other.prerelease[i];if(debug("prerelease compare",i,a,b),void 0===a&&void 0===b)return 0;if(void 0===b)return 1;if(void 0===a)return  -1;if(a!==b)return compareIdentifiers(a,b)}while(++i)},SemVer.prototype.compareBuild=function(other){other instanceof SemVer||(other=new SemVer(other,this.options));var i=0;do{var a=this.build[i],b=other.build[i];if(debug("prerelease compare",i,a,b),void 0===a&&void 0===b)return 0;if(void 0===b)return 1;if(void 0===a)return  -1;if(a!==b)return compareIdentifiers(a,b)}while(++i)},SemVer.prototype.inc=function(release,identifier){switch(release){case "premajor":this.prerelease.length=0,this.patch=0,this.minor=0,this.major++,this.inc("pre",identifier);break;case "preminor":this.prerelease.length=0,this.patch=0,this.minor++,this.inc("pre",identifier);break;case "prepatch":this.prerelease.length=0,this.inc("patch",identifier),this.inc("pre",identifier);break;case "prerelease":0===this.prerelease.length&&this.inc("patch",identifier),this.inc("pre",identifier);break;case "major":0===this.minor&&0===this.patch&&0!==this.prerelease.length||this.major++,this.minor=0,this.patch=0,this.prerelease=[];break;case "minor":0===this.patch&&0!==this.prerelease.length||this.minor++,this.patch=0,this.prerelease=[];break;case "patch":0===this.prerelease.length&&this.patch++,this.prerelease=[];break;case "pre":if(0===this.prerelease.length)this.prerelease=[0];else {for(var i=this.prerelease.length;--i>=0;)"number"==typeof this.prerelease[i]&&(this.prerelease[i]++,i=-2);-1===i&&this.prerelease.push(0);}identifier&&(this.prerelease[0]===identifier?isNaN(this.prerelease[1])&&(this.prerelease=[identifier,0]):this.prerelease=[identifier,0]);break;default:throw new Error("invalid increment argument: "+release)}return this.format(),this.raw=this.version,this},exports.inc=function(version,release,loose,identifier){"string"==typeof loose&&(identifier=loose,loose=void 0);try{return new SemVer(version,loose).inc(release,identifier).version}catch(er){return null}},exports.diff=function(version1,version2){if(eq(version1,version2))return null;var v1=parse(version1),v2=parse(version2),prefix="";if(v1.prerelease.length||v2.prerelease.length){prefix="pre";var defaultResult="prerelease";}for(var key in v1)if(("major"===key||"minor"===key||"patch"===key)&&v1[key]!==v2[key])return prefix+key;return defaultResult},exports.compareIdentifiers=compareIdentifiers;var numeric=/^[0-9]+$/;function compareIdentifiers(a,b){var anum=numeric.test(a),bnum=numeric.test(b);return anum&&bnum&&(a=+a,b=+b),a===b?0:anum&&!bnum?-1:bnum&&!anum?1:a<b?-1:1}function compare(a,b,loose){return new SemVer(a,loose).compare(new SemVer(b,loose))}function gt(a,b,loose){return compare(a,b,loose)>0}function lt(a,b,loose){return compare(a,b,loose)<0}function eq(a,b,loose){return 0===compare(a,b,loose)}function neq(a,b,loose){return 0!==compare(a,b,loose)}function gte(a,b,loose){return compare(a,b,loose)>=0}function lte(a,b,loose){return compare(a,b,loose)<=0}function cmp(a,op,b,loose){switch(op){case "===":return "object"==typeof a&&(a=a.version),"object"==typeof b&&(b=b.version),a===b;case "!==":return "object"==typeof a&&(a=a.version),"object"==typeof b&&(b=b.version),a!==b;case "":case "=":case "==":return eq(a,b,loose);case "!=":return neq(a,b,loose);case ">":return gt(a,b,loose);case ">=":return gte(a,b,loose);case "<":return lt(a,b,loose);case "<=":return lte(a,b,loose);default:throw new TypeError("Invalid operator: "+op)}}function Comparator(comp,options){if(options&&"object"==typeof options||(options={loose:!!options,includePrerelease:false}),comp instanceof Comparator){if(comp.loose===!!options.loose)return comp;comp=comp.value;}if(!(this instanceof Comparator))return new Comparator(comp,options);comp=comp.trim().split(/\s+/).join(" "),debug("comparator",comp,options),this.options=options,this.loose=!!options.loose,this.parse(comp),this.semver===ANY?this.value="":this.value=this.operator+this.semver.version,debug("comp",this);}exports.rcompareIdentifiers=function(a,b){return compareIdentifiers(b,a)},exports.major=function(a,loose){return new SemVer(a,loose).major},exports.minor=function(a,loose){return new SemVer(a,loose).minor},exports.patch=function(a,loose){return new SemVer(a,loose).patch},exports.compare=compare,exports.compareLoose=function(a,b){return compare(a,b,true)},exports.compareBuild=function(a,b,loose){var versionA=new SemVer(a,loose),versionB=new SemVer(b,loose);return versionA.compare(versionB)||versionA.compareBuild(versionB)},exports.rcompare=function(a,b,loose){return compare(b,a,loose)},exports.sort=function(list,loose){return list.sort((function(a,b){return exports.compareBuild(a,b,loose)}))},exports.rsort=function(list,loose){return list.sort((function(a,b){return exports.compareBuild(b,a,loose)}))},exports.gt=gt,exports.lt=lt,exports.eq=eq,exports.neq=neq,exports.gte=gte,exports.lte=lte,exports.cmp=cmp,exports.Comparator=Comparator;var ANY={};function Range(range,options){if(options&&"object"==typeof options||(options={loose:!!options,includePrerelease:false}),range instanceof Range)return range.loose===!!options.loose&&range.includePrerelease===!!options.includePrerelease?range:new Range(range.raw,options);if(range instanceof Comparator)return new Range(range.value,options);if(!(this instanceof Range))return new Range(range,options);if(this.options=options,this.loose=!!options.loose,this.includePrerelease=!!options.includePrerelease,this.raw=range.trim().split(/\s+/).join(" "),this.set=this.raw.split("||").map((function(range){return this.parseRange(range.trim())}),this).filter((function(c){return c.length})),!this.set.length)throw new TypeError("Invalid SemVer Range: "+this.raw);this.format();}function isSatisfiable(comparators,options){for(var result=true,remainingComparators=comparators.slice(),testComparator=remainingComparators.pop();result&&remainingComparators.length;)result=remainingComparators.every((function(otherComparator){return testComparator.intersects(otherComparator,options)})),testComparator=remainingComparators.pop();return result}function isX(id){return !id||"x"===id.toLowerCase()||"*"===id}function hyphenReplace($0,from,fM,fm,fp,fpr,fb,to,tM,tm,tp,tpr,tb){return ((from=isX(fM)?"":isX(fm)?">="+fM+".0.0":isX(fp)?">="+fM+"."+fm+".0":">="+from)+" "+(to=isX(tM)?"":isX(tm)?"<"+(+tM+1)+".0.0":isX(tp)?"<"+tM+"."+(+tm+1)+".0":tpr?"<="+tM+"."+tm+"."+tp+"-"+tpr:"<="+to)).trim()}function testSet(set,version,options){for(var i=0;i<set.length;i++)if(!set[i].test(version))return  false;if(version.prerelease.length&&!options.includePrerelease){for(i=0;i<set.length;i++)if(debug(set[i].semver),set[i].semver!==ANY&&set[i].semver.prerelease.length>0){var allowed=set[i].semver;if(allowed.major===version.major&&allowed.minor===version.minor&&allowed.patch===version.patch)return  true}return  false}return  true}function satisfies(version,range,options){try{range=new Range(range,options);}catch(er){return  false}return range.test(version)}function outside(version,range,hilo,options){var gtfn,ltefn,ltfn,comp,ecomp;switch(version=new SemVer(version,options),range=new Range(range,options),hilo){case ">":gtfn=gt,ltefn=lte,ltfn=lt,comp=">",ecomp=">=";break;case "<":gtfn=lt,ltefn=gte,ltfn=gt,comp="<",ecomp="<=";break;default:throw new TypeError('Must provide a hilo val of "<" or ">"')}if(satisfies(version,range,options))return  false;for(var i=0;i<range.set.length;++i){var comparators=range.set[i],high=null,low=null;if(comparators.forEach((function(comparator){comparator.semver===ANY&&(comparator=new Comparator(">=0.0.0")),high=high||comparator,low=low||comparator,gtfn(comparator.semver,high.semver,options)?high=comparator:ltfn(comparator.semver,low.semver,options)&&(low=comparator);})),high.operator===comp||high.operator===ecomp)return  false;if((!low.operator||low.operator===comp)&&ltefn(version,low.semver))return  false;if(low.operator===ecomp&&ltfn(version,low.semver))return  false}return  true}Comparator.prototype.parse=function(comp){var r=this.options.loose?safeRe[t.COMPARATORLOOSE]:safeRe[t.COMPARATOR],m=comp.match(r);if(!m)throw new TypeError("Invalid comparator: "+comp);this.operator=void 0!==m[1]?m[1]:"","="===this.operator&&(this.operator=""),m[2]?this.semver=new SemVer(m[2],this.options.loose):this.semver=ANY;},Comparator.prototype.toString=function(){return this.value},Comparator.prototype.test=function(version){if(debug("Comparator.test",version,this.options.loose),this.semver===ANY||version===ANY)return  true;if("string"==typeof version)try{version=new SemVer(version,this.options);}catch(er){return  false}return cmp(version,this.operator,this.semver,this.options)},Comparator.prototype.intersects=function(comp,options){if(!(comp instanceof Comparator))throw new TypeError("a Comparator is required");var rangeTmp;if(options&&"object"==typeof options||(options={loose:!!options,includePrerelease:false}),""===this.operator)return ""===this.value||(rangeTmp=new Range(comp.value,options),satisfies(this.value,rangeTmp,options));if(""===comp.operator)return ""===comp.value||(rangeTmp=new Range(this.value,options),satisfies(comp.semver,rangeTmp,options));var sameDirectionIncreasing=!(">="!==this.operator&&">"!==this.operator||">="!==comp.operator&&">"!==comp.operator),sameDirectionDecreasing=!("<="!==this.operator&&"<"!==this.operator||"<="!==comp.operator&&"<"!==comp.operator),sameSemVer=this.semver.version===comp.semver.version,differentDirectionsInclusive=!(">="!==this.operator&&"<="!==this.operator||">="!==comp.operator&&"<="!==comp.operator),oppositeDirectionsLessThan=cmp(this.semver,"<",comp.semver,options)&&(">="===this.operator||">"===this.operator)&&("<="===comp.operator||"<"===comp.operator),oppositeDirectionsGreaterThan=cmp(this.semver,">",comp.semver,options)&&("<="===this.operator||"<"===this.operator)&&(">="===comp.operator||">"===comp.operator);return sameDirectionIncreasing||sameDirectionDecreasing||sameSemVer&&differentDirectionsInclusive||oppositeDirectionsLessThan||oppositeDirectionsGreaterThan},exports.Range=Range,Range.prototype.format=function(){return this.range=this.set.map((function(comps){return comps.join(" ").trim()})).join("||").trim(),this.range},Range.prototype.toString=function(){return this.range},Range.prototype.parseRange=function(range){var loose=this.options.loose,hr=loose?safeRe[t.HYPHENRANGELOOSE]:safeRe[t.HYPHENRANGE];range=range.replace(hr,hyphenReplace),debug("hyphen replace",range),range=range.replace(safeRe[t.COMPARATORTRIM],"$1$2$3"),debug("comparator trim",range,safeRe[t.COMPARATORTRIM]),range=(range=(range=range.replace(safeRe[t.TILDETRIM],"$1~")).replace(safeRe[t.CARETTRIM],"$1^")).split(/\s+/).join(" ");var compRe=loose?safeRe[t.COMPARATORLOOSE]:safeRe[t.COMPARATOR],set=range.split(" ").map((function(comp){return function(comp,options){return debug("comp",comp,options),comp=function(comp,options){return comp.trim().split(/\s+/).map((function(comp){return function(comp,options){debug("caret",comp,options);var r=options.loose?safeRe[t.CARETLOOSE]:safeRe[t.CARET];return comp.replace(r,(function(_,M,m,p,pr){var ret;return debug("caret",comp,_,M,m,p,pr),isX(M)?ret="":isX(m)?ret=">="+M+".0.0 <"+(+M+1)+".0.0":isX(p)?ret="0"===M?">="+M+"."+m+".0 <"+M+"."+(+m+1)+".0":">="+M+"."+m+".0 <"+(+M+1)+".0.0":pr?(debug("replaceCaret pr",pr),ret="0"===M?"0"===m?">="+M+"."+m+"."+p+"-"+pr+" <"+M+"."+m+"."+(+p+1):">="+M+"."+m+"."+p+"-"+pr+" <"+M+"."+(+m+1)+".0":">="+M+"."+m+"."+p+"-"+pr+" <"+(+M+1)+".0.0"):(debug("no pr"),ret="0"===M?"0"===m?">="+M+"."+m+"."+p+" <"+M+"."+m+"."+(+p+1):">="+M+"."+m+"."+p+" <"+M+"."+(+m+1)+".0":">="+M+"."+m+"."+p+" <"+(+M+1)+".0.0"),debug("caret return",ret),ret}))}(comp,options)})).join(" ")}(comp,options),debug("caret",comp),comp=function(comp,options){return comp.trim().split(/\s+/).map((function(comp){return function(comp,options){var r=options.loose?safeRe[t.TILDELOOSE]:safeRe[t.TILDE];return comp.replace(r,(function(_,M,m,p,pr){var ret;return debug("tilde",comp,_,M,m,p,pr),isX(M)?ret="":isX(m)?ret=">="+M+".0.0 <"+(+M+1)+".0.0":isX(p)?ret=">="+M+"."+m+".0 <"+M+"."+(+m+1)+".0":pr?(debug("replaceTilde pr",pr),ret=">="+M+"."+m+"."+p+"-"+pr+" <"+M+"."+(+m+1)+".0"):ret=">="+M+"."+m+"."+p+" <"+M+"."+(+m+1)+".0",debug("tilde return",ret),ret}))}(comp,options)})).join(" ")}(comp,options),debug("tildes",comp),comp=function(comp,options){return debug("replaceXRanges",comp,options),comp.split(/\s+/).map((function(comp){return function(comp,options){comp=comp.trim();var r=options.loose?safeRe[t.XRANGELOOSE]:safeRe[t.XRANGE];return comp.replace(r,(function(ret,gtlt,M,m,p,pr){debug("xRange",comp,ret,gtlt,M,m,p,pr);var xM=isX(M),xm=xM||isX(m),xp=xm||isX(p),anyX=xp;return "="===gtlt&&anyX&&(gtlt=""),pr=options.includePrerelease?"-0":"",xM?ret=">"===gtlt||"<"===gtlt?"<0.0.0-0":"*":gtlt&&anyX?(xm&&(m=0),p=0,">"===gtlt?(gtlt=">=",xm?(M=+M+1,m=0,p=0):(m=+m+1,p=0)):"<="===gtlt&&(gtlt="<",xm?M=+M+1:m=+m+1),ret=gtlt+M+"."+m+"."+p+pr):xm?ret=">="+M+".0.0"+pr+" <"+(+M+1)+".0.0"+pr:xp&&(ret=">="+M+"."+m+".0"+pr+" <"+M+"."+(+m+1)+".0"+pr),debug("xRange return",ret),ret}))}(comp,options)})).join(" ")}(comp,options),debug("xrange",comp),comp=function(comp,options){return debug("replaceStars",comp,options),comp.trim().replace(safeRe[t.STAR],"")}(comp,options),debug("stars",comp),comp}(comp,this.options)}),this).join(" ").split(/\s+/);return this.options.loose&&(set=set.filter((function(comp){return !!comp.match(compRe)}))),set=set.map((function(comp){return new Comparator(comp,this.options)}),this)},Range.prototype.intersects=function(range,options){if(!(range instanceof Range))throw new TypeError("a Range is required");return this.set.some((function(thisComparators){return isSatisfiable(thisComparators,options)&&range.set.some((function(rangeComparators){return isSatisfiable(rangeComparators,options)&&thisComparators.every((function(thisComparator){return rangeComparators.every((function(rangeComparator){return thisComparator.intersects(rangeComparator,options)}))}))}))}))},exports.toComparators=function(range,options){return new Range(range,options).set.map((function(comp){return comp.map((function(c){return c.value})).join(" ").trim().split(" ")}))},Range.prototype.test=function(version){if(!version)return  false;if("string"==typeof version)try{version=new SemVer(version,this.options);}catch(er){return  false}for(var i=0;i<this.set.length;i++)if(testSet(this.set[i],version,this.options))return  true;return  false},exports.satisfies=satisfies,exports.maxSatisfying=function(versions,range,options){var max=null,maxSV=null;try{var rangeObj=new Range(range,options);}catch(er){return null}return versions.forEach((function(v){rangeObj.test(v)&&(max&&-1!==maxSV.compare(v)||(maxSV=new SemVer(max=v,options)));})),max},exports.minSatisfying=function(versions,range,options){var min=null,minSV=null;try{var rangeObj=new Range(range,options);}catch(er){return null}return versions.forEach((function(v){rangeObj.test(v)&&(min&&1!==minSV.compare(v)||(minSV=new SemVer(min=v,options)));})),min},exports.minVersion=function(range,loose){range=new Range(range,loose);var minver=new SemVer("0.0.0");if(range.test(minver))return minver;if(minver=new SemVer("0.0.0-0"),range.test(minver))return minver;minver=null;for(var i=0;i<range.set.length;++i){range.set[i].forEach((function(comparator){var compver=new SemVer(comparator.semver.version);switch(comparator.operator){case ">":0===compver.prerelease.length?compver.patch++:compver.prerelease.push(0),compver.raw=compver.format();case "":case ">=":minver&&!gt(minver,compver)||(minver=compver);break;case "<":case "<=":break;default:throw new Error("Unexpected operation: "+comparator.operator)}}));}if(minver&&range.test(minver))return minver;return null},exports.validRange=function(range,options){try{return new Range(range,options).range||"*"}catch(er){return null}},exports.ltr=function(version,range,options){return outside(version,range,"<",options)},exports.gtr=function(version,range,options){return outside(version,range,">",options)},exports.outside=outside,exports.prerelease=function(version,options){var parsed=parse(version,options);return parsed&&parsed.prerelease.length?parsed.prerelease:null},exports.intersects=function(r1,r2,options){return r1=new Range(r1,options),r2=new Range(r2,options),r1.intersects(r2)},exports.coerce=function(version,options){if(version instanceof SemVer)return version;"number"==typeof version&&(version=String(version));if("string"!=typeof version)return null;var match=null;if((options=options||{}).rtl){for(var next;(next=safeRe[t.COERCERTL].exec(version))&&(!match||match.index+match[0].length!==version.length);)match&&next.index+next[0].length===match.index+match[0].length||(match=next),safeRe[t.COERCERTL].lastIndex=next.index+next[1].length+next[2].length;safeRe[t.COERCERTL].lastIndex=-1;}else match=version.match(safeRe[t.COERCE]);if(null===match)return null;return parse(match[2]+"."+(match[3]||"0")+"."+(match[4]||"0"),options)};},"./node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{const os=__webpack_require__("os"),tty=__webpack_require__("tty"),hasFlag=__webpack_require__("./node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js"),{env}=process;let forceColor;function translateLevel(level){return 0!==level&&{level,hasBasic:true,has256:level>=2,has16m:level>=3}}function supportsColor(haveStream,streamIsTTY){if(0===forceColor)return 0;if(hasFlag("color=16m")||hasFlag("color=full")||hasFlag("color=truecolor"))return 3;if(hasFlag("color=256"))return 2;if(haveStream&&!streamIsTTY&&void 0===forceColor)return 0;const min=forceColor||0;if("dumb"===env.TERM)return min;if("win32"===process.platform){const osRelease=os.release().split(".");return Number(osRelease[0])>=10&&Number(osRelease[2])>=10586?Number(osRelease[2])>=14931?3:2:1}if("CI"in env)return ["TRAVIS","CIRCLECI","APPVEYOR","GITLAB_CI","GITHUB_ACTIONS","BUILDKITE"].some((sign=>sign in env))||"codeship"===env.CI_NAME?1:min;if("TEAMCITY_VERSION"in env)return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION)?1:0;if("truecolor"===env.COLORTERM)return 3;if("TERM_PROGRAM"in env){const version=parseInt((env.TERM_PROGRAM_VERSION||"").split(".")[0],10);switch(env.TERM_PROGRAM){case "iTerm.app":return version>=3?3:2;case "Apple_Terminal":return 2}}return /-256(color)?$/i.test(env.TERM)?2:/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)||"COLORTERM"in env?1:min}hasFlag("no-color")||hasFlag("no-colors")||hasFlag("color=false")||hasFlag("color=never")?forceColor=0:(hasFlag("color")||hasFlag("colors")||hasFlag("color=true")||hasFlag("color=always"))&&(forceColor=1),"FORCE_COLOR"in env&&(forceColor="true"===env.FORCE_COLOR?1:"false"===env.FORCE_COLOR?0:0===env.FORCE_COLOR.length?1:Math.min(parseInt(env.FORCE_COLOR,10),3)),module.exports={supportsColor:function(stream){return translateLevel(supportsColor(stream,stream&&stream.isTTY))},stdout:translateLevel(supportsColor(true,tty.isatty(1))),stderr:translateLevel(supportsColor(true,tty.isatty(2)))};},assert:module=>{module.exports=require$$0$4;},fs:module=>{module.exports=require$$0$1;},module:module=>{module.exports=require$$2$3;},os:module=>{module.exports=require$$0;},path:module=>{module.exports=sysPath__default;},process:module=>{module.exports=require$$5$1;},tty:module=>{module.exports=require$$6$2;},url:module=>{module.exports=require$$7$1;},util:module=>{module.exports=require$$0$2;},v8:module=>{module.exports=require$$9$1;},"./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/caching.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _gensync(){const data=__webpack_require__("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");return _gensync=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:true}),exports.assertSimpleType=assertSimpleType,exports.makeStrongCache=makeStrongCache,exports.makeStrongCacheSync=function(handler){return synchronize(makeStrongCache(handler))},exports.makeWeakCache=makeWeakCache,exports.makeWeakCacheSync=function(handler){return synchronize(makeWeakCache(handler))};var _async=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/gensync-utils/async.js"),_util=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/util.js");const synchronize=gen=>_gensync()(gen).sync;function*genTrue(){return  true}function makeWeakCache(handler){return makeCachedFunction(WeakMap,handler)}function makeStrongCache(handler){return makeCachedFunction(Map,handler)}function makeCachedFunction(CallCache,handler){const callCacheSync=new CallCache,callCacheAsync=new CallCache,futureCache=new CallCache;return function*(arg,data){const asyncContext=yield*(0, _async.isAsync)(),callCache=asyncContext?callCacheAsync:callCacheSync,cached=yield*function*(asyncContext,callCache,futureCache,arg,data){const cached=yield*getCachedValue(callCache,arg,data);if(cached.valid)return cached;if(asyncContext){const cached=yield*getCachedValue(futureCache,arg,data);if(cached.valid){return {valid:true,value:yield*(0, _async.waitFor)(cached.value.promise)}}}return {valid:false,value:null}}(asyncContext,callCache,futureCache,arg,data);if(cached.valid)return cached.value;const cache=new CacheConfigurator(data),handlerResult=handler(arg,cache);let finishLock,value;return value=(0, _util.isIterableIterator)(handlerResult)?yield*(0, _async.onFirstPause)(handlerResult,(()=>{finishLock=function(config,futureCache,arg){const finishLock=new Lock;return updateFunctionCache(futureCache,config,arg,finishLock),finishLock}(cache,futureCache,arg);})):handlerResult,updateFunctionCache(callCache,cache,arg,value),finishLock&&(futureCache.delete(arg),finishLock.release(value)),value}}function*getCachedValue(cache,arg,data){const cachedValue=cache.get(arg);if(cachedValue)for(const{value,valid}of cachedValue)if(yield*valid(data))return {valid:true,value};return {valid:false,value:null}}function updateFunctionCache(cache,config,arg,value){config.configured()||config.forever();let cachedValue=cache.get(arg);switch(config.deactivate(),config.mode()){case "forever":cachedValue=[{value,valid:genTrue}],cache.set(arg,cachedValue);break;case "invalidate":cachedValue=[{value,valid:config.validator()}],cache.set(arg,cachedValue);break;case "valid":cachedValue?cachedValue.push({value,valid:config.validator()}):(cachedValue=[{value,valid:config.validator()}],cache.set(arg,cachedValue));}}class CacheConfigurator{constructor(data){this._active=true,this._never=false,this._forever=false,this._invalidate=false,this._configured=false,this._pairs=[],this._data=void 0,this._data=data;}simple(){return function(cache){function cacheFn(val){if("boolean"!=typeof val)return cache.using((()=>assertSimpleType(val())));val?cache.forever():cache.never();}return cacheFn.forever=()=>cache.forever(),cacheFn.never=()=>cache.never(),cacheFn.using=cb=>cache.using((()=>assertSimpleType(cb()))),cacheFn.invalidate=cb=>cache.invalidate((()=>assertSimpleType(cb()))),cacheFn}(this)}mode(){return this._never?"never":this._forever?"forever":this._invalidate?"invalidate":"valid"}forever(){if(!this._active)throw new Error("Cannot change caching after evaluation has completed.");if(this._never)throw new Error("Caching has already been configured with .never()");this._forever=true,this._configured=true;}never(){if(!this._active)throw new Error("Cannot change caching after evaluation has completed.");if(this._forever)throw new Error("Caching has already been configured with .forever()");this._never=true,this._configured=true;}using(handler){if(!this._active)throw new Error("Cannot change caching after evaluation has completed.");if(this._never||this._forever)throw new Error("Caching has already been configured with .never or .forever()");this._configured=true;const key=handler(this._data),fn=(0, _async.maybeAsync)(handler,"You appear to be using an async cache handler, but Babel has been called synchronously");return (0, _async.isThenable)(key)?key.then((key=>(this._pairs.push([key,fn]),key))):(this._pairs.push([key,fn]),key)}invalidate(handler){return this._invalidate=true,this.using(handler)}validator(){const pairs=this._pairs;return function*(data){for(const[key,fn]of pairs)if(key!==(yield*fn(data)))return  false;return  true}}deactivate(){this._active=false;}configured(){return this._configured}}function assertSimpleType(value){if((0, _async.isThenable)(value))throw new Error("You appear to be using an async cache handler, which your current version of Babel does not support. We may add support for this in the future, but if you're on the most recent version of @babel/core and still seeing this error, then you'll need to synchronously handle your caching logic.");if(null!=value&&"string"!=typeof value&&"boolean"!=typeof value&&"number"!=typeof value)throw new Error("Cache keys must be either string, boolean, number, null, or undefined.");return value}class Lock{constructor(){this.released=false,this.promise=void 0,this._resolve=void 0,this.promise=new Promise((resolve=>{this._resolve=resolve;}));}release(value){this.released=true,this._resolve(value);}}},"./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/config-chain.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _path(){const data=__webpack_require__("path");return _path=function(){return data},data}function _debug(){const data=__webpack_require__("./node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/index.js");return _debug=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:true}),exports.buildPresetChain=function*(arg,context){const chain=yield*buildPresetChainWalker(arg,context);return chain?{plugins:dedupDescriptors(chain.plugins),presets:dedupDescriptors(chain.presets),options:chain.options.map((o=>normalizeOptions(o))),files:new Set}:null},exports.buildPresetChainWalker=void 0,exports.buildRootChain=function*(opts,context){let configReport,babelRcReport;const programmaticLogger=new _printer.ConfigPrinter,programmaticChain=yield*loadProgrammaticChain({options:opts,dirname:context.cwd},context,void 0,programmaticLogger);if(!programmaticChain)return null;const programmaticReport=yield*programmaticLogger.output();let configFile;"string"==typeof opts.configFile?configFile=yield*(0, _index.loadConfig)(opts.configFile,context.cwd,context.envName,context.caller):false!==opts.configFile&&(configFile=yield*(0, _index.findRootConfig)(context.root,context.envName,context.caller));let{babelrc,babelrcRoots}=opts,babelrcRootsDirectory=context.cwd;const configFileChain=emptyChain(),configFileLogger=new _printer.ConfigPrinter;if(configFile){const validatedFile=validateConfigFile(configFile),result=yield*loadFileChain(validatedFile,context,void 0,configFileLogger);if(!result)return null;configReport=yield*configFileLogger.output(),void 0===babelrc&&(babelrc=validatedFile.options.babelrc),void 0===babelrcRoots&&(babelrcRootsDirectory=validatedFile.dirname,babelrcRoots=validatedFile.options.babelrcRoots),mergeChain(configFileChain,result);}let ignoreFile,babelrcFile,isIgnored=false;const fileChain=emptyChain();if((true===babelrc||void 0===babelrc)&&"string"==typeof context.filename){const pkgData=yield*(0, _index.findPackageData)(context.filename);if(pkgData&&function(context,pkgData,babelrcRoots,babelrcRootsDirectory){if("boolean"==typeof babelrcRoots)return babelrcRoots;const absoluteRoot=context.root;if(void 0===babelrcRoots)return pkgData.directories.includes(absoluteRoot);let babelrcPatterns=babelrcRoots;Array.isArray(babelrcPatterns)||(babelrcPatterns=[babelrcPatterns]);if(babelrcPatterns=babelrcPatterns.map((pat=>"string"==typeof pat?_path().resolve(babelrcRootsDirectory,pat):pat)),1===babelrcPatterns.length&&babelrcPatterns[0]===absoluteRoot)return pkgData.directories.includes(absoluteRoot);return babelrcPatterns.some((pat=>("string"==typeof pat&&(pat=(0, _patternToRegex.default)(pat,babelrcRootsDirectory)),pkgData.directories.some((directory=>matchPattern(pat,babelrcRootsDirectory,directory,context))))))}(context,pkgData,babelrcRoots,babelrcRootsDirectory)){if(({ignore:ignoreFile,config:babelrcFile}=yield*(0, _index.findRelativeConfig)(pkgData,context.envName,context.caller)),ignoreFile&&fileChain.files.add(ignoreFile.filepath),ignoreFile&&shouldIgnore(context,ignoreFile.ignore,null,ignoreFile.dirname)&&(isIgnored=true),babelrcFile&&!isIgnored){const validatedFile=validateBabelrcFile(babelrcFile),babelrcLogger=new _printer.ConfigPrinter,result=yield*loadFileChain(validatedFile,context,void 0,babelrcLogger);result?(babelRcReport=yield*babelrcLogger.output(),mergeChain(fileChain,result)):isIgnored=true;}babelrcFile&&isIgnored&&fileChain.files.add(babelrcFile.filepath);}}context.showConfig&&console.log(`Babel configs on "${context.filename}" (ascending priority):\n`+[configReport,babelRcReport,programmaticReport].filter((x=>!!x)).join("\n\n")+"\n-----End Babel configs-----");const chain=mergeChain(mergeChain(mergeChain(emptyChain(),configFileChain),fileChain),programmaticChain);return {plugins:isIgnored?[]:dedupDescriptors(chain.plugins),presets:isIgnored?[]:dedupDescriptors(chain.presets),options:isIgnored?[]:chain.options.map((o=>normalizeOptions(o))),fileHandling:isIgnored?"ignored":"transpile",ignore:ignoreFile||void 0,babelrc:babelrcFile||void 0,config:configFile||void 0,files:chain.files}};var _options=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/validation/options.js"),_patternToRegex=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/pattern-to-regex.js"),_printer=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/printer.js"),_rewriteStackTrace=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/errors/rewrite-stack-trace.js"),_configError=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/errors/config-error.js"),_index=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files/index.js"),_caching=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/caching.js"),_configDescriptors=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/config-descriptors.js");const debug=_debug()("babel:config:config-chain");const buildPresetChainWalker=exports.buildPresetChainWalker=makeChainWalker({root:preset=>loadPresetDescriptors(preset),env:(preset,envName)=>loadPresetEnvDescriptors(preset)(envName),overrides:(preset,index)=>loadPresetOverridesDescriptors(preset)(index),overridesEnv:(preset,index,envName)=>loadPresetOverridesEnvDescriptors(preset)(index)(envName),createLogger:()=>()=>{}}),loadPresetDescriptors=(0, _caching.makeWeakCacheSync)((preset=>buildRootDescriptors(preset,preset.alias,_configDescriptors.createUncachedDescriptors))),loadPresetEnvDescriptors=(0, _caching.makeWeakCacheSync)((preset=>(0, _caching.makeStrongCacheSync)((envName=>buildEnvDescriptors(preset,preset.alias,_configDescriptors.createUncachedDescriptors,envName))))),loadPresetOverridesDescriptors=(0, _caching.makeWeakCacheSync)((preset=>(0, _caching.makeStrongCacheSync)((index=>buildOverrideDescriptors(preset,preset.alias,_configDescriptors.createUncachedDescriptors,index))))),loadPresetOverridesEnvDescriptors=(0, _caching.makeWeakCacheSync)((preset=>(0, _caching.makeStrongCacheSync)((index=>(0, _caching.makeStrongCacheSync)((envName=>buildOverrideEnvDescriptors(preset,preset.alias,_configDescriptors.createUncachedDescriptors,index,envName)))))));const validateConfigFile=(0, _caching.makeWeakCacheSync)((file=>({filepath:file.filepath,dirname:file.dirname,options:(0, _options.validate)("configfile",file.options,file.filepath)}))),validateBabelrcFile=(0, _caching.makeWeakCacheSync)((file=>({filepath:file.filepath,dirname:file.dirname,options:(0, _options.validate)("babelrcfile",file.options,file.filepath)}))),validateExtendFile=(0, _caching.makeWeakCacheSync)((file=>({filepath:file.filepath,dirname:file.dirname,options:(0, _options.validate)("extendsfile",file.options,file.filepath)}))),loadProgrammaticChain=makeChainWalker({root:input=>buildRootDescriptors(input,"base",_configDescriptors.createCachedDescriptors),env:(input,envName)=>buildEnvDescriptors(input,"base",_configDescriptors.createCachedDescriptors,envName),overrides:(input,index)=>buildOverrideDescriptors(input,"base",_configDescriptors.createCachedDescriptors,index),overridesEnv:(input,index,envName)=>buildOverrideEnvDescriptors(input,"base",_configDescriptors.createCachedDescriptors,index,envName),createLogger:(input,context,baseLogger)=>function(_,context,baseLogger){var _context$caller;if(!baseLogger)return ()=>{};return baseLogger.configure(context.showConfig,_printer.ChainFormatter.Programmatic,{callerName:null==(_context$caller=context.caller)?void 0:_context$caller.name})}(0,context,baseLogger)}),loadFileChainWalker=makeChainWalker({root:file=>loadFileDescriptors(file),env:(file,envName)=>loadFileEnvDescriptors(file)(envName),overrides:(file,index)=>loadFileOverridesDescriptors(file)(index),overridesEnv:(file,index,envName)=>loadFileOverridesEnvDescriptors(file)(index)(envName),createLogger:(file,context,baseLogger)=>function(filepath,context,baseLogger){if(!baseLogger)return ()=>{};return baseLogger.configure(context.showConfig,_printer.ChainFormatter.Config,{filepath})}(file.filepath,context,baseLogger)});function*loadFileChain(input,context,files,baseLogger){const chain=yield*loadFileChainWalker(input,context,files,baseLogger);return null==chain||chain.files.add(input.filepath),chain}const loadFileDescriptors=(0, _caching.makeWeakCacheSync)((file=>buildRootDescriptors(file,file.filepath,_configDescriptors.createUncachedDescriptors))),loadFileEnvDescriptors=(0, _caching.makeWeakCacheSync)((file=>(0, _caching.makeStrongCacheSync)((envName=>buildEnvDescriptors(file,file.filepath,_configDescriptors.createUncachedDescriptors,envName))))),loadFileOverridesDescriptors=(0, _caching.makeWeakCacheSync)((file=>(0, _caching.makeStrongCacheSync)((index=>buildOverrideDescriptors(file,file.filepath,_configDescriptors.createUncachedDescriptors,index))))),loadFileOverridesEnvDescriptors=(0, _caching.makeWeakCacheSync)((file=>(0, _caching.makeStrongCacheSync)((index=>(0, _caching.makeStrongCacheSync)((envName=>buildOverrideEnvDescriptors(file,file.filepath,_configDescriptors.createUncachedDescriptors,index,envName)))))));function buildRootDescriptors({dirname,options},alias,descriptors){return descriptors(dirname,options,alias)}function buildEnvDescriptors({dirname,options},alias,descriptors,envName){var _options$env;const opts=null==(_options$env=options.env)?void 0:_options$env[envName];return opts?descriptors(dirname,opts,`${alias}.env["${envName}"]`):null}function buildOverrideDescriptors({dirname,options},alias,descriptors,index){var _options$overrides;const opts=null==(_options$overrides=options.overrides)?void 0:_options$overrides[index];if(!opts)throw new Error("Assertion failure - missing override");return descriptors(dirname,opts,`${alias}.overrides[${index}]`)}function buildOverrideEnvDescriptors({dirname,options},alias,descriptors,index,envName){var _options$overrides2,_override$env;const override=null==(_options$overrides2=options.overrides)?void 0:_options$overrides2[index];if(!override)throw new Error("Assertion failure - missing override");const opts=null==(_override$env=override.env)?void 0:_override$env[envName];return opts?descriptors(dirname,opts,`${alias}.overrides[${index}].env["${envName}"]`):null}function makeChainWalker({root,env,overrides,overridesEnv,createLogger}){return function*(input,context,files=new Set,baseLogger){const{dirname}=input,flattenedConfigs=[],rootOpts=root(input);if(configIsApplicable(rootOpts,dirname,context,input.filepath)){flattenedConfigs.push({config:rootOpts,envName:void 0,index:void 0});const envOpts=env(input,context.envName);envOpts&&configIsApplicable(envOpts,dirname,context,input.filepath)&&flattenedConfigs.push({config:envOpts,envName:context.envName,index:void 0}),(rootOpts.options.overrides||[]).forEach(((_,index)=>{const overrideOps=overrides(input,index);if(configIsApplicable(overrideOps,dirname,context,input.filepath)){flattenedConfigs.push({config:overrideOps,index,envName:void 0});const overrideEnvOpts=overridesEnv(input,index,context.envName);overrideEnvOpts&&configIsApplicable(overrideEnvOpts,dirname,context,input.filepath)&&flattenedConfigs.push({config:overrideEnvOpts,index,envName:context.envName});}}));}if(flattenedConfigs.some((({config:{options:{ignore,only}}})=>shouldIgnore(context,ignore,only,dirname))))return null;const chain=emptyChain(),logger=createLogger(input,context,baseLogger);for(const{config,index,envName}of flattenedConfigs){if(!(yield*mergeExtendsChain(chain,config.options,dirname,context,files,baseLogger)))return null;logger(config,index,envName),yield*mergeChainOpts(chain,config);}return chain}}function*mergeExtendsChain(chain,opts,dirname,context,files,baseLogger){if(void 0===opts.extends)return  true;const file=yield*(0, _index.loadConfig)(opts.extends,dirname,context.envName,context.caller);if(files.has(file))throw new Error(`Configuration cycle detected loading ${file.filepath}.\nFile already loaded following the config chain:\n`+Array.from(files,(file=>` - ${file.filepath}`)).join("\n"));files.add(file);const fileChain=yield*loadFileChain(validateExtendFile(file),context,files,baseLogger);return files.delete(file),!!fileChain&&(mergeChain(chain,fileChain),true)}function mergeChain(target,source){target.options.push(...source.options),target.plugins.push(...source.plugins),target.presets.push(...source.presets);for(const file of source.files)target.files.add(file);return target}function*mergeChainOpts(target,{options,plugins,presets}){return target.options.push(options),target.plugins.push(...yield*plugins()),target.presets.push(...yield*presets()),target}function emptyChain(){return {options:[],presets:[],plugins:[],files:new Set}}function normalizeOptions(opts){const options=Object.assign({},opts);return delete options.extends,delete options.env,delete options.overrides,delete options.plugins,delete options.presets,delete options.passPerPreset,delete options.ignore,delete options.only,delete options.test,delete options.include,delete options.exclude,hasOwnProperty.call(options,"sourceMap")&&(options.sourceMaps=options.sourceMap,delete options.sourceMap),options}function dedupDescriptors(items){const map=new Map,descriptors=[];for(const item of items)if("function"==typeof item.value){const fnKey=item.value;let nameMap=map.get(fnKey);nameMap||(nameMap=new Map,map.set(fnKey,nameMap));let desc=nameMap.get(item.name);desc?desc.value=item:(desc={value:item},descriptors.push(desc),item.ownPass||nameMap.set(item.name,desc));}else descriptors.push({value:item});return descriptors.reduce(((acc,desc)=>(acc.push(desc.value),acc)),[])}function configIsApplicable({options},dirname,context,configName){return (void 0===options.test||configFieldIsApplicable(context,options.test,dirname,configName))&&(void 0===options.include||configFieldIsApplicable(context,options.include,dirname,configName))&&(void 0===options.exclude||!configFieldIsApplicable(context,options.exclude,dirname,configName))}function configFieldIsApplicable(context,test,dirname,configName){return matchesPatterns(context,Array.isArray(test)?test:[test],dirname,configName)}function ignoreListReplacer(_key,value){return value instanceof RegExp?String(value):value}function shouldIgnore(context,ignore,only,dirname){if(ignore&&matchesPatterns(context,ignore,dirname)){var _context$filename;const message=`No config is applied to "${null!=(_context$filename=context.filename)?_context$filename:"(unknown)"}" because it matches one of \`ignore: ${JSON.stringify(ignore,ignoreListReplacer)}\` from "${dirname}"`;return debug(message),context.showConfig&&console.log(message),true}if(only&&!matchesPatterns(context,only,dirname)){var _context$filename2;const message=`No config is applied to "${null!=(_context$filename2=context.filename)?_context$filename2:"(unknown)"}" because it fails to match one of \`only: ${JSON.stringify(only,ignoreListReplacer)}\` from "${dirname}"`;return debug(message),context.showConfig&&console.log(message),true}return  false}function matchesPatterns(context,patterns,dirname,configName){return patterns.some((pattern=>matchPattern(pattern,dirname,context.filename,context,configName)))}function matchPattern(pattern,dirname,pathToTest,context,configName){if("function"==typeof pattern)return !!(0, _rewriteStackTrace.endHiddenCallStack)(pattern)(pathToTest,{dirname,envName:context.envName,caller:context.caller});if("string"!=typeof pathToTest)throw new _configError.default("Configuration contains string/RegExp pattern, but no filename was passed to Babel",configName);return "string"==typeof pattern&&(pattern=(0, _patternToRegex.default)(pattern,dirname)),pattern.test(pathToTest)}},"./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/config-descriptors.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _gensync(){const data=__webpack_require__("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");return _gensync=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:true}),exports.createCachedDescriptors=function(dirname,options,alias){const{plugins,presets,passPerPreset}=options;return {options:optionsWithResolvedBrowserslistConfigFile(options,dirname),plugins:plugins?()=>createCachedPluginDescriptors(plugins,dirname)(alias):()=>handlerOf([]),presets:presets?()=>createCachedPresetDescriptors(presets,dirname)(alias)(!!passPerPreset):()=>handlerOf([])}},exports.createDescriptor=createDescriptor,exports.createUncachedDescriptors=function(dirname,options,alias){return {options:optionsWithResolvedBrowserslistConfigFile(options,dirname),plugins:(0, _functional.once)((()=>createPluginDescriptors(options.plugins||[],dirname,alias))),presets:(0, _functional.once)((()=>createPresetDescriptors(options.presets||[],dirname,alias,!!options.passPerPreset)))}};var _functional=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/gensync-utils/functional.js"),_index=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files/index.js"),_item=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/item.js"),_caching=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/caching.js"),_resolveTargets=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/resolve-targets.js");function*handlerOf(value){return value}function optionsWithResolvedBrowserslistConfigFile(options,dirname){return "string"==typeof options.browserslistConfigFile&&(options.browserslistConfigFile=(0, _resolveTargets.resolveBrowserslistConfigFile)(options.browserslistConfigFile,dirname)),options}const PRESET_DESCRIPTOR_CACHE=new WeakMap,createCachedPresetDescriptors=(0, _caching.makeWeakCacheSync)(((items,cache)=>{const dirname=cache.using((dir=>dir));return (0, _caching.makeStrongCacheSync)((alias=>(0, _caching.makeStrongCache)((function*(passPerPreset){return (yield*createPresetDescriptors(items,dirname,alias,passPerPreset)).map((desc=>loadCachedDescriptor(PRESET_DESCRIPTOR_CACHE,desc)))}))))})),PLUGIN_DESCRIPTOR_CACHE=new WeakMap,createCachedPluginDescriptors=(0, _caching.makeWeakCacheSync)(((items,cache)=>{const dirname=cache.using((dir=>dir));return (0, _caching.makeStrongCache)((function*(alias){return (yield*createPluginDescriptors(items,dirname,alias)).map((desc=>loadCachedDescriptor(PLUGIN_DESCRIPTOR_CACHE,desc)))}))})),DEFAULT_OPTIONS={};function loadCachedDescriptor(cache,desc){const{value,options=DEFAULT_OPTIONS}=desc;if(false===options)return desc;let cacheByOptions=cache.get(value);cacheByOptions||(cacheByOptions=new WeakMap,cache.set(value,cacheByOptions));let possibilities=cacheByOptions.get(options);if(possibilities||(possibilities=[],cacheByOptions.set(options,possibilities)),!possibilities.includes(desc)){const matches=possibilities.filter((possibility=>{return b=desc,(a=possibility).name===b.name&&a.value===b.value&&a.options===b.options&&a.dirname===b.dirname&&a.alias===b.alias&&a.ownPass===b.ownPass&&(null==(_a$file=a.file)?void 0:_a$file.request)===(null==(_b$file=b.file)?void 0:_b$file.request)&&(null==(_a$file2=a.file)?void 0:_a$file2.resolved)===(null==(_b$file2=b.file)?void 0:_b$file2.resolved);var a,b,_a$file,_b$file,_a$file2,_b$file2;}));if(matches.length>0)return matches[0];possibilities.push(desc);}return desc}function*createPresetDescriptors(items,dirname,alias,passPerPreset){return yield*createDescriptors("preset",items,dirname,alias,passPerPreset)}function*createPluginDescriptors(items,dirname,alias){return yield*createDescriptors("plugin",items,dirname,alias)}function*createDescriptors(type,items,dirname,alias,ownPass){const descriptors=yield*_gensync().all(items.map(((item,index)=>createDescriptor(item,dirname,{type,alias:`${alias}$${index}`,ownPass:!!ownPass}))));return function(items){const map=new Map;for(const item of items){if("function"!=typeof item.value)continue;let nameMap=map.get(item.value);if(nameMap||(nameMap=new Set,map.set(item.value,nameMap)),nameMap.has(item.name)){const conflicts=items.filter((i=>i.value===item.value));throw new Error(["Duplicate plugin/preset detected.","If you'd like to use two separate instances of a plugin,","they need separate names, e.g.","","  plugins: [","    ['some-plugin', {}],","    ['some-plugin', {}, 'some unique name'],","  ]","","Duplicates detected are:",`${JSON.stringify(conflicts,null,2)}`].join("\n"))}nameMap.add(item.name);}}(descriptors),descriptors}function*createDescriptor(pair,dirname,{type,alias,ownPass}){const desc=(0, _item.getItemDescriptor)(pair);if(desc)return desc;let name,options,file,value=pair;Array.isArray(value)&&(3===value.length?[value,options,name]=value:[value,options]=value);let filepath=null;if("string"==typeof value){if("string"!=typeof type)throw new Error("To resolve a string-based item, the type of item must be given");const resolver="plugin"===type?_index.loadPlugin:_index.loadPreset,request=value;(({filepath,value}=yield*resolver(value,dirname))),file={request,resolved:filepath};}if(!value)throw new Error(`Unexpected falsy value: ${String(value)}`);if("object"==typeof value&&value.__esModule){if(!value.default)throw new Error("Must export a default export when using ES6 modules.");value=value.default;}if("object"!=typeof value&&"function"!=typeof value)throw new Error(`Unsupported format: ${typeof value}. Expected an object or a function.`);if(null!==filepath&&"object"==typeof value&&value)throw new Error(`Plugin/Preset files are not allowed to export objects, only functions. In ${filepath}`);return {name,alias:filepath||alias,value,options,dirname,ownPass,file}}},"./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files/configuration.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _debug(){const data=__webpack_require__("./node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/index.js");return _debug=function(){return data},data}function _fs(){const data=__webpack_require__("fs");return _fs=function(){return data},data}function _path(){const data=__webpack_require__("path");return _path=function(){return data},data}function _json(){const data=__webpack_require__("./node_modules/.pnpm/json5@2.2.3/node_modules/json5/dist/index.mjs");return _json=function(){return data},data}function _gensync(){const data=__webpack_require__("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");return _gensync=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:true}),exports.ROOT_CONFIG_FILENAMES=void 0,exports.findConfigUpwards=function(rootDir){let dirname=rootDir;for(;;){for(const filename of ROOT_CONFIG_FILENAMES)if(_fs().existsSync(_path().join(dirname,filename)))return dirname;const nextDir=_path().dirname(dirname);if(dirname===nextDir)break;dirname=nextDir;}return null},exports.findRelativeConfig=function*(packageData,envName,caller){let config=null,ignore=null;const dirname=_path().dirname(packageData.filepath);for(const loc of packageData.directories){var _packageData$pkg;if(!config)config=yield*loadOneConfig(RELATIVE_CONFIG_FILENAMES,loc,envName,caller,(null==(_packageData$pkg=packageData.pkg)?void 0:_packageData$pkg.dirname)===loc?packageToBabelConfig(packageData.pkg):null);if(!ignore){const ignoreLoc=_path().join(loc,BABELIGNORE_FILENAME);ignore=yield*readIgnoreConfig(ignoreLoc),ignore&&debug("Found ignore %o from %o.",ignore.filepath,dirname);}}return {config,ignore}},exports.findRootConfig=function(dirname,envName,caller){return loadOneConfig(ROOT_CONFIG_FILENAMES,dirname,envName,caller)},exports.loadConfig=function*(name,dirname,envName,caller){const filepath=(v=process.versions.node,w="8.9",v=v.split("."),w=w.split("."),+v[0]>+w[0]||v[0]==w[0]&&+v[1]>=+w[1]?__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files sync recursive").resolve:(r,{paths:[b]},M=__webpack_require__("module"))=>{let f=M._findPath(r,M._nodeModulePaths(b).concat(b));if(f)return f;throw f=new Error(`Cannot resolve module '${r}'`),f.code="MODULE_NOT_FOUND",f})(name,{paths:[dirname]}),conf=yield*readConfig(filepath,envName,caller);var v,w;if(!conf)throw new _configError.default("Config file contains no configuration data",filepath);return debug("Loaded config %o from %o.",name,dirname),conf},exports.resolveShowConfigPath=function*(dirname){const targetPath=process.env.BABEL_SHOW_CONFIG_FOR;if(null!=targetPath){const absolutePath=_path().resolve(dirname,targetPath);if(!(yield*fs.stat(absolutePath)).isFile())throw new Error(`${absolutePath}: BABEL_SHOW_CONFIG_FOR must refer to a regular file, directories are not supported.`);return absolutePath}return null};var _caching=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/caching.js"),_configApi=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/helpers/config-api.js"),_utils=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files/utils.js"),_moduleTypes=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files/module-types.js"),_patternToRegex=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/pattern-to-regex.js"),_configError=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/errors/config-error.js"),fs=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/gensync-utils/fs.js"),_rewriteStackTrace=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/errors/rewrite-stack-trace.js"),_async=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/gensync-utils/async.js");const debug=_debug()("babel:config:loading:files:configuration"),ROOT_CONFIG_FILENAMES=exports.ROOT_CONFIG_FILENAMES=["babel.config.js","babel.config.cjs","babel.config.mjs","babel.config.json","babel.config.cts"],RELATIVE_CONFIG_FILENAMES=[".babelrc",".babelrc.js",".babelrc.cjs",".babelrc.mjs",".babelrc.json",".babelrc.cts"],BABELIGNORE_FILENAME=".babelignore",runConfig=(0, _caching.makeWeakCache)((function*(options,cache){return yield*[],{options:(0, _rewriteStackTrace.endHiddenCallStack)(options)((0, _configApi.makeConfigAPI)(cache)),cacheNeedsConfiguration:!cache.configured()}}));function*readConfigCode(filepath,data){if(!_fs().existsSync(filepath))return null;let options=yield*(0, _moduleTypes.default)(filepath,(yield*(0, _async.isAsync)())?"auto":"require","You appear to be using a native ECMAScript module configuration file, which is only supported when running Babel asynchronously or when using the Node.js `--experimental-require-module` flag.","You appear to be using a configuration file that contains top-level await, which is only supported when running Babel asynchronously."),cacheNeedsConfiguration=false;if("function"==typeof options&&({options,cacheNeedsConfiguration}=yield*runConfig(options,data)),!options||"object"!=typeof options||Array.isArray(options))throw new _configError.default("Configuration should be an exported JavaScript object.",filepath);if("function"==typeof options.then)throw null==options.catch||options.catch((()=>{})),new _configError.default("You appear to be using an async configuration, which your current version of Babel does not support. We may add support for this in the future, but if you're on the most recent version of @babel/core and still seeing this error, then you'll need to synchronously return your config.",filepath);return cacheNeedsConfiguration&&function(filepath){throw new _configError.default('Caching was left unconfigured. Babel\'s plugins, presets, and .babelrc.js files can be configured\nfor various types of caching, using the first param of their handler functions:\n\nmodule.exports = function(api) {\n  // The API exposes the following:\n\n  // Cache the returned value forever and don\'t call this function again.\n  api.cache(true);\n\n  // Don\'t cache at all. Not recommended because it will be very slow.\n  api.cache(false);\n\n  // Cached based on the value of some function. If this function returns a value different from\n  // a previously-encountered value, the plugins will re-evaluate.\n  var env = api.cache(() => process.env.NODE_ENV);\n\n  // If testing for a specific env, we recommend specifics to avoid instantiating a plugin for\n  // any possible NODE_ENV value that might come up during plugin execution.\n  var isProd = api.cache(() => process.env.NODE_ENV === "production");\n\n  // .cache(fn) will perform a linear search though instances to find the matching plugin based\n  // based on previous instantiated plugins. If you want to recreate the plugin and discard the\n  // previous instance whenever something changes, you may use:\n  var isProd = api.cache.invalidate(() => process.env.NODE_ENV === "production");\n\n  // Note, we also expose the following more-verbose versions of the above examples:\n  api.cache.forever(); // api.cache(true)\n  api.cache.never();   // api.cache(false)\n  api.cache.using(fn); // api.cache(fn)\n\n  // Return the value that will be cached.\n  return { };\n};',filepath)}(filepath),function(options,filepath){let configFilesByFilepath=cfboaf.get(options);configFilesByFilepath||cfboaf.set(options,configFilesByFilepath=new Map);let configFile=configFilesByFilepath.get(filepath);configFile||(configFile={filepath,dirname:_path().dirname(filepath),options},configFilesByFilepath.set(filepath,configFile));return configFile}(options,filepath)}const cfboaf=new WeakMap;const packageToBabelConfig=(0, _caching.makeWeakCacheSync)((file=>{const babel=file.options.babel;if(void 0===babel)return null;if("object"!=typeof babel||Array.isArray(babel)||null===babel)throw new _configError.default(".babel property must be an object",file.filepath);return {filepath:file.filepath,dirname:file.dirname,options:babel}})),readConfigJSON5=(0, _utils.makeStaticFileCache)(((filepath,content)=>{let options;try{options=_json().parse(content);}catch(err){throw new _configError.default(`Error while parsing config - ${err.message}`,filepath)}if(!options)throw new _configError.default("No config detected",filepath);if("object"!=typeof options)throw new _configError.default("Config returned typeof "+typeof options,filepath);if(Array.isArray(options))throw new _configError.default("Expected config object but found array",filepath);return delete options.$schema,{filepath,dirname:_path().dirname(filepath),options}})),readIgnoreConfig=(0, _utils.makeStaticFileCache)(((filepath,content)=>{const ignoreDir=_path().dirname(filepath),ignorePatterns=content.split("\n").map((line=>line.replace(/#.*$/,"").trim())).filter(Boolean);for(const pattern of ignorePatterns)if("!"===pattern[0])throw new _configError.default("Negation of file paths is not supported.",filepath);return {filepath,dirname:_path().dirname(filepath),ignore:ignorePatterns.map((pattern=>(0, _patternToRegex.default)(pattern,ignoreDir)))}}));function*loadOneConfig(names,dirname,envName,caller,previousConfig=null){const config=(yield*_gensync().all(names.map((filename=>readConfig(_path().join(dirname,filename),envName,caller))))).reduce(((previousConfig,config)=>{if(config&&previousConfig)throw new _configError.default(`Multiple configuration files found. Please remove one:\n - ${_path().basename(previousConfig.filepath)}\n - ${config.filepath}\nfrom ${dirname}`);return config||previousConfig}),previousConfig);return config&&debug("Found configuration %o from %o.",config.filepath,dirname),config}function readConfig(filepath,envName,caller){switch(_path().extname(filepath)){case ".js":case ".cjs":case ".mjs":case ".cts":return readConfigCode(filepath,{envName,caller});default:return readConfigJSON5(filepath)}}},"./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files/import.cjs":(module,__unused_webpack_exports,__webpack_require__)=>{module.exports=function(filepath){return __webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files lazy recursive")(filepath)};},"./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),Object.defineProperty(exports,"ROOT_CONFIG_FILENAMES",{enumerable:true,get:function(){return _configuration.ROOT_CONFIG_FILENAMES}}),Object.defineProperty(exports,"findConfigUpwards",{enumerable:true,get:function(){return _configuration.findConfigUpwards}}),Object.defineProperty(exports,"findPackageData",{enumerable:true,get:function(){return _package.findPackageData}}),Object.defineProperty(exports,"findRelativeConfig",{enumerable:true,get:function(){return _configuration.findRelativeConfig}}),Object.defineProperty(exports,"findRootConfig",{enumerable:true,get:function(){return _configuration.findRootConfig}}),Object.defineProperty(exports,"loadConfig",{enumerable:true,get:function(){return _configuration.loadConfig}}),Object.defineProperty(exports,"loadPlugin",{enumerable:true,get:function(){return _plugins.loadPlugin}}),Object.defineProperty(exports,"loadPreset",{enumerable:true,get:function(){return _plugins.loadPreset}}),Object.defineProperty(exports,"resolvePlugin",{enumerable:true,get:function(){return _plugins.resolvePlugin}}),Object.defineProperty(exports,"resolvePreset",{enumerable:true,get:function(){return _plugins.resolvePreset}}),Object.defineProperty(exports,"resolveShowConfigPath",{enumerable:true,get:function(){return _configuration.resolveShowConfigPath}});var _package=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files/package.js"),_configuration=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files/configuration.js"),_plugins=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files/plugins.js");},"./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files/module-types.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function*(filepath,loader,esmError,tlaError){var _async2;let async,ext=_path().extname(filepath);SUPPORTED_EXTENSIONS.has(ext)||(ext=".js");switch(`${loader} ${ext}`){case "require .cjs":case "auto .cjs":return loadCjsDefault(filepath,arguments[2]);case "require .cts":case "auto .cts":return function(filepath){const ext=".cts",hasTsSupport=!!(__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files sync recursive").extensions[".ts"]||__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files sync recursive").extensions[".cts"]||__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files sync recursive").extensions[".mts"]);let handler;if(!hasTsSupport){const opts={babelrc:false,configFile:false,sourceType:"unambiguous",sourceMaps:"inline",sourceFileName:_path().basename(filepath),presets:[[getTSPreset(filepath),Object.assign({onlyRemoveTypeImports:true,optimizeConstEnums:true},{allowDeclareFields:true})]]};handler=function(m,filename){if(handler&&filename.endsWith(ext))try{return m._compile((0,_transformFile.transformFileSync)(filename,Object.assign({},opts,{filename})).code,filename)}catch(error){if(!hasTsSupport){const packageJson=__webpack_require__("./node_modules/.pnpm/@babel+preset-typescript@7.26.0_@babel+core@7.26.0/node_modules/@babel/preset-typescript/package.json");_semver().lt(packageJson.version,"7.21.4")&&console.error("`.cts` configuration file failed to load, please try to update `@babel/preset-typescript`.");}throw error}return __webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files sync recursive").extensions[".js"](m,filename)},__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files sync recursive").extensions[ext]=handler;}try{return loadCjsDefault(filepath)}finally{hasTsSupport||(__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files sync recursive").extensions[ext]===handler&&delete __webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files sync recursive").extensions[ext],handler=void 0);}}(filepath);case "auto .js":case "require .js":case "require .mjs":try{return loadCjsDefault(filepath,arguments[2])}catch(e){var _async;if("ERR_REQUIRE_ASYNC_MODULE"===e.code||"ERR_REQUIRE_CYCLE_MODULE"===e.code&&asyncModules.has(filepath)){if(asyncModules.add(filepath),!(null!=(_async=async)?_async:async=yield*(0, _async3.isAsync)()))throw new _configError.default(tlaError,filepath)}else if("ERR_REQUIRE_ESM"!==e.code&&".mjs"!==ext)throw e}case "auto .mjs":if(null!=(_async2=async)?_async2:async=yield*(0, _async3.isAsync)())return (yield*(0, _async3.waitFor)(loadMjsFromPath(filepath))).default;throw new _configError.default(esmError,filepath);default:throw new Error("Internal Babel error: unreachable code.")}},exports.supportsESM=void 0;var _async3=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/gensync-utils/async.js");function _path(){const data=__webpack_require__("path");return _path=function(){return data},data}function _url(){const data=__webpack_require__("url");return _url=function(){return data},data}function _semver(){const data=__webpack_require__("./node_modules/.pnpm/semver@6.3.1/node_modules/semver/semver.js");return _semver=function(){return data},data}function _debug(){const data=__webpack_require__("./node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/index.js");return _debug=function(){return data},data}var _rewriteStackTrace=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/errors/rewrite-stack-trace.js"),_configError=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/errors/config-error.js"),_transformFile=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transform-file.js");function asyncGeneratorStep(n,t,e,r,o,a,c){try{var i=n[a](c),u=i.value;}catch(n){return void e(n)}i.done?t(u):Promise.resolve(u).then(r,o);}const debug=_debug()("babel:config:loading:files:module-types");try{var import_=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files/import.cjs");}catch(_unused){}exports.supportsESM=_semver().satisfies(process.versions.node,"^12.17 || >=13.2");const LOADING_CJS_FILES=new Set;function loadCjsDefault(filepath){if(LOADING_CJS_FILES.has(filepath))return debug("Auto-ignoring usage of config %o.",filepath),{};let module;try{LOADING_CJS_FILES.add(filepath),module=(0,_rewriteStackTrace.endHiddenCallStack)(__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files sync recursive"))(filepath);}finally{LOADING_CJS_FILES.delete(filepath);}return null==module||!module.__esModule&&"Module"!==module[Symbol.toStringTag]?module:module.default||(arguments[1]?module:void 0)}const loadMjsFromPath=(0, _rewriteStackTrace.endHiddenCallStack)((n=function*(filepath){const url=(0, _url().pathToFileURL)(filepath).toString()+"?import";if(!import_)throw new _configError.default("Internal error: Native ECMAScript modules aren't supported by this platform.\n",filepath);return yield import_(url)},_loadMjsFromPath=function(){var t=this,e=arguments;return new Promise((function(r,o){var a=n.apply(t,e);function _next(n){asyncGeneratorStep(a,r,o,_next,_throw,"next",n);}function _throw(n){asyncGeneratorStep(a,r,o,_next,_throw,"throw",n);}_next(void 0);}))},function(_x){return _loadMjsFromPath.apply(this,arguments)}));var n,_loadMjsFromPath;const SUPPORTED_EXTENSIONS=new Set([".js",".mjs",".cjs",".cts"]),asyncModules=new Set;function getTSPreset(filepath){try{return __webpack_require__("./node_modules/.pnpm/@babel+preset-typescript@7.26.0_@babel+core@7.26.0/node_modules/@babel/preset-typescript/lib/index.js")}catch(error){if("MODULE_NOT_FOUND"!==error.code)throw error;let message="You appear to be using a .cts file as Babel configuration, but the `@babel/preset-typescript` package was not found: please install it!";throw process.versions.pnp&&(message+='\nIf you are using Yarn Plug\'n\'Play, you may also need to add the following configuration to your .yarnrc.yml file:\n\npackageExtensions:\n\t"@babel/core@*":\n\t\tpeerDependencies:\n\t\t\t"@babel/preset-typescript": "*"\n'),new _configError.default(message,filepath)}}},"./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files/package.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _path(){const data=__webpack_require__("path");return _path=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:true}),exports.findPackageData=function*(filepath){let pkg=null;const directories=[];let isPackage=true,dirname=_path().dirname(filepath);for(;!pkg&&"node_modules"!==_path().basename(dirname);){directories.push(dirname),pkg=yield*readConfigPackage(_path().join(dirname,PACKAGE_FILENAME));const nextLoc=_path().dirname(dirname);if(dirname===nextLoc){isPackage=false;break}dirname=nextLoc;}return {filepath,directories,pkg,isPackage}};var _utils=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files/utils.js"),_configError=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/errors/config-error.js");const PACKAGE_FILENAME="package.json",readConfigPackage=(0, _utils.makeStaticFileCache)(((filepath,content)=>{let options;try{options=JSON.parse(content);}catch(err){throw new _configError.default(`Error while parsing JSON - ${err.message}`,filepath)}if(!options)throw new Error(`${filepath}: No config detected`);if("object"!=typeof options)throw new _configError.default("Config returned typeof "+typeof options,filepath);if(Array.isArray(options))throw new _configError.default("Expected config object but found array",filepath);return {filepath,dirname:_path().dirname(filepath),options}}));},"./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files/plugins.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _debug(){const data=__webpack_require__("./node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/index.js");return _debug=function(){return data},data}function _path(){const data=__webpack_require__("path");return _path=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:true}),exports.loadPlugin=function*(name,dirname){const{filepath,loader}=resolvePlugin(name,dirname,yield*(0, _async.isAsync)()),value=yield*requireModule("plugin",loader,filepath);return debug("Loaded plugin %o from %o.",name,dirname),{filepath,value}},exports.loadPreset=function*(name,dirname){const{filepath,loader}=resolvePreset(name,dirname,yield*(0, _async.isAsync)()),value=yield*requireModule("preset",loader,filepath);return debug("Loaded preset %o from %o.",name,dirname),{filepath,value}},exports.resolvePreset=exports.resolvePlugin=void 0;var _async=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/gensync-utils/async.js"),_moduleTypes=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files/module-types.js");function _url(){const data=__webpack_require__("url");return _url=function(){return data},data}var _importMetaResolve=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/vendor/import-meta-resolve.js");function _fs(){const data=__webpack_require__("fs");return _fs=function(){return data},data}const debug=_debug()("babel:config:loading:files:plugins"),EXACT_RE=/^module:/,BABEL_PLUGIN_PREFIX_RE=/^(?!@|module:|[^/]+\/|babel-plugin-)/,BABEL_PRESET_PREFIX_RE=/^(?!@|module:|[^/]+\/|babel-preset-)/,BABEL_PLUGIN_ORG_RE=/^(@babel\/)(?!plugin-|[^/]+\/)/,BABEL_PRESET_ORG_RE=/^(@babel\/)(?!preset-|[^/]+\/)/,OTHER_PLUGIN_ORG_RE=/^(@(?!babel\/)[^/]+\/)(?![^/]*babel-plugin(?:-|\/|$)|[^/]+\/)/,OTHER_PRESET_ORG_RE=/^(@(?!babel\/)[^/]+\/)(?![^/]*babel-preset(?:-|\/|$)|[^/]+\/)/,OTHER_ORG_DEFAULT_RE=/^(@(?!babel$)[^/]+)$/,resolvePlugin=exports.resolvePlugin=resolveStandardizedName.bind(null,"plugin"),resolvePreset=exports.resolvePreset=resolveStandardizedName.bind(null,"preset");function standardizeName(type,name){if(_path().isAbsolute(name))return name;const isPreset="preset"===type;return name.replace(isPreset?BABEL_PRESET_PREFIX_RE:BABEL_PLUGIN_PREFIX_RE,`babel-${type}-`).replace(isPreset?BABEL_PRESET_ORG_RE:BABEL_PLUGIN_ORG_RE,`$1${type}-`).replace(isPreset?OTHER_PRESET_ORG_RE:OTHER_PLUGIN_ORG_RE,`$1babel-${type}-`).replace(OTHER_ORG_DEFAULT_RE,`$1/babel-${type}`).replace(EXACT_RE,"")}function*resolveAlternativesHelper(type,name){const standardizedName=standardizeName(type,name),{error,value}=yield standardizedName;if(!error)return value;if("MODULE_NOT_FOUND"!==error.code)throw error;standardizedName===name||(yield name).error||(error.message+=`\n- If you want to resolve "${name}", use "module:${name}"`),(yield standardizeName(type,"@babel/"+name)).error||(error.message+=`\n- Did you mean "@babel/${name}"?`);const oppositeType="preset"===type?"plugin":"preset";if((yield standardizeName(oppositeType,name)).error||(error.message+=`\n- Did you accidentally pass a ${oppositeType} as a ${type}?`),"plugin"===type){const transformName=standardizedName.replace("-proposal-","-transform-");transformName===standardizedName||(yield transformName).error||(error.message+=`\n- Did you mean "${transformName}"?`);}throw error.message+="\n\nMake sure that all the Babel plugins and presets you are using\nare defined as dependencies or devDependencies in your package.json\nfile. It's possible that the missing plugin is loaded by a preset\nyou are using that forgot to add the plugin to its dependencies: you\ncan workaround this problem by explicitly adding the missing package\nto your top-level package.json.\n",error}function tryRequireResolve(id,dirname){try{return dirname?{error:null,value:(v=process.versions.node,w="8.9",v=v.split("."),w=w.split("."),+v[0]>+w[0]||v[0]==w[0]&&+v[1]>=+w[1]?__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files sync recursive").resolve:(r,{paths:[b]},M=__webpack_require__("module"))=>{let f=M._findPath(r,M._nodeModulePaths(b).concat(b));if(f)return f;throw f=new Error(`Cannot resolve module '${r}'`),f.code="MODULE_NOT_FOUND",f})(id,{paths:[dirname]})}:{error:null,value:__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files sync recursive").resolve(id)}}catch(error){return {error,value:null}}var v,w;}function tryImportMetaResolve(id,options){try{return {error:null,value:(0,_importMetaResolve.resolve)(id,options)}}catch(error){return {error,value:null}}}function resolveStandardizedNameForRequire(type,name,dirname){const it=resolveAlternativesHelper(type,name);let res=it.next();for(;!res.done;)res=it.next(tryRequireResolve(res.value,dirname));return {loader:"require",filepath:res.value}}function resolveStandardizedName(type,name,dirname,allowAsync){if(!_moduleTypes.supportsESM||!allowAsync)return resolveStandardizedNameForRequire(type,name,dirname);try{const resolved=function(type,name,dirname){const parentUrl=(0,_url().pathToFileURL)(_path().join(dirname,"./babel-virtual-resolve-base.js")).href,it=resolveAlternativesHelper(type,name);let res=it.next();for(;!res.done;)res=it.next(tryImportMetaResolve(res.value,parentUrl));return {loader:"auto",filepath:(0,_url().fileURLToPath)(res.value)}}(type,name,dirname);if(!(0,_fs().existsSync)(resolved.filepath))throw Object.assign(new Error(`Could not resolve "${name}" in file ${dirname}.`),{type:"MODULE_NOT_FOUND"});return resolved}catch(e){try{return resolveStandardizedNameForRequire(type,name,dirname)}catch(e2){if("MODULE_NOT_FOUND"===e.type)throw e;if("MODULE_NOT_FOUND"===e2.type)throw e2;throw e}}}var LOADING_MODULES=new Set;function*requireModule(type,loader,name){if(!(yield*(0, _async.isAsync)())&&LOADING_MODULES.has(name))throw new Error(`Reentrant ${type} detected trying to load "${name}". This module is not ignored and is trying to load itself while compiling itself, leading to a dependency cycle. We recommend adding it to your "ignore" list in your babelrc, or to a .babelignore.`);try{return LOADING_MODULES.add(name),yield*(0,_moduleTypes.default)(name,loader,`You appear to be using a native ECMAScript module ${type}, which is only supported when running Babel asynchronously or when using the Node.js \`--experimental-require-module\` flag.`,`You appear to be using a ${type} that contains top-level await, which is only supported when running Babel asynchronously.`,!0)}catch(err){throw err.message=`[BABEL]: ${err.message} (While processing: ${name})`,err}finally{LOADING_MODULES.delete(name);}}},"./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files/utils.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.makeStaticFileCache=function(fn){return (0, _caching.makeStrongCache)((function*(filepath,cache){const cached=cache.invalidate((()=>function(filepath){if(!_fs2().existsSync(filepath))return null;try{return +_fs2().statSync(filepath).mtime}catch(e){if("ENOENT"!==e.code&&"ENOTDIR"!==e.code)throw e}return null}(filepath)));return null===cached?null:fn(filepath,yield*fs.readFile(filepath,"utf8"))}))};var _caching=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/caching.js"),fs=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/gensync-utils/fs.js");function _fs2(){const data=__webpack_require__("fs");return _fs2=function(){return data},data}},"./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/full.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _gensync(){const data=__webpack_require__("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");return _gensync=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:true}),exports.default=void 0;var _async=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/gensync-utils/async.js"),_util=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/util.js"),context=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/index.js"),_plugin=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/plugin.js"),_item=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/item.js"),_configChain=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/config-chain.js"),_deepArray=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/helpers/deep-array.js");function _traverse(){const data=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/index.js");return _traverse=function(){return data},data}var _caching=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/caching.js"),_options=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/validation/options.js"),_plugins=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/validation/plugins.js"),_configApi=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/helpers/config-api.js"),_partial=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/partial.js"),_configError=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/errors/config-error.js");exports.default=_gensync()((function*(inputOpts){var _opts$assumptions;const result=yield*(0, _partial.default)(inputOpts);if(!result)return null;const{options,context,fileHandling}=result;if("ignored"===fileHandling)return null;const optionDefaults={},{plugins,presets}=options;if(!plugins||!presets)throw new Error("Assertion failure - plugins and presets exist");const presetContext=Object.assign({},context,{targets:options.targets}),toDescriptor=item=>{const desc=(0, _item.getItemDescriptor)(item);if(!desc)throw new Error("Assertion failure - must be config item");return desc},presetsDescriptors=presets.map(toDescriptor),initialPluginsDescriptors=plugins.map(toDescriptor),pluginDescriptorsByPass=[[]],passes=[],externalDependencies=[],ignored=yield*enhanceError(context,(function*recursePresetDescriptors(rawPresets,pluginDescriptorsPass){const presets=[];for(let i=0;i<rawPresets.length;i++){const descriptor=rawPresets[i];if(!1!==descriptor.options){try{var preset=yield*loadPresetDescriptor(descriptor,presetContext);}catch(e){throw "BABEL_UNKNOWN_OPTION"===e.code&&(0,_options.checkNoUnwrappedItemOptionPairs)(rawPresets,i,"preset",e),e}externalDependencies.push(preset.externalDependencies),descriptor.ownPass?presets.push({preset:preset.chain,pass:[]}):presets.unshift({preset:preset.chain,pass:pluginDescriptorsPass});}}if(presets.length>0){pluginDescriptorsByPass.splice(1,0,...presets.map((o=>o.pass)).filter((p=>p!==pluginDescriptorsPass)));for(const{preset,pass}of presets){if(!preset)return !0;pass.push(...preset.plugins);if(yield*recursePresetDescriptors(preset.presets,pass))return !0;preset.options.forEach((opts=>{(0,_util.mergeOptions)(optionDefaults,opts);}));}}}))(presetsDescriptors,pluginDescriptorsByPass[0]);if(ignored)return null;const opts=optionDefaults;(0, _util.mergeOptions)(opts,options);const pluginContext=Object.assign({},presetContext,{assumptions:null!=(_opts$assumptions=opts.assumptions)?_opts$assumptions:{}});return yield*enhanceError(context,(function*(){pluginDescriptorsByPass[0].unshift(...initialPluginsDescriptors);for(const descs of pluginDescriptorsByPass){const pass=[];passes.push(pass);for(let i=0;i<descs.length;i++){const descriptor=descs[i];if(!1!==descriptor.options){try{var plugin=yield*loadPluginDescriptor(descriptor,pluginContext);}catch(e){throw "BABEL_UNKNOWN_PLUGIN_PROPERTY"===e.code&&(0,_options.checkNoUnwrappedItemOptionPairs)(descs,i,"plugin",e),e}pass.push(plugin),externalDependencies.push(plugin.externalDependencies);}}}}))(),opts.plugins=passes[0],opts.presets=passes.slice(1).filter((plugins=>plugins.length>0)).map((plugins=>({plugins}))),opts.passPerPreset=opts.presets.length>0,{options:opts,passes,externalDependencies:(0, _deepArray.finalize)(externalDependencies)}}));function enhanceError(context,fn){return function*(arg1,arg2){try{return yield*fn(arg1,arg2)}catch(e){var _context$filename;if(!/^\[BABEL\]/.test(e.message))e.message=`[BABEL] ${null!=(_context$filename=context.filename)?_context$filename:"unknown file"}: ${e.message}`;throw e}}}const makeDescriptorLoader=apiFactory=>(0, _caching.makeWeakCache)((function*({value,options,dirname,alias},cache){if(false===options)throw new Error("Assertion failure");options=options||{};const externalDependencies=[];let item=value;if("function"==typeof value){const factory=(0, _async.maybeAsync)(value,"You appear to be using an async plugin/preset, but Babel has been called synchronously"),api=Object.assign({},context,apiFactory(cache,externalDependencies));try{item=yield*factory(api,options,dirname);}catch(e){throw alias&&(e.message+=` (While processing: ${JSON.stringify(alias)})`),e}}if(!item||"object"!=typeof item)throw new Error("Plugin/Preset did not return an object.");if((0, _async.isThenable)(item))throw yield*[],new Error(`You appear to be using a promise as a plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version. As an alternative, you can prefix the promise with "await". (While processing: ${JSON.stringify(alias)})`);if(externalDependencies.length>0&&(!cache.configured()||"forever"===cache.mode())){let error=`A plugin/preset has external untracked dependencies (${externalDependencies[0]}), but the cache `;throw cache.configured()?error+=" has been configured to never be invalidated. ":error+="has not been configured to be invalidated when the external dependencies change. ",error+=`Plugins/presets should configure their cache to be invalidated when the external dependencies change, for example using \`api.cache.invalidate(() => statSync(filepath).mtimeMs)\` or \`api.cache.never()\`\n(While processing: ${JSON.stringify(alias)})`,new Error(error)}return {value:item,options,dirname,alias,externalDependencies:(0, _deepArray.finalize)(externalDependencies)}})),pluginDescriptorLoader=makeDescriptorLoader(_configApi.makePluginAPI),presetDescriptorLoader=makeDescriptorLoader(_configApi.makePresetAPI),instantiatePlugin=(0, _caching.makeWeakCache)((function*({value,options,dirname,alias,externalDependencies},cache){const pluginObj=(0, _plugins.validatePluginObject)(value),plugin=Object.assign({},pluginObj);if(plugin.visitor&&(plugin.visitor=_traverse().default.explode(Object.assign({},plugin.visitor))),plugin.inherits){const inheritsDescriptor={name:void 0,alias:`${alias}$inherits`,value:plugin.inherits,options,dirname},inherits=yield*(0, _async.forwardAsync)(loadPluginDescriptor,(run=>cache.invalidate((data=>run(inheritsDescriptor,data)))));plugin.pre=chainMaybeAsync(inherits.pre,plugin.pre),plugin.post=chainMaybeAsync(inherits.post,plugin.post),plugin.manipulateOptions=chainMaybeAsync(inherits.manipulateOptions,plugin.manipulateOptions),plugin.visitor=_traverse().default.visitors.merge([inherits.visitor||{},plugin.visitor||{}]),inherits.externalDependencies.length>0&&(externalDependencies=0===externalDependencies.length?inherits.externalDependencies:(0, _deepArray.finalize)([externalDependencies,inherits.externalDependencies]));}return new _plugin.default(plugin,options,alias,externalDependencies)}));function*loadPluginDescriptor(descriptor,context){if(descriptor.value instanceof _plugin.default){if(descriptor.options)throw new Error("Passed options to an existing Plugin instance will not work.");return descriptor.value}return yield*instantiatePlugin(yield*pluginDescriptorLoader(descriptor,context),context)}const needsFilename=val=>val&&"function"!=typeof val,validateIfOptionNeedsFilename=(options,descriptor)=>{if(needsFilename(options.test)||needsFilename(options.include)||needsFilename(options.exclude)){const formattedPresetName=descriptor.name?`"${descriptor.name}"`:"/* your preset */";throw new _configError.default([`Preset ${formattedPresetName} requires a filename to be set when babel is called directly,`,"```",`babel.transformSync(code, { filename: 'file.ts', presets: [${formattedPresetName}] });`,"```","See https://babeljs.io/docs/en/options#filename for more information."].join("\n"))}},validatePreset=(preset,context,descriptor)=>{if(!context.filename){var _options$overrides;const{options}=preset;validateIfOptionNeedsFilename(options,descriptor),null==(_options$overrides=options.overrides)||_options$overrides.forEach((overrideOptions=>validateIfOptionNeedsFilename(overrideOptions,descriptor)));}},instantiatePreset=(0, _caching.makeWeakCacheSync)((({value,dirname,alias,externalDependencies})=>({options:(0, _options.validate)("preset",value),alias,dirname,externalDependencies})));function*loadPresetDescriptor(descriptor,context){const preset=instantiatePreset(yield*presetDescriptorLoader(descriptor,context));return validatePreset(preset,context,descriptor),{chain:yield*(0, _configChain.buildPresetChain)(preset,context),externalDependencies:preset.externalDependencies}}function chainMaybeAsync(a,b){return a?b?function(...args){const res=a.apply(this,args);return res&&"function"==typeof res.then?res.then((()=>b.apply(this,args))):b.apply(this,args)}:a:b}},"./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/helpers/config-api.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _semver(){const data=__webpack_require__("./node_modules/.pnpm/semver@6.3.1/node_modules/semver/semver.js");return _semver=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:true}),exports.makeConfigAPI=makeConfigAPI,exports.makePluginAPI=function(cache,externalDependencies){return Object.assign({},makePresetAPI(cache,externalDependencies),{assumption:name=>cache.using((data=>data.assumptions[name]))})},exports.makePresetAPI=makePresetAPI;var _index=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/index.js"),_caching=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/caching.js");function makeConfigAPI(cache){return {version:_index.version,cache:cache.simple(),env:value=>cache.using((data=>void 0===value?data.envName:"function"==typeof value?(0, _caching.assertSimpleType)(value(data.envName)):(Array.isArray(value)?value:[value]).some((entry=>{if("string"!=typeof entry)throw new Error("Unexpected non-string value");return entry===data.envName})))),async:()=>false,caller:cb=>cache.using((data=>(0, _caching.assertSimpleType)(cb(data.caller)))),assertVersion}}function makePresetAPI(cache,externalDependencies){return Object.assign({},makeConfigAPI(cache),{targets:()=>JSON.parse(cache.using((data=>JSON.stringify(data.targets)))),addExternalDependency:ref=>{externalDependencies.push(ref);}})}function assertVersion(range){if("number"==typeof range){if(!Number.isInteger(range))throw new Error("Expected string or integer value.");range=`^${range}.0.0-0`;}if("string"!=typeof range)throw new Error("Expected string or integer value.");if("*"===range||_semver().satisfies(_index.version,range))return;const limit=Error.stackTraceLimit;"number"==typeof limit&&limit<25&&(Error.stackTraceLimit=25);const err=new Error(`Requires Babel "${range}", but was loaded with "${_index.version}". If you are sure you have a compatible version of @babel/core, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for the first entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`);throw "number"==typeof limit&&(Error.stackTraceLimit=limit),Object.assign(err,{code:"BABEL_VERSION_UNSUPPORTED",version:_index.version,range})}},"./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/helpers/deep-array.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.finalize=function(deepArr){return Object.freeze(deepArr)},exports.flattenToSet=function(arr){const result=new Set,stack=[arr];for(;stack.length>0;)for(const el of stack.pop())Array.isArray(el)?stack.push(el):result.add(el);return result};},"./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/helpers/environment.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.getEnv=function(defaultValue="development"){return process.env.BABEL_ENV||process.env.NODE_ENV||defaultValue};},"./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _gensync(){const data=__webpack_require__("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");return _gensync=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:true}),exports.createConfigItem=function(target,options,callback){if(void 0!==callback)(0, _rewriteStackTrace.beginHiddenCallStack)(createConfigItemRunner.errback)(target,options,callback);else {if("function"!=typeof options)return createConfigItemSync(target,options);(0, _rewriteStackTrace.beginHiddenCallStack)(createConfigItemRunner.errback)(target,void 0,callback);}},exports.createConfigItemAsync=function(...args){return (0, _rewriteStackTrace.beginHiddenCallStack)(createConfigItemRunner.async)(...args)},exports.createConfigItemSync=createConfigItemSync,Object.defineProperty(exports,"default",{enumerable:true,get:function(){return _full.default}}),exports.loadOptions=function(opts,callback){if(void 0!==callback)(0, _rewriteStackTrace.beginHiddenCallStack)(loadOptionsRunner.errback)(opts,callback);else {if("function"!=typeof opts)return loadOptionsSync(opts);(0, _rewriteStackTrace.beginHiddenCallStack)(loadOptionsRunner.errback)(void 0,opts);}},exports.loadOptionsAsync=function(...args){return (0, _rewriteStackTrace.beginHiddenCallStack)(loadOptionsRunner.async)(...args)},exports.loadOptionsSync=loadOptionsSync,exports.loadPartialConfig=function(opts,callback){if(void 0!==callback)(0, _rewriteStackTrace.beginHiddenCallStack)(loadPartialConfigRunner.errback)(opts,callback);else {if("function"!=typeof opts)return loadPartialConfigSync(opts);(0, _rewriteStackTrace.beginHiddenCallStack)(loadPartialConfigRunner.errback)(void 0,opts);}},exports.loadPartialConfigAsync=function(...args){return (0, _rewriteStackTrace.beginHiddenCallStack)(loadPartialConfigRunner.async)(...args)},exports.loadPartialConfigSync=loadPartialConfigSync;var _full=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/full.js"),_partial=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/partial.js"),_item=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/item.js"),_rewriteStackTrace=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/errors/rewrite-stack-trace.js");const loadPartialConfigRunner=_gensync()(_partial.loadPartialConfig);function loadPartialConfigSync(...args){return (0, _rewriteStackTrace.beginHiddenCallStack)(loadPartialConfigRunner.sync)(...args)}const loadOptionsRunner=_gensync()((function*(opts){var _config$options;const config=yield*(0, _full.default)(opts);return null!=(_config$options=null==config?void 0:config.options)?_config$options:null}));function loadOptionsSync(...args){return (0, _rewriteStackTrace.beginHiddenCallStack)(loadOptionsRunner.sync)(...args)}const createConfigItemRunner=_gensync()(_item.createConfigItem);function createConfigItemSync(...args){return (0, _rewriteStackTrace.beginHiddenCallStack)(createConfigItemRunner.sync)(...args)}},"./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/item.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _path(){const data=__webpack_require__("path");return _path=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:true}),exports.createConfigItem=function*(value,{dirname=".",type}={}){return createItemFromDescriptor(yield*(0, _configDescriptors.createDescriptor)(value,_path().resolve(dirname),{type,alias:"programmatic item"}))},exports.createItemFromDescriptor=createItemFromDescriptor,exports.getItemDescriptor=function(item){if(null!=item&&item[CONFIG_ITEM_BRAND])return item._descriptor;return};var _configDescriptors=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/config-descriptors.js");function createItemFromDescriptor(desc){return new ConfigItem(desc)}const CONFIG_ITEM_BRAND=Symbol.for("@babel/core@7 - ConfigItem");class ConfigItem{constructor(descriptor){this._descriptor=void 0,this[CONFIG_ITEM_BRAND]=true,this.value=void 0,this.options=void 0,this.dirname=void 0,this.name=void 0,this.file=void 0,this._descriptor=descriptor,Object.defineProperty(this,"_descriptor",{enumerable:false}),Object.defineProperty(this,CONFIG_ITEM_BRAND,{enumerable:false}),this.value=this._descriptor.value,this.options=this._descriptor.options,this.dirname=this._descriptor.dirname,this.name=this._descriptor.name,this.file=this._descriptor.file?{request:this._descriptor.file.request,resolved:this._descriptor.file.resolved}:void 0,Object.freeze(this);}}Object.freeze(ConfigItem.prototype);},"./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/partial.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _path(){const data=__webpack_require__("path");return _path=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:true}),exports.default=loadPrivatePartialConfig,exports.loadPartialConfig=function*(opts){let showIgnoredFiles=false;if("object"==typeof opts&&null!==opts&&!Array.isArray(opts)){var _opts=opts;(({showIgnoredFiles}=_opts)),opts=function(r,e){if(null==r)return {};var t={};for(var n in r)if({}.hasOwnProperty.call(r,n)){if(e.includes(n))continue;t[n]=r[n];}return t}(_opts,_excluded);}const result=yield*loadPrivatePartialConfig(opts);if(!result)return null;const{options,babelrc,ignore,config,fileHandling,files}=result;if("ignored"===fileHandling&&!showIgnoredFiles)return null;return (options.plugins||[]).forEach((item=>{if(item.value instanceof _plugin.default)throw new Error("Passing cached plugin instances is not supported in babel.loadPartialConfig()")})),new PartialConfig(options,babelrc?babelrc.filepath:void 0,ignore?ignore.filepath:void 0,config?config.filepath:void 0,fileHandling,files)};var _plugin=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/plugin.js"),_util=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/util.js"),_item=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/item.js"),_configChain=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/config-chain.js"),_environment=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/helpers/environment.js"),_options=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/validation/options.js"),_index=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files/index.js"),_resolveTargets=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/resolve-targets.js");const _excluded=["showIgnoredFiles"];function*loadPrivatePartialConfig(inputOpts){if(null!=inputOpts&&("object"!=typeof inputOpts||Array.isArray(inputOpts)))throw new Error("Babel options must be an object, null, or undefined");const args=inputOpts?(0, _options.validate)("arguments",inputOpts):{},{envName=(0, _environment.getEnv)(),cwd=".",root:rootDir=".",rootMode="root",caller,cloneInputAst=true}=args,absoluteCwd=_path().resolve(cwd),absoluteRootDir=function(rootDir,rootMode){switch(rootMode){case "root":return rootDir;case "upward-optional":{const upwardRootDir=(0, _index.findConfigUpwards)(rootDir);return null===upwardRootDir?rootDir:upwardRootDir}case "upward":{const upwardRootDir=(0, _index.findConfigUpwards)(rootDir);if(null!==upwardRootDir)return upwardRootDir;throw Object.assign(new Error(`Babel was run with rootMode:"upward" but a root could not be found when searching upward from "${rootDir}".\nOne of the following config files must be in the directory tree: "${_index.ROOT_CONFIG_FILENAMES.join(", ")}".`),{code:"BABEL_ROOT_NOT_FOUND",dirname:rootDir})}default:throw new Error("Assertion failure - unknown rootMode value.")}}(_path().resolve(absoluteCwd,rootDir),rootMode),filename="string"==typeof args.filename?_path().resolve(cwd,args.filename):void 0,context={filename,cwd:absoluteCwd,root:absoluteRootDir,envName,caller,showConfig:(yield*(0, _index.resolveShowConfigPath)(absoluteCwd))===filename},configChain=yield*(0, _configChain.buildRootChain)(args,context);if(!configChain)return null;const merged={assumptions:{}};configChain.options.forEach((opts=>{(0, _util.mergeOptions)(merged,opts);}));return {options:Object.assign({},merged,{targets:(0, _resolveTargets.resolveTargets)(merged,absoluteRootDir),cloneInputAst,babelrc:false,configFile:false,browserslistConfigFile:false,passPerPreset:false,envName:context.envName,cwd:context.cwd,root:context.root,rootMode:"root",filename:"string"==typeof context.filename?context.filename:void 0,plugins:configChain.plugins.map((descriptor=>(0, _item.createItemFromDescriptor)(descriptor))),presets:configChain.presets.map((descriptor=>(0, _item.createItemFromDescriptor)(descriptor)))}),context,fileHandling:configChain.fileHandling,ignore:configChain.ignore,babelrc:configChain.babelrc,config:configChain.config,files:configChain.files}}class PartialConfig{constructor(options,babelrc,ignore,config,fileHandling,files){this.options=void 0,this.babelrc=void 0,this.babelignore=void 0,this.config=void 0,this.fileHandling=void 0,this.files=void 0,this.options=options,this.babelignore=ignore,this.babelrc=babelrc,this.config=config,this.fileHandling=fileHandling,this.files=files,Object.freeze(this);}hasFilesystemConfig(){return void 0!==this.babelrc||void 0!==this.config}}Object.freeze(PartialConfig.prototype);},"./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/pattern-to-regex.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _path(){const data=__webpack_require__("path");return _path=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(pattern,dirname){const parts=_path().resolve(dirname,pattern).split(_path().sep);return new RegExp(["^",...parts.map(((part,i)=>{const last=i===parts.length-1;return "**"===part?last?starStarPatLast:starStarPat:"*"===part?last?starPatLast:starPat:0===part.indexOf("*.")?substitution+escapeRegExp(part.slice(1))+(last?endSep:sep):escapeRegExp(part)+(last?endSep:sep)}))].join(""))};const sep=`\\${_path().sep}`,endSep=`(?:${sep}|$)`,substitution=`[^${sep}]+`,starPat=`(?:${substitution}${sep})`,starPatLast=`(?:${substitution}${endSep})`,starStarPat=`${starPat}*?`,starStarPatLast=`${starPat}*?${starPatLast}?`;function escapeRegExp(string){return string.replace(/[|\\{}()[\]^$+*?.]/g,"\\$&")}},"./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/plugin.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=void 0;var _deepArray=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/helpers/deep-array.js");exports.default=class{constructor(plugin,options,key,externalDependencies=(0, _deepArray.finalize)([])){this.key=void 0,this.manipulateOptions=void 0,this.post=void 0,this.pre=void 0,this.visitor=void 0,this.parserOverride=void 0,this.generatorOverride=void 0,this.options=void 0,this.externalDependencies=void 0,this.key=plugin.name||key,this.manipulateOptions=plugin.manipulateOptions,this.post=plugin.post,this.pre=plugin.pre,this.visitor=plugin.visitor||{},this.parserOverride=plugin.parserOverride,this.generatorOverride=plugin.generatorOverride,this.options=options,this.externalDependencies=externalDependencies;}};},"./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/printer.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _gensync(){const data=__webpack_require__("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");return _gensync=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:true}),exports.ConfigPrinter=exports.ChainFormatter=void 0;const ChainFormatter=exports.ChainFormatter={Programmatic:0,Config:1},Formatter={title(type,callerName,filepath){let title="";return type===ChainFormatter.Programmatic?(title="programmatic options",callerName&&(title+=" from "+callerName)):title="config "+filepath,title},loc(index,envName){let loc="";return null!=index&&(loc+=`.overrides[${index}]`),null!=envName&&(loc+=`.env["${envName}"]`),loc},*optionsAndDescriptors(opt){const content=Object.assign({},opt.options);delete content.overrides,delete content.env;const pluginDescriptors=[...yield*opt.plugins()];pluginDescriptors.length&&(content.plugins=pluginDescriptors.map((d=>descriptorToConfig(d))));const presetDescriptors=[...yield*opt.presets()];return presetDescriptors.length&&(content.presets=[...presetDescriptors].map((d=>descriptorToConfig(d)))),JSON.stringify(content,void 0,2)}};function descriptorToConfig(d){var _d$file;let name=null==(_d$file=d.file)?void 0:_d$file.request;return null==name&&("object"==typeof d.value?name=d.value:"function"==typeof d.value&&(name=`[Function: ${d.value.toString().slice(0,50)} ... ]`)),null==name&&(name="[Unknown]"),void 0===d.options?name:null==d.name?[name,d.options]:[name,d.options,d.name]}class ConfigPrinter{constructor(){this._stack=[];}configure(enabled,type,{callerName,filepath}){return enabled?(content,index,envName)=>{this._stack.push({type,callerName,filepath,content,index,envName});}:()=>{}}static*format(config){let title=Formatter.title(config.type,config.callerName,config.filepath);const loc=Formatter.loc(config.index,config.envName);loc&&(title+=` ${loc}`);return `${title}\n${yield*Formatter.optionsAndDescriptors(config.content)}`}*output(){if(0===this._stack.length)return "";return (yield*_gensync().all(this._stack.map((s=>ConfigPrinter.format(s))))).join("\n\n")}}exports.ConfigPrinter=ConfigPrinter;},"./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/resolve-targets.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _path(){const data=__webpack_require__("path");return _path=function(){return data},data}function _helperCompilationTargets(){const data=__webpack_require__("./stubs/helper-compilation-targets.mjs");return _helperCompilationTargets=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:true}),exports.resolveBrowserslistConfigFile=function(browserslistConfigFile,configFileDir){return _path().resolve(configFileDir,browserslistConfigFile)},exports.resolveTargets=function(options,root){const optTargets=options.targets;let targets;"string"==typeof optTargets||Array.isArray(optTargets)?targets={browsers:optTargets}:optTargets&&(targets="esmodules"in optTargets?Object.assign({},optTargets,{esmodules:"intersect"}):optTargets);const{browserslistConfigFile}=options;let configFile,ignoreBrowserslistConfig=false;"string"==typeof browserslistConfigFile?configFile=browserslistConfigFile:ignoreBrowserslistConfig=false===browserslistConfigFile;return (0, _helperCompilationTargets().default)(targets,{ignoreBrowserslistConfig,configFile,configPath:root,browserslistEnv:options.browserslistEnv})};},"./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/util.js":(__unused_webpack_module,exports)=>{function mergeDefaultFields(target,source){for(const k of Object.keys(source)){const val=source[k];void 0!==val&&(target[k]=val);}}Object.defineProperty(exports,"__esModule",{value:true}),exports.isIterableIterator=function(value){return !!value&&"function"==typeof value.next&&"function"==typeof value[Symbol.iterator]},exports.mergeOptions=function(target,source){for(const k of Object.keys(source))if("parserOpts"!==k&&"generatorOpts"!==k&&"assumptions"!==k||!source[k]){const val=source[k];void 0!==val&&(target[k]=val);}else {const parserOpts=source[k];mergeDefaultFields(target[k]||(target[k]={}),parserOpts);}};},"./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/validation/option-assertions.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _helperCompilationTargets(){const data=__webpack_require__("./stubs/helper-compilation-targets.mjs");return _helperCompilationTargets=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:true}),exports.access=access,exports.assertArray=assertArray,exports.assertAssumptions=function(loc,value){if(void 0===value)return;if("object"!=typeof value||null===value)throw new Error(`${msg(loc)} must be an object or undefined.`);let root=loc;do{root=root.parent;}while("root"!==root.type);const inPreset="preset"===root.source;for(const name of Object.keys(value)){const subLoc=access(loc,name);if(!_options.assumptionsNames.has(name))throw new Error(`${msg(subLoc)} is not a supported assumption.`);if("boolean"!=typeof value[name])throw new Error(`${msg(subLoc)} must be a boolean.`);if(inPreset&&false===value[name])throw new Error(`${msg(subLoc)} cannot be set to 'false' inside presets.`)}return value},exports.assertBabelrcSearch=function(loc,value){if(void 0===value||"boolean"==typeof value)return value;if(Array.isArray(value))value.forEach(((item,i)=>{if(!checkValidTest(item))throw new Error(`${msg(access(loc,i))} must be a string/Function/RegExp.`)}));else if(!checkValidTest(value))throw new Error(`${msg(loc)} must be a undefined, a boolean, a string/Function/RegExp or an array of those, got ${JSON.stringify(value)}`);return value},exports.assertBoolean=assertBoolean,exports.assertCallerMetadata=function(loc,value){const obj=assertObject(loc,value);if(obj){if("string"!=typeof obj.name)throw new Error(`${msg(loc)} set but does not contain "name" property string`);for(const prop of Object.keys(obj)){const propLoc=access(loc,prop),value=obj[prop];if(null!=value&&"boolean"!=typeof value&&"string"!=typeof value&&"number"!=typeof value)throw new Error(`${msg(propLoc)} must be null, undefined, a boolean, a string, or a number.`)}}return value},exports.assertCompact=function(loc,value){if(void 0!==value&&"boolean"!=typeof value&&"auto"!==value)throw new Error(`${msg(loc)} must be a boolean, "auto", or undefined`);return value},exports.assertConfigApplicableTest=function(loc,value){if(void 0===value)return value;if(Array.isArray(value))value.forEach(((item,i)=>{if(!checkValidTest(item))throw new Error(`${msg(access(loc,i))} must be a string/Function/RegExp.`)}));else if(!checkValidTest(value))throw new Error(`${msg(loc)} must be a string/Function/RegExp, or an array of those`);return value},exports.assertConfigFileSearch=function(loc,value){if(void 0!==value&&"boolean"!=typeof value&&"string"!=typeof value)throw new Error(`${msg(loc)} must be a undefined, a boolean, a string, got ${JSON.stringify(value)}`);return value},exports.assertFunction=function(loc,value){if(void 0!==value&&"function"!=typeof value)throw new Error(`${msg(loc)} must be a function, or undefined`);return value},exports.assertIgnoreList=function(loc,value){const arr=assertArray(loc,value);return null==arr||arr.forEach(((item,i)=>function(loc,value){if("string"!=typeof value&&"function"!=typeof value&&!(value instanceof RegExp))throw new Error(`${msg(loc)} must be an array of string/Function/RegExp values, or undefined`);return value}(access(loc,i),item))),arr},exports.assertInputSourceMap=function(loc,value){if(void 0!==value&&"boolean"!=typeof value&&("object"!=typeof value||!value))throw new Error(`${msg(loc)} must be a boolean, object, or undefined`);return value},exports.assertObject=assertObject,exports.assertPluginList=function(loc,value){const arr=assertArray(loc,value);arr&&arr.forEach(((item,i)=>function(loc,value){if(Array.isArray(value)){if(0===value.length)throw new Error(`${msg(loc)} must include an object`);if(value.length>3)throw new Error(`${msg(loc)} may only be a two-tuple or three-tuple`);if(assertPluginTarget(access(loc,0),value[0]),value.length>1){const opts=value[1];if(void 0!==opts&&false!==opts&&("object"!=typeof opts||Array.isArray(opts)||null===opts))throw new Error(`${msg(access(loc,1))} must be an object, false, or undefined`)}if(3===value.length){const name=value[2];if(void 0!==name&&"string"!=typeof name)throw new Error(`${msg(access(loc,2))} must be a string, or undefined`)}}else assertPluginTarget(loc,value);return value}(access(loc,i),item)));return arr},exports.assertRootMode=function(loc,value){if(void 0!==value&&"root"!==value&&"upward"!==value&&"upward-optional"!==value)throw new Error(`${msg(loc)} must be a "root", "upward", "upward-optional" or undefined`);return value},exports.assertSourceMaps=function(loc,value){if(void 0!==value&&"boolean"!=typeof value&&"inline"!==value&&"both"!==value)throw new Error(`${msg(loc)} must be a boolean, "inline", "both", or undefined`);return value},exports.assertSourceType=function(loc,value){if(void 0!==value&&"module"!==value&&"script"!==value&&"unambiguous"!==value)throw new Error(`${msg(loc)} must be "module", "script", "unambiguous", or undefined`);return value},exports.assertString=function(loc,value){if(void 0!==value&&"string"!=typeof value)throw new Error(`${msg(loc)} must be a string, or undefined`);return value},exports.assertTargets=function(loc,value){if((0, _helperCompilationTargets().isBrowsersQueryValid)(value))return value;if("object"!=typeof value||!value||Array.isArray(value))throw new Error(`${msg(loc)} must be a string, an array of strings or an object`);const browsersLoc=access(loc,"browsers"),esmodulesLoc=access(loc,"esmodules");assertBrowsersList(browsersLoc,value.browsers),assertBoolean(esmodulesLoc,value.esmodules);for(const key of Object.keys(value)){const val=value[key],subLoc=access(loc,key);if("esmodules"===key)assertBoolean(subLoc,val);else if("browsers"===key)assertBrowsersList(subLoc,val);else {if(!hasOwnProperty.call(_helperCompilationTargets().TargetNames,key)){const validTargets=Object.keys(_helperCompilationTargets().TargetNames).join(", ");throw new Error(`${msg(subLoc)} is not a valid target. Supported targets are ${validTargets}`)}assertBrowserVersion(subLoc,val);}}return value},exports.msg=msg;var _options=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/validation/options.js");function msg(loc){switch(loc.type){case "root":return "";case "env":return `${msg(loc.parent)}.env["${loc.name}"]`;case "overrides":return `${msg(loc.parent)}.overrides[${loc.index}]`;case "option":return `${msg(loc.parent)}.${loc.name}`;case "access":return `${msg(loc.parent)}[${JSON.stringify(loc.name)}]`;default:throw new Error(`Assertion failure: Unknown type ${loc.type}`)}}function access(loc,name){return {type:"access",name,parent:loc}}function assertBoolean(loc,value){if(void 0!==value&&"boolean"!=typeof value)throw new Error(`${msg(loc)} must be a boolean, or undefined`);return value}function assertObject(loc,value){if(void 0!==value&&("object"!=typeof value||Array.isArray(value)||!value))throw new Error(`${msg(loc)} must be an object, or undefined`);return value}function assertArray(loc,value){if(null!=value&&!Array.isArray(value))throw new Error(`${msg(loc)} must be an array, or undefined`);return value}function checkValidTest(value){return "string"==typeof value||"function"==typeof value||value instanceof RegExp}function assertPluginTarget(loc,value){if(("object"!=typeof value||!value)&&"string"!=typeof value&&"function"!=typeof value)throw new Error(`${msg(loc)} must be a string, object, function`);return value}function assertBrowsersList(loc,value){if(void 0!==value&&!(0, _helperCompilationTargets().isBrowsersQueryValid)(value))throw new Error(`${msg(loc)} must be undefined, a string or an array of strings`)}function assertBrowserVersion(loc,value){if(("number"!=typeof value||Math.round(value)!==value)&&"string"!=typeof value)throw new Error(`${msg(loc)} must be a string or an integer number`)}},"./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/validation/options.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.assumptionsNames=void 0,exports.checkNoUnwrappedItemOptionPairs=function(items,index,type,e){if(0===index)return;const lastItem=items[index-1],thisItem=items[index];lastItem.file&&void 0===lastItem.options&&"object"==typeof thisItem.value&&(e.message+=`\n- Maybe you meant to use\n"${type}s": [\n  ["${lastItem.file.request}", ${JSON.stringify(thisItem.value,void 0,2)}]\n]\nTo be a valid ${type}, its name and options should be wrapped in a pair of brackets`);},exports.validate=function(type,opts,filename){try{return validateNested({type:"root",source:type},opts)}catch(error){const configError=new _configError.default(error.message,filename);throw error.code&&(configError.code=error.code),configError}};var _removed=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/validation/removed.js"),_optionAssertions=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/validation/option-assertions.js"),_configError=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/errors/config-error.js");const ROOT_VALIDATORS={cwd:_optionAssertions.assertString,root:_optionAssertions.assertString,rootMode:_optionAssertions.assertRootMode,configFile:_optionAssertions.assertConfigFileSearch,caller:_optionAssertions.assertCallerMetadata,filename:_optionAssertions.assertString,filenameRelative:_optionAssertions.assertString,code:_optionAssertions.assertBoolean,ast:_optionAssertions.assertBoolean,cloneInputAst:_optionAssertions.assertBoolean,envName:_optionAssertions.assertString},BABELRC_VALIDATORS={babelrc:_optionAssertions.assertBoolean,babelrcRoots:_optionAssertions.assertBabelrcSearch},NONPRESET_VALIDATORS={extends:_optionAssertions.assertString,ignore:_optionAssertions.assertIgnoreList,only:_optionAssertions.assertIgnoreList,targets:_optionAssertions.assertTargets,browserslistConfigFile:_optionAssertions.assertConfigFileSearch,browserslistEnv:_optionAssertions.assertString},COMMON_VALIDATORS={inputSourceMap:_optionAssertions.assertInputSourceMap,presets:_optionAssertions.assertPluginList,plugins:_optionAssertions.assertPluginList,passPerPreset:_optionAssertions.assertBoolean,assumptions:_optionAssertions.assertAssumptions,env:function(loc,value){if("env"===loc.parent.type)throw new Error(`${(0, _optionAssertions.msg)(loc)} is not allowed inside of another .env block`);const parent=loc.parent,obj=(0, _optionAssertions.assertObject)(loc,value);if(obj)for(const envName of Object.keys(obj)){const env=(0, _optionAssertions.assertObject)((0, _optionAssertions.access)(loc,envName),obj[envName]);if(!env)continue;validateNested({type:"env",name:envName,parent},env);}return obj},overrides:function(loc,value){if("env"===loc.parent.type)throw new Error(`${(0, _optionAssertions.msg)(loc)} is not allowed inside an .env block`);if("overrides"===loc.parent.type)throw new Error(`${(0, _optionAssertions.msg)(loc)} is not allowed inside an .overrides block`);const parent=loc.parent,arr=(0, _optionAssertions.assertArray)(loc,value);if(arr)for(const[index,item]of arr.entries()){const objLoc=(0, _optionAssertions.access)(loc,index),env=(0, _optionAssertions.assertObject)(objLoc,item);if(!env)throw new Error(`${(0, _optionAssertions.msg)(objLoc)} must be an object`);validateNested({type:"overrides",index,parent},env);}return arr},test:_optionAssertions.assertConfigApplicableTest,include:_optionAssertions.assertConfigApplicableTest,exclude:_optionAssertions.assertConfigApplicableTest,retainLines:_optionAssertions.assertBoolean,comments:_optionAssertions.assertBoolean,shouldPrintComment:_optionAssertions.assertFunction,compact:_optionAssertions.assertCompact,minified:_optionAssertions.assertBoolean,auxiliaryCommentBefore:_optionAssertions.assertString,auxiliaryCommentAfter:_optionAssertions.assertString,sourceType:_optionAssertions.assertSourceType,wrapPluginVisitorMethod:_optionAssertions.assertFunction,highlightCode:_optionAssertions.assertBoolean,sourceMaps:_optionAssertions.assertSourceMaps,sourceMap:_optionAssertions.assertSourceMaps,sourceFileName:_optionAssertions.assertString,sourceRoot:_optionAssertions.assertString,parserOpts:_optionAssertions.assertObject,generatorOpts:_optionAssertions.assertObject};Object.assign(COMMON_VALIDATORS,{getModuleId:_optionAssertions.assertFunction,moduleRoot:_optionAssertions.assertString,moduleIds:_optionAssertions.assertBoolean,moduleId:_optionAssertions.assertString});exports.assumptionsNames=new Set(["arrayLikeIsIterable","constantReexports","constantSuper","enumerableModuleMeta","ignoreFunctionLength","ignoreToPrimitiveHint","iterableIsArray","mutableTemplateObject","noClassCalls","noDocumentAll","noIncompleteNsImportDetection","noNewArrows","noUninitializedPrivateFieldAccess","objectRestNoSymbols","privateFieldsAsSymbols","privateFieldsAsProperties","pureGetters","setClassMethods","setComputedProperties","setPublicClassFields","setSpreadProperties","skipForOfIteratorClosing","superIsCallableConstructor"]);function getSource(loc){return "root"===loc.type?loc.source:getSource(loc.parent)}function validateNested(loc,opts){const type=getSource(loc);return function(opts){if(hasOwnProperty.call(opts,"sourceMap")&&hasOwnProperty.call(opts,"sourceMaps"))throw new Error(".sourceMap is an alias for .sourceMaps, cannot use both")}(opts),Object.keys(opts).forEach((key=>{const optLoc={type:"option",name:key,parent:loc};if("preset"===type&&NONPRESET_VALIDATORS[key])throw new Error(`${(0, _optionAssertions.msg)(optLoc)} is not allowed in preset options`);if("arguments"!==type&&ROOT_VALIDATORS[key])throw new Error(`${(0, _optionAssertions.msg)(optLoc)} is only allowed in root programmatic options`);if("arguments"!==type&&"configfile"!==type&&BABELRC_VALIDATORS[key]){if("babelrcfile"===type||"extendsfile"===type)throw new Error(`${(0, _optionAssertions.msg)(optLoc)} is not allowed in .babelrc or "extends"ed files, only in root programmatic options, or babel.config.js/config file options`);throw new Error(`${(0, _optionAssertions.msg)(optLoc)} is only allowed in root programmatic options, or babel.config.js/config file options`)}(COMMON_VALIDATORS[key]||NONPRESET_VALIDATORS[key]||BABELRC_VALIDATORS[key]||ROOT_VALIDATORS[key]||throwUnknownError)(optLoc,opts[key]);})),opts}function throwUnknownError(loc){const key=loc.name;if(_removed.default[key]){const{message,version=5}=_removed.default[key];throw new Error(`Using removed Babel ${version} option: ${(0, _optionAssertions.msg)(loc)} - ${message}`)}{const unknownOptErr=new Error(`Unknown option: ${(0, _optionAssertions.msg)(loc)}. Check out https://babeljs.io/docs/en/babel-core/#options for more information about options.`);throw unknownOptErr.code="BABEL_UNKNOWN_OPTION",unknownOptErr}}},"./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/validation/plugins.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.validatePluginObject=function(obj){const rootPath={type:"root",source:"plugin"};return Object.keys(obj).forEach((key=>{const validator=VALIDATORS[key];if(!validator){const invalidPluginPropertyError=new Error(`.${key} is not a valid Plugin property`);throw invalidPluginPropertyError.code="BABEL_UNKNOWN_PLUGIN_PROPERTY",invalidPluginPropertyError}validator({type:"option",name:key,parent:rootPath},obj[key]);})),obj};var _optionAssertions=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/validation/option-assertions.js");const VALIDATORS={name:_optionAssertions.assertString,manipulateOptions:_optionAssertions.assertFunction,pre:_optionAssertions.assertFunction,post:_optionAssertions.assertFunction,inherits:_optionAssertions.assertFunction,visitor:function(loc,value){const obj=(0, _optionAssertions.assertObject)(loc,value);if(obj&&(Object.keys(obj).forEach((prop=>{"_exploded"!==prop&&"_verified"!==prop&&function(key,value){if(value&&"object"==typeof value)Object.keys(value).forEach((handler=>{if("enter"!==handler&&"exit"!==handler)throw new Error(`.visitor["${key}"] may only have .enter and/or .exit handlers.`)}));else if("function"!=typeof value)throw new Error(`.visitor["${key}"] must be a function`)}(prop,obj[prop]);})),obj.enter||obj.exit))throw new Error(`${(0, _optionAssertions.msg)(loc)} cannot contain catch-all "enter" or "exit" handlers. Please target individual nodes.`);return obj},parserOverride:_optionAssertions.assertFunction,generatorOverride:_optionAssertions.assertFunction};},"./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/validation/removed.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=void 0;exports.default={auxiliaryComment:{message:"Use `auxiliaryCommentBefore` or `auxiliaryCommentAfter`"},blacklist:{message:"Put the specific transforms you want in the `plugins` option"},breakConfig:{message:"This is not a necessary option in Babel 6"},experimental:{message:"Put the specific transforms you want in the `plugins` option"},externalHelpers:{message:"Use the `external-helpers` plugin instead. Check out http://babeljs.io/docs/plugins/external-helpers/"},extra:{message:""},jsxPragma:{message:"use the `pragma` option in the `react-jsx` plugin. Check out http://babeljs.io/docs/plugins/transform-react-jsx/"},loose:{message:"Specify the `loose` option for the relevant plugin you are using or use a preset that sets the option."},metadataUsedHelpers:{message:"Not required anymore as this is enabled by default"},modules:{message:"Use the corresponding module transform plugin in the `plugins` option. Check out http://babeljs.io/docs/plugins/#modules"},nonStandard:{message:"Use the `react-jsx` and `flow-strip-types` plugins to support JSX and Flow. Also check out the react preset http://babeljs.io/docs/plugins/preset-react/"},optional:{message:"Put the specific transforms you want in the `plugins` option"},sourceMapName:{message:"The `sourceMapName` option has been removed because it makes more sense for the tooling that calls Babel to assign `map.file` themselves."},stage:{message:"Check out the corresponding stage-x presets http://babeljs.io/docs/plugins/#presets"},whitelist:{message:"Put the specific transforms you want in the `plugins` option"},resolveModuleSource:{version:6,message:"Use `babel-plugin-module-resolver@3`'s 'resolvePath' options"},metadata:{version:6,message:"Generated plugin metadata is always included in the output result"},sourceMapTarget:{version:6,message:"The `sourceMapTarget` option has been removed because it makes more sense for the tooling that calls Babel to assign `map.file` themselves."}};},"./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/errors/config-error.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=void 0;var _rewriteStackTrace=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/errors/rewrite-stack-trace.js");class ConfigError extends Error{constructor(message,filename){super(message),(0, _rewriteStackTrace.expectedError)(this),filename&&(0, _rewriteStackTrace.injectVirtualStackFrame)(this,filename);}}exports.default=ConfigError;},"./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/errors/rewrite-stack-trace.js":(__unused_webpack_module,exports)=>{var _Object$getOwnPropert;Object.defineProperty(exports,"__esModule",{value:true}),exports.beginHiddenCallStack=function(fn){return SUPPORTED?Object.defineProperty((function(...args){return setupPrepareStackTrace(),fn(...args)}),"name",{value:STOP_HIDING}):fn},exports.endHiddenCallStack=function(fn){return SUPPORTED?Object.defineProperty((function(...args){return fn(...args)}),"name",{value:START_HIDING}):fn},exports.expectedError=function(error){if(!SUPPORTED)return;return expectedErrors.add(error),error},exports.injectVirtualStackFrame=function(error,filename){if(!SUPPORTED)return;let frames=virtualFrames.get(error);frames||virtualFrames.set(error,frames=[]);return frames.push(function(filename){return Object.create({isNative:()=>false,isConstructor:()=>false,isToplevel:()=>true,getFileName:()=>filename,getLineNumber:()=>{},getColumnNumber:()=>{},getFunctionName:()=>{},getMethodName:()=>{},getTypeName:()=>{},toString:()=>filename})}(filename)),error};const ErrorToString=Function.call.bind(Error.prototype.toString),SUPPORTED=!!Error.captureStackTrace&&true===(null==(_Object$getOwnPropert=Object.getOwnPropertyDescriptor(Error,"stackTraceLimit"))?void 0:_Object$getOwnPropert.writable),START_HIDING="startHiding - secret - don't use this - v1",STOP_HIDING="stopHiding - secret - don't use this - v1",expectedErrors=new WeakSet,virtualFrames=new WeakMap;function setupPrepareStackTrace(){setupPrepareStackTrace=()=>{};const{prepareStackTrace=defaultPrepareStackTrace}=Error;Error.stackTraceLimit&&(Error.stackTraceLimit=Math.max(Error.stackTraceLimit,50)),Error.prepareStackTrace=function(err,trace){let newTrace=[];let status=expectedErrors.has(err)?"hiding":"unknown";for(let i=0;i<trace.length;i++){const name=trace[i].getFunctionName();if(name===START_HIDING)status="hiding";else if(name===STOP_HIDING){if("hiding"===status)status="showing",virtualFrames.has(err)&&newTrace.unshift(...virtualFrames.get(err));else if("unknown"===status){newTrace=trace;break}}else "hiding"!==status&&newTrace.push(trace[i]);}return prepareStackTrace(err,newTrace)};}function defaultPrepareStackTrace(err,trace){return 0===trace.length?ErrorToString(err):`${ErrorToString(err)}\n    at ${trace.join("\n    at ")}`}},"./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/gensync-utils/async.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _gensync(){const data=__webpack_require__("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");return _gensync=function(){return data},data}function asyncGeneratorStep(n,t,e,r,o,a,c){try{var i=n[a](c),u=i.value;}catch(n){return void e(n)}i.done?t(u):Promise.resolve(u).then(r,o);}function _asyncToGenerator(n){return function(){var t=this,e=arguments;return new Promise((function(r,o){var a=n.apply(t,e);function _next(n){asyncGeneratorStep(a,r,o,_next,_throw,"next",n);}function _throw(n){asyncGeneratorStep(a,r,o,_next,_throw,"throw",n);}_next(void 0);}))}}Object.defineProperty(exports,"__esModule",{value:true}),exports.forwardAsync=function(action,cb){const g=_gensync()(action);return withKind((kind=>{const adapted=g[kind];return cb(adapted)}))},exports.isAsync=void 0,exports.isThenable=isThenable,exports.maybeAsync=function(fn,message){return _gensync()({sync(...args){const result=fn.apply(this,args);if(isThenable(result))throw new Error(message);return result},async(...args){return Promise.resolve(fn.apply(this,args))}})},exports.waitFor=exports.onFirstPause=void 0;const runGenerator=_gensync()((function*(item){return yield*item}));exports.isAsync=_gensync()({sync:()=>false,errback:cb=>cb(null,true)});const withKind=_gensync()({sync:cb=>cb("sync"),async:(_ref=_asyncToGenerator((function*(cb){return cb("async")})),function(_x){return _ref.apply(this,arguments)})});var _ref;exports.onFirstPause=_gensync()({name:"onFirstPause",arity:2,sync:function(item){return runGenerator.sync(item)},errback:function(item,firstPause,cb){let completed=false;runGenerator.errback(item,((err,value)=>{completed=true,cb(err,value);})),completed||firstPause();}}),exports.waitFor=_gensync()({sync:x=>x,async:(_ref2=_asyncToGenerator((function*(x){return x})),function(_x2){return _ref2.apply(this,arguments)})});var _ref2;function isThenable(val){return !(!val||"object"!=typeof val&&"function"!=typeof val||!val.then||"function"!=typeof val.then)}},"./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/gensync-utils/fs.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _fs(){const data=__webpack_require__("fs");return _fs=function(){return data},data}function _gensync(){const data=__webpack_require__("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");return _gensync=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:true}),exports.stat=exports.readFile=void 0;exports.readFile=_gensync()({sync:_fs().readFileSync,errback:_fs().readFile}),exports.stat=_gensync()({sync:_fs().statSync,errback:_fs().stat});},"./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/gensync-utils/functional.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.once=function(fn){let result,resultP,promiseReferenced=false;return function*(){if(!result){if(resultP)return promiseReferenced=true,yield*(0, _async.waitFor)(resultP);if(yield*(0, _async.isAsync)()){let resolve,reject;resultP=new Promise(((res,rej)=>{resolve=res,reject=rej;}));try{result={ok:!0,value:yield*fn()},resultP=null,promiseReferenced&&resolve(result.value);}catch(error){result={ok:false,value:error},resultP=null,promiseReferenced&&reject(error);}}else try{result={ok:!0,value:yield*fn()};}catch(error){result={ok:false,value:error};}}if(result.ok)return result.value;throw result.value}};var _async=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/gensync-utils/async.js");},"./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.DEFAULT_EXTENSIONS=void 0,Object.defineProperty(exports,"File",{enumerable:true,get:function(){return _file.default}}),Object.defineProperty(exports,"buildExternalHelpers",{enumerable:true,get:function(){return _buildExternalHelpers.default}}),Object.defineProperty(exports,"createConfigItem",{enumerable:true,get:function(){return _index2.createConfigItem}}),Object.defineProperty(exports,"createConfigItemAsync",{enumerable:true,get:function(){return _index2.createConfigItemAsync}}),Object.defineProperty(exports,"createConfigItemSync",{enumerable:true,get:function(){return _index2.createConfigItemSync}}),Object.defineProperty(exports,"getEnv",{enumerable:true,get:function(){return _environment.getEnv}}),Object.defineProperty(exports,"loadOptions",{enumerable:true,get:function(){return _index2.loadOptions}}),Object.defineProperty(exports,"loadOptionsAsync",{enumerable:true,get:function(){return _index2.loadOptionsAsync}}),Object.defineProperty(exports,"loadOptionsSync",{enumerable:true,get:function(){return _index2.loadOptionsSync}}),Object.defineProperty(exports,"loadPartialConfig",{enumerable:true,get:function(){return _index2.loadPartialConfig}}),Object.defineProperty(exports,"loadPartialConfigAsync",{enumerable:true,get:function(){return _index2.loadPartialConfigAsync}}),Object.defineProperty(exports,"loadPartialConfigSync",{enumerable:true,get:function(){return _index2.loadPartialConfigSync}}),Object.defineProperty(exports,"parse",{enumerable:true,get:function(){return _parse.parse}}),Object.defineProperty(exports,"parseAsync",{enumerable:true,get:function(){return _parse.parseAsync}}),Object.defineProperty(exports,"parseSync",{enumerable:true,get:function(){return _parse.parseSync}}),exports.resolvePreset=exports.resolvePlugin=void 0,Object.defineProperty(exports,"template",{enumerable:true,get:function(){return _template().default}}),Object.defineProperty(exports,"tokTypes",{enumerable:true,get:function(){return _parser().tokTypes}}),Object.defineProperty(exports,"transform",{enumerable:true,get:function(){return _transform.transform}}),Object.defineProperty(exports,"transformAsync",{enumerable:true,get:function(){return _transform.transformAsync}}),Object.defineProperty(exports,"transformFile",{enumerable:true,get:function(){return _transformFile.transformFile}}),Object.defineProperty(exports,"transformFileAsync",{enumerable:true,get:function(){return _transformFile.transformFileAsync}}),Object.defineProperty(exports,"transformFileSync",{enumerable:true,get:function(){return _transformFile.transformFileSync}}),Object.defineProperty(exports,"transformFromAst",{enumerable:true,get:function(){return _transformAst.transformFromAst}}),Object.defineProperty(exports,"transformFromAstAsync",{enumerable:true,get:function(){return _transformAst.transformFromAstAsync}}),Object.defineProperty(exports,"transformFromAstSync",{enumerable:true,get:function(){return _transformAst.transformFromAstSync}}),Object.defineProperty(exports,"transformSync",{enumerable:true,get:function(){return _transform.transformSync}}),Object.defineProperty(exports,"traverse",{enumerable:true,get:function(){return _traverse().default}}),exports.version=exports.types=void 0;var _file=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transformation/file/file.js"),_buildExternalHelpers=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/tools/build-external-helpers.js"),resolvers=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files/index.js"),_environment=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/helpers/environment.js");function _types(){const data=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js");return _types=function(){return data},data}function _parser(){const data=__webpack_require__("./node_modules/.pnpm/@babel+parser@7.26.3/node_modules/@babel/parser/lib/index.js");return _parser=function(){return data},data}function _traverse(){const data=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/index.js");return _traverse=function(){return data},data}function _template(){const data=__webpack_require__("./node_modules/.pnpm/@babel+template@7.25.9/node_modules/@babel/template/lib/index.js");return _template=function(){return data},data}Object.defineProperty(exports,"types",{enumerable:true,get:function(){return _types()}});var _index2=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/index.js"),_transform=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transform.js"),_transformFile=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transform-file.js"),_transformAst=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transform-ast.js"),_parse=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/parse.js");__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/index.js");exports.version="7.26.0";exports.resolvePlugin=(name,dirname)=>resolvers.resolvePlugin(name,dirname,false).filepath;exports.resolvePreset=(name,dirname)=>resolvers.resolvePreset(name,dirname,false).filepath;exports.DEFAULT_EXTENSIONS=Object.freeze([".js",".jsx",".es6",".es",".mjs",".cjs"]);exports.OptionManager=class{init(opts){return (0, _index2.loadOptionsSync)(opts)}},exports.Plugin=function(alias){throw new Error(`The (${alias}) Babel 5 plugin is being run with an unsupported Babel version.`)};},"./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/parse.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _gensync(){const data=__webpack_require__("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");return _gensync=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:true}),exports.parse=void 0,exports.parseAsync=function(...args){return (0, _rewriteStackTrace.beginHiddenCallStack)(parseRunner.async)(...args)},exports.parseSync=function(...args){return (0, _rewriteStackTrace.beginHiddenCallStack)(parseRunner.sync)(...args)};var _index=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/index.js"),_index2=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/parser/index.js"),_normalizeOpts=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transformation/normalize-opts.js"),_rewriteStackTrace=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/errors/rewrite-stack-trace.js");const parseRunner=_gensync()((function*(code,opts){const config=yield*(0, _index.default)(opts);return null===config?null:yield*(0, _index2.default)(config.passes,(0, _normalizeOpts.default)(config),code)}));exports.parse=function(code,opts,callback){if("function"==typeof opts&&(callback=opts,opts=void 0),void 0===callback)return (0, _rewriteStackTrace.beginHiddenCallStack)(parseRunner.sync)(code,opts);(0, _rewriteStackTrace.beginHiddenCallStack)(parseRunner.errback)(code,opts,callback);};},"./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/parser/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _parser(){const data=__webpack_require__("./node_modules/.pnpm/@babel+parser@7.26.3/node_modules/@babel/parser/lib/index.js");return _parser=function(){return data},data}function _codeFrame(){const data=__webpack_require__("./stubs/babel-codeframe.mjs");return _codeFrame=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function*(pluginPasses,{parserOpts,highlightCode=true,filename="unknown"},code){try{const results=[];for(const plugins of pluginPasses)for(const plugin of plugins){const{parserOverride}=plugin;if(parserOverride){const ast=parserOverride(code,parserOpts,_parser().parse);void 0!==ast&&results.push(ast);}}if(0===results.length)return (0,_parser().parse)(code,parserOpts);if(1===results.length){if(yield*[],"function"==typeof results[0].then)throw new Error("You appear to be using an async parser plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");return results[0]}throw new Error("More than one plugin attempted to override parsing.")}catch(err){"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"===err.code&&(err.message+="\nConsider renaming the file to '.mjs', or setting sourceType:module or sourceType:unambiguous in your Babel config for this file.");const{loc,missingPlugin}=err;if(loc){const codeFrame=(0, _codeFrame().codeFrameColumns)(code,{start:{line:loc.line,column:loc.column+1}},{highlightCode});err.message=missingPlugin?`${filename}: `+(0, _missingPluginHelper.default)(missingPlugin[0],loc,codeFrame,filename):`${filename}: ${err.message}\n\n`+codeFrame,err.code="BABEL_PARSE_ERROR";}throw err}};var _missingPluginHelper=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/parser/util/missing-plugin-helper.js");},"./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/parser/util/missing-plugin-helper.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(missingPluginName,loc,codeFrame,filename){let helpMessage=`Support for the experimental syntax '${missingPluginName}' isn't currently enabled (${loc.line}:${loc.column+1}):\n\n`+codeFrame;const pluginInfo=pluginNameMap[missingPluginName];if(pluginInfo){const{syntax:syntaxPlugin,transform:transformPlugin}=pluginInfo;if(syntaxPlugin){const syntaxPluginInfo=getNameURLCombination(syntaxPlugin);if(transformPlugin){helpMessage+=`\n\nAdd ${getNameURLCombination(transformPlugin)} to the '${transformPlugin.name.startsWith("@babel/plugin")?"plugins":"presets"}' section of your Babel config to enable transformation.\nIf you want to leave it as-is, add ${syntaxPluginInfo} to the 'plugins' section to enable parsing.`;}else helpMessage+=`\n\nAdd ${syntaxPluginInfo} to the 'plugins' section of your Babel config to enable parsing.`;}}return helpMessage+=`\n\nIf you already added the plugin for this syntax to your config, it's possible that your config isn't being loaded.\nYou can re-run Babel with the BABEL_SHOW_CONFIG_FOR environment variable to show the loaded configuration:\n\tnpx cross-env BABEL_SHOW_CONFIG_FOR=${filename==="unknown"?"<name of the input file>":filename} <your build command>\nSee https://babeljs.io/docs/configuration#print-effective-configs for more info.\n`,helpMessage};const pluginNameMap={asyncDoExpressions:{syntax:{name:"@babel/plugin-syntax-async-do-expressions",url:"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-async-do-expressions"}},decimal:{syntax:{name:"@babel/plugin-syntax-decimal",url:"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-decimal"}},decorators:{syntax:{name:"@babel/plugin-syntax-decorators",url:"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-decorators"},transform:{name:"@babel/plugin-proposal-decorators",url:"https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-decorators"}},doExpressions:{syntax:{name:"@babel/plugin-syntax-do-expressions",url:"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-do-expressions"},transform:{name:"@babel/plugin-proposal-do-expressions",url:"https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-do-expressions"}},exportDefaultFrom:{syntax:{name:"@babel/plugin-syntax-export-default-from",url:"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-export-default-from"},transform:{name:"@babel/plugin-proposal-export-default-from",url:"https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-export-default-from"}},flow:{syntax:{name:"@babel/plugin-syntax-flow",url:"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-flow"},transform:{name:"@babel/preset-flow",url:"https://github.com/babel/babel/tree/main/packages/babel-preset-flow"}},functionBind:{syntax:{name:"@babel/plugin-syntax-function-bind",url:"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-function-bind"},transform:{name:"@babel/plugin-proposal-function-bind",url:"https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-function-bind"}},functionSent:{syntax:{name:"@babel/plugin-syntax-function-sent",url:"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-function-sent"},transform:{name:"@babel/plugin-proposal-function-sent",url:"https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-function-sent"}},jsx:{syntax:{name:"@babel/plugin-syntax-jsx",url:"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-jsx"},transform:{name:"@babel/preset-react",url:"https://github.com/babel/babel/tree/main/packages/babel-preset-react"}},pipelineOperator:{syntax:{name:"@babel/plugin-syntax-pipeline-operator",url:"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-pipeline-operator"},transform:{name:"@babel/plugin-proposal-pipeline-operator",url:"https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-pipeline-operator"}},recordAndTuple:{syntax:{name:"@babel/plugin-syntax-record-and-tuple",url:"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-record-and-tuple"}},throwExpressions:{syntax:{name:"@babel/plugin-syntax-throw-expressions",url:"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-throw-expressions"},transform:{name:"@babel/plugin-proposal-throw-expressions",url:"https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-throw-expressions"}},typescript:{syntax:{name:"@babel/plugin-syntax-typescript",url:"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-typescript"},transform:{name:"@babel/preset-typescript",url:"https://github.com/babel/babel/tree/main/packages/babel-preset-typescript"}}};Object.assign(pluginNameMap,{asyncGenerators:{syntax:{name:"@babel/plugin-syntax-async-generators",url:"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-async-generators"},transform:{name:"@babel/plugin-transform-async-generator-functions",url:"https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-async-generator-functions"}},classProperties:{syntax:{name:"@babel/plugin-syntax-class-properties",url:"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties"},transform:{name:"@babel/plugin-transform-class-properties",url:"https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-class-properties"}},classPrivateProperties:{syntax:{name:"@babel/plugin-syntax-class-properties",url:"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties"},transform:{name:"@babel/plugin-transform-class-properties",url:"https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-class-properties"}},classPrivateMethods:{syntax:{name:"@babel/plugin-syntax-class-properties",url:"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties"},transform:{name:"@babel/plugin-transform-private-methods",url:"https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-private-methods"}},classStaticBlock:{syntax:{name:"@babel/plugin-syntax-class-static-block",url:"https://github.com/babel/babel/tree/HEAD/packages/babel-plugin-syntax-class-static-block"},transform:{name:"@babel/plugin-transform-class-static-block",url:"https://github.com/babel/babel/tree/HEAD/packages/babel-plugin-transform-class-static-block"}},dynamicImport:{syntax:{name:"@babel/plugin-syntax-dynamic-import",url:"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-dynamic-import"}},exportNamespaceFrom:{syntax:{name:"@babel/plugin-syntax-export-namespace-from",url:"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-export-namespace-from"},transform:{name:"@babel/plugin-transform-export-namespace-from",url:"https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-export-namespace-from"}},importAssertions:{syntax:{name:"@babel/plugin-syntax-import-assertions",url:"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-assertions"}},importAttributes:{syntax:{name:"@babel/plugin-syntax-import-attributes",url:"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-attributes"}},importMeta:{syntax:{name:"@babel/plugin-syntax-import-meta",url:"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-meta"}},logicalAssignment:{syntax:{name:"@babel/plugin-syntax-logical-assignment-operators",url:"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-logical-assignment-operators"},transform:{name:"@babel/plugin-transform-logical-assignment-operators",url:"https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-logical-assignment-operators"}},moduleStringNames:{syntax:{name:"@babel/plugin-syntax-module-string-names",url:"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-module-string-names"}},numericSeparator:{syntax:{name:"@babel/plugin-syntax-numeric-separator",url:"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-numeric-separator"},transform:{name:"@babel/plugin-transform-numeric-separator",url:"https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-numeric-separator"}},nullishCoalescingOperator:{syntax:{name:"@babel/plugin-syntax-nullish-coalescing-operator",url:"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-nullish-coalescing-operator"},transform:{name:"@babel/plugin-transform-nullish-coalescing-operator",url:"https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-nullish-coalescing-opearator"}},objectRestSpread:{syntax:{name:"@babel/plugin-syntax-object-rest-spread",url:"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-object-rest-spread"},transform:{name:"@babel/plugin-transform-object-rest-spread",url:"https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-object-rest-spread"}},optionalCatchBinding:{syntax:{name:"@babel/plugin-syntax-optional-catch-binding",url:"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-optional-catch-binding"},transform:{name:"@babel/plugin-transform-optional-catch-binding",url:"https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-optional-catch-binding"}},optionalChaining:{syntax:{name:"@babel/plugin-syntax-optional-chaining",url:"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-optional-chaining"},transform:{name:"@babel/plugin-transform-optional-chaining",url:"https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-optional-chaining"}},privateIn:{syntax:{name:"@babel/plugin-syntax-private-property-in-object",url:"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-private-property-in-object"},transform:{name:"@babel/plugin-transform-private-property-in-object",url:"https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-private-property-in-object"}},regexpUnicodeSets:{syntax:{name:"@babel/plugin-syntax-unicode-sets-regex",url:"https://github.com/babel/babel/blob/main/packages/babel-plugin-syntax-unicode-sets-regex/README.md"},transform:{name:"@babel/plugin-transform-unicode-sets-regex",url:"https://github.com/babel/babel/blob/main/packages/babel-plugin-proposalunicode-sets-regex/README.md"}}});const getNameURLCombination=({name,url})=>`${name} (${url})`;},"./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/tools/build-external-helpers.js":(__unused_webpack_module,exports,__webpack_require__)=>{function helpers(){const data=__webpack_require__("./node_modules/.pnpm/@babel+helpers@7.26.0/node_modules/@babel/helpers/lib/index.js");return helpers=function(){return data},data}function _generator(){const data=__webpack_require__("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/index.js");return _generator=function(){return data},data}function _template(){const data=__webpack_require__("./node_modules/.pnpm/@babel+template@7.25.9/node_modules/@babel/template/lib/index.js");return _template=function(){return data},data}function _t(){const data=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js");return _t=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(allowlist,outputType="global"){let tree;const build={global:buildGlobal,module:buildModule,umd:buildUmd,var:buildVar}[outputType];if(!build)throw new Error(`Unsupported output type ${outputType}`);tree=build(allowlist);return (0, _generator().default)(tree).code};const{arrayExpression,assignmentExpression,binaryExpression,blockStatement,callExpression,cloneNode,conditionalExpression,exportNamedDeclaration,exportSpecifier,expressionStatement,functionExpression,identifier,memberExpression,objectExpression,program,stringLiteral,unaryExpression,variableDeclaration,variableDeclarator}=_t(),buildUmdWrapper=replacements=>_template().default.statement`
    (function (root, factory) {
      if (typeof define === "function" && define.amd) {
        define(AMD_ARGUMENTS, factory);
      } else if (typeof exports === "object") {
        factory(COMMON_ARGUMENTS);
      } else {
        factory(BROWSER_ARGUMENTS);
      }
    })(UMD_ROOT, function (FACTORY_PARAMETERS) {
      FACTORY_BODY
    });
  `(replacements);function buildGlobal(allowlist){const namespace=identifier("babelHelpers"),body=[],container=functionExpression(null,[identifier("global")],blockStatement(body)),tree=program([expressionStatement(callExpression(container,[conditionalExpression(binaryExpression("===",unaryExpression("typeof",identifier("global")),stringLiteral("undefined")),identifier("self"),identifier("global"))]))]);return body.push(variableDeclaration("var",[variableDeclarator(namespace,assignmentExpression("=",memberExpression(identifier("global"),namespace),objectExpression([])))])),buildHelpers(body,namespace,allowlist),tree}function buildModule(allowlist){const body=[],refs=buildHelpers(body,null,allowlist);return body.unshift(exportNamedDeclaration(null,Object.keys(refs).map((name=>exportSpecifier(cloneNode(refs[name]),identifier(name)))))),program(body,[],"module")}function buildUmd(allowlist){const namespace=identifier("babelHelpers"),body=[];return body.push(variableDeclaration("var",[variableDeclarator(namespace,identifier("global"))])),buildHelpers(body,namespace,allowlist),program([buildUmdWrapper({FACTORY_PARAMETERS:identifier("global"),BROWSER_ARGUMENTS:assignmentExpression("=",memberExpression(identifier("root"),namespace),objectExpression([])),COMMON_ARGUMENTS:identifier("exports"),AMD_ARGUMENTS:arrayExpression([stringLiteral("exports")]),FACTORY_BODY:body,UMD_ROOT:identifier("this")})])}function buildVar(allowlist){const namespace=identifier("babelHelpers"),body=[];body.push(variableDeclaration("var",[variableDeclarator(namespace,objectExpression([]))]));const tree=program(body);return buildHelpers(body,namespace,allowlist),body.push(expressionStatement(namespace)),tree}function buildHelpers(body,namespace,allowlist){const getHelperReference=name=>namespace?memberExpression(namespace,identifier(name)):identifier(`_${name}`),refs={};return helpers().list.forEach((function(name){if(allowlist&&!allowlist.includes(name))return;const ref=refs[name]=getHelperReference(name),{nodes}=helpers().get(name,getHelperReference,namespace?null:`_${name}`,[],namespace?(ast,exportName,mapExportBindingAssignments)=>{mapExportBindingAssignments((node=>assignmentExpression("=",ref,node))),ast.body.push(expressionStatement(assignmentExpression("=",ref,identifier(exportName))));}:null);body.push(...nodes);})),refs}},"./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transform-ast.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _gensync(){const data=__webpack_require__("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");return _gensync=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:true}),exports.transformFromAst=void 0,exports.transformFromAstAsync=function(...args){return (0, _rewriteStackTrace.beginHiddenCallStack)(transformFromAstRunner.async)(...args)},exports.transformFromAstSync=function(...args){return (0, _rewriteStackTrace.beginHiddenCallStack)(transformFromAstRunner.sync)(...args)};var _index=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/index.js"),_index2=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transformation/index.js"),_rewriteStackTrace=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/errors/rewrite-stack-trace.js");const transformFromAstRunner=_gensync()((function*(ast,code,opts){const config=yield*(0, _index.default)(opts);if(null===config)return null;if(!ast)throw new Error("No AST given");return yield*(0, _index2.run)(config,code,ast)}));exports.transformFromAst=function(ast,code,optsOrCallback,maybeCallback){let opts,callback;if("function"==typeof optsOrCallback?(callback=optsOrCallback,opts=void 0):(opts=optsOrCallback,callback=maybeCallback),void 0===callback)return (0, _rewriteStackTrace.beginHiddenCallStack)(transformFromAstRunner.sync)(ast,code,opts);(0, _rewriteStackTrace.beginHiddenCallStack)(transformFromAstRunner.errback)(ast,code,opts,callback);};},"./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transform-file.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _gensync(){const data=__webpack_require__("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");return _gensync=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:true}),exports.transformFile=function(...args){transformFileRunner.errback(...args);},exports.transformFileAsync=function(...args){return transformFileRunner.async(...args)},exports.transformFileSync=function(...args){return transformFileRunner.sync(...args)};var _index=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/index.js"),_index2=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transformation/index.js"),fs=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/gensync-utils/fs.js");const transformFileRunner=_gensync()((function*(filename,opts){const options=Object.assign({},opts,{filename}),config=yield*(0, _index.default)(options);if(null===config)return null;const code=yield*fs.readFile(filename,"utf8");return yield*(0, _index2.run)(config,code)}));},"./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transform.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _gensync(){const data=__webpack_require__("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");return _gensync=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:true}),exports.transform=void 0,exports.transformAsync=function(...args){return (0, _rewriteStackTrace.beginHiddenCallStack)(transformRunner.async)(...args)},exports.transformSync=function(...args){return (0, _rewriteStackTrace.beginHiddenCallStack)(transformRunner.sync)(...args)};var _index=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/index.js"),_index2=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transformation/index.js"),_rewriteStackTrace=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/errors/rewrite-stack-trace.js");const transformRunner=_gensync()((function*(code,opts){const config=yield*(0, _index.default)(opts);return null===config?null:yield*(0, _index2.run)(config,code)}));exports.transform=function(code,optsOrCallback,maybeCallback){let opts,callback;if("function"==typeof optsOrCallback?(callback=optsOrCallback,opts=void 0):(opts=optsOrCallback,callback=maybeCallback),void 0===callback)return (0, _rewriteStackTrace.beginHiddenCallStack)(transformRunner.sync)(code,opts);(0, _rewriteStackTrace.beginHiddenCallStack)(transformRunner.errback)(code,opts,callback);};},"./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transformation/block-hoist-plugin.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _traverse(){const data=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/index.js");return _traverse=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(){LOADED_PLUGIN||(LOADED_PLUGIN=new _plugin.default(Object.assign({},blockHoistPlugin,{visitor:_traverse().default.explode(blockHoistPlugin.visitor)}),{}));return LOADED_PLUGIN};var _plugin=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/plugin.js");let LOADED_PLUGIN;const blockHoistPlugin={name:"internal.blockHoist",visitor:{Block:{exit({node}){node.body=performHoisting(node.body);}},SwitchCase:{exit({node}){node.consequent=performHoisting(node.consequent);}}}};function performHoisting(body){let max=Math.pow(2,30)-1,hasChange=false;for(let i=0;i<body.length;i++){const p=priority(body[i]);if(p>max){hasChange=true;break}max=p;}return hasChange?function(body){const buckets=Object.create(null);for(let i=0;i<body.length;i++){const n=body[i],p=priority(n);(buckets[p]||(buckets[p]=[])).push(n);}const keys=Object.keys(buckets).map((k=>+k)).sort(((a,b)=>b-a));let index=0;for(const key of keys){const bucket=buckets[key];for(const n of bucket)body[index++]=n;}return body}(body.slice()):body}function priority(bodyNode){const priority=null==bodyNode?void 0:bodyNode._blockHoist;return null==priority?1:true===priority?2:priority}},"./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transformation/file/babel-7-helpers.cjs":(__unused_webpack_module,exports,__webpack_require__)=>{exports.getModuleName=()=>__webpack_require__("./node_modules/.pnpm/@babel+helper-module-transforms@7.26.0_@babel+core@7.26.0/node_modules/@babel/helper-module-transforms/lib/index.js").getModuleName;},"./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transformation/file/file.js":(__unused_webpack_module,exports,__webpack_require__)=>{function helpers(){const data=__webpack_require__("./node_modules/.pnpm/@babel+helpers@7.26.0/node_modules/@babel/helpers/lib/index.js");return helpers=function(){return data},data}function _traverse(){const data=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/index.js");return _traverse=function(){return data},data}function _codeFrame(){const data=__webpack_require__("./stubs/babel-codeframe.mjs");return _codeFrame=function(){return data},data}function _t(){const data=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js");return _t=function(){return data},data}function _semver(){const data=__webpack_require__("./node_modules/.pnpm/semver@6.3.1/node_modules/semver/semver.js");return _semver=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:true}),exports.default=void 0;var babel7=function(e,r){if(null===e||"object"!=typeof e&&"function"!=typeof e)return {default:e};var t=_getRequireWildcardCache(r);if(t&&t.has(e))return t.get(e);var n={__proto__:null},a=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var u in e)if("default"!==u&&{}.hasOwnProperty.call(e,u)){var i=a?Object.getOwnPropertyDescriptor(e,u):null;i&&(i.get||i.set)?Object.defineProperty(n,u,i):n[u]=e[u];}return n.default=e,t&&t.set(e,n),n}(__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transformation/file/babel-7-helpers.cjs"),true);function _getRequireWildcardCache(e){if("function"!=typeof WeakMap)return null;var r=new WeakMap,t=new WeakMap;return (_getRequireWildcardCache=function(e){return e?t:r})(e)}const{cloneNode,interpreterDirective}=_t(),errorVisitor={enter(path,state){const loc=path.node.loc;loc&&(state.loc=loc,path.stop());}};class File{constructor(options,{code,ast,inputMap}){this._map=new Map,this.opts=void 0,this.declarations={},this.path=void 0,this.ast=void 0,this.scope=void 0,this.metadata={},this.code="",this.inputMap=void 0,this.hub={file:this,getCode:()=>this.code,getScope:()=>this.scope,addHelper:this.addHelper.bind(this),buildError:this.buildCodeFrameError.bind(this)},this.opts=options,this.code=code,this.ast=ast,this.inputMap=inputMap,this.path=_traverse().NodePath.get({hub:this.hub,parentPath:null,parent:this.ast,container:this.ast,key:"program"}).setContext(),this.scope=this.path.scope;}get shebang(){const{interpreter}=this.path.node;return interpreter?interpreter.value:""}set shebang(value){value?this.path.get("interpreter").replaceWith(interpreterDirective(value)):this.path.get("interpreter").remove();}set(key,val){if("helpersNamespace"===key)throw new Error("Babel 7.0.0-beta.56 has dropped support for the 'helpersNamespace' utility.If you are using @babel/plugin-external-helpers you will need to use a newer version than the one you currently have installed. If you have your own implementation, you'll want to explore using 'helperGenerator' alongside 'file.availableHelper()'.");this._map.set(key,val);}get(key){return this._map.get(key)}has(key){return this._map.has(key)}availableHelper(name,versionRange){let minVersion;try{minVersion=helpers().minVersion(name);}catch(err){if("BABEL_HELPER_UNKNOWN"!==err.code)throw err;return  false}return "string"!=typeof versionRange||(_semver().valid(versionRange)&&(versionRange=`^${versionRange}`),!_semver().intersects(`<${minVersion}`,versionRange)&&!_semver().intersects(">=8.0.0",versionRange))}addHelper(name){const declar=this.declarations[name];if(declar)return cloneNode(declar);const generator=this.get("helperGenerator");if(generator){const res=generator(name);if(res)return res}helpers().minVersion(name);const uid=this.declarations[name]=this.scope.generateUidIdentifier(name),dependencies={};for(const dep of helpers().getDependencies(name))dependencies[dep]=this.addHelper(dep);const{nodes,globals}=helpers().get(name,(dep=>dependencies[dep]),uid.name,Object.keys(this.scope.getAllBindings()));globals.forEach((name=>{this.path.scope.hasBinding(name,true)&&this.path.scope.rename(name);})),nodes.forEach((node=>{node._compact=true;}));const added=this.path.unshiftContainer("body",nodes);for(const path of added)path.isVariableDeclaration()&&this.scope.registerDeclaration(path);return uid}buildCodeFrameError(node,msg,_Error=SyntaxError){let loc=null==node?void 0:node.loc;if(!loc&&node){const state={loc:null};(0, _traverse().default)(node,errorVisitor,this.scope,state),loc=state.loc;let txt="This is an error on an internal node. Probably an internal error.";loc&&(txt+=" Location has been estimated."),msg+=` (${txt})`;}if(loc){const{highlightCode=true}=this.opts;msg+="\n"+(0, _codeFrame().codeFrameColumns)(this.code,{start:{line:loc.start.line,column:loc.start.column+1},end:loc.end&&loc.start.line===loc.end.line?{line:loc.end.line,column:loc.end.column+1}:void 0},{highlightCode});}return new _Error(msg)}}exports.default=File,File.prototype.addImport=function(){throw new Error("This API has been removed. If you're looking for this functionality in Babel 7, you should import the '@babel/helper-module-imports' module and use the functions exposed  from that module, such as 'addNamed' or 'addDefault'.")},File.prototype.addTemplateObject=function(){throw new Error("This function has been moved into the template literal transform itself.")},File.prototype.getModuleName=function(){return babel7.getModuleName()(this.opts,this.opts)};},"./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transformation/file/generate.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _convertSourceMap(){const data=__webpack_require__("./node_modules/.pnpm/convert-source-map@2.0.0/node_modules/convert-source-map/index.js");return _convertSourceMap=function(){return data},data}function _generator(){const data=__webpack_require__("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/index.js");return _generator=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(pluginPasses,file){const{opts,ast,code,inputMap}=file,{generatorOpts}=opts;generatorOpts.inputSourceMap=null==inputMap?void 0:inputMap.toObject();const results=[];for(const plugins of pluginPasses)for(const plugin of plugins){const{generatorOverride}=plugin;if(generatorOverride){const result=generatorOverride(ast,generatorOpts,code,_generator().default);void 0!==result&&results.push(result);}}let result;if(0===results.length)result=(0, _generator().default)(ast,generatorOpts,code);else {if(1!==results.length)throw new Error("More than one plugin attempted to override codegen.");if(result=results[0],"function"==typeof result.then)throw new Error("You appear to be using an async codegen plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.")}let{code:outputCode,decodedMap:outputMap=result.map}=result;result.__mergedMap?outputMap=Object.assign({},result.map):outputMap&&(outputMap=inputMap?(0, _mergeMap.default)(inputMap.toObject(),outputMap,generatorOpts.sourceFileName):result.map);"inline"!==opts.sourceMaps&&"both"!==opts.sourceMaps||(outputCode+="\n"+_convertSourceMap().fromObject(outputMap).toComment());"inline"===opts.sourceMaps&&(outputMap=null);return {outputCode,outputMap}};var _mergeMap=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transformation/file/merge-map.js");},"./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transformation/file/merge-map.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _remapping(){const data=__webpack_require__("./node_modules/.pnpm/@ampproject+remapping@2.3.0/node_modules/@ampproject/remapping/dist/remapping.umd.js");return _remapping=function(){return data},data}function rootless(map){return Object.assign({},map,{sourceRoot:null})}Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(inputMap,map,sourceFileName){const source=sourceFileName.replace(/\\/g,"/");let found=false;const result=_remapping()(rootless(map),((s,ctx)=>s!==source||found?null:(found=true,ctx.source="",rootless(inputMap))));"string"==typeof inputMap.sourceRoot&&(result.sourceRoot=inputMap.sourceRoot);return Object.assign({},result)};},"./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transformation/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _traverse(){const data=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/index.js");return _traverse=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:true}),exports.run=function*(config,code,ast){const file=yield*(0, _normalizeFile.default)(config.passes,(0, _normalizeOpts.default)(config),code,ast),opts=file.opts;try{yield*function*(file,pluginPasses){const async=yield*(0,_async.isAsync)();for(const pluginPairs of pluginPasses){const passPairs=[],passes=[],visitors=[];for(const plugin of pluginPairs.concat([(0,_blockHoistPlugin.default)()])){const pass=new _pluginPass.default(file,plugin.key,plugin.options,async);passPairs.push([plugin,pass]),passes.push(pass),visitors.push(plugin.visitor);}for(const[plugin,pass]of passPairs)if(plugin.pre){const fn=(0,_async.maybeAsync)(plugin.pre,"You appear to be using an async plugin/preset, but Babel has been called synchronously");yield*fn.call(pass,file);}const visitor=_traverse().default.visitors.merge(visitors,passes,file.opts.wrapPluginVisitorMethod);(0,_traverse().default)(file.ast,visitor,file.scope);for(const[plugin,pass]of passPairs)if(plugin.post){const fn=(0,_async.maybeAsync)(plugin.post,"You appear to be using an async plugin/preset, but Babel has been called synchronously");yield*fn.call(pass,file);}}}(file,config.passes);}catch(e){var _opts$filename;throw e.message=`${null!=(_opts$filename=opts.filename)?_opts$filename:"unknown file"}: ${e.message}`,e.code||(e.code="BABEL_TRANSFORM_ERROR"),e}let outputCode,outputMap;try{!1!==opts.code&&({outputCode,outputMap}=(0,_generate.default)(config.passes,file));}catch(e){var _opts$filename2;throw e.message=`${null!=(_opts$filename2=opts.filename)?_opts$filename2:"unknown file"}: ${e.message}`,e.code||(e.code="BABEL_GENERATE_ERROR"),e}return {metadata:file.metadata,options:opts,ast:true===opts.ast?file.ast:null,code:void 0===outputCode?null:outputCode,map:void 0===outputMap?null:outputMap,sourceType:file.ast.program.sourceType,externalDependencies:(0, _deepArray.flattenToSet)(config.externalDependencies)}};var _pluginPass=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transformation/plugin-pass.js"),_blockHoistPlugin=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transformation/block-hoist-plugin.js"),_normalizeOpts=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transformation/normalize-opts.js"),_normalizeFile=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transformation/normalize-file.js"),_generate=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transformation/file/generate.js"),_deepArray=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/helpers/deep-array.js"),_async=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/gensync-utils/async.js");},"./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transformation/normalize-file.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _fs(){const data=__webpack_require__("fs");return _fs=function(){return data},data}function _path(){const data=__webpack_require__("path");return _path=function(){return data},data}function _debug(){const data=__webpack_require__("./node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/index.js");return _debug=function(){return data},data}function _t(){const data=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js");return _t=function(){return data},data}function _convertSourceMap(){const data=__webpack_require__("./node_modules/.pnpm/convert-source-map@2.0.0/node_modules/convert-source-map/index.js");return _convertSourceMap=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function*(pluginPasses,options,code,ast){if(code=`${code||""}`,ast){if("Program"===ast.type)ast=file(ast,[],[]);else if("File"!==ast.type)throw new Error("AST root must be a Program or File node");options.cloneInputAst&&(ast=(0, _cloneDeep.default)(ast));}else ast=yield*(0, _index.default)(pluginPasses,options,code);let inputMap=null;if(false!==options.inputSourceMap){if("object"==typeof options.inputSourceMap&&(inputMap=_convertSourceMap().fromObject(options.inputSourceMap)),!inputMap){const lastComment=extractComments(INLINE_SOURCEMAP_REGEX,ast);if(lastComment)try{inputMap=_convertSourceMap().fromComment("//"+lastComment);}catch(err){debug("discarding unknown inline input sourcemap");}}if(!inputMap){const lastComment=extractComments(EXTERNAL_SOURCEMAP_REGEX,ast);if("string"==typeof options.filename&&lastComment)try{const match=EXTERNAL_SOURCEMAP_REGEX.exec(lastComment),inputMapContent=_fs().readFileSync(_path().resolve(_path().dirname(options.filename),match[1]),"utf8");inputMap=_convertSourceMap().fromJSON(inputMapContent);}catch(err){debug("discarding unknown file input sourcemap",err);}else lastComment&&debug("discarding un-loadable file input sourcemap");}}return new _file.default(options,{code,ast,inputMap})};var _file=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transformation/file/file.js"),_index=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/parser/index.js"),_cloneDeep=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transformation/util/clone-deep.js");const{file,traverseFast}=_t(),debug=_debug()("babel:transform:file"),INLINE_SOURCEMAP_REGEX=/^[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,.*$/,EXTERNAL_SOURCEMAP_REGEX=/^[@#][ \t]+sourceMappingURL=([^\s'"`]+)[ \t]*$/;function extractCommentsFromList(regex,comments,lastComment){return comments&&(comments=comments.filter((({value})=>!regex.test(value)||(lastComment=value,false)))),[comments,lastComment]}function extractComments(regex,ast){let lastComment=null;return traverseFast(ast,(node=>{[node.leadingComments,lastComment]=extractCommentsFromList(regex,node.leadingComments,lastComment),[node.innerComments,lastComment]=extractCommentsFromList(regex,node.innerComments,lastComment),[node.trailingComments,lastComment]=extractCommentsFromList(regex,node.trailingComments,lastComment);})),lastComment}},"./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transformation/normalize-opts.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _path(){const data=__webpack_require__("path");return _path=function(){return data},data}Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(config){const{filename,cwd,filenameRelative="string"==typeof filename?_path().relative(cwd,filename):"unknown",sourceType="module",inputSourceMap,sourceMaps=!!inputSourceMap,sourceRoot=config.options.moduleRoot,sourceFileName=_path().basename(filenameRelative),comments=true,compact="auto"}=config.options,opts=config.options,options=Object.assign({},opts,{parserOpts:Object.assign({sourceType:".mjs"===_path().extname(filenameRelative)?"module":sourceType,sourceFileName:filename,plugins:[]},opts.parserOpts),generatorOpts:Object.assign({filename,auxiliaryCommentBefore:opts.auxiliaryCommentBefore,auxiliaryCommentAfter:opts.auxiliaryCommentAfter,retainLines:opts.retainLines,comments,shouldPrintComment:opts.shouldPrintComment,compact,minified:opts.minified,sourceMaps,sourceRoot,sourceFileName},opts.generatorOpts)});for(const plugins of config.passes)for(const plugin of plugins)plugin.manipulateOptions&&plugin.manipulateOptions(options,options.parserOpts);return options};},"./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transformation/plugin-pass.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=void 0;class PluginPass{constructor(file,key,options,isAsync){this._map=new Map,this.key=void 0,this.file=void 0,this.opts=void 0,this.cwd=void 0,this.filename=void 0,this.isAsync=void 0,this.key=key,this.file=file,this.opts=options||{},this.cwd=file.opts.cwd,this.filename=file.opts.filename,this.isAsync=isAsync;}set(key,val){this._map.set(key,val);}get(key){return this._map.get(key)}availableHelper(name,versionRange){return this.file.availableHelper(name,versionRange)}addHelper(name){return this.file.addHelper(name)}buildCodeFrameError(node,msg,_Error){return this.file.buildCodeFrameError(node,msg,_Error)}}exports.default=PluginPass,PluginPass.prototype.getModuleName=function(){return this.file.getModuleName()},PluginPass.prototype.addImport=function(){this.file.addImport();};},"./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transformation/util/clone-deep.js":(__unused_webpack_module,exports)=>{function deepClone(value,cache){if(null!==value){if(cache.has(value))return cache.get(value);let cloned;if(Array.isArray(value)){cloned=new Array(value.length),cache.set(value,cloned);for(let i=0;i<value.length;i++)cloned[i]="object"!=typeof value[i]?value[i]:deepClone(value[i],cache);}else {cloned={},cache.set(value,cloned);const keys=Object.keys(value);for(let i=0;i<keys.length;i++){const key=keys[i];cloned[key]="object"!=typeof value[key]?value[key]:deepClone(value[key],cache);}}return cloned}return value}Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(value){return "object"!=typeof value?value:deepClone(value,new Map)};},"./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/vendor/import-meta-resolve.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _assert(){const data=__webpack_require__("assert");return _assert=function(){return data},data}function _fs(){const data=function(e,r){if(null===e||"object"!=typeof e&&"function"!=typeof e)return {default:e};var t=_getRequireWildcardCache(r);if(t&&t.has(e))return t.get(e);var n={__proto__:null},a=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var u in e)if("default"!==u&&{}.hasOwnProperty.call(e,u)){var i=a?Object.getOwnPropertyDescriptor(e,u):null;i&&(i.get||i.set)?Object.defineProperty(n,u,i):n[u]=e[u];}return n.default=e,t&&t.set(e,n),n}(__webpack_require__("fs"),true);return _fs=function(){return data},data}function _process(){const data=__webpack_require__("process");return _process=function(){return data},data}function _url(){const data=__webpack_require__("url");return _url=function(){return data},data}function _path(){const data=__webpack_require__("path");return _path=function(){return data},data}function _module(){const data=__webpack_require__("module");return _module=function(){return data},data}function _v(){const data=__webpack_require__("v8");return _v=function(){return data},data}function _util(){const data=__webpack_require__("util");return _util=function(){return data},data}function _getRequireWildcardCache(e){if("function"!=typeof WeakMap)return null;var r=new WeakMap,t=new WeakMap;return (_getRequireWildcardCache=function(e){return e?t:r})(e)}Object.defineProperty(exports,"__esModule",{value:true}),exports.moduleResolve=moduleResolve,exports.resolve=function(specifier,parent){if(!parent)throw new Error("Please pass `parent`: `import-meta-resolve` cannot ponyfill that");try{return function(specifier,context={}){const{parentURL}=context;let parsedParentURL,parsed,protocol;if(_assert()(void 0!==parentURL,"expected `parentURL` to be defined"),function(parentURL){if(void 0===parentURL)return;if("string"!=typeof parentURL&&(self=parentURL,!Boolean(self&&"object"==typeof self&&"href"in self&&"string"==typeof self.href&&"protocol"in self&&"string"==typeof self.protocol&&self.href&&self.protocol)))throw new codes.ERR_INVALID_ARG_TYPE("parentURL",["string","URL"],parentURL);var self;}(parentURL),parentURL)try{parsedParentURL=new(_url().URL)(parentURL);}catch(_unused4){}try{if(parsed=shouldBeTreatedAsRelativeOrAbsolutePath(specifier)?new(_url().URL)(specifier,parsedParentURL):new(_url().URL)(specifier),protocol=parsed.protocol,"data:"===protocol)return {url:parsed.href,format:null}}catch(_unused5){}const maybeReturn=function(specifier,parsed,parsedParentURL){if(parsedParentURL){const parentProtocol=parsedParentURL.protocol;if("http:"===parentProtocol||"https:"===parentProtocol){if(shouldBeTreatedAsRelativeOrAbsolutePath(specifier)){const parsedProtocol=null==parsed?void 0:parsed.protocol;if(parsedProtocol&&"https:"!==parsedProtocol&&"http:"!==parsedProtocol)throw new ERR_NETWORK_IMPORT_DISALLOWED(specifier,parsedParentURL,"remote imports cannot import from a local location.");return {url:(null==parsed?void 0:parsed.href)||""}}if(_module().builtinModules.includes(specifier))throw new ERR_NETWORK_IMPORT_DISALLOWED(specifier,parsedParentURL,"remote imports cannot import from a local location.");throw new ERR_NETWORK_IMPORT_DISALLOWED(specifier,parsedParentURL,"only relative and absolute specifiers are supported.")}}}(specifier,parsed,parsedParentURL);if(maybeReturn)return maybeReturn;void 0===protocol&&parsed&&(protocol=parsed.protocol);if("node:"===protocol)return {url:specifier};if(parsed&&"node:"===parsed.protocol)return {url:specifier};const conditions=function(conditions){if(void 0!==conditions&&conditions!==DEFAULT_CONDITIONS){if(!Array.isArray(conditions))throw new ERR_INVALID_ARG_VALUE("conditions",conditions,"expected an array");return new Set(conditions)}return DEFAULT_CONDITIONS_SET}(context.conditions),url=moduleResolve(specifier,new(_url().URL)(parentURL),conditions,!1);return {url:url.href,format:defaultGetFormatWithoutErrors(url,{parentURL})}}(specifier,{parentURL:parent}).url}catch(error){const exception=error;if(("ERR_UNSUPPORTED_DIR_IMPORT"===exception.code||"ERR_MODULE_NOT_FOUND"===exception.code)&&"string"==typeof exception.url)return exception.url;throw error}};const own$1={}.hasOwnProperty,classRegExp=/^([A-Z][a-z\d]*)+$/,kTypes=new Set(["string","function","number","object","Function","Object","boolean","bigint","symbol"]),codes={};function formatList(array,type="and"){return array.length<3?array.join(` ${type} `):`${array.slice(0,-1).join(", ")}, ${type} ${array[array.length-1]}`}const messages=new Map;let userStackTraceLimit;function createError(sym,value,constructor){return messages.set(sym,value),function(Base,key){return NodeError;function NodeError(...parameters){const limit=Error.stackTraceLimit;isErrorStackTraceLimitWritable()&&(Error.stackTraceLimit=0);const error=new Base;isErrorStackTraceLimitWritable()&&(Error.stackTraceLimit=limit);const message=function(key,parameters,self){const message=messages.get(key);if(_assert()(void 0!==message,"expected `message` to be found"),"function"==typeof message)return _assert()(message.length<=parameters.length,`Code: ${key}; The provided arguments length (${parameters.length}) does not match the required ones (${message.length}).`),Reflect.apply(message,self,parameters);const regex=/%[dfijoOs]/g;let expectedLength=0;for(;null!==regex.exec(message);)expectedLength++;return _assert()(expectedLength===parameters.length,`Code: ${key}; The provided arguments length (${parameters.length}) does not match the required ones (${expectedLength}).`),0===parameters.length?message:(parameters.unshift(message),Reflect.apply(_util().format,null,parameters))}(key,parameters,error);return Object.defineProperties(error,{message:{value:message,enumerable:false,writable:true,configurable:true},toString:{value(){return `${this.name} [${key}]: ${this.message}`},enumerable:false,writable:true,configurable:true}}),captureLargerStackTrace(error),error.code=key,error}}(constructor,sym)}function isErrorStackTraceLimitWritable(){try{if(_v().startupSnapshot.isBuildingSnapshot())return !1}catch(_unused){}const desc=Object.getOwnPropertyDescriptor(Error,"stackTraceLimit");return void 0===desc?Object.isExtensible(Error):own$1.call(desc,"writable")&&void 0!==desc.writable?desc.writable:void 0!==desc.set}codes.ERR_INVALID_ARG_TYPE=createError("ERR_INVALID_ARG_TYPE",((name,expected,actual)=>{_assert()("string"==typeof name,"'name' must be a string"),Array.isArray(expected)||(expected=[expected]);let message="The ";if(name.endsWith(" argument"))message+=`${name} `;else {const type=name.includes(".")?"property":"argument";message+=`"${name}" ${type} `;}message+="must be ";const types=[],instances=[],other=[];for(const value of expected)_assert()("string"==typeof value,"All expected entries have to be of type string"),kTypes.has(value)?types.push(value.toLowerCase()):null===classRegExp.exec(value)?(_assert()("object"!==value,'The value "object" should be written as "Object"'),other.push(value)):instances.push(value);if(instances.length>0){const pos=types.indexOf("object");-1!==pos&&(types.slice(pos,1),instances.push("Object"));}return types.length>0&&(message+=`${types.length>1?"one of type":"of type"} ${formatList(types,"or")}`,(instances.length>0||other.length>0)&&(message+=" or ")),instances.length>0&&(message+=`an instance of ${formatList(instances,"or")}`,other.length>0&&(message+=" or ")),other.length>0&&(other.length>1?message+=`one of ${formatList(other,"or")}`:(other[0].toLowerCase()!==other[0]&&(message+="an "),message+=`${other[0]}`)),message+=`. Received ${function(value){if(null==value)return String(value);if("function"==typeof value&&value.name)return `function ${value.name}`;if("object"==typeof value)return value.constructor&&value.constructor.name?`an instance of ${value.constructor.name}`:`${(0, _util().inspect)(value,{depth:-1})}`;let inspected=(0, _util().inspect)(value,{colors:false});inspected.length>28&&(inspected=`${inspected.slice(0,25)}...`);return `type ${typeof value} (${inspected})`}(actual)}`,message}),TypeError),codes.ERR_INVALID_MODULE_SPECIFIER=createError("ERR_INVALID_MODULE_SPECIFIER",((request,reason,base=void 0)=>`Invalid module "${request}" ${reason}${base?` imported from ${base}`:""}`),TypeError),codes.ERR_INVALID_PACKAGE_CONFIG=createError("ERR_INVALID_PACKAGE_CONFIG",((path,base,message)=>`Invalid package config ${path}${base?` while importing ${base}`:""}${message?`. ${message}`:""}`),Error),codes.ERR_INVALID_PACKAGE_TARGET=createError("ERR_INVALID_PACKAGE_TARGET",((packagePath,key,target,isImport=false,base=void 0)=>{const relatedError="string"==typeof target&&!isImport&&target.length>0&&!target.startsWith("./");return "."===key?(_assert()(false===isImport),`Invalid "exports" main target ${JSON.stringify(target)} defined in the package config ${packagePath}package.json${base?` imported from ${base}`:""}${relatedError?'; targets must start with "./"':""}`):`Invalid "${isImport?"imports":"exports"}" target ${JSON.stringify(target)} defined for '${key}' in the package config ${packagePath}package.json${base?` imported from ${base}`:""}${relatedError?'; targets must start with "./"':""}`}),Error),codes.ERR_MODULE_NOT_FOUND=createError("ERR_MODULE_NOT_FOUND",((path,base,exactUrl=false)=>`Cannot find ${exactUrl?"module":"package"} '${path}' imported from ${base}`),Error),codes.ERR_NETWORK_IMPORT_DISALLOWED=createError("ERR_NETWORK_IMPORT_DISALLOWED","import of '%s' by %s is not supported: %s",Error),codes.ERR_PACKAGE_IMPORT_NOT_DEFINED=createError("ERR_PACKAGE_IMPORT_NOT_DEFINED",((specifier,packagePath,base)=>`Package import specifier "${specifier}" is not defined${packagePath?` in package ${packagePath}package.json`:""} imported from ${base}`),TypeError),codes.ERR_PACKAGE_PATH_NOT_EXPORTED=createError("ERR_PACKAGE_PATH_NOT_EXPORTED",((packagePath,subpath,base=void 0)=>"."===subpath?`No "exports" main defined in ${packagePath}package.json${base?` imported from ${base}`:""}`:`Package subpath '${subpath}' is not defined by "exports" in ${packagePath}package.json${base?` imported from ${base}`:""}`),Error),codes.ERR_UNSUPPORTED_DIR_IMPORT=createError("ERR_UNSUPPORTED_DIR_IMPORT","Directory import '%s' is not supported resolving ES modules imported from %s",Error),codes.ERR_UNSUPPORTED_RESOLVE_REQUEST=createError("ERR_UNSUPPORTED_RESOLVE_REQUEST",'Failed to resolve module specifier "%s" from "%s": Invalid relative URL or base scheme is not hierarchical.',TypeError),codes.ERR_UNKNOWN_FILE_EXTENSION=createError("ERR_UNKNOWN_FILE_EXTENSION",((extension,path)=>`Unknown file extension "${extension}" for ${path}`),TypeError),codes.ERR_INVALID_ARG_VALUE=createError("ERR_INVALID_ARG_VALUE",((name,value,reason="is invalid")=>{let inspected=(0, _util().inspect)(value);inspected.length>128&&(inspected=`${inspected.slice(0,128)}...`);return `The ${name.includes(".")?"property":"argument"} '${name}' ${reason}. Received ${inspected}`}),TypeError);const captureLargerStackTrace=function(wrappedFunction){const hidden="__node_internal_"+wrappedFunction.name;return Object.defineProperty(wrappedFunction,"name",{value:hidden}),wrappedFunction}((function(error){const stackTraceLimitIsWritable=isErrorStackTraceLimitWritable();return stackTraceLimitIsWritable&&(userStackTraceLimit=Error.stackTraceLimit,Error.stackTraceLimit=Number.POSITIVE_INFINITY),Error.captureStackTrace(error),stackTraceLimitIsWritable&&(Error.stackTraceLimit=userStackTraceLimit),error}));const hasOwnProperty$1={}.hasOwnProperty,{ERR_INVALID_PACKAGE_CONFIG:ERR_INVALID_PACKAGE_CONFIG$1}=codes,cache=new Map;function read(jsonPath,{base,specifier}){const existing=cache.get(jsonPath);if(existing)return existing;let string;try{string=_fs().default.readFileSync(_path().toNamespacedPath(jsonPath),"utf8");}catch(error){const exception=error;if("ENOENT"!==exception.code)throw exception}const result={exists:false,pjsonPath:jsonPath,main:void 0,name:void 0,type:"none",exports:void 0,imports:void 0};if(void 0!==string){let parsed;try{parsed=JSON.parse(string);}catch(error_){const cause=error_,error=new ERR_INVALID_PACKAGE_CONFIG$1(jsonPath,(base?`"${specifier}" from `:"")+(0, _url().fileURLToPath)(base||specifier),cause.message);throw error.cause=cause,error}result.exists=true,hasOwnProperty$1.call(parsed,"name")&&"string"==typeof parsed.name&&(result.name=parsed.name),hasOwnProperty$1.call(parsed,"main")&&"string"==typeof parsed.main&&(result.main=parsed.main),hasOwnProperty$1.call(parsed,"exports")&&(result.exports=parsed.exports),hasOwnProperty$1.call(parsed,"imports")&&(result.imports=parsed.imports),!hasOwnProperty$1.call(parsed,"type")||"commonjs"!==parsed.type&&"module"!==parsed.type||(result.type=parsed.type);}return cache.set(jsonPath,result),result}function getPackageScopeConfig(resolved){let packageJSONUrl=new URL("package.json",resolved);for(;;){if(packageJSONUrl.pathname.endsWith("node_modules/package.json"))break;const packageConfig=read((0, _url().fileURLToPath)(packageJSONUrl),{specifier:resolved});if(packageConfig.exists)return packageConfig;const lastPackageJSONUrl=packageJSONUrl;if(packageJSONUrl=new URL("../package.json",packageJSONUrl),packageJSONUrl.pathname===lastPackageJSONUrl.pathname)break}return {pjsonPath:(0, _url().fileURLToPath)(packageJSONUrl),exists:false,type:"none"}}function getPackageType(url){return getPackageScopeConfig(url).type}const{ERR_UNKNOWN_FILE_EXTENSION}=codes,hasOwnProperty={}.hasOwnProperty,extensionFormatMap={__proto__:null,".cjs":"commonjs",".js":"module",".json":"json",".mjs":"module"};const protocolHandlers={__proto__:null,"data:":function(parsed){const{1:mime}=/^([^/]+\/[^;,]+)[^,]*?(;base64)?,/.exec(parsed.pathname)||[null,null,null];return function(mime){return mime&&/\s*(text|application)\/javascript\s*(;\s*charset=utf-?8\s*)?/i.test(mime)?"module":"application/json"===mime?"json":null}(mime)},"file:":function(url,_context,ignoreErrors){const value=function(url){const pathname=url.pathname;let index=pathname.length;for(;index--;){const code=pathname.codePointAt(index);if(47===code)return "";if(46===code)return 47===pathname.codePointAt(index-1)?"":pathname.slice(index)}return ""}(url);if(".js"===value){const packageType=getPackageType(url);return "none"!==packageType?packageType:"commonjs"}if(""===value){const packageType=getPackageType(url);return "none"===packageType||"commonjs"===packageType?"commonjs":"module"}const format=extensionFormatMap[value];if(format)return format;if(ignoreErrors)return;const filepath=(0, _url().fileURLToPath)(url);throw new ERR_UNKNOWN_FILE_EXTENSION(value,filepath)},"http:":getHttpProtocolModuleFormat,"https:":getHttpProtocolModuleFormat,"node:":()=>"builtin"};function getHttpProtocolModuleFormat(){}function defaultGetFormatWithoutErrors(url,context){const protocol=url.protocol;return hasOwnProperty.call(protocolHandlers,protocol)&&protocolHandlers[protocol](url,context,true)||null}const{ERR_INVALID_ARG_VALUE}=codes,DEFAULT_CONDITIONS=Object.freeze(["node","import"]),DEFAULT_CONDITIONS_SET=new Set(DEFAULT_CONDITIONS);const RegExpPrototypeSymbolReplace=RegExp.prototype[Symbol.replace],{ERR_NETWORK_IMPORT_DISALLOWED,ERR_INVALID_MODULE_SPECIFIER,ERR_INVALID_PACKAGE_CONFIG,ERR_INVALID_PACKAGE_TARGET,ERR_MODULE_NOT_FOUND,ERR_PACKAGE_IMPORT_NOT_DEFINED,ERR_PACKAGE_PATH_NOT_EXPORTED,ERR_UNSUPPORTED_DIR_IMPORT,ERR_UNSUPPORTED_RESOLVE_REQUEST}=codes,own={}.hasOwnProperty,invalidSegmentRegEx=/(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))?(\\|\/|$)/i,deprecatedInvalidSegmentRegEx=/(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i,invalidPackageNameRegEx=/^\.|%|\\/,patternRegEx=/\*/g,encodedSeparatorRegEx=/%2f|%5c/i,emittedPackageWarnings=new Set,doubleSlashRegEx=/[/\\]{2}/;function emitInvalidSegmentDeprecation(target,request,match,packageJsonUrl,internal,base,isTarget){if(_process().noDeprecation)return;const pjsonPath=(0, _url().fileURLToPath)(packageJsonUrl),double=null!==doubleSlashRegEx.exec(isTarget?target:request);_process().emitWarning(`Use of deprecated ${double?"double slash":"leading or trailing slash matching"} resolving "${target}" for module request "${request}" ${request===match?"":`matched to "${match}" `}in the "${internal?"imports":"exports"}" field module resolution of the package at ${pjsonPath}${base?` imported from ${(0, _url().fileURLToPath)(base)}`:""}.`,"DeprecationWarning","DEP0166");}function emitLegacyIndexDeprecation(url,packageJsonUrl,base,main){if(_process().noDeprecation)return;if("module"!==defaultGetFormatWithoutErrors(url,{parentURL:base.href}))return;const urlPath=(0, _url().fileURLToPath)(url.href),packagePath=(0, _url().fileURLToPath)(new(_url().URL)(".",packageJsonUrl)),basePath=(0, _url().fileURLToPath)(base);main?_path().resolve(packagePath,main)!==urlPath&&_process().emitWarning(`Package ${packagePath} has a "main" field set to "${main}", excluding the full filename and extension to the resolved file at "${urlPath.slice(packagePath.length)}", imported from ${basePath}.\n Automatic extension resolution of the "main" field is deprecated for ES modules.`,"DeprecationWarning","DEP0151"):_process().emitWarning(`No "main" or "exports" field defined in the package.json for ${packagePath} resolving the main entry point "${urlPath.slice(packagePath.length)}", imported from ${basePath}.\nDefault "index" lookups for the main are deprecated for ES modules.`,"DeprecationWarning","DEP0151");}function tryStatSync(path){try{return (0,_fs().statSync)(path)}catch(_unused2){}}function fileExists(url){const stats=(0, _fs().statSync)(url,{throwIfNoEntry:false}),isFile=stats?stats.isFile():void 0;return null!=isFile&&isFile}function legacyMainResolve(packageJsonUrl,packageConfig,base){let guess;if(void 0!==packageConfig.main){if(guess=new(_url().URL)(packageConfig.main,packageJsonUrl),fileExists(guess))return guess;const tries=[`./${packageConfig.main}.js`,`./${packageConfig.main}.json`,`./${packageConfig.main}.node`,`./${packageConfig.main}/index.js`,`./${packageConfig.main}/index.json`,`./${packageConfig.main}/index.node`];let i=-1;for(;++i<tries.length&&(guess=new(_url().URL)(tries[i],packageJsonUrl),!fileExists(guess));)guess=void 0;if(guess)return emitLegacyIndexDeprecation(guess,packageJsonUrl,base,packageConfig.main),guess}const tries=["./index.js","./index.json","./index.node"];let i=-1;for(;++i<tries.length&&(guess=new(_url().URL)(tries[i],packageJsonUrl),!fileExists(guess));)guess=void 0;if(guess)return emitLegacyIndexDeprecation(guess,packageJsonUrl,base,packageConfig.main),guess;throw new ERR_MODULE_NOT_FOUND((0, _url().fileURLToPath)(new(_url().URL)(".",packageJsonUrl)),(0, _url().fileURLToPath)(base))}function exportsNotFound(subpath,packageJsonUrl,base){return new ERR_PACKAGE_PATH_NOT_EXPORTED((0, _url().fileURLToPath)(new(_url().URL)(".",packageJsonUrl)),subpath,base&&(0, _url().fileURLToPath)(base))}function invalidPackageTarget(subpath,target,packageJsonUrl,internal,base){return target="object"==typeof target&&null!==target?JSON.stringify(target,null,""):`${target}`,new ERR_INVALID_PACKAGE_TARGET((0, _url().fileURLToPath)(new(_url().URL)(".",packageJsonUrl)),subpath,target,internal,base&&(0, _url().fileURLToPath)(base))}function resolvePackageTargetString(target,subpath,match,packageJsonUrl,base,pattern,internal,isPathMap,conditions){if(""!==subpath&&!pattern&&"/"!==target[target.length-1])throw invalidPackageTarget(match,target,packageJsonUrl,internal,base);if(!target.startsWith("./")){if(internal&&!target.startsWith("../")&&!target.startsWith("/")){let isURL=false;try{new(_url().URL)(target),isURL=!0;}catch(_unused3){}if(!isURL){return packageResolve(pattern?RegExpPrototypeSymbolReplace.call(patternRegEx,target,(()=>subpath)):target+subpath,packageJsonUrl,conditions)}}throw invalidPackageTarget(match,target,packageJsonUrl,internal,base)}if(null!==invalidSegmentRegEx.exec(target.slice(2))){if(null!==deprecatedInvalidSegmentRegEx.exec(target.slice(2)))throw invalidPackageTarget(match,target,packageJsonUrl,internal,base);if(!isPathMap){const request=pattern?match.replace("*",(()=>subpath)):match+subpath;emitInvalidSegmentDeprecation(pattern?RegExpPrototypeSymbolReplace.call(patternRegEx,target,(()=>subpath)):target,request,match,packageJsonUrl,internal,base,true);}}const resolved=new(_url().URL)(target,packageJsonUrl),resolvedPath=resolved.pathname,packagePath=new(_url().URL)(".",packageJsonUrl).pathname;if(!resolvedPath.startsWith(packagePath))throw invalidPackageTarget(match,target,packageJsonUrl,internal,base);if(""===subpath)return resolved;if(null!==invalidSegmentRegEx.exec(subpath)){const request=pattern?match.replace("*",(()=>subpath)):match+subpath;if(null===deprecatedInvalidSegmentRegEx.exec(subpath)){if(!isPathMap){emitInvalidSegmentDeprecation(pattern?RegExpPrototypeSymbolReplace.call(patternRegEx,target,(()=>subpath)):target,request,match,packageJsonUrl,internal,base,false);}}else !function(request,match,packageJsonUrl,internal,base){const reason=`request is not a valid match in pattern "${match}" for the "${internal?"imports":"exports"}" resolution of ${(0, _url().fileURLToPath)(packageJsonUrl)}`;throw new ERR_INVALID_MODULE_SPECIFIER(request,reason,base&&(0, _url().fileURLToPath)(base))}(request,match,packageJsonUrl,internal,base);}return pattern?new(_url().URL)(RegExpPrototypeSymbolReplace.call(patternRegEx,resolved.href,(()=>subpath))):new(_url().URL)(subpath,resolved)}function isArrayIndex(key){const keyNumber=Number(key);return `${keyNumber}`===key&&(keyNumber>=0&&keyNumber<4294967295)}function resolvePackageTarget(packageJsonUrl,target,subpath,packageSubpath,base,pattern,internal,isPathMap,conditions){if("string"==typeof target)return resolvePackageTargetString(target,subpath,packageSubpath,packageJsonUrl,base,pattern,internal,isPathMap,conditions);if(Array.isArray(target)){const targetList=target;if(0===targetList.length)return null;let lastException,i=-1;for(;++i<targetList.length;){const targetItem=targetList[i];let resolveResult;try{resolveResult=resolvePackageTarget(packageJsonUrl,targetItem,subpath,packageSubpath,base,pattern,internal,isPathMap,conditions);}catch(error){if(lastException=error,"ERR_INVALID_PACKAGE_TARGET"===error.code)continue;throw error}if(void 0!==resolveResult){if(null!==resolveResult)return resolveResult;lastException=null;}}if(null==lastException)return null;throw lastException}if("object"==typeof target&&null!==target){const keys=Object.getOwnPropertyNames(target);let i=-1;for(;++i<keys.length;){if(isArrayIndex(keys[i]))throw new ERR_INVALID_PACKAGE_CONFIG((0, _url().fileURLToPath)(packageJsonUrl),base,'"exports" cannot contain numeric property keys.')}for(i=-1;++i<keys.length;){const key=keys[i];if("default"===key||conditions&&conditions.has(key)){const resolveResult=resolvePackageTarget(packageJsonUrl,target[key],subpath,packageSubpath,base,pattern,internal,isPathMap,conditions);if(void 0===resolveResult)continue;return resolveResult}}return null}if(null===target)return null;throw invalidPackageTarget(packageSubpath,target,packageJsonUrl,internal,base)}function emitTrailingSlashPatternDeprecation(match,pjsonUrl,base){if(_process().noDeprecation)return;const pjsonPath=(0, _url().fileURLToPath)(pjsonUrl);emittedPackageWarnings.has(pjsonPath+"|"+match)||(emittedPackageWarnings.add(pjsonPath+"|"+match),_process().emitWarning(`Use of deprecated trailing slash pattern mapping "${match}" in the "exports" field module resolution of the package at ${pjsonPath}${base?` imported from ${(0, _url().fileURLToPath)(base)}`:""}. Mapping specifiers ending in "/" is no longer supported.`,"DeprecationWarning","DEP0155"));}function packageExportsResolve(packageJsonUrl,packageSubpath,packageConfig,base,conditions){let exports=packageConfig.exports;if(function(exports,packageJsonUrl,base){if("string"==typeof exports||Array.isArray(exports))return  true;if("object"!=typeof exports||null===exports)return  false;const keys=Object.getOwnPropertyNames(exports);let isConditionalSugar=false,i=0,keyIndex=-1;for(;++keyIndex<keys.length;){const key=keys[keyIndex],currentIsConditionalSugar=""===key||"."!==key[0];if(0==i++)isConditionalSugar=currentIsConditionalSugar;else if(isConditionalSugar!==currentIsConditionalSugar)throw new ERR_INVALID_PACKAGE_CONFIG((0, _url().fileURLToPath)(packageJsonUrl),base,"\"exports\" cannot contain some keys starting with '.' and some not. The exports object must either be an object of package subpath keys or an object of main entry condition name keys only.")}return isConditionalSugar}(exports,packageJsonUrl,base)&&(exports={".":exports}),own.call(exports,packageSubpath)&&!packageSubpath.includes("*")&&!packageSubpath.endsWith("/")){const resolveResult=resolvePackageTarget(packageJsonUrl,exports[packageSubpath],"",packageSubpath,base,false,false,false,conditions);if(null==resolveResult)throw exportsNotFound(packageSubpath,packageJsonUrl,base);return resolveResult}let bestMatch="",bestMatchSubpath="";const keys=Object.getOwnPropertyNames(exports);let i=-1;for(;++i<keys.length;){const key=keys[i],patternIndex=key.indexOf("*");if(-1!==patternIndex&&packageSubpath.startsWith(key.slice(0,patternIndex))){packageSubpath.endsWith("/")&&emitTrailingSlashPatternDeprecation(packageSubpath,packageJsonUrl,base);const patternTrailer=key.slice(patternIndex+1);packageSubpath.length>=key.length&&packageSubpath.endsWith(patternTrailer)&&1===patternKeyCompare(bestMatch,key)&&key.lastIndexOf("*")===patternIndex&&(bestMatch=key,bestMatchSubpath=packageSubpath.slice(patternIndex,packageSubpath.length-patternTrailer.length));}}if(bestMatch){const resolveResult=resolvePackageTarget(packageJsonUrl,exports[bestMatch],bestMatchSubpath,bestMatch,base,true,false,packageSubpath.endsWith("/"),conditions);if(null==resolveResult)throw exportsNotFound(packageSubpath,packageJsonUrl,base);return resolveResult}throw exportsNotFound(packageSubpath,packageJsonUrl,base)}function patternKeyCompare(a,b){const aPatternIndex=a.indexOf("*"),bPatternIndex=b.indexOf("*"),baseLengthA=-1===aPatternIndex?a.length:aPatternIndex+1,baseLengthB=-1===bPatternIndex?b.length:bPatternIndex+1;return baseLengthA>baseLengthB?-1:baseLengthB>baseLengthA||-1===aPatternIndex?1:-1===bPatternIndex||a.length>b.length?-1:b.length>a.length?1:0}function packageImportsResolve(name,base,conditions){if("#"===name||name.startsWith("#/")||name.endsWith("/")){throw new ERR_INVALID_MODULE_SPECIFIER(name,"is not a valid internal imports specifier name",(0, _url().fileURLToPath)(base))}let packageJsonUrl;const packageConfig=getPackageScopeConfig(base);if(packageConfig.exists){packageJsonUrl=(0, _url().pathToFileURL)(packageConfig.pjsonPath);const imports=packageConfig.imports;if(imports)if(own.call(imports,name)&&!name.includes("*")){const resolveResult=resolvePackageTarget(packageJsonUrl,imports[name],"",name,base,false,true,false,conditions);if(null!=resolveResult)return resolveResult}else {let bestMatch="",bestMatchSubpath="";const keys=Object.getOwnPropertyNames(imports);let i=-1;for(;++i<keys.length;){const key=keys[i],patternIndex=key.indexOf("*");if(-1!==patternIndex&&name.startsWith(key.slice(0,-1))){const patternTrailer=key.slice(patternIndex+1);name.length>=key.length&&name.endsWith(patternTrailer)&&1===patternKeyCompare(bestMatch,key)&&key.lastIndexOf("*")===patternIndex&&(bestMatch=key,bestMatchSubpath=name.slice(patternIndex,name.length-patternTrailer.length));}}if(bestMatch){const resolveResult=resolvePackageTarget(packageJsonUrl,imports[bestMatch],bestMatchSubpath,bestMatch,base,true,true,false,conditions);if(null!=resolveResult)return resolveResult}}}throw function(specifier,packageJsonUrl,base){return new ERR_PACKAGE_IMPORT_NOT_DEFINED(specifier,packageJsonUrl&&(0, _url().fileURLToPath)(new(_url().URL)(".",packageJsonUrl)),(0, _url().fileURLToPath)(base))}(name,packageJsonUrl,base)}function packageResolve(specifier,base,conditions){if(_module().builtinModules.includes(specifier))return new(_url().URL)("node:"+specifier);const{packageName,packageSubpath,isScoped}=function(specifier,base){let separatorIndex=specifier.indexOf("/"),validPackageName=true,isScoped=false;"@"===specifier[0]&&(isScoped=true,-1===separatorIndex||0===specifier.length?validPackageName=false:separatorIndex=specifier.indexOf("/",separatorIndex+1));const packageName=-1===separatorIndex?specifier:specifier.slice(0,separatorIndex);if(null!==invalidPackageNameRegEx.exec(packageName)&&(validPackageName=false),!validPackageName)throw new ERR_INVALID_MODULE_SPECIFIER(specifier,"is not a valid package name",(0, _url().fileURLToPath)(base));return {packageName,packageSubpath:"."+(-1===separatorIndex?"":specifier.slice(separatorIndex)),isScoped}}(specifier,base),packageConfig=getPackageScopeConfig(base);if(packageConfig.exists){const packageJsonUrl=(0, _url().pathToFileURL)(packageConfig.pjsonPath);if(packageConfig.name===packageName&&void 0!==packageConfig.exports&&null!==packageConfig.exports)return packageExportsResolve(packageJsonUrl,packageSubpath,packageConfig,base,conditions)}let lastPath,packageJsonUrl=new(_url().URL)("./node_modules/"+packageName+"/package.json",base),packageJsonPath=(0, _url().fileURLToPath)(packageJsonUrl);do{const stat=tryStatSync(packageJsonPath.slice(0,-13));if(!stat||!stat.isDirectory()){lastPath=packageJsonPath,packageJsonUrl=new(_url().URL)((isScoped?"../../../../node_modules/":"../../../node_modules/")+packageName+"/package.json",packageJsonUrl),packageJsonPath=(0, _url().fileURLToPath)(packageJsonUrl);continue}const packageConfig=read(packageJsonPath,{base,specifier});return void 0!==packageConfig.exports&&null!==packageConfig.exports?packageExportsResolve(packageJsonUrl,packageSubpath,packageConfig,base,conditions):"."===packageSubpath?legacyMainResolve(packageJsonUrl,packageConfig,base):new(_url().URL)(packageSubpath,packageJsonUrl)}while(packageJsonPath.length!==lastPath.length);throw new ERR_MODULE_NOT_FOUND(packageName,(0, _url().fileURLToPath)(base),false)}function shouldBeTreatedAsRelativeOrAbsolutePath(specifier){return ""!==specifier&&("/"===specifier[0]||function(specifier){if("."===specifier[0]){if(1===specifier.length||"/"===specifier[1])return  true;if("."===specifier[1]&&(2===specifier.length||"/"===specifier[2]))return  true}return  false}(specifier))}function moduleResolve(specifier,base,conditions,preserveSymlinks){const protocol=base.protocol,isRemote="data:"===protocol||"http:"===protocol||"https:"===protocol;let resolved;if(shouldBeTreatedAsRelativeOrAbsolutePath(specifier))try{resolved=new(_url().URL)(specifier,base);}catch(error_){const error=new ERR_UNSUPPORTED_RESOLVE_REQUEST(specifier,base);throw error.cause=error_,error}else if("file:"===protocol&&"#"===specifier[0])resolved=packageImportsResolve(specifier,base,conditions);else try{resolved=new(_url().URL)(specifier);}catch(error_){if(isRemote&&!_module().builtinModules.includes(specifier)){const error=new ERR_UNSUPPORTED_RESOLVE_REQUEST(specifier,base);throw error.cause=error_,error}resolved=packageResolve(specifier,base,conditions);}return _assert()(void 0!==resolved,"expected to be defined"),"file:"!==resolved.protocol?resolved:function(resolved,base,preserveSymlinks){if(null!==encodedSeparatorRegEx.exec(resolved.pathname))throw new ERR_INVALID_MODULE_SPECIFIER(resolved.pathname,'must not include encoded "/" or "\\" characters',(0, _url().fileURLToPath)(base));let filePath;try{filePath=(0,_url().fileURLToPath)(resolved);}catch(error){const cause=error;throw Object.defineProperty(cause,"input",{value:String(resolved)}),Object.defineProperty(cause,"module",{value:String(base)}),cause}const stats=tryStatSync(filePath.endsWith("/")?filePath.slice(-1):filePath);if(stats&&stats.isDirectory()){const error=new ERR_UNSUPPORTED_DIR_IMPORT(filePath,(0, _url().fileURLToPath)(base));throw error.url=String(resolved),error}if(!stats||!stats.isFile()){const error=new ERR_MODULE_NOT_FOUND(filePath||resolved.pathname,base&&(0, _url().fileURLToPath)(base),true);throw error.url=String(resolved),error}if(!preserveSymlinks){const real=(0, _fs().realpathSync)(filePath),{search,hash}=resolved;(resolved=(0, _url().pathToFileURL)(real+(filePath.endsWith(_path().sep)?"/":""))).search=search,resolved.hash=hash;}return resolved}(resolved,base,preserveSymlinks)}},"./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/buffer.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=void 0;exports.default=class{constructor(map,indentChar){this._map=null,this._buf="",this._str="",this._appendCount=0,this._last=0,this._queue=[],this._queueCursor=0,this._canMarkIdName=true,this._indentChar="",this._fastIndentations=[],this._position={line:1,column:0},this._sourcePosition={identifierName:void 0,identifierNamePos:void 0,line:void 0,column:void 0,filename:void 0},this._map=map,this._indentChar=indentChar;for(let i=0;i<64;i++)this._fastIndentations.push(indentChar.repeat(i));this._allocQueue();}_allocQueue(){const queue=this._queue;for(let i=0;i<16;i++)queue.push({char:0,repeat:1,line:void 0,column:void 0,identifierName:void 0,identifierNamePos:void 0,filename:""});}_pushQueue(char,repeat,line,column,filename){const cursor=this._queueCursor;cursor===this._queue.length&&this._allocQueue();const item=this._queue[cursor];item.char=char,item.repeat=repeat,item.line=line,item.column=column,item.filename=filename,this._queueCursor++;}_popQueue(){if(0===this._queueCursor)throw new Error("Cannot pop from empty queue");return this._queue[--this._queueCursor]}get(){this._flush();const map=this._map,result={code:(this._buf+this._str).trimRight(),decodedMap:null==map?void 0:map.getDecoded(),get __mergedMap(){return this.map},get map(){const resultMap=map?map.get():null;return result.map=resultMap,resultMap},set map(value){Object.defineProperty(result,"map",{value,writable:true});},get rawMappings(){const mappings=null==map?void 0:map.getRawMappings();return result.rawMappings=mappings,mappings},set rawMappings(value){Object.defineProperty(result,"rawMappings",{value,writable:true});}};return result}append(str,maybeNewline){this._flush(),this._append(str,this._sourcePosition,maybeNewline);}appendChar(char){this._flush(),this._appendChar(char,1,this._sourcePosition);}queue(char){if(10===char)for(;0!==this._queueCursor;){const char=this._queue[this._queueCursor-1].char;if(32!==char&&9!==char)break;this._queueCursor--;}const sourcePosition=this._sourcePosition;this._pushQueue(char,1,sourcePosition.line,sourcePosition.column,sourcePosition.filename);}queueIndentation(repeat){0!==repeat&&this._pushQueue(-1,repeat,void 0,void 0,void 0);}_flush(){const queueCursor=this._queueCursor,queue=this._queue;for(let i=0;i<queueCursor;i++){const item=queue[i];this._appendChar(item.char,item.repeat,item);}this._queueCursor=0;}_appendChar(char,repeat,sourcePos){if(this._last=char,-1===char){const fastIndentation=this._fastIndentations[repeat];this._str+=void 0!==fastIndentation?fastIndentation:repeat>1?this._indentChar.repeat(repeat):this._indentChar;}else this._str+=repeat>1?String.fromCharCode(char).repeat(repeat):String.fromCharCode(char);10!==char?(this._mark(sourcePos.line,sourcePos.column,sourcePos.identifierName,sourcePos.identifierNamePos,sourcePos.filename),this._position.column+=repeat):(this._position.line++,this._position.column=0),this._canMarkIdName&&(sourcePos.identifierName=void 0,sourcePos.identifierNamePos=void 0);}_append(str,sourcePos,maybeNewline){const len=str.length,position=this._position;if(this._last=str.charCodeAt(len-1),++this._appendCount>4096?(this._str,this._buf+=this._str,this._str=str,this._appendCount=0):this._str+=str,!maybeNewline&&!this._map)return void(position.column+=len);const{column,identifierName,identifierNamePos,filename}=sourcePos;let line=sourcePos.line;null==identifierName&&null==identifierNamePos||!this._canMarkIdName||(sourcePos.identifierName=void 0,sourcePos.identifierNamePos=void 0);let i=str.indexOf("\n"),last=0;for(0!==i&&this._mark(line,column,identifierName,identifierNamePos,filename);-1!==i;)position.line++,position.column=0,last=i+1,last<len&&void 0!==line&&this._mark(++line,0,null,null,filename),i=str.indexOf("\n",last);position.column+=len-last;}_mark(line,column,identifierName,identifierNamePos,filename){var _this$_map;null==(_this$_map=this._map)||_this$_map.mark(this._position,line,column,identifierName,identifierNamePos,filename);}removeTrailingNewline(){const queueCursor=this._queueCursor;0!==queueCursor&&10===this._queue[queueCursor-1].char&&this._queueCursor--;}removeLastSemicolon(){const queueCursor=this._queueCursor;0!==queueCursor&&59===this._queue[queueCursor-1].char&&this._queueCursor--;}getLastChar(){const queueCursor=this._queueCursor;return 0!==queueCursor?this._queue[queueCursor-1].char:this._last}getNewlineCount(){const queueCursor=this._queueCursor;let count=0;if(0===queueCursor)return 10===this._last?1:0;for(let i=queueCursor-1;i>=0&&10===this._queue[i].char;i--)count++;return count===queueCursor&&10===this._last?count+1:count}endsWithCharAndNewline(){const queue=this._queue,queueCursor=this._queueCursor;if(0!==queueCursor){if(10!==queue[queueCursor-1].char)return;return queueCursor>1?queue[queueCursor-2].char:this._last}}hasContent(){return 0!==this._queueCursor||!!this._last}exactSource(loc,cb){if(!this._map)return void cb();this.source("start",loc);const identifierName=loc.identifierName,sourcePos=this._sourcePosition;identifierName&&(this._canMarkIdName=false,sourcePos.identifierName=identifierName),cb(),identifierName&&(this._canMarkIdName=true,sourcePos.identifierName=void 0,sourcePos.identifierNamePos=void 0),this.source("end",loc);}source(prop,loc){this._map&&this._normalizePosition(prop,loc,0);}sourceWithOffset(prop,loc,columnOffset){this._map&&this._normalizePosition(prop,loc,columnOffset);}_normalizePosition(prop,loc,columnOffset){const pos=loc[prop],target=this._sourcePosition;pos&&(target.line=pos.line,target.column=Math.max(pos.column+columnOffset,0),target.filename=loc.filename);}getCurrentColumn(){const queue=this._queue,queueCursor=this._queueCursor;let lastIndex=-1,len=0;for(let i=0;i<queueCursor;i++){const item=queue[i];10===item.char&&(lastIndex=len),len+=item.repeat;}return  -1===lastIndex?this._position.column+len:len-1-lastIndex}getCurrentLine(){let count=0;const queue=this._queue;for(let i=0;i<this._queueCursor;i++)10===queue[i].char&&count++;return this._position.line+count}};},"./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/generators/base.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.BlockStatement=function(node){var _node$directives2;this.tokenChar(123);const exit=this.enterDelimited(),directivesLen=null==(_node$directives2=node.directives)?void 0:_node$directives2.length;if(directivesLen){var _node$directives$trai2;const newline=node.body.length?2:1;this.printSequence(node.directives,true,newline),null!=(_node$directives$trai2=node.directives[directivesLen-1].trailingComments)&&_node$directives$trai2.length||this.newline(newline);}this.printSequence(node.body,true),exit(),this.rightBrace(node);},exports.Directive=function(node){this.print(node.value),this.semicolon();},exports.DirectiveLiteral=function(node){const raw=this.getPossibleRaw(node);if(!this.format.minified&&void 0!==raw)return void this.token(raw);const{value}=node;if(unescapedDoubleQuoteRE.test(value)){if(unescapedSingleQuoteRE.test(value))throw new Error("Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.");this.token(`'${value}'`);}else this.token(`"${value}"`);},exports.File=function(node){node.program&&this.print(node.program.interpreter);this.print(node.program);},exports.InterpreterDirective=function(node){this.token(`#!${node.value}`),this.newline(1,true);},exports.Placeholder=function(node){this.token("%%"),this.print(node.name),this.token("%%"),"Statement"===node.expectedNode&&this.semicolon();},exports.Program=function(node){var _node$directives;this.noIndentInnerCommentsHere(),this.printInnerComments();const directivesLen=null==(_node$directives=node.directives)?void 0:_node$directives.length;if(directivesLen){var _node$directives$trai;const newline=node.body.length?2:1;this.printSequence(node.directives,void 0,newline),null!=(_node$directives$trai=node.directives[directivesLen-1].trailingComments)&&_node$directives$trai.length||this.newline(newline);}this.printSequence(node.body);};const unescapedSingleQuoteRE=/(?:^|[^\\])(?:\\\\)*'/,unescapedDoubleQuoteRE=/(?:^|[^\\])(?:\\\\)*"/;},"./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/generators/classes.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.ClassAccessorProperty=function(node){var _node$key$loc2;this.printJoin(node.decorators);const endLine=null==(_node$key$loc2=node.key.loc)||null==(_node$key$loc2=_node$key$loc2.end)?void 0:_node$key$loc2.line;endLine&&this.catchUp(endLine);this.tsPrintClassMemberModifiers(node),this.word("accessor",true),this.space(),node.computed?(this.tokenChar(91),this.print(node.key),this.tokenChar(93)):(this._variance(node),this.print(node.key));node.optional&&this.tokenChar(63);node.definite&&this.tokenChar(33);this.print(node.typeAnnotation),node.value&&(this.space(),this.tokenChar(61),this.space(),this.print(node.value));this.semicolon();},exports.ClassBody=function(node){if(this.tokenChar(123),0===node.body.length)this.tokenChar(125);else {this.newline();const separator=function(printer,node){if(!printer.tokenMap||null==node.start||null==node.end)return null;const indexes=printer.tokenMap.getIndexes(node);if(!indexes)return null;let k=1,occurrenceCount=0,nextLocIndex=0;const advanceNextLocIndex=()=>{for(;nextLocIndex<node.body.length&&null==node.body[nextLocIndex].start;)nextLocIndex++;};return advanceNextLocIndex(),i=>{nextLocIndex<=i&&(nextLocIndex=i+1,advanceNextLocIndex());const end=nextLocIndex===node.body.length?node.end:node.body[nextLocIndex].start;let tok;for(;k<indexes.length&&printer.tokenMap.matchesOriginal(tok=printer._tokens[indexes[k]],";")&&tok.start<end;)printer.token(";",void 0,occurrenceCount++),k++;}}(this,node);null==separator||separator(-1);const exit=this.enterDelimited();this.printJoin(node.body,true,true,separator,true),exit(),this.endsWith(10)||this.newline(),this.rightBrace(node);}},exports.ClassExpression=exports.ClassDeclaration=function(node,parent){(isExportDefaultDeclaration(parent)||isExportNamedDeclaration(parent))&&this._shouldPrintDecoratorsBeforeExport(parent)||this.printJoin(node.decorators);node.declare&&(this.word("declare"),this.space());node.abstract&&(this.word("abstract"),this.space());this.word("class"),node.id&&(this.space(),this.print(node.id));this.print(node.typeParameters),node.superClass&&(this.space(),this.word("extends"),this.space(),this.print(node.superClass),this.print(node.superTypeParameters));node.implements&&(this.space(),this.word("implements"),this.space(),this.printList(node.implements));this.space(),this.print(node.body);},exports.ClassMethod=function(node){this._classMethodHead(node),this.space(),this.print(node.body);},exports.ClassPrivateMethod=function(node){this._classMethodHead(node),this.space(),this.print(node.body);},exports.ClassPrivateProperty=function(node){this.printJoin(node.decorators),node.static&&(this.word("static"),this.space());this.print(node.key),this.print(node.typeAnnotation),node.value&&(this.space(),this.tokenChar(61),this.space(),this.print(node.value));this.semicolon();},exports.ClassProperty=function(node){if(this.printJoin(node.decorators),!node.static&&!this.format.preserveFormat){var _node$key$loc;const endLine=null==(_node$key$loc=node.key.loc)||null==(_node$key$loc=_node$key$loc.end)?void 0:_node$key$loc.line;endLine&&this.catchUp(endLine);}this.tsPrintClassMemberModifiers(node),node.computed?(this.tokenChar(91),this.print(node.key),this.tokenChar(93)):(this._variance(node),this.print(node.key));node.optional&&this.tokenChar(63);node.definite&&this.tokenChar(33);this.print(node.typeAnnotation),node.value&&(this.space(),this.tokenChar(61),this.space(),this.print(node.value));this.semicolon();},exports.StaticBlock=function(node){this.word("static"),this.space(),this.tokenChar(123),0===node.body.length?this.tokenChar(125):(this.newline(),this.printSequence(node.body,true),this.rightBrace(node));},exports._classMethodHead=function(node){if(this.printJoin(node.decorators),!this.format.preserveFormat){var _node$key$loc3;const endLine=null==(_node$key$loc3=node.key.loc)||null==(_node$key$loc3=_node$key$loc3.end)?void 0:_node$key$loc3.line;endLine&&this.catchUp(endLine);}this.tsPrintClassMemberModifiers(node),this._methodHead(node);};var _t=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js");const{isExportDefaultDeclaration,isExportNamedDeclaration}=_t;},"./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/generators/expressions.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.LogicalExpression=exports.BinaryExpression=exports.AssignmentExpression=function(node){this.print(node.left),this.space(),"in"===node.operator||"instanceof"===node.operator?this.word(node.operator):(this.token(node.operator),this._endsWithDiv="/"===node.operator);this.space(),this.print(node.right);},exports.AssignmentPattern=function(node){this.print(node.left),("Identifier"===node.left.type||isPattern(node.left))&&(node.left.optional&&this.tokenChar(63),this.print(node.left.typeAnnotation));this.space(),this.tokenChar(61),this.space(),this.print(node.right);},exports.AwaitExpression=function(node){this.word("await"),node.argument&&(this.space(),this.printTerminatorless(node.argument));},exports.BindExpression=function(node){this.print(node.object),this.token("::"),this.print(node.callee);},exports.CallExpression=function(node){this.print(node.callee),this.print(node.typeArguments),this.print(node.typeParameters),this.tokenChar(40);const exit=this.enterDelimited();this.printList(node.arguments,this.shouldPrintTrailingComma(")")),exit(),this.rightParens(node);},exports.ConditionalExpression=function(node){this.print(node.test),this.space(),this.tokenChar(63),this.space(),this.print(node.consequent),this.space(),this.tokenChar(58),this.space(),this.print(node.alternate);},exports.Decorator=function(node){this.tokenChar(64),this.print(node.expression),this.newline();},exports.DoExpression=function(node){node.async&&(this.word("async",true),this.space());this.word("do"),this.space(),this.print(node.body);},exports.EmptyStatement=function(){this.semicolon(true);},exports.ExpressionStatement=function(node){this.tokenContext|=_index.TokenContext.expressionStatement,this.print(node.expression),this.semicolon();},exports.Import=function(){this.word("import");},exports.MemberExpression=function(node){if(this.print(node.object),!node.computed&&isMemberExpression(node.property))throw new TypeError("Got a MemberExpression for MemberExpression property");let computed=node.computed;isLiteral(node.property)&&"number"==typeof node.property.value&&(computed=true);if(computed){const exit=this.enterDelimited();this.tokenChar(91),this.print(node.property),this.tokenChar(93),exit();}else this.tokenChar(46),this.print(node.property);},exports.MetaProperty=function(node){this.print(node.meta),this.tokenChar(46),this.print(node.property);},exports.ModuleExpression=function(node){this.word("module",true),this.space(),this.tokenChar(123),this.indent();const{body}=node;(body.body.length||body.directives.length)&&this.newline();this.print(body),this.dedent(),this.rightBrace(node);},exports.NewExpression=function(node,parent){if(this.word("new"),this.space(),this.print(node.callee),this.format.minified&&0===node.arguments.length&&!node.optional&&!isCallExpression(parent,{callee:node})&&!isMemberExpression(parent)&&!isNewExpression(parent))return;this.print(node.typeArguments),this.print(node.typeParameters),node.optional&&this.token("?.");if(0===node.arguments.length&&this.tokenMap&&!this.tokenMap.endMatches(node,")"))return;this.tokenChar(40);const exit=this.enterDelimited();this.printList(node.arguments,this.shouldPrintTrailingComma(")")),exit(),this.rightParens(node);},exports.OptionalCallExpression=function(node){this.print(node.callee),this.print(node.typeParameters),node.optional&&this.token("?.");this.print(node.typeArguments),this.tokenChar(40);const exit=this.enterDelimited();this.printList(node.arguments),exit(),this.rightParens(node);},exports.OptionalMemberExpression=function(node){let{computed}=node;const{optional,property}=node;if(this.print(node.object),!computed&&isMemberExpression(property))throw new TypeError("Got a MemberExpression for MemberExpression property");isLiteral(property)&&"number"==typeof property.value&&(computed=true);optional&&this.token("?.");computed?(this.tokenChar(91),this.print(property),this.tokenChar(93)):(optional||this.tokenChar(46),this.print(property));},exports.ParenthesizedExpression=function(node){this.tokenChar(40);const exit=this.enterDelimited();this.print(node.expression),exit(),this.rightParens(node);},exports.PrivateName=function(node){this.tokenChar(35),this.print(node.id);},exports.SequenceExpression=function(node){this.printList(node.expressions);},exports.Super=function(){this.word("super");},exports.ThisExpression=function(){this.word("this");},exports.UnaryExpression=function(node){const{operator}=node;"void"===operator||"delete"===operator||"typeof"===operator||"throw"===operator?(this.word(operator),this.space()):this.token(operator);this.print(node.argument);},exports.UpdateExpression=function(node){node.prefix?(this.token(node.operator),this.print(node.argument)):(this.print(node.argument,true),this.token(node.operator));},exports.V8IntrinsicIdentifier=function(node){this.tokenChar(37),this.word(node.name);},exports.YieldExpression=function(node){this.word("yield",true),node.delegate?(this.tokenChar(42),node.argument&&(this.space(),this.print(node.argument))):node.argument&&(this.space(),this.printTerminatorless(node.argument));},exports._shouldPrintDecoratorsBeforeExport=function(node){if("boolean"==typeof this.format.decoratorsBeforeExport)return this.format.decoratorsBeforeExport;return "number"==typeof node.start&&node.start===node.declaration.start};var _t=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js"),_index=__webpack_require__("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/node/index.js");const{isCallExpression,isLiteral,isMemberExpression,isNewExpression,isPattern}=_t;},"./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/generators/flow.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.AnyTypeAnnotation=function(){this.word("any");},exports.ArrayTypeAnnotation=function(node){this.print(node.elementType,true),this.tokenChar(91),this.tokenChar(93);},exports.BooleanLiteralTypeAnnotation=function(node){this.word(node.value?"true":"false");},exports.BooleanTypeAnnotation=function(){this.word("boolean");},exports.DeclareClass=function(node,parent){isDeclareExportDeclaration(parent)||(this.word("declare"),this.space());this.word("class"),this.space(),this._interfaceish(node);},exports.DeclareExportAllDeclaration=function(node){this.word("declare"),this.space(),_modules.ExportAllDeclaration.call(this,node);},exports.DeclareExportDeclaration=function(node){this.word("declare"),this.space(),this.word("export"),this.space(),node.default&&(this.word("default"),this.space());FlowExportDeclaration.call(this,node);},exports.DeclareFunction=function(node,parent){isDeclareExportDeclaration(parent)||(this.word("declare"),this.space());this.word("function"),this.space(),this.print(node.id),this.print(node.id.typeAnnotation.typeAnnotation),node.predicate&&(this.space(),this.print(node.predicate));this.semicolon();},exports.DeclareInterface=function(node){this.word("declare"),this.space(),this.InterfaceDeclaration(node);},exports.DeclareModule=function(node){this.word("declare"),this.space(),this.word("module"),this.space(),this.print(node.id),this.space(),this.print(node.body);},exports.DeclareModuleExports=function(node){this.word("declare"),this.space(),this.word("module"),this.tokenChar(46),this.word("exports"),this.print(node.typeAnnotation);},exports.DeclareOpaqueType=function(node,parent){isDeclareExportDeclaration(parent)||(this.word("declare"),this.space());this.OpaqueType(node);},exports.DeclareTypeAlias=function(node){this.word("declare"),this.space(),this.TypeAlias(node);},exports.DeclareVariable=function(node,parent){isDeclareExportDeclaration(parent)||(this.word("declare"),this.space());this.word("var"),this.space(),this.print(node.id),this.print(node.id.typeAnnotation),this.semicolon();},exports.DeclaredPredicate=function(node){this.tokenChar(37),this.word("checks"),this.tokenChar(40),this.print(node.value),this.tokenChar(41);},exports.EmptyTypeAnnotation=function(){this.word("empty");},exports.EnumBooleanBody=function(node){const{explicitType}=node;enumExplicitType(this,"boolean",explicitType),enumBody(this,node);},exports.EnumBooleanMember=function(node){enumInitializedMember(this,node);},exports.EnumDeclaration=function(node){const{id,body}=node;this.word("enum"),this.space(),this.print(id),this.print(body);},exports.EnumDefaultedMember=function(node){const{id}=node;this.print(id),this.tokenChar(44);},exports.EnumNumberBody=function(node){const{explicitType}=node;enumExplicitType(this,"number",explicitType),enumBody(this,node);},exports.EnumNumberMember=function(node){enumInitializedMember(this,node);},exports.EnumStringBody=function(node){const{explicitType}=node;enumExplicitType(this,"string",explicitType),enumBody(this,node);},exports.EnumStringMember=function(node){enumInitializedMember(this,node);},exports.EnumSymbolBody=function(node){enumExplicitType(this,"symbol",true),enumBody(this,node);},exports.ExistsTypeAnnotation=function(){this.tokenChar(42);},exports.FunctionTypeAnnotation=function(node,parent){this.print(node.typeParameters),this.tokenChar(40),node.this&&(this.word("this"),this.tokenChar(58),this.space(),this.print(node.this.typeAnnotation),(node.params.length||node.rest)&&(this.tokenChar(44),this.space()));this.printList(node.params),node.rest&&(node.params.length&&(this.tokenChar(44),this.space()),this.token("..."),this.print(node.rest));this.tokenChar(41);const type=null==parent?void 0:parent.type;null!=type&&("ObjectTypeCallProperty"===type||"ObjectTypeInternalSlot"===type||"DeclareFunction"===type||"ObjectTypeProperty"===type&&parent.method)?this.tokenChar(58):(this.space(),this.token("=>"));this.space(),this.print(node.returnType);},exports.FunctionTypeParam=function(node){this.print(node.name),node.optional&&this.tokenChar(63);node.name&&(this.tokenChar(58),this.space());this.print(node.typeAnnotation);},exports.IndexedAccessType=function(node){this.print(node.objectType,true),this.tokenChar(91),this.print(node.indexType),this.tokenChar(93);},exports.InferredPredicate=function(){this.tokenChar(37),this.word("checks");},exports.InterfaceDeclaration=function(node){this.word("interface"),this.space(),this._interfaceish(node);},exports.GenericTypeAnnotation=exports.ClassImplements=exports.InterfaceExtends=function(node){this.print(node.id),this.print(node.typeParameters,true);},exports.InterfaceTypeAnnotation=function(node){var _node$extends2;this.word("interface"),null!=(_node$extends2=node.extends)&&_node$extends2.length&&(this.space(),this.word("extends"),this.space(),this.printList(node.extends));this.space(),this.print(node.body);},exports.IntersectionTypeAnnotation=function(node){this.printJoin(node.types,void 0,void 0,andSeparator);},exports.MixedTypeAnnotation=function(){this.word("mixed");},exports.NullLiteralTypeAnnotation=function(){this.word("null");},exports.NullableTypeAnnotation=function(node){this.tokenChar(63),this.print(node.typeAnnotation);},Object.defineProperty(exports,"NumberLiteralTypeAnnotation",{enumerable:true,get:function(){return _types2.NumericLiteral}}),exports.NumberTypeAnnotation=function(){this.word("number");},exports.ObjectTypeAnnotation=function(node){node.exact?this.token("{|"):this.tokenChar(123);const props=[...node.properties,...node.callProperties||[],...node.indexers||[],...node.internalSlots||[]];props.length&&(this.newline(),this.space(),this.printJoin(props,true,true,void 0,void 0,(function(leading){if(leading&&!props[0])return 1}),(()=>{(1!==props.length||node.inexact)&&(this.tokenChar(44),this.space());})),this.space());node.inexact&&(this.indent(),this.token("..."),props.length&&this.newline(),this.dedent());node.exact?this.token("|}"):this.tokenChar(125);},exports.ObjectTypeCallProperty=function(node){node.static&&(this.word("static"),this.space());this.print(node.value);},exports.ObjectTypeIndexer=function(node){node.static&&(this.word("static"),this.space());this._variance(node),this.tokenChar(91),node.id&&(this.print(node.id),this.tokenChar(58),this.space());this.print(node.key),this.tokenChar(93),this.tokenChar(58),this.space(),this.print(node.value);},exports.ObjectTypeInternalSlot=function(node){node.static&&(this.word("static"),this.space());this.tokenChar(91),this.tokenChar(91),this.print(node.id),this.tokenChar(93),this.tokenChar(93),node.optional&&this.tokenChar(63);node.method||(this.tokenChar(58),this.space());this.print(node.value);},exports.ObjectTypeProperty=function(node){node.proto&&(this.word("proto"),this.space());node.static&&(this.word("static"),this.space());"get"!==node.kind&&"set"!==node.kind||(this.word(node.kind),this.space());this._variance(node),this.print(node.key),node.optional&&this.tokenChar(63);node.method||(this.tokenChar(58),this.space());this.print(node.value);},exports.ObjectTypeSpreadProperty=function(node){this.token("..."),this.print(node.argument);},exports.OpaqueType=function(node){this.word("opaque"),this.space(),this.word("type"),this.space(),this.print(node.id),this.print(node.typeParameters),node.supertype&&(this.tokenChar(58),this.space(),this.print(node.supertype));node.impltype&&(this.space(),this.tokenChar(61),this.space(),this.print(node.impltype));this.semicolon();},exports.OptionalIndexedAccessType=function(node){this.print(node.objectType),node.optional&&this.token("?.");this.tokenChar(91),this.print(node.indexType),this.tokenChar(93);},exports.QualifiedTypeIdentifier=function(node){this.print(node.qualification),this.tokenChar(46),this.print(node.id);},Object.defineProperty(exports,"StringLiteralTypeAnnotation",{enumerable:true,get:function(){return _types2.StringLiteral}}),exports.StringTypeAnnotation=function(){this.word("string");},exports.SymbolTypeAnnotation=function(){this.word("symbol");},exports.ThisTypeAnnotation=function(){this.word("this");},exports.TupleTypeAnnotation=function(node){this.tokenChar(91),this.printList(node.types),this.tokenChar(93);},exports.TypeAlias=function(node){this.word("type"),this.space(),this.print(node.id),this.print(node.typeParameters),this.space(),this.tokenChar(61),this.space(),this.print(node.right),this.semicolon();},exports.TypeAnnotation=function(node,parent){this.tokenChar(58),this.space(),"ArrowFunctionExpression"===parent.type?this.tokenContext|=_index.TokenContext.arrowFlowReturnType:node.optional&&this.tokenChar(63);this.print(node.typeAnnotation);},exports.TypeCastExpression=function(node){this.tokenChar(40),this.print(node.expression),this.print(node.typeAnnotation),this.tokenChar(41);},exports.TypeParameter=function(node){this._variance(node),this.word(node.name),node.bound&&this.print(node.bound);node.default&&(this.space(),this.tokenChar(61),this.space(),this.print(node.default));},exports.TypeParameterDeclaration=exports.TypeParameterInstantiation=function(node){this.tokenChar(60),this.printList(node.params),this.tokenChar(62);},exports.TypeofTypeAnnotation=function(node){this.word("typeof"),this.space(),this.print(node.argument);},exports.UnionTypeAnnotation=function(node){this.printJoin(node.types,void 0,void 0,orSeparator);},exports.Variance=function(node){"plus"===node.kind?this.tokenChar(43):this.tokenChar(45);},exports.VoidTypeAnnotation=function(){this.word("void");},exports._interfaceish=function(node){var _node$extends;this.print(node.id),this.print(node.typeParameters),null!=(_node$extends=node.extends)&&_node$extends.length&&(this.space(),this.word("extends"),this.space(),this.printList(node.extends));if("DeclareClass"===node.type){var _node$mixins,_node$implements;null!=(_node$mixins=node.mixins)&&_node$mixins.length&&(this.space(),this.word("mixins"),this.space(),this.printList(node.mixins)),null!=(_node$implements=node.implements)&&_node$implements.length&&(this.space(),this.word("implements"),this.space(),this.printList(node.implements));}this.space(),this.print(node.body);},exports._variance=function(node){var _node$variance;const kind=null==(_node$variance=node.variance)?void 0:_node$variance.kind;null!=kind&&("plus"===kind?this.tokenChar(43):"minus"===kind&&this.tokenChar(45));};var _t=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js"),_modules=__webpack_require__("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/generators/modules.js"),_index=__webpack_require__("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/node/index.js"),_types2=__webpack_require__("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/generators/types.js");const{isDeclareExportDeclaration,isStatement}=_t;function enumExplicitType(context,name,hasExplicitType){hasExplicitType&&(context.space(),context.word("of"),context.space(),context.word(name)),context.space();}function enumBody(context,node){const{members}=node;context.token("{"),context.indent(),context.newline();for(const member of members)context.print(member),context.newline();node.hasUnknownMembers&&(context.token("..."),context.newline()),context.dedent(),context.token("}");}function enumInitializedMember(context,node){context.print(node.id),context.space(),context.token("="),context.space(),context.print(node.init),context.token(",");}function FlowExportDeclaration(node){if(node.declaration){const declar=node.declaration;this.print(declar),isStatement(declar)||this.semicolon();}else this.tokenChar(123),node.specifiers.length&&(this.space(),this.printList(node.specifiers),this.space()),this.tokenChar(125),node.source&&(this.space(),this.word("from"),this.space(),this.print(node.source)),this.semicolon();}function andSeparator(occurrenceCount){this.space(),this.token("&",false,occurrenceCount),this.space();}function orSeparator(occurrenceCount){this.space(),this.token("|",false,occurrenceCount),this.space();}},"./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/generators/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true});var _templateLiterals=__webpack_require__("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/generators/template-literals.js");Object.keys(_templateLiterals).forEach((function(key){"default"!==key&&"__esModule"!==key&&(key in exports&&exports[key]===_templateLiterals[key]||Object.defineProperty(exports,key,{enumerable:true,get:function(){return _templateLiterals[key]}}));}));var _expressions=__webpack_require__("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/generators/expressions.js");Object.keys(_expressions).forEach((function(key){"default"!==key&&"__esModule"!==key&&(key in exports&&exports[key]===_expressions[key]||Object.defineProperty(exports,key,{enumerable:true,get:function(){return _expressions[key]}}));}));var _statements=__webpack_require__("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/generators/statements.js");Object.keys(_statements).forEach((function(key){"default"!==key&&"__esModule"!==key&&(key in exports&&exports[key]===_statements[key]||Object.defineProperty(exports,key,{enumerable:true,get:function(){return _statements[key]}}));}));var _classes=__webpack_require__("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/generators/classes.js");Object.keys(_classes).forEach((function(key){"default"!==key&&"__esModule"!==key&&(key in exports&&exports[key]===_classes[key]||Object.defineProperty(exports,key,{enumerable:true,get:function(){return _classes[key]}}));}));var _methods=__webpack_require__("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/generators/methods.js");Object.keys(_methods).forEach((function(key){"default"!==key&&"__esModule"!==key&&(key in exports&&exports[key]===_methods[key]||Object.defineProperty(exports,key,{enumerable:true,get:function(){return _methods[key]}}));}));var _modules=__webpack_require__("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/generators/modules.js");Object.keys(_modules).forEach((function(key){"default"!==key&&"__esModule"!==key&&(key in exports&&exports[key]===_modules[key]||Object.defineProperty(exports,key,{enumerable:true,get:function(){return _modules[key]}}));}));var _types=__webpack_require__("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/generators/types.js");Object.keys(_types).forEach((function(key){"default"!==key&&"__esModule"!==key&&(key in exports&&exports[key]===_types[key]||Object.defineProperty(exports,key,{enumerable:true,get:function(){return _types[key]}}));}));var _flow=__webpack_require__("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/generators/flow.js");Object.keys(_flow).forEach((function(key){"default"!==key&&"__esModule"!==key&&(key in exports&&exports[key]===_flow[key]||Object.defineProperty(exports,key,{enumerable:true,get:function(){return _flow[key]}}));}));var _base=__webpack_require__("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/generators/base.js");Object.keys(_base).forEach((function(key){"default"!==key&&"__esModule"!==key&&(key in exports&&exports[key]===_base[key]||Object.defineProperty(exports,key,{enumerable:true,get:function(){return _base[key]}}));}));var _jsx=__webpack_require__("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/generators/jsx.js");Object.keys(_jsx).forEach((function(key){"default"!==key&&"__esModule"!==key&&(key in exports&&exports[key]===_jsx[key]||Object.defineProperty(exports,key,{enumerable:true,get:function(){return _jsx[key]}}));}));var _typescript=__webpack_require__("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/generators/typescript.js");Object.keys(_typescript).forEach((function(key){"default"!==key&&"__esModule"!==key&&(key in exports&&exports[key]===_typescript[key]||Object.defineProperty(exports,key,{enumerable:true,get:function(){return _typescript[key]}}));}));},"./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/generators/jsx.js":(__unused_webpack_module,exports)=>{function spaceSeparator(){this.space();}Object.defineProperty(exports,"__esModule",{value:true}),exports.JSXAttribute=function(node){this.print(node.name),node.value&&(this.tokenChar(61),this.print(node.value));},exports.JSXClosingElement=function(node){this.tokenChar(60),this.tokenChar(47),this.print(node.name),this.tokenChar(62);},exports.JSXClosingFragment=function(){this.token("</"),this.tokenChar(62);},exports.JSXElement=function(node){const open=node.openingElement;if(this.print(open),open.selfClosing)return;this.indent();for(const child of node.children)this.print(child);this.dedent(),this.print(node.closingElement);},exports.JSXEmptyExpression=function(){this.printInnerComments();},exports.JSXExpressionContainer=function(node){this.tokenChar(123),this.print(node.expression),this.rightBrace(node);},exports.JSXFragment=function(node){this.print(node.openingFragment),this.indent();for(const child of node.children)this.print(child);this.dedent(),this.print(node.closingFragment);},exports.JSXIdentifier=function(node){this.word(node.name);},exports.JSXMemberExpression=function(node){this.print(node.object),this.tokenChar(46),this.print(node.property);},exports.JSXNamespacedName=function(node){this.print(node.namespace),this.tokenChar(58),this.print(node.name);},exports.JSXOpeningElement=function(node){this.tokenChar(60),this.print(node.name),this.print(node.typeParameters),node.attributes.length>0&&(this.space(),this.printJoin(node.attributes,void 0,void 0,spaceSeparator));node.selfClosing&&(this.space(),this.tokenChar(47));this.tokenChar(62);},exports.JSXOpeningFragment=function(){this.tokenChar(60),this.tokenChar(62);},exports.JSXSpreadAttribute=function(node){this.tokenChar(123),this.token("..."),this.print(node.argument),this.rightBrace(node);},exports.JSXSpreadChild=function(node){this.tokenChar(123),this.token("..."),this.print(node.expression),this.rightBrace(node);},exports.JSXText=function(node){const raw=this.getPossibleRaw(node);void 0!==raw?this.token(raw,true):this.token(node.value,true);};},"./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/generators/methods.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.ArrowFunctionExpression=function(node,parent){node.async&&(this.word("async",true),this.space());this._shouldPrintArrowParamsParens(node)?this._params(node,void 0,parent):this.print(node.params[0],true);this._predicate(node,true),this.space(),this.printInnerComments(),this.token("=>"),this.space(),this.tokenContext|=_index.TokenContext.arrowBody,this.print(node.body);},exports.FunctionDeclaration=exports.FunctionExpression=function(node,parent){this._functionHead(node,parent),this.space(),this.print(node.body);},exports._functionHead=function(node,parent){node.async&&(this.word("async"),this.format.preserveFormat||(this._endsWithInnerRaw=false),this.space());this.word("function"),node.generator&&(this.format.preserveFormat||(this._endsWithInnerRaw=false),this.tokenChar(42));this.space(),node.id&&this.print(node.id);this._params(node,node.id,parent),"TSDeclareFunction"!==node.type&&this._predicate(node);},exports._methodHead=function(node){const kind=node.kind,key=node.key;"get"!==kind&&"set"!==kind||(this.word(kind),this.space());node.async&&(this.word("async",true),this.space());"method"!==kind&&"init"!==kind||node.generator&&this.tokenChar(42);node.computed?(this.tokenChar(91),this.print(key),this.tokenChar(93)):this.print(key);node.optional&&this.tokenChar(63);this._params(node,node.computed&&"StringLiteral"!==node.key.type?void 0:node.key,void 0);},exports._param=function(parameter){this.printJoin(parameter.decorators),this.print(parameter),parameter.optional&&this.tokenChar(63);this.print(parameter.typeAnnotation);},exports._parameters=function(parameters,endToken){const exit=this.enterDelimited(),trailingComma=this.shouldPrintTrailingComma(endToken),paramLength=parameters.length;for(let i=0;i<paramLength;i++)this._param(parameters[i]),(trailingComma||i<paramLength-1)&&(this.token(",",null,i),this.space());this.token(endToken),exit();},exports._params=function(node,idNode,parentNode){this.print(node.typeParameters);const nameInfo=_getFuncIdName.call(this,idNode,parentNode);nameInfo&&this.sourceIdentifierName(nameInfo.name,nameInfo.pos);this.tokenChar(40),this._parameters(node.params,")");const noLineTerminator="ArrowFunctionExpression"===node.type;this.print(node.returnType,noLineTerminator),this._noLineTerminator=noLineTerminator;},exports._predicate=function(node,noLineTerminatorAfter){node.predicate&&(node.returnType||this.tokenChar(58),this.space(),this.print(node.predicate,noLineTerminatorAfter));},exports._shouldPrintArrowParamsParens=function(node){var _firstParam$leadingCo,_firstParam$trailingC;if(1!==node.params.length)return  true;if(node.typeParameters||node.returnType||node.predicate)return  true;const firstParam=node.params[0];if(!isIdentifier(firstParam)||firstParam.typeAnnotation||firstParam.optional||null!=(_firstParam$leadingCo=firstParam.leadingComments)&&_firstParam$leadingCo.length||null!=(_firstParam$trailingC=firstParam.trailingComments)&&_firstParam$trailingC.length)return  true;if(this.tokenMap){if(null==node.loc)return  true;if(null!==this.tokenMap.findMatching(node,"("))return  true;const arrowToken=this.tokenMap.findMatching(node,"=>");return null==(null==arrowToken?void 0:arrowToken.loc)||arrowToken.loc.start.line!==node.loc.start.line}return !!this.format.retainLines};var _t=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js"),_index=__webpack_require__("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/node/index.js");const{isIdentifier}=_t;function _getFuncIdName(idNode,parent){let nameInfo,id=idNode;if(!id&&parent){const parentType=parent.type;"VariableDeclarator"===parentType?id=parent.id:"AssignmentExpression"===parentType||"AssignmentPattern"===parentType?id=parent.left:"ObjectProperty"===parentType||"ClassProperty"===parentType?parent.computed&&"StringLiteral"!==parent.key.type||(id=parent.key):"ClassPrivateProperty"!==parentType&&"ClassAccessorProperty"!==parentType||(id=parent.key);}if(id){var _id$loc,_id$loc2;if("Identifier"===id.type)nameInfo={pos:null==(_id$loc=id.loc)?void 0:_id$loc.start,name:(null==(_id$loc2=id.loc)?void 0:_id$loc2.identifierName)||id.name};else if("PrivateName"===id.type){var _id$loc3;nameInfo={pos:null==(_id$loc3=id.loc)?void 0:_id$loc3.start,name:"#"+id.id.name};}else if("StringLiteral"===id.type){var _id$loc4;nameInfo={pos:null==(_id$loc4=id.loc)?void 0:_id$loc4.start,name:id.value};}return nameInfo}}},"./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/generators/modules.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.ExportAllDeclaration=function(node){var _node$attributes,_node$assertions;this.word("export"),this.space(),"type"===node.exportKind&&(this.word("type"),this.space());this.tokenChar(42),this.space(),this.word("from"),this.space(),null!=(_node$attributes=node.attributes)&&_node$attributes.length||null!=(_node$assertions=node.assertions)&&_node$assertions.length?(this.print(node.source,true),this.space(),this._printAttributes(node,false)):this.print(node.source);this.semicolon();},exports.ExportDefaultDeclaration=function(node){maybePrintDecoratorsBeforeExport(this,node),this.word("export"),this.noIndentInnerCommentsHere(),this.space(),this.word("default"),this.space(),this.tokenContext|=_index.TokenContext.exportDefault;const declar=node.declaration;this.print(declar),isStatement(declar)||this.semicolon();},exports.ExportDefaultSpecifier=function(node){this.print(node.exported);},exports.ExportNamedDeclaration=function(node){if(maybePrintDecoratorsBeforeExport(this,node),this.word("export"),this.space(),node.declaration){const declar=node.declaration;this.print(declar),isStatement(declar)||this.semicolon();}else {"type"===node.exportKind&&(this.word("type"),this.space());const specifiers=node.specifiers.slice(0);let hasSpecial=false;for(;;){const first=specifiers[0];if(!isExportDefaultSpecifier(first)&&!isExportNamespaceSpecifier(first))break;hasSpecial=true,this.print(specifiers.shift()),specifiers.length&&(this.tokenChar(44),this.space());}let hasBrace=false;var _node$attributes2,_node$assertions2;if((specifiers.length||!specifiers.length&&!hasSpecial)&&(hasBrace=true,this.tokenChar(123),specifiers.length&&(this.space(),this.printList(specifiers,this.shouldPrintTrailingComma("}")),this.space()),this.tokenChar(125)),node.source)this.space(),this.word("from"),this.space(),null!=(_node$attributes2=node.attributes)&&_node$attributes2.length||null!=(_node$assertions2=node.assertions)&&_node$assertions2.length?(this.print(node.source,true),this.space(),this._printAttributes(node,hasBrace)):this.print(node.source);this.semicolon();}},exports.ExportNamespaceSpecifier=function(node){this.tokenChar(42),this.space(),this.word("as"),this.space(),this.print(node.exported);},exports.ExportSpecifier=function(node){"type"===node.exportKind&&(this.word("type"),this.space());this.print(node.local),node.exported&&node.local.name!==node.exported.name&&(this.space(),this.word("as"),this.space(),this.print(node.exported));},exports.ImportAttribute=function(node){this.print(node.key),this.tokenChar(58),this.space(),this.print(node.value);},exports.ImportDeclaration=function(node){var _node$attributes3,_node$assertions3;this.word("import"),this.space();const isTypeKind="type"===node.importKind||"typeof"===node.importKind;isTypeKind?(this.noIndentInnerCommentsHere(),this.word(node.importKind),this.space()):node.module?(this.noIndentInnerCommentsHere(),this.word("module"),this.space()):node.phase&&(this.noIndentInnerCommentsHere(),this.word(node.phase),this.space());const specifiers=node.specifiers.slice(0),hasSpecifiers=!!specifiers.length;for(;hasSpecifiers;){const first=specifiers[0];if(!isImportDefaultSpecifier(first)&&!isImportNamespaceSpecifier(first))break;this.print(specifiers.shift()),specifiers.length&&(this.tokenChar(44),this.space());}let hasBrace=false;specifiers.length?(hasBrace=true,this.tokenChar(123),this.space(),this.printList(specifiers,this.shouldPrintTrailingComma("}")),this.space(),this.tokenChar(125)):isTypeKind&&!hasSpecifiers&&(hasBrace=true,this.tokenChar(123),this.tokenChar(125));(hasSpecifiers||isTypeKind)&&(this.space(),this.word("from"),this.space());null!=(_node$attributes3=node.attributes)&&_node$attributes3.length||null!=(_node$assertions3=node.assertions)&&_node$assertions3.length?(this.print(node.source,true),this.space(),this._printAttributes(node,hasBrace)):this.print(node.source);this.semicolon();},exports.ImportDefaultSpecifier=function(node){this.print(node.local);},exports.ImportExpression=function(node){this.word("import"),node.phase&&(this.tokenChar(46),this.word(node.phase));this.tokenChar(40),this.print(node.source),null!=node.options&&(this.tokenChar(44),this.space(),this.print(node.options));this.tokenChar(41);},exports.ImportNamespaceSpecifier=function(node){this.tokenChar(42),this.space(),this.word("as"),this.space(),this.print(node.local);},exports.ImportSpecifier=function(node){"type"!==node.importKind&&"typeof"!==node.importKind||(this.word(node.importKind),this.space());this.print(node.imported),node.local&&node.local.name!==node.imported.name&&(this.space(),this.word("as"),this.space(),this.print(node.local));},exports._printAttributes=function(node,hasPreviousBrace){const{importAttributesKeyword}=this.format,{attributes,assertions}=node;!attributes||importAttributesKeyword||warningShown||(warningShown=true,console.warn('You are using import attributes, without specifying the desired output syntax.\nPlease specify the "importAttributesKeyword" generator option, whose value can be one of:\n - "with"        : `import { a } from "b" with { type: "json" };`\n - "assert"      : `import { a } from "b" assert { type: "json" };`\n - "with-legacy" : `import { a } from "b" with type: "json";`\n'));const useAssertKeyword="assert"===importAttributesKeyword||!importAttributesKeyword&&assertions;if(this.word(useAssertKeyword?"assert":"with"),this.space(),!useAssertKeyword&&"with"!==importAttributesKeyword)return void this.printList(attributes||assertions);const occurrenceCount=hasPreviousBrace?1:0;this.token("{",null,occurrenceCount),this.space(),this.printList(attributes||assertions,this.shouldPrintTrailingComma("}")),this.space(),this.token("}",null,occurrenceCount);};var _t=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js"),_index=__webpack_require__("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/node/index.js");const{isClassDeclaration,isExportDefaultSpecifier,isExportNamespaceSpecifier,isImportDefaultSpecifier,isImportNamespaceSpecifier,isStatement}=_t;let warningShown=false;function maybePrintDecoratorsBeforeExport(printer,node){isClassDeclaration(node.declaration)&&printer._shouldPrintDecoratorsBeforeExport(node)&&printer.printJoin(node.declaration.decorators);}},"./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/generators/statements.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.BreakStatement=function(node){this.word("break"),printStatementAfterKeyword(this,node.label);},exports.CatchClause=function(node){this.word("catch"),this.space(),node.param&&(this.tokenChar(40),this.print(node.param),this.print(node.param.typeAnnotation),this.tokenChar(41),this.space());this.print(node.body);},exports.ContinueStatement=function(node){this.word("continue"),printStatementAfterKeyword(this,node.label);},exports.DebuggerStatement=function(){this.word("debugger"),this.semicolon();},exports.DoWhileStatement=function(node){this.word("do"),this.space(),this.print(node.body),this.space(),this.word("while"),this.space(),this.tokenChar(40),this.print(node.test),this.tokenChar(41),this.semicolon();},exports.ForOfStatement=exports.ForInStatement=void 0,exports.ForStatement=function(node){this.word("for"),this.space(),this.tokenChar(40);{const exit=this.enterForStatementInit();this.tokenContext|=_index.TokenContext.forHead,this.print(node.init),exit();}this.tokenChar(59),node.test&&(this.space(),this.print(node.test));this.token(";",false,1),node.update&&(this.space(),this.print(node.update));this.tokenChar(41),this.printBlock(node);},exports.IfStatement=function(node){this.word("if"),this.space(),this.tokenChar(40),this.print(node.test),this.tokenChar(41),this.space();const needsBlock=node.alternate&&isIfStatement(getLastStatement(node.consequent));needsBlock&&(this.tokenChar(123),this.newline(),this.indent());this.printAndIndentOnComments(node.consequent),needsBlock&&(this.dedent(),this.newline(),this.tokenChar(125));node.alternate&&(this.endsWith(125)&&this.space(),this.word("else"),this.space(),this.printAndIndentOnComments(node.alternate));},exports.LabeledStatement=function(node){this.print(node.label),this.tokenChar(58),this.space(),this.print(node.body);},exports.ReturnStatement=function(node){this.word("return"),printStatementAfterKeyword(this,node.argument);},exports.SwitchCase=function(node){node.test?(this.word("case"),this.space(),this.print(node.test),this.tokenChar(58)):(this.word("default"),this.tokenChar(58));node.consequent.length&&(this.newline(),this.printSequence(node.consequent,true));},exports.SwitchStatement=function(node){this.word("switch"),this.space(),this.tokenChar(40),this.print(node.discriminant),this.tokenChar(41),this.space(),this.tokenChar(123),this.printSequence(node.cases,true,void 0,(function(leading,cas){if(!leading&&node.cases[node.cases.length-1]===cas)return  -1})),this.rightBrace(node);},exports.ThrowStatement=function(node){this.word("throw"),printStatementAfterKeyword(this,node.argument);},exports.TryStatement=function(node){this.word("try"),this.space(),this.print(node.block),this.space(),node.handlers?this.print(node.handlers[0]):this.print(node.handler);node.finalizer&&(this.space(),this.word("finally"),this.space(),this.print(node.finalizer));},exports.VariableDeclaration=function(node,parent){node.declare&&(this.word("declare"),this.space());const{kind}=node;"await using"===kind?(this.word("await"),this.space(),this.word("using",true)):this.word(kind,"using"===kind);this.space();let hasInits=false;if(!isFor(parent))for(const declar of node.declarations)declar.init&&(hasInits=true);if(this.printList(node.declarations,void 0,void 0,node.declarations.length>1,hasInits?function(occurrenceCount){this.token(",",false,occurrenceCount),this.newline();}:void 0),isFor(parent))if(isForStatement(parent)){if(parent.init===node)return}else if(parent.left===node)return;this.semicolon();},exports.VariableDeclarator=function(node){this.print(node.id),node.definite&&this.tokenChar(33);this.print(node.id.typeAnnotation),node.init&&(this.space(),this.tokenChar(61),this.space(),this.print(node.init));},exports.WhileStatement=function(node){this.word("while"),this.space(),this.tokenChar(40),this.print(node.test),this.tokenChar(41),this.printBlock(node);},exports.WithStatement=function(node){this.word("with"),this.space(),this.tokenChar(40),this.print(node.object),this.tokenChar(41),this.printBlock(node);};var _t=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js"),_index=__webpack_require__("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/node/index.js");const{isFor,isForStatement,isIfStatement,isStatement}=_t;function getLastStatement(statement){const{body}=statement;return  false===isStatement(body)?statement:getLastStatement(body)}function ForXStatement(node){this.word("for"),this.space();const isForOf="ForOfStatement"===node.type;isForOf&&node.await&&(this.word("await"),this.space()),this.noIndentInnerCommentsHere(),this.tokenChar(40);{const exit=isForOf?null:this.enterForStatementInit();this.tokenContext|=isForOf?_index.TokenContext.forOfHead:_index.TokenContext.forInHead,this.print(node.left),null==exit||exit();}this.space(),this.word(isForOf?"of":"in"),this.space(),this.print(node.right),this.tokenChar(41),this.printBlock(node);}exports.ForInStatement=ForXStatement,exports.ForOfStatement=ForXStatement;function printStatementAfterKeyword(printer,node){node&&(printer.space(),printer.printTerminatorless(node)),printer.semicolon();}},"./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/generators/template-literals.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.TaggedTemplateExpression=function(node){this.print(node.tag),this.print(node.typeParameters),this.print(node.quasi);},exports.TemplateElement=function(){throw new Error("TemplateElement printing is handled in TemplateLiteral")},exports.TemplateLiteral=function(node){const quasis=node.quasis;let partRaw="`";for(let i=0;i<quasis.length;i++)if(partRaw+=quasis[i].value.raw,i+1<quasis.length&&(this.token(partRaw+"${",true),this.print(node.expressions[i]),partRaw="}",this.tokenMap)){const token=this.tokenMap.findMatching(node,"}",i);token&&this._catchUpTo(token.loc.start);}this.token(partRaw+"`",true);};},"./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/generators/types.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.ArgumentPlaceholder=function(){this.tokenChar(63);},exports.ArrayPattern=exports.ArrayExpression=function(node){const elems=node.elements,len=elems.length;this.tokenChar(91);const exit=this.enterDelimited();for(let i=0;i<elems.length;i++){const elem=elems[i];elem?(i>0&&this.space(),this.print(elem),(i<len-1||this.shouldPrintTrailingComma("]"))&&this.token(",",false,i)):this.token(",",false,i);}exit(),this.tokenChar(93);},exports.BigIntLiteral=function(node){const raw=this.getPossibleRaw(node);if(!this.format.minified&&void 0!==raw)return void this.word(raw);this.word(node.value+"n");},exports.BooleanLiteral=function(node){this.word(node.value?"true":"false");},exports.DecimalLiteral=function(node){const raw=this.getPossibleRaw(node);if(!this.format.minified&&void 0!==raw)return void this.word(raw);this.word(node.value+"m");},exports.Identifier=function(node){var _node$loc;this.sourceIdentifierName((null==(_node$loc=node.loc)?void 0:_node$loc.identifierName)||node.name),this.word(this.tokenMap?this._getRawIdentifier(node):node.name);},exports.NullLiteral=function(){this.word("null");},exports.NumericLiteral=function(node){const raw=this.getPossibleRaw(node),opts=this.format.jsescOption,value=node.value,str=value+"";opts.numbers?this.number(_jsesc(value,opts),value):null==raw?this.number(str,value):this.format.minified?this.number(raw.length<str.length?raw:str,value):this.number(raw,value);},exports.ObjectPattern=exports.ObjectExpression=function(node){const props=node.properties;if(this.tokenChar(123),props.length){const exit=this.enterDelimited();this.space(),this.printList(props,this.shouldPrintTrailingComma("}"),true,true),this.space(),exit();}this.sourceWithOffset("end",node.loc,-1),this.tokenChar(125);},exports.ObjectMethod=function(node){this.printJoin(node.decorators),this._methodHead(node),this.space(),this.print(node.body);},exports.ObjectProperty=function(node){if(this.printJoin(node.decorators),node.computed)this.tokenChar(91),this.print(node.key),this.tokenChar(93);else {if(isAssignmentPattern(node.value)&&isIdentifier(node.key)&&node.key.name===node.value.left.name)return void this.print(node.value);if(this.print(node.key),node.shorthand&&isIdentifier(node.key)&&isIdentifier(node.value)&&node.key.name===node.value.name)return}this.tokenChar(58),this.space(),this.print(node.value);},exports.PipelineBareFunction=function(node){this.print(node.callee);},exports.PipelinePrimaryTopicReference=function(){this.tokenChar(35);},exports.PipelineTopicExpression=function(node){this.print(node.expression);},exports.RecordExpression=function(node){const props=node.properties;let startToken,endToken;if("bar"===this.format.recordAndTupleSyntaxType)startToken="{|",endToken="|}";else {if("hash"!==this.format.recordAndTupleSyntaxType&&null!=this.format.recordAndTupleSyntaxType)throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)} received).`);startToken="#{",endToken="}";}this.token(startToken),props.length&&(this.space(),this.printList(props,this.shouldPrintTrailingComma(endToken),true,true),this.space());this.token(endToken);},exports.RegExpLiteral=function(node){this.word(`/${node.pattern}/${node.flags}`);},exports.SpreadElement=exports.RestElement=function(node){this.token("..."),this.print(node.argument);},exports.StringLiteral=function(node){const raw=this.getPossibleRaw(node);if(!this.format.minified&&void 0!==raw)return void this.token(raw);const val=_jsesc(node.value,this.format.jsescOption);this.token(val);},exports.TopicReference=function(){const{topicToken}=this.format;if(!validTopicTokenSet.has(topicToken)){const givenTopicTokenJSON=JSON.stringify(topicToken),validTopics=Array.from(validTopicTokenSet,(v=>JSON.stringify(v)));throw new Error(`The "topicToken" generator option must be one of ${validTopics.join(", ")} (${givenTopicTokenJSON} received instead).`)}this.token(topicToken);},exports.TupleExpression=function(node){const elems=node.elements,len=elems.length;let startToken,endToken;if("bar"===this.format.recordAndTupleSyntaxType)startToken="[|",endToken="|]";else {if("hash"!==this.format.recordAndTupleSyntaxType)throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);startToken="#[",endToken="]";}this.token(startToken);for(let i=0;i<elems.length;i++){const elem=elems[i];elem&&(i>0&&this.space(),this.print(elem),(i<len-1||this.shouldPrintTrailingComma(endToken))&&this.token(",",false,i));}this.token(endToken);},exports._getRawIdentifier=function(node){if(node===lastRawIdentNode)return lastRawIdentResult;lastRawIdentNode=node;const{name}=node,token=this.tokenMap.find(node,(tok=>tok.value===name));if(token)return lastRawIdentResult=this._originalCode.slice(token.start,token.end),lastRawIdentResult;return lastRawIdentResult=node.name};var _t=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js"),_jsesc=__webpack_require__("./node_modules/.pnpm/jsesc@3.1.0/node_modules/jsesc/jsesc.js");const{isAssignmentPattern,isIdentifier}=_t;let lastRawIdentNode=null,lastRawIdentResult="";const validTopicTokenSet=new Set(["^^","@@","^","%","#"]);},"./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/generators/typescript.js":(__unused_webpack_module,exports)=>{function maybePrintTrailingCommaOrSemicolon(printer,node){printer.tokenMap&&node.start&&node.end?printer.tokenMap.endMatches(node,",")?printer.token(","):printer.tokenMap.endMatches(node,";")&&printer.semicolon():printer.semicolon();}function tsPrintUnionOrIntersectionType(printer,node,sep){var _printer$tokenMap;let hasLeadingToken=0;null!=(_printer$tokenMap=printer.tokenMap)&&_printer$tokenMap.startMatches(node,sep)&&(hasLeadingToken=1,printer.token(sep)),printer.printJoin(node.types,void 0,void 0,(function(i){this.space(),this.token(sep,null,i+hasLeadingToken),this.space();}));}function tokenIfPlusMinus(self,tok){ true!==tok&&self.token(tok);}function printBraced(printer,node,cb){printer.token("{");const exit=printer.enterDelimited();cb(),exit(),printer.rightBrace(node);}function printModifiersList(printer,node,modifiers){var _printer$tokenMap2;const modifiersSet=new Set;for(const modifier of modifiers)modifier&&modifiersSet.add(modifier);null==(_printer$tokenMap2=printer.tokenMap)||_printer$tokenMap2.find(node,(tok=>{if(modifiersSet.has(tok.value))return printer.token(tok.value),printer.space(),modifiersSet.delete(tok.value),0===modifiersSet.size}));for(const modifier of modifiersSet)printer.word(modifier),printer.space();}Object.defineProperty(exports,"__esModule",{value:true}),exports.TSAnyKeyword=function(){this.word("any");},exports.TSArrayType=function(node){this.print(node.elementType,true),this.tokenChar(91),this.tokenChar(93);},exports.TSSatisfiesExpression=exports.TSAsExpression=function(node){const{type,expression,typeAnnotation}=node;this.print(expression,true),this.space(),this.word("TSAsExpression"===type?"as":"satisfies"),this.space(),this.print(typeAnnotation);},exports.TSBigIntKeyword=function(){this.word("bigint");},exports.TSBooleanKeyword=function(){this.word("boolean");},exports.TSCallSignatureDeclaration=function(node){this.tsPrintSignatureDeclarationBase(node),maybePrintTrailingCommaOrSemicolon(this,node);},exports.TSInterfaceHeritage=exports.TSExpressionWithTypeArguments=exports.TSClassImplements=function(node){this.print(node.expression),this.print(node.typeParameters);},exports.TSConditionalType=function(node){this.print(node.checkType),this.space(),this.word("extends"),this.space(),this.print(node.extendsType),this.space(),this.tokenChar(63),this.space(),this.print(node.trueType),this.space(),this.tokenChar(58),this.space(),this.print(node.falseType);},exports.TSConstructSignatureDeclaration=function(node){this.word("new"),this.space(),this.tsPrintSignatureDeclarationBase(node),maybePrintTrailingCommaOrSemicolon(this,node);},exports.TSConstructorType=function(node){node.abstract&&(this.word("abstract"),this.space());this.word("new"),this.space(),this.tsPrintFunctionOrConstructorType(node);},exports.TSDeclareFunction=function(node,parent){node.declare&&(this.word("declare"),this.space());this._functionHead(node,parent),this.semicolon();},exports.TSDeclareMethod=function(node){this._classMethodHead(node),this.semicolon();},exports.TSEnumDeclaration=function(node){const{declare,const:isConst,id,members}=node;declare&&(this.word("declare"),this.space());isConst&&(this.word("const"),this.space());this.word("enum"),this.space(),this.print(id),this.space(),printBraced(this,node,(()=>{var _this$shouldPrintTrai;return this.printList(members,null==(_this$shouldPrintTrai=this.shouldPrintTrailingComma("}"))||_this$shouldPrintTrai,true,true)}));},exports.TSEnumMember=function(node){const{id,initializer}=node;this.print(id),initializer&&(this.space(),this.tokenChar(61),this.space(),this.print(initializer));},exports.TSExportAssignment=function(node){this.word("export"),this.space(),this.tokenChar(61),this.space(),this.print(node.expression),this.semicolon();},exports.TSExternalModuleReference=function(node){this.token("require("),this.print(node.expression),this.tokenChar(41);},exports.TSFunctionType=function(node){this.tsPrintFunctionOrConstructorType(node);},exports.TSImportEqualsDeclaration=function(node){const{isExport,id,moduleReference}=node;isExport&&(this.word("export"),this.space());this.word("import"),this.space(),this.print(id),this.space(),this.tokenChar(61),this.space(),this.print(moduleReference),this.semicolon();},exports.TSImportType=function(node){const{argument,qualifier,typeParameters}=node;this.word("import"),this.tokenChar(40),this.print(argument),this.tokenChar(41),qualifier&&(this.tokenChar(46),this.print(qualifier));typeParameters&&this.print(typeParameters);},exports.TSIndexSignature=function(node){const{readonly,static:isStatic}=node;isStatic&&(this.word("static"),this.space());readonly&&(this.word("readonly"),this.space());this.tokenChar(91),this._parameters(node.parameters,"]"),this.print(node.typeAnnotation),maybePrintTrailingCommaOrSemicolon(this,node);},exports.TSIndexedAccessType=function(node){this.print(node.objectType,true),this.tokenChar(91),this.print(node.indexType),this.tokenChar(93);},exports.TSInferType=function(node){this.word("infer"),this.print(node.typeParameter);},exports.TSInstantiationExpression=function(node){this.print(node.expression),this.print(node.typeParameters);},exports.TSInterfaceBody=function(node){printBraced(this,node,(()=>this.printJoin(node.body,true,true)));},exports.TSInterfaceDeclaration=function(node){const{declare,id,typeParameters,extends:extendz,body}=node;declare&&(this.word("declare"),this.space());this.word("interface"),this.space(),this.print(id),this.print(typeParameters),null!=extendz&&extendz.length&&(this.space(),this.word("extends"),this.space(),this.printList(extendz));this.space(),this.print(body);},exports.TSIntersectionType=function(node){tsPrintUnionOrIntersectionType(this,node,"&");},exports.TSIntrinsicKeyword=function(){this.word("intrinsic");},exports.TSLiteralType=function(node){this.print(node.literal);},exports.TSMappedType=function(node){const{nameType,optional,readonly,typeAnnotation}=node;this.tokenChar(123);const exit=this.enterDelimited();this.space(),readonly&&(tokenIfPlusMinus(this,readonly),this.word("readonly"),this.space());this.tokenChar(91),this.word(node.typeParameter.name),this.space(),this.word("in"),this.space(),this.print(node.typeParameter.constraint),nameType&&(this.space(),this.word("as"),this.space(),this.print(nameType));this.tokenChar(93),optional&&(tokenIfPlusMinus(this,optional),this.tokenChar(63));typeAnnotation&&(this.tokenChar(58),this.space(),this.print(typeAnnotation));this.space(),exit(),this.tokenChar(125);},exports.TSMethodSignature=function(node){const{kind}=node;"set"!==kind&&"get"!==kind||(this.word(kind),this.space());this.tsPrintPropertyOrMethodName(node),this.tsPrintSignatureDeclarationBase(node),maybePrintTrailingCommaOrSemicolon(this,node);},exports.TSModuleBlock=function(node){printBraced(this,node,(()=>this.printSequence(node.body,true)));},exports.TSModuleDeclaration=function(node){const{declare,id,kind}=node;declare&&(this.word("declare"),this.space());{if(node.global||(this.word(null!=kind?kind:"Identifier"===id.type?"namespace":"module"),this.space()),this.print(id),!node.body)return void this.semicolon();let body=node.body;for(;"TSModuleDeclaration"===body.type;)this.tokenChar(46),this.print(body.id),body=body.body;this.space(),this.print(body);}},exports.TSNamedTupleMember=function(node){this.print(node.label),node.optional&&this.tokenChar(63);this.tokenChar(58),this.space(),this.print(node.elementType);},exports.TSNamespaceExportDeclaration=function(node){this.word("export"),this.space(),this.word("as"),this.space(),this.word("namespace"),this.space(),this.print(node.id),this.semicolon();},exports.TSNeverKeyword=function(){this.word("never");},exports.TSNonNullExpression=function(node){this.print(node.expression),this.tokenChar(33);},exports.TSNullKeyword=function(){this.word("null");},exports.TSNumberKeyword=function(){this.word("number");},exports.TSObjectKeyword=function(){this.word("object");},exports.TSOptionalType=function(node){this.print(node.typeAnnotation),this.tokenChar(63);},exports.TSParameterProperty=function(node){node.accessibility&&(this.word(node.accessibility),this.space());node.readonly&&(this.word("readonly"),this.space());this._param(node.parameter);},exports.TSParenthesizedType=function(node){this.tokenChar(40),this.print(node.typeAnnotation),this.tokenChar(41);},exports.TSPropertySignature=function(node){const{readonly}=node;readonly&&(this.word("readonly"),this.space());this.tsPrintPropertyOrMethodName(node),this.print(node.typeAnnotation),maybePrintTrailingCommaOrSemicolon(this,node);},exports.TSQualifiedName=function(node){this.print(node.left),this.tokenChar(46),this.print(node.right);},exports.TSRestType=function(node){this.token("..."),this.print(node.typeAnnotation);},exports.TSStringKeyword=function(){this.word("string");},exports.TSSymbolKeyword=function(){this.word("symbol");},exports.TSThisType=function(){this.word("this");},exports.TSTupleType=function(node){this.tokenChar(91),this.printList(node.elementTypes,this.shouldPrintTrailingComma("]")),this.tokenChar(93);},exports.TSTypeAliasDeclaration=function(node){const{declare,id,typeParameters,typeAnnotation}=node;declare&&(this.word("declare"),this.space());this.word("type"),this.space(),this.print(id),this.print(typeParameters),this.space(),this.tokenChar(61),this.space(),this.print(typeAnnotation),this.semicolon();},exports.TSTypeAnnotation=function(node,parent){this.token("TSFunctionType"!==parent.type&&"TSConstructorType"!==parent.type||parent.typeAnnotation!==node?":":"=>"),this.space(),node.optional&&this.tokenChar(63);this.print(node.typeAnnotation);},exports.TSTypeAssertion=function(node){const{typeAnnotation,expression}=node;this.tokenChar(60),this.print(typeAnnotation),this.tokenChar(62),this.space(),this.print(expression);},exports.TSTypeLiteral=function(node){printBraced(this,node,(()=>this.printJoin(node.members,true,true)));},exports.TSTypeOperator=function(node){this.word(node.operator),this.space(),this.print(node.typeAnnotation);},exports.TSTypeParameter=function(node){node.in&&(this.word("in"),this.space());node.out&&(this.word("out"),this.space());this.word(node.name),node.constraint&&(this.space(),this.word("extends"),this.space(),this.print(node.constraint));node.default&&(this.space(),this.tokenChar(61),this.space(),this.print(node.default));},exports.TSTypeParameterDeclaration=exports.TSTypeParameterInstantiation=function(node,parent){this.tokenChar(60);let printTrailingSeparator="ArrowFunctionExpression"===parent.type&&1===node.params.length;this.tokenMap&&null!=node.start&&null!=node.end&&(printTrailingSeparator&&(printTrailingSeparator=!!this.tokenMap.find(node,(t=>this.tokenMap.matchesOriginal(t,",")))),printTrailingSeparator||(printTrailingSeparator=this.shouldPrintTrailingComma(">")));this.printList(node.params,printTrailingSeparator),this.tokenChar(62);},exports.TSTypePredicate=function(node){node.asserts&&(this.word("asserts"),this.space());this.print(node.parameterName),node.typeAnnotation&&(this.space(),this.word("is"),this.space(),this.print(node.typeAnnotation.typeAnnotation));},exports.TSTypeQuery=function(node){this.word("typeof"),this.space(),this.print(node.exprName),node.typeParameters&&this.print(node.typeParameters);},exports.TSTypeReference=function(node){this.print(node.typeName,!!node.typeParameters),this.print(node.typeParameters);},exports.TSUndefinedKeyword=function(){this.word("undefined");},exports.TSUnionType=function(node){tsPrintUnionOrIntersectionType(this,node,"|");},exports.TSUnknownKeyword=function(){this.word("unknown");},exports.TSVoidKeyword=function(){this.word("void");},exports.tsPrintClassMemberModifiers=function(node){const isField="ClassAccessorProperty"===node.type||"ClassProperty"===node.type;printModifiersList(this,node,[isField&&node.declare&&"declare",node.accessibility]),node.static&&(this.word("static"),this.space());printModifiersList(this,node,[node.override&&"override",node.abstract&&"abstract",isField&&node.readonly&&"readonly"]);},exports.tsPrintFunctionOrConstructorType=function(node){const{typeParameters}=node,parameters=node.parameters;this.print(typeParameters),this.tokenChar(40),this._parameters(parameters,")"),this.space();const returnType=node.typeAnnotation;this.print(returnType);},exports.tsPrintPropertyOrMethodName=function(node){node.computed&&this.tokenChar(91);this.print(node.key),node.computed&&this.tokenChar(93);node.optional&&this.tokenChar(63);},exports.tsPrintSignatureDeclarationBase=function(node){const{typeParameters}=node,parameters=node.parameters;this.print(typeParameters),this.tokenChar(40),this._parameters(parameters,")");const returnType=node.typeAnnotation;this.print(returnType);};},"./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(ast,opts={},code){const format=normalizeOptions(code,opts,ast),map=opts.sourceMaps?new _sourceMap.default(opts,code):null;return new _printer.default(format,map,ast.tokens,"string"==typeof code?code:null).generate(ast)};var _sourceMap=__webpack_require__("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/source-map.js"),_printer=__webpack_require__("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/printer.js");function normalizeOptions(code,opts,ast){if(opts.experimental_preserveFormat){if("string"!=typeof code)throw new Error("`experimental_preserveFormat` requires the original `code` to be passed to @babel/generator as a string");if(!opts.retainLines)throw new Error("`experimental_preserveFormat` requires `retainLines` to be set to `true`");if(opts.compact&&"auto"!==opts.compact)throw new Error("`experimental_preserveFormat` is not compatible with the `compact` option");if(opts.minified)throw new Error("`experimental_preserveFormat` is not compatible with the `minified` option");if(opts.jsescOption)throw new Error("`experimental_preserveFormat` is not compatible with the `jsescOption` option");if(!Array.isArray(ast.tokens))throw new Error("`experimental_preserveFormat` requires the AST to have attatched the token of the input code. Make sure to enable the `tokens: true` parser option.")}const format={auxiliaryCommentBefore:opts.auxiliaryCommentBefore,auxiliaryCommentAfter:opts.auxiliaryCommentAfter,shouldPrintComment:opts.shouldPrintComment,preserveFormat:opts.experimental_preserveFormat,retainLines:opts.retainLines,retainFunctionParens:opts.retainFunctionParens,comments:null==opts.comments||opts.comments,compact:opts.compact,minified:opts.minified,concise:opts.concise,indent:{adjustMultilineComment:true,style:"  "},jsescOption:Object.assign({quotes:"double",wrap:true,minimal:false},opts.jsescOption),topicToken:opts.topicToken,importAttributesKeyword:opts.importAttributesKeyword};var _opts$recordAndTupleS;format.decoratorsBeforeExport=opts.decoratorsBeforeExport,format.jsescOption.json=opts.jsonCompatibleStrings,format.recordAndTupleSyntaxType=null!=(_opts$recordAndTupleS=opts.recordAndTupleSyntaxType)?_opts$recordAndTupleS:"hash",format.minified?(format.compact=true,format.shouldPrintComment=format.shouldPrintComment||(()=>format.comments)):format.shouldPrintComment=format.shouldPrintComment||(value=>format.comments||value.includes("@license")||value.includes("@preserve")),"auto"===format.compact&&(format.compact="string"==typeof code&&code.length>5e5,format.compact&&console.error(`[BABEL] Note: The code generator has deoptimised the styling of ${opts.filename} as it exceeds the max of 500KB.`)),(format.compact||format.preserveFormat)&&(format.indent.adjustMultilineComment=false);const{auxiliaryCommentBefore,auxiliaryCommentAfter,shouldPrintComment}=format;return auxiliaryCommentBefore&&!shouldPrintComment(auxiliaryCommentBefore)&&(format.auxiliaryCommentBefore=void 0),auxiliaryCommentAfter&&!shouldPrintComment(auxiliaryCommentAfter)&&(format.auxiliaryCommentAfter=void 0),format}exports.CodeGenerator=class{constructor(ast,opts={},code){this._ast=void 0,this._format=void 0,this._map=void 0,this._ast=ast,this._format=normalizeOptions(code,opts,ast),this._map=opts.sourceMaps?new _sourceMap.default(opts,code):null;}generate(){return new _printer.default(this._format,this._map).generate(this._ast)}};},"./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/node/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.TokenContext=void 0,exports.isLastChild=function(parent,child){const visitorKeys=VISITOR_KEYS[parent.type];for(let i=visitorKeys.length-1;i>=0;i--){const val=parent[visitorKeys[i]];if(val===child)return  true;if(Array.isArray(val)){let j=val.length-1;for(;j>=0&&null===val[j];)j--;return j>=0&&val[j]===child}if(val)return  false}return  false},exports.needsParens=function(node,parent,tokenContext,inForInit,getRawIdentifier){var _expandedParens$get;if(!parent)return  false;if(isNewExpression(parent)&&parent.callee===node&&isOrHasCallExpression(node))return  true;if(isDecorator(parent))return !(isDecoratorMemberExpression(node)||isCallExpression(node)&&isDecoratorMemberExpression(node.callee)||isParenthesizedExpression(node));return null==(_expandedParens$get=expandedParens.get(node.type))?void 0:_expandedParens$get(node,parent,tokenContext,inForInit,getRawIdentifier)},exports.needsWhitespace=needsWhitespace,exports.needsWhitespaceAfter=function(node,parent){return needsWhitespace(node,parent,2)},exports.needsWhitespaceBefore=function(node,parent){return needsWhitespace(node,parent,1)};var whitespace=__webpack_require__("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/node/whitespace.js"),parens=__webpack_require__("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/node/parentheses.js"),_t=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js");const{FLIPPED_ALIAS_KEYS,VISITOR_KEYS,isCallExpression,isDecorator,isExpressionStatement,isMemberExpression,isNewExpression,isParenthesizedExpression}=_t;exports.TokenContext={expressionStatement:1,arrowBody:2,exportDefault:4,forHead:8,forInHead:16,forOfHead:32,arrowFlowReturnType:64};function expandAliases(obj){const map=new Map;function add(type,func){const fn=map.get(type);map.set(type,fn?function(node,parent,stack,inForInit,getRawIdentifier){var _fn;return null!=(_fn=fn(node,parent,stack,inForInit,getRawIdentifier))?_fn:func(node,parent,stack,inForInit,getRawIdentifier)}:func);}for(const type of Object.keys(obj)){const aliases=FLIPPED_ALIAS_KEYS[type];if(aliases)for(const alias of aliases)add(alias,obj[type]);else add(type,obj[type]);}return map}const expandedParens=expandAliases(parens),expandedWhitespaceNodes=expandAliases(whitespace.nodes);function isOrHasCallExpression(node){return !!isCallExpression(node)||isMemberExpression(node)&&isOrHasCallExpression(node.object)}function needsWhitespace(node,parent,type){var _expandedWhitespaceNo;if(!node)return  false;isExpressionStatement(node)&&(node=node.expression);const flag=null==(_expandedWhitespaceNo=expandedWhitespaceNodes.get(node.type))?void 0:_expandedWhitespaceNo(node,parent);return "number"==typeof flag&&!!(flag&type)}function isDecoratorMemberExpression(node){switch(node.type){case "Identifier":return  true;case "MemberExpression":return !node.computed&&"Identifier"===node.property.type&&isDecoratorMemberExpression(node.object);default:return  false}}},"./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/node/parentheses.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.AssignmentExpression=function(node,parent,tokenContext){return !(!needsParenBeforeExpressionBrace(tokenContext)||!isObjectPattern(node.left))||ConditionalExpression(node,parent)},exports.Binary=Binary,exports.BinaryExpression=function(node,parent,tokenContext,inForStatementInit){return "in"===node.operator&&inForStatementInit},exports.ClassExpression=function(node,parent,tokenContext){return Boolean(tokenContext&(_index.TokenContext.expressionStatement|_index.TokenContext.exportDefault))},exports.ArrowFunctionExpression=exports.ConditionalExpression=ConditionalExpression,exports.DoExpression=function(node,parent,tokenContext){return !node.async&&Boolean(tokenContext&_index.TokenContext.expressionStatement)},exports.FunctionExpression=function(node,parent,tokenContext){return Boolean(tokenContext&(_index.TokenContext.expressionStatement|_index.TokenContext.exportDefault))},exports.FunctionTypeAnnotation=function(node,parent,tokenContext){const parentType=parent.type;return "UnionTypeAnnotation"===parentType||"IntersectionTypeAnnotation"===parentType||"ArrayTypeAnnotation"===parentType||Boolean(tokenContext&_index.TokenContext.arrowFlowReturnType)},exports.Identifier=function(node,parent,tokenContext,_inForInit,getRawIdentifier){var _node$extra;const parentType=parent.type;if(null!=(_node$extra=node.extra)&&_node$extra.parenthesized&&"AssignmentExpression"===parentType&&parent.left===node){const rightType=parent.right.type;if(("FunctionExpression"===rightType||"ClassExpression"===rightType)&&null==parent.right.id)return  true}if(getRawIdentifier&&getRawIdentifier(node)!==node.name)return  false;if("let"===node.name){return !!((isMemberExpression(parent,{object:node,computed:true})||isOptionalMemberExpression(parent,{object:node,computed:true,optional:false}))&&tokenContext&(_index.TokenContext.expressionStatement|_index.TokenContext.forHead|_index.TokenContext.forInHead))||Boolean(tokenContext&_index.TokenContext.forOfHead)}return "async"===node.name&&isForOfStatement(parent,{left:node,await:false})},exports.LogicalExpression=function(node,parent){const parentType=parent.type;if(isTSTypeExpression(parentType))return  true;if("LogicalExpression"!==parentType)return  false;switch(node.operator){case "||":return "??"===parent.operator||"&&"===parent.operator;case "&&":return "??"===parent.operator;case "??":return "??"!==parent.operator}},exports.NullableTypeAnnotation=function(node,parent){return isArrayTypeAnnotation(parent)},exports.ObjectExpression=function(node,parent,tokenContext){return needsParenBeforeExpressionBrace(tokenContext)},exports.OptionalIndexedAccessType=function(node,parent){return isIndexedAccessType(parent)&&parent.objectType===node},exports.OptionalCallExpression=exports.OptionalMemberExpression=function(node,parent){return isCallExpression(parent)&&parent.callee===node||isMemberExpression(parent)&&parent.object===node},exports.SequenceExpression=function(node,parent){const parentType=parent.type;if("SequenceExpression"===parentType||"ParenthesizedExpression"===parentType||"MemberExpression"===parentType&&parent.property===node||"OptionalMemberExpression"===parentType&&parent.property===node||"TemplateLiteral"===parentType)return  false;if("ClassDeclaration"===parentType)return  true;if("ForOfStatement"===parentType)return parent.right===node;if("ExportDefaultDeclaration"===parentType)return  true;return !isStatement(parent)},exports.TSSatisfiesExpression=exports.TSAsExpression=function(node,parent){if(("AssignmentExpression"===parent.type||"AssignmentPattern"===parent.type)&&parent.left===node)return  true;if("BinaryExpression"===parent.type&&("|"===parent.operator||"&"===parent.operator)&&node===parent.left)return  true;return Binary(node,parent)},exports.TSInferType=function(node,parent){const parentType=parent.type;return "TSArrayType"===parentType||"TSOptionalType"===parentType},exports.TSInstantiationExpression=function(node,parent){const parentType=parent.type;return ("CallExpression"===parentType||"OptionalCallExpression"===parentType||"NewExpression"===parentType||"TSInstantiationExpression"===parentType)&&!!parent.typeParameters},exports.UnaryLike=exports.TSTypeAssertion=UnaryLike,exports.TSIntersectionType=exports.TSUnionType=function(node,parent){const parentType=parent.type;return "TSArrayType"===parentType||"TSOptionalType"===parentType||"TSIntersectionType"===parentType||"TSRestType"===parentType},exports.IntersectionTypeAnnotation=exports.UnionTypeAnnotation=function(node,parent){const parentType=parent.type;return "ArrayTypeAnnotation"===parentType||"NullableTypeAnnotation"===parentType||"IntersectionTypeAnnotation"===parentType||"UnionTypeAnnotation"===parentType},exports.UpdateExpression=function(node,parent){return hasPostfixPart(node,parent)||isClassExtendsClause(node,parent)},exports.AwaitExpression=exports.YieldExpression=function(node,parent){const parentType=parent.type;return "BinaryExpression"===parentType||"LogicalExpression"===parentType||"UnaryExpression"===parentType||"SpreadElement"===parentType||hasPostfixPart(node,parent)||"AwaitExpression"===parentType&&isYieldExpression(node)||"ConditionalExpression"===parentType&&node===parent.test||isClassExtendsClause(node,parent)||isTSTypeExpression(parentType)};var _t=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js"),_index=__webpack_require__("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/node/index.js");const{isArrayTypeAnnotation,isBinaryExpression,isCallExpression,isForOfStatement,isIndexedAccessType,isMemberExpression,isObjectPattern,isOptionalMemberExpression,isYieldExpression,isStatement}=_t,PRECEDENCE=new Map([["||",0],["??",0],["|>",0],["&&",1],["|",2],["^",3],["&",4],["==",5],["===",5],["!=",5],["!==",5],["<",6],[">",6],["<=",6],[">=",6],["in",6],["instanceof",6],[">>",7],["<<",7],[">>>",7],["+",8],["-",8],["*",9],["/",9],["%",9],["**",10]]);function getBinaryPrecedence(node,nodeType){return "BinaryExpression"===nodeType||"LogicalExpression"===nodeType?PRECEDENCE.get(node.operator):"TSAsExpression"===nodeType||"TSSatisfiesExpression"===nodeType?PRECEDENCE.get("in"):void 0}function isTSTypeExpression(nodeType){return "TSAsExpression"===nodeType||"TSSatisfiesExpression"===nodeType||"TSTypeAssertion"===nodeType}const isClassExtendsClause=(node,parent)=>{const parentType=parent.type;return ("ClassDeclaration"===parentType||"ClassExpression"===parentType)&&parent.superClass===node},hasPostfixPart=(node,parent)=>{const parentType=parent.type;return ("MemberExpression"===parentType||"OptionalMemberExpression"===parentType)&&parent.object===node||("CallExpression"===parentType||"OptionalCallExpression"===parentType||"NewExpression"===parentType)&&parent.callee===node||"TaggedTemplateExpression"===parentType&&parent.tag===node||"TSNonNullExpression"===parentType};function needsParenBeforeExpressionBrace(tokenContext){return Boolean(tokenContext&(_index.TokenContext.expressionStatement|_index.TokenContext.arrowBody))}function Binary(node,parent){const parentType=parent.type;if("BinaryExpression"===node.type&&"**"===node.operator&&"BinaryExpression"===parentType&&"**"===parent.operator)return parent.left===node;if(isClassExtendsClause(node,parent))return  true;if(hasPostfixPart(node,parent)||"UnaryExpression"===parentType||"SpreadElement"===parentType||"AwaitExpression"===parentType)return  true;const parentPos=getBinaryPrecedence(parent,parentType);if(null!=parentPos){const nodePos=getBinaryPrecedence(node,node.type);if(parentPos===nodePos&&"BinaryExpression"===parentType&&parent.right===node||parentPos>nodePos)return  true}}function UnaryLike(node,parent){return hasPostfixPart(node,parent)||isBinaryExpression(parent)&&"**"===parent.operator&&parent.left===node||isClassExtendsClause(node,parent)}function ConditionalExpression(node,parent){const parentType=parent.type;return !!("UnaryExpression"===parentType||"SpreadElement"===parentType||"BinaryExpression"===parentType||"LogicalExpression"===parentType||"ConditionalExpression"===parentType&&parent.test===node||"AwaitExpression"===parentType||isTSTypeExpression(parentType))||UnaryLike(node,parent)}},"./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/node/whitespace.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.nodes=void 0;var _t=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js");const{FLIPPED_ALIAS_KEYS,isArrayExpression,isAssignmentExpression,isBinary,isBlockStatement,isCallExpression,isFunction,isIdentifier,isLiteral,isMemberExpression,isObjectExpression,isOptionalCallExpression,isOptionalMemberExpression,isStringLiteral}=_t;function crawlInternal(node,state){return node?(isMemberExpression(node)||isOptionalMemberExpression(node)?(crawlInternal(node.object,state),node.computed&&crawlInternal(node.property,state)):isBinary(node)||isAssignmentExpression(node)?(crawlInternal(node.left,state),crawlInternal(node.right,state)):isCallExpression(node)||isOptionalCallExpression(node)?(state.hasCall=true,crawlInternal(node.callee,state)):isFunction(node)?state.hasFunction=true:isIdentifier(node)&&(state.hasHelper=state.hasHelper||node.callee&&isHelper(node.callee)),state):state}function crawl(node){return crawlInternal(node,{hasCall:false,hasFunction:false,hasHelper:false})}function isHelper(node){return !!node&&(isMemberExpression(node)?isHelper(node.object)||isHelper(node.property):isIdentifier(node)?"require"===node.name||95===node.name.charCodeAt(0):isCallExpression(node)?isHelper(node.callee):!(!isBinary(node)&&!isAssignmentExpression(node))&&(isIdentifier(node.left)&&isHelper(node.left)||isHelper(node.right)))}function isType(node){return isLiteral(node)||isObjectExpression(node)||isArrayExpression(node)||isIdentifier(node)||isMemberExpression(node)}const nodes=exports.nodes={AssignmentExpression(node){const state=crawl(node.right);if(state.hasCall&&state.hasHelper||state.hasFunction)return state.hasFunction?3:2},SwitchCase:(node,parent)=>(node.consequent.length||parent.cases[0]===node?1:0)|(node.consequent.length||parent.cases[parent.cases.length-1]!==node?0:2),LogicalExpression(node){if(isFunction(node.left)||isFunction(node.right))return 2},Literal(node){if(isStringLiteral(node)&&"use strict"===node.value)return 2},CallExpression(node){if(isFunction(node.callee)||isHelper(node))return 3},OptionalCallExpression(node){if(isFunction(node.callee))return 3},VariableDeclaration(node){for(let i=0;i<node.declarations.length;i++){const declar=node.declarations[i];let enabled=isHelper(declar.id)&&!isType(declar.init);if(!enabled&&declar.init){const state=crawl(declar.init);enabled=isHelper(declar.init)&&state.hasCall||state.hasFunction;}if(enabled)return 3}},IfStatement(node){if(isBlockStatement(node.consequent))return 3}};nodes.ObjectProperty=nodes.ObjectTypeProperty=nodes.ObjectMethod=function(node,parent){if(parent.properties[0]===node)return 1},nodes.ObjectTypeCallProperty=function(node,parent){var _parent$properties;if(parent.callProperties[0]===node&&(null==(_parent$properties=parent.properties)||!_parent$properties.length))return 1},nodes.ObjectTypeIndexer=function(node,parent){var _parent$properties2,_parent$callPropertie;if(!(parent.indexers[0]!==node||null!=(_parent$properties2=parent.properties)&&_parent$properties2.length||null!=(_parent$callPropertie=parent.callProperties)&&_parent$callPropertie.length))return 1},nodes.ObjectTypeInternalSlot=function(node,parent){var _parent$properties3,_parent$callPropertie2,_parent$indexers;if(!(parent.internalSlots[0]!==node||null!=(_parent$properties3=parent.properties)&&_parent$properties3.length||null!=(_parent$callPropertie2=parent.callProperties)&&_parent$callPropertie2.length||null!=(_parent$indexers=parent.indexers)&&_parent$indexers.length))return 1},[["Function",true],["Class",true],["Loop",true],["LabeledStatement",true],["SwitchStatement",true],["TryStatement",true]].forEach((function([type,amounts]){[type].concat(FLIPPED_ALIAS_KEYS[type]||[]).forEach((function(type){const ret=amounts?3:0;nodes[type]=()=>ret;}));}));},"./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/printer.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=void 0;var _buffer=__webpack_require__("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/buffer.js"),n=__webpack_require__("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/node/index.js"),_t=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js"),_tokenMap=__webpack_require__("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/token-map.js"),generatorFunctions=__webpack_require__("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/generators/index.js");const{isExpression,isFunction,isStatement,isClassBody,isTSInterfaceBody,isTSEnumDeclaration}=_t,SCIENTIFIC_NOTATION=/e/i,ZERO_DECIMAL_INTEGER=/\.0+$/,HAS_NEWLINE=/[\n\r\u2028\u2029]/,HAS_NEWLINE_OR_BlOCK_COMMENT_END=/[\n\r\u2028\u2029]|\*\//;function commentIsNewline(c){return "CommentLine"===c.type||HAS_NEWLINE.test(c.value)}const{needsParens}=n;class Printer{constructor(format,map,tokens,originalCode){this.inForStatementInit=false,this.tokenContext=0,this._tokens=null,this._originalCode=null,this._currentNode=null,this._indent=0,this._indentRepeat=0,this._insideAux=false,this._noLineTerminator=false,this._noLineTerminatorAfterNode=null,this._printAuxAfterOnNextUserNode=false,this._printedComments=new Set,this._endsWithInteger=false,this._endsWithWord=false,this._endsWithDiv=false,this._lastCommentLine=0,this._endsWithInnerRaw=false,this._indentInnerComments=true,this.tokenMap=null,this._boundGetRawIdentifier=this._getRawIdentifier.bind(this),this._printSemicolonBeforeNextNode=-1,this._printSemicolonBeforeNextToken=-1,this.format=format,this._tokens=tokens,this._originalCode=originalCode,this._indentRepeat=format.indent.style.length,this._inputMap=null==map?void 0:map._inputMap,this._buf=new _buffer.default(map,format.indent.style[0]);}enterForStatementInit(){return this.inForStatementInit?()=>{}:(this.inForStatementInit=true,()=>{this.inForStatementInit=false;})}enterDelimited(){const oldInForStatementInit=this.inForStatementInit,oldNoLineTerminatorAfterNode=this._noLineTerminatorAfterNode;return  false===oldInForStatementInit&&null===oldNoLineTerminatorAfterNode?()=>{}:(this.inForStatementInit=false,this._noLineTerminatorAfterNode=null,()=>{this.inForStatementInit=oldInForStatementInit,this._noLineTerminatorAfterNode=oldNoLineTerminatorAfterNode;})}generate(ast){return this.format.preserveFormat&&(this.tokenMap=new _tokenMap.TokenMap(ast,this._tokens,this._originalCode)),this.print(ast),this._maybeAddAuxComment(),this._buf.get()}indent(){const{format}=this;format.preserveFormat||format.compact||format.concise||this._indent++;}dedent(){const{format}=this;format.preserveFormat||format.compact||format.concise||this._indent--;}semicolon(force=false){if(this._maybeAddAuxComment(),force)return this._appendChar(59),void(this._noLineTerminator=false);if(this.tokenMap){const node=this._currentNode;if(null!=node.start&&null!=node.end){if(!this.tokenMap.endMatches(node,";"))return void(this._printSemicolonBeforeNextNode=this._buf.getCurrentLine());const indexes=this.tokenMap.getIndexes(this._currentNode);this._catchUpTo(this._tokens[indexes[indexes.length-1]].loc.start);}}this._queue(59),this._noLineTerminator=false;}rightBrace(node){this.format.minified&&this._buf.removeLastSemicolon(),this.sourceWithOffset("end",node.loc,-1),this.tokenChar(125);}rightParens(node){this.sourceWithOffset("end",node.loc,-1),this.tokenChar(41);}space(force=false){const{format}=this;if(!format.compact&&!format.preserveFormat)if(force)this._space();else if(this._buf.hasContent()){const lastCp=this.getLastChar();32!==lastCp&&10!==lastCp&&this._space();}}word(str,noLineTerminatorAfter=false){this.tokenContext=0,this._maybePrintInnerComments(str),this._maybeAddAuxComment(),this.tokenMap&&this._catchUpToCurrentToken(str),(this._endsWithWord||this._endsWithDiv&&47===str.charCodeAt(0))&&this._space(),this._append(str,false),this._endsWithWord=true,this._noLineTerminator=noLineTerminatorAfter;}number(str,number){this.word(str),this._endsWithInteger=Number.isInteger(number)&&!function(str){if(str.length>2&&48===str.charCodeAt(0)){const secondChar=str.charCodeAt(1);return 98===secondChar||111===secondChar||120===secondChar}return  false}(str)&&!SCIENTIFIC_NOTATION.test(str)&&!ZERO_DECIMAL_INTEGER.test(str)&&46!==str.charCodeAt(str.length-1);}token(str,maybeNewline=false,occurrenceCount=0){this.tokenContext=0,this._maybePrintInnerComments(str,occurrenceCount),this._maybeAddAuxComment(),this.tokenMap&&this._catchUpToCurrentToken(str,occurrenceCount);const lastChar=this.getLastChar(),strFirst=str.charCodeAt(0);(33===lastChar&&("--"===str||61===strFirst)||43===strFirst&&43===lastChar||45===strFirst&&45===lastChar||46===strFirst&&this._endsWithInteger)&&this._space(),this._append(str,maybeNewline),this._noLineTerminator=false;}tokenChar(char){this.tokenContext=0;const str=String.fromCharCode(char);this._maybePrintInnerComments(str),this._maybeAddAuxComment(),this.tokenMap&&this._catchUpToCurrentToken(str);const lastChar=this.getLastChar();(43===char&&43===lastChar||45===char&&45===lastChar||46===char&&this._endsWithInteger)&&this._space(),this._appendChar(char),this._noLineTerminator=false;}newline(i=1,force){if(!(i<=0)){if(!force){if(this.format.retainLines||this.format.compact)return;if(this.format.concise)return void this.space()}i>2&&(i=2),i-=this._buf.getNewlineCount();for(let j=0;j<i;j++)this._newline();}}endsWith(char){return this.getLastChar()===char}getLastChar(){return this._buf.getLastChar()}endsWithCharAndNewline(){return this._buf.endsWithCharAndNewline()}removeTrailingNewline(){this._buf.removeTrailingNewline();}exactSource(loc,cb){loc?(this._catchUp("start",loc),this._buf.exactSource(loc,cb)):cb();}source(prop,loc){loc&&(this._catchUp(prop,loc),this._buf.source(prop,loc));}sourceWithOffset(prop,loc,columnOffset){loc&&!this.format.preserveFormat&&(this._catchUp(prop,loc),this._buf.sourceWithOffset(prop,loc,columnOffset));}sourceIdentifierName(identifierName,pos){if(!this._buf._canMarkIdName)return;const sourcePosition=this._buf._sourcePosition;sourcePosition.identifierNamePos=pos,sourcePosition.identifierName=identifierName;}_space(){this._queue(32);}_newline(){this._queue(10);}_catchUpToCurrentToken(str,occurrenceCount=0){const token=this.tokenMap.findMatching(this._currentNode,str,occurrenceCount);token&&this._catchUpTo(token.loc.start),-1!==this._printSemicolonBeforeNextToken&&this._printSemicolonBeforeNextToken===this._buf.getCurrentLine()&&(this._buf.appendChar(59),this._endsWithWord=false,this._endsWithInteger=false,this._endsWithDiv=false),this._printSemicolonBeforeNextToken=-1,this._printSemicolonBeforeNextNode=-1;}_append(str,maybeNewline){this._maybeIndent(str.charCodeAt(0)),this._buf.append(str,maybeNewline),this._endsWithWord=false,this._endsWithInteger=false,this._endsWithDiv=false;}_appendChar(char){this._maybeIndent(char),this._buf.appendChar(char),this._endsWithWord=false,this._endsWithInteger=false,this._endsWithDiv=false;}_queue(char){this._maybeIndent(char),this._buf.queue(char),this._endsWithWord=false,this._endsWithInteger=false;}_maybeIndent(firstChar){this._indent&&10!==firstChar&&this.endsWith(10)&&this._buf.queueIndentation(this._getIndent());}_shouldIndent(firstChar){if(this._indent&&10!==firstChar&&this.endsWith(10))return  true}catchUp(line){if(!this.format.retainLines)return;const count=line-this._buf.getCurrentLine();for(let i=0;i<count;i++)this._newline();}_catchUp(prop,loc){const{format}=this;if(!format.preserveFormat)return void(format.retainLines&&null!=loc&&loc[prop]&&this.catchUp(loc[prop].line));const pos=null==loc?void 0:loc[prop];null!=pos&&this._catchUpTo(pos);}_catchUpTo({line,column,index}){const count=line-this._buf.getCurrentLine();if(count>0&&this._noLineTerminator)return;for(let i=0;i<count;i++)this._newline();const spacesCount=count>0?column:column-this._buf.getCurrentColumn();if(spacesCount>0){const spaces=this._originalCode?this._originalCode.slice(index-spacesCount,index).replace(/[^\t\x0B\f \xA0\u1680\u2000-\u200A\u202F\u205F\u3000\uFEFF]/gu," "):" ".repeat(spacesCount);this._append(spaces,false);}}_getIndent(){return this._indentRepeat*this._indent}printTerminatorless(node){this._noLineTerminator=true,this.print(node);}print(node,noLineTerminatorAfter,trailingCommentsLineOffset){var _node$extra,_node$leadingComments,_node$leadingComments2;if(!node)return;this._endsWithInnerRaw=false;const nodeType=node.type,format=this.format,oldConcise=format.concise;node._compact&&(format.concise=true);const printMethod=this[nodeType];if(void 0===printMethod)throw new ReferenceError(`unknown node of type ${JSON.stringify(nodeType)} with constructor ${JSON.stringify(node.constructor.name)}`);const parent=this._currentNode;this._currentNode=node,this.tokenMap&&(this._printSemicolonBeforeNextToken=this._printSemicolonBeforeNextNode);const oldInAux=this._insideAux;this._insideAux=null==node.loc,this._maybeAddAuxComment(this._insideAux&&!oldInAux);const parenthesized=null==(_node$extra=node.extra)?void 0:_node$extra.parenthesized;let shouldPrintParens=parenthesized&&format.preserveFormat||parenthesized&&format.retainFunctionParens&&"FunctionExpression"===nodeType||needsParens(node,parent,this.tokenContext,this.inForStatementInit,format.preserveFormat?this._boundGetRawIdentifier:void 0);if(!shouldPrintParens&&parenthesized&&null!=(_node$leadingComments=node.leadingComments)&&_node$leadingComments.length&&"CommentBlock"===node.leadingComments[0].type){switch(null==parent?void 0:parent.type){case "ExpressionStatement":case "VariableDeclarator":case "AssignmentExpression":case "ReturnStatement":break;case "CallExpression":case "OptionalCallExpression":case "NewExpression":if(parent.callee!==node)break;default:shouldPrintParens=true;}}let oldNoLineTerminatorAfterNode,oldInForStatementInitWasTrue,indentParenthesized=false;var _node$trailingComment;(!shouldPrintParens&&this._noLineTerminator&&(null!=(_node$leadingComments2=node.leadingComments)&&_node$leadingComments2.some(commentIsNewline)||this.format.retainLines&&node.loc&&node.loc.start.line>this._buf.getCurrentLine())&&(shouldPrintParens=true,indentParenthesized=true),shouldPrintParens)||(noLineTerminatorAfter||(noLineTerminatorAfter=parent&&this._noLineTerminatorAfterNode===parent&&n.isLastChild(parent,node)),noLineTerminatorAfter&&(null!=(_node$trailingComment=node.trailingComments)&&_node$trailingComment.some(commentIsNewline)?isExpression(node)&&(shouldPrintParens=true):(oldNoLineTerminatorAfterNode=this._noLineTerminatorAfterNode,this._noLineTerminatorAfterNode=node)));shouldPrintParens&&(this.tokenChar(40),indentParenthesized&&this.indent(),this._endsWithInnerRaw=false,this.inForStatementInit&&(oldInForStatementInitWasTrue=true,this.inForStatementInit=false),oldNoLineTerminatorAfterNode=this._noLineTerminatorAfterNode,this._noLineTerminatorAfterNode=null),this._lastCommentLine=0,this._printLeadingComments(node,parent);const loc="Program"===nodeType||"File"===nodeType?null:node.loc;this.exactSource(loc,printMethod.bind(this,node,parent)),shouldPrintParens?(this._printTrailingComments(node,parent),indentParenthesized&&(this.dedent(),this.newline()),this.tokenChar(41),this._noLineTerminator=noLineTerminatorAfter,oldInForStatementInitWasTrue&&(this.inForStatementInit=true)):noLineTerminatorAfter&&!this._noLineTerminator?(this._noLineTerminator=true,this._printTrailingComments(node,parent)):this._printTrailingComments(node,parent,trailingCommentsLineOffset),this._currentNode=parent,format.concise=oldConcise,this._insideAux=oldInAux,void 0!==oldNoLineTerminatorAfterNode&&(this._noLineTerminatorAfterNode=oldNoLineTerminatorAfterNode),this._endsWithInnerRaw=false;}_maybeAddAuxComment(enteredPositionlessNode){enteredPositionlessNode&&this._printAuxBeforeComment(),this._insideAux||this._printAuxAfterComment();}_printAuxBeforeComment(){if(this._printAuxAfterOnNextUserNode)return;this._printAuxAfterOnNextUserNode=true;const comment=this.format.auxiliaryCommentBefore;comment&&this._printComment({type:"CommentBlock",value:comment},0);}_printAuxAfterComment(){if(!this._printAuxAfterOnNextUserNode)return;this._printAuxAfterOnNextUserNode=false;const comment=this.format.auxiliaryCommentAfter;comment&&this._printComment({type:"CommentBlock",value:comment},0);}getPossibleRaw(node){const extra=node.extra;if(null!=(null==extra?void 0:extra.raw)&&null!=extra.rawValue&&node.value===extra.rawValue)return extra.raw}printJoin(nodes,statement,indent,separator,printTrailingSeparator,addNewlines,iterator,trailingCommentsLineOffset){if(null==nodes||!nodes.length)return;if(null==indent&&this.format.retainLines){var _nodes$0$loc;const startLine=null==(_nodes$0$loc=nodes[0].loc)?void 0:_nodes$0$loc.start.line;null!=startLine&&startLine!==this._buf.getCurrentLine()&&(indent=true);}indent&&this.indent();const newlineOpts={addNewlines,nextNodeStartLine:0},boundSeparator=null==separator?void 0:separator.bind(this),len=nodes.length;for(let i=0;i<len;i++){const node=nodes[i];var _node$trailingComment2;if(node)if(statement&&this._printNewline(0===i,newlineOpts),this.print(node,void 0,trailingCommentsLineOffset||0),null==iterator||iterator(node,i),null!=boundSeparator&&(i<len-1?boundSeparator(i,false):printTrailingSeparator&&boundSeparator(i,true)),statement)if(null!=(_node$trailingComment2=node.trailingComments)&&_node$trailingComment2.length||(this._lastCommentLine=0),i+1===len)this.newline(1);else {var _nextNode$loc;const nextNode=nodes[i+1];newlineOpts.nextNodeStartLine=(null==(_nextNode$loc=nextNode.loc)?void 0:_nextNode$loc.start.line)||0,this._printNewline(true,newlineOpts);}}indent&&this.dedent();}printAndIndentOnComments(node){const indent=node.leadingComments&&node.leadingComments.length>0;indent&&this.indent(),this.print(node),indent&&this.dedent();}printBlock(parent){const node=parent.body;"EmptyStatement"!==node.type&&this.space(),this.print(node);}_printTrailingComments(node,parent,lineOffset){const{innerComments,trailingComments}=node;null!=innerComments&&innerComments.length&&this._printComments(2,innerComments,node,parent,lineOffset),null!=trailingComments&&trailingComments.length&&this._printComments(2,trailingComments,node,parent,lineOffset);}_printLeadingComments(node,parent){const comments=node.leadingComments;null!=comments&&comments.length&&this._printComments(0,comments,node,parent);}_maybePrintInnerComments(nextTokenStr,nextTokenOccurrenceCount){var _this$tokenMap;this._endsWithInnerRaw&&this.printInnerComments(null==(_this$tokenMap=this.tokenMap)?void 0:_this$tokenMap.findMatching(this._currentNode,nextTokenStr,nextTokenOccurrenceCount));this._endsWithInnerRaw=true,this._indentInnerComments=true;}printInnerComments(nextToken){const node=this._currentNode,comments=node.innerComments;if(null==comments||!comments.length)return;const hasSpace=this.endsWith(32),indent=this._indentInnerComments,printedCommentsCount=this._printedComments.size;indent&&this.indent(),this._printComments(1,comments,node,void 0,void 0,nextToken),hasSpace&&printedCommentsCount!==this._printedComments.size&&this.space(),indent&&this.dedent();}noIndentInnerCommentsHere(){this._indentInnerComments=false;}printSequence(nodes,indent,trailingCommentsLineOffset,addNewlines){this.printJoin(nodes,true,null!=indent&&indent,void 0,void 0,addNewlines,void 0,trailingCommentsLineOffset);}printList(items,printTrailingSeparator,statement,indent,separator,iterator){this.printJoin(items,statement,indent,null!=separator?separator:commaSeparator,printTrailingSeparator,void 0,iterator);}shouldPrintTrailingComma(listEnd){if(!this.tokenMap)return null;const listEndIndex=this.tokenMap.findLastIndex(this._currentNode,(token=>this.tokenMap.matchesOriginal(token,listEnd)));return listEndIndex<=0?null:this.tokenMap.matchesOriginal(this._tokens[listEndIndex-1],",")}_printNewline(newLine,opts){const format=this.format;if(format.retainLines||format.compact)return;if(format.concise)return void this.space();if(!newLine)return;const startLine=opts.nextNodeStartLine,lastCommentLine=this._lastCommentLine;if(startLine>0&&lastCommentLine>0){const offset=startLine-lastCommentLine;if(offset>=0)return void this.newline(offset||1)}this._buf.hasContent()&&this.newline(1);}_shouldPrintComment(comment,nextToken){if(comment.ignore)return 0;if(this._printedComments.has(comment))return 0;if(this._noLineTerminator&&HAS_NEWLINE_OR_BlOCK_COMMENT_END.test(comment.value))return 2;if(nextToken&&this.tokenMap){const commentTok=this.tokenMap.find(this._currentNode,(token=>token.value===comment.value));if(commentTok&&commentTok.start>nextToken.start)return 2}return this._printedComments.add(comment),this.format.shouldPrintComment(comment.value)?1:0}_printComment(comment,skipNewLines){const noLineTerminator=this._noLineTerminator,isBlockComment="CommentBlock"===comment.type,printNewLines=isBlockComment&&1!==skipNewLines&&!this._noLineTerminator;printNewLines&&this._buf.hasContent()&&2!==skipNewLines&&this.newline(1);const lastCharCode=this.getLastChar();let val;if(91!==lastCharCode&&123!==lastCharCode&&40!==lastCharCode&&this.space(),isBlockComment){if(val=`/*${comment.value}*/`,this.format.indent.adjustMultilineComment){var _comment$loc;const offset=null==(_comment$loc=comment.loc)?void 0:_comment$loc.start.column;if(offset){const newlineRegex=new RegExp("\\n\\s{1,"+offset+"}","g");val=val.replace(newlineRegex,"\n");}if(this.format.concise)val=val.replace(/\n(?!$)/g,"\n");else {let indentSize=this.format.retainLines?0:this._buf.getCurrentColumn();(this._shouldIndent(47)||this.format.retainLines)&&(indentSize+=this._getIndent()),val=val.replace(/\n(?!$)/g,`\n${" ".repeat(indentSize)}`);}}}else val=noLineTerminator?`/*${comment.value}*/`:`//${comment.value}`;if(this._endsWithDiv&&this._space(),this.tokenMap){const{_printSemicolonBeforeNextToken,_printSemicolonBeforeNextNode}=this;this._printSemicolonBeforeNextToken=-1,this._printSemicolonBeforeNextNode=-1,this.source("start",comment.loc),this._append(val,isBlockComment),this._printSemicolonBeforeNextNode=_printSemicolonBeforeNextNode,this._printSemicolonBeforeNextToken=_printSemicolonBeforeNextToken;}else this.source("start",comment.loc),this._append(val,isBlockComment);isBlockComment||noLineTerminator||this.newline(1,true),printNewLines&&3!==skipNewLines&&this.newline(1);}_printComments(type,comments,node,parent,lineOffset=0,nextToken){const nodeLoc=node.loc,len=comments.length;let hasLoc=!!nodeLoc;const nodeStartLine=hasLoc?nodeLoc.start.line:0,nodeEndLine=hasLoc?nodeLoc.end.line:0;let lastLine=0,leadingCommentNewline=0;const maybeNewline=this._noLineTerminator?function(){}:this.newline.bind(this);for(let i=0;i<len;i++){const comment=comments[i],shouldPrint=this._shouldPrintComment(comment,nextToken);if(2===shouldPrint){hasLoc=false;break}if(hasLoc&&comment.loc&&1===shouldPrint){const commentStartLine=comment.loc.start.line,commentEndLine=comment.loc.end.line;if(0===type){let offset=0;0===i?!this._buf.hasContent()||"CommentLine"!==comment.type&&commentStartLine===commentEndLine||(offset=leadingCommentNewline=1):offset=commentStartLine-lastLine,lastLine=commentEndLine,maybeNewline(offset),this._printComment(comment,1),i+1===len&&(maybeNewline(Math.max(nodeStartLine-lastLine,leadingCommentNewline)),lastLine=nodeStartLine);}else if(1===type){const offset=commentStartLine-(0===i?nodeStartLine:lastLine);lastLine=commentEndLine,maybeNewline(offset),this._printComment(comment,1),i+1===len&&(maybeNewline(Math.min(1,nodeEndLine-lastLine)),lastLine=nodeEndLine);}else {const offset=commentStartLine-(0===i?nodeEndLine-lineOffset:lastLine);lastLine=commentEndLine,maybeNewline(offset),this._printComment(comment,1);}}else {if(hasLoc=false,1!==shouldPrint)continue;if(1===len){const singleLine=comment.loc?comment.loc.start.line===comment.loc.end.line:!HAS_NEWLINE.test(comment.value),shouldSkipNewline=singleLine&&!isStatement(node)&&!isClassBody(parent)&&!isTSInterfaceBody(parent)&&!isTSEnumDeclaration(parent);0===type?this._printComment(comment,shouldSkipNewline&&"ObjectExpression"!==node.type||singleLine&&isFunction(parent,{body:node})?1:0):shouldSkipNewline&&2===type?this._printComment(comment,1):this._printComment(comment,0);}else 1!==type||"ObjectExpression"===node.type&&node.properties.length>1||"ClassBody"===node.type||"TSInterfaceBody"===node.type?this._printComment(comment,0):this._printComment(comment,0===i?2:i===len-1?3:0);}}2===type&&hasLoc&&lastLine&&(this._lastCommentLine=lastLine);}}Object.assign(Printer.prototype,generatorFunctions),Printer.prototype.Noop=function(){};exports.default=Printer;function commaSeparator(occurrenceCount,last){this.token(",",false,occurrenceCount),last||this.space();}},"./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/source-map.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=void 0;var _genMapping=__webpack_require__("./node_modules/.pnpm/@jridgewell+gen-mapping@0.3.8/node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js"),_traceMapping=__webpack_require__("./node_modules/.pnpm/@jridgewell+trace-mapping@0.3.25/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js");exports.default=class{constructor(opts,code){var _opts$sourceFileName;this._map=void 0,this._rawMappings=void 0,this._sourceFileName=void 0,this._lastGenLine=0,this._lastSourceLine=0,this._lastSourceColumn=0,this._inputMap=void 0;const map=this._map=new _genMapping.GenMapping({sourceRoot:opts.sourceRoot});if(this._sourceFileName=null==(_opts$sourceFileName=opts.sourceFileName)?void 0:_opts$sourceFileName.replace(/\\/g,"/"),this._rawMappings=void 0,opts.inputSourceMap){this._inputMap=new _traceMapping.TraceMap(opts.inputSourceMap);const resolvedSources=this._inputMap.resolvedSources;if(resolvedSources.length)for(let i=0;i<resolvedSources.length;i++){var _this$_inputMap$sourc;(0, _genMapping.setSourceContent)(map,resolvedSources[i],null==(_this$_inputMap$sourc=this._inputMap.sourcesContent)?void 0:_this$_inputMap$sourc[i]);}}if("string"!=typeof code||opts.inputSourceMap){if("object"==typeof code)for(const sourceFileName of Object.keys(code))(0, _genMapping.setSourceContent)(map,sourceFileName.replace(/\\/g,"/"),code[sourceFileName]);}else (0, _genMapping.setSourceContent)(map,this._sourceFileName,code);}get(){return (0, _genMapping.toEncodedMap)(this._map)}getDecoded(){return (0, _genMapping.toDecodedMap)(this._map)}getRawMappings(){return this._rawMappings||(this._rawMappings=(0, _genMapping.allMappings)(this._map))}mark(generated,line,column,identifierName,identifierNamePos,filename){var _originalMapping;let originalMapping;if(this._rawMappings=void 0,null!=line)if(this._inputMap){if(originalMapping=(0, _traceMapping.originalPositionFor)(this._inputMap,{line,column}),!originalMapping.name&&identifierNamePos){const originalIdentifierMapping=(0, _traceMapping.originalPositionFor)(this._inputMap,identifierNamePos);originalIdentifierMapping.name&&(identifierName=originalIdentifierMapping.name);}}else originalMapping={source:(null==filename?void 0:filename.replace(/\\/g,"/"))||this._sourceFileName,line,column};(0, _genMapping.maybeAddMapping)(this._map,{name:identifierName,generated,source:null==(_originalMapping=originalMapping)?void 0:_originalMapping.source,original:originalMapping});}};},"./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/token-map.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.TokenMap=void 0;var _t=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js");const{traverseFast,VISITOR_KEYS}=_t;exports.TokenMap=class{constructor(ast,tokens,source){this._tokens=void 0,this._source=void 0,this._nodesToTokenIndexes=new Map,this._nodesOccurrencesCountCache=new Map,this._tokensCache=new Map,this._tokens=tokens,this._source=source,traverseFast(ast,(node=>{const indexes=this._getTokensIndexesOfNode(node);indexes.length>0&&this._nodesToTokenIndexes.set(node,indexes);})),this._tokensCache=null;}has(node){return this._nodesToTokenIndexes.has(node)}getIndexes(node){return this._nodesToTokenIndexes.get(node)}find(node,condition){const indexes=this._nodesToTokenIndexes.get(node);if(indexes)for(let k=0;k<indexes.length;k++){const index=indexes[k],tok=this._tokens[index];if(condition(tok,index))return tok}return null}findLastIndex(node,condition){const indexes=this._nodesToTokenIndexes.get(node);if(indexes)for(let k=indexes.length-1;k>=0;k--){const index=indexes[k];if(condition(this._tokens[index],index))return index}return  -1}findMatching(node,test,occurrenceCount=0){const indexes=this._nodesToTokenIndexes.get(node);if(indexes){let i=0;const count=occurrenceCount;if(count>1){const cache=this._nodesOccurrencesCountCache.get(node);cache&&cache.test===test&&cache.count<count&&(i=cache.i+1,occurrenceCount-=cache.count+1);}for(;i<indexes.length;i++){const tok=this._tokens[indexes[i]];if(this.matchesOriginal(tok,test)){if(0===occurrenceCount)return count>0&&this._nodesOccurrencesCountCache.set(node,{test,count,i}),tok;occurrenceCount--;}}}return null}matchesOriginal(token,test){return token.end-token.start===test.length&&(null!=token.value?token.value===test:this._source.startsWith(test,token.start))}startMatches(node,test){const indexes=this._nodesToTokenIndexes.get(node);if(!indexes)return  false;const tok=this._tokens[indexes[0]];return tok.start===node.start&&this.matchesOriginal(tok,test)}endMatches(node,test){const indexes=this._nodesToTokenIndexes.get(node);if(!indexes)return  false;const tok=this._tokens[indexes[indexes.length-1]];return tok.end===node.end&&this.matchesOriginal(tok,test)}_getTokensIndexesOfNode(node){if(null==node.start||null==node.end)return [];const{first,last}=this._findTokensOfNode(node,0,this._tokens.length-1);let low=first;const children=function*(node){if("TemplateLiteral"===node.type){yield node.quasis[0];for(let i=1;i<node.quasis.length;i++)yield node.expressions[i-1],yield node.quasis[i];return}const keys=VISITOR_KEYS[node.type];for(const key of keys){const child=node[key];child&&(Array.isArray(child)?yield*child:yield child);}}(node);"ExportNamedDeclaration"!==node.type&&"ExportDefaultDeclaration"!==node.type||!node.declaration||"ClassDeclaration"!==node.declaration.type||children.next();const indexes=[];for(const child of children){if(null==child)continue;if(null==child.start||null==child.end)continue;const childTok=this._findTokensOfNode(child,low,last),high=childTok.first;for(let k=low;k<high;k++)indexes.push(k);low=childTok.last+1;}for(let k=low;k<=last;k++)indexes.push(k);return indexes}_findTokensOfNode(node,low,high){const cached=this._tokensCache.get(node);if(cached)return cached;const first=this._findFirstTokenOfNode(node.start,low,high),last=this._findLastTokenOfNode(node.end,first,high);return this._tokensCache.set(node,{first,last}),{first,last}}_findFirstTokenOfNode(start,low,high){for(;low<=high;){const mid=high+low>>1;if(start<this._tokens[mid].start)high=mid-1;else {if(!(start>this._tokens[mid].start))return mid;low=mid+1;}}return low}_findLastTokenOfNode(end,low,high){for(;low<=high;){const mid=high+low>>1;if(end<this._tokens[mid].end)high=mid-1;else {if(!(end>this._tokens[mid].end))return mid;low=mid+1;}}return high}};},"./node_modules/.pnpm/@babel+helper-annotate-as-pure@7.25.9/node_modules/@babel/helper-annotate-as-pure/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(pathOrNode){const node=pathOrNode.node||pathOrNode;if(isPureAnnotated(node))return;addComment(node,"leading",PURE_ANNOTATION);};var _t=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js");const{addComment}=_t,PURE_ANNOTATION="#__PURE__",isPureAnnotated=({leadingComments})=>!!leadingComments&&leadingComments.some((comment=>/[@#]__PURE__/.test(comment.value)));},"./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.25.9_@babel+core@7.26.0/node_modules/@babel/helper-create-class-features-plugin/lib/decorators-2018-09.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.buildDecoratedClass=function(ref,path,elements,file){const{node,scope}=path,initializeId=scope.generateUidIdentifier("initialize"),isDeclaration=node.id&&path.isDeclaration(),isStrict=path.isInStrictMode(),{superClass}=node;node.type="ClassDeclaration",node.id||(node.id=_core.types.cloneNode(ref));let superId;superClass&&(superId=scope.generateUidIdentifierBasedOnNode(node.superClass,"super"),node.superClass=superId);const classDecorators=takeDecorators(node),definitions=_core.types.arrayExpression(elements.filter((element=>!element.node.abstract&&"TSIndexSignature"!==element.node.type)).map((path=>function(file,classRef,superRef,path){const isMethod=path.isClassMethod();if(path.isPrivate())throw path.buildCodeFrameError(`Private ${isMethod?"methods":"fields"} in decorated classes are not supported yet.`);if("ClassAccessorProperty"===path.node.type)throw path.buildCodeFrameError('Accessor properties are not supported in 2018-09 decorator transform, please specify { "version": "2021-12" } instead.');if("StaticBlock"===path.node.type)throw path.buildCodeFrameError('Static blocks are not supported in 2018-09 decorator transform, please specify { "version": "2021-12" } instead.');const{node,scope}=path;path.isTSDeclareMethod()||new _helperReplaceSupers.default({methodPath:path,objectRef:classRef,superRef,file,refToPreserve:classRef}).replace();const properties=[prop("kind",_core.types.stringLiteral(_core.types.isClassMethod(node)?node.kind:"field")),prop("decorators",takeDecorators(node)),prop("static",node.static&&_core.types.booleanLiteral(true)),prop("key",getKey(node))].filter(Boolean);if(isMethod){null!=path.ensureFunctionName||(path.ensureFunctionName=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/index.js").NodePath.prototype.ensureFunctionName),path.ensureFunctionName(false),properties.push(prop("value",_core.types.toExpression(path.node)));}else _core.types.isClassProperty(node)&&node.value?properties.push((key="value",body=_core.template.statements.ast`return ${node.value}`,_core.types.objectMethod("method",_core.types.identifier(key),[],_core.types.blockStatement(body)))):properties.push(prop("value",scope.buildUndefinedNode()));var key,body;return path.remove(),_core.types.objectExpression(properties)}(file,node.id,superId,path)))),wrapperCall=_core.template.expression.ast`
    ${function(file){return file.addHelper("decorate")}(file)}(
      ${classDecorators||_core.types.nullLiteral()},
      function (${initializeId}, ${superClass?_core.types.cloneNode(superId):null}) {
        ${node}
        return { F: ${_core.types.cloneNode(node.id)}, d: ${definitions} };
      },
      ${superClass}
    )
  `;isStrict||wrapperCall.arguments[1].body.directives.push(_core.types.directive(_core.types.directiveLiteral("use strict")));let replacement=wrapperCall,classPathDesc="arguments.1.body.body.0";isDeclaration&&(replacement=_core.template.statement.ast`let ${ref} = ${wrapperCall}`,classPathDesc="declarations.0.init."+classPathDesc);return {instanceNodes:[_core.template.statement.ast`
        ${_core.types.cloneNode(initializeId)}(this)
      `],wrapClass:path=>(path.replaceWith(replacement),path.get(classPathDesc))}},exports.hasDecorators=function(node){return hasOwnDecorators(node)||node.body.body.some(hasOwnDecorators)},exports.hasOwnDecorators=hasOwnDecorators;var _core=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/index.js"),_helperReplaceSupers=__webpack_require__("./node_modules/.pnpm/@babel+helper-replace-supers@7.25.9_@babel+core@7.26.0/node_modules/@babel/helper-replace-supers/lib/index.js");function hasOwnDecorators(node){var _node$decorators;return !(null==(_node$decorators=node.decorators)||!_node$decorators.length)}function prop(key,value){return value?_core.types.objectProperty(_core.types.identifier(key),value):null}function takeDecorators(node){let result;return node.decorators&&node.decorators.length>0&&(result=_core.types.arrayExpression(node.decorators.map((decorator=>decorator.expression)))),node.decorators=void 0,result}function getKey(node){return node.computed?node.key:_core.types.isIdentifier(node.key)?_core.types.stringLiteral(node.key.name):_core.types.stringLiteral(String(node.key.value))}},"./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.25.9_@babel+core@7.26.0/node_modules/@babel/helper-create-class-features-plugin/lib/decorators.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function({assertVersion,assumption},{loose},version,inherits){var _assumption,_assumption2;assertVersion("2023-11"===version||"2023-05"===version||"2023-01"===version?"^7.21.0":"2021-12"===version?"^7.16.0":"^7.19.0");const VISITED=new WeakSet,constantSuper=null!=(_assumption=assumption("constantSuper"))?_assumption:loose,ignoreFunctionLength=null!=(_assumption2=assumption("ignoreFunctionLength"))?_assumption2:loose,namedEvaluationVisitor=function(isAnonymous,visitor){function handleComputedProperty(propertyPath,key,state){switch(key.type){case "StringLiteral":return _core.types.stringLiteral(key.value);case "NumericLiteral":case "BigIntLiteral":{const keyValue=key.value+"";return propertyPath.get("key").replaceWith(_core.types.stringLiteral(keyValue)),_core.types.stringLiteral(keyValue)}default:{const ref=propertyPath.scope.maybeGenerateMemoised(key);return propertyPath.get("key").replaceWith(_core.types.assignmentExpression("=",ref,createToPropertyKeyCall(state,key))),_core.types.cloneNode(ref)}}}return {VariableDeclarator(path,state){const id=path.node.id;if("Identifier"===id.type){const initializer=(0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers)(path.get("init"));if(isAnonymous(initializer)){const name=id.name;visitor(initializer,state,name);}}},AssignmentExpression(path,state){const id=path.node.left;if("Identifier"===id.type){const initializer=(0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers)(path.get("right"));if(isAnonymous(initializer))switch(path.node.operator){case "=":case "&&=":case "||=":case "??=":visitor(initializer,state,id.name);}}},AssignmentPattern(path,state){const id=path.node.left;if("Identifier"===id.type){const initializer=(0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers)(path.get("right"));if(isAnonymous(initializer)){const name=id.name;visitor(initializer,state,name);}}},ObjectExpression(path,state){for(const propertyPath of path.get("properties")){if(!propertyPath.isObjectProperty())continue;const{node}=propertyPath,id=node.key,initializer=(0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers)(propertyPath.get("value"));if(isAnonymous(initializer))if(node.computed){const ref=handleComputedProperty(propertyPath,id,state);visitor(initializer,state,ref);}else if(!isProtoKey(id))if("Identifier"===id.type)visitor(initializer,state,id.name);else {const className=_core.types.stringLiteral(id.value+"");visitor(initializer,state,className);}}},ClassPrivateProperty(path,state){const{node}=path,initializer=(0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers)(path.get("value"));if(isAnonymous(initializer)){const className=_core.types.stringLiteral("#"+node.key.id.name);visitor(initializer,state,className);}},ClassAccessorProperty(path,state){const{node}=path,id=node.key,initializer=(0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers)(path.get("value"));if(isAnonymous(initializer))if(node.computed){const ref=handleComputedProperty(path,id,state);visitor(initializer,state,ref);}else if("Identifier"===id.type)visitor(initializer,state,id.name);else if("PrivateName"===id.type){const className=_core.types.stringLiteral("#"+id.id.name);visitor(initializer,state,className);}else {const className=_core.types.stringLiteral(id.value+"");visitor(initializer,state,className);}},ClassProperty(path,state){const{node}=path,id=node.key,initializer=(0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers)(path.get("value"));if(isAnonymous(initializer))if(node.computed){const ref=handleComputedProperty(path,id,state);visitor(initializer,state,ref);}else if("Identifier"===id.type)visitor(initializer,state,id.name);else {const className=_core.types.stringLiteral(id.value+"");visitor(initializer,state,className);}}}}(isDecoratedAnonymousClassExpression,visitClass);function visitClass(path,state,className){var _node$id;if(VISITED.has(path))return;const{node}=path;null!=className||(className=null==(_node$id=node.id)?void 0:_node$id.name);const newPath=function(path,state,constantSuper,ignoreFunctionLength,className,propertyVisitor,version){var _path$node$id,_classDecorationsId;const body=path.get("body.body"),classDecorators=path.node.decorators;let hasElementDecorators=false,hasComputedKeysSideEffects=false,elemDecsUseFnContext=false;const generateClassPrivateUid=function(classPath){let generator;return ()=>(generator||(generator=function(classPath){const currentPrivateId=[],privateNames=new Set;return classPath.traverse({PrivateName(path){privateNames.add(path.node.id.name);}}),()=>{let reifiedId;do{incrementId(currentPrivateId),reifiedId=String.fromCharCode(...currentPrivateId);}while(privateNames.has(reifiedId));return _core.types.privateName(_core.types.identifier(reifiedId))}}(classPath)),generator())}(path),classAssignments=[],scopeParent=path.scope.parent,memoiseExpression=(expression,hint,assignments)=>{const localEvaluatedId=generateLetUidIdentifier(scopeParent,hint);return assignments.push(_core.types.assignmentExpression("=",localEvaluatedId,expression)),_core.types.cloneNode(localEvaluatedId)};let protoInitLocal,staticInitLocal;const classIdName=null==(_path$node$id=path.node.id)?void 0:_path$node$id.name,setClassName="object"==typeof className?className:void 0,usesFunctionContextOrYieldAwait=decorator=>{try{return _core.types.traverseFast(decorator,(node=>{if(_core.types.isThisExpression(node)||_core.types.isSuper(node)||_core.types.isYieldExpression(node)||_core.types.isAwaitExpression(node)||_core.types.isIdentifier(node,{name:"arguments"})||classIdName&&_core.types.isIdentifier(node,{name:classIdName})||_core.types.isMetaProperty(node)&&"import"!==node.meta.name)throw null})),!1}catch(_unused2){return  true}},instancePrivateNames=[];for(const element of body){if(!isClassDecoratableElementPath(element))continue;const elementNode=element.node;if(!elementNode.static&&_core.types.isPrivateName(elementNode.key)&&instancePrivateNames.push(elementNode.key.id.name),isDecorated(elementNode)){switch(elementNode.type){case "ClassProperty":propertyVisitor.ClassProperty(element,state);break;case "ClassPrivateProperty":propertyVisitor.ClassPrivateProperty(element,state);break;case "ClassAccessorProperty":if(propertyVisitor.ClassAccessorProperty(element,state),"2023-11"===version)break;default:if(elementNode.static)null!=staticInitLocal||(staticInitLocal=generateLetUidIdentifier(scopeParent,"initStatic"));else null!=protoInitLocal||(protoInitLocal=generateLetUidIdentifier(scopeParent,"initProto"));}hasElementDecorators=true,elemDecsUseFnContext||(elemDecsUseFnContext=elementNode.decorators.some(usesFunctionContextOrYieldAwait));}else if("ClassAccessorProperty"===elementNode.type){propertyVisitor.ClassAccessorProperty(element,state);const{key,value,static:isStatic,computed}=elementNode,newId=generateClassPrivateUid(),newField=generateClassProperty(newId,value,isStatic),keyPath=element.get("key"),[newPath]=element.replaceWith(newField);let getterKey,setterKey;computed&&!keyPath.isConstantExpression()?(getterKey=(0, _misc.memoiseComputedKey)(createToPropertyKeyCall(state,key),scopeParent,scopeParent.generateUid("computedKey")),setterKey=_core.types.cloneNode(getterKey.left)):(getterKey=_core.types.cloneNode(key),setterKey=_core.types.cloneNode(key)),assignIdForAnonymousClass(path,className),addProxyAccessorsFor(path.node.id,newPath,getterKey,setterKey,newId,computed,isStatic,version);}"computed"in element.node&&element.node.computed&&(hasComputedKeysSideEffects||(hasComputedKeysSideEffects=!scopeParent.isStatic(element.node.key)));}if(!classDecorators&&!hasElementDecorators)return path.node.id||"string"!=typeof className||(path.node.id=_core.types.identifier(className)),void(setClassName&&path.node.body.body.unshift(createStaticBlockFromExpressions([createSetFunctionNameCall(state,setClassName)])));const elementDecoratorInfo=[];let constructorPath;const decoratedPrivateMethods=new Set;let classInitLocal,classIdLocal,decoratorReceiverId=null;function handleDecorators(decorators){let hasSideEffects=false,usesFnContext=false;const decoratorsThis=[];for(const decorator of decorators){const{expression}=decorator;let object;if(("2023-11"===version||"2023-05"===version)&&_core.types.isMemberExpression(expression))if(_core.types.isSuper(expression.object))object=_core.types.thisExpression();else if(scopeParent.isStatic(expression.object))object=_core.types.cloneNode(expression.object);else {null!=decoratorReceiverId||(decoratorReceiverId=generateLetUidIdentifier(scopeParent,"obj")),object=_core.types.assignmentExpression("=",_core.types.cloneNode(decoratorReceiverId),expression.object),expression.object=_core.types.cloneNode(decoratorReceiverId);}decoratorsThis.push(object),hasSideEffects||(hasSideEffects=!scopeParent.isStatic(expression)),usesFnContext||(usesFnContext=usesFunctionContextOrYieldAwait(decorator));}return {hasSideEffects,usesFnContext,decoratorsThis}}const willExtractSomeElemDecs=hasComputedKeysSideEffects||elemDecsUseFnContext||"2023-11"!==version;let classDecorationsId,lastInstancePrivateName,needsDeclaraionForClassBinding=false,classDecorationsFlag=0,classDecorations=[],computedKeyAssignments=[];if(classDecorators){classInitLocal=generateLetUidIdentifier(scopeParent,"initClass"),needsDeclaraionForClassBinding=path.isClassDeclaration(),({id:classIdLocal,path}=function(path,className){const id=path.node.id,scope=path.scope;if("ClassDeclaration"===path.type){const className=id.name,varId=scope.generateUidIdentifierBasedOnNode(id),classId=_core.types.identifier(className);return scope.rename(className,varId.name),path.get("id").replaceWith(classId),{id:_core.types.cloneNode(varId),path}}{let varId;id?(className=id.name,varId=generateLetUidIdentifier(scope.parent,className),scope.rename(className,varId.name)):varId=generateLetUidIdentifier(scope.parent,"string"==typeof className?className:"decorated_class");const newClassExpr=_core.types.classExpression("string"==typeof className?_core.types.identifier(className):null,path.node.superClass,path.node.body),[newPath]=path.replaceWith(_core.types.sequenceExpression([newClassExpr,varId]));return {id:_core.types.cloneNode(varId),path:newPath.get("expressions.0")}}}(path,className)),path.node.decorators=null;const classDecsUsePrivateName=classDecorators.some(usesPrivateField),{hasSideEffects,usesFnContext,decoratorsThis}=handleDecorators(classDecorators),{haveThis,decs}=generateDecorationList(classDecorators,decoratorsThis,version);if(classDecorationsFlag=haveThis?1:0,classDecorations=decs,(usesFnContext||hasSideEffects&&willExtractSomeElemDecs||classDecsUsePrivateName)&&(classDecorationsId=memoiseExpression(_core.types.arrayExpression(classDecorations),"classDecs",classAssignments)),!hasElementDecorators)for(const element of path.get("body.body")){const{node}=element;if("computed"in node&&node.computed)if(element.isClassProperty({static:true})){if(!element.get("key").isConstantExpression()){const key=node.key,maybeAssignment=(0, _misc.memoiseComputedKey)(key,scopeParent,scopeParent.generateUid("computedKey"));null!=maybeAssignment&&(node.key=_core.types.cloneNode(maybeAssignment.left),computedKeyAssignments.push(maybeAssignment));}}else computedKeyAssignments.length>0&&(prependExpressionsToComputedKey(computedKeyAssignments,element),computedKeyAssignments=[]);}}else assignIdForAnonymousClass(path,className),classIdLocal=_core.types.cloneNode(path.node.id);let needsInstancePrivateBrandCheck=false,fieldInitializerExpressions=[],staticFieldInitializerExpressions=[];if(hasElementDecorators){if(protoInitLocal){const protoInitCall=_core.types.callExpression(_core.types.cloneNode(protoInitLocal),[_core.types.thisExpression()]);fieldInitializerExpressions.push(protoInitCall);}for(const element of body){if(!isClassDecoratableElementPath(element)){staticFieldInitializerExpressions.length>0&&element.isStaticBlock()&&(prependExpressionsToStaticBlock(staticFieldInitializerExpressions,element),staticFieldInitializerExpressions=[]);continue}const{node}=element,decorators=node.decorators,hasDecorators=!(null==decorators||!decorators.length),isComputed="computed"in node&&node.computed;let decoratorsArray,decoratorsHaveThis,name="computedKey";if("PrivateName"===node.key.type?name=node.key.id.name:isComputed||"Identifier"!==node.key.type||(name=node.key.name),hasDecorators){const{hasSideEffects,usesFnContext,decoratorsThis}=handleDecorators(decorators),{decs,haveThis}=generateDecorationList(decorators,decoratorsThis,version);decoratorsHaveThis=haveThis,decoratorsArray=1===decs.length?decs[0]:_core.types.arrayExpression(decs),(usesFnContext||hasSideEffects&&willExtractSomeElemDecs)&&(decoratorsArray=memoiseExpression(decoratorsArray,name+"Decs",computedKeyAssignments));}if(isComputed&&!element.get("key").isConstantExpression()){const key=node.key,maybeAssignment=(0, _misc.memoiseComputedKey)(hasDecorators?createToPropertyKeyCall(state,key):key,scopeParent,scopeParent.generateUid("computedKey"));null!=maybeAssignment&&(classDecorators&&element.isClassProperty({static:true})?(node.key=_core.types.cloneNode(maybeAssignment.left),computedKeyAssignments.push(maybeAssignment)):node.key=maybeAssignment);}const{key,static:isStatic}=node,isPrivate="PrivateName"===key.type,kind=getElementKind(element);let locals;if(isPrivate&&!isStatic&&(hasDecorators&&(needsInstancePrivateBrandCheck=true),!_core.types.isClassPrivateProperty(node)&&lastInstancePrivateName||(lastInstancePrivateName=key)),element.isClassMethod({kind:"constructor"})&&(constructorPath=element),hasDecorators){let privateMethods,nameExpr;if(nameExpr=isComputed?getComputedKeyMemoiser(element.get("key")):"PrivateName"===key.type?_core.types.stringLiteral(key.id.name):"Identifier"===key.type?_core.types.stringLiteral(key.name):_core.types.cloneNode(key),kind===ACCESSOR){const{value}=element.node,params="2023-11"===version&&isStatic?[]:[_core.types.thisExpression()];value&&params.push(_core.types.cloneNode(value));const newId=generateClassPrivateUid(),newFieldInitId=generateLetUidIdentifier(scopeParent,`init_${name}`),newField=generateClassProperty(newId,_core.types.callExpression(_core.types.cloneNode(newFieldInitId),params),isStatic),[newPath]=element.replaceWith(newField);if(isPrivate){privateMethods=extractProxyAccessorsFor(newId,version);const getId=generateLetUidIdentifier(scopeParent,`get_${name}`),setId=generateLetUidIdentifier(scopeParent,`set_${name}`);addCallAccessorsFor(version,newPath,key,getId,setId,isStatic),locals=[newFieldInitId,getId,setId];}else assignIdForAnonymousClass(path,className),addProxyAccessorsFor(path.node.id,newPath,_core.types.cloneNode(key),_core.types.isAssignmentExpression(key)?_core.types.cloneNode(key.left):_core.types.cloneNode(key),newId,isComputed,isStatic,version),locals=[newFieldInitId];}else if(kind===FIELD){const initId=generateLetUidIdentifier(scopeParent,`init_${name}`),valuePath=element.get("value"),args="2023-11"===version&&isStatic?[]:[_core.types.thisExpression()];valuePath.node&&args.push(valuePath.node),valuePath.replaceWith(_core.types.callExpression(_core.types.cloneNode(initId),args)),locals=[initId],isPrivate&&(privateMethods=extractProxyAccessorsFor(key,version));}else if(isPrivate){const callId=generateLetUidIdentifier(scopeParent,`call_${name}`);locals=[callId];if(new _helperReplaceSupers.default({constantSuper,methodPath:element,objectRef:classIdLocal,superRef:path.node.superClass,file:state.file,refToPreserve:classIdLocal}).replace(),privateMethods=[createFunctionExpressionFromPrivateMethod(element.node)],kind===GETTER||kind===SETTER)movePrivateAccessor(element,_core.types.cloneNode(key),_core.types.cloneNode(callId),isStatic);else {const node=element.node;path.node.body.body.unshift(_core.types.classPrivateProperty(key,_core.types.cloneNode(callId),[],node.static)),decoratedPrivateMethods.add(key.id.name),element.remove();}}elementDecoratorInfo.push({kind,decoratorsArray,decoratorsHaveThis,name:nameExpr,isStatic,privateMethods,locals}),element.node&&(element.node.decorators=null);}if(isComputed&&computedKeyAssignments.length>0&&(classDecorators&&element.isClassProperty({static:true})||(prependExpressionsToComputedKey(computedKeyAssignments,kind===ACCESSOR?element.getNextSibling():element),computedKeyAssignments=[])),fieldInitializerExpressions.length>0&&!isStatic&&(kind===FIELD||kind===ACCESSOR)&&(prependExpressionsToFieldInitializer(fieldInitializerExpressions,element),fieldInitializerExpressions=[]),staticFieldInitializerExpressions.length>0&&isStatic&&(kind===FIELD||kind===ACCESSOR)&&(prependExpressionsToFieldInitializer(staticFieldInitializerExpressions,element),staticFieldInitializerExpressions=[]),hasDecorators&&"2023-11"===version&&(kind===FIELD||kind===ACCESSOR)){const initExtraId=generateLetUidIdentifier(scopeParent,`init_extra_${name}`);locals.push(initExtraId);const initExtraCall=_core.types.callExpression(_core.types.cloneNode(initExtraId),isStatic?[]:[_core.types.thisExpression()]);isStatic?staticFieldInitializerExpressions.push(initExtraCall):fieldInitializerExpressions.push(initExtraCall);}}}if(computedKeyAssignments.length>0){const elements=path.get("body.body");let lastComputedElement;for(let i=elements.length-1;i>=0;i--){const path=elements[i],node=path.node;if(node.computed){if(classDecorators&&_core.types.isClassProperty(node,{static:true}))continue;lastComputedElement=path;break}}null!=lastComputedElement&&(!function(expressions,fieldPath){const key=fieldPath.get("key"),completion=getComputedKeyLastElement(key);if(completion.isConstantExpression())prependExpressionsToComputedKey(expressions,fieldPath);else {const scopeParent=key.scope.parent,maybeAssignment=(0, _misc.memoiseComputedKey)(completion.node,scopeParent,scopeParent.generateUid("computedKey"));if(maybeAssignment){const expressionSequence=[...expressions,_core.types.cloneNode(maybeAssignment.left)],completionParent=completion.parentPath;completionParent.isSequenceExpression()?completionParent.pushContainer("expressions",expressionSequence):completion.replaceWith(maybeSequenceExpression([_core.types.cloneNode(maybeAssignment),...expressionSequence]));}else prependExpressionsToComputedKey(expressions,fieldPath);}}(computedKeyAssignments,lastComputedElement),computedKeyAssignments=[]);}if(fieldInitializerExpressions.length>0){const isDerivedClass=!!path.node.superClass;constructorPath?isDerivedClass?function(expressions,constructorPath,protoInitLocal){constructorPath.traverse({CallExpression:{exit(path){if(!path.get("callee").isSuper())return;const newNodes=[path.node,...expressions.map((expr=>_core.types.cloneNode(expr)))];path.isCompletionRecord()&&newNodes.push(_core.types.thisExpression()),path.replaceWith(function(expressions,protoInitLocal){if(protoInitLocal){if(expressions.length>=2&&isProtoInitCallExpression(expressions[1],protoInitLocal)){const mergedSuperCall=_core.types.callExpression(_core.types.cloneNode(protoInitLocal),[expressions[0]]);expressions.splice(0,2,mergedSuperCall);}expressions.length>=2&&_core.types.isThisExpression(expressions[expressions.length-1])&&isProtoInitCallExpression(expressions[expressions.length-2],protoInitLocal)&&expressions.splice(expressions.length-1,1);}return maybeSequenceExpression(expressions)}(newNodes,protoInitLocal)),path.skip();}},ClassMethod(path){"constructor"===path.node.kind&&path.skip();}});}(fieldInitializerExpressions,constructorPath,protoInitLocal):function(expressions,constructorPath){constructorPath.node.body.body.unshift(_core.types.expressionStatement(maybeSequenceExpression(expressions)));}(fieldInitializerExpressions,constructorPath):path.node.body.body.unshift(createConstructorFromExpressions(fieldInitializerExpressions,isDerivedClass)),fieldInitializerExpressions=[];}staticFieldInitializerExpressions.length>0&&(path.node.body.body.push(createStaticBlockFromExpressions(staticFieldInitializerExpressions)),staticFieldInitializerExpressions=[]);const sortedElementDecoratorInfo=(info=elementDecoratorInfo,[...info.filter((el=>el.isStatic&&el.kind>=ACCESSOR&&el.kind<=SETTER)),...info.filter((el=>!el.isStatic&&el.kind>=ACCESSOR&&el.kind<=SETTER)),...info.filter((el=>el.isStatic&&el.kind===FIELD)),...info.filter((el=>!el.isStatic&&el.kind===FIELD))]),elementDecorations=function(decorationInfo,version){return _core.types.arrayExpression(decorationInfo.map((el=>{let flag=el.kind;return el.isStatic&&(flag+="2023-11"===version||"2023-05"===version?STATIC:STATIC_OLD_VERSION),el.decoratorsHaveThis&&(flag+=DECORATORS_HAVE_THIS),_core.types.arrayExpression([el.decoratorsArray,_core.types.numericLiteral(flag),el.name,...el.privateMethods||[]])})))}("2023-11"===version?elementDecoratorInfo:sortedElementDecoratorInfo,version),elementLocals=function(decorationInfo){const localIds=[];for(const el of decorationInfo){const{locals}=el;Array.isArray(locals)?localIds.push(...locals):void 0!==locals&&localIds.push(locals);}return localIds}(sortedElementDecoratorInfo);var info;protoInitLocal&&elementLocals.push(protoInitLocal);staticInitLocal&&elementLocals.push(staticInitLocal);const classLocals=[];let classInitInjected=false;const classInitCall=classInitLocal&&_core.types.callExpression(_core.types.cloneNode(classInitLocal),[]);let originalClassPath=path;const originalClass=path.node,staticClosures=[];if(classDecorators){classLocals.push(classIdLocal,classInitLocal);const statics=[];if(path.get("body.body").forEach((element=>{if(element.isStaticBlock()){if(hasInstancePrivateAccess(element,instancePrivateNames)){const staticBlockClosureId=memoiseExpression((block=element.node,_core.types.functionExpression(null,[],_core.types.blockStatement(block.body))),"staticBlock",staticClosures);staticFieldInitializerExpressions.push(_core.types.callExpression(_core.types.memberExpression(staticBlockClosureId,_core.types.identifier("call")),[_core.types.thisExpression()]));}else staticFieldInitializerExpressions.push(function(block){return _core.types.callExpression(_core.types.arrowFunctionExpression([],_core.types.blockStatement(block.body)),[])}(element.node));element.remove();}else {var block;if((element.isClassProperty()||element.isClassPrivateProperty())&&element.node.static){const valuePath=element.get("value");if(hasInstancePrivateAccess(valuePath,instancePrivateNames)){const fieldValueClosureId=memoiseExpression(function(value){return _core.types.functionExpression(null,[],_core.types.blockStatement([_core.types.returnStatement(value)]))}(valuePath.node),"fieldValue",staticClosures);valuePath.replaceWith(_core.types.callExpression(_core.types.memberExpression(fieldValueClosureId,_core.types.identifier("call")),[_core.types.thisExpression()]));}staticFieldInitializerExpressions.length>0&&(prependExpressionsToFieldInitializer(staticFieldInitializerExpressions,element),staticFieldInitializerExpressions=[]),element.node.static=false,statics.push(element.node),element.remove();}else if(element.isClassPrivateMethod({static:true})){if(hasInstancePrivateAccess(element,instancePrivateNames)){new _helperReplaceSupers.default({constantSuper,methodPath:element,objectRef:classIdLocal,superRef:path.node.superClass,file:state.file,refToPreserve:classIdLocal}).replace();const privateMethodDelegateId=memoiseExpression(createFunctionExpressionFromPrivateMethod(element.node),element.get("key.id").node.name,staticClosures);ignoreFunctionLength?(element.node.params=[_core.types.restElement(_core.types.identifier("arg"))],element.node.body=_core.types.blockStatement([_core.types.returnStatement(_core.types.callExpression(_core.types.memberExpression(privateMethodDelegateId,_core.types.identifier("apply")),[_core.types.thisExpression(),_core.types.identifier("arg")]))])):(element.node.params=element.node.params.map(((p,i)=>_core.types.isRestElement(p)?_core.types.restElement(_core.types.identifier("arg")):_core.types.identifier("_"+i))),element.node.body=_core.types.blockStatement([_core.types.returnStatement(_core.types.callExpression(_core.types.memberExpression(privateMethodDelegateId,_core.types.identifier("apply")),[_core.types.thisExpression(),_core.types.identifier("arguments")]))]));}element.node.static=false,statics.push(element.node),element.remove();}}})),statics.length>0||staticFieldInitializerExpressions.length>0){const staticsClass=_core.template.expression.ast`
        class extends ${state.addHelper("identity")} {}
      `;staticsClass.body.body=[_core.types.classProperty(_core.types.toExpression(originalClass),void 0,void 0,void 0,true,true),...statics];const constructorBody=[],newExpr=_core.types.newExpression(staticsClass,[]);staticFieldInitializerExpressions.length>0&&constructorBody.push(...staticFieldInitializerExpressions),classInitCall&&(classInitInjected=true,constructorBody.push(classInitCall)),constructorBody.length>0?(constructorBody.unshift(_core.types.callExpression(_core.types.super(),[_core.types.cloneNode(classIdLocal)])),staticsClass.body.body.push(createConstructorFromExpressions(constructorBody,false))):newExpr.arguments.push(_core.types.cloneNode(classIdLocal));const[newPath]=path.replaceWith(newExpr);originalClassPath=newPath.get("callee").get("body").get("body.0.key");}}!classInitInjected&&classInitCall&&path.node.body.body.push(_core.types.staticBlock([_core.types.expressionStatement(classInitCall)]));let{superClass}=originalClass;if(superClass&&("2023-11"===version||"2023-05"===version)){const id=path.scope.maybeGenerateMemoised(superClass);id&&(originalClass.superClass=_core.types.assignmentExpression("=",id,superClass),superClass=id);}const applyDecoratorWrapper=_core.types.staticBlock([]);originalClass.body.body.unshift(applyDecoratorWrapper);const applyDecsBody=applyDecoratorWrapper.body;if(computedKeyAssignments.length>0){const elements=originalClassPath.get("body.body");let firstPublicElement;for(const path of elements)if((path.isClassProperty()||path.isClassMethod())&&"constructor"!==path.node.kind){firstPublicElement=path;break}null!=firstPublicElement?(!function(path){const{node}=path;node.computed=true,_core.types.isIdentifier(node.key)&&(node.key=_core.types.stringLiteral(node.key.name));}(firstPublicElement),prependExpressionsToComputedKey(computedKeyAssignments,firstPublicElement)):(originalClass.body.body.unshift(_core.types.classProperty(_core.types.sequenceExpression([...computedKeyAssignments,_core.types.stringLiteral("_")]),void 0,void 0,void 0,true,true)),applyDecsBody.push(_core.types.expressionStatement(_core.types.unaryExpression("delete",_core.types.memberExpression(_core.types.thisExpression(),_core.types.identifier("_")))))),computedKeyAssignments=[];}applyDecsBody.push(_core.types.expressionStatement(function(elementLocals,classLocals,elementDecorations,classDecorations,classDecorationsFlag,maybePrivateBrandName,setClassName,superClass,state,version){let lhs,rhs;const args=[setClassName?createSetFunctionNameCall(state,setClassName):_core.types.thisExpression(),classDecorations,elementDecorations];"2023-11"!==version&&args.splice(1,2,elementDecorations,classDecorations);if("2021-12"===version||"2022-03"===version&&!state.availableHelper("applyDecs2203R"))return lhs=_core.types.arrayPattern([...elementLocals,...classLocals]),rhs=_core.types.callExpression(state.addHelper("2021-12"===version?"applyDecs":"applyDecs2203"),args),_core.types.assignmentExpression("=",lhs,rhs);"2022-03"===version?rhs=_core.types.callExpression(state.addHelper("applyDecs2203R"),args):"2023-01"===version?(maybePrivateBrandName&&args.push(createPrivateBrandCheckClosure(maybePrivateBrandName)),rhs=_core.types.callExpression(state.addHelper("applyDecs2301"),args)):"2023-05"===version&&((maybePrivateBrandName||superClass||0!==classDecorationsFlag.value)&&args.push(classDecorationsFlag),maybePrivateBrandName?args.push(createPrivateBrandCheckClosure(maybePrivateBrandName)):superClass&&args.push(_core.types.unaryExpression("void",_core.types.numericLiteral(0))),superClass&&args.push(superClass),rhs=_core.types.callExpression(state.addHelper("applyDecs2305"),args));"2023-11"===version&&((maybePrivateBrandName||superClass||0!==classDecorationsFlag.value)&&args.push(classDecorationsFlag),maybePrivateBrandName?args.push(createPrivateBrandCheckClosure(maybePrivateBrandName)):superClass&&args.push(_core.types.unaryExpression("void",_core.types.numericLiteral(0))),superClass&&args.push(superClass),rhs=_core.types.callExpression(state.addHelper("applyDecs2311"),args));elementLocals.length>0?classLocals.length>0?lhs=_core.types.objectPattern([_core.types.objectProperty(_core.types.identifier("e"),_core.types.arrayPattern(elementLocals)),_core.types.objectProperty(_core.types.identifier("c"),_core.types.arrayPattern(classLocals))]):(lhs=_core.types.arrayPattern(elementLocals),rhs=_core.types.memberExpression(rhs,_core.types.identifier("e"),false,false)):(lhs=_core.types.arrayPattern(classLocals),rhs=_core.types.memberExpression(rhs,_core.types.identifier("c"),false,false));return _core.types.assignmentExpression("=",lhs,rhs)}(elementLocals,classLocals,elementDecorations,null!=(_classDecorationsId=classDecorationsId)?_classDecorationsId:_core.types.arrayExpression(classDecorations),_core.types.numericLiteral(classDecorationsFlag),needsInstancePrivateBrandCheck?lastInstancePrivateName:null,setClassName,_core.types.cloneNode(superClass),state,version))),staticInitLocal&&applyDecsBody.push(_core.types.expressionStatement(_core.types.callExpression(_core.types.cloneNode(staticInitLocal),[_core.types.thisExpression()])));staticClosures.length>0&&applyDecsBody.push(...staticClosures.map((expr=>_core.types.expressionStatement(expr))));if(path.insertBefore(classAssignments.map((expr=>_core.types.expressionStatement(expr)))),needsDeclaraionForClassBinding){if(scopeParent.getBinding(classIdLocal.name).constantViolations.length){const classOuterBindingDelegateLocal=scopeParent.generateUidIdentifier("t"+classIdLocal.name),classOuterBindingLocal=classIdLocal;path.replaceWithMultiple([_core.types.variableDeclaration("let",[_core.types.variableDeclarator(_core.types.cloneNode(classOuterBindingLocal)),_core.types.variableDeclarator(classOuterBindingDelegateLocal)]),_core.types.blockStatement([_core.types.variableDeclaration("let",[_core.types.variableDeclarator(_core.types.cloneNode(classIdLocal))]),path.node,_core.types.expressionStatement(_core.types.assignmentExpression("=",_core.types.cloneNode(classOuterBindingDelegateLocal),_core.types.cloneNode(classIdLocal)))]),_core.types.expressionStatement(_core.types.assignmentExpression("=",_core.types.cloneNode(classOuterBindingLocal),_core.types.cloneNode(classOuterBindingDelegateLocal)))]);}else path.insertBefore(_core.types.variableDeclaration("let",[_core.types.variableDeclarator(_core.types.cloneNode(classIdLocal))]));}decoratedPrivateMethods.size>0&&function(path,decoratedPrivateMethods){const privateNameVisitor=(0, _fields.privateNameVisitorFactory)({PrivateName(path,state){if(!state.privateNamesMap.has(path.node.id.name))return;const parentPath=path.parentPath,parentParentPath=parentPath.parentPath;if("AssignmentExpression"===parentParentPath.node.type&&parentParentPath.node.left===parentPath.node||"UpdateExpression"===parentParentPath.node.type||"RestElement"===parentParentPath.node.type||"ArrayPattern"===parentParentPath.node.type||"ObjectProperty"===parentParentPath.node.type&&parentParentPath.node.value===parentPath.node&&"ObjectPattern"===parentParentPath.parentPath.type||"ForOfStatement"===parentParentPath.node.type&&parentParentPath.node.left===parentPath.node)throw path.buildCodeFrameError(`Decorated private methods are read-only, but "#${path.node.id.name}" is updated via this expression.`)}}),privateNamesMap=new Map;for(const name of decoratedPrivateMethods)privateNamesMap.set(name,null);path.traverse(privateNameVisitor,{privateNamesMap});}(path,decoratedPrivateMethods);return path.scope.crawl(),path}(path,state,constantSuper,ignoreFunctionLength,className,namedEvaluationVisitor,version);newPath?VISITED.add(newPath):VISITED.add(path);}return {name:"proposal-decorators",inherits,visitor:Object.assign({ExportDefaultDeclaration(path,state){const{declaration}=path.node;if("ClassDeclaration"===(null==declaration?void 0:declaration.type)&&isDecorated(declaration)){const isAnonymous=!declaration.id;null!=path.splitExportDeclaration||(path.splitExportDeclaration=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/index.js").NodePath.prototype.splitExportDeclaration);const updatedVarDeclarationPath=path.splitExportDeclaration();isAnonymous&&visitClass(updatedVarDeclarationPath,state,_core.types.stringLiteral("default"));}},ExportNamedDeclaration(path){const{declaration}=path.node;"ClassDeclaration"===(null==declaration?void 0:declaration.type)&&isDecorated(declaration)&&(null!=path.splitExportDeclaration||(path.splitExportDeclaration=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/index.js").NodePath.prototype.splitExportDeclaration),path.splitExportDeclaration());},Class(path,state){visitClass(path,state,void 0);}},namedEvaluationVisitor)}};var _core=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/index.js"),_helperReplaceSupers=__webpack_require__("./node_modules/.pnpm/@babel+helper-replace-supers@7.25.9_@babel+core@7.26.0/node_modules/@babel/helper-replace-supers/lib/index.js"),_helperSkipTransparentExpressionWrappers=__webpack_require__("./node_modules/.pnpm/@babel+helper-skip-transparent-expression-wrappers@7.25.9/node_modules/@babel/helper-skip-transparent-expression-wrappers/lib/index.js"),_fields=__webpack_require__("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.25.9_@babel+core@7.26.0/node_modules/@babel/helper-create-class-features-plugin/lib/fields.js"),_misc=__webpack_require__("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.25.9_@babel+core@7.26.0/node_modules/@babel/helper-create-class-features-plugin/lib/misc.js");function incrementId(id,idx=id.length-1){if(-1===idx)return void id.unshift(65);const current=id[idx];90===current?id[idx]=97:122===current?(id[idx]=65,incrementId(id,idx-1)):id[idx]=current+1;}function generateClassProperty(key,value,isStatic){return "PrivateName"===key.type?_core.types.classPrivateProperty(key,value,void 0,isStatic):_core.types.classProperty(key,value,void 0,void 0,isStatic)}function assignIdForAnonymousClass(path,className){path.node.id||(path.node.id="string"==typeof className?_core.types.identifier(className):path.scope.generateUidIdentifier("Class"));}function addProxyAccessorsFor(className,element,getterKey,setterKey,targetKey,isComputed,isStatic,version){const thisArg="2023-11"!==version&&"2023-05"!==version||!isStatic?_core.types.thisExpression():className,getterBody=_core.types.blockStatement([_core.types.returnStatement(_core.types.memberExpression(_core.types.cloneNode(thisArg),_core.types.cloneNode(targetKey)))]),setterBody=_core.types.blockStatement([_core.types.expressionStatement(_core.types.assignmentExpression("=",_core.types.memberExpression(_core.types.cloneNode(thisArg),_core.types.cloneNode(targetKey)),_core.types.identifier("v")))]);let getter,setter;"PrivateName"===getterKey.type?(getter=_core.types.classPrivateMethod("get",getterKey,[],getterBody,isStatic),setter=_core.types.classPrivateMethod("set",setterKey,[_core.types.identifier("v")],setterBody,isStatic)):(getter=_core.types.classMethod("get",getterKey,[],getterBody,isComputed,isStatic),setter=_core.types.classMethod("set",setterKey,[_core.types.identifier("v")],setterBody,isComputed,isStatic)),element.insertAfter(setter),element.insertAfter(getter);}function extractProxyAccessorsFor(targetKey,version){return "2023-11"!==version&&"2023-05"!==version&&"2023-01"!==version?[_core.template.expression.ast`
        function () {
          return this.${_core.types.cloneNode(targetKey)};
        }
      `,_core.template.expression.ast`
        function (value) {
          this.${_core.types.cloneNode(targetKey)} = value;
        }
      `]:[_core.template.expression.ast`
      o => o.${_core.types.cloneNode(targetKey)}
    `,_core.template.expression.ast`
      (o, v) => o.${_core.types.cloneNode(targetKey)} = v
    `]}function getComputedKeyLastElement(path){if((path=(0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers)(path)).isSequenceExpression()){const expressions=path.get("expressions");return getComputedKeyLastElement(expressions[expressions.length-1])}return path}function getComputedKeyMemoiser(path){const element=getComputedKeyLastElement(path);if(element.isConstantExpression())return _core.types.cloneNode(path.node);if(element.isIdentifier()&&path.scope.hasUid(element.node.name))return _core.types.cloneNode(path.node);if(element.isAssignmentExpression()&&element.get("left").isIdentifier())return _core.types.cloneNode(element.node.left);throw new Error(`Internal Error: the computed key ${path.toString()} has not yet been memoised.`)}function prependExpressionsToComputedKey(expressions,fieldPath){const key=fieldPath.get("key");key.isSequenceExpression()?expressions.push(...key.node.expressions):expressions.push(key.node),key.replaceWith(maybeSequenceExpression(expressions));}function prependExpressionsToFieldInitializer(expressions,fieldPath){const initializer=fieldPath.get("value");initializer.node?expressions.push(initializer.node):expressions.length>0&&(expressions[expressions.length-1]=_core.types.unaryExpression("void",expressions[expressions.length-1])),initializer.replaceWith(maybeSequenceExpression(expressions));}function prependExpressionsToStaticBlock(expressions,blockPath){blockPath.unshiftContainer("body",_core.types.expressionStatement(maybeSequenceExpression(expressions)));}function isProtoInitCallExpression(expression,protoInitCall){return _core.types.isCallExpression(expression)&&_core.types.isIdentifier(expression.callee,{name:protoInitCall.name})}function createConstructorFromExpressions(expressions,isDerivedClass){const body=[_core.types.expressionStatement(maybeSequenceExpression(expressions))];return isDerivedClass&&body.unshift(_core.types.expressionStatement(_core.types.callExpression(_core.types.super(),[_core.types.spreadElement(_core.types.identifier("args"))]))),_core.types.classMethod("constructor",_core.types.identifier("constructor"),isDerivedClass?[_core.types.restElement(_core.types.identifier("args"))]:[],_core.types.blockStatement(body))}function createStaticBlockFromExpressions(expressions){return _core.types.staticBlock([_core.types.expressionStatement(maybeSequenceExpression(expressions))])}const FIELD=0,ACCESSOR=1,METHOD=2,GETTER=3,SETTER=4,STATIC_OLD_VERSION=5,STATIC=8,DECORATORS_HAVE_THIS=16;function getElementKind(element){switch(element.node.type){case "ClassProperty":case "ClassPrivateProperty":return FIELD;case "ClassAccessorProperty":return ACCESSOR;case "ClassMethod":case "ClassPrivateMethod":return "get"===element.node.kind?GETTER:"set"===element.node.kind?SETTER:METHOD}}function generateDecorationList(decorators,decoratorsThis,version){const decsCount=decorators.length,haveOneThis=decoratorsThis.some(Boolean),decs=[];for(let i=0;i<decsCount;i++)"2023-11"!==version&&"2023-05"!==version||!haveOneThis||decs.push(decoratorsThis[i]||_core.types.unaryExpression("void",_core.types.numericLiteral(0))),decs.push(decorators[i].expression);return {haveThis:haveOneThis,decs}}function addCallAccessorsFor(version,element,key,getId,setId,isStatic){element.insertAfter(_core.types.classPrivateMethod("get",_core.types.cloneNode(key),[],_core.types.blockStatement([_core.types.returnStatement(_core.types.callExpression(_core.types.cloneNode(getId),"2023-11"===version&&isStatic?[]:[_core.types.thisExpression()]))]),isStatic)),element.insertAfter(_core.types.classPrivateMethod("set",_core.types.cloneNode(key),[_core.types.identifier("v")],_core.types.blockStatement([_core.types.expressionStatement(_core.types.callExpression(_core.types.cloneNode(setId),"2023-11"===version&&isStatic?[_core.types.identifier("v")]:[_core.types.thisExpression(),_core.types.identifier("v")]))]),isStatic));}function movePrivateAccessor(element,key,methodLocalVar,isStatic){let params,block;"set"===element.node.kind?(params=[_core.types.identifier("v")],block=[_core.types.expressionStatement(_core.types.callExpression(methodLocalVar,[_core.types.thisExpression(),_core.types.identifier("v")]))]):(params=[],block=[_core.types.returnStatement(_core.types.callExpression(methodLocalVar,[_core.types.thisExpression()]))]),element.replaceWith(_core.types.classPrivateMethod(element.node.kind,_core.types.cloneNode(key),params,_core.types.blockStatement(block),isStatic));}function isClassDecoratableElementPath(path){const{type}=path;return "TSDeclareMethod"!==type&&"TSIndexSignature"!==type&&"StaticBlock"!==type}function maybeSequenceExpression(exprs){return 0===exprs.length?_core.types.unaryExpression("void",_core.types.numericLiteral(0)):1===exprs.length?exprs[0]:_core.types.sequenceExpression(exprs)}function createFunctionExpressionFromPrivateMethod(node){const{params,body,generator:isGenerator,async:isAsync}=node;return _core.types.functionExpression(void 0,params,body,isGenerator,isAsync)}function createSetFunctionNameCall(state,className){return _core.types.callExpression(state.addHelper("setFunctionName"),[_core.types.thisExpression(),className])}function createToPropertyKeyCall(state,propertyKey){return _core.types.callExpression(state.addHelper("toPropertyKey"),[propertyKey])}function createPrivateBrandCheckClosure(brandName){return _core.types.arrowFunctionExpression([_core.types.identifier("_")],_core.types.binaryExpression("in",_core.types.cloneNode(brandName),_core.types.identifier("_")))}function usesPrivateField(expression){try{return _core.types.traverseFast(expression,(node=>{if(_core.types.isPrivateName(node))throw null})),!1}catch(_unused){return  true}}function hasInstancePrivateAccess(path,privateNames){let containsInstancePrivateAccess=false;if(privateNames.length>0){const privateNameVisitor=(0, _fields.privateNameVisitorFactory)({PrivateName(path,state){state.privateNamesMap.has(path.node.id.name)&&(containsInstancePrivateAccess=true,path.stop());}}),privateNamesMap=new Map;for(const name of privateNames)privateNamesMap.set(name,null);path.traverse(privateNameVisitor,{privateNamesMap});}return containsInstancePrivateAccess}function isProtoKey(node){return "Identifier"===node.type?"__proto__"===node.name:"__proto__"===node.value}function isDecorated(node){return node.decorators&&node.decorators.length>0}function shouldTransformElement(node){switch(node.type){case "ClassAccessorProperty":return  true;case "ClassMethod":case "ClassProperty":case "ClassPrivateMethod":case "ClassPrivateProperty":return isDecorated(node);default:return  false}}function isDecoratedAnonymousClassExpression(path){return path.isClassExpression({id:null})&&(isDecorated(node=path.node)||node.body.body.some(shouldTransformElement));var node;}function generateLetUidIdentifier(scope,name){const id=scope.generateUidIdentifier(name);return scope.push({id,kind:"let"}),_core.types.cloneNode(id)}},"./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.25.9_@babel+core@7.26.0/node_modules/@babel/helper-create-class-features-plugin/lib/features.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.FEATURES=void 0,exports.enableFeature=function(file,feature,loose){hasFeature(file,feature)&&!canIgnoreLoose(file,feature)||(file.set(featuresKey,file.get(featuresKey)|feature),"#__internal__@babel/preset-env__prefer-true-but-false-is-ok-if-it-prevents-an-error"===loose?(setLoose(file,feature,true),file.set(looseLowPriorityKey,file.get(looseLowPriorityKey)|feature)):"#__internal__@babel/preset-env__prefer-false-but-true-is-ok-if-it-prevents-an-error"===loose?(setLoose(file,feature,false),file.set(looseLowPriorityKey,file.get(looseLowPriorityKey)|feature)):setLoose(file,feature,loose));let resolvedLoose;for(const[mask,name]of featuresSameLoose){if(!hasFeature(file,mask))continue;if(canIgnoreLoose(file,mask))continue;const loose=isLoose(file,mask);if(resolvedLoose===!loose)throw new Error("'loose' mode configuration must be the same for @babel/plugin-transform-class-properties, @babel/plugin-transform-private-methods and @babel/plugin-transform-private-property-in-object (when they are enabled).\n\n"+getBabelShowConfigForHint(file));resolvedLoose=loose;var higherPriorityPluginName=name;}if(void 0!==resolvedLoose)for(const[mask,name]of featuresSameLoose)hasFeature(file,mask)&&isLoose(file,mask)!==resolvedLoose&&(setLoose(file,mask,resolvedLoose),console.warn(`Though the "loose" option was set to "${!resolvedLoose}" in your @babel/preset-env config, it will not be used for ${name} since the "loose" mode option was set to "${resolvedLoose}" for ${higherPriorityPluginName}.\nThe "loose" option must be the same for @babel/plugin-transform-class-properties, @babel/plugin-transform-private-methods and @babel/plugin-transform-private-property-in-object (when they are enabled): you can silence this warning by explicitly adding\n\t["${name}", { "loose": ${resolvedLoose} }]\nto the "plugins" section of your Babel config.\n\n`+getBabelShowConfigForHint(file)));},exports.isLoose=isLoose,exports.shouldTransform=function(path,file){let decoratorPath=null,publicFieldPath=null,privateFieldPath=null,privateMethodPath=null,staticBlockPath=null;(0, _decorators.hasOwnDecorators)(path.node)&&(decoratorPath=path.get("decorators.0"));for(const el of path.get("body.body"))!decoratorPath&&(0, _decorators.hasOwnDecorators)(el.node)&&(decoratorPath=el.get("decorators.0")),!publicFieldPath&&el.isClassProperty()&&(publicFieldPath=el),!privateFieldPath&&el.isClassPrivateProperty()&&(privateFieldPath=el),!privateMethodPath&&null!=el.isClassPrivateMethod&&el.isClassPrivateMethod()&&(privateMethodPath=el),!staticBlockPath&&null!=el.isStaticBlock&&el.isStaticBlock()&&(staticBlockPath=el);if(decoratorPath&&privateFieldPath)throw privateFieldPath.buildCodeFrameError("Private fields in decorated classes are not supported yet.");if(decoratorPath&&privateMethodPath)throw privateMethodPath.buildCodeFrameError("Private methods in decorated classes are not supported yet.");if(decoratorPath&&!hasFeature(file,FEATURES.decorators))throw path.buildCodeFrameError('Decorators are not enabled.\nIf you are using ["@babel/plugin-proposal-decorators", { "version": "legacy" }], make sure it comes *before* "@babel/plugin-transform-class-properties" and enable loose mode, like so:\n\t["@babel/plugin-proposal-decorators", { "version": "legacy" }]\n\t["@babel/plugin-transform-class-properties", { "loose": true }]');if(privateMethodPath&&!hasFeature(file,FEATURES.privateMethods))throw privateMethodPath.buildCodeFrameError("Class private methods are not enabled. Please add `@babel/plugin-transform-private-methods` to your configuration.");if((publicFieldPath||privateFieldPath)&&!hasFeature(file,FEATURES.fields)&&!hasFeature(file,FEATURES.privateMethods))throw path.buildCodeFrameError("Class fields are not enabled. Please add `@babel/plugin-transform-class-properties` to your configuration.");if(staticBlockPath&&!hasFeature(file,FEATURES.staticBlocks))throw path.buildCodeFrameError("Static class blocks are not enabled. Please add `@babel/plugin-transform-class-static-block` to your configuration.");if(decoratorPath||privateMethodPath||staticBlockPath)return  true;if((publicFieldPath||privateFieldPath)&&hasFeature(file,FEATURES.fields))return  true;return  false};var _decorators=__webpack_require__("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.25.9_@babel+core@7.26.0/node_modules/@babel/helper-create-class-features-plugin/lib/decorators-2018-09.js");const FEATURES=exports.FEATURES=Object.freeze({fields:2,privateMethods:4,decorators:8,privateIn:16,staticBlocks:32}),featuresSameLoose=new Map([[FEATURES.fields,"@babel/plugin-transform-class-properties"],[FEATURES.privateMethods,"@babel/plugin-transform-private-methods"],[FEATURES.privateIn,"@babel/plugin-transform-private-property-in-object"]]),featuresKey="@babel/plugin-class-features/featuresKey",looseKey="@babel/plugin-class-features/looseKey";var looseLowPriorityKey="@babel/plugin-class-features/looseLowPriorityKey/#__internal__@babel/preset-env__please-overwrite-loose-instead-of-throwing",canIgnoreLoose=function(file,feature){return !!(file.get(looseLowPriorityKey)&feature)};function getBabelShowConfigForHint(file){let{filename}=file.opts;return filename&&"unknown"!==filename||(filename="[name of the input file]"),`If you already set the same 'loose' mode for these plugins in your config, it's possible that they are enabled multiple times with different options.\nYou can re-run Babel with the BABEL_SHOW_CONFIG_FOR environment variable to show the loaded configuration:\n\tnpx cross-env BABEL_SHOW_CONFIG_FOR=${filename} <your build command>\nSee https://babeljs.io/docs/configuration#print-effective-configs for more info.`}function hasFeature(file,feature){return !!(file.get(featuresKey)&feature)}function isLoose(file,feature){return !!(file.get(looseKey)&feature)}function setLoose(file,feature,loose){loose?file.set(looseKey,file.get(looseKey)|feature):file.set(looseKey,file.get(looseKey)&~feature),file.set(looseLowPriorityKey,file.get(looseLowPriorityKey)&~feature);}},"./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.25.9_@babel+core@7.26.0/node_modules/@babel/helper-create-class-features-plugin/lib/fields.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.buildCheckInRHS=buildCheckInRHS,exports.buildFieldsInitNodes=function(ref,superRef,props,privateNamesMap,file,setPublicClassFields,privateFieldsAsSymbolsOrProperties,noUninitializedPrivateFieldAccess,constantSuper,innerBindingRef){var _ref;let injectSuperRef,classRefFlags=0;const staticNodes=[],instanceNodes=[];let lastInstanceNodeReturnsThis=false;const pureStaticNodes=[];let classBindingNode=null;const getSuperRef=_core.types.isIdentifier(superRef)?()=>superRef:()=>(null!=injectSuperRef||(injectSuperRef=props[0].scope.generateUidIdentifierBasedOnNode(superRef)),injectSuperRef),classRefForInnerBinding=null!=(_ref=ref)?_ref:props[0].scope.generateUidIdentifier((null==innerBindingRef?void 0:innerBindingRef.name)||"Class");null!=ref||(ref=_core.types.cloneNode(innerBindingRef));for(const prop of props){prop.isClassProperty()&&ts.assertFieldTransformed(prop);const isStatic=!(null!=_core.types.isStaticBlock&&_core.types.isStaticBlock(prop.node))&&prop.node.static,isInstance=!isStatic,isPrivate=prop.isPrivate(),isPublic=!isPrivate,isField=prop.isProperty(),isMethod=!isField,isStaticBlock=null==prop.isStaticBlock?void 0:prop.isStaticBlock();if(isStatic&&(classRefFlags|=1),isStatic||isMethod&&isPrivate||isStaticBlock){new _helperReplaceSupers.default({methodPath:prop,constantSuper,file,refToPreserve:innerBindingRef,getSuperRef,getObjectRef:()=>(classRefFlags|=2,isStatic||isStaticBlock?classRefForInnerBinding:_core.types.memberExpression(classRefForInnerBinding,_core.types.identifier("prototype")))}).replace();replaceThisContext(prop,classRefForInnerBinding,innerBindingRef)&&(classRefFlags|=2);}switch(lastInstanceNodeReturnsThis=false,true){case isStaticBlock:{const blockBody=prop.node.body;1===blockBody.length&&_core.types.isExpressionStatement(blockBody[0])?staticNodes.push(inheritPropComments(blockBody[0],prop)):staticNodes.push(_core.types.inheritsComments(_core.template.statement.ast`(() => { ${blockBody} })()`,prop.node));break}case isStatic&&isPrivate&&isField&&privateFieldsAsSymbolsOrProperties:staticNodes.push(buildPrivateFieldInitLoose(_core.types.cloneNode(ref),prop,privateNamesMap));break;case isStatic&&isPrivate&&isField&&!privateFieldsAsSymbolsOrProperties:newHelpers(file)?staticNodes.push(buildPrivateStaticFieldInitSpec(prop,privateNamesMap,noUninitializedPrivateFieldAccess)):staticNodes.push(buildPrivateStaticFieldInitSpecOld(prop,privateNamesMap));break;case isStatic&&isPublic&&isField&&setPublicClassFields:if(!isNameOrLength(prop.node)){staticNodes.push(buildPublicFieldInitLoose(_core.types.cloneNode(ref),prop));break}case isStatic&&isPublic&&isField&&!setPublicClassFields:staticNodes.push(buildPublicFieldInitSpec(_core.types.cloneNode(ref),prop,file));break;case isInstance&&isPrivate&&isField&&privateFieldsAsSymbolsOrProperties:instanceNodes.push(buildPrivateFieldInitLoose(_core.types.thisExpression(),prop,privateNamesMap));break;case isInstance&&isPrivate&&isField&&!privateFieldsAsSymbolsOrProperties:instanceNodes.push(buildPrivateInstanceFieldInitSpec(_core.types.thisExpression(),prop,privateNamesMap,file));break;case isInstance&&isPrivate&&isMethod&&privateFieldsAsSymbolsOrProperties:instanceNodes.unshift(buildPrivateMethodInitLoose(_core.types.thisExpression(),prop,privateNamesMap)),pureStaticNodes.push(buildPrivateMethodDeclaration(file,prop,privateNamesMap,privateFieldsAsSymbolsOrProperties));break;case isInstance&&isPrivate&&isMethod&&!privateFieldsAsSymbolsOrProperties:instanceNodes.unshift(buildPrivateInstanceMethodInitSpec(_core.types.thisExpression(),prop,privateNamesMap,file)),pureStaticNodes.push(buildPrivateMethodDeclaration(file,prop,privateNamesMap,privateFieldsAsSymbolsOrProperties));break;case isStatic&&isPrivate&&isMethod&&!privateFieldsAsSymbolsOrProperties:newHelpers(file)||staticNodes.unshift(buildPrivateStaticFieldInitSpecOld(prop,privateNamesMap)),pureStaticNodes.push(buildPrivateMethodDeclaration(file,prop,privateNamesMap,privateFieldsAsSymbolsOrProperties));break;case isStatic&&isPrivate&&isMethod&&privateFieldsAsSymbolsOrProperties:staticNodes.unshift(buildPrivateStaticMethodInitLoose(_core.types.cloneNode(ref),prop,file,privateNamesMap)),pureStaticNodes.push(buildPrivateMethodDeclaration(file,prop,privateNamesMap,privateFieldsAsSymbolsOrProperties));break;case isInstance&&isPublic&&isField&&setPublicClassFields:instanceNodes.push(buildPublicFieldInitLoose(_core.types.thisExpression(),prop));break;case isInstance&&isPublic&&isField&&!setPublicClassFields:lastInstanceNodeReturnsThis=true,instanceNodes.push(buildPublicFieldInitSpec(_core.types.thisExpression(),prop,file));break;default:throw new Error("Unreachable.")}}2&classRefFlags&&null!=innerBindingRef&&(classBindingNode=_core.types.expressionStatement(_core.types.assignmentExpression("=",_core.types.cloneNode(classRefForInnerBinding),_core.types.cloneNode(innerBindingRef))));return {staticNodes:staticNodes.filter(Boolean),instanceNodes:instanceNodes.filter(Boolean),lastInstanceNodeReturnsThis,pureStaticNodes:pureStaticNodes.filter(Boolean),classBindingNode,wrapClass(path){for(const prop of props)prop.node.leadingComments=null,prop.remove();return injectSuperRef&&(path.scope.push({id:_core.types.cloneNode(injectSuperRef)}),path.set("superClass",_core.types.assignmentExpression("=",injectSuperRef,path.node.superClass))),0!==classRefFlags&&(path.isClassExpression()?(path.scope.push({id:ref}),path.replaceWith(_core.types.assignmentExpression("=",_core.types.cloneNode(ref),path.node))):(null==innerBindingRef&&(path.node.id=ref),null!=classBindingNode&&path.scope.push({id:classRefForInnerBinding}))),path}}},exports.buildPrivateNamesMap=function(className,privateFieldsAsSymbolsOrProperties,props,file){const privateNamesMap=new Map;let classBrandId;for(const prop of props)if(prop.isPrivate()){const{name}=prop.node.key.id;let update=privateNamesMap.get(name);if(!update){const isMethod=!prop.isProperty(),isStatic=prop.node.static;let id,initAdded=false;if(!privateFieldsAsSymbolsOrProperties&&newHelpers(file)&&isMethod&&!isStatic)initAdded=!!classBrandId,null!=classBrandId||(classBrandId=prop.scope.generateUidIdentifier(`${className}_brand`)),id=classBrandId;else id=prop.scope.generateUidIdentifier(name);update={id,static:isStatic,method:isMethod,initAdded},privateNamesMap.set(name,update);}if(prop.isClassPrivateMethod())if("get"===prop.node.kind){const{body}=prop.node.body;let $;1===body.length&&_core.types.isReturnStatement($=body[0])&&_core.types.isCallExpression($=$.argument)&&1===$.arguments.length&&_core.types.isThisExpression($.arguments[0])&&_core.types.isIdentifier($=$.callee)?(update.getId=_core.types.cloneNode($),update.getterDeclared=true):update.getId=prop.scope.generateUidIdentifier(`get_${name}`);}else if("set"===prop.node.kind){const{params}=prop.node,{body}=prop.node.body;let $;1===body.length&&_core.types.isExpressionStatement($=body[0])&&_core.types.isCallExpression($=$.expression)&&2===$.arguments.length&&_core.types.isThisExpression($.arguments[0])&&_core.types.isIdentifier($.arguments[1],{name:params[0].name})&&_core.types.isIdentifier($=$.callee)?(update.setId=_core.types.cloneNode($),update.setterDeclared=true):update.setId=prop.scope.generateUidIdentifier(`set_${name}`);}else "method"===prop.node.kind&&(update.methodId=prop.scope.generateUidIdentifier(name));privateNamesMap.set(name,update);}return privateNamesMap},exports.buildPrivateNamesNodes=function(privateNamesMap,privateFieldsAsProperties,privateFieldsAsSymbols,state){const initNodes=[],injectedIds=new Set;for(const[name,value]of privateNamesMap){const{static:isStatic,method:isMethod,getId,setId}=value,isGetterOrSetter=getId||setId,id=_core.types.cloneNode(value.id);let init;if(privateFieldsAsProperties)init=_core.types.callExpression(state.addHelper("classPrivateFieldLooseKey"),[_core.types.stringLiteral(name)]);else if(privateFieldsAsSymbols)init=_core.types.callExpression(_core.types.identifier("Symbol"),[_core.types.stringLiteral(name)]);else if(!isStatic){if(injectedIds.has(id.name))continue;injectedIds.add(id.name),init=_core.types.newExpression(_core.types.identifier(!isMethod||isGetterOrSetter&&!newHelpers(state)?"WeakMap":"WeakSet"),[]);}init&&(privateFieldsAsSymbols||(0, _helperAnnotateAsPure.default)(init),initNodes.push(_core.template.statement.ast`var ${id} = ${init}`));}return initNodes},exports.privateNameVisitorFactory=privateNameVisitorFactory,exports.transformPrivateNamesUsage=function(ref,path,privateNamesMap,{privateFieldsAsProperties,noUninitializedPrivateFieldAccess,noDocumentAll,innerBinding},state){if(!privateNamesMap.size)return;const body=path.get("body"),handler=privateFieldsAsProperties?privateNameHandlerLoose:privateNameHandlerSpec;(0, _helperMemberExpressionToFunctions.default)(body,privateNameVisitor,Object.assign({privateNamesMap,classRef:ref,file:state},handler,{noDocumentAll,noUninitializedPrivateFieldAccess,innerBinding})),body.traverse(privateInVisitor,{privateNamesMap,classRef:ref,file:state,privateFieldsAsProperties,innerBinding});};var _core=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/index.js"),_traverse=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/index.js"),_helperReplaceSupers=__webpack_require__("./node_modules/.pnpm/@babel+helper-replace-supers@7.25.9_@babel+core@7.26.0/node_modules/@babel/helper-replace-supers/lib/index.js"),_helperMemberExpressionToFunctions=__webpack_require__("./node_modules/.pnpm/@babel+helper-member-expression-to-functions@7.25.9/node_modules/@babel/helper-member-expression-to-functions/lib/index.js"),_helperOptimiseCallExpression=__webpack_require__("./node_modules/.pnpm/@babel+helper-optimise-call-expression@7.25.9/node_modules/@babel/helper-optimise-call-expression/lib/index.js"),_helperAnnotateAsPure=__webpack_require__("./node_modules/.pnpm/@babel+helper-annotate-as-pure@7.25.9/node_modules/@babel/helper-annotate-as-pure/lib/index.js"),_helperSkipTransparentExpressionWrappers=__webpack_require__("./node_modules/.pnpm/@babel+helper-skip-transparent-expression-wrappers@7.25.9/node_modules/@babel/helper-skip-transparent-expression-wrappers/lib/index.js"),ts=__webpack_require__("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.25.9_@babel+core@7.26.0/node_modules/@babel/helper-create-class-features-plugin/lib/typescript.js"),newHelpers=file=>file.availableHelper("classPrivateFieldGet2");function privateNameVisitorFactory(visitor){const nestedVisitor=_traverse.visitors.environmentVisitor(Object.assign({},visitor)),privateNameVisitor=Object.assign({},visitor,{Class(path){const{privateNamesMap}=this,body=path.get("body.body"),visiblePrivateNames=new Map(privateNamesMap),redeclared=[];for(const prop of body){if(!prop.isPrivate())continue;const{name}=prop.node.key.id;visiblePrivateNames.delete(name),redeclared.push(name);}redeclared.length&&(path.get("body").traverse(nestedVisitor,Object.assign({},this,{redeclared})),path.traverse(privateNameVisitor,Object.assign({},this,{privateNamesMap:visiblePrivateNames})),path.skipKey("body"));}});return privateNameVisitor}const privateNameVisitor=privateNameVisitorFactory({PrivateName(path,{noDocumentAll}){const{privateNamesMap,redeclared}=this,{node,parentPath}=path;if(!parentPath.isMemberExpression({property:node})&&!parentPath.isOptionalMemberExpression({property:node}))return;const{name}=node.id;privateNamesMap.has(name)&&(null!=redeclared&&redeclared.includes(name)||this.handle(parentPath,noDocumentAll));}});function unshadow(name,scope,innerBinding){for(;null!=(_scope=scope)&&_scope.hasBinding(name)&&!scope.bindingIdentifierEquals(name,innerBinding);){var _scope;scope.rename(name),scope=scope.parent;}}function buildCheckInRHS(rhs,file,inRHSIsObject){return inRHSIsObject||null==file.availableHelper||!file.availableHelper("checkInRHS")?rhs:_core.types.callExpression(file.addHelper("checkInRHS"),[rhs])}const privateInVisitor=privateNameVisitorFactory({BinaryExpression(path,{file}){const{operator,left,right}=path.node;if("in"!==operator)return;if(!_core.types.isPrivateName(left))return;const{privateFieldsAsProperties,privateNamesMap,redeclared}=this,{name}=left.id;if(!privateNamesMap.has(name))return;if(null!=redeclared&&redeclared.includes(name))return;if(unshadow(this.classRef.name,path.scope,this.innerBinding),privateFieldsAsProperties){const{id}=privateNamesMap.get(name);return void path.replaceWith(_core.template.expression.ast`
        Object.prototype.hasOwnProperty.call(${buildCheckInRHS(right,file)}, ${_core.types.cloneNode(id)})
      `)}const{id,static:isStatic}=privateNamesMap.get(name);isStatic?path.replaceWith(_core.template.expression.ast`${buildCheckInRHS(right,file)} === ${_core.types.cloneNode(this.classRef)}`):path.replaceWith(_core.template.expression.ast`${_core.types.cloneNode(id)}.has(${buildCheckInRHS(right,file)})`);}});function readOnlyError(file,name){return _core.types.callExpression(file.addHelper("readOnlyError"),[_core.types.stringLiteral(`#${name}`)])}function writeOnlyError(file,name){return file.availableHelper("writeOnlyError")?_core.types.callExpression(file.addHelper("writeOnlyError"),[_core.types.stringLiteral(`#${name}`)]):(console.warn("@babel/helpers is outdated, update it to silence this warning."),_core.types.buildUndefinedNode())}function buildStaticPrivateFieldAccess(expr,noUninitializedPrivateFieldAccess){return noUninitializedPrivateFieldAccess?expr:_core.types.memberExpression(expr,_core.types.identifier("_"))}function autoInherits(fn){return function(member){return _core.types.inherits(fn.apply(this,arguments),member.node)}}const privateNameHandlerSpec={memoise(member,count){const{scope}=member,{object}=member.node,memo=scope.maybeGenerateMemoised(object);memo&&this.memoiser.set(object,memo,count);},receiver(member){const{object}=member.node;return this.memoiser.has(object)?_core.types.cloneNode(this.memoiser.get(object)):_core.types.cloneNode(object)},get:autoInherits((function(member){const{classRef,privateNamesMap,file,innerBinding,noUninitializedPrivateFieldAccess}=this,privateName=member.node.property,{name}=privateName.id,{id,static:isStatic,method:isMethod,methodId,getId,setId}=privateNamesMap.get(name),isGetterOrSetter=getId||setId,cloneId=id=>_core.types.inherits(_core.types.cloneNode(id),privateName);if(isStatic){if(unshadow(classRef.name,member.scope,innerBinding),!newHelpers(file)){const helperName=isMethod&&!isGetterOrSetter?"classStaticPrivateMethodGet":"classStaticPrivateFieldSpecGet";return _core.types.callExpression(file.addHelper(helperName),[this.receiver(member),_core.types.cloneNode(classRef),cloneId(id)])}const receiver=this.receiver(member),skipCheck=_core.types.isIdentifier(receiver)&&receiver.name===classRef.name;if(!isMethod)return buildStaticPrivateFieldAccess(skipCheck?cloneId(id):_core.types.callExpression(file.addHelper("assertClassBrand"),[_core.types.cloneNode(classRef),receiver,cloneId(id)]),noUninitializedPrivateFieldAccess);if(getId)return skipCheck?_core.types.callExpression(cloneId(getId),[receiver]):_core.types.callExpression(file.addHelper("classPrivateGetter"),[_core.types.cloneNode(classRef),receiver,cloneId(getId)]);if(setId){const err=_core.types.buildUndefinedNode();return skipCheck?err:_core.types.sequenceExpression([_core.types.callExpression(file.addHelper("assertClassBrand"),[_core.types.cloneNode(classRef),receiver]),err])}return skipCheck?cloneId(id):_core.types.callExpression(file.addHelper("assertClassBrand"),[_core.types.cloneNode(classRef),receiver,cloneId(id)])}return isMethod?isGetterOrSetter?getId?newHelpers(file)?_core.types.callExpression(file.addHelper("classPrivateGetter"),[_core.types.cloneNode(id),this.receiver(member),cloneId(getId)]):_core.types.callExpression(file.addHelper("classPrivateFieldGet"),[this.receiver(member),cloneId(id)]):_core.types.sequenceExpression([this.receiver(member),writeOnlyError(file,name)]):newHelpers(file)?_core.types.callExpression(file.addHelper("assertClassBrand"),[_core.types.cloneNode(id),this.receiver(member),cloneId(methodId)]):_core.types.callExpression(file.addHelper("classPrivateMethodGet"),[this.receiver(member),_core.types.cloneNode(id),cloneId(methodId)]):newHelpers(file)?_core.types.callExpression(file.addHelper("classPrivateFieldGet2"),[cloneId(id),this.receiver(member)]):_core.types.callExpression(file.addHelper("classPrivateFieldGet"),[this.receiver(member),cloneId(id)])})),boundGet(member){return this.memoise(member,1),_core.types.callExpression(_core.types.memberExpression(this.get(member),_core.types.identifier("bind")),[this.receiver(member)])},set:autoInherits((function(member,value){const{classRef,privateNamesMap,file,noUninitializedPrivateFieldAccess}=this,privateName=member.node.property,{name}=privateName.id,{id,static:isStatic,method:isMethod,setId,getId}=privateNamesMap.get(name),isGetterOrSetter=getId||setId,cloneId=id=>_core.types.inherits(_core.types.cloneNode(id),privateName);if(isStatic){if(!newHelpers(file)){const helperName=isMethod&&!isGetterOrSetter?"classStaticPrivateMethodSet":"classStaticPrivateFieldSpecSet";return _core.types.callExpression(file.addHelper(helperName),[this.receiver(member),_core.types.cloneNode(classRef),cloneId(id),value])}const receiver=this.receiver(member),skipCheck=_core.types.isIdentifier(receiver)&&receiver.name===classRef.name;if(isMethod&&!setId){const err=readOnlyError(file,name);return skipCheck?_core.types.sequenceExpression([value,err]):_core.types.sequenceExpression([value,_core.types.callExpression(file.addHelper("assertClassBrand"),[_core.types.cloneNode(classRef),receiver]),readOnlyError(file,name)])}return setId?skipCheck?_core.types.callExpression(_core.types.cloneNode(setId),[receiver,value]):_core.types.callExpression(file.addHelper("classPrivateSetter"),[_core.types.cloneNode(classRef),cloneId(setId),receiver,value]):_core.types.assignmentExpression("=",buildStaticPrivateFieldAccess(cloneId(id),noUninitializedPrivateFieldAccess),skipCheck?value:_core.types.callExpression(file.addHelper("assertClassBrand"),[_core.types.cloneNode(classRef),receiver,value]))}return isMethod?setId?newHelpers(file)?_core.types.callExpression(file.addHelper("classPrivateSetter"),[_core.types.cloneNode(id),cloneId(setId),this.receiver(member),value]):_core.types.callExpression(file.addHelper("classPrivateFieldSet"),[this.receiver(member),cloneId(id),value]):_core.types.sequenceExpression([this.receiver(member),value,readOnlyError(file,name)]):newHelpers(file)?_core.types.callExpression(file.addHelper("classPrivateFieldSet2"),[cloneId(id),this.receiver(member),value]):_core.types.callExpression(file.addHelper("classPrivateFieldSet"),[this.receiver(member),cloneId(id),value])})),destructureSet(member){const{classRef,privateNamesMap,file,noUninitializedPrivateFieldAccess}=this,privateName=member.node.property,{name}=privateName.id,{id,static:isStatic,method:isMethod,setId}=privateNamesMap.get(name),cloneId=id=>_core.types.inherits(_core.types.cloneNode(id),privateName);if(!newHelpers(file)){if(isStatic){try{var helper=file.addHelper("classStaticPrivateFieldDestructureSet");}catch(_unused){throw new Error("Babel can not transpile `[C.#p] = [0]` with @babel/helpers < 7.13.10, \nplease update @babel/helpers to the latest version.")}return _core.types.memberExpression(_core.types.callExpression(helper,[this.receiver(member),_core.types.cloneNode(classRef),cloneId(id)]),_core.types.identifier("value"))}return _core.types.memberExpression(_core.types.callExpression(file.addHelper("classPrivateFieldDestructureSet"),[this.receiver(member),cloneId(id)]),_core.types.identifier("value"))}if(isMethod&&!setId)return _core.types.memberExpression(_core.types.sequenceExpression([member.node.object,readOnlyError(file,name)]),_core.types.identifier("_"));if(isStatic&&!isMethod){const getCall=this.get(member);if(!noUninitializedPrivateFieldAccess||!_core.types.isCallExpression(getCall))return getCall;const ref=getCall.arguments.pop();return getCall.arguments.push(_core.template.expression.ast`(_) => ${ref} = _`),_core.types.memberExpression(_core.types.callExpression(file.addHelper("toSetter"),[getCall]),_core.types.identifier("_"))}const setCall=this.set(member,_core.types.identifier("_"));if(!_core.types.isCallExpression(setCall)||!_core.types.isIdentifier(setCall.arguments[setCall.arguments.length-1],{name:"_"}))throw member.buildCodeFrameError("Internal Babel error while compiling this code. This is a Babel bug. Please report it at https://github.com/babel/babel/issues.");let args;return args=_core.types.isMemberExpression(setCall.callee,{computed:false})&&_core.types.isIdentifier(setCall.callee.property)&&"call"===setCall.callee.property.name?[setCall.callee.object,_core.types.arrayExpression(setCall.arguments.slice(1,-1)),setCall.arguments[0]]:[setCall.callee,_core.types.arrayExpression(setCall.arguments.slice(0,-1))],_core.types.memberExpression(_core.types.callExpression(file.addHelper("toSetter"),args),_core.types.identifier("_"))},call(member,args){return this.memoise(member,1),(0, _helperOptimiseCallExpression.default)(this.get(member),this.receiver(member),args,false)},optionalCall(member,args){return this.memoise(member,1),(0, _helperOptimiseCallExpression.default)(this.get(member),this.receiver(member),args,true)},delete(){throw new Error("Internal Babel error: deleting private elements is a parsing error.")}},privateNameHandlerLoose={get(member){const{privateNamesMap,file}=this,{object}=member.node,{name}=member.node.property.id;return _core.template.expression`BASE(REF, PROP)[PROP]`({BASE:file.addHelper("classPrivateFieldLooseBase"),REF:_core.types.cloneNode(object),PROP:_core.types.cloneNode(privateNamesMap.get(name).id)})},set(){throw new Error("private name handler with loose = true don't need set()")},boundGet(member){return _core.types.callExpression(_core.types.memberExpression(this.get(member),_core.types.identifier("bind")),[_core.types.cloneNode(member.node.object)])},simpleSet(member){return this.get(member)},destructureSet(member){return this.get(member)},call(member,args){return _core.types.callExpression(this.get(member),args)},optionalCall(member,args){return _core.types.optionalCallExpression(this.get(member),args,true)},delete(){throw new Error("Internal Babel error: deleting private elements is a parsing error.")}};function buildPrivateFieldInitLoose(ref,prop,privateNamesMap){const{id}=privateNamesMap.get(prop.node.key.id.name),value=prop.node.value||prop.scope.buildUndefinedNode();return inheritPropComments(_core.template.statement.ast`
      Object.defineProperty(${ref}, ${_core.types.cloneNode(id)}, {
        // configurable is false by default
        // enumerable is false by default
        writable: true,
        value: ${value}
      });
    `,prop)}function buildPrivateInstanceFieldInitSpec(ref,prop,privateNamesMap,state){const{id}=privateNamesMap.get(prop.node.key.id.name),value=prop.node.value||prop.scope.buildUndefinedNode();if(!state.availableHelper("classPrivateFieldInitSpec"))return inheritPropComments(_core.template.statement.ast`${_core.types.cloneNode(id)}.set(${ref}, {
          // configurable is always false for private elements
          // enumerable is always false for private elements
          writable: true,
          value: ${value},
        })`,prop);const helper=state.addHelper("classPrivateFieldInitSpec");return inheritLoc(inheritPropComments(_core.types.expressionStatement(_core.types.callExpression(helper,[_core.types.thisExpression(),inheritLoc(_core.types.cloneNode(id),prop.node.key),newHelpers(state)?value:_core.template.expression.ast`{ writable: true, value: ${value} }`])),prop),prop.node)}function buildPrivateStaticFieldInitSpec(prop,privateNamesMap,noUninitializedPrivateFieldAccess){const privateName=privateNamesMap.get(prop.node.key.id.name),value=noUninitializedPrivateFieldAccess?prop.node.value:_core.template.expression.ast`{
        _: ${prop.node.value||_core.types.buildUndefinedNode()}
      }`;return inheritPropComments(_core.types.variableDeclaration("var",[_core.types.variableDeclarator(_core.types.cloneNode(privateName.id),value)]),prop)}var buildPrivateStaticFieldInitSpecOld=function(prop,privateNamesMap){const privateName=privateNamesMap.get(prop.node.key.id.name),{id,getId,setId,initAdded}=privateName,isGetterOrSetter=getId||setId;if(!prop.isProperty()&&(initAdded||!isGetterOrSetter))return;if(isGetterOrSetter)return privateNamesMap.set(prop.node.key.id.name,Object.assign({},privateName,{initAdded:true})),inheritPropComments(_core.template.statement.ast`
          var ${_core.types.cloneNode(id)} = {
            // configurable is false by default
            // enumerable is false by default
            // writable is false by default
            get: ${getId?getId.name:prop.scope.buildUndefinedNode()},
            set: ${setId?setId.name:prop.scope.buildUndefinedNode()}
          }
        `,prop);const value=prop.node.value||prop.scope.buildUndefinedNode();return inheritPropComments(_core.template.statement.ast`
        var ${_core.types.cloneNode(id)} = {
          // configurable is false by default
          // enumerable is false by default
          writable: true,
          value: ${value}
        };
      `,prop)};function buildPrivateMethodInitLoose(ref,prop,privateNamesMap){const privateName=privateNamesMap.get(prop.node.key.id.name),{methodId,id,getId,setId,initAdded}=privateName;if(initAdded)return;if(methodId)return inheritPropComments(_core.template.statement.ast`
        Object.defineProperty(${ref}, ${id}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          value: ${methodId.name}
        });
      `,prop);return getId||setId?(privateNamesMap.set(prop.node.key.id.name,Object.assign({},privateName,{initAdded:true})),inheritPropComments(_core.template.statement.ast`
        Object.defineProperty(${ref}, ${id}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          get: ${getId?getId.name:prop.scope.buildUndefinedNode()},
          set: ${setId?setId.name:prop.scope.buildUndefinedNode()}
        });
      `,prop)):void 0}function buildPrivateInstanceMethodInitSpec(ref,prop,privateNamesMap,state){const privateName=privateNamesMap.get(prop.node.key.id.name);if(!privateName.initAdded){if(!newHelpers(state)){if(privateName.getId||privateName.setId)return function(ref,prop,privateNamesMap,state){const privateName=privateNamesMap.get(prop.node.key.id.name),{id,getId,setId}=privateName;if(privateNamesMap.set(prop.node.key.id.name,Object.assign({},privateName,{initAdded:true})),!state.availableHelper("classPrivateFieldInitSpec"))return inheritPropComments(_core.template.statement.ast`
          ${id}.set(${ref}, {
            get: ${getId?getId.name:prop.scope.buildUndefinedNode()},
            set: ${setId?setId.name:prop.scope.buildUndefinedNode()}
          });
        `,prop);const helper=state.addHelper("classPrivateFieldInitSpec");return inheritLoc(inheritPropComments(_core.template.statement.ast`${helper}(
      ${_core.types.thisExpression()},
      ${_core.types.cloneNode(id)},
      {
        get: ${getId?getId.name:prop.scope.buildUndefinedNode()},
        set: ${setId?setId.name:prop.scope.buildUndefinedNode()}
      },
    )`,prop),prop.node)}(ref,prop,privateNamesMap,state)}return function(ref,prop,privateNamesMap,state){const privateName=privateNamesMap.get(prop.node.key.id.name),{id}=privateName;if(!state.availableHelper("classPrivateMethodInitSpec"))return inheritPropComments(_core.template.statement.ast`${id}.add(${ref})`,prop);const helper=state.addHelper("classPrivateMethodInitSpec");return inheritPropComments(_core.template.statement.ast`${helper}(
      ${_core.types.thisExpression()},
      ${_core.types.cloneNode(id)}
    )`,prop)}(ref,prop,privateNamesMap,state)}}function buildPublicFieldInitLoose(ref,prop){const{key,computed}=prop.node,value=prop.node.value||prop.scope.buildUndefinedNode();return inheritPropComments(_core.types.expressionStatement(_core.types.assignmentExpression("=",_core.types.memberExpression(ref,key,computed||_core.types.isLiteral(key)),value)),prop)}function buildPublicFieldInitSpec(ref,prop,state){const{key,computed}=prop.node,value=prop.node.value||prop.scope.buildUndefinedNode();return inheritPropComments(_core.types.expressionStatement(_core.types.callExpression(state.addHelper("defineProperty"),[ref,computed||_core.types.isLiteral(key)?key:_core.types.stringLiteral(key.name),value])),prop)}function buildPrivateStaticMethodInitLoose(ref,prop,state,privateNamesMap){const privateName=privateNamesMap.get(prop.node.key.id.name),{id,methodId,getId,setId,initAdded}=privateName;if(initAdded)return;return getId||setId?(privateNamesMap.set(prop.node.key.id.name,Object.assign({},privateName,{initAdded:true})),inheritPropComments(_core.template.statement.ast`
        Object.defineProperty(${ref}, ${id}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          get: ${getId?getId.name:prop.scope.buildUndefinedNode()},
          set: ${setId?setId.name:prop.scope.buildUndefinedNode()}
        })
      `,prop)):inheritPropComments(_core.template.statement.ast`
      Object.defineProperty(${ref}, ${id}, {
        // configurable is false by default
        // enumerable is false by default
        // writable is false by default
        value: ${methodId.name}
      });
    `,prop)}function buildPrivateMethodDeclaration(file,prop,privateNamesMap,privateFieldsAsSymbolsOrProperties=false){const privateName=privateNamesMap.get(prop.node.key.id.name),{id,methodId,getId,setId,getterDeclared,setterDeclared,static:isStatic}=privateName,{params,body,generator,async}=prop.node,isGetter=getId&&0===params.length,isSetter=setId&&params.length>0;if(isGetter&&getterDeclared||isSetter&&setterDeclared)return privateNamesMap.set(prop.node.key.id.name,Object.assign({},privateName,{initAdded:true})),null;if(newHelpers(file)&&(isGetter||isSetter)&&!privateFieldsAsSymbolsOrProperties){const scope=prop.get("body").scope,thisArg=scope.generateUidIdentifier("this"),state={thisRef:thisArg,argumentsPath:[]};if(prop.traverse(thisContextVisitor,state),state.argumentsPath.length){const argumentsId=scope.generateUidIdentifier("arguments");scope.push({id:argumentsId,init:_core.template.expression.ast`[].slice.call(arguments, 1)`});for(const path of state.argumentsPath)path.replaceWith(_core.types.cloneNode(argumentsId));}params.unshift(_core.types.cloneNode(thisArg));}let declId=methodId;return isGetter?(privateNamesMap.set(prop.node.key.id.name,Object.assign({},privateName,{getterDeclared:true,initAdded:true})),declId=getId):isSetter?(privateNamesMap.set(prop.node.key.id.name,Object.assign({},privateName,{setterDeclared:true,initAdded:true})),declId=setId):isStatic&&!privateFieldsAsSymbolsOrProperties&&(declId=id),inheritPropComments(_core.types.functionDeclaration(_core.types.cloneNode(declId),params,body,generator,async),prop)}const thisContextVisitor=_traverse.visitors.environmentVisitor({Identifier(path,state){state.argumentsPath&&"arguments"===path.node.name&&state.argumentsPath.push(path);},UnaryExpression(path){const{node}=path;if("delete"===node.operator){const argument=(0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrapperNodes)(node.argument);_core.types.isThisExpression(argument)&&path.replaceWith(_core.types.booleanLiteral(true));}},ThisExpression(path,state){state.needsClassRef=true,path.replaceWith(_core.types.cloneNode(state.thisRef));},MetaProperty(path){const{node,scope}=path;"new"===node.meta.name&&"target"===node.property.name&&path.replaceWith(scope.buildUndefinedNode());}}),innerReferencesVisitor={ReferencedIdentifier(path,state){path.scope.bindingIdentifierEquals(path.node.name,state.innerBinding)&&(state.needsClassRef=true,path.node.name=state.thisRef.name);}};function replaceThisContext(path,ref,innerBindingRef){var _state$thisRef;const state={thisRef:ref,needsClassRef:false,innerBinding:innerBindingRef};return path.isMethod()||path.traverse(thisContextVisitor,state),null!=innerBindingRef&&null!=(_state$thisRef=state.thisRef)&&_state$thisRef.name&&state.thisRef.name!==innerBindingRef.name&&path.traverse(innerReferencesVisitor,state),state.needsClassRef}function isNameOrLength({key,computed}){return "Identifier"===key.type?!computed&&("name"===key.name||"length"===key.name):"StringLiteral"===key.type&&("name"===key.value||"length"===key.value)}function inheritPropComments(node,prop){return _core.types.inheritLeadingComments(node,prop.node),_core.types.inheritInnerComments(node,prop.node),node}function inheritLoc(node,original){return node.start=original.start,node.end=original.end,node.loc=original.loc,node}},"./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.25.9_@babel+core@7.26.0/node_modules/@babel/helper-create-class-features-plugin/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),Object.defineProperty(exports,"FEATURES",{enumerable:true,get:function(){return _features.FEATURES}}),Object.defineProperty(exports,"buildCheckInRHS",{enumerable:true,get:function(){return _fields.buildCheckInRHS}}),exports.createClassFeaturePlugin=function({name,feature,loose,manipulateOptions,api,inherits,decoratorVersion}){var _api$assumption;if(feature&_features.FEATURES.decorators&&("2023-11"===decoratorVersion||"2023-05"===decoratorVersion||"2023-01"===decoratorVersion||"2022-03"===decoratorVersion||"2021-12"===decoratorVersion))return (0, _decorators.default)(api,{loose},decoratorVersion,inherits);null!=api||(api={assumption:()=>{}});const setPublicClassFields=api.assumption("setPublicClassFields"),privateFieldsAsSymbols=api.assumption("privateFieldsAsSymbols"),privateFieldsAsProperties=api.assumption("privateFieldsAsProperties"),noUninitializedPrivateFieldAccess=null!=(_api$assumption=api.assumption("noUninitializedPrivateFieldAccess"))&&_api$assumption,constantSuper=api.assumption("constantSuper"),noDocumentAll=api.assumption("noDocumentAll");if(privateFieldsAsProperties&&privateFieldsAsSymbols)throw new Error('Cannot enable both the "privateFieldsAsProperties" and "privateFieldsAsSymbols" assumptions as the same time.');const privateFieldsAsSymbolsOrProperties=privateFieldsAsProperties||privateFieldsAsSymbols;if(true===loose){const explicit=[];void 0!==setPublicClassFields&&explicit.push('"setPublicClassFields"'),void 0!==privateFieldsAsProperties&&explicit.push('"privateFieldsAsProperties"'),void 0!==privateFieldsAsSymbols&&explicit.push('"privateFieldsAsSymbols"'),0!==explicit.length&&console.warn(`[${name}]: You are using the "loose: true" option and you are explicitly setting a value for the ${explicit.join(" and ")} assumption${explicit.length>1?"s":""}. The "loose" option can cause incompatibilities with the other class features plugins, so it's recommended that you replace it with the following top-level option:\n\t"assumptions": {\n\t\t"setPublicClassFields": true,\n\t\t"privateFieldsAsSymbols": true\n\t}`);}return {name,manipulateOptions,inherits,pre(file){(0, _features.enableFeature)(file,feature,loose),"number"!=typeof file.get(versionKey)&&file.get(versionKey)&&!_semver.lt(file.get(versionKey),"7.25.9")||file.set(versionKey,"7.25.9");},visitor:{Class(path,{file}){var _ref;if("7.25.9"!==file.get(versionKey))return;if(!(0, _features.shouldTransform)(path,file))return;const pathIsClassDeclaration=path.isClassDeclaration();pathIsClassDeclaration&&(0, _typescript.assertFieldTransformed)(path);const loose=(0, _features.isLoose)(file,feature);let constructor;const isDecorated=(0, _decorators2.hasDecorators)(path.node),props=[],elements=[],computedPaths=[],privateNames=new Set,body=path.get("body");for(const path of body.get("body")){if((path.isClassProperty()||path.isClassMethod())&&path.node.computed&&computedPaths.push(path),path.isPrivate()){const{name}=path.node.key.id,getName=`get ${name}`,setName=`set ${name}`;if(path.isClassPrivateMethod()){if("get"===path.node.kind){if(privateNames.has(getName)||privateNames.has(name)&&!privateNames.has(setName))throw path.buildCodeFrameError("Duplicate private field");privateNames.add(getName).add(name);}else if("set"===path.node.kind){if(privateNames.has(setName)||privateNames.has(name)&&!privateNames.has(getName))throw path.buildCodeFrameError("Duplicate private field");privateNames.add(setName).add(name);}}else {if(privateNames.has(name)&&!privateNames.has(getName)&&!privateNames.has(setName)||privateNames.has(name)&&(privateNames.has(getName)||privateNames.has(setName)))throw path.buildCodeFrameError("Duplicate private field");privateNames.add(name);}}path.isClassMethod({kind:"constructor"})?constructor=path:(elements.push(path),(path.isProperty()||path.isPrivate()||null!=path.isStaticBlock&&path.isStaticBlock())&&props.push(path));}if(!props.length&&!isDecorated)return;const innerBinding=path.node.id;let ref;innerBinding&&pathIsClassDeclaration||(null!=path.ensureFunctionName||(path.ensureFunctionName=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/index.js").NodePath.prototype.ensureFunctionName),path.ensureFunctionName(false),ref=path.scope.generateUidIdentifier((null==innerBinding?void 0:innerBinding.name)||"Class"));const classRefForDefine=null!=(_ref=ref)?_ref:_core.types.cloneNode(innerBinding),privateNamesMap=(0, _fields.buildPrivateNamesMap)(classRefForDefine.name,null!=privateFieldsAsSymbolsOrProperties?privateFieldsAsSymbolsOrProperties:loose,props,file),privateNamesNodes=(0, _fields.buildPrivateNamesNodes)(privateNamesMap,null!=privateFieldsAsProperties?privateFieldsAsProperties:loose,null!=privateFieldsAsSymbols&&privateFieldsAsSymbols,file);let keysNodes,staticNodes,instanceNodes,lastInstanceNodeReturnsThis,pureStaticNodes,classBindingNode,wrapClass;(0, _fields.transformPrivateNamesUsage)(classRefForDefine,path,privateNamesMap,{privateFieldsAsProperties:null!=privateFieldsAsSymbolsOrProperties?privateFieldsAsSymbolsOrProperties:loose,noUninitializedPrivateFieldAccess,noDocumentAll,innerBinding},file),isDecorated?(staticNodes=pureStaticNodes=keysNodes=[],({instanceNodes,wrapClass}=(0, _decorators2.buildDecoratedClass)(classRefForDefine,path,elements,file))):(keysNodes=(0, _misc.extractComputedKeys)(path,computedPaths,file),({staticNodes,pureStaticNodes,instanceNodes,lastInstanceNodeReturnsThis,classBindingNode,wrapClass}=(0, _fields.buildFieldsInitNodes)(ref,path.node.superClass,props,privateNamesMap,file,null!=setPublicClassFields?setPublicClassFields:loose,null!=privateFieldsAsSymbolsOrProperties?privateFieldsAsSymbolsOrProperties:loose,noUninitializedPrivateFieldAccess,null!=constantSuper?constantSuper:loose,innerBinding))),instanceNodes.length>0&&(0, _misc.injectInitialization)(path,constructor,instanceNodes,((referenceVisitor,state)=>{if(!isDecorated)for(const prop of props)null!=_core.types.isStaticBlock&&_core.types.isStaticBlock(prop.node)||prop.node.static||prop.traverse(referenceVisitor,state);}),lastInstanceNodeReturnsThis);const wrappedPath=wrapClass(path);wrappedPath.insertBefore([...privateNamesNodes,...keysNodes]),staticNodes.length>0&&wrappedPath.insertAfter(staticNodes),pureStaticNodes.length>0&&wrappedPath.find((parent=>parent.isStatement()||parent.isDeclaration())).insertAfter(pureStaticNodes),null!=classBindingNode&&pathIsClassDeclaration&&wrappedPath.insertAfter(classBindingNode);},ExportDefaultDeclaration(path,{file}){{if("7.25.9"!==file.get(versionKey))return;const decl=path.get("declaration");if(decl.isClassDeclaration()&&(0, _decorators2.hasDecorators)(decl.node))if(decl.node.id)null!=path.splitExportDeclaration||(path.splitExportDeclaration=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/index.js").NodePath.prototype.splitExportDeclaration),path.splitExportDeclaration();else decl.node.type="ClassExpression";}}}}},Object.defineProperty(exports,"enableFeature",{enumerable:true,get:function(){return _features.enableFeature}}),Object.defineProperty(exports,"injectInitialization",{enumerable:true,get:function(){return _misc.injectInitialization}});var _core=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/index.js"),_decorators=__webpack_require__("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.25.9_@babel+core@7.26.0/node_modules/@babel/helper-create-class-features-plugin/lib/decorators.js"),_semver=__webpack_require__("./node_modules/.pnpm/semver@6.3.1/node_modules/semver/semver.js"),_fields=__webpack_require__("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.25.9_@babel+core@7.26.0/node_modules/@babel/helper-create-class-features-plugin/lib/fields.js"),_decorators2=__webpack_require__("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.25.9_@babel+core@7.26.0/node_modules/@babel/helper-create-class-features-plugin/lib/decorators-2018-09.js"),_misc=__webpack_require__("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.25.9_@babel+core@7.26.0/node_modules/@babel/helper-create-class-features-plugin/lib/misc.js"),_features=__webpack_require__("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.25.9_@babel+core@7.26.0/node_modules/@babel/helper-create-class-features-plugin/lib/features.js"),_typescript=__webpack_require__("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.25.9_@babel+core@7.26.0/node_modules/@babel/helper-create-class-features-plugin/lib/typescript.js");const versionKey="@babel/plugin-class-features/version";},"./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.25.9_@babel+core@7.26.0/node_modules/@babel/helper-create-class-features-plugin/lib/misc.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.extractComputedKeys=function(path,computedPaths,file){const{scope}=path,declarations=[],state={classBinding:path.node.id&&scope.getBinding(path.node.id.name),file};for(const computedPath of computedPaths){const computedKey=computedPath.get("key");computedKey.isReferencedIdentifier()?handleClassTDZ(computedKey,state):computedKey.traverse(classFieldDefinitionEvaluationTDZVisitor,state);const computedNode=computedPath.node;if(!computedKey.isConstantExpression()){const assignment=memoiseComputedKey(computedKey.node,scope,scope.generateUidBasedOnNode(computedKey.node));assignment&&(declarations.push(_core.types.expressionStatement(assignment)),computedNode.key=_core.types.cloneNode(assignment.left));}}return declarations},exports.injectInitialization=function(path,constructor,nodes,renamer,lastReturnsThis){if(!nodes.length)return;const isDerived=!!path.node.superClass;if(!constructor){const newConstructor=_core.types.classMethod("constructor",_core.types.identifier("constructor"),[],_core.types.blockStatement([]));isDerived&&(newConstructor.params=[_core.types.restElement(_core.types.identifier("args"))],newConstructor.body.body.push(_core.template.statement.ast`super(...args)`)),[constructor]=path.get("body").unshiftContainer("body",newConstructor);}renamer&&renamer(referenceVisitor,{scope:constructor.scope});if(isDerived){const bareSupers=[];constructor.traverse(findBareSupers,bareSupers);let isFirst=true;for(const bareSuper of bareSupers)if(isFirst?isFirst=false:nodes=nodes.map((n=>_core.types.cloneNode(n))),bareSuper.parentPath.isExpressionStatement())bareSuper.insertAfter(nodes);else {const allNodes=[bareSuper.node,...nodes.map((n=>_core.types.toExpression(n)))];lastReturnsThis||allNodes.push(_core.types.thisExpression()),bareSuper.replaceWith(_core.types.sequenceExpression(allNodes));}}else constructor.get("body").unshiftContainer("body",nodes);},exports.memoiseComputedKey=memoiseComputedKey;var _core=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/index.js");const findBareSupers=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/index.js").visitors.environmentVisitor({Super(path){const{node,parentPath}=path;parentPath.isCallExpression({callee:node})&&this.push(parentPath);}}),referenceVisitor={"TSTypeAnnotation|TypeAnnotation"(path){path.skip();},ReferencedIdentifier(path,{scope}){scope.hasOwnBinding(path.node.name)&&(scope.rename(path.node.name),path.skip());}};function handleClassTDZ(path,state){if(state.classBinding&&state.classBinding===path.scope.getBinding(path.node.name)){const classNameTDZError=state.file.addHelper("classNameTDZError"),throwNode=_core.types.callExpression(classNameTDZError,[_core.types.stringLiteral(path.node.name)]);path.replaceWith(_core.types.sequenceExpression([throwNode,path.node])),path.skip();}}const classFieldDefinitionEvaluationTDZVisitor={ReferencedIdentifier:handleClassTDZ};function memoiseComputedKey(keyNode,scope,hint){if(_core.types.isIdentifier(keyNode)&&scope.hasUid(keyNode.name))return;if(_core.types.isAssignmentExpression(keyNode,{operator:"="})&&_core.types.isIdentifier(keyNode.left)&&scope.hasUid(keyNode.left.name))return _core.types.cloneNode(keyNode);{const ident=_core.types.identifier(hint);return scope.push({id:ident,kind:"let"}),_core.types.assignmentExpression("=",_core.types.cloneNode(ident),keyNode)}}},"./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.25.9_@babel+core@7.26.0/node_modules/@babel/helper-create-class-features-plugin/lib/typescript.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.assertFieldTransformed=function(path){if(path.node.declare)throw path.buildCodeFrameError("TypeScript 'declare' fields must first be transformed by @babel/plugin-transform-typescript.\nIf you have already enabled that plugin (or '@babel/preset-typescript'), make sure that it runs before any plugin related to additional class features:\n - @babel/plugin-transform-class-properties\n - @babel/plugin-transform-private-methods\n - @babel/plugin-proposal-decorators")};},"./node_modules/.pnpm/@babel+helper-member-expression-to-functions@7.25.9/node_modules/@babel/helper-member-expression-to-functions/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{function _interopNamespace(e){if(e&&e.__esModule)return e;var n=Object.create(null);return e&&Object.keys(e).forEach((function(k){if("default"!==k){var d=Object.getOwnPropertyDescriptor(e,k);Object.defineProperty(n,k,d.get?d:{enumerable:true,get:function(){return e[k]}});}})),n.default=e,Object.freeze(n)}Object.defineProperty(exports,"__esModule",{value:true});var _t__namespace=_interopNamespace(__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js"));function willPathCastToBoolean(path){const maybeWrapped=path,{node,parentPath}=maybeWrapped;if(parentPath.isLogicalExpression()){const{operator,right}=parentPath.node;if("&&"===operator||"||"===operator||"??"===operator&&node===right)return willPathCastToBoolean(parentPath)}if(parentPath.isSequenceExpression()){const{expressions}=parentPath.node;return expressions[expressions.length-1]!==node||willPathCastToBoolean(parentPath)}return parentPath.isConditional({test:node})||parentPath.isUnaryExpression({operator:"!"})||parentPath.isLoop({test:node})}const{LOGICAL_OPERATORS,arrowFunctionExpression,assignmentExpression,binaryExpression,booleanLiteral,callExpression,cloneNode,conditionalExpression,identifier,isMemberExpression,isOptionalCallExpression,isOptionalMemberExpression,isUpdateExpression,logicalExpression,memberExpression,nullLiteral,optionalCallExpression,optionalMemberExpression,sequenceExpression,updateExpression}=_t__namespace;class AssignmentMemoiser{constructor(){this._map=void 0,this._map=new WeakMap;}has(key){return this._map.has(key)}get(key){if(!this.has(key))return;const record=this._map.get(key),{value}=record;return record.count--,0===record.count?assignmentExpression("=",value,key):value}set(key,value,count){return this._map.set(key,{count,value})}}function toNonOptional(path,base){const{node}=path;if(isOptionalMemberExpression(node))return memberExpression(base,node.property,node.computed);if(path.isOptionalCallExpression()){const callee=path.get("callee");if(path.node.optional&&callee.isOptionalMemberExpression()){const object=callee.node.object,context=path.scope.maybeGenerateMemoised(object);return callee.get("object").replaceWith(assignmentExpression("=",context,object)),callExpression(memberExpression(base,identifier("call")),[context,...path.node.arguments])}return callExpression(base,path.node.arguments)}return path.node}const handle={memoise(){},handle(member,noDocumentAll){const{node,parent,parentPath,scope}=member;if(member.isOptionalMemberExpression()){if(function(path){for(;path&&!path.isProgram();){const{parentPath,container,listKey}=path,parentNode=parentPath.node;if(listKey){if(container!==parentNode[listKey])return  true}else if(container!==parentNode)return  true;path=parentPath;}return  false}(member))return;const endPath=member.find((({node,parent})=>isOptionalMemberExpression(parent)?parent.optional||parent.object!==node:!isOptionalCallExpression(parent)||(node!==member.node&&parent.optional||parent.callee!==node)));if(scope.path.isPattern())return void endPath.replaceWith(callExpression(arrowFunctionExpression([],endPath.node),[]));const willEndPathCastToBoolean=willPathCastToBoolean(endPath),rootParentPath=endPath.parentPath;if(rootParentPath.isUpdateExpression({argument:node}))throw member.buildCodeFrameError("can't handle update expression");const isAssignment=rootParentPath.isAssignmentExpression({left:endPath.node}),isDeleteOperation=rootParentPath.isUnaryExpression({operator:"delete"});if(isDeleteOperation&&endPath.isOptionalMemberExpression()&&endPath.get("property").isPrivateName())throw member.buildCodeFrameError("can't delete a private class element");let startingOptional=member;for(;;)if(startingOptional.isOptionalMemberExpression()){if(startingOptional.node.optional)break;startingOptional=startingOptional.get("object");}else {if(!startingOptional.isOptionalCallExpression())throw new Error(`Internal error: unexpected ${startingOptional.node.type}`);if(startingOptional.node.optional)break;startingOptional=startingOptional.get("callee");}const startingNode=startingOptional.isOptionalMemberExpression()?startingOptional.node.object:startingOptional.node.callee,baseNeedsMemoised=scope.maybeGenerateMemoised(startingNode),baseRef=null!=baseNeedsMemoised?baseNeedsMemoised:startingNode,parentIsOptionalCall=parentPath.isOptionalCallExpression({callee:node}),isOptionalCall=parent=>parentIsOptionalCall,parentIsCall=parentPath.isCallExpression({callee:node});startingOptional.replaceWith(toNonOptional(startingOptional,baseRef)),isOptionalCall()?parent.optional?parentPath.replaceWith(this.optionalCall(member,parent.arguments)):parentPath.replaceWith(this.call(member,parent.arguments)):parentIsCall?member.replaceWith(this.boundGet(member)):this.delete&&parentPath.isUnaryExpression({operator:"delete"})?parentPath.replaceWith(this.delete(member)):parentPath.isAssignmentExpression()?handleAssignment(this,member,parentPath):member.replaceWith(this.get(member));let context,regular=member.node;for(let current=member;current!==endPath;){const parentPath=current.parentPath;if(parentPath===endPath&&isOptionalCall()&&parent.optional){regular=parentPath.node;break}regular=toNonOptional(parentPath,regular),current=parentPath;}const endParentPath=endPath.parentPath;if(isMemberExpression(regular)&&endParentPath.isOptionalCallExpression({callee:endPath.node,optional:true})){const{object}=regular;context=member.scope.maybeGenerateMemoised(object),context&&(regular.object=assignmentExpression("=",context,object));}let replacementPath=endPath;(isDeleteOperation||isAssignment)&&(replacementPath=endParentPath,regular=endParentPath.node);const baseMemoised=baseNeedsMemoised?assignmentExpression("=",cloneNode(baseRef),cloneNode(startingNode)):cloneNode(baseRef);if(willEndPathCastToBoolean){let nonNullishCheck;nonNullishCheck=noDocumentAll?binaryExpression("!=",baseMemoised,nullLiteral()):logicalExpression("&&",binaryExpression("!==",baseMemoised,nullLiteral()),binaryExpression("!==",cloneNode(baseRef),scope.buildUndefinedNode())),replacementPath.replaceWith(logicalExpression("&&",nonNullishCheck,regular));}else {let nullishCheck;nullishCheck=noDocumentAll?binaryExpression("==",baseMemoised,nullLiteral()):logicalExpression("||",binaryExpression("===",baseMemoised,nullLiteral()),binaryExpression("===",cloneNode(baseRef),scope.buildUndefinedNode())),replacementPath.replaceWith(conditionalExpression(nullishCheck,isDeleteOperation?booleanLiteral(true):scope.buildUndefinedNode(),regular));}if(context){const endParent=endParentPath.node;endParentPath.replaceWith(optionalCallExpression(optionalMemberExpression(endParent.callee,identifier("call"),false,true),[cloneNode(context),...endParent.arguments],false));}}else {if(isUpdateExpression(parent,{argument:node})){if(this.simpleSet)return void member.replaceWith(this.simpleSet(member));const{operator,prefix}=parent;this.memoise(member,2);const ref=scope.generateUidIdentifierBasedOnNode(node);scope.push({id:ref});const seq=[assignmentExpression("=",cloneNode(ref),this.get(member))];if(prefix){seq.push(updateExpression(operator,cloneNode(ref),prefix));const value=sequenceExpression(seq);return void parentPath.replaceWith(this.set(member,value))}{const ref2=scope.generateUidIdentifierBasedOnNode(node);scope.push({id:ref2}),seq.push(assignmentExpression("=",cloneNode(ref2),updateExpression(operator,cloneNode(ref),prefix)),cloneNode(ref));const value=sequenceExpression(seq);return void parentPath.replaceWith(sequenceExpression([this.set(member,value),cloneNode(ref2)]))}}if(parentPath.isAssignmentExpression({left:node}))handleAssignment(this,member,parentPath);else {if(!parentPath.isCallExpression({callee:node}))return parentPath.isOptionalCallExpression({callee:node})?scope.path.isPattern()?void parentPath.replaceWith(callExpression(arrowFunctionExpression([],parentPath.node),[])):void parentPath.replaceWith(this.optionalCall(member,parentPath.node.arguments)):void(this.delete&&parentPath.isUnaryExpression({operator:"delete"})?parentPath.replaceWith(this.delete(member)):parentPath.isForXStatement({left:node})||parentPath.isObjectProperty({value:node})&&parentPath.parentPath.isObjectPattern()||parentPath.isAssignmentPattern({left:node})&&parentPath.parentPath.isObjectProperty({value:parent})&&parentPath.parentPath.parentPath.isObjectPattern()||parentPath.isArrayPattern()||parentPath.isAssignmentPattern({left:node})&&parentPath.parentPath.isArrayPattern()||parentPath.isRestElement()?member.replaceWith(this.destructureSet(member)):parentPath.isTaggedTemplateExpression()?member.replaceWith(this.boundGet(member)):member.replaceWith(this.get(member)));parentPath.replaceWith(this.call(member,parentPath.node.arguments));}}}};function handleAssignment(state,member,parentPath){if(state.simpleSet)return void member.replaceWith(state.simpleSet(member));const{operator,right:value}=parentPath.node;if("="===operator)parentPath.replaceWith(state.set(member,value));else {const operatorTrunc=operator.slice(0,-1);LOGICAL_OPERATORS.includes(operatorTrunc)?(state.memoise(member,1),parentPath.replaceWith(logicalExpression(operatorTrunc,state.get(member),state.set(member,value)))):(state.memoise(member,2),parentPath.replaceWith(state.set(member,binaryExpression(operatorTrunc,state.get(member),value))));}}exports.default=function(path,visitor,state){path.traverse(visitor,Object.assign({},handle,state,{memoiser:new AssignmentMemoiser}));};},"./node_modules/.pnpm/@babel+helper-module-imports@7.25.9/node_modules/@babel/helper-module-imports/lib/import-builder.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=void 0;var _assert=__webpack_require__("assert"),_t=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js");const{callExpression,cloneNode,expressionStatement,identifier,importDeclaration,importDefaultSpecifier,importNamespaceSpecifier,importSpecifier,memberExpression,stringLiteral,variableDeclaration,variableDeclarator}=_t;exports.default=class{constructor(importedSource,scope,hub){this._statements=[],this._resultName=null,this._importedSource=void 0,this._scope=scope,this._hub=hub,this._importedSource=importedSource;}done(){return {statements:this._statements,resultName:this._resultName}}import(){return this._statements.push(importDeclaration([],stringLiteral(this._importedSource))),this}require(){return this._statements.push(expressionStatement(callExpression(identifier("require"),[stringLiteral(this._importedSource)]))),this}namespace(name="namespace"){const local=this._scope.generateUidIdentifier(name),statement=this._statements[this._statements.length-1];return _assert("ImportDeclaration"===statement.type),_assert(0===statement.specifiers.length),statement.specifiers=[importNamespaceSpecifier(local)],this._resultName=cloneNode(local),this}default(name){const id=this._scope.generateUidIdentifier(name),statement=this._statements[this._statements.length-1];return _assert("ImportDeclaration"===statement.type),_assert(0===statement.specifiers.length),statement.specifiers=[importDefaultSpecifier(id)],this._resultName=cloneNode(id),this}named(name,importName){if("default"===importName)return this.default(name);const id=this._scope.generateUidIdentifier(name),statement=this._statements[this._statements.length-1];return _assert("ImportDeclaration"===statement.type),_assert(0===statement.specifiers.length),statement.specifiers=[importSpecifier(id,identifier(importName))],this._resultName=cloneNode(id),this}var(name){const id=this._scope.generateUidIdentifier(name);let statement=this._statements[this._statements.length-1];return "ExpressionStatement"!==statement.type&&(_assert(this._resultName),statement=expressionStatement(this._resultName),this._statements.push(statement)),this._statements[this._statements.length-1]=variableDeclaration("var",[variableDeclarator(id,statement.expression)]),this._resultName=cloneNode(id),this}defaultInterop(){return this._interop(this._hub.addHelper("interopRequireDefault"))}wildcardInterop(){return this._interop(this._hub.addHelper("interopRequireWildcard"))}_interop(callee){const statement=this._statements[this._statements.length-1];return "ExpressionStatement"===statement.type?statement.expression=callExpression(callee,[statement.expression]):"VariableDeclaration"===statement.type?(_assert(1===statement.declarations.length),statement.declarations[0].init=callExpression(callee,[statement.declarations[0].init])):_assert.fail("Unexpected type."),this}prop(name){const statement=this._statements[this._statements.length-1];return "ExpressionStatement"===statement.type?statement.expression=memberExpression(statement.expression,identifier(name)):"VariableDeclaration"===statement.type?(_assert(1===statement.declarations.length),statement.declarations[0].init=memberExpression(statement.declarations[0].init,identifier(name))):_assert.fail("Unexpected type:"+statement.type),this}read(name){this._resultName=memberExpression(this._resultName,identifier(name));}};},"./node_modules/.pnpm/@babel+helper-module-imports@7.25.9/node_modules/@babel/helper-module-imports/lib/import-injector.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=void 0;var _assert=__webpack_require__("assert"),_t=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js"),_importBuilder=__webpack_require__("./node_modules/.pnpm/@babel+helper-module-imports@7.25.9/node_modules/@babel/helper-module-imports/lib/import-builder.js"),_isModule=__webpack_require__("./node_modules/.pnpm/@babel+helper-module-imports@7.25.9/node_modules/@babel/helper-module-imports/lib/is-module.js");const{identifier,importSpecifier,numericLiteral,sequenceExpression,isImportDeclaration}=_t;function isValueImport(node){return "type"!==node.importKind&&"typeof"!==node.importKind}function hasNamespaceImport(node){return 1===node.specifiers.length&&"ImportNamespaceSpecifier"===node.specifiers[0].type||2===node.specifiers.length&&"ImportNamespaceSpecifier"===node.specifiers[1].type}function hasDefaultImport(node){return node.specifiers.length>0&&"ImportDefaultSpecifier"===node.specifiers[0].type}function maybeAppendImportSpecifiers(target,source){return target.specifiers.length?!source.specifiers.length||!hasNamespaceImport(target)&&!hasNamespaceImport(source)&&(hasDefaultImport(source)&&(hasDefaultImport(target)?source.specifiers[0]=importSpecifier(source.specifiers[0].local,identifier("default")):target.specifiers.unshift(source.specifiers.shift())),target.specifiers.push(...source.specifiers),true):(target.specifiers=source.specifiers,true)}exports.default=class{constructor(path,importedSource,opts){this._defaultOpts={importedSource:null,importedType:"commonjs",importedInterop:"babel",importingInterop:"babel",ensureLiveReference:false,ensureNoContext:false,importPosition:"before"};const programPath=path.find((p=>p.isProgram()));this._programPath=programPath,this._programScope=programPath.scope,this._hub=programPath.hub,this._defaultOpts=this._applyDefaults(importedSource,opts,true);}addDefault(importedSourceIn,opts){return this.addNamed("default",importedSourceIn,opts)}addNamed(importName,importedSourceIn,opts){return _assert("string"==typeof importName),this._generateImport(this._applyDefaults(importedSourceIn,opts),importName)}addNamespace(importedSourceIn,opts){return this._generateImport(this._applyDefaults(importedSourceIn,opts),null)}addSideEffect(importedSourceIn,opts){return this._generateImport(this._applyDefaults(importedSourceIn,opts),void 0)}_applyDefaults(importedSource,opts,isInit=false){let newOpts;return "string"==typeof importedSource?newOpts=Object.assign({},this._defaultOpts,{importedSource},opts):(_assert(!opts,"Unexpected secondary arguments."),newOpts=Object.assign({},this._defaultOpts,importedSource)),!isInit&&opts&&(void 0!==opts.nameHint&&(newOpts.nameHint=opts.nameHint),void 0!==opts.blockHoist&&(newOpts.blockHoist=opts.blockHoist)),newOpts}_generateImport(opts,importName){const isDefault="default"===importName,isNamed=!!importName&&!isDefault,isNamespace=null===importName,{importedSource,importedType,importedInterop,importingInterop,ensureLiveReference,ensureNoContext,nameHint,importPosition,blockHoist}=opts;let name=nameHint||importName;const isMod=(0, _isModule.default)(this._programPath),isModuleForNode=isMod&&"node"===importingInterop,isModuleForBabel=isMod&&"babel"===importingInterop;if("after"===importPosition&&!isMod)throw new Error('"importPosition": "after" is only supported in modules');const builder=new _importBuilder.default(importedSource,this._programScope,this._hub);if("es6"===importedType){if(!isModuleForNode&&!isModuleForBabel)throw new Error("Cannot import an ES6 module from CommonJS");builder.import(),isNamespace?builder.namespace(nameHint||importedSource):(isDefault||isNamed)&&builder.named(name,importName);}else {if("commonjs"!==importedType)throw new Error(`Unexpected interopType "${importedType}"`);if("babel"===importedInterop)if(isModuleForNode){name="default"!==name?name:importedSource;const es6Default=`${importedSource}$es6Default`;builder.import(),isNamespace?builder.default(es6Default).var(name||importedSource).wildcardInterop():isDefault?ensureLiveReference?builder.default(es6Default).var(name||importedSource).defaultInterop().read("default"):builder.default(es6Default).var(name).defaultInterop().prop(importName):isNamed&&builder.default(es6Default).read(importName);}else isModuleForBabel?(builder.import(),isNamespace?builder.namespace(name||importedSource):(isDefault||isNamed)&&builder.named(name,importName)):(builder.require(),isNamespace?builder.var(name||importedSource).wildcardInterop():(isDefault||isNamed)&&ensureLiveReference?isDefault?(name="default"!==name?name:importedSource,builder.var(name).read(importName),builder.defaultInterop()):builder.var(importedSource).read(importName):isDefault?builder.var(name).defaultInterop().prop(importName):isNamed&&builder.var(name).prop(importName));else if("compiled"===importedInterop)isModuleForNode?(builder.import(),isNamespace?builder.default(name||importedSource):(isDefault||isNamed)&&builder.default(importedSource).read(name)):isModuleForBabel?(builder.import(),isNamespace?builder.namespace(name||importedSource):(isDefault||isNamed)&&builder.named(name,importName)):(builder.require(),isNamespace?builder.var(name||importedSource):(isDefault||isNamed)&&(ensureLiveReference?builder.var(importedSource).read(name):builder.prop(importName).var(name)));else {if("uncompiled"!==importedInterop)throw new Error(`Unknown importedInterop "${importedInterop}".`);if(isDefault&&ensureLiveReference)throw new Error("No live reference for commonjs default");isModuleForNode?(builder.import(),isNamespace?builder.default(name||importedSource):isDefault?builder.default(name):isNamed&&builder.default(importedSource).read(name)):isModuleForBabel?(builder.import(),isNamespace?builder.default(name||importedSource):isDefault?builder.default(name):isNamed&&builder.named(name,importName)):(builder.require(),isNamespace?builder.var(name||importedSource):isDefault?builder.var(name):isNamed&&(ensureLiveReference?builder.var(importedSource).read(name):builder.var(name).prop(importName)));}}const{statements,resultName}=builder.done();return this._insertStatements(statements,importPosition,blockHoist),(isDefault||isNamed)&&ensureNoContext&&"Identifier"!==resultName.type?sequenceExpression([numericLiteral(0),resultName]):resultName}_insertStatements(statements,importPosition="before",blockHoist=3){if("after"===importPosition){if(this._insertStatementsAfter(statements))return}else if(this._insertStatementsBefore(statements,blockHoist))return;this._programPath.unshiftContainer("body",statements);}_insertStatementsBefore(statements,blockHoist){if(1===statements.length&&isImportDeclaration(statements[0])&&isValueImport(statements[0])){const firstImportDecl=this._programPath.get("body").find((p=>p.isImportDeclaration()&&isValueImport(p.node)));if((null==firstImportDecl?void 0:firstImportDecl.node.source.value)===statements[0].source.value&&maybeAppendImportSpecifiers(firstImportDecl.node,statements[0]))return  true}statements.forEach((node=>{node._blockHoist=blockHoist;}));const targetPath=this._programPath.get("body").find((p=>{const val=p.node._blockHoist;return Number.isFinite(val)&&val<4}));return !!targetPath&&(targetPath.insertBefore(statements),true)}_insertStatementsAfter(statements){const statementsSet=new Set(statements),importDeclarations=new Map;for(const statement of statements)if(isImportDeclaration(statement)&&isValueImport(statement)){const source=statement.source.value;importDeclarations.has(source)||importDeclarations.set(source,[]),importDeclarations.get(source).push(statement);}let lastImportPath=null;for(const bodyStmt of this._programPath.get("body"))if(bodyStmt.isImportDeclaration()&&isValueImport(bodyStmt.node)){lastImportPath=bodyStmt;const source=bodyStmt.node.source.value,newImports=importDeclarations.get(source);if(!newImports)continue;for(const decl of newImports)statementsSet.has(decl)&&maybeAppendImportSpecifiers(bodyStmt.node,decl)&&statementsSet.delete(decl);}return 0===statementsSet.size||(lastImportPath&&lastImportPath.insertAfter(Array.from(statementsSet)),!!lastImportPath)}};},"./node_modules/.pnpm/@babel+helper-module-imports@7.25.9/node_modules/@babel/helper-module-imports/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),Object.defineProperty(exports,"ImportInjector",{enumerable:true,get:function(){return _importInjector.default}}),exports.addDefault=function(path,importedSource,opts){return new _importInjector.default(path).addDefault(importedSource,opts)},exports.addNamed=function(path,name,importedSource,opts){return new _importInjector.default(path).addNamed(name,importedSource,opts)},exports.addNamespace=function(path,importedSource,opts){return new _importInjector.default(path).addNamespace(importedSource,opts)},exports.addSideEffect=function(path,importedSource,opts){return new _importInjector.default(path).addSideEffect(importedSource,opts)},Object.defineProperty(exports,"isModule",{enumerable:true,get:function(){return _isModule.default}});var _importInjector=__webpack_require__("./node_modules/.pnpm/@babel+helper-module-imports@7.25.9/node_modules/@babel/helper-module-imports/lib/import-injector.js"),_isModule=__webpack_require__("./node_modules/.pnpm/@babel+helper-module-imports@7.25.9/node_modules/@babel/helper-module-imports/lib/is-module.js");},"./node_modules/.pnpm/@babel+helper-module-imports@7.25.9/node_modules/@babel/helper-module-imports/lib/is-module.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(path){return "module"===path.node.sourceType};},"./node_modules/.pnpm/@babel+helper-module-transforms@7.26.0_@babel+core@7.26.0/node_modules/@babel/helper-module-transforms/lib/dynamic-import.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.buildDynamicImport=function(node,deferToThen,wrapWithPromise,builder){const specifier=_core.types.isCallExpression(node)?node.arguments[0]:node.source;if(_core.types.isStringLiteral(specifier)||_core.types.isTemplateLiteral(specifier)&&0===specifier.quasis.length)return deferToThen?_core.template.expression.ast`
        Promise.resolve().then(() => ${builder(specifier)})
      `:builder(specifier);const specifierToString=_core.types.isTemplateLiteral(specifier)?_core.types.identifier("specifier"):_core.types.templateLiteral([_core.types.templateElement({raw:""}),_core.types.templateElement({raw:""})],[_core.types.identifier("specifier")]);return deferToThen?_core.template.expression.ast`
      (specifier =>
        new Promise(r => r(${specifierToString}))
          .then(s => ${builder(_core.types.identifier("s"))})
      )(${specifier})
    `:wrapWithPromise?_core.template.expression.ast`
      (specifier =>
        new Promise(r => r(${builder(specifierToString)}))
      )(${specifier})
    `:_core.template.expression.ast`
      (specifier => ${builder(specifierToString)})(${specifier})
    `};var _core=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/index.js");exports.getDynamicImportSource=function(node){const[source]=node.arguments;return _core.types.isStringLiteral(source)||_core.types.isTemplateLiteral(source)?source:_core.template.expression.ast`\`\${${source}}\``};},"./node_modules/.pnpm/@babel+helper-module-transforms@7.26.0_@babel+core@7.26.0/node_modules/@babel/helper-module-transforms/lib/get-module-name.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=getModuleName;{const originalGetModuleName=getModuleName;exports.default=getModuleName=function(rootOpts,pluginOpts){var _pluginOpts$moduleId,_pluginOpts$moduleIds,_pluginOpts$getModule,_pluginOpts$moduleRoo;return originalGetModuleName(rootOpts,{moduleId:null!=(_pluginOpts$moduleId=pluginOpts.moduleId)?_pluginOpts$moduleId:rootOpts.moduleId,moduleIds:null!=(_pluginOpts$moduleIds=pluginOpts.moduleIds)?_pluginOpts$moduleIds:rootOpts.moduleIds,getModuleId:null!=(_pluginOpts$getModule=pluginOpts.getModuleId)?_pluginOpts$getModule:rootOpts.getModuleId,moduleRoot:null!=(_pluginOpts$moduleRoo=pluginOpts.moduleRoot)?_pluginOpts$moduleRoo:rootOpts.moduleRoot})};}function getModuleName(rootOpts,pluginOpts){const{filename,filenameRelative=filename,sourceRoot=pluginOpts.moduleRoot}=rootOpts,{moduleId,moduleIds=!!moduleId,getModuleId,moduleRoot=sourceRoot}=pluginOpts;if(!moduleIds)return null;if(null!=moduleId&&!getModuleId)return moduleId;let moduleName=null!=moduleRoot?moduleRoot+"/":"";if(filenameRelative){const sourceRootReplacer=null!=sourceRoot?new RegExp("^"+sourceRoot+"/?"):"";moduleName+=filenameRelative.replace(sourceRootReplacer,"").replace(/\.\w*$/,"");}return moduleName=moduleName.replace(/\\/g,"/"),getModuleId&&getModuleId(moduleName)||moduleName}},"./node_modules/.pnpm/@babel+helper-module-transforms@7.26.0_@babel+core@7.26.0/node_modules/@babel/helper-module-transforms/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),Object.defineProperty(exports,"buildDynamicImport",{enumerable:true,get:function(){return _dynamicImport.buildDynamicImport}}),exports.buildNamespaceInitStatements=function(metadata,sourceMetadata,constantReexports=false,wrapReference=Lazy.wrapReference){var _wrapReference;const statements=[],srcNamespaceId=_core.types.identifier(sourceMetadata.name);for(const localName of sourceMetadata.importsNamespace)localName!==sourceMetadata.name&&statements.push(_core.template.statement`var NAME = SOURCE;`({NAME:localName,SOURCE:_core.types.cloneNode(srcNamespaceId)}));const srcNamespace=null!=(_wrapReference=wrapReference(srcNamespaceId,sourceMetadata.wrap))?_wrapReference:srcNamespaceId;constantReexports&&statements.push(...buildReexportsFromMeta(metadata,sourceMetadata,true,wrapReference));for(const exportName of sourceMetadata.reexportNamespace)statements.push((_core.types.isIdentifier(srcNamespace)?_core.template.statement`EXPORTS.NAME = NAMESPACE;`:_core.template.statement`
            Object.defineProperty(EXPORTS, "NAME", {
              enumerable: true,
              get: function() {
                return NAMESPACE;
              }
            });
          `)({EXPORTS:metadata.exportName,NAME:exportName,NAMESPACE:_core.types.cloneNode(srcNamespace)}));if(sourceMetadata.reexportAll){const statement=function(metadata,namespace,constantReexports){return (constantReexports?_core.template.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          EXPORTS[key] = NAMESPACE[key];
        });
      `:_core.template.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          Object.defineProperty(EXPORTS, key, {
            enumerable: true,
            get: function() {
              return NAMESPACE[key];
            },
          });
        });
    `)({NAMESPACE:namespace,EXPORTS:metadata.exportName,VERIFY_NAME_LIST:metadata.exportNameListName?_core.template`
            if (Object.prototype.hasOwnProperty.call(EXPORTS_LIST, key)) return;
          `({EXPORTS_LIST:metadata.exportNameListName}):null})}(metadata,_core.types.cloneNode(srcNamespace),constantReexports);statement.loc=sourceMetadata.reexportAll.loc,statements.push(statement);}return statements},exports.ensureStatementsHoisted=function(statements){statements.forEach((header=>{header._blockHoist=3;}));},Object.defineProperty(exports,"getModuleName",{enumerable:true,get:function(){return _getModuleName.default}}),Object.defineProperty(exports,"hasExports",{enumerable:true,get:function(){return _normalizeAndLoadMetadata.hasExports}}),Object.defineProperty(exports,"isModule",{enumerable:true,get:function(){return _helperModuleImports.isModule}}),Object.defineProperty(exports,"isSideEffectImport",{enumerable:true,get:function(){return _normalizeAndLoadMetadata.isSideEffectImport}}),exports.rewriteModuleStatementsAndPrepareHeader=function(path,{exportName,strict,allowTopLevelThis,strictMode,noInterop,importInterop=noInterop?"none":"babel",lazy,getWrapperPayload=Lazy.toGetWrapperPayload(null!=lazy&&lazy),wrapReference=Lazy.wrapReference,esNamespaceOnly,filename,constantReexports=arguments[1].loose,enumerableModuleMeta=arguments[1].loose,noIncompleteNsImportDetection}){(0, _normalizeAndLoadMetadata.validateImportInteropOption)(importInterop),_assert((0, _helperModuleImports.isModule)(path),"Cannot process module statements in a script"),path.node.sourceType="script";const meta=(0, _normalizeAndLoadMetadata.default)(path,exportName,{importInterop,initializeReexports:constantReexports,getWrapperPayload,esNamespaceOnly,filename});allowTopLevelThis||(0, _rewriteThis.default)(path);if((0, _rewriteLiveReferences.default)(path,meta,wrapReference),false!==strictMode){path.node.directives.some((directive=>"use strict"===directive.value.value))||path.unshiftContainer("directives",_core.types.directive(_core.types.directiveLiteral("use strict")));}const headers=[];(0, _normalizeAndLoadMetadata.hasExports)(meta)&&!strict&&headers.push(function(metadata,enumerableModuleMeta=false){return (enumerableModuleMeta?_core.template.statement`
        EXPORTS.__esModule = true;
      `:_core.template.statement`
        Object.defineProperty(EXPORTS, "__esModule", {
          value: true,
        });
      `)({EXPORTS:metadata.exportName})}(meta,enumerableModuleMeta));const nameList=function(programPath,metadata){const exportedVars=Object.create(null);for(const data of metadata.local.values())for(const name of data.names)exportedVars[name]=true;let hasReexport=false;for(const data of metadata.source.values()){for(const exportName of data.reexports.keys())exportedVars[exportName]=true;for(const exportName of data.reexportNamespace)exportedVars[exportName]=true;hasReexport=hasReexport||!!data.reexportAll;}if(!hasReexport||0===Object.keys(exportedVars).length)return null;const name=programPath.scope.generateUidIdentifier("exportNames");return delete exportedVars.default,{name:name.name,statement:_core.types.variableDeclaration("var",[_core.types.variableDeclarator(name,_core.types.valueToNode(exportedVars))])}}(path,meta);nameList&&(meta.exportNameListName=nameList.name,headers.push(nameList.statement));return headers.push(...function(programPath,metadata,wrapReference,constantReexports=false,noIncompleteNsImportDetection=false){const initStatements=[];for(const[localName,data]of metadata.local)if("import"===data.kind);else if("hoisted"===data.kind)initStatements.push([data.names[0],buildInitStatement(metadata,data.names,_core.types.identifier(localName))]);else if(!noIncompleteNsImportDetection)for(const exportName of data.names)initStatements.push([exportName,null]);for(const data of metadata.source.values()){if(!constantReexports){const reexportsStatements=buildReexportsFromMeta(metadata,data,false,wrapReference),reexports=[...data.reexports.keys()];for(let i=0;i<reexportsStatements.length;i++)initStatements.push([reexports[i],reexportsStatements[i]]);}if(!noIncompleteNsImportDetection)for(const exportName of data.reexportNamespace)initStatements.push([exportName,null]);}initStatements.sort((([a],[b])=>a<b?-1:b<a?1:0));const results=[];if(noIncompleteNsImportDetection)for(const[,initStatement]of initStatements)results.push(initStatement);else {const chunkSize=100;for(let i=0;i<initStatements.length;i+=chunkSize){let uninitializedExportNames=[];for(let j=0;j<chunkSize&&i+j<initStatements.length;j++){const[exportName,initStatement]=initStatements[i+j];null!==initStatement?(uninitializedExportNames.length>0&&(results.push(buildInitStatement(metadata,uninitializedExportNames,programPath.scope.buildUndefinedNode())),uninitializedExportNames=[]),results.push(initStatement)):uninitializedExportNames.push(exportName);}uninitializedExportNames.length>0&&results.push(buildInitStatement(metadata,uninitializedExportNames,programPath.scope.buildUndefinedNode()));}}return results}(path,meta,wrapReference,constantReexports,noIncompleteNsImportDetection)),{meta,headers}},Object.defineProperty(exports,"rewriteThis",{enumerable:true,get:function(){return _rewriteThis.default}}),exports.wrapInterop=function(programPath,expr,type){if("none"===type)return null;if("node-namespace"===type)return _core.types.callExpression(programPath.hub.addHelper("interopRequireWildcard"),[expr,_core.types.booleanLiteral(true)]);if("node-default"===type)return null;let helper;if("default"===type)helper="interopRequireDefault";else {if("namespace"!==type)throw new Error(`Unknown interop: ${type}`);helper="interopRequireWildcard";}return _core.types.callExpression(programPath.hub.addHelper(helper),[expr])};var _assert=__webpack_require__("assert"),_core=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/index.js"),_helperModuleImports=__webpack_require__("./node_modules/.pnpm/@babel+helper-module-imports@7.25.9/node_modules/@babel/helper-module-imports/lib/index.js"),_rewriteThis=__webpack_require__("./node_modules/.pnpm/@babel+helper-module-transforms@7.26.0_@babel+core@7.26.0/node_modules/@babel/helper-module-transforms/lib/rewrite-this.js"),_rewriteLiveReferences=__webpack_require__("./node_modules/.pnpm/@babel+helper-module-transforms@7.26.0_@babel+core@7.26.0/node_modules/@babel/helper-module-transforms/lib/rewrite-live-references.js"),_normalizeAndLoadMetadata=__webpack_require__("./node_modules/.pnpm/@babel+helper-module-transforms@7.26.0_@babel+core@7.26.0/node_modules/@babel/helper-module-transforms/lib/normalize-and-load-metadata.js"),Lazy=__webpack_require__("./node_modules/.pnpm/@babel+helper-module-transforms@7.26.0_@babel+core@7.26.0/node_modules/@babel/helper-module-transforms/lib/lazy-modules.js"),_dynamicImport=__webpack_require__("./node_modules/.pnpm/@babel+helper-module-transforms@7.26.0_@babel+core@7.26.0/node_modules/@babel/helper-module-transforms/lib/dynamic-import.js"),_getModuleName=__webpack_require__("./node_modules/.pnpm/@babel+helper-module-transforms@7.26.0_@babel+core@7.26.0/node_modules/@babel/helper-module-transforms/lib/get-module-name.js");exports.getDynamicImportSource=__webpack_require__("./node_modules/.pnpm/@babel+helper-module-transforms@7.26.0_@babel+core@7.26.0/node_modules/@babel/helper-module-transforms/lib/dynamic-import.js").getDynamicImportSource;const ReexportTemplate={constant:({exports,exportName,namespaceImport})=>_core.template.statement.ast`
      ${exports}.${exportName} = ${namespaceImport};
    `,constantComputed:({exports,exportName,namespaceImport})=>_core.template.statement.ast`
      ${exports}["${exportName}"] = ${namespaceImport};
    `,spec:({exports,exportName,namespaceImport})=>_core.template.statement.ast`
      Object.defineProperty(${exports}, "${exportName}", {
        enumerable: true,
        get: function() {
          return ${namespaceImport};
        },
      });
    `};function buildReexportsFromMeta(meta,metadata,constantReexports,wrapReference){var _wrapReference2;let namespace=_core.types.identifier(metadata.name);namespace=null!=(_wrapReference2=wrapReference(namespace,metadata.wrap))?_wrapReference2:namespace;const{stringSpecifiers}=meta;return Array.from(metadata.reexports,(([exportName,importName])=>{let namespaceImport=_core.types.cloneNode(namespace);"default"===importName&&"node-default"===metadata.interop||(namespaceImport=stringSpecifiers.has(importName)?_core.types.memberExpression(namespaceImport,_core.types.stringLiteral(importName),true):_core.types.memberExpression(namespaceImport,_core.types.identifier(importName)));const astNodes={exports:meta.exportName,exportName,namespaceImport};return constantReexports||_core.types.isIdentifier(namespaceImport)?stringSpecifiers.has(exportName)?ReexportTemplate.constantComputed(astNodes):ReexportTemplate.constant(astNodes):ReexportTemplate.spec(astNodes)}))}const InitTemplate={computed:({exports,name,value})=>_core.template.expression.ast`${exports}["${name}"] = ${value}`,default:({exports,name,value})=>_core.template.expression.ast`${exports}.${name} = ${value}`,define:({exports,name,value})=>_core.template.expression.ast`
      Object.defineProperty(${exports}, "${name}", {
        enumerable: true,
        value: void 0,
        writable: true
      })["${name}"] = ${value}`};function buildInitStatement(metadata,exportNames,initExpr){const{stringSpecifiers,exportName:exports}=metadata;return _core.types.expressionStatement(exportNames.reduce(((value,name)=>{const params={exports,name,value};return "__proto__"===name?InitTemplate.define(params):stringSpecifiers.has(name)?InitTemplate.computed(params):InitTemplate.default(params)}),initExpr))}},"./node_modules/.pnpm/@babel+helper-module-transforms@7.26.0_@babel+core@7.26.0/node_modules/@babel/helper-module-transforms/lib/lazy-modules.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.toGetWrapperPayload=function(lazy){return (source,metadata)=>{if(false===lazy)return null;if((0, _normalizeAndLoadMetadata.isSideEffectImport)(metadata)||metadata.reexportAll)return null;if(true===lazy)return source.includes(".")?null:"lazy";if(Array.isArray(lazy))return lazy.includes(source)?"lazy":null;if("function"==typeof lazy)return lazy(source)?"lazy":null;throw new Error(".lazy must be a boolean, string array, or function")}},exports.wrapReference=function(ref,payload){return "lazy"===payload?_core.types.callExpression(ref,[]):null};var _core=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/index.js"),_normalizeAndLoadMetadata=__webpack_require__("./node_modules/.pnpm/@babel+helper-module-transforms@7.26.0_@babel+core@7.26.0/node_modules/@babel/helper-module-transforms/lib/normalize-and-load-metadata.js");},"./node_modules/.pnpm/@babel+helper-module-transforms@7.26.0_@babel+core@7.26.0/node_modules/@babel/helper-module-transforms/lib/normalize-and-load-metadata.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(programPath,exportName,{importInterop,initializeReexports=false,getWrapperPayload,esNamespaceOnly=false,filename}){exportName||(exportName=programPath.scope.generateUidIdentifier("exports").name);const stringSpecifiers=new Set;!function(programPath){programPath.get("body").forEach((child=>{child.isExportDefaultDeclaration()&&(null!=child.splitExportDeclaration||(child.splitExportDeclaration=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/index.js").NodePath.prototype.splitExportDeclaration),child.splitExportDeclaration());}));}(programPath);const{local,sources,hasExports}=function(programPath,{getWrapperPayload,initializeReexports},stringSpecifiers){const localData=function(programPath,initializeReexports,stringSpecifiers){const bindingKindLookup=new Map;programPath.get("body").forEach((child=>{let kind;if(child.isImportDeclaration())kind="import";else {if(child.isExportDefaultDeclaration()&&(child=child.get("declaration")),child.isExportNamedDeclaration())if(child.node.declaration)child=child.get("declaration");else if(initializeReexports&&child.node.source&&child.get("source").isStringLiteral())return void child.get("specifiers").forEach((spec=>{assertExportSpecifier(spec),bindingKindLookup.set(spec.get("local").node.name,"block");}));if(child.isFunctionDeclaration())kind="hoisted";else if(child.isClassDeclaration())kind="block";else if(child.isVariableDeclaration({kind:"var"}))kind="var";else {if(!child.isVariableDeclaration())return;kind="block";}}Object.keys(child.getOuterBindingIdentifiers()).forEach((name=>{bindingKindLookup.set(name,kind);}));}));const localMetadata=new Map,getLocalMetadata=idPath=>{const localName=idPath.node.name;let metadata=localMetadata.get(localName);if(!metadata){const kind=bindingKindLookup.get(localName);if(void 0===kind)throw idPath.buildCodeFrameError(`Exporting local "${localName}", which is not declared.`);metadata={names:[],kind},localMetadata.set(localName,metadata);}return metadata};return programPath.get("body").forEach((child=>{if(!child.isExportNamedDeclaration()||!initializeReexports&&child.node.source){if(child.isExportDefaultDeclaration()){const declaration=child.get("declaration");if(!declaration.isFunctionDeclaration()&&!declaration.isClassDeclaration())throw declaration.buildCodeFrameError("Unexpected default expression export.");getLocalMetadata(declaration.get("id")).names.push("default");}}else if(child.node.declaration){const declaration=child.get("declaration"),ids=declaration.getOuterBindingIdentifierPaths();Object.keys(ids).forEach((name=>{if("__esModule"===name)throw declaration.buildCodeFrameError('Illegal export "__esModule".');getLocalMetadata(ids[name]).names.push(name);}));}else child.get("specifiers").forEach((spec=>{const local=spec.get("local"),exported=spec.get("exported"),localMetadata=getLocalMetadata(local),exportName=getExportSpecifierName(exported,stringSpecifiers);if("__esModule"===exportName)throw exported.buildCodeFrameError('Illegal export "__esModule".');localMetadata.names.push(exportName);}));})),localMetadata}(programPath,initializeReexports,stringSpecifiers),importNodes=new Map,sourceData=new Map,getData=(sourceNode,node)=>{const source=sourceNode.value;let data=sourceData.get(source);return data?importNodes.get(source).push(node):(data={name:programPath.scope.generateUidIdentifier((0, _path.basename)(source,(0, _path.extname)(source))).name,interop:"none",loc:null,imports:new Map,importsNamespace:new Set,reexports:new Map,reexportNamespace:new Set,reexportAll:null,wrap:null,get lazy(){return "lazy"===this.wrap},referenced:false},sourceData.set(source,data),importNodes.set(source,[node])),data};let hasExports=false;programPath.get("body").forEach((child=>{if(child.isImportDeclaration()){const data=getData(child.node.source,child.node);data.loc||(data.loc=child.node.loc),child.get("specifiers").forEach((spec=>{if(spec.isImportDefaultSpecifier()){const localName=spec.get("local").node.name;data.imports.set(localName,"default");const reexport=localData.get(localName);reexport&&(localData.delete(localName),reexport.names.forEach((name=>{data.reexports.set(name,"default");})),data.referenced=true);}else if(spec.isImportNamespaceSpecifier()){const localName=spec.get("local").node.name;data.importsNamespace.add(localName);const reexport=localData.get(localName);reexport&&(localData.delete(localName),reexport.names.forEach((name=>{data.reexportNamespace.add(name);})),data.referenced=true);}else if(spec.isImportSpecifier()){const importName=getExportSpecifierName(spec.get("imported"),stringSpecifiers),localName=spec.get("local").node.name;data.imports.set(localName,importName);const reexport=localData.get(localName);reexport&&(localData.delete(localName),reexport.names.forEach((name=>{data.reexports.set(name,importName);})),data.referenced=true);}}));}else if(child.isExportAllDeclaration()){hasExports=true;const data=getData(child.node.source,child.node);data.loc||(data.loc=child.node.loc),data.reexportAll={loc:child.node.loc},data.referenced=true;}else if(child.isExportNamedDeclaration()&&child.node.source){hasExports=true;const data=getData(child.node.source,child.node);data.loc||(data.loc=child.node.loc),child.get("specifiers").forEach((spec=>{assertExportSpecifier(spec);const importName=getExportSpecifierName(spec.get("local"),stringSpecifiers),exportName=getExportSpecifierName(spec.get("exported"),stringSpecifiers);if(data.reexports.set(exportName,importName),data.referenced=true,"__esModule"===exportName)throw spec.get("exported").buildCodeFrameError('Illegal export "__esModule".')}));}else (child.isExportNamedDeclaration()||child.isExportDefaultDeclaration())&&(hasExports=true);}));for(const metadata of sourceData.values()){let needsDefault=false,needsNamed=false;metadata.importsNamespace.size>0&&(needsDefault=true,needsNamed=true),metadata.reexportAll&&(needsNamed=true);for(const importName of metadata.imports.values())"default"===importName?needsDefault=true:needsNamed=true;for(const importName of metadata.reexports.values())"default"===importName?needsDefault=true:needsNamed=true;needsDefault&&needsNamed?metadata.interop="namespace":needsDefault&&(metadata.interop="default");}if(getWrapperPayload)for(const[source,metadata]of sourceData)metadata.wrap=getWrapperPayload(source,metadata,importNodes.get(source));return {hasExports,local:localData,sources:sourceData}}(programPath,{initializeReexports,getWrapperPayload},stringSpecifiers);!function(programPath){programPath.get("body").forEach((child=>{if(child.isImportDeclaration())child.remove();else if(child.isExportNamedDeclaration())child.node.declaration?(child.node.declaration._blockHoist=child.node._blockHoist,child.replaceWith(child.node.declaration)):child.remove();else if(child.isExportDefaultDeclaration()){const declaration=child.get("declaration");if(!declaration.isFunctionDeclaration()&&!declaration.isClassDeclaration())throw declaration.buildCodeFrameError("Unexpected default expression export.");declaration._blockHoist=child.node._blockHoist,child.replaceWith(declaration);}else child.isExportAllDeclaration()&&child.remove();}));}(programPath);for(const[source,metadata]of sources){const{importsNamespace,imports}=metadata;if(importsNamespace.size>0&&0===imports.size){const[nameOfnamespace]=importsNamespace;metadata.name=nameOfnamespace;}const resolvedInterop=resolveImportInterop(importInterop,source,filename);"none"===resolvedInterop?metadata.interop="none":"node"===resolvedInterop&&"namespace"===metadata.interop?metadata.interop="node-namespace":"node"===resolvedInterop&&"default"===metadata.interop?metadata.interop="node-default":esNamespaceOnly&&"namespace"===metadata.interop&&(metadata.interop="default");}return {exportName,exportNameListName:null,hasExports,local,source:sources,stringSpecifiers}},exports.hasExports=function(metadata){return metadata.hasExports},exports.isSideEffectImport=function(source){return 0===source.imports.size&&0===source.importsNamespace.size&&0===source.reexports.size&&0===source.reexportNamespace.size&&!source.reexportAll},exports.validateImportInteropOption=validateImportInteropOption;var _path=__webpack_require__("path"),_helperValidatorIdentifier=__webpack_require__("./node_modules/.pnpm/@babel+helper-validator-identifier@7.25.9/node_modules/@babel/helper-validator-identifier/lib/index.js");function validateImportInteropOption(importInterop){if("function"!=typeof importInterop&&"none"!==importInterop&&"babel"!==importInterop&&"node"!==importInterop)throw new Error(`.importInterop must be one of "none", "babel", "node", or a function returning one of those values (received ${importInterop}).`);return importInterop}function resolveImportInterop(importInterop,source,filename){return "function"==typeof importInterop?validateImportInteropOption(importInterop(source,filename)):importInterop}function getExportSpecifierName(path,stringSpecifiers){if(path.isIdentifier())return path.node.name;if(path.isStringLiteral()){const stringValue=path.node.value;return (0, _helperValidatorIdentifier.isIdentifierName)(stringValue)||stringSpecifiers.add(stringValue),stringValue}throw new Error(`Expected export specifier to be either Identifier or StringLiteral, got ${path.node.type}`)}function assertExportSpecifier(path){if(!path.isExportSpecifier())throw path.isExportNamespaceSpecifier()?path.buildCodeFrameError("Export namespace should be first transformed by `@babel/plugin-transform-export-namespace-from`."):path.buildCodeFrameError("Unexpected export specifier type")}},"./node_modules/.pnpm/@babel+helper-module-transforms@7.26.0_@babel+core@7.26.0/node_modules/@babel/helper-module-transforms/lib/rewrite-live-references.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(programPath,metadata,wrapReference){const imported=new Map,exported=new Map,requeueInParent=path=>{programPath.requeue(path);};for(const[source,data]of metadata.source){for(const[localName,importName]of data.imports)imported.set(localName,[source,importName,null]);for(const localName of data.importsNamespace)imported.set(localName,[source,null,localName]);}for(const[local,data]of metadata.local){let exportMeta=exported.get(local);exportMeta||(exportMeta=[],exported.set(local,exportMeta)),exportMeta.push(...data.names);}const rewriteBindingInitVisitorState={metadata,requeueInParent,scope:programPath.scope,exported};programPath.traverse(rewriteBindingInitVisitor,rewriteBindingInitVisitorState);const rewriteReferencesVisitorState={seen:new WeakSet,metadata,requeueInParent,scope:programPath.scope,imported,exported,buildImportReference([source,importName,localName],identNode){const meta=metadata.source.get(source);if(meta.referenced=true,localName){var _wrapReference;if(meta.wrap)identNode=null!=(_wrapReference=wrapReference(identNode,meta.wrap))?_wrapReference:identNode;return identNode}let namespace=_core.types.identifier(meta.name);var _wrapReference2;meta.wrap&&(namespace=null!=(_wrapReference2=wrapReference(namespace,meta.wrap))?_wrapReference2:namespace);if("default"===importName&&"node-default"===meta.interop)return namespace;const computed=metadata.stringSpecifiers.has(importName);return _core.types.memberExpression(namespace,computed?_core.types.stringLiteral(importName):_core.types.identifier(importName),computed)}};programPath.traverse(rewriteReferencesVisitor,rewriteReferencesVisitorState);};var _core=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/index.js");const rewriteBindingInitVisitor={Scope(path){path.skip();},ClassDeclaration(path){const{requeueInParent,exported,metadata}=this,{id}=path.node;if(!id)throw new Error("Expected class to have a name");const localName=id.name,exportNames=exported.get(localName)||[];if(exportNames.length>0){const statement=_core.types.expressionStatement(buildBindingExportAssignmentExpression(metadata,exportNames,_core.types.identifier(localName),path.scope));statement._blockHoist=path.node._blockHoist,requeueInParent(path.insertAfter(statement)[0]);}},VariableDeclaration(path){const{requeueInParent,exported,metadata}=this,isVar="var"===path.node.kind;for(const decl of path.get("declarations")){const{id}=decl.node;let{init}=decl.node;if(!_core.types.isIdentifier(id)||!exported.has(id.name)||_core.types.isArrowFunctionExpression(init)||_core.types.isFunctionExpression(init)&&!init.id||_core.types.isClassExpression(init)&&!init.id){for(const localName of Object.keys(decl.getOuterBindingIdentifiers()))if(exported.has(localName)){const statement=_core.types.expressionStatement(buildBindingExportAssignmentExpression(metadata,exported.get(localName),_core.types.identifier(localName),path.scope));statement._blockHoist=path.node._blockHoist,requeueInParent(path.insertAfter(statement)[0]);}}else {if(!init){if(isVar)continue;init=path.scope.buildUndefinedNode();}decl.node.init=buildBindingExportAssignmentExpression(metadata,exported.get(id.name),init,path.scope),requeueInParent(decl.get("init"));}}}},buildBindingExportAssignmentExpression=(metadata,exportNames,localExpr,scope)=>{const exportsObjectName=metadata.exportName;for(let currentScope=scope;null!=currentScope;currentScope=currentScope.parent)currentScope.hasOwnBinding(exportsObjectName)&&currentScope.rename(exportsObjectName);return (exportNames||[]).reduce(((expr,exportName)=>{const{stringSpecifiers}=metadata,computed=stringSpecifiers.has(exportName);return _core.types.assignmentExpression("=",_core.types.memberExpression(_core.types.identifier(exportsObjectName),computed?_core.types.stringLiteral(exportName):_core.types.identifier(exportName),computed),expr)}),localExpr)},buildImportThrow=localName=>_core.template.expression.ast`
    (function() {
      throw new Error('"' + '${localName}' + '" is read-only.');
    })()
  `,rewriteReferencesVisitor={ReferencedIdentifier(path){const{seen,buildImportReference,scope,imported,requeueInParent}=this;if(seen.has(path.node))return;seen.add(path.node);const localName=path.node.name,importData=imported.get(localName);if(importData){if(function(path){do{switch(path.parent.type){case "TSTypeAnnotation":case "TSTypeAliasDeclaration":case "TSTypeReference":case "TypeAnnotation":case "TypeAlias":return  true;case "ExportSpecifier":return "type"===path.parentPath.parent.exportKind;default:if(path.parentPath.isStatement()||path.parentPath.isExpression())return  false}}while(path=path.parentPath)}(path))throw path.buildCodeFrameError(`Cannot transform the imported binding "${localName}" since it's also used in a type annotation. Please strip type annotations using @babel/preset-typescript or @babel/preset-flow.`);const localBinding=path.scope.getBinding(localName);if(scope.getBinding(localName)!==localBinding)return;const ref=buildImportReference(importData,path.node);if(ref.loc=path.node.loc,(path.parentPath.isCallExpression({callee:path.node})||path.parentPath.isOptionalCallExpression({callee:path.node})||path.parentPath.isTaggedTemplateExpression({tag:path.node}))&&_core.types.isMemberExpression(ref))path.replaceWith(_core.types.sequenceExpression([_core.types.numericLiteral(0),ref]));else if(path.isJSXIdentifier()&&_core.types.isMemberExpression(ref)){const{object,property}=ref;path.replaceWith(_core.types.jsxMemberExpression(_core.types.jsxIdentifier(object.name),_core.types.jsxIdentifier(property.name)));}else path.replaceWith(ref);requeueInParent(path),path.skip();}},UpdateExpression(path){const{scope,seen,imported,exported,requeueInParent,buildImportReference}=this;if(seen.has(path.node))return;seen.add(path.node);const arg=path.get("argument");if(arg.isMemberExpression())return;const update=path.node;if(arg.isIdentifier()){const localName=arg.node.name;if(scope.getBinding(localName)!==path.scope.getBinding(localName))return;const exportedNames=exported.get(localName),importData=imported.get(localName);if((null==exportedNames?void 0:exportedNames.length)>0||importData)if(importData)path.replaceWith(_core.types.assignmentExpression(update.operator[0]+"=",buildImportReference(importData,arg.node),buildImportThrow(localName)));else if(update.prefix)path.replaceWith(buildBindingExportAssignmentExpression(this.metadata,exportedNames,_core.types.cloneNode(update),path.scope));else {const ref=scope.generateDeclaredUidIdentifier(localName);path.replaceWith(_core.types.sequenceExpression([_core.types.assignmentExpression("=",_core.types.cloneNode(ref),_core.types.cloneNode(update)),buildBindingExportAssignmentExpression(this.metadata,exportedNames,_core.types.identifier(localName),path.scope),_core.types.cloneNode(ref)]));}}requeueInParent(path),path.skip();},AssignmentExpression:{exit(path){const{scope,seen,imported,exported,requeueInParent,buildImportReference}=this;if(seen.has(path.node))return;seen.add(path.node);const left=path.get("left");if(!left.isMemberExpression())if(left.isIdentifier()){const localName=left.node.name;if(scope.getBinding(localName)!==path.scope.getBinding(localName))return;const exportedNames=exported.get(localName),importData=imported.get(localName);if((null==exportedNames?void 0:exportedNames.length)>0||importData){const assignment=path.node;importData&&(assignment.left=buildImportReference(importData,left.node),assignment.right=_core.types.sequenceExpression([assignment.right,buildImportThrow(localName)]));const{operator}=assignment;let newExpr;newExpr="="===operator?assignment:"&&="===operator||"||="===operator||"??="===operator?_core.types.assignmentExpression("=",assignment.left,_core.types.logicalExpression(operator.slice(0,-1),_core.types.cloneNode(assignment.left),assignment.right)):_core.types.assignmentExpression("=",assignment.left,_core.types.binaryExpression(operator.slice(0,-1),_core.types.cloneNode(assignment.left),assignment.right)),path.replaceWith(buildBindingExportAssignmentExpression(this.metadata,exportedNames,newExpr,path.scope)),requeueInParent(path),path.skip();}}else {const ids=left.getOuterBindingIdentifiers(),programScopeIds=Object.keys(ids).filter((localName=>scope.getBinding(localName)===path.scope.getBinding(localName))),id=programScopeIds.find((localName=>imported.has(localName)));id&&(path.node.right=_core.types.sequenceExpression([path.node.right,buildImportThrow(id)]));const items=[];if(programScopeIds.forEach((localName=>{const exportedNames=exported.get(localName)||[];exportedNames.length>0&&items.push(buildBindingExportAssignmentExpression(this.metadata,exportedNames,_core.types.identifier(localName),path.scope));})),items.length>0){let node=_core.types.sequenceExpression(items);path.parentPath.isExpressionStatement()&&(node=_core.types.expressionStatement(node),node._blockHoist=path.parentPath.node._blockHoist);requeueInParent(path.insertAfter(node)[0]);}}}},ForXStatement(path){const{scope,node}=path,{left}=node,{exported,imported,scope:programScope}=this;if(!_core.types.isVariableDeclaration(left)){let importConstViolationName,didTransformExport=false;const loopBodyScope=path.get("body").scope;for(const name of Object.keys(_core.types.getOuterBindingIdentifiers(left)))programScope.getBinding(name)===scope.getBinding(name)&&(exported.has(name)&&(didTransformExport=true,loopBodyScope.hasOwnBinding(name)&&loopBodyScope.rename(name)),imported.has(name)&&!importConstViolationName&&(importConstViolationName=name));if(!didTransformExport&&!importConstViolationName)return;path.ensureBlock();const bodyPath=path.get("body"),newLoopId=scope.generateUidIdentifierBasedOnNode(left);path.get("left").replaceWith(_core.types.variableDeclaration("let",[_core.types.variableDeclarator(_core.types.cloneNode(newLoopId))])),scope.registerDeclaration(path.get("left")),didTransformExport&&bodyPath.unshiftContainer("body",_core.types.expressionStatement(_core.types.assignmentExpression("=",left,newLoopId))),importConstViolationName&&bodyPath.unshiftContainer("body",_core.types.expressionStatement(buildImportThrow(importConstViolationName)));}}};},"./node_modules/.pnpm/@babel+helper-module-transforms@7.26.0_@babel+core@7.26.0/node_modules/@babel/helper-module-transforms/lib/rewrite-this.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(programPath){rewriteThisVisitor||(rewriteThisVisitor=_traverse.visitors.environmentVisitor({ThisExpression(path){path.replaceWith(_core.types.unaryExpression("void",_core.types.numericLiteral(0),true));}}),rewriteThisVisitor.noScope=true);(0, _traverse.default)(programPath.node,rewriteThisVisitor);};var _core=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/index.js"),_traverse=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/index.js");let rewriteThisVisitor;},"./node_modules/.pnpm/@babel+helper-optimise-call-expression@7.25.9/node_modules/@babel/helper-optimise-call-expression/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(callee,thisNode,args,optional){return 1===args.length&&isSpreadElement(args[0])&&isIdentifier(args[0].argument,{name:"arguments"})?optional?optionalCallExpression(optionalMemberExpression(callee,identifier("apply"),false,true),[thisNode,args[0].argument],false):callExpression(memberExpression(callee,identifier("apply")),[thisNode,args[0].argument]):optional?optionalCallExpression(optionalMemberExpression(callee,identifier("call"),false,true),[thisNode,...args],false):callExpression(memberExpression(callee,identifier("call")),[thisNode,...args])};var _t=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js");const{callExpression,identifier,isIdentifier,isSpreadElement,memberExpression,optionalCallExpression,optionalMemberExpression}=_t;},"./node_modules/.pnpm/@babel+helper-plugin-utils@7.25.9/node_modules/@babel/helper-plugin-utils/lib/index.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.declare=declare,exports.declarePreset=void 0;const apiPolyfills={assertVersion:api=>range=>{!function(range,version){if("number"==typeof range){if(!Number.isInteger(range))throw new Error("Expected string or integer value.");range=`^${range}.0.0-0`;}if("string"!=typeof range)throw new Error("Expected string or integer value.");const limit=Error.stackTraceLimit;"number"==typeof limit&&limit<25&&(Error.stackTraceLimit=25);let err;err="7."===version.slice(0,2)?new Error(`Requires Babel "^7.0.0-beta.41", but was loaded with "${version}". You'll need to update your @babel/core version.`):new Error(`Requires Babel "${range}", but was loaded with "${version}". If you are sure you have a compatible version of @babel/core, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for the first entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`);"number"==typeof limit&&(Error.stackTraceLimit=limit);throw Object.assign(err,{code:"BABEL_VERSION_UNSUPPORTED",version,range})}(range,api.version);}};function declare(builder){return (api,options,dirname)=>{var _clonedApi2;let clonedApi;for(const name of Object.keys(apiPolyfills)){api[name]||(null!=clonedApi||(clonedApi=copyApiObject(api)),clonedApi[name]=apiPolyfills[name](clonedApi));}return builder(null!=(_clonedApi2=clonedApi)?_clonedApi2:api,options||{},dirname)}}Object.assign(apiPolyfills,{targets:()=>()=>({}),assumption:()=>()=>{},addExternalDependency:()=>()=>{}});exports.declarePreset=declare;function copyApiObject(api){let proto=null;return "string"==typeof api.version&&/^7\./.test(api.version)&&(proto=Object.getPrototypeOf(api),!proto||hasOwnProperty.call(proto,"version")&&hasOwnProperty.call(proto,"transform")&&hasOwnProperty.call(proto,"template")&&hasOwnProperty.call(proto,"types")||(proto=null)),Object.assign({},proto,api)}},"./node_modules/.pnpm/@babel+helper-replace-supers@7.25.9_@babel+core@7.26.0/node_modules/@babel/helper-replace-supers/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=void 0;var _helperMemberExpressionToFunctions=__webpack_require__("./node_modules/.pnpm/@babel+helper-member-expression-to-functions@7.25.9/node_modules/@babel/helper-member-expression-to-functions/lib/index.js"),_helperOptimiseCallExpression=__webpack_require__("./node_modules/.pnpm/@babel+helper-optimise-call-expression@7.25.9/node_modules/@babel/helper-optimise-call-expression/lib/index.js"),_core=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/index.js"),_traverse=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/index.js");const{assignmentExpression,callExpression,cloneNode,identifier,memberExpression,sequenceExpression,stringLiteral,thisExpression}=_core.types;exports.environmentVisitor=_traverse.visitors.environmentVisitor({}),exports.skipAllButComputedKey=function(path){path.skip(),path.node.computed&&path.context.maybeQueue(path.get("key"));};const visitor=_traverse.visitors.environmentVisitor({Super(path,state){const{node,parentPath}=path;parentPath.isMemberExpression({object:node})&&state.handle(parentPath);}}),unshadowSuperBindingVisitor=_traverse.visitors.environmentVisitor({Scopable(path,{refName}){const binding=path.scope.getOwnBinding(refName);binding&&binding.identifier.name===refName&&path.scope.rename(refName);}}),specHandlers={memoise(superMember,count){const{scope,node}=superMember,{computed,property}=node;if(!computed)return;const memo=scope.maybeGenerateMemoised(property);memo&&this.memoiser.set(property,memo,count);},prop(superMember){const{computed,property}=superMember.node;return this.memoiser.has(property)?cloneNode(this.memoiser.get(property)):computed?cloneNode(property):stringLiteral(property.name)},_getPrototypeOfExpression(){const objectRef=cloneNode(this.getObjectRef()),targetRef=this.isStatic||this.isPrivateMethod?objectRef:memberExpression(objectRef,identifier("prototype"));return callExpression(this.file.addHelper("getPrototypeOf"),[targetRef])},get(superMember){const objectRef=cloneNode(this.getObjectRef());return callExpression(this.file.addHelper("superPropGet"),[this.isDerivedConstructor?sequenceExpression([thisExpression(),objectRef]):objectRef,this.prop(superMember),thisExpression(),...this.isStatic||this.isPrivateMethod?[]:[_core.types.numericLiteral(1)]])},_call(superMember,args,optional){const objectRef=cloneNode(this.getObjectRef());let argsNode;argsNode=1===args.length&&_core.types.isSpreadElement(args[0])&&(_core.types.isIdentifier(args[0].argument)||_core.types.isArrayExpression(args[0].argument))?args[0].argument:_core.types.arrayExpression(args);const call=_core.types.callExpression(this.file.addHelper("superPropGet"),[this.isDerivedConstructor?sequenceExpression([thisExpression(),objectRef]):objectRef,this.prop(superMember),thisExpression(),_core.types.numericLiteral(2|(this.isStatic||this.isPrivateMethod?0:1))]);return optional?_core.types.optionalCallExpression(call,[argsNode],true):callExpression(call,[argsNode])},set(superMember,value){const objectRef=cloneNode(this.getObjectRef());return callExpression(this.file.addHelper("superPropSet"),[this.isDerivedConstructor?sequenceExpression([thisExpression(),objectRef]):objectRef,this.prop(superMember),value,thisExpression(),_core.types.numericLiteral(superMember.isInStrictMode()?1:0),...this.isStatic||this.isPrivateMethod?[]:[_core.types.numericLiteral(1)]])},destructureSet(superMember){throw superMember.buildCodeFrameError("Destructuring to a super field is not supported yet.")},call(superMember,args){return this._call(superMember,args,false)},optionalCall(superMember,args){return this._call(superMember,args,true)},delete(superMember){return superMember.node.computed?sequenceExpression([callExpression(this.file.addHelper("toPropertyKey"),[cloneNode(superMember.node.property)]),_core.template.expression.ast`
          function () { throw new ReferenceError("'delete super[expr]' is invalid"); }()
        `]):_core.template.expression.ast`
        function () { throw new ReferenceError("'delete super.prop' is invalid"); }()
      `}},specHandlers_old={memoise(superMember,count){const{scope,node}=superMember,{computed,property}=node;if(!computed)return;const memo=scope.maybeGenerateMemoised(property);memo&&this.memoiser.set(property,memo,count);},prop(superMember){const{computed,property}=superMember.node;return this.memoiser.has(property)?cloneNode(this.memoiser.get(property)):computed?cloneNode(property):stringLiteral(property.name)},_getPrototypeOfExpression(){const objectRef=cloneNode(this.getObjectRef()),targetRef=this.isStatic||this.isPrivateMethod?objectRef:memberExpression(objectRef,identifier("prototype"));return callExpression(this.file.addHelper("getPrototypeOf"),[targetRef])},get(superMember){return this._get(superMember)},_get(superMember){const proto=this._getPrototypeOfExpression();return callExpression(this.file.addHelper("get"),[this.isDerivedConstructor?sequenceExpression([thisExpression(),proto]):proto,this.prop(superMember),thisExpression()])},set(superMember,value){const proto=this._getPrototypeOfExpression();return callExpression(this.file.addHelper("set"),[this.isDerivedConstructor?sequenceExpression([thisExpression(),proto]):proto,this.prop(superMember),value,thisExpression(),_core.types.booleanLiteral(superMember.isInStrictMode())])},destructureSet(superMember){throw superMember.buildCodeFrameError("Destructuring to a super field is not supported yet.")},call(superMember,args){return (0, _helperOptimiseCallExpression.default)(this._get(superMember),thisExpression(),args,false)},optionalCall(superMember,args){return (0, _helperOptimiseCallExpression.default)(this._get(superMember),cloneNode(thisExpression()),args,true)},delete(superMember){return superMember.node.computed?sequenceExpression([callExpression(this.file.addHelper("toPropertyKey"),[cloneNode(superMember.node.property)]),_core.template.expression.ast`
          function () { throw new ReferenceError("'delete super[expr]' is invalid"); }()
        `]):_core.template.expression.ast`
        function () { throw new ReferenceError("'delete super.prop' is invalid"); }()
      `}},looseHandlers=Object.assign({},specHandlers,{prop(superMember){const{property}=superMember.node;return this.memoiser.has(property)?cloneNode(this.memoiser.get(property)):cloneNode(property)},get(superMember){const{isStatic,getSuperRef}=this,{computed}=superMember.node,prop=this.prop(superMember);let object;var _getSuperRef,_getSuperRef2;isStatic?object=null!=(_getSuperRef=getSuperRef())?_getSuperRef:memberExpression(identifier("Function"),identifier("prototype")):object=memberExpression(null!=(_getSuperRef2=getSuperRef())?_getSuperRef2:identifier("Object"),identifier("prototype"));return memberExpression(object,prop,computed)},set(superMember,value){const{computed}=superMember.node,prop=this.prop(superMember);return assignmentExpression("=",memberExpression(thisExpression(),prop,computed),value)},destructureSet(superMember){const{computed}=superMember.node,prop=this.prop(superMember);return memberExpression(thisExpression(),prop,computed)},call(superMember,args){return (0, _helperOptimiseCallExpression.default)(this.get(superMember),thisExpression(),args,false)},optionalCall(superMember,args){return (0, _helperOptimiseCallExpression.default)(this.get(superMember),thisExpression(),args,true)}});exports.default=class{constructor(opts){var _opts$constantSuper;const path=opts.methodPath;this.methodPath=path,this.isDerivedConstructor=path.isClassMethod({kind:"constructor"})&&!!opts.superRef,this.isStatic=path.isObjectMethod()||path.node.static||(null==path.isStaticBlock?void 0:path.isStaticBlock()),this.isPrivateMethod=path.isPrivate()&&path.isMethod(),this.file=opts.file,this.constantSuper=null!=(_opts$constantSuper=opts.constantSuper)?_opts$constantSuper:opts.isLoose,this.opts=opts;}getObjectRef(){return cloneNode(this.opts.objectRef||this.opts.getObjectRef())}getSuperRef(){return this.opts.superRef?cloneNode(this.opts.superRef):this.opts.getSuperRef?cloneNode(this.opts.getSuperRef()):void 0}replace(){const{methodPath}=this;this.opts.refToPreserve&&methodPath.traverse(unshadowSuperBindingVisitor,{refName:this.opts.refToPreserve.name});const handler=this.constantSuper?looseHandlers:this.file.availableHelper("superPropSet")?specHandlers:specHandlers_old;visitor.shouldSkip=path=>{if(path.parentPath===methodPath&&("decorators"===path.parentKey||"key"===path.parentKey))return  true},(0, _helperMemberExpressionToFunctions.default)(methodPath,visitor,Object.assign({file:this.file,scope:this.methodPath.scope,isDerivedConstructor:this.isDerivedConstructor,isStatic:this.isStatic,isPrivateMethod:this.isPrivateMethod,getObjectRef:this.getObjectRef.bind(this),getSuperRef:this.getSuperRef.bind(this),boundGet:handler.get},handler));}};},"./node_modules/.pnpm/@babel+helper-simple-access@7.25.9/node_modules/@babel/helper-simple-access/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{exports.A=function(path,bindingNames){var _arguments$;path.traverse(simpleAssignmentVisitor,{scope:path.scope,bindingNames,seen:new WeakSet,includeUpdateExpression:null==(_arguments$=arguments[2])||_arguments$});};var _t=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js");const{LOGICAL_OPERATORS,assignmentExpression,binaryExpression,cloneNode,identifier,logicalExpression,numericLiteral,sequenceExpression,unaryExpression}=_t,simpleAssignmentVisitor={AssignmentExpression:{exit(path){const{scope,seen,bindingNames}=this;if("="===path.node.operator)return;if(seen.has(path.node))return;seen.add(path.node);const left=path.get("left");if(!left.isIdentifier())return;const localName=left.node.name;if(!bindingNames.has(localName))return;if(scope.getBinding(localName)!==path.scope.getBinding(localName))return;const operator=path.node.operator.slice(0,-1);LOGICAL_OPERATORS.includes(operator)?path.replaceWith(logicalExpression(operator,path.node.left,assignmentExpression("=",cloneNode(path.node.left),path.node.right))):(path.node.right=binaryExpression(operator,cloneNode(path.node.left),path.node.right),path.node.operator="=");}}};simpleAssignmentVisitor.UpdateExpression={exit(path){if(!this.includeUpdateExpression)return;const{scope,bindingNames}=this,arg=path.get("argument");if(!arg.isIdentifier())return;const localName=arg.node.name;if(bindingNames.has(localName)&&scope.getBinding(localName)===path.scope.getBinding(localName))if(path.parentPath.isExpressionStatement()&&!path.isCompletionRecord()){const operator="++"===path.node.operator?"+=":"-=";path.replaceWith(assignmentExpression(operator,arg.node,numericLiteral(1)));}else if(path.node.prefix)path.replaceWith(assignmentExpression("=",identifier(localName),binaryExpression(path.node.operator[0],unaryExpression("+",arg.node),numericLiteral(1))));else {const old=path.scope.generateUidIdentifierBasedOnNode(arg.node,"old"),varName=old.name;path.scope.push({id:old});const binary=binaryExpression(path.node.operator[0],identifier(varName),numericLiteral(1));path.replaceWith(sequenceExpression([assignmentExpression("=",identifier(varName),unaryExpression("+",arg.node)),assignmentExpression("=",cloneNode(arg.node),binary),identifier(varName)]));}}};},"./node_modules/.pnpm/@babel+helper-skip-transparent-expression-wrappers@7.25.9/node_modules/@babel/helper-skip-transparent-expression-wrappers/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.isTransparentExprWrapper=isTransparentExprWrapper,exports.skipTransparentExprWrapperNodes=function(node){for(;isTransparentExprWrapper(node);)node=node.expression;return node},exports.skipTransparentExprWrappers=function(path){for(;isTransparentExprWrapper(path.node);)path=path.get("expression");return path};var _t=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js");const{isParenthesizedExpression,isTSAsExpression,isTSNonNullExpression,isTSSatisfiesExpression,isTSTypeAssertion,isTypeCastExpression}=_t;function isTransparentExprWrapper(node){return isTSAsExpression(node)||isTSSatisfiesExpression(node)||isTSTypeAssertion(node)||isTSNonNullExpression(node)||isTypeCastExpression(node)||isParenthesizedExpression(node)}},"./node_modules/.pnpm/@babel+helper-string-parser@7.25.9/node_modules/@babel/helper-string-parser/lib/index.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.readCodePoint=readCodePoint,exports.readInt=readInt,exports.readStringContents=function(type,input,pos,lineStart,curLine,errors){const initialPos=pos,initialLineStart=lineStart,initialCurLine=curLine;let out="",firstInvalidLoc=null,chunkStart=pos;const{length}=input;for(;;){if(pos>=length){errors.unterminated(initialPos,initialLineStart,initialCurLine),out+=input.slice(chunkStart,pos);break}const ch=input.charCodeAt(pos);if(isStringEnd(type,ch,input,pos)){out+=input.slice(chunkStart,pos);break}if(92===ch){out+=input.slice(chunkStart,pos);const res=readEscapedChar(input,pos,lineStart,curLine,"template"===type,errors);null!==res.ch||firstInvalidLoc?out+=res.ch:firstInvalidLoc={pos,lineStart,curLine},({pos,lineStart,curLine}=res),chunkStart=pos;}else 8232===ch||8233===ch?(++curLine,lineStart=++pos):10===ch||13===ch?"template"===type?(out+=input.slice(chunkStart,pos)+"\n",++pos,13===ch&&10===input.charCodeAt(pos)&&++pos,++curLine,chunkStart=lineStart=pos):errors.unterminated(initialPos,initialLineStart,initialCurLine):++pos;}return {pos,str:out,firstInvalidLoc,lineStart,curLine,containsInvalid:!!firstInvalidLoc}};var _isDigit=function(code){return code>=48&&code<=57};const forbiddenNumericSeparatorSiblings={decBinOct:new Set([46,66,69,79,95,98,101,111]),hex:new Set([46,88,95,120])},isAllowedNumericSeparatorSibling={bin:ch=>48===ch||49===ch,oct:ch=>ch>=48&&ch<=55,dec:ch=>ch>=48&&ch<=57,hex:ch=>ch>=48&&ch<=57||ch>=65&&ch<=70||ch>=97&&ch<=102};function isStringEnd(type,ch,input,pos){return "template"===type?96===ch||36===ch&&123===input.charCodeAt(pos+1):ch===("double"===type?34:39)}function readEscapedChar(input,pos,lineStart,curLine,inTemplate,errors){const throwOnInvalid=!inTemplate;pos++;const res=ch=>({pos,ch,lineStart,curLine}),ch=input.charCodeAt(pos++);switch(ch){case 110:return res("\n");case 114:return res("\r");case 120:{let code;return ({code,pos}=readHexChar(input,pos,lineStart,curLine,2,false,throwOnInvalid,errors)),res(null===code?null:String.fromCharCode(code))}case 117:{let code;return ({code,pos}=readCodePoint(input,pos,lineStart,curLine,throwOnInvalid,errors)),res(null===code?null:String.fromCodePoint(code))}case 116:return res("\t");case 98:return res("\b");case 118:return res("\v");case 102:return res("\f");case 13:10===input.charCodeAt(pos)&&++pos;case 10:lineStart=pos,++curLine;case 8232:case 8233:return res("");case 56:case 57:if(inTemplate)return res(null);errors.strictNumericEscape(pos-1,lineStart,curLine);default:if(ch>=48&&ch<=55){const startPos=pos-1;let octalStr=/^[0-7]+/.exec(input.slice(startPos,pos+2))[0],octal=parseInt(octalStr,8);octal>255&&(octalStr=octalStr.slice(0,-1),octal=parseInt(octalStr,8)),pos+=octalStr.length-1;const next=input.charCodeAt(pos);if("0"!==octalStr||56===next||57===next){if(inTemplate)return res(null);errors.strictNumericEscape(startPos,lineStart,curLine);}return res(String.fromCharCode(octal))}return res(String.fromCharCode(ch))}}function readHexChar(input,pos,lineStart,curLine,len,forceLen,throwOnInvalid,errors){const initialPos=pos;let n;return ({n,pos}=readInt(input,pos,lineStart,curLine,16,len,forceLen,false,errors,!throwOnInvalid)),null===n&&(throwOnInvalid?errors.invalidEscapeSequence(initialPos,lineStart,curLine):pos=initialPos-1),{code:n,pos}}function readInt(input,pos,lineStart,curLine,radix,len,forceLen,allowNumSeparator,errors,bailOnError){const start=pos,forbiddenSiblings=16===radix?forbiddenNumericSeparatorSiblings.hex:forbiddenNumericSeparatorSiblings.decBinOct,isAllowedSibling=16===radix?isAllowedNumericSeparatorSibling.hex:10===radix?isAllowedNumericSeparatorSibling.dec:8===radix?isAllowedNumericSeparatorSibling.oct:isAllowedNumericSeparatorSibling.bin;let invalid=false,total=0;for(let i=0,e=null==len?1/0:len;i<e;++i){const code=input.charCodeAt(pos);let val;if(95!==code||"bail"===allowNumSeparator){if(val=code>=97?code-97+10:code>=65?code-65+10:_isDigit(code)?code-48:1/0,val>=radix){if(val<=9&&bailOnError)return {n:null,pos};if(val<=9&&errors.invalidDigit(pos,lineStart,curLine,radix))val=0;else {if(!forceLen)break;val=0,invalid=true;}}++pos,total=total*radix+val;}else {const prev=input.charCodeAt(pos-1),next=input.charCodeAt(pos+1);if(allowNumSeparator){if(Number.isNaN(next)||!isAllowedSibling(next)||forbiddenSiblings.has(prev)||forbiddenSiblings.has(next)){if(bailOnError)return {n:null,pos};errors.unexpectedNumericSeparator(pos,lineStart,curLine);}}else {if(bailOnError)return {n:null,pos};errors.numericSeparatorInEscapeSequence(pos,lineStart,curLine);}++pos;}}return pos===start||null!=len&&pos-start!==len||invalid?{n:null,pos}:{n:total,pos}}function readCodePoint(input,pos,lineStart,curLine,throwOnInvalid,errors){let code;if(123===input.charCodeAt(pos)){if(++pos,({code,pos}=readHexChar(input,pos,lineStart,curLine,input.indexOf("}",pos)-pos,true,throwOnInvalid,errors)),++pos,null!==code&&code>1114111){if(!throwOnInvalid)return {code:null,pos};errors.invalidCodePoint(pos,lineStart,curLine);}}else ({code,pos}=readHexChar(input,pos,lineStart,curLine,4,false,throwOnInvalid,errors));return {code,pos}}},"./node_modules/.pnpm/@babel+helper-validator-identifier@7.25.9/node_modules/@babel/helper-validator-identifier/lib/identifier.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.isIdentifierChar=isIdentifierChar,exports.isIdentifierName=function(name){let isFirst=true;for(let i=0;i<name.length;i++){let cp=name.charCodeAt(i);if(55296==(64512&cp)&&i+1<name.length){const trail=name.charCodeAt(++i);56320==(64512&trail)&&(cp=65536+((1023&cp)<<10)+(1023&trail));}if(isFirst){if(isFirst=false,!isIdentifierStart(cp))return  false}else if(!isIdentifierChar(cp))return  false}return !isFirst},exports.isIdentifierStart=isIdentifierStart;let nonASCIIidentifierStartChars="------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------",nonASCIIidentifierChars="-----------------------------------------------------------------------------------------------------------------------------------------------------";const nonASCIIidentifierStart=new RegExp("["+nonASCIIidentifierStartChars+"]"),nonASCIIidentifier=new RegExp("["+nonASCIIidentifierStartChars+nonASCIIidentifierChars+"]");nonASCIIidentifierStartChars=nonASCIIidentifierChars=null;const astralIdentifierStartCodes=[0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,13,10,2,14,2,6,2,1,2,10,2,14,2,6,2,1,4,51,13,310,10,21,11,7,25,5,2,41,2,8,70,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,39,27,10,22,251,41,7,1,17,2,60,28,11,0,9,21,43,17,47,20,28,22,13,52,58,1,3,0,14,44,33,24,27,35,30,0,3,0,9,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,20,1,64,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,31,9,2,0,3,0,2,37,2,0,26,0,2,0,45,52,19,3,21,2,31,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,38,6,186,43,117,63,32,7,3,0,3,7,2,1,2,23,16,0,2,0,95,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,19,72,200,32,32,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,16,0,2,12,2,33,125,0,80,921,103,110,18,195,2637,96,16,1071,18,5,26,3994,6,582,6842,29,1763,568,8,30,18,78,18,29,19,47,17,3,32,20,6,18,433,44,212,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,1237,42,9,8936,3,2,6,2,1,2,290,16,0,30,2,3,0,15,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,1845,30,7,5,262,61,147,44,11,6,17,0,322,29,19,43,485,27,229,29,3,0,496,6,2,3,2,1,2,14,2,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42719,33,4153,7,221,3,5761,15,7472,16,621,2467,541,1507,4938,6,4191],astralIdentifierCodes=[509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,7,9,32,4,318,1,80,3,71,10,50,3,123,2,54,14,32,10,3,1,11,3,46,10,8,0,46,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,2,11,83,11,7,0,3,0,158,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,68,8,2,0,3,0,2,3,2,4,2,0,15,1,83,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,7,19,58,14,5,9,243,14,166,9,71,5,2,1,3,3,2,0,2,1,13,9,120,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,343,9,54,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,10,1,2,0,49,6,4,4,14,10,5350,0,7,14,11465,27,2343,9,87,9,39,4,60,6,26,9,535,9,470,0,2,54,8,3,82,0,12,1,19628,1,4178,9,519,45,3,22,543,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,101,0,161,6,10,9,357,0,62,13,499,13,245,1,2,9,726,6,110,6,6,9,4759,9,787719,239];function isInAstralSet(code,set){let pos=65536;for(let i=0,length=set.length;i<length;i+=2){if(pos+=set[i],pos>code)return  false;if(pos+=set[i+1],pos>=code)return  true}return  false}function isIdentifierStart(code){return code<65?36===code:code<=90||(code<97?95===code:code<=122||(code<=65535?code>=170&&nonASCIIidentifierStart.test(String.fromCharCode(code)):isInAstralSet(code,astralIdentifierStartCodes)))}function isIdentifierChar(code){return code<48?36===code:code<58||!(code<65)&&(code<=90||(code<97?95===code:code<=122||(code<=65535?code>=170&&nonASCIIidentifier.test(String.fromCharCode(code)):isInAstralSet(code,astralIdentifierStartCodes)||isInAstralSet(code,astralIdentifierCodes))))}},"./node_modules/.pnpm/@babel+helper-validator-identifier@7.25.9/node_modules/@babel/helper-validator-identifier/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),Object.defineProperty(exports,"isIdentifierChar",{enumerable:true,get:function(){return _identifier.isIdentifierChar}}),Object.defineProperty(exports,"isIdentifierName",{enumerable:true,get:function(){return _identifier.isIdentifierName}}),Object.defineProperty(exports,"isIdentifierStart",{enumerable:true,get:function(){return _identifier.isIdentifierStart}}),Object.defineProperty(exports,"isKeyword",{enumerable:true,get:function(){return _keyword.isKeyword}}),Object.defineProperty(exports,"isReservedWord",{enumerable:true,get:function(){return _keyword.isReservedWord}}),Object.defineProperty(exports,"isStrictBindOnlyReservedWord",{enumerable:true,get:function(){return _keyword.isStrictBindOnlyReservedWord}}),Object.defineProperty(exports,"isStrictBindReservedWord",{enumerable:true,get:function(){return _keyword.isStrictBindReservedWord}}),Object.defineProperty(exports,"isStrictReservedWord",{enumerable:true,get:function(){return _keyword.isStrictReservedWord}});var _identifier=__webpack_require__("./node_modules/.pnpm/@babel+helper-validator-identifier@7.25.9/node_modules/@babel/helper-validator-identifier/lib/identifier.js"),_keyword=__webpack_require__("./node_modules/.pnpm/@babel+helper-validator-identifier@7.25.9/node_modules/@babel/helper-validator-identifier/lib/keyword.js");},"./node_modules/.pnpm/@babel+helper-validator-identifier@7.25.9/node_modules/@babel/helper-validator-identifier/lib/keyword.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.isKeyword=function(word){return keywords.has(word)},exports.isReservedWord=isReservedWord,exports.isStrictBindOnlyReservedWord=isStrictBindOnlyReservedWord,exports.isStrictBindReservedWord=function(word,inModule){return isStrictReservedWord(word,inModule)||isStrictBindOnlyReservedWord(word)},exports.isStrictReservedWord=isStrictReservedWord;const reservedWords_strict=["implements","interface","let","package","private","protected","public","static","yield"],reservedWords_strictBind=["eval","arguments"],keywords=new Set(["break","case","catch","continue","debugger","default","do","else","finally","for","function","if","return","switch","throw","try","var","const","while","with","new","this","super","class","extends","export","import","null","true","false","in","instanceof","typeof","void","delete"]),reservedWordsStrictSet=new Set(reservedWords_strict),reservedWordsStrictBindSet=new Set(reservedWords_strictBind);function isReservedWord(word,inModule){return inModule&&"await"===word||"enum"===word}function isStrictReservedWord(word,inModule){return isReservedWord(word,inModule)||reservedWordsStrictSet.has(word)}function isStrictBindOnlyReservedWord(word){return reservedWordsStrictBindSet.has(word)}},"./node_modules/.pnpm/@babel+helper-validator-option@7.25.9/node_modules/@babel/helper-validator-option/lib/find-suggestion.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.findSuggestion=function(str,arr){const distances=arr.map((el=>function(a,b){let i,j,t=[],u=[];const m=a.length,n=b.length;if(!m)return n;if(!n)return m;for(j=0;j<=n;j++)t[j]=j;for(i=1;i<=m;i++){for(u=[i],j=1;j<=n;j++)u[j]=a[i-1]===b[j-1]?t[j-1]:min(t[j-1],t[j],u[j-1])+1;t=u;}return u[n]}(el,str)));return arr[distances.indexOf(min(...distances))]};const{min}=Math;},"./node_modules/.pnpm/@babel+helper-validator-option@7.25.9/node_modules/@babel/helper-validator-option/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),Object.defineProperty(exports,"OptionValidator",{enumerable:true,get:function(){return _validator.OptionValidator}}),Object.defineProperty(exports,"findSuggestion",{enumerable:true,get:function(){return _findSuggestion.findSuggestion}});var _validator=__webpack_require__("./node_modules/.pnpm/@babel+helper-validator-option@7.25.9/node_modules/@babel/helper-validator-option/lib/validator.js"),_findSuggestion=__webpack_require__("./node_modules/.pnpm/@babel+helper-validator-option@7.25.9/node_modules/@babel/helper-validator-option/lib/find-suggestion.js");},"./node_modules/.pnpm/@babel+helper-validator-option@7.25.9/node_modules/@babel/helper-validator-option/lib/validator.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.OptionValidator=void 0;var _findSuggestion=__webpack_require__("./node_modules/.pnpm/@babel+helper-validator-option@7.25.9/node_modules/@babel/helper-validator-option/lib/find-suggestion.js");exports.OptionValidator=class{constructor(descriptor){this.descriptor=descriptor;}validateTopLevelOptions(options,TopLevelOptionShape){const validOptionNames=Object.keys(TopLevelOptionShape);for(const option of Object.keys(options))if(!validOptionNames.includes(option))throw new Error(this.formatMessage(`'${option}' is not a valid top-level option.\n- Did you mean '${(0, _findSuggestion.findSuggestion)(option,validOptionNames)}'?`))}validateBooleanOption(name,value,defaultValue){return void 0===value?defaultValue:(this.invariant("boolean"==typeof value,`'${name}' option must be a boolean.`),value)}validateStringOption(name,value,defaultValue){return void 0===value?defaultValue:(this.invariant("string"==typeof value,`'${name}' option must be a string.`),value)}invariant(condition,message){if(!condition)throw new Error(this.formatMessage(message))}formatMessage(message){return `${this.descriptor}: ${message}`}};},"./node_modules/.pnpm/@babel+helpers@7.26.0/node_modules/@babel/helpers/lib/helpers-generated.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=void 0;var _template=__webpack_require__("./node_modules/.pnpm/@babel+template@7.25.9/node_modules/@babel/template/lib/index.js");function helper(minVersion,source,metadata){return Object.freeze({minVersion,ast:()=>_template.default.program.ast(source,{preserveComments:true}),metadata})}const helpers=exports.default={__proto__:null,OverloadYield:helper("7.18.14","function _OverloadYield(e,d){this.v=e,this.k=d}",{globals:[],locals:{_OverloadYield:["body.0.id"]},exportBindingAssignments:[],exportName:"_OverloadYield",dependencies:{}}),applyDecoratedDescriptor:helper("7.0.0-beta.0",'function _applyDecoratedDescriptor(i,e,r,n,l){var a={};return Object.keys(n).forEach((function(i){a[i]=n[i]})),a.enumerable=!!a.enumerable,a.configurable=!!a.configurable,("value"in a||a.initializer)&&(a.writable=!0),a=r.slice().reverse().reduce((function(r,n){return n(i,e,r)||r}),a),l&&void 0!==a.initializer&&(a.value=a.initializer?a.initializer.call(l):void 0,a.initializer=void 0),void 0===a.initializer?(Object.defineProperty(i,e,a),null):a}',{globals:["Object"],locals:{_applyDecoratedDescriptor:["body.0.id"]},exportBindingAssignments:[],exportName:"_applyDecoratedDescriptor",dependencies:{}}),applyDecs2311:helper("7.24.0",'function applyDecs2311(e,t,n,r,o,i){var a,c,u,s,f,l,p,d=Symbol.metadata||Symbol.for("Symbol.metadata"),m=Object.defineProperty,h=Object.create,y=[h(null),h(null)],v=t.length;function g(t,n,r){return function(o,i){n&&(i=o,o=e);for(var a=0;a<t.length;a++)i=t[a].apply(o,r?[i]:[]);return r?i:o}}function b(e,t,n,r){if("function"!=typeof e&&(r||void 0!==e))throw new TypeError(t+" must "+(n||"be")+" a function"+(r?"":" or undefined"));return e}function applyDec(e,t,n,r,o,i,u,s,f,l,p){function d(e){if(!p(e))throw new TypeError("Attempted to access private element on non-instance")}var h=[].concat(t[0]),v=t[3],w=!u,D=1===o,S=3===o,j=4===o,E=2===o;function I(t,n,r){return function(o,i){return n&&(i=o,o=e),r&&r(o),P[t].call(o,i)}}if(!w){var P={},k=[],F=S?"get":j||D?"set":"value";if(f?(l||D?P={get:setFunctionName((function(){return v(this)}),r,"get"),set:function(e){t[4](this,e)}}:P[F]=v,l||setFunctionName(P[F],r,E?"":F)):l||(P=Object.getOwnPropertyDescriptor(e,r)),!l&&!f){if((c=y[+s][r])&&7!=(c^o))throw Error("Decorating two elements with the same name ("+P[F].name+") is not supported yet");y[+s][r]=o<3?1:o}}for(var N=e,O=h.length-1;O>=0;O-=n?2:1){var T=b(h[O],"A decorator","be",!0),z=n?h[O-1]:void 0,A={},H={kind:["field","accessor","method","getter","setter","class"][o],name:r,metadata:a,addInitializer:function(e,t){if(e.v)throw new TypeError("attempted to call addInitializer after decoration was finished");b(t,"An initializer","be",!0),i.push(t)}.bind(null,A)};if(w)c=T.call(z,N,H),A.v=1,b(c,"class decorators","return")&&(N=c);else if(H.static=s,H.private=f,c=H.access={has:f?p.bind():function(e){return r in e}},j||(c.get=f?E?function(e){return d(e),P.value}:I("get",0,d):function(e){return e[r]}),E||S||(c.set=f?I("set",0,d):function(e,t){e[r]=t}),N=T.call(z,D?{get:P.get,set:P.set}:P[F],H),A.v=1,D){if("object"==typeof N&&N)(c=b(N.get,"accessor.get"))&&(P.get=c),(c=b(N.set,"accessor.set"))&&(P.set=c),(c=b(N.init,"accessor.init"))&&k.unshift(c);else if(void 0!==N)throw new TypeError("accessor decorators must return an object with get, set, or init properties or undefined")}else b(N,(l?"field":"method")+" decorators","return")&&(l?k.unshift(N):P[F]=N)}return o<2&&u.push(g(k,s,1),g(i,s,0)),l||w||(f?D?u.splice(-1,0,I("get",s),I("set",s)):u.push(E?P[F]:b.call.bind(P[F])):m(e,r,P)),N}function w(e){return m(e,d,{configurable:!0,enumerable:!0,value:a})}return void 0!==i&&(a=i[d]),a=h(null==a?null:a),f=[],l=function(e){e&&f.push(g(e))},p=function(t,r){for(var i=0;i<n.length;i++){var a=n[i],c=a[1],l=7&c;if((8&c)==t&&!l==r){var p=a[2],d=!!a[3],m=16&c;applyDec(t?e:e.prototype,a,m,d?"#"+p:toPropertyKey(p),l,l<2?[]:t?s=s||[]:u=u||[],f,!!t,d,r,t&&d?function(t){return checkInRHS(t)===e}:o)}}},p(8,0),p(0,0),p(8,1),p(0,1),l(u),l(s),c=f,v||w(e),{e:c,get c(){var n=[];return v&&[w(e=applyDec(e,[t],r,e.name,5,n)),g(n,1)]}}}',{globals:["Symbol","Object","TypeError","Error"],locals:{applyDecs2311:["body.0.id"]},exportBindingAssignments:[],exportName:"applyDecs2311",dependencies:{checkInRHS:["body.0.body.body.5.argument.expressions.4.right.body.body.0.body.body.1.consequent.body.1.expression.arguments.10.consequent.body.body.0.argument.left.callee"],setFunctionName:["body.0.body.body.3.body.body.3.consequent.body.1.test.expressions.0.consequent.expressions.0.consequent.right.properties.0.value.callee","body.0.body.body.3.body.body.3.consequent.body.1.test.expressions.0.consequent.expressions.1.right.callee"],toPropertyKey:["body.0.body.body.5.argument.expressions.4.right.body.body.0.body.body.1.consequent.body.1.expression.arguments.3.alternate.callee"]}}),arrayLikeToArray:helper("7.9.0","function _arrayLikeToArray(r,a){(null==a||a>r.length)&&(a=r.length);for(var e=0,n=Array(a);e<a;e++)n[e]=r[e];return n}",{globals:["Array"],locals:{_arrayLikeToArray:["body.0.id"]},exportBindingAssignments:[],exportName:"_arrayLikeToArray",dependencies:{}}),arrayWithHoles:helper("7.0.0-beta.0","function _arrayWithHoles(r){if(Array.isArray(r))return r}",{globals:["Array"],locals:{_arrayWithHoles:["body.0.id"]},exportBindingAssignments:[],exportName:"_arrayWithHoles",dependencies:{}}),arrayWithoutHoles:helper("7.0.0-beta.0","function _arrayWithoutHoles(r){if(Array.isArray(r))return arrayLikeToArray(r)}",{globals:["Array"],locals:{_arrayWithoutHoles:["body.0.id"]},exportBindingAssignments:[],exportName:"_arrayWithoutHoles",dependencies:{arrayLikeToArray:["body.0.body.body.0.consequent.argument.callee"]}}),assertClassBrand:helper("7.24.0",'function _assertClassBrand(e,t,n){if("function"==typeof e?e===t:e.has(t))return arguments.length<3?t:n;throw new TypeError("Private element is not present on this object")}',{globals:["TypeError"],locals:{_assertClassBrand:["body.0.id"]},exportBindingAssignments:[],exportName:"_assertClassBrand",dependencies:{}}),assertThisInitialized:helper("7.0.0-beta.0","function _assertThisInitialized(e){if(void 0===e)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return e}",{globals:["ReferenceError"],locals:{_assertThisInitialized:["body.0.id"]},exportBindingAssignments:[],exportName:"_assertThisInitialized",dependencies:{}}),asyncGeneratorDelegate:helper("7.0.0-beta.0",'function _asyncGeneratorDelegate(t){var e={},n=!1;function pump(e,r){return n=!0,r=new Promise((function(n){n(t[e](r))})),{done:!1,value:new OverloadYield(r,1)}}return e["undefined"!=typeof Symbol&&Symbol.iterator||"@@iterator"]=function(){return this},e.next=function(t){return n?(n=!1,t):pump("next",t)},"function"==typeof t.throw&&(e.throw=function(t){if(n)throw n=!1,t;return pump("throw",t)}),"function"==typeof t.return&&(e.return=function(t){return n?(n=!1,t):pump("return",t)}),e}',{globals:["Promise","Symbol"],locals:{_asyncGeneratorDelegate:["body.0.id"]},exportBindingAssignments:[],exportName:"_asyncGeneratorDelegate",dependencies:{OverloadYield:["body.0.body.body.1.body.body.0.argument.expressions.2.properties.1.value.callee"]}}),asyncIterator:helper("7.15.9",'function _asyncIterator(r){var n,t,o,e=2;for("undefined"!=typeof Symbol&&(t=Symbol.asyncIterator,o=Symbol.iterator);e--;){if(t&&null!=(n=r[t]))return n.call(r);if(o&&null!=(n=r[o]))return new AsyncFromSyncIterator(n.call(r));t="@@asyncIterator",o="@@iterator"}throw new TypeError("Object is not async iterable")}function AsyncFromSyncIterator(r){function AsyncFromSyncIteratorContinuation(r){if(Object(r)!==r)return Promise.reject(new TypeError(r+" is not an object."));var n=r.done;return Promise.resolve(r.value).then((function(r){return{value:r,done:n}}))}return AsyncFromSyncIterator=function(r){this.s=r,this.n=r.next},AsyncFromSyncIterator.prototype={s:null,n:null,next:function(){return AsyncFromSyncIteratorContinuation(this.n.apply(this.s,arguments))},return:function(r){var n=this.s.return;return void 0===n?Promise.resolve({value:r,done:!0}):AsyncFromSyncIteratorContinuation(n.apply(this.s,arguments))},throw:function(r){var n=this.s.return;return void 0===n?Promise.reject(r):AsyncFromSyncIteratorContinuation(n.apply(this.s,arguments))}},new AsyncFromSyncIterator(r)}',{globals:["Symbol","TypeError","Object","Promise"],locals:{_asyncIterator:["body.0.id"],AsyncFromSyncIterator:["body.1.id","body.0.body.body.1.body.body.1.consequent.argument.callee","body.1.body.body.1.argument.expressions.1.left.object","body.1.body.body.1.argument.expressions.2.callee","body.1.body.body.1.argument.expressions.0.left"]},exportBindingAssignments:[],exportName:"_asyncIterator",dependencies:{}}),asyncToGenerator:helper("7.0.0-beta.0",'function asyncGeneratorStep(n,t,e,r,o,a,c){try{var i=n[a](c),u=i.value}catch(n){return void e(n)}i.done?t(u):Promise.resolve(u).then(r,o)}function _asyncToGenerator(n){return function(){var t=this,e=arguments;return new Promise((function(r,o){var a=n.apply(t,e);function _next(n){asyncGeneratorStep(a,r,o,_next,_throw,"next",n)}function _throw(n){asyncGeneratorStep(a,r,o,_next,_throw,"throw",n)}_next(void 0)}))}}',{globals:["Promise"],locals:{asyncGeneratorStep:["body.0.id","body.1.body.body.0.argument.body.body.1.argument.arguments.0.body.body.1.body.body.0.expression.callee","body.1.body.body.0.argument.body.body.1.argument.arguments.0.body.body.2.body.body.0.expression.callee"],_asyncToGenerator:["body.1.id"]},exportBindingAssignments:[],exportName:"_asyncToGenerator",dependencies:{}}),awaitAsyncGenerator:helper("7.0.0-beta.0","function _awaitAsyncGenerator(e){return new OverloadYield(e,0)}",{globals:[],locals:{_awaitAsyncGenerator:["body.0.id"]},exportBindingAssignments:[],exportName:"_awaitAsyncGenerator",dependencies:{OverloadYield:["body.0.body.body.0.argument.callee"]}}),callSuper:helper("7.23.8","function _callSuper(t,o,e){return o=getPrototypeOf(o),possibleConstructorReturn(t,isNativeReflectConstruct()?Reflect.construct(o,e||[],getPrototypeOf(t).constructor):o.apply(t,e))}",{globals:["Reflect"],locals:{_callSuper:["body.0.id"]},exportBindingAssignments:[],exportName:"_callSuper",dependencies:{getPrototypeOf:["body.0.body.body.0.argument.expressions.0.right.callee","body.0.body.body.0.argument.expressions.1.arguments.1.consequent.arguments.2.object.callee"],isNativeReflectConstruct:["body.0.body.body.0.argument.expressions.1.arguments.1.test.callee"],possibleConstructorReturn:["body.0.body.body.0.argument.expressions.1.callee"]}}),checkInRHS:helper("7.20.5",'function _checkInRHS(e){if(Object(e)!==e)throw TypeError("right-hand side of \'in\' should be an object, got "+(null!==e?typeof e:"null"));return e}',{globals:["Object","TypeError"],locals:{_checkInRHS:["body.0.id"]},exportBindingAssignments:[],exportName:"_checkInRHS",dependencies:{}}),checkPrivateRedeclaration:helper("7.14.1",'function _checkPrivateRedeclaration(e,t){if(t.has(e))throw new TypeError("Cannot initialize the same private elements twice on an object")}',{globals:["TypeError"],locals:{_checkPrivateRedeclaration:["body.0.id"]},exportBindingAssignments:[],exportName:"_checkPrivateRedeclaration",dependencies:{}}),classCallCheck:helper("7.0.0-beta.0",'function _classCallCheck(a,n){if(!(a instanceof n))throw new TypeError("Cannot call a class as a function")}',{globals:["TypeError"],locals:{_classCallCheck:["body.0.id"]},exportBindingAssignments:[],exportName:"_classCallCheck",dependencies:{}}),classNameTDZError:helper("7.0.0-beta.0","function _classNameTDZError(e){throw new ReferenceError('Class \"'+e+'\" cannot be referenced in computed property keys.')}",{globals:["ReferenceError"],locals:{_classNameTDZError:["body.0.id"]},exportBindingAssignments:[],exportName:"_classNameTDZError",dependencies:{}}),classPrivateFieldGet2:helper("7.24.0","function _classPrivateFieldGet2(s,a){return s.get(assertClassBrand(s,a))}",{globals:[],locals:{_classPrivateFieldGet2:["body.0.id"]},exportBindingAssignments:[],exportName:"_classPrivateFieldGet2",dependencies:{assertClassBrand:["body.0.body.body.0.argument.arguments.0.callee"]}}),classPrivateFieldInitSpec:helper("7.14.1","function _classPrivateFieldInitSpec(e,t,a){checkPrivateRedeclaration(e,t),t.set(e,a)}",{globals:[],locals:{_classPrivateFieldInitSpec:["body.0.id"]},exportBindingAssignments:[],exportName:"_classPrivateFieldInitSpec",dependencies:{checkPrivateRedeclaration:["body.0.body.body.0.expression.expressions.0.callee"]}}),classPrivateFieldLooseBase:helper("7.0.0-beta.0",'function _classPrivateFieldBase(e,t){if(!{}.hasOwnProperty.call(e,t))throw new TypeError("attempted to use private field on non-instance");return e}',{globals:["TypeError"],locals:{_classPrivateFieldBase:["body.0.id"]},exportBindingAssignments:[],exportName:"_classPrivateFieldBase",dependencies:{}}),classPrivateFieldLooseKey:helper("7.0.0-beta.0",'var id=0;function _classPrivateFieldKey(e){return"__private_"+id+++"_"+e}',{globals:[],locals:{id:["body.0.declarations.0.id","body.1.body.body.0.argument.left.left.right.argument","body.1.body.body.0.argument.left.left.right.argument"],_classPrivateFieldKey:["body.1.id"]},exportBindingAssignments:[],exportName:"_classPrivateFieldKey",dependencies:{}}),classPrivateFieldSet2:helper("7.24.0","function _classPrivateFieldSet2(s,a,r){return s.set(assertClassBrand(s,a),r),r}",{globals:[],locals:{_classPrivateFieldSet2:["body.0.id"]},exportBindingAssignments:[],exportName:"_classPrivateFieldSet2",dependencies:{assertClassBrand:["body.0.body.body.0.argument.expressions.0.arguments.0.callee"]}}),classPrivateGetter:helper("7.24.0","function _classPrivateGetter(s,r,a){return a(assertClassBrand(s,r))}",{globals:[],locals:{_classPrivateGetter:["body.0.id"]},exportBindingAssignments:[],exportName:"_classPrivateGetter",dependencies:{assertClassBrand:["body.0.body.body.0.argument.arguments.0.callee"]}}),classPrivateMethodInitSpec:helper("7.14.1","function _classPrivateMethodInitSpec(e,a){checkPrivateRedeclaration(e,a),a.add(e)}",{globals:[],locals:{_classPrivateMethodInitSpec:["body.0.id"]},exportBindingAssignments:[],exportName:"_classPrivateMethodInitSpec",dependencies:{checkPrivateRedeclaration:["body.0.body.body.0.expression.expressions.0.callee"]}}),classPrivateSetter:helper("7.24.0","function _classPrivateSetter(s,r,a,t){return r(assertClassBrand(s,a),t),t}",{globals:[],locals:{_classPrivateSetter:["body.0.id"]},exportBindingAssignments:[],exportName:"_classPrivateSetter",dependencies:{assertClassBrand:["body.0.body.body.0.argument.expressions.0.arguments.0.callee"]}}),classStaticPrivateMethodGet:helper("7.3.2","function _classStaticPrivateMethodGet(s,a,t){return assertClassBrand(a,s),t}",{globals:[],locals:{_classStaticPrivateMethodGet:["body.0.id"]},exportBindingAssignments:[],exportName:"_classStaticPrivateMethodGet",dependencies:{assertClassBrand:["body.0.body.body.0.argument.expressions.0.callee"]}}),construct:helper("7.0.0-beta.0","function _construct(t,e,r){if(isNativeReflectConstruct())return Reflect.construct.apply(null,arguments);var o=[null];o.push.apply(o,e);var p=new(t.bind.apply(t,o));return r&&setPrototypeOf(p,r.prototype),p}",{globals:["Reflect"],locals:{_construct:["body.0.id"]},exportBindingAssignments:[],exportName:"_construct",dependencies:{isNativeReflectConstruct:["body.0.body.body.0.test.callee"],setPrototypeOf:["body.0.body.body.4.argument.expressions.0.right.callee"]}}),createClass:helper("7.0.0-beta.0",'function _defineProperties(e,r){for(var t=0;t<r.length;t++){var o=r[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,toPropertyKey(o.key),o)}}function _createClass(e,r,t){return r&&_defineProperties(e.prototype,r),t&&_defineProperties(e,t),Object.defineProperty(e,"prototype",{writable:!1}),e}',{globals:["Object"],locals:{_defineProperties:["body.0.id","body.1.body.body.0.argument.expressions.0.right.callee","body.1.body.body.0.argument.expressions.1.right.callee"],_createClass:["body.1.id"]},exportBindingAssignments:[],exportName:"_createClass",dependencies:{toPropertyKey:["body.0.body.body.0.body.body.1.expression.expressions.3.arguments.1.callee"]}}),createForOfIteratorHelper:helper("7.9.0",'function _createForOfIteratorHelper(r,e){var t="undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(!t){if(Array.isArray(r)||(t=unsupportedIterableToArray(r))||e&&r&&"number"==typeof r.length){t&&(r=t);var n=0,F=function(){};return{s:F,n:function(){return n>=r.length?{done:!0}:{done:!1,value:r[n++]}},e:function(r){throw r},f:F}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var o,a=!0,u=!1;return{s:function(){t=t.call(r)},n:function(){var r=t.next();return a=r.done,r},e:function(r){u=!0,o=r},f:function(){try{a||null==t.return||t.return()}finally{if(u)throw o}}}}',{globals:["Symbol","Array","TypeError"],locals:{_createForOfIteratorHelper:["body.0.id"]},exportBindingAssignments:[],exportName:"_createForOfIteratorHelper",dependencies:{unsupportedIterableToArray:["body.0.body.body.1.consequent.body.0.test.left.right.right.callee"]}}),createForOfIteratorHelperLoose:helper("7.9.0",'function _createForOfIteratorHelperLoose(r,e){var t="undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(t)return(t=t.call(r)).next.bind(t);if(Array.isArray(r)||(t=unsupportedIterableToArray(r))||e&&r&&"number"==typeof r.length){t&&(r=t);var o=0;return function(){return o>=r.length?{done:!0}:{done:!1,value:r[o++]}}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}',{globals:["Symbol","Array","TypeError"],locals:{_createForOfIteratorHelperLoose:["body.0.id"]},exportBindingAssignments:[],exportName:"_createForOfIteratorHelperLoose",dependencies:{unsupportedIterableToArray:["body.0.body.body.2.test.left.right.right.callee"]}}),createSuper:helper("7.9.0","function _createSuper(t){var r=isNativeReflectConstruct();return function(){var e,o=getPrototypeOf(t);if(r){var s=getPrototypeOf(this).constructor;e=Reflect.construct(o,arguments,s)}else e=o.apply(this,arguments);return possibleConstructorReturn(this,e)}}",{globals:["Reflect"],locals:{_createSuper:["body.0.id"]},exportBindingAssignments:[],exportName:"_createSuper",dependencies:{getPrototypeOf:["body.0.body.body.1.argument.body.body.0.declarations.1.init.callee","body.0.body.body.1.argument.body.body.1.consequent.body.0.declarations.0.init.object.callee"],isNativeReflectConstruct:["body.0.body.body.0.declarations.0.init.callee"],possibleConstructorReturn:["body.0.body.body.1.argument.body.body.2.argument.callee"]}}),decorate:helper("7.1.5",'function _decorate(e,r,t,i){var o=_getDecoratorsApi();if(i)for(var n=0;n<i.length;n++)o=i[n](o);var s=r((function(e){o.initializeInstanceElements(e,a.elements)}),t),a=o.decorateClass(_coalesceClassElements(s.d.map(_createElementDescriptor)),e);return o.initializeClassElements(s.F,a.elements),o.runClassFinishers(s.F,a.finishers)}function _getDecoratorsApi(){_getDecoratorsApi=function(){return e};var e={elementsDefinitionOrder:[["method"],["field"]],initializeInstanceElements:function(e,r){["method","field"].forEach((function(t){r.forEach((function(r){r.kind===t&&"own"===r.placement&&this.defineClassElement(e,r)}),this)}),this)},initializeClassElements:function(e,r){var t=e.prototype;["method","field"].forEach((function(i){r.forEach((function(r){var o=r.placement;if(r.kind===i&&("static"===o||"prototype"===o)){var n="static"===o?e:t;this.defineClassElement(n,r)}}),this)}),this)},defineClassElement:function(e,r){var t=r.descriptor;if("field"===r.kind){var i=r.initializer;t={enumerable:t.enumerable,writable:t.writable,configurable:t.configurable,value:void 0===i?void 0:i.call(e)}}Object.defineProperty(e,r.key,t)},decorateClass:function(e,r){var t=[],i=[],o={static:[],prototype:[],own:[]};if(e.forEach((function(e){this.addElementPlacement(e,o)}),this),e.forEach((function(e){if(!_hasDecorators(e))return t.push(e);var r=this.decorateElement(e,o);t.push(r.element),t.push.apply(t,r.extras),i.push.apply(i,r.finishers)}),this),!r)return{elements:t,finishers:i};var n=this.decorateConstructor(t,r);return i.push.apply(i,n.finishers),n.finishers=i,n},addElementPlacement:function(e,r,t){var i=r[e.placement];if(!t&&-1!==i.indexOf(e.key))throw new TypeError("Duplicated element ("+e.key+")");i.push(e.key)},decorateElement:function(e,r){for(var t=[],i=[],o=e.decorators,n=o.length-1;n>=0;n--){var s=r[e.placement];s.splice(s.indexOf(e.key),1);var a=this.fromElementDescriptor(e),l=this.toElementFinisherExtras((0,o[n])(a)||a);e=l.element,this.addElementPlacement(e,r),l.finisher&&i.push(l.finisher);var c=l.extras;if(c){for(var p=0;p<c.length;p++)this.addElementPlacement(c[p],r);t.push.apply(t,c)}}return{element:e,finishers:i,extras:t}},decorateConstructor:function(e,r){for(var t=[],i=r.length-1;i>=0;i--){var o=this.fromClassDescriptor(e),n=this.toClassDescriptor((0,r[i])(o)||o);if(void 0!==n.finisher&&t.push(n.finisher),void 0!==n.elements){e=n.elements;for(var s=0;s<e.length-1;s++)for(var a=s+1;a<e.length;a++)if(e[s].key===e[a].key&&e[s].placement===e[a].placement)throw new TypeError("Duplicated element ("+e[s].key+")")}}return{elements:e,finishers:t}},fromElementDescriptor:function(e){var r={kind:e.kind,key:e.key,placement:e.placement,descriptor:e.descriptor};return Object.defineProperty(r,Symbol.toStringTag,{value:"Descriptor",configurable:!0}),"field"===e.kind&&(r.initializer=e.initializer),r},toElementDescriptors:function(e){if(void 0!==e)return toArray(e).map((function(e){var r=this.toElementDescriptor(e);return this.disallowProperty(e,"finisher","An element descriptor"),this.disallowProperty(e,"extras","An element descriptor"),r}),this)},toElementDescriptor:function(e){var r=e.kind+"";if("method"!==r&&"field"!==r)throw new TypeError(\'An element descriptor\\\'s .kind property must be either "method" or "field", but a decorator created an element descriptor with .kind "\'+r+\'"\');var t=toPropertyKey(e.key),i=e.placement+"";if("static"!==i&&"prototype"!==i&&"own"!==i)throw new TypeError(\'An element descriptor\\\'s .placement property must be one of "static", "prototype" or "own", but a decorator created an element descriptor with .placement "\'+i+\'"\');var o=e.descriptor;this.disallowProperty(e,"elements","An element descriptor");var n={kind:r,key:t,placement:i,descriptor:Object.assign({},o)};return"field"!==r?this.disallowProperty(e,"initializer","A method descriptor"):(this.disallowProperty(o,"get","The property descriptor of a field descriptor"),this.disallowProperty(o,"set","The property descriptor of a field descriptor"),this.disallowProperty(o,"value","The property descriptor of a field descriptor"),n.initializer=e.initializer),n},toElementFinisherExtras:function(e){return{element:this.toElementDescriptor(e),finisher:_optionalCallableProperty(e,"finisher"),extras:this.toElementDescriptors(e.extras)}},fromClassDescriptor:function(e){var r={kind:"class",elements:e.map(this.fromElementDescriptor,this)};return Object.defineProperty(r,Symbol.toStringTag,{value:"Descriptor",configurable:!0}),r},toClassDescriptor:function(e){var r=e.kind+"";if("class"!==r)throw new TypeError(\'A class descriptor\\\'s .kind property must be "class", but a decorator created a class descriptor with .kind "\'+r+\'"\');this.disallowProperty(e,"key","A class descriptor"),this.disallowProperty(e,"placement","A class descriptor"),this.disallowProperty(e,"descriptor","A class descriptor"),this.disallowProperty(e,"initializer","A class descriptor"),this.disallowProperty(e,"extras","A class descriptor");var t=_optionalCallableProperty(e,"finisher");return{elements:this.toElementDescriptors(e.elements),finisher:t}},runClassFinishers:function(e,r){for(var t=0;t<r.length;t++){var i=(0,r[t])(e);if(void 0!==i){if("function"!=typeof i)throw new TypeError("Finishers must return a constructor.");e=i}}return e},disallowProperty:function(e,r,t){if(void 0!==e[r])throw new TypeError(t+" can\'t have a ."+r+" property.")}};return e}function _createElementDescriptor(e){var r,t=toPropertyKey(e.key);"method"===e.kind?r={value:e.value,writable:!0,configurable:!0,enumerable:!1}:"get"===e.kind?r={get:e.value,configurable:!0,enumerable:!1}:"set"===e.kind?r={set:e.value,configurable:!0,enumerable:!1}:"field"===e.kind&&(r={configurable:!0,writable:!0,enumerable:!0});var i={kind:"field"===e.kind?"field":"method",key:t,placement:e.static?"static":"field"===e.kind?"own":"prototype",descriptor:r};return e.decorators&&(i.decorators=e.decorators),"field"===e.kind&&(i.initializer=e.value),i}function _coalesceGetterSetter(e,r){void 0!==e.descriptor.get?r.descriptor.get=e.descriptor.get:r.descriptor.set=e.descriptor.set}function _coalesceClassElements(e){for(var r=[],isSameElement=function(e){return"method"===e.kind&&e.key===o.key&&e.placement===o.placement},t=0;t<e.length;t++){var i,o=e[t];if("method"===o.kind&&(i=r.find(isSameElement)))if(_isDataDescriptor(o.descriptor)||_isDataDescriptor(i.descriptor)){if(_hasDecorators(o)||_hasDecorators(i))throw new ReferenceError("Duplicated methods ("+o.key+") can\'t be decorated.");i.descriptor=o.descriptor}else{if(_hasDecorators(o)){if(_hasDecorators(i))throw new ReferenceError("Decorators can\'t be placed on different accessors with for the same property ("+o.key+").");i.decorators=o.decorators}_coalesceGetterSetter(o,i)}else r.push(o)}return r}function _hasDecorators(e){return e.decorators&&e.decorators.length}function _isDataDescriptor(e){return void 0!==e&&!(void 0===e.value&&void 0===e.writable)}function _optionalCallableProperty(e,r){var t=e[r];if(void 0!==t&&"function"!=typeof t)throw new TypeError("Expected \'"+r+"\' to be a function");return t}',{globals:["Object","TypeError","Symbol","ReferenceError"],locals:{_decorate:["body.0.id"],_getDecoratorsApi:["body.1.id","body.0.body.body.0.declarations.0.init.callee","body.1.body.body.0.expression.left"],_createElementDescriptor:["body.2.id","body.0.body.body.2.declarations.1.init.arguments.0.arguments.0.arguments.0"],_coalesceGetterSetter:["body.3.id","body.4.body.body.0.body.body.1.consequent.alternate.body.1.expression.callee"],_coalesceClassElements:["body.4.id","body.0.body.body.2.declarations.1.init.arguments.0.callee"],_hasDecorators:["body.5.id","body.1.body.body.1.declarations.0.init.properties.4.value.body.body.1.test.expressions.1.arguments.0.body.body.0.test.argument.callee","body.4.body.body.0.body.body.1.consequent.consequent.body.0.test.left.callee","body.4.body.body.0.body.body.1.consequent.consequent.body.0.test.right.callee","body.4.body.body.0.body.body.1.consequent.alternate.body.0.test.callee","body.4.body.body.0.body.body.1.consequent.alternate.body.0.consequent.body.0.test.callee"],_isDataDescriptor:["body.6.id","body.4.body.body.0.body.body.1.consequent.test.left.callee","body.4.body.body.0.body.body.1.consequent.test.right.callee"],_optionalCallableProperty:["body.7.id","body.1.body.body.1.declarations.0.init.properties.11.value.body.body.0.argument.properties.1.value.callee","body.1.body.body.1.declarations.0.init.properties.13.value.body.body.3.declarations.0.init.callee"]},exportBindingAssignments:[],exportName:"_decorate",dependencies:{toArray:["body.1.body.body.1.declarations.0.init.properties.9.value.body.body.0.consequent.argument.callee.object.callee"],toPropertyKey:["body.1.body.body.1.declarations.0.init.properties.10.value.body.body.2.declarations.0.init.callee","body.2.body.body.0.declarations.1.init.callee"]}}),defaults:helper("7.0.0-beta.0","function _defaults(e,r){for(var t=Object.getOwnPropertyNames(r),o=0;o<t.length;o++){var n=t[o],a=Object.getOwnPropertyDescriptor(r,n);a&&a.configurable&&void 0===e[n]&&Object.defineProperty(e,n,a)}return e}",{globals:["Object"],locals:{_defaults:["body.0.id"]},exportBindingAssignments:[],exportName:"_defaults",dependencies:{}}),defineAccessor:helper("7.20.7","function _defineAccessor(e,r,n,t){var c={configurable:!0,enumerable:!0};return c[e]=t,Object.defineProperty(r,n,c)}",{globals:["Object"],locals:{_defineAccessor:["body.0.id"]},exportBindingAssignments:[],exportName:"_defineAccessor",dependencies:{}}),defineProperty:helper("7.0.0-beta.0","function _defineProperty(e,r,t){return(r=toPropertyKey(r))in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}",{globals:["Object"],locals:{_defineProperty:["body.0.id"]},exportBindingAssignments:[],exportName:"_defineProperty",dependencies:{toPropertyKey:["body.0.body.body.0.argument.expressions.0.test.left.right.callee"]}}),extends:helper("7.0.0-beta.0","function _extends(){return _extends=Object.assign?Object.assign.bind():function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var r in t)({}).hasOwnProperty.call(t,r)&&(n[r]=t[r])}return n},_extends.apply(null,arguments)}",{globals:["Object"],locals:{_extends:["body.0.id","body.0.body.body.0.argument.expressions.1.callee.object","body.0.body.body.0.argument.expressions.0.left"]},exportBindingAssignments:["body.0.body.body.0.argument.expressions.0"],exportName:"_extends",dependencies:{}}),get:helper("7.0.0-beta.0",'function _get(){return _get="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(e,t,r){var p=superPropBase(e,t);if(p){var n=Object.getOwnPropertyDescriptor(p,t);return n.get?n.get.call(arguments.length<3?e:r):n.value}},_get.apply(null,arguments)}',{globals:["Reflect","Object"],locals:{_get:["body.0.id","body.0.body.body.0.argument.expressions.1.callee.object","body.0.body.body.0.argument.expressions.0.left"]},exportBindingAssignments:["body.0.body.body.0.argument.expressions.0"],exportName:"_get",dependencies:{superPropBase:["body.0.body.body.0.argument.expressions.0.right.alternate.body.body.0.declarations.0.init.callee"]}}),getPrototypeOf:helper("7.0.0-beta.0","function _getPrototypeOf(t){return _getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},_getPrototypeOf(t)}",{globals:["Object"],locals:{_getPrototypeOf:["body.0.id","body.0.body.body.0.argument.expressions.1.callee","body.0.body.body.0.argument.expressions.0.left"]},exportBindingAssignments:["body.0.body.body.0.argument.expressions.0"],exportName:"_getPrototypeOf",dependencies:{}}),identity:helper("7.17.0","function _identity(t){return t}",{globals:[],locals:{_identity:["body.0.id"]},exportBindingAssignments:[],exportName:"_identity",dependencies:{}}),importDeferProxy:helper("7.23.0","function _importDeferProxy(e){var t=null,constValue=function(e){return function(){return e}},proxy=function(r){return function(n,o,f){return null===t&&(t=e()),r(t,o,f)}};return new Proxy({},{defineProperty:constValue(!1),deleteProperty:constValue(!1),get:proxy(Reflect.get),getOwnPropertyDescriptor:proxy(Reflect.getOwnPropertyDescriptor),getPrototypeOf:constValue(null),isExtensible:constValue(!1),has:proxy(Reflect.has),ownKeys:proxy(Reflect.ownKeys),preventExtensions:constValue(!0),set:constValue(!1),setPrototypeOf:constValue(!1)})}",{globals:["Proxy","Reflect"],locals:{_importDeferProxy:["body.0.id"]},exportBindingAssignments:[],exportName:"_importDeferProxy",dependencies:{}}),inherits:helper("7.0.0-beta.0",'function _inherits(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&setPrototypeOf(t,e)}',{globals:["TypeError","Object"],locals:{_inherits:["body.0.id"]},exportBindingAssignments:[],exportName:"_inherits",dependencies:{setPrototypeOf:["body.0.body.body.1.expression.expressions.2.right.callee"]}}),inheritsLoose:helper("7.0.0-beta.0","function _inheritsLoose(t,o){t.prototype=Object.create(o.prototype),t.prototype.constructor=t,setPrototypeOf(t,o)}",{globals:["Object"],locals:{_inheritsLoose:["body.0.id"]},exportBindingAssignments:[],exportName:"_inheritsLoose",dependencies:{setPrototypeOf:["body.0.body.body.0.expression.expressions.2.callee"]}}),initializerDefineProperty:helper("7.0.0-beta.0","function _initializerDefineProperty(e,i,r,l){r&&Object.defineProperty(e,i,{enumerable:r.enumerable,configurable:r.configurable,writable:r.writable,value:r.initializer?r.initializer.call(l):void 0})}",{globals:["Object"],locals:{_initializerDefineProperty:["body.0.id"]},exportBindingAssignments:[],exportName:"_initializerDefineProperty",dependencies:{}}),initializerWarningHelper:helper("7.0.0-beta.0",'function _initializerWarningHelper(r,e){throw Error("Decorating class property failed. Please ensure that transform-class-properties is enabled and runs after the decorators transform.")}',{globals:["Error"],locals:{_initializerWarningHelper:["body.0.id"]},exportBindingAssignments:[],exportName:"_initializerWarningHelper",dependencies:{}}),instanceof:helper("7.0.0-beta.0",'function _instanceof(n,e){return null!=e&&"undefined"!=typeof Symbol&&e[Symbol.hasInstance]?!!e[Symbol.hasInstance](n):n instanceof e}',{globals:["Symbol"],locals:{_instanceof:["body.0.id"]},exportBindingAssignments:[],exportName:"_instanceof",dependencies:{}}),interopRequireDefault:helper("7.0.0-beta.0","function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}",{globals:[],locals:{_interopRequireDefault:["body.0.id"]},exportBindingAssignments:[],exportName:"_interopRequireDefault",dependencies:{}}),interopRequireWildcard:helper("7.14.0",'function _getRequireWildcardCache(e){if("function"!=typeof WeakMap)return null;var r=new WeakMap,t=new WeakMap;return(_getRequireWildcardCache=function(e){return e?t:r})(e)}function _interopRequireWildcard(e,r){if(!r&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var t=_getRequireWildcardCache(r);if(t&&t.has(e))return t.get(e);var n={__proto__:null},a=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var u in e)if("default"!==u&&{}.hasOwnProperty.call(e,u)){var i=a?Object.getOwnPropertyDescriptor(e,u):null;i&&(i.get||i.set)?Object.defineProperty(n,u,i):n[u]=e[u]}return n.default=e,t&&t.set(e,n),n}',{globals:["WeakMap","Object"],locals:{_getRequireWildcardCache:["body.0.id","body.1.body.body.2.declarations.0.init.callee","body.0.body.body.2.argument.callee.left"],_interopRequireWildcard:["body.1.id"]},exportBindingAssignments:[],exportName:"_interopRequireWildcard",dependencies:{}}),isNativeFunction:helper("7.0.0-beta.0",'function _isNativeFunction(t){try{return-1!==Function.toString.call(t).indexOf("[native code]")}catch(n){return"function"==typeof t}}',{globals:["Function"],locals:{_isNativeFunction:["body.0.id"]},exportBindingAssignments:[],exportName:"_isNativeFunction",dependencies:{}}),isNativeReflectConstruct:helper("7.9.0","function _isNativeReflectConstruct(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(_isNativeReflectConstruct=function(){return!!t})()}",{globals:["Boolean","Reflect"],locals:{_isNativeReflectConstruct:["body.0.id","body.0.body.body.1.argument.callee.left"]},exportBindingAssignments:["body.0.body.body.1.argument.callee"],exportName:"_isNativeReflectConstruct",dependencies:{}}),iterableToArray:helper("7.0.0-beta.0",'function _iterableToArray(r){if("undefined"!=typeof Symbol&&null!=r[Symbol.iterator]||null!=r["@@iterator"])return Array.from(r)}',{globals:["Symbol","Array"],locals:{_iterableToArray:["body.0.id"]},exportBindingAssignments:[],exportName:"_iterableToArray",dependencies:{}}),iterableToArrayLimit:helper("7.0.0-beta.0",'function _iterableToArrayLimit(r,l){var t=null==r?null:"undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(null!=t){var e,n,i,u,a=[],f=!0,o=!1;try{if(i=(t=t.call(r)).next,0===l){if(Object(t)!==t)return;f=!1}else for(;!(f=(e=i.call(t)).done)&&(a.push(e.value),a.length!==l);f=!0);}catch(r){o=!0,n=r}finally{try{if(!f&&null!=t.return&&(u=t.return(),Object(u)!==u))return}finally{if(o)throw n}}return a}}',{globals:["Symbol","Object"],locals:{_iterableToArrayLimit:["body.0.id"]},exportBindingAssignments:[],exportName:"_iterableToArrayLimit",dependencies:{}}),jsx:helper("7.0.0-beta.0",'var REACT_ELEMENT_TYPE;function _createRawReactElement(e,r,E,l){REACT_ELEMENT_TYPE||(REACT_ELEMENT_TYPE="function"==typeof Symbol&&Symbol.for&&Symbol.for("react.element")||60103);var o=e&&e.defaultProps,n=arguments.length-3;if(r||0===n||(r={children:void 0}),1===n)r.children=l;else if(n>1){for(var t=Array(n),f=0;f<n;f++)t[f]=arguments[f+3];r.children=t}if(r&&o)for(var i in o)void 0===r[i]&&(r[i]=o[i]);else r||(r=o||{});return{$$typeof:REACT_ELEMENT_TYPE,type:e,key:void 0===E?null:""+E,ref:null,props:r,_owner:null}}',{globals:["Symbol","Array"],locals:{REACT_ELEMENT_TYPE:["body.0.declarations.0.id","body.1.body.body.0.expression.left","body.1.body.body.4.argument.properties.0.value","body.1.body.body.0.expression.right.left"],_createRawReactElement:["body.1.id"]},exportBindingAssignments:[],exportName:"_createRawReactElement",dependencies:{}}),maybeArrayLike:helper("7.9.0",'function _maybeArrayLike(r,a,e){if(a&&!Array.isArray(a)&&"number"==typeof a.length){var y=a.length;return arrayLikeToArray(a,void 0!==e&&e<y?e:y)}return r(a,e)}',{globals:["Array"],locals:{_maybeArrayLike:["body.0.id"]},exportBindingAssignments:[],exportName:"_maybeArrayLike",dependencies:{arrayLikeToArray:["body.0.body.body.0.consequent.body.1.argument.callee"]}}),newArrowCheck:helper("7.0.0-beta.0",'function _newArrowCheck(n,r){if(n!==r)throw new TypeError("Cannot instantiate an arrow function")}',{globals:["TypeError"],locals:{_newArrowCheck:["body.0.id"]},exportBindingAssignments:[],exportName:"_newArrowCheck",dependencies:{}}),nonIterableRest:helper("7.0.0-beta.0",'function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}',{globals:["TypeError"],locals:{_nonIterableRest:["body.0.id"]},exportBindingAssignments:[],exportName:"_nonIterableRest",dependencies:{}}),nonIterableSpread:helper("7.0.0-beta.0",'function _nonIterableSpread(){throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}',{globals:["TypeError"],locals:{_nonIterableSpread:["body.0.id"]},exportBindingAssignments:[],exportName:"_nonIterableSpread",dependencies:{}}),nullishReceiverError:helper("7.22.6",'function _nullishReceiverError(r){throw new TypeError("Cannot set property of null or undefined.")}',{globals:["TypeError"],locals:{_nullishReceiverError:["body.0.id"]},exportBindingAssignments:[],exportName:"_nullishReceiverError",dependencies:{}}),objectDestructuringEmpty:helper("7.0.0-beta.0",'function _objectDestructuringEmpty(t){if(null==t)throw new TypeError("Cannot destructure "+t)}',{globals:["TypeError"],locals:{_objectDestructuringEmpty:["body.0.id"]},exportBindingAssignments:[],exportName:"_objectDestructuringEmpty",dependencies:{}}),objectSpread2:helper("7.5.0","function ownKeys(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);r&&(o=o.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,o)}return t}function _objectSpread2(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?ownKeys(Object(t),!0).forEach((function(r){defineProperty(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):ownKeys(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}",{globals:["Object"],locals:{ownKeys:["body.0.id","body.1.body.body.0.body.body.1.expression.consequent.callee.object.callee","body.1.body.body.0.body.body.1.expression.alternate.alternate.callee.object.callee"],_objectSpread2:["body.1.id"]},exportBindingAssignments:[],exportName:"_objectSpread2",dependencies:{defineProperty:["body.1.body.body.0.body.body.1.expression.consequent.arguments.0.body.body.0.expression.callee"]}}),objectWithoutProperties:helper("7.0.0-beta.0","function _objectWithoutProperties(e,t){if(null==e)return{};var o,r,i=objectWithoutPropertiesLoose(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)o=s[r],t.includes(o)||{}.propertyIsEnumerable.call(e,o)&&(i[o]=e[o])}return i}",{globals:["Object"],locals:{_objectWithoutProperties:["body.0.id"]},exportBindingAssignments:[],exportName:"_objectWithoutProperties",dependencies:{objectWithoutPropertiesLoose:["body.0.body.body.1.declarations.2.init.callee"]}}),objectWithoutPropertiesLoose:helper("7.0.0-beta.0","function _objectWithoutPropertiesLoose(r,e){if(null==r)return{};var t={};for(var n in r)if({}.hasOwnProperty.call(r,n)){if(e.includes(n))continue;t[n]=r[n]}return t}",{globals:[],locals:{_objectWithoutPropertiesLoose:["body.0.id"]},exportBindingAssignments:[],exportName:"_objectWithoutPropertiesLoose",dependencies:{}}),possibleConstructorReturn:helper("7.0.0-beta.0",'function _possibleConstructorReturn(t,e){if(e&&("object"==typeof e||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return assertThisInitialized(t)}',{globals:["TypeError"],locals:{_possibleConstructorReturn:["body.0.id"]},exportBindingAssignments:[],exportName:"_possibleConstructorReturn",dependencies:{assertThisInitialized:["body.0.body.body.2.argument.callee"]}}),readOnlyError:helper("7.0.0-beta.0","function _readOnlyError(r){throw new TypeError('\"'+r+'\" is read-only')}",{globals:["TypeError"],locals:{_readOnlyError:["body.0.id"]},exportBindingAssignments:[],exportName:"_readOnlyError",dependencies:{}}),regeneratorRuntime:helper("7.18.0",'function _regeneratorRuntime(){"use strict";\n/*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */_regeneratorRuntime=function(){return e};var t,e={},r=Object.prototype,n=r.hasOwnProperty,o=Object.defineProperty||function(t,e,r){t[e]=r.value},i="function"==typeof Symbol?Symbol:{},a=i.iterator||"@@iterator",c=i.asyncIterator||"@@asyncIterator",u=i.toStringTag||"@@toStringTag";function define(t,e,r){return Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}),t[e]}try{define({},"")}catch(t){define=function(t,e,r){return t[e]=r}}function wrap(t,e,r,n){var i=e&&e.prototype instanceof Generator?e:Generator,a=Object.create(i.prototype),c=new Context(n||[]);return o(a,"_invoke",{value:makeInvokeMethod(t,r,c)}),a}function tryCatch(t,e,r){try{return{type:"normal",arg:t.call(e,r)}}catch(t){return{type:"throw",arg:t}}}e.wrap=wrap;var h="suspendedStart",l="suspendedYield",f="executing",s="completed",y={};function Generator(){}function GeneratorFunction(){}function GeneratorFunctionPrototype(){}var p={};define(p,a,(function(){return this}));var d=Object.getPrototypeOf,v=d&&d(d(values([])));v&&v!==r&&n.call(v,a)&&(p=v);var g=GeneratorFunctionPrototype.prototype=Generator.prototype=Object.create(p);function defineIteratorMethods(t){["next","throw","return"].forEach((function(e){define(t,e,(function(t){return this._invoke(e,t)}))}))}function AsyncIterator(t,e){function invoke(r,o,i,a){var c=tryCatch(t[r],t,o);if("throw"!==c.type){var u=c.arg,h=u.value;return h&&"object"==typeof h&&n.call(h,"__await")?e.resolve(h.__await).then((function(t){invoke("next",t,i,a)}),(function(t){invoke("throw",t,i,a)})):e.resolve(h).then((function(t){u.value=t,i(u)}),(function(t){return invoke("throw",t,i,a)}))}a(c.arg)}var r;o(this,"_invoke",{value:function(t,n){function callInvokeWithMethodAndArg(){return new e((function(e,r){invoke(t,n,e,r)}))}return r=r?r.then(callInvokeWithMethodAndArg,callInvokeWithMethodAndArg):callInvokeWithMethodAndArg()}})}function makeInvokeMethod(e,r,n){var o=h;return function(i,a){if(o===f)throw Error("Generator is already running");if(o===s){if("throw"===i)throw a;return{value:t,done:!0}}for(n.method=i,n.arg=a;;){var c=n.delegate;if(c){var u=maybeInvokeDelegate(c,n);if(u){if(u===y)continue;return u}}if("next"===n.method)n.sent=n._sent=n.arg;else if("throw"===n.method){if(o===h)throw o=s,n.arg;n.dispatchException(n.arg)}else"return"===n.method&&n.abrupt("return",n.arg);o=f;var p=tryCatch(e,r,n);if("normal"===p.type){if(o=n.done?s:l,p.arg===y)continue;return{value:p.arg,done:n.done}}"throw"===p.type&&(o=s,n.method="throw",n.arg=p.arg)}}}function maybeInvokeDelegate(e,r){var n=r.method,o=e.iterator[n];if(o===t)return r.delegate=null,"throw"===n&&e.iterator.return&&(r.method="return",r.arg=t,maybeInvokeDelegate(e,r),"throw"===r.method)||"return"!==n&&(r.method="throw",r.arg=new TypeError("The iterator does not provide a \'"+n+"\' method")),y;var i=tryCatch(o,e.iterator,r.arg);if("throw"===i.type)return r.method="throw",r.arg=i.arg,r.delegate=null,y;var a=i.arg;return a?a.done?(r[e.resultName]=a.value,r.next=e.nextLoc,"return"!==r.method&&(r.method="next",r.arg=t),r.delegate=null,y):a:(r.method="throw",r.arg=new TypeError("iterator result is not an object"),r.delegate=null,y)}function pushTryEntry(t){var e={tryLoc:t[0]};1 in t&&(e.catchLoc=t[1]),2 in t&&(e.finallyLoc=t[2],e.afterLoc=t[3]),this.tryEntries.push(e)}function resetTryEntry(t){var e=t.completion||{};e.type="normal",delete e.arg,t.completion=e}function Context(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(pushTryEntry,this),this.reset(!0)}function values(e){if(e||""===e){var r=e[a];if(r)return r.call(e);if("function"==typeof e.next)return e;if(!isNaN(e.length)){var o=-1,i=function next(){for(;++o<e.length;)if(n.call(e,o))return next.value=e[o],next.done=!1,next;return next.value=t,next.done=!0,next};return i.next=i}}throw new TypeError(typeof e+" is not iterable")}return GeneratorFunction.prototype=GeneratorFunctionPrototype,o(g,"constructor",{value:GeneratorFunctionPrototype,configurable:!0}),o(GeneratorFunctionPrototype,"constructor",{value:GeneratorFunction,configurable:!0}),GeneratorFunction.displayName=define(GeneratorFunctionPrototype,u,"GeneratorFunction"),e.isGeneratorFunction=function(t){var e="function"==typeof t&&t.constructor;return!!e&&(e===GeneratorFunction||"GeneratorFunction"===(e.displayName||e.name))},e.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,GeneratorFunctionPrototype):(t.__proto__=GeneratorFunctionPrototype,define(t,u,"GeneratorFunction")),t.prototype=Object.create(g),t},e.awrap=function(t){return{__await:t}},defineIteratorMethods(AsyncIterator.prototype),define(AsyncIterator.prototype,c,(function(){return this})),e.AsyncIterator=AsyncIterator,e.async=function(t,r,n,o,i){void 0===i&&(i=Promise);var a=new AsyncIterator(wrap(t,r,n,o),i);return e.isGeneratorFunction(r)?a:a.next().then((function(t){return t.done?t.value:a.next()}))},defineIteratorMethods(g),define(g,u,"Generator"),define(g,a,(function(){return this})),define(g,"toString",(function(){return"[object Generator]"})),e.keys=function(t){var e=Object(t),r=[];for(var n in e)r.push(n);return r.reverse(),function next(){for(;r.length;){var t=r.pop();if(t in e)return next.value=t,next.done=!1,next}return next.done=!0,next}},e.values=values,Context.prototype={constructor:Context,reset:function(e){if(this.prev=0,this.next=0,this.sent=this._sent=t,this.done=!1,this.delegate=null,this.method="next",this.arg=t,this.tryEntries.forEach(resetTryEntry),!e)for(var r in this)"t"===r.charAt(0)&&n.call(this,r)&&!isNaN(+r.slice(1))&&(this[r]=t)},stop:function(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.type)throw t.arg;return this.rval},dispatchException:function(e){if(this.done)throw e;var r=this;function handle(n,o){return a.type="throw",a.arg=e,r.next=n,o&&(r.method="next",r.arg=t),!!o}for(var o=this.tryEntries.length-1;o>=0;--o){var i=this.tryEntries[o],a=i.completion;if("root"===i.tryLoc)return handle("end");if(i.tryLoc<=this.prev){var c=n.call(i,"catchLoc"),u=n.call(i,"finallyLoc");if(c&&u){if(this.prev<i.catchLoc)return handle(i.catchLoc,!0);if(this.prev<i.finallyLoc)return handle(i.finallyLoc)}else if(c){if(this.prev<i.catchLoc)return handle(i.catchLoc,!0)}else{if(!u)throw Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return handle(i.finallyLoc)}}}},abrupt:function(t,e){for(var r=this.tryEntries.length-1;r>=0;--r){var o=this.tryEntries[r];if(o.tryLoc<=this.prev&&n.call(o,"finallyLoc")&&this.prev<o.finallyLoc){var i=o;break}}i&&("break"===t||"continue"===t)&&i.tryLoc<=e&&e<=i.finallyLoc&&(i=null);var a=i?i.completion:{};return a.type=t,a.arg=e,i?(this.method="next",this.next=i.finallyLoc,y):this.complete(a)},complete:function(t,e){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&e&&(this.next=e),y},finish:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),resetTryEntry(r),y}},catch:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.tryLoc===t){var n=r.completion;if("throw"===n.type){var o=n.arg;resetTryEntry(r)}return o}}throw Error("illegal catch attempt")},delegateYield:function(e,r,n){return this.delegate={iterator:values(e),resultName:r,nextLoc:n},"next"===this.method&&(this.arg=t),y}},e}',{globals:["Object","Symbol","Error","TypeError","isNaN","Promise"],locals:{_regeneratorRuntime:["body.0.id","body.0.body.body.0.expression.left"]},exportBindingAssignments:["body.0.body.body.0.expression"],exportName:"_regeneratorRuntime",dependencies:{}}),set:helper("7.0.0-beta.0",'function set(e,r,t,o){return set="undefined"!=typeof Reflect&&Reflect.set?Reflect.set:function(e,r,t,o){var f,i=superPropBase(e,r);if(i){if((f=Object.getOwnPropertyDescriptor(i,r)).set)return f.set.call(o,t),!0;if(!f.writable)return!1}if(f=Object.getOwnPropertyDescriptor(o,r)){if(!f.writable)return!1;f.value=t,Object.defineProperty(o,r,f)}else defineProperty(o,r,t);return!0},set(e,r,t,o)}function _set(e,r,t,o,f){if(!set(e,r,t,o||e)&&f)throw new TypeError("failed to set property");return t}',{globals:["Reflect","Object","TypeError"],locals:{set:["body.0.id","body.0.body.body.0.argument.expressions.1.callee","body.1.body.body.0.test.left.argument.callee","body.0.body.body.0.argument.expressions.0.left"],_set:["body.1.id"]},exportBindingAssignments:[],exportName:"_set",dependencies:{superPropBase:["body.0.body.body.0.argument.expressions.0.right.alternate.body.body.0.declarations.1.init.callee"],defineProperty:["body.0.body.body.0.argument.expressions.0.right.alternate.body.body.2.alternate.expression.callee"]}}),setFunctionName:helper("7.23.6",'function setFunctionName(e,t,n){"symbol"==typeof t&&(t=(t=t.description)?"["+t+"]":"");try{Object.defineProperty(e,"name",{configurable:!0,value:n?n+" "+t:t})}catch(e){}return e}',{globals:["Object"],locals:{setFunctionName:["body.0.id"]},exportBindingAssignments:[],exportName:"setFunctionName",dependencies:{}}),setPrototypeOf:helper("7.0.0-beta.0","function _setPrototypeOf(t,e){return _setPrototypeOf=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},_setPrototypeOf(t,e)}",{globals:["Object"],locals:{_setPrototypeOf:["body.0.id","body.0.body.body.0.argument.expressions.1.callee","body.0.body.body.0.argument.expressions.0.left"]},exportBindingAssignments:["body.0.body.body.0.argument.expressions.0"],exportName:"_setPrototypeOf",dependencies:{}}),skipFirstGeneratorNext:helper("7.0.0-beta.0","function _skipFirstGeneratorNext(t){return function(){var r=t.apply(this,arguments);return r.next(),r}}",{globals:[],locals:{_skipFirstGeneratorNext:["body.0.id"]},exportBindingAssignments:[],exportName:"_skipFirstGeneratorNext",dependencies:{}}),slicedToArray:helper("7.0.0-beta.0","function _slicedToArray(r,e){return arrayWithHoles(r)||iterableToArrayLimit(r,e)||unsupportedIterableToArray(r,e)||nonIterableRest()}",{globals:[],locals:{_slicedToArray:["body.0.id"]},exportBindingAssignments:[],exportName:"_slicedToArray",dependencies:{arrayWithHoles:["body.0.body.body.0.argument.left.left.left.callee"],iterableToArrayLimit:["body.0.body.body.0.argument.left.left.right.callee"],unsupportedIterableToArray:["body.0.body.body.0.argument.left.right.callee"],nonIterableRest:["body.0.body.body.0.argument.right.callee"]}}),superPropBase:helper("7.0.0-beta.0","function _superPropBase(t,o){for(;!{}.hasOwnProperty.call(t,o)&&null!==(t=getPrototypeOf(t)););return t}",{globals:[],locals:{_superPropBase:["body.0.id"]},exportBindingAssignments:[],exportName:"_superPropBase",dependencies:{getPrototypeOf:["body.0.body.body.0.test.right.right.right.callee"]}}),superPropGet:helper("7.25.0",'function _superPropGet(t,o,e,r){var p=get(getPrototypeOf(1&r?t.prototype:t),o,e);return 2&r&&"function"==typeof p?function(t){return p.apply(e,t)}:p}',{globals:[],locals:{_superPropGet:["body.0.id"]},exportBindingAssignments:[],exportName:"_superPropGet",dependencies:{get:["body.0.body.body.0.declarations.0.init.callee"],getPrototypeOf:["body.0.body.body.0.declarations.0.init.arguments.0.callee"]}}),superPropSet:helper("7.25.0","function _superPropSet(t,e,o,r,p,f){return set(getPrototypeOf(f?t.prototype:t),e,o,r,p)}",{globals:[],locals:{_superPropSet:["body.0.id"]},exportBindingAssignments:[],exportName:"_superPropSet",dependencies:{set:["body.0.body.body.0.argument.callee"],getPrototypeOf:["body.0.body.body.0.argument.arguments.0.callee"]}}),taggedTemplateLiteral:helper("7.0.0-beta.0","function _taggedTemplateLiteral(e,t){return t||(t=e.slice(0)),Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(t)}}))}",{globals:["Object"],locals:{_taggedTemplateLiteral:["body.0.id"]},exportBindingAssignments:[],exportName:"_taggedTemplateLiteral",dependencies:{}}),taggedTemplateLiteralLoose:helper("7.0.0-beta.0","function _taggedTemplateLiteralLoose(e,t){return t||(t=e.slice(0)),e.raw=t,e}",{globals:[],locals:{_taggedTemplateLiteralLoose:["body.0.id"]},exportBindingAssignments:[],exportName:"_taggedTemplateLiteralLoose",dependencies:{}}),tdz:helper("7.5.5",'function _tdzError(e){throw new ReferenceError(e+" is not defined - temporal dead zone")}',{globals:["ReferenceError"],locals:{_tdzError:["body.0.id"]},exportBindingAssignments:[],exportName:"_tdzError",dependencies:{}}),temporalRef:helper("7.0.0-beta.0","function _temporalRef(r,e){return r===undef?err(e):r}",{globals:[],locals:{_temporalRef:["body.0.id"]},exportBindingAssignments:[],exportName:"_temporalRef",dependencies:{temporalUndefined:["body.0.body.body.0.argument.test.right"],tdz:["body.0.body.body.0.argument.consequent.callee"]}}),temporalUndefined:helper("7.0.0-beta.0","function _temporalUndefined(){}",{globals:[],locals:{_temporalUndefined:["body.0.id"]},exportBindingAssignments:[],exportName:"_temporalUndefined",dependencies:{}}),toArray:helper("7.0.0-beta.0","function _toArray(r){return arrayWithHoles(r)||iterableToArray(r)||unsupportedIterableToArray(r)||nonIterableRest()}",{globals:[],locals:{_toArray:["body.0.id"]},exportBindingAssignments:[],exportName:"_toArray",dependencies:{arrayWithHoles:["body.0.body.body.0.argument.left.left.left.callee"],iterableToArray:["body.0.body.body.0.argument.left.left.right.callee"],unsupportedIterableToArray:["body.0.body.body.0.argument.left.right.callee"],nonIterableRest:["body.0.body.body.0.argument.right.callee"]}}),toConsumableArray:helper("7.0.0-beta.0","function _toConsumableArray(r){return arrayWithoutHoles(r)||iterableToArray(r)||unsupportedIterableToArray(r)||nonIterableSpread()}",{globals:[],locals:{_toConsumableArray:["body.0.id"]},exportBindingAssignments:[],exportName:"_toConsumableArray",dependencies:{arrayWithoutHoles:["body.0.body.body.0.argument.left.left.left.callee"],iterableToArray:["body.0.body.body.0.argument.left.left.right.callee"],unsupportedIterableToArray:["body.0.body.body.0.argument.left.right.callee"],nonIterableSpread:["body.0.body.body.0.argument.right.callee"]}}),toPrimitive:helper("7.1.5",'function toPrimitive(t,r){if("object"!=typeof t||!t)return t;var e=t[Symbol.toPrimitive];if(void 0!==e){var i=e.call(t,r||"default");if("object"!=typeof i)return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===r?String:Number)(t)}',{globals:["Symbol","TypeError","String","Number"],locals:{toPrimitive:["body.0.id"]},exportBindingAssignments:[],exportName:"toPrimitive",dependencies:{}}),toPropertyKey:helper("7.1.5",'function toPropertyKey(t){var i=toPrimitive(t,"string");return"symbol"==typeof i?i:i+""}',{globals:[],locals:{toPropertyKey:["body.0.id"]},exportBindingAssignments:[],exportName:"toPropertyKey",dependencies:{toPrimitive:["body.0.body.body.0.declarations.0.init.callee"]}}),toSetter:helper("7.24.0",'function _toSetter(t,e,n){e||(e=[]);var r=e.length++;return Object.defineProperty({},"_",{set:function(o){e[r]=o,t.apply(n,e)}})}',{globals:["Object"],locals:{_toSetter:["body.0.id"]},exportBindingAssignments:[],exportName:"_toSetter",dependencies:{}}),typeof:helper("7.0.0-beta.0",'function _typeof(o){"@babel/helpers - typeof";return _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(o){return typeof o}:function(o){return o&&"function"==typeof Symbol&&o.constructor===Symbol&&o!==Symbol.prototype?"symbol":typeof o},_typeof(o)}',{globals:["Symbol"],locals:{_typeof:["body.0.id","body.0.body.body.0.argument.expressions.1.callee","body.0.body.body.0.argument.expressions.0.left"]},exportBindingAssignments:["body.0.body.body.0.argument.expressions.0"],exportName:"_typeof",dependencies:{}}),unsupportedIterableToArray:helper("7.9.0",'function _unsupportedIterableToArray(r,a){if(r){if("string"==typeof r)return arrayLikeToArray(r,a);var t={}.toString.call(r).slice(8,-1);return"Object"===t&&r.constructor&&(t=r.constructor.name),"Map"===t||"Set"===t?Array.from(r):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?arrayLikeToArray(r,a):void 0}}',{globals:["Array"],locals:{_unsupportedIterableToArray:["body.0.id"]},exportBindingAssignments:[],exportName:"_unsupportedIterableToArray",dependencies:{arrayLikeToArray:["body.0.body.body.0.consequent.body.0.consequent.argument.callee","body.0.body.body.0.consequent.body.2.argument.expressions.1.alternate.consequent.callee"]}}),usingCtx:helper("7.23.9",'function _usingCtx(){var r="function"==typeof SuppressedError?SuppressedError:function(r,e){var n=Error();return n.name="SuppressedError",n.error=r,n.suppressed=e,n},e={},n=[];function using(r,e){if(null!=e){if(Object(e)!==e)throw new TypeError("using declarations can only be used with objects, functions, null, or undefined.");if(r)var o=e[Symbol.asyncDispose||Symbol.for("Symbol.asyncDispose")];if(void 0===o&&(o=e[Symbol.dispose||Symbol.for("Symbol.dispose")],r))var t=o;if("function"!=typeof o)throw new TypeError("Object is not disposable.");t&&(o=function(){try{t.call(e)}catch(r){return Promise.reject(r)}}),n.push({v:e,d:o,a:r})}else r&&n.push({d:e,a:r});return e}return{e:e,u:using.bind(null,!1),a:using.bind(null,!0),d:function(){var o,t=this.e,s=0;function next(){for(;o=n.pop();)try{if(!o.a&&1===s)return s=0,n.push(o),Promise.resolve().then(next);if(o.d){var r=o.d.call(o.v);if(o.a)return s|=2,Promise.resolve(r).then(next,err)}else s|=1}catch(r){return err(r)}if(1===s)return t!==e?Promise.reject(t):Promise.resolve();if(t!==e)throw t}function err(n){return t=t!==e?new r(n,t):n,next()}return next()}}}',{globals:["SuppressedError","Error","Object","TypeError","Symbol","Promise"],locals:{_usingCtx:["body.0.id"]},exportBindingAssignments:[],exportName:"_usingCtx",dependencies:{}}),wrapAsyncGenerator:helper("7.0.0-beta.0",'function _wrapAsyncGenerator(e){return function(){return new AsyncGenerator(e.apply(this,arguments))}}function AsyncGenerator(e){var r,t;function resume(r,t){try{var n=e[r](t),o=n.value,u=o instanceof OverloadYield;Promise.resolve(u?o.v:o).then((function(t){if(u){var i="return"===r?"return":"next";if(!o.k||t.done)return resume(i,t);t=e[i](t).value}settle(n.done?"return":"normal",t)}),(function(e){resume("throw",e)}))}catch(e){settle("throw",e)}}function settle(e,n){switch(e){case"return":r.resolve({value:n,done:!0});break;case"throw":r.reject(n);break;default:r.resolve({value:n,done:!1})}(r=r.next)?resume(r.key,r.arg):t=null}this._invoke=function(e,n){return new Promise((function(o,u){var i={key:e,arg:n,resolve:o,reject:u,next:null};t?t=t.next=i:(r=t=i,resume(e,n))}))},"function"!=typeof e.return&&(this.return=void 0)}AsyncGenerator.prototype["function"==typeof Symbol&&Symbol.asyncIterator||"@@asyncIterator"]=function(){return this},AsyncGenerator.prototype.next=function(e){return this._invoke("next",e)},AsyncGenerator.prototype.throw=function(e){return this._invoke("throw",e)},AsyncGenerator.prototype.return=function(e){return this._invoke("return",e)};',{globals:["Promise","Symbol"],locals:{_wrapAsyncGenerator:["body.0.id"],AsyncGenerator:["body.1.id","body.0.body.body.0.argument.body.body.0.argument.callee","body.2.expression.expressions.0.left.object.object","body.2.expression.expressions.1.left.object.object","body.2.expression.expressions.2.left.object.object","body.2.expression.expressions.3.left.object.object"]},exportBindingAssignments:[],exportName:"_wrapAsyncGenerator",dependencies:{OverloadYield:["body.1.body.body.1.body.body.0.block.body.0.declarations.2.init.right"]}}),wrapNativeSuper:helper("7.0.0-beta.0",'function _wrapNativeSuper(t){var r="function"==typeof Map?new Map:void 0;return _wrapNativeSuper=function(t){if(null===t||!isNativeFunction(t))return t;if("function"!=typeof t)throw new TypeError("Super expression must either be null or a function");if(void 0!==r){if(r.has(t))return r.get(t);r.set(t,Wrapper)}function Wrapper(){return construct(t,arguments,getPrototypeOf(this).constructor)}return Wrapper.prototype=Object.create(t.prototype,{constructor:{value:Wrapper,enumerable:!1,writable:!0,configurable:!0}}),setPrototypeOf(Wrapper,t)},_wrapNativeSuper(t)}',{globals:["Map","TypeError","Object"],locals:{_wrapNativeSuper:["body.0.id","body.0.body.body.1.argument.expressions.1.callee","body.0.body.body.1.argument.expressions.0.left"]},exportBindingAssignments:["body.0.body.body.1.argument.expressions.0"],exportName:"_wrapNativeSuper",dependencies:{getPrototypeOf:["body.0.body.body.1.argument.expressions.0.right.body.body.3.body.body.0.argument.arguments.2.object.callee"],setPrototypeOf:["body.0.body.body.1.argument.expressions.0.right.body.body.4.argument.expressions.1.callee"],isNativeFunction:["body.0.body.body.1.argument.expressions.0.right.body.body.0.test.right.argument.callee"],construct:["body.0.body.body.1.argument.expressions.0.right.body.body.3.body.body.0.argument.callee"]}}),wrapRegExp:helper("7.19.0",'function _wrapRegExp(){_wrapRegExp=function(e,r){return new BabelRegExp(e,void 0,r)};var e=RegExp.prototype,r=new WeakMap;function BabelRegExp(e,t,p){var o=RegExp(e,t);return r.set(o,p||r.get(e)),setPrototypeOf(o,BabelRegExp.prototype)}function buildGroups(e,t){var p=r.get(t);return Object.keys(p).reduce((function(r,t){var o=p[t];if("number"==typeof o)r[t]=e[o];else{for(var i=0;void 0===e[o[i]]&&i+1<o.length;)i++;r[t]=e[o[i]]}return r}),Object.create(null))}return inherits(BabelRegExp,RegExp),BabelRegExp.prototype.exec=function(r){var t=e.exec.call(this,r);if(t){t.groups=buildGroups(t,this);var p=t.indices;p&&(p.groups=buildGroups(p,this))}return t},BabelRegExp.prototype[Symbol.replace]=function(t,p){if("string"==typeof p){var o=r.get(this);return e[Symbol.replace].call(this,t,p.replace(/\\$<([^>]+)>/g,(function(e,r){var t=o[r];return"$"+(Array.isArray(t)?t.join("$"):t)})))}if("function"==typeof p){var i=this;return e[Symbol.replace].call(this,t,(function(){var e=arguments;return"object"!=typeof e[e.length-1]&&(e=[].slice.call(e)).push(buildGroups(e,i)),p.apply(this,e)}))}return e[Symbol.replace].call(this,t,p)},_wrapRegExp.apply(this,arguments)}',{globals:["RegExp","WeakMap","Object","Symbol","Array"],locals:{_wrapRegExp:["body.0.id","body.0.body.body.4.argument.expressions.3.callee.object","body.0.body.body.0.expression.left"]},exportBindingAssignments:["body.0.body.body.0.expression"],exportName:"_wrapRegExp",dependencies:{setPrototypeOf:["body.0.body.body.2.body.body.1.argument.expressions.1.callee"],inherits:["body.0.body.body.4.argument.expressions.0.callee"]}}),writeOnlyError:helper("7.12.13","function _writeOnlyError(r){throw new TypeError('\"'+r+'\" is write-only')}",{globals:["TypeError"],locals:{_writeOnlyError:["body.0.id"]},exportBindingAssignments:[],exportName:"_writeOnlyError",dependencies:{}})};Object.assign(helpers,{AwaitValue:helper("7.0.0-beta.0","function _AwaitValue(t){this.wrapped=t}",{globals:[],locals:{_AwaitValue:["body.0.id"]},exportBindingAssignments:[],exportName:"_AwaitValue",dependencies:{}}),applyDecs:helper("7.17.8",'function old_createMetadataMethodsForProperty(e,t,a,r){return{getMetadata:function(o){old_assertNotFinished(r,"getMetadata"),old_assertMetadataKey(o);var i=e[o];if(void 0!==i)if(1===t){var n=i.public;if(void 0!==n)return n[a]}else if(2===t){var l=i.private;if(void 0!==l)return l.get(a)}else if(Object.hasOwnProperty.call(i,"constructor"))return i.constructor},setMetadata:function(o,i){old_assertNotFinished(r,"setMetadata"),old_assertMetadataKey(o);var n=e[o];if(void 0===n&&(n=e[o]={}),1===t){var l=n.public;void 0===l&&(l=n.public={}),l[a]=i}else if(2===t){var s=n.priv;void 0===s&&(s=n.private=new Map),s.set(a,i)}else n.constructor=i}}}function old_convertMetadataMapToFinal(e,t){var a=e[Symbol.metadata||Symbol.for("Symbol.metadata")],r=Object.getOwnPropertySymbols(t);if(0!==r.length){for(var o=0;o<r.length;o++){var i=r[o],n=t[i],l=a?a[i]:null,s=n.public,c=l?l.public:null;s&&c&&Object.setPrototypeOf(s,c);var d=n.private;if(d){var u=Array.from(d.values()),f=l?l.private:null;f&&(u=u.concat(f)),n.private=u}l&&Object.setPrototypeOf(n,l)}a&&Object.setPrototypeOf(t,a),e[Symbol.metadata||Symbol.for("Symbol.metadata")]=t}}function old_createAddInitializerMethod(e,t){return function(a){old_assertNotFinished(t,"addInitializer"),old_assertCallable(a,"An initializer"),e.push(a)}}function old_memberDec(e,t,a,r,o,i,n,l,s){var c;switch(i){case 1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c="setter";break;default:c="field"}var d,u,f={kind:c,name:l?"#"+t:toPropertyKey(t),isStatic:n,isPrivate:l},p={v:!1};if(0!==i&&(f.addInitializer=old_createAddInitializerMethod(o,p)),l){d=2,u=Symbol(t);var v={};0===i?(v.get=a.get,v.set=a.set):2===i?v.get=function(){return a.value}:(1!==i&&3!==i||(v.get=function(){return a.get.call(this)}),1!==i&&4!==i||(v.set=function(e){a.set.call(this,e)})),f.access=v}else d=1,u=t;try{return e(s,Object.assign(f,old_createMetadataMethodsForProperty(r,d,u,p)))}finally{p.v=!0}}function old_assertNotFinished(e,t){if(e.v)throw Error("attempted to call "+t+" after decoration was finished")}function old_assertMetadataKey(e){if("symbol"!=typeof e)throw new TypeError("Metadata keys must be symbols, received: "+e)}function old_assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function old_assertValidReturnValue(e,t){var a=typeof t;if(1===e){if("object"!==a||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&old_assertCallable(t.get,"accessor.get"),void 0!==t.set&&old_assertCallable(t.set,"accessor.set"),void 0!==t.init&&old_assertCallable(t.init,"accessor.init"),void 0!==t.initializer&&old_assertCallable(t.initializer,"accessor.initializer")}else if("function"!==a)throw new TypeError((0===e?"field":10===e?"class":"method")+" decorators must return a function or void 0")}function old_getInit(e){var t;return null==(t=e.init)&&(t=e.initializer)&&void 0!==console&&console.warn(".initializer has been renamed to .init as of March 2022"),t}function old_applyMemberDec(e,t,a,r,o,i,n,l,s){var c,d,u,f,p,v,y,h=a[0];if(n?(0===o||1===o?(c={get:a[3],set:a[4]},u="get"):3===o?(c={get:a[3]},u="get"):4===o?(c={set:a[3]},u="set"):c={value:a[3]},0!==o&&(1===o&&setFunctionName(a[4],"#"+r,"set"),setFunctionName(a[3],"#"+r,u))):0!==o&&(c=Object.getOwnPropertyDescriptor(t,r)),1===o?f={get:c.get,set:c.set}:2===o?f=c.value:3===o?f=c.get:4===o&&(f=c.set),"function"==typeof h)void 0!==(p=old_memberDec(h,r,c,l,s,o,i,n,f))&&(old_assertValidReturnValue(o,p),0===o?d=p:1===o?(d=old_getInit(p),v=p.get||f.get,y=p.set||f.set,f={get:v,set:y}):f=p);else for(var m=h.length-1;m>=0;m--){var b;void 0!==(p=old_memberDec(h[m],r,c,l,s,o,i,n,f))&&(old_assertValidReturnValue(o,p),0===o?b=p:1===o?(b=old_getInit(p),v=p.get||f.get,y=p.set||f.set,f={get:v,set:y}):f=p,void 0!==b&&(void 0===d?d=b:"function"==typeof d?d=[d,b]:d.push(b)))}if(0===o||1===o){if(void 0===d)d=function(e,t){return t};else if("function"!=typeof d){var g=d;d=function(e,t){for(var a=t,r=0;r<g.length;r++)a=g[r].call(e,a);return a}}else{var _=d;d=function(e,t){return _.call(e,t)}}e.push(d)}0!==o&&(1===o?(c.get=f.get,c.set=f.set):2===o?c.value=f:3===o?c.get=f:4===o&&(c.set=f),n?1===o?(e.push((function(e,t){return f.get.call(e,t)})),e.push((function(e,t){return f.set.call(e,t)}))):2===o?e.push(f):e.push((function(e,t){return f.call(e,t)})):Object.defineProperty(t,r,c))}function old_applyMemberDecs(e,t,a,r,o){for(var i,n,l=new Map,s=new Map,c=0;c<o.length;c++){var d=o[c];if(Array.isArray(d)){var u,f,p,v=d[1],y=d[2],h=d.length>3,m=v>=5;if(m?(u=t,f=r,0!=(v-=5)&&(p=n=n||[])):(u=t.prototype,f=a,0!==v&&(p=i=i||[])),0!==v&&!h){var b=m?s:l,g=b.get(y)||0;if(!0===g||3===g&&4!==v||4===g&&3!==v)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+y);!g&&v>2?b.set(y,v):b.set(y,!0)}old_applyMemberDec(e,u,d,y,v,m,h,f,p)}}old_pushInitializers(e,i),old_pushInitializers(e,n)}function old_pushInitializers(e,t){t&&e.push((function(e){for(var a=0;a<t.length;a++)t[a].call(e);return e}))}function old_applyClassDecs(e,t,a,r){if(r.length>0){for(var o=[],i=t,n=t.name,l=r.length-1;l>=0;l--){var s={v:!1};try{var c=Object.assign({kind:"class",name:n,addInitializer:old_createAddInitializerMethod(o,s)},old_createMetadataMethodsForProperty(a,0,n,s)),d=r[l](i,c)}finally{s.v=!0}void 0!==d&&(old_assertValidReturnValue(10,d),i=d)}e.push(i,(function(){for(var e=0;e<o.length;e++)o[e].call(i)}))}}function applyDecs(e,t,a){var r=[],o={},i={};return old_applyMemberDecs(r,e,i,o,t),old_convertMetadataMapToFinal(e.prototype,i),old_applyClassDecs(r,e,o,a),old_convertMetadataMapToFinal(e,o),r}',{globals:["Object","Map","Symbol","Array","Error","TypeError","console"],locals:{old_createMetadataMethodsForProperty:["body.0.id","body.3.body.body.4.block.body.0.argument.arguments.1.arguments.1.callee","body.12.body.body.0.consequent.body.0.body.body.1.block.body.0.declarations.0.init.arguments.1.callee"],old_convertMetadataMapToFinal:["body.1.id","body.13.body.body.1.argument.expressions.1.callee","body.13.body.body.1.argument.expressions.3.callee"],old_createAddInitializerMethod:["body.2.id","body.3.body.body.3.test.expressions.0.right.right.callee","body.12.body.body.0.consequent.body.0.body.body.1.block.body.0.declarations.0.init.arguments.0.properties.2.value.callee"],old_memberDec:["body.3.id","body.9.body.body.1.consequent.expression.left.right.right.callee","body.9.body.body.1.alternate.body.body.1.expression.left.right.right.callee"],old_assertNotFinished:["body.4.id","body.0.body.body.0.argument.properties.0.value.body.body.0.expression.expressions.0.callee","body.0.body.body.0.argument.properties.1.value.body.body.0.expression.expressions.0.callee","body.2.body.body.0.argument.body.body.0.expression.expressions.0.callee"],old_assertMetadataKey:["body.5.id","body.0.body.body.0.argument.properties.0.value.body.body.0.expression.expressions.1.callee","body.0.body.body.0.argument.properties.1.value.body.body.0.expression.expressions.1.callee"],old_assertCallable:["body.6.id","body.2.body.body.0.argument.body.body.0.expression.expressions.1.callee","body.7.body.body.1.consequent.body.1.expression.expressions.0.right.callee","body.7.body.body.1.consequent.body.1.expression.expressions.1.right.callee","body.7.body.body.1.consequent.body.1.expression.expressions.2.right.callee","body.7.body.body.1.consequent.body.1.expression.expressions.3.right.callee"],old_assertValidReturnValue:["body.7.id","body.9.body.body.1.consequent.expression.right.expressions.0.callee","body.9.body.body.1.alternate.body.body.1.expression.right.expressions.0.callee","body.12.body.body.0.consequent.body.0.body.body.2.expression.right.expressions.0.callee"],old_getInit:["body.8.id","body.9.body.body.1.consequent.expression.right.expressions.1.alternate.consequent.expressions.0.right.callee","body.9.body.body.1.alternate.body.body.1.expression.right.expressions.1.alternate.consequent.expressions.0.right.callee"],old_applyMemberDec:["body.9.id","body.10.body.body.0.body.body.1.consequent.body.2.expression.callee"],old_applyMemberDecs:["body.10.id","body.13.body.body.1.argument.expressions.0.callee"],old_pushInitializers:["body.11.id","body.10.body.body.1.expression.expressions.0.callee","body.10.body.body.1.expression.expressions.1.callee"],old_applyClassDecs:["body.12.id","body.13.body.body.1.argument.expressions.2.callee"],applyDecs:["body.13.id"]},exportBindingAssignments:[],exportName:"applyDecs",dependencies:{setFunctionName:["body.9.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.0.right.callee","body.9.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.1.callee"],toPropertyKey:["body.3.body.body.2.declarations.2.init.properties.1.value.alternate.callee"]}}),applyDecs2203:helper("7.19.0",'function applyDecs2203Factory(){function createAddInitializerMethod(e,t){return function(r){!function(e,t){if(e.v)throw Error("attempted to call addInitializer after decoration was finished")}(t),assertCallable(r,"An initializer"),e.push(r)}}function memberDec(e,t,r,a,n,i,s,o){var c;switch(n){case 1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c="setter";break;default:c="field"}var l,u,f={kind:c,name:s?"#"+t:t,static:i,private:s},p={v:!1};0!==n&&(f.addInitializer=createAddInitializerMethod(a,p)),0===n?s?(l=r.get,u=r.set):(l=function(){return this[t]},u=function(e){this[t]=e}):2===n?l=function(){return r.value}:(1!==n&&3!==n||(l=function(){return r.get.call(this)}),1!==n&&4!==n||(u=function(e){r.set.call(this,e)})),f.access=l&&u?{get:l,set:u}:l?{get:l}:{set:u};try{return e(o,f)}finally{p.v=!0}}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertValidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.set"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r)throw new TypeError((0===e?"field":10===e?"class":"method")+" decorators must return a function or void 0")}function applyMemberDec(e,t,r,a,n,i,s,o){var c,l,u,f,p,d,h=r[0];if(s?c=0===n||1===n?{get:r[3],set:r[4]}:3===n?{get:r[3]}:4===n?{set:r[3]}:{value:r[3]}:0!==n&&(c=Object.getOwnPropertyDescriptor(t,a)),1===n?u={get:c.get,set:c.set}:2===n?u=c.value:3===n?u=c.get:4===n&&(u=c.set),"function"==typeof h)void 0!==(f=memberDec(h,a,c,o,n,i,s,u))&&(assertValidReturnValue(n,f),0===n?l=f:1===n?(l=f.init,p=f.get||u.get,d=f.set||u.set,u={get:p,set:d}):u=f);else for(var v=h.length-1;v>=0;v--){var g;void 0!==(f=memberDec(h[v],a,c,o,n,i,s,u))&&(assertValidReturnValue(n,f),0===n?g=f:1===n?(g=f.init,p=f.get||u.get,d=f.set||u.set,u={get:p,set:d}):u=f,void 0!==g&&(void 0===l?l=g:"function"==typeof l?l=[l,g]:l.push(g)))}if(0===n||1===n){if(void 0===l)l=function(e,t){return t};else if("function"!=typeof l){var y=l;l=function(e,t){for(var r=t,a=0;a<y.length;a++)r=y[a].call(e,r);return r}}else{var m=l;l=function(e,t){return m.call(e,t)}}e.push(l)}0!==n&&(1===n?(c.get=u.get,c.set=u.set):2===n?c.value=u:3===n?c.get=u:4===n&&(c.set=u),s?1===n?(e.push((function(e,t){return u.get.call(e,t)})),e.push((function(e,t){return u.set.call(e,t)}))):2===n?e.push(u):e.push((function(e,t){return u.call(e,t)})):Object.defineProperty(t,a,c))}function pushInitializers(e,t){t&&e.push((function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e}))}return function(e,t,r){var a=[];return function(e,t,r){for(var a,n,i=new Map,s=new Map,o=0;o<r.length;o++){var c=r[o];if(Array.isArray(c)){var l,u,f=c[1],p=c[2],d=c.length>3,h=f>=5;if(h?(l=t,0!=(f-=5)&&(u=n=n||[])):(l=t.prototype,0!==f&&(u=a=a||[])),0!==f&&!d){var v=h?s:i,g=v.get(p)||0;if(!0===g||3===g&&4!==f||4===g&&3!==f)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+p);!g&&f>2?v.set(p,f):v.set(p,!0)}applyMemberDec(e,l,c,p,f,h,d,u)}}pushInitializers(e,a),pushInitializers(e,n)}(a,e,t),function(e,t,r){if(r.length>0){for(var a=[],n=t,i=t.name,s=r.length-1;s>=0;s--){var o={v:!1};try{var c=r[s](n,{kind:"class",name:i,addInitializer:createAddInitializerMethod(a,o)})}finally{o.v=!0}void 0!==c&&(assertValidReturnValue(10,c),n=c)}e.push(n,(function(){for(var e=0;e<a.length;e++)a[e].call(n)}))}}(a,e,r),a}}var applyDecs2203Impl;function applyDecs2203(e,t,r){return(applyDecs2203Impl=applyDecs2203Impl||applyDecs2203Factory())(e,t,r)}',{globals:["Error","TypeError","Object","Map","Array"],locals:{applyDecs2203Factory:["body.0.id","body.2.body.body.0.argument.callee.right.right.callee"],applyDecs2203Impl:["body.1.declarations.0.id","body.2.body.body.0.argument.callee.right.left","body.2.body.body.0.argument.callee.left"],applyDecs2203:["body.2.id"]},exportBindingAssignments:[],exportName:"applyDecs2203",dependencies:{}}),applyDecs2203R:helper("7.20.0",'function applyDecs2203RFactory(){function createAddInitializerMethod(e,t){return function(r){!function(e,t){if(e.v)throw Error("attempted to call addInitializer after decoration was finished")}(t),assertCallable(r,"An initializer"),e.push(r)}}function memberDec(e,t,r,n,a,i,o,s){var c;switch(a){case 1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c="setter";break;default:c="field"}var l,u,f={kind:c,name:o?"#"+t:toPropertyKey(t),static:i,private:o},p={v:!1};0!==a&&(f.addInitializer=createAddInitializerMethod(n,p)),0===a?o?(l=r.get,u=r.set):(l=function(){return this[t]},u=function(e){this[t]=e}):2===a?l=function(){return r.value}:(1!==a&&3!==a||(l=function(){return r.get.call(this)}),1!==a&&4!==a||(u=function(e){r.set.call(this,e)})),f.access=l&&u?{get:l,set:u}:l?{get:l}:{set:u};try{return e(s,f)}finally{p.v=!0}}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertValidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.set"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r)throw new TypeError((0===e?"field":10===e?"class":"method")+" decorators must return a function or void 0")}function applyMemberDec(e,t,r,n,a,i,o,s){var c,l,u,f,p,d,h,v=r[0];if(o?(0===a||1===a?(c={get:r[3],set:r[4]},u="get"):3===a?(c={get:r[3]},u="get"):4===a?(c={set:r[3]},u="set"):c={value:r[3]},0!==a&&(1===a&&setFunctionName(r[4],"#"+n,"set"),setFunctionName(r[3],"#"+n,u))):0!==a&&(c=Object.getOwnPropertyDescriptor(t,n)),1===a?f={get:c.get,set:c.set}:2===a?f=c.value:3===a?f=c.get:4===a&&(f=c.set),"function"==typeof v)void 0!==(p=memberDec(v,n,c,s,a,i,o,f))&&(assertValidReturnValue(a,p),0===a?l=p:1===a?(l=p.init,d=p.get||f.get,h=p.set||f.set,f={get:d,set:h}):f=p);else for(var g=v.length-1;g>=0;g--){var y;void 0!==(p=memberDec(v[g],n,c,s,a,i,o,f))&&(assertValidReturnValue(a,p),0===a?y=p:1===a?(y=p.init,d=p.get||f.get,h=p.set||f.set,f={get:d,set:h}):f=p,void 0!==y&&(void 0===l?l=y:"function"==typeof l?l=[l,y]:l.push(y)))}if(0===a||1===a){if(void 0===l)l=function(e,t){return t};else if("function"!=typeof l){var m=l;l=function(e,t){for(var r=t,n=0;n<m.length;n++)r=m[n].call(e,r);return r}}else{var b=l;l=function(e,t){return b.call(e,t)}}e.push(l)}0!==a&&(1===a?(c.get=f.get,c.set=f.set):2===a?c.value=f:3===a?c.get=f:4===a&&(c.set=f),o?1===a?(e.push((function(e,t){return f.get.call(e,t)})),e.push((function(e,t){return f.set.call(e,t)}))):2===a?e.push(f):e.push((function(e,t){return f.call(e,t)})):Object.defineProperty(t,n,c))}function applyMemberDecs(e,t){for(var r,n,a=[],i=new Map,o=new Map,s=0;s<t.length;s++){var c=t[s];if(Array.isArray(c)){var l,u,f=c[1],p=c[2],d=c.length>3,h=f>=5;if(h?(l=e,0!=(f-=5)&&(u=n=n||[])):(l=e.prototype,0!==f&&(u=r=r||[])),0!==f&&!d){var v=h?o:i,g=v.get(p)||0;if(!0===g||3===g&&4!==f||4===g&&3!==f)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+p);!g&&f>2?v.set(p,f):v.set(p,!0)}applyMemberDec(a,l,c,p,f,h,d,u)}}return pushInitializers(a,r),pushInitializers(a,n),a}function pushInitializers(e,t){t&&e.push((function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e}))}return function(e,t,r){return{e:applyMemberDecs(e,t),get c(){return function(e,t){if(t.length>0){for(var r=[],n=e,a=e.name,i=t.length-1;i>=0;i--){var o={v:!1};try{var s=t[i](n,{kind:"class",name:a,addInitializer:createAddInitializerMethod(r,o)})}finally{o.v=!0}void 0!==s&&(assertValidReturnValue(10,s),n=s)}return[n,function(){for(var e=0;e<r.length;e++)r[e].call(n)}]}}(e,r)}}}}function applyDecs2203R(e,t,r){return(applyDecs2203R=applyDecs2203RFactory())(e,t,r)}',{globals:["Error","TypeError","Object","Map","Array"],locals:{applyDecs2203RFactory:["body.0.id","body.1.body.body.0.argument.callee.right.callee"],applyDecs2203R:["body.1.id","body.1.body.body.0.argument.callee.left"]},exportBindingAssignments:["body.1.body.body.0.argument.callee"],exportName:"applyDecs2203R",dependencies:{setFunctionName:["body.0.body.body.4.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.0.right.callee","body.0.body.body.4.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.1.callee"],toPropertyKey:["body.0.body.body.1.body.body.2.declarations.2.init.properties.1.value.alternate.callee"]}}),applyDecs2301:helper("7.21.0",'function applyDecs2301Factory(){function createAddInitializerMethod(e,t){return function(r){!function(e,t){if(e.v)throw Error("attempted to call addInitializer after decoration was finished")}(t),assertCallable(r,"An initializer"),e.push(r)}}function assertInstanceIfPrivate(e,t){if(!e(t))throw new TypeError("Attempted to access private element on non-instance")}function memberDec(e,t,r,n,a,i,s,o,c){var u;switch(a){case 1:u="accessor";break;case 2:u="method";break;case 3:u="getter";break;case 4:u="setter";break;default:u="field"}var l,f,p={kind:u,name:s?"#"+t:toPropertyKey(t),static:i,private:s},d={v:!1};if(0!==a&&(p.addInitializer=createAddInitializerMethod(n,d)),s||0!==a&&2!==a)if(2===a)l=function(e){return assertInstanceIfPrivate(c,e),r.value};else{var h=0===a||1===a;(h||3===a)&&(l=s?function(e){return assertInstanceIfPrivate(c,e),r.get.call(e)}:function(e){return r.get.call(e)}),(h||4===a)&&(f=s?function(e,t){assertInstanceIfPrivate(c,e),r.set.call(e,t)}:function(e,t){r.set.call(e,t)})}else l=function(e){return e[t]},0===a&&(f=function(e,r){e[t]=r});var v=s?c.bind():function(e){return t in e};p.access=l&&f?{get:l,set:f,has:v}:l?{get:l,has:v}:{set:f,has:v};try{return e(o,p)}finally{d.v=!0}}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertValidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.set"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r)throw new TypeError((0===e?"field":10===e?"class":"method")+" decorators must return a function or void 0")}function curryThis2(e){return function(t){e(this,t)}}function applyMemberDec(e,t,r,n,a,i,s,o,c){var u,l,f,p,d,h,v,y,g=r[0];if(s?(0===a||1===a?(u={get:(d=r[3],function(){return d(this)}),set:curryThis2(r[4])},f="get"):3===a?(u={get:r[3]},f="get"):4===a?(u={set:r[3]},f="set"):u={value:r[3]},0!==a&&(1===a&&setFunctionName(u.set,"#"+n,"set"),setFunctionName(u[f||"value"],"#"+n,f))):0!==a&&(u=Object.getOwnPropertyDescriptor(t,n)),1===a?p={get:u.get,set:u.set}:2===a?p=u.value:3===a?p=u.get:4===a&&(p=u.set),"function"==typeof g)void 0!==(h=memberDec(g,n,u,o,a,i,s,p,c))&&(assertValidReturnValue(a,h),0===a?l=h:1===a?(l=h.init,v=h.get||p.get,y=h.set||p.set,p={get:v,set:y}):p=h);else for(var m=g.length-1;m>=0;m--){var b;void 0!==(h=memberDec(g[m],n,u,o,a,i,s,p,c))&&(assertValidReturnValue(a,h),0===a?b=h:1===a?(b=h.init,v=h.get||p.get,y=h.set||p.set,p={get:v,set:y}):p=h,void 0!==b&&(void 0===l?l=b:"function"==typeof l?l=[l,b]:l.push(b)))}if(0===a||1===a){if(void 0===l)l=function(e,t){return t};else if("function"!=typeof l){var I=l;l=function(e,t){for(var r=t,n=0;n<I.length;n++)r=I[n].call(e,r);return r}}else{var w=l;l=function(e,t){return w.call(e,t)}}e.push(l)}0!==a&&(1===a?(u.get=p.get,u.set=p.set):2===a?u.value=p:3===a?u.get=p:4===a&&(u.set=p),s?1===a?(e.push((function(e,t){return p.get.call(e,t)})),e.push((function(e,t){return p.set.call(e,t)}))):2===a?e.push(p):e.push((function(e,t){return p.call(e,t)})):Object.defineProperty(t,n,u))}function applyMemberDecs(e,t,r){for(var n,a,i,s=[],o=new Map,c=new Map,u=0;u<t.length;u++){var l=t[u];if(Array.isArray(l)){var f,p,d=l[1],h=l[2],v=l.length>3,y=d>=5,g=r;if(y?(f=e,0!=(d-=5)&&(p=a=a||[]),v&&!i&&(i=function(t){return checkInRHS(t)===e}),g=i):(f=e.prototype,0!==d&&(p=n=n||[])),0!==d&&!v){var m=y?c:o,b=m.get(h)||0;if(!0===b||3===b&&4!==d||4===b&&3!==d)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+h);!b&&d>2?m.set(h,d):m.set(h,!0)}applyMemberDec(s,f,l,h,d,y,v,p,g)}}return pushInitializers(s,n),pushInitializers(s,a),s}function pushInitializers(e,t){t&&e.push((function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e}))}return function(e,t,r,n){return{e:applyMemberDecs(e,t,n),get c(){return function(e,t){if(t.length>0){for(var r=[],n=e,a=e.name,i=t.length-1;i>=0;i--){var s={v:!1};try{var o=t[i](n,{kind:"class",name:a,addInitializer:createAddInitializerMethod(r,s)})}finally{s.v=!0}void 0!==o&&(assertValidReturnValue(10,o),n=o)}return[n,function(){for(var e=0;e<r.length;e++)r[e].call(n)}]}}(e,r)}}}}function applyDecs2301(e,t,r,n){return(applyDecs2301=applyDecs2301Factory())(e,t,r,n)}',{globals:["Error","TypeError","Object","Map","Array"],locals:{applyDecs2301Factory:["body.0.id","body.1.body.body.0.argument.callee.right.callee"],applyDecs2301:["body.1.id","body.1.body.body.0.argument.callee.left"]},exportBindingAssignments:["body.1.body.body.0.argument.callee"],exportName:"applyDecs2301",dependencies:{checkInRHS:["body.0.body.body.7.body.body.0.body.body.1.consequent.body.1.test.expressions.0.consequent.expressions.2.right.right.body.body.0.argument.left.callee"],setFunctionName:["body.0.body.body.6.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.0.right.callee","body.0.body.body.6.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.1.callee"],toPropertyKey:["body.0.body.body.2.body.body.2.declarations.2.init.properties.1.value.alternate.callee"]}}),applyDecs2305:helper("7.21.0",'function applyDecs2305(e,t,r,n,o,a){function i(e,t,r){return function(n,o){return r&&r(n),e[t].call(n,o)}}function c(e,t){for(var r=0;r<e.length;r++)e[r].call(t);return t}function s(e,t,r,n){if("function"!=typeof e&&(n||void 0!==e))throw new TypeError(t+" must "+(r||"be")+" a function"+(n?"":" or undefined"));return e}function applyDec(e,t,r,n,o,a,c,u,l,f,p,d,h){function m(e){if(!h(e))throw new TypeError("Attempted to access private element on non-instance")}var y,v=t[0],g=t[3],b=!u;if(!b){r||Array.isArray(v)||(v=[v]);var w={},S=[],A=3===o?"get":4===o||d?"set":"value";f?(p||d?w={get:setFunctionName((function(){return g(this)}),n,"get"),set:function(e){t[4](this,e)}}:w[A]=g,p||setFunctionName(w[A],n,2===o?"":A)):p||(w=Object.getOwnPropertyDescriptor(e,n))}for(var P=e,j=v.length-1;j>=0;j-=r?2:1){var D=v[j],E=r?v[j-1]:void 0,I={},O={kind:["field","accessor","method","getter","setter","class"][o],name:n,metadata:a,addInitializer:function(e,t){if(e.v)throw Error("attempted to call addInitializer after decoration was finished");s(t,"An initializer","be",!0),c.push(t)}.bind(null,I)};try{if(b)(y=s(D.call(E,P,O),"class decorators","return"))&&(P=y);else{var k,F;O.static=l,O.private=f,f?2===o?k=function(e){return m(e),w.value}:(o<4&&(k=i(w,"get",m)),3!==o&&(F=i(w,"set",m))):(k=function(e){return e[n]},(o<2||4===o)&&(F=function(e,t){e[n]=t}));var N=O.access={has:f?h.bind():function(e){return n in e}};if(k&&(N.get=k),F&&(N.set=F),P=D.call(E,d?{get:w.get,set:w.set}:w[A],O),d){if("object"==typeof P&&P)(y=s(P.get,"accessor.get"))&&(w.get=y),(y=s(P.set,"accessor.set"))&&(w.set=y),(y=s(P.init,"accessor.init"))&&S.push(y);else if(void 0!==P)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0")}else s(P,(p?"field":"method")+" decorators","return")&&(p?S.push(P):w[A]=P)}}finally{I.v=!0}}return(p||d)&&u.push((function(e,t){for(var r=S.length-1;r>=0;r--)t=S[r].call(e,t);return t})),p||b||(f?d?u.push(i(w,"get"),i(w,"set")):u.push(2===o?w[A]:i.call.bind(w[A])):Object.defineProperty(e,n,w)),P}function u(e,t){return Object.defineProperty(e,Symbol.metadata||Symbol.for("Symbol.metadata"),{configurable:!0,enumerable:!0,value:t})}if(arguments.length>=6)var l=a[Symbol.metadata||Symbol.for("Symbol.metadata")];var f=Object.create(null==l?null:l),p=function(e,t,r,n){var o,a,i=[],s=function(t){return checkInRHS(t)===e},u=new Map;function l(e){e&&i.push(c.bind(null,e))}for(var f=0;f<t.length;f++){var p=t[f];if(Array.isArray(p)){var d=p[1],h=p[2],m=p.length>3,y=16&d,v=!!(8&d),g=0==(d&=7),b=h+"/"+v;if(!g&&!m){var w=u.get(b);if(!0===w||3===w&&4!==d||4===w&&3!==d)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+h);u.set(b,!(d>2)||d)}applyDec(v?e:e.prototype,p,y,m?"#"+h:toPropertyKey(h),d,n,v?a=a||[]:o=o||[],i,v,m,g,1===d,v&&m?s:r)}}return l(o),l(a),i}(e,t,o,f);return r.length||u(e,f),{e:p,get c(){var t=[];return r.length&&[u(applyDec(e,[r],n,e.name,5,f,t),f),c.bind(null,t,e)]}}}',{globals:["TypeError","Array","Object","Error","Symbol","Map"],locals:{applyDecs2305:["body.0.id"]},exportBindingAssignments:[],exportName:"applyDecs2305",dependencies:{checkInRHS:["body.0.body.body.6.declarations.1.init.callee.body.body.0.declarations.3.init.body.body.0.argument.left.callee"],setFunctionName:["body.0.body.body.3.body.body.2.consequent.body.2.expression.consequent.expressions.0.consequent.right.properties.0.value.callee","body.0.body.body.3.body.body.2.consequent.body.2.expression.consequent.expressions.1.right.callee"],toPropertyKey:["body.0.body.body.6.declarations.1.init.callee.body.body.2.body.body.1.consequent.body.2.expression.arguments.3.alternate.callee"]}}),classApplyDescriptorDestructureSet:helper("7.13.10",'function _classApplyDescriptorDestructureSet(e,t){if(t.set)return"__destrObj"in t||(t.__destrObj={set value(r){t.set.call(e,r)}}),t.__destrObj;if(!t.writable)throw new TypeError("attempted to set read only private field");return t}',{globals:["TypeError"],locals:{_classApplyDescriptorDestructureSet:["body.0.id"]},exportBindingAssignments:[],exportName:"_classApplyDescriptorDestructureSet",dependencies:{}}),classApplyDescriptorGet:helper("7.13.10","function _classApplyDescriptorGet(e,t){return t.get?t.get.call(e):t.value}",{globals:[],locals:{_classApplyDescriptorGet:["body.0.id"]},exportBindingAssignments:[],exportName:"_classApplyDescriptorGet",dependencies:{}}),classApplyDescriptorSet:helper("7.13.10",'function _classApplyDescriptorSet(e,t,l){if(t.set)t.set.call(e,l);else{if(!t.writable)throw new TypeError("attempted to set read only private field");t.value=l}}',{globals:["TypeError"],locals:{_classApplyDescriptorSet:["body.0.id"]},exportBindingAssignments:[],exportName:"_classApplyDescriptorSet",dependencies:{}}),classCheckPrivateStaticAccess:helper("7.13.10","function _classCheckPrivateStaticAccess(s,a,r){return assertClassBrand(a,s,r)}",{globals:[],locals:{_classCheckPrivateStaticAccess:["body.0.id"]},exportBindingAssignments:[],exportName:"_classCheckPrivateStaticAccess",dependencies:{assertClassBrand:["body.0.body.body.0.argument.callee"]}}),classCheckPrivateStaticFieldDescriptor:helper("7.13.10",'function _classCheckPrivateStaticFieldDescriptor(t,e){if(void 0===t)throw new TypeError("attempted to "+e+" private static field before its declaration")}',{globals:["TypeError"],locals:{_classCheckPrivateStaticFieldDescriptor:["body.0.id"]},exportBindingAssignments:[],exportName:"_classCheckPrivateStaticFieldDescriptor",dependencies:{}}),classExtractFieldDescriptor:helper("7.13.10","function _classExtractFieldDescriptor(e,t){return classPrivateFieldGet2(t,e)}",{globals:[],locals:{_classExtractFieldDescriptor:["body.0.id"]},exportBindingAssignments:[],exportName:"_classExtractFieldDescriptor",dependencies:{classPrivateFieldGet2:["body.0.body.body.0.argument.callee"]}}),classPrivateFieldDestructureSet:helper("7.4.4","function _classPrivateFieldDestructureSet(e,t){var r=classPrivateFieldGet2(t,e);return classApplyDescriptorDestructureSet(e,r)}",{globals:[],locals:{_classPrivateFieldDestructureSet:["body.0.id"]},exportBindingAssignments:[],exportName:"_classPrivateFieldDestructureSet",dependencies:{classApplyDescriptorDestructureSet:["body.0.body.body.1.argument.callee"],classPrivateFieldGet2:["body.0.body.body.0.declarations.0.init.callee"]}}),classPrivateFieldGet:helper("7.0.0-beta.0","function _classPrivateFieldGet(e,t){var r=classPrivateFieldGet2(t,e);return classApplyDescriptorGet(e,r)}",{globals:[],locals:{_classPrivateFieldGet:["body.0.id"]},exportBindingAssignments:[],exportName:"_classPrivateFieldGet",dependencies:{classApplyDescriptorGet:["body.0.body.body.1.argument.callee"],classPrivateFieldGet2:["body.0.body.body.0.declarations.0.init.callee"]}}),classPrivateFieldSet:helper("7.0.0-beta.0","function _classPrivateFieldSet(e,t,r){var s=classPrivateFieldGet2(t,e);return classApplyDescriptorSet(e,s,r),r}",{globals:[],locals:{_classPrivateFieldSet:["body.0.id"]},exportBindingAssignments:[],exportName:"_classPrivateFieldSet",dependencies:{classApplyDescriptorSet:["body.0.body.body.1.argument.expressions.0.callee"],classPrivateFieldGet2:["body.0.body.body.0.declarations.0.init.callee"]}}),classPrivateMethodGet:helper("7.1.6","function _classPrivateMethodGet(s,a,r){return assertClassBrand(a,s),r}",{globals:[],locals:{_classPrivateMethodGet:["body.0.id"]},exportBindingAssignments:[],exportName:"_classPrivateMethodGet",dependencies:{assertClassBrand:["body.0.body.body.0.argument.expressions.0.callee"]}}),classPrivateMethodSet:helper("7.1.6",'function _classPrivateMethodSet(){throw new TypeError("attempted to reassign private method")}',{globals:["TypeError"],locals:{_classPrivateMethodSet:["body.0.id"]},exportBindingAssignments:[],exportName:"_classPrivateMethodSet",dependencies:{}}),classStaticPrivateFieldDestructureSet:helper("7.13.10",'function _classStaticPrivateFieldDestructureSet(t,r,s){return assertClassBrand(r,t),classCheckPrivateStaticFieldDescriptor(s,"set"),classApplyDescriptorDestructureSet(t,s)}',{globals:[],locals:{_classStaticPrivateFieldDestructureSet:["body.0.id"]},exportBindingAssignments:[],exportName:"_classStaticPrivateFieldDestructureSet",dependencies:{classApplyDescriptorDestructureSet:["body.0.body.body.0.argument.expressions.2.callee"],assertClassBrand:["body.0.body.body.0.argument.expressions.0.callee"],classCheckPrivateStaticFieldDescriptor:["body.0.body.body.0.argument.expressions.1.callee"]}}),classStaticPrivateFieldSpecGet:helper("7.0.2",'function _classStaticPrivateFieldSpecGet(t,s,r){return assertClassBrand(s,t),classCheckPrivateStaticFieldDescriptor(r,"get"),classApplyDescriptorGet(t,r)}',{globals:[],locals:{_classStaticPrivateFieldSpecGet:["body.0.id"]},exportBindingAssignments:[],exportName:"_classStaticPrivateFieldSpecGet",dependencies:{classApplyDescriptorGet:["body.0.body.body.0.argument.expressions.2.callee"],assertClassBrand:["body.0.body.body.0.argument.expressions.0.callee"],classCheckPrivateStaticFieldDescriptor:["body.0.body.body.0.argument.expressions.1.callee"]}}),classStaticPrivateFieldSpecSet:helper("7.0.2",'function _classStaticPrivateFieldSpecSet(s,t,r,e){return assertClassBrand(t,s),classCheckPrivateStaticFieldDescriptor(r,"set"),classApplyDescriptorSet(s,r,e),e}',{globals:[],locals:{_classStaticPrivateFieldSpecSet:["body.0.id"]},exportBindingAssignments:[],exportName:"_classStaticPrivateFieldSpecSet",dependencies:{classApplyDescriptorSet:["body.0.body.body.0.argument.expressions.2.callee"],assertClassBrand:["body.0.body.body.0.argument.expressions.0.callee"],classCheckPrivateStaticFieldDescriptor:["body.0.body.body.0.argument.expressions.1.callee"]}}),classStaticPrivateMethodSet:helper("7.3.2",'function _classStaticPrivateMethodSet(){throw new TypeError("attempted to set read only static private field")}',{globals:["TypeError"],locals:{_classStaticPrivateMethodSet:["body.0.id"]},exportBindingAssignments:[],exportName:"_classStaticPrivateMethodSet",dependencies:{}}),defineEnumerableProperties:helper("7.0.0-beta.0",'function _defineEnumerableProperties(e,r){for(var t in r){var n=r[t];n.configurable=n.enumerable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,t,n)}if(Object.getOwnPropertySymbols)for(var a=Object.getOwnPropertySymbols(r),b=0;b<a.length;b++){var i=a[b];(n=r[i]).configurable=n.enumerable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,i,n)}return e}',{globals:["Object"],locals:{_defineEnumerableProperties:["body.0.id"]},exportBindingAssignments:[],exportName:"_defineEnumerableProperties",dependencies:{}}),dispose:helper("7.22.0",'function dispose_SuppressedError(r,e){return"undefined"!=typeof SuppressedError?dispose_SuppressedError=SuppressedError:(dispose_SuppressedError=function(r,e){this.suppressed=e,this.error=r,this.stack=Error().stack},dispose_SuppressedError.prototype=Object.create(Error.prototype,{constructor:{value:dispose_SuppressedError,writable:!0,configurable:!0}})),new dispose_SuppressedError(r,e)}function _dispose(r,e,s){function next(){for(;r.length>0;)try{var o=r.pop(),p=o.d.call(o.v);if(o.a)return Promise.resolve(p).then(next,err)}catch(r){return err(r)}if(s)throw e}function err(r){return e=s?new dispose_SuppressedError(e,r):r,s=!0,next()}return next()}',{globals:["SuppressedError","Error","Object","Promise"],locals:{dispose_SuppressedError:["body.0.id","body.0.body.body.0.argument.expressions.0.alternate.expressions.1.left.object","body.0.body.body.0.argument.expressions.0.alternate.expressions.1.right.arguments.1.properties.0.value.properties.0.value","body.0.body.body.0.argument.expressions.1.callee","body.1.body.body.1.body.body.0.argument.expressions.0.right.consequent.callee","body.0.body.body.0.argument.expressions.0.consequent.left","body.0.body.body.0.argument.expressions.0.alternate.expressions.0.left"],_dispose:["body.1.id"]},exportBindingAssignments:[],exportName:"_dispose",dependencies:{}}),objectSpread:helper("7.0.0-beta.0",'function _objectSpread(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?Object(arguments[r]):{},o=Object.keys(t);"function"==typeof Object.getOwnPropertySymbols&&o.push.apply(o,Object.getOwnPropertySymbols(t).filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),o.forEach((function(r){defineProperty(e,r,t[r])}))}return e}',{globals:["Object"],locals:{_objectSpread:["body.0.id"]},exportBindingAssignments:[],exportName:"_objectSpread",dependencies:{defineProperty:["body.0.body.body.0.body.body.1.expression.expressions.1.arguments.0.body.body.0.expression.callee"]}}),using:helper("7.22.0",'function _using(o,n,e){if(null==n)return n;if(Object(n)!==n)throw new TypeError("using declarations can only be used with objects, functions, null, or undefined.");if(e)var r=n[Symbol.asyncDispose||Symbol.for("Symbol.asyncDispose")];if(null==r&&(r=n[Symbol.dispose||Symbol.for("Symbol.dispose")]),"function"!=typeof r)throw new TypeError("Property [Symbol.dispose] is not a function.");return o.push({v:n,d:r,a:e}),n}',{globals:["Object","TypeError","Symbol"],locals:{_using:["body.0.id"]},exportBindingAssignments:[],exportName:"_using",dependencies:{}})});},"./node_modules/.pnpm/@babel+helpers@7.26.0/node_modules/@babel/helpers/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=void 0,exports.get=get,exports.getDependencies=function(name){return loadHelper(name).getDependencies()},exports.list=void 0,exports.minVersion=function(name){return loadHelper(name).minVersion};var _t=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js"),_helpersGenerated=__webpack_require__("./node_modules/.pnpm/@babel+helpers@7.26.0/node_modules/@babel/helpers/lib/helpers-generated.js");const{cloneNode,identifier}=_t;function deep(obj,path,value){try{const parts=path.split(".");let last=parts.shift();for(;parts.length>0;)obj=obj[last],last=parts.shift();if(!(arguments.length>2))return obj[last];obj[last]=value;}catch(e){throw e.message+=` (when accessing ${path})`,e}}const helperData=Object.create(null);function loadHelper(name){if(!helperData[name]){const helper=_helpersGenerated.default[name];if(!helper)throw Object.assign(new ReferenceError(`Unknown helper ${name}`),{code:"BABEL_HELPER_UNKNOWN",helper:name});helperData[name]={minVersion:helper.minVersion,build(getDependency,bindingName,localBindings,adjustAst){const ast=helper.ast();return function(ast,metadata,bindingName,localBindings,getDependency,adjustAst){const{locals,dependencies,exportBindingAssignments,exportName}=metadata,bindings=new Set(localBindings||[]);bindingName&&bindings.add(bindingName);for(const[name,paths]of (Object.entries||(o=>Object.keys(o).map((k=>[k,o[k]]))))(locals)){let newName=name;if(bindingName&&name===exportName)newName=bindingName;else for(;bindings.has(newName);)newName="_"+newName;if(newName!==name)for(const path of paths)deep(ast,path,identifier(newName));}for(const[name,paths]of (Object.entries||(o=>Object.keys(o).map((k=>[k,o[k]]))))(dependencies)){const ref="function"==typeof getDependency&&getDependency(name)||identifier(name);for(const path of paths)deep(ast,path,cloneNode(ref));}null==adjustAst||adjustAst(ast,exportName,(map=>{exportBindingAssignments.forEach((p=>deep(ast,p,map(deep(ast,p)))));}));}(ast,helper.metadata,bindingName,localBindings,getDependency,adjustAst),{nodes:ast.body,globals:helper.metadata.globals}},getDependencies:()=>Object.keys(helper.metadata.dependencies)};}return helperData[name]}function get(name,getDependency,bindingName,localBindings,adjustAst){if("object"==typeof bindingName){const id=bindingName;bindingName="Identifier"===(null==id?void 0:id.type)?id.name:void 0;}return loadHelper(name).build(getDependency,bindingName,localBindings,adjustAst)}exports.ensure=name=>{loadHelper(name);};exports.list=Object.keys(_helpersGenerated.default).map((name=>name.replace(/^_/,"")));exports.default=get;},"./node_modules/.pnpm/@babel+parser@7.26.3/node_modules/@babel/parser/lib/index.js":(__unused_webpack_module,exports)=>{function _objectWithoutPropertiesLoose(r,e){if(null==r)return {};var t={};for(var n in r)if({}.hasOwnProperty.call(r,n)){if(e.includes(n))continue;t[n]=r[n];}return t}Object.defineProperty(exports,"__esModule",{value:true});class Position{constructor(line,col,index){this.line=void 0,this.column=void 0,this.index=void 0,this.line=line,this.column=col,this.index=index;}}class SourceLocation{constructor(start,end){this.start=void 0,this.end=void 0,this.filename=void 0,this.identifierName=void 0,this.start=start,this.end=end;}}function createPositionWithColumnOffset(position,columnOffset){const{line,column,index}=position;return new Position(line,column+columnOffset,index+columnOffset)}const code="BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED";var ModuleErrors={ImportMetaOutsideModule:{message:"import.meta may appear only with 'sourceType: \"module\"'",code},ImportOutsideModule:{message:"'import' and 'export' may appear only with 'sourceType: \"module\"'",code}};const NodeDescriptions={ArrayPattern:"array destructuring pattern",AssignmentExpression:"assignment expression",AssignmentPattern:"assignment expression",ArrowFunctionExpression:"arrow function expression",ConditionalExpression:"conditional expression",CatchClause:"catch clause",ForOfStatement:"for-of statement",ForInStatement:"for-in statement",ForStatement:"for-loop",FormalParameters:"function parameter list",Identifier:"identifier",ImportSpecifier:"import specifier",ImportDefaultSpecifier:"import default specifier",ImportNamespaceSpecifier:"import namespace specifier",ObjectPattern:"object destructuring pattern",ParenthesizedExpression:"parenthesized expression",RestElement:"rest element",UpdateExpression:{true:"prefix operation",false:"postfix operation"},VariableDeclarator:"variable declaration",YieldExpression:"yield expression"},toNodeDescription=node=>"UpdateExpression"===node.type?NodeDescriptions.UpdateExpression[`${node.prefix}`]:NodeDescriptions[node.type];var StandardErrors={AccessorIsGenerator:({kind})=>`A ${kind}ter cannot be a generator.`,ArgumentsInClass:"'arguments' is only allowed in functions and class methods.",AsyncFunctionInSingleStatementContext:"Async functions can only be declared at the top level or inside a block.",AwaitBindingIdentifier:"Can not use 'await' as identifier inside an async function.",AwaitBindingIdentifierInStaticBlock:"Can not use 'await' as identifier inside a static block.",AwaitExpressionFormalParameter:"'await' is not allowed in async function parameters.",AwaitUsingNotInAsyncContext:"'await using' is only allowed within async functions and at the top levels of modules.",AwaitNotInAsyncContext:"'await' is only allowed within async functions and at the top levels of modules.",AwaitNotInAsyncFunction:"'await' is only allowed within async functions.",BadGetterArity:"A 'get' accessor must not have any formal parameters.",BadSetterArity:"A 'set' accessor must have exactly one formal parameter.",BadSetterRestParameter:"A 'set' accessor function argument must not be a rest parameter.",ConstructorClassField:"Classes may not have a field named 'constructor'.",ConstructorClassPrivateField:"Classes may not have a private field named '#constructor'.",ConstructorIsAccessor:"Class constructor may not be an accessor.",ConstructorIsAsync:"Constructor can't be an async function.",ConstructorIsGenerator:"Constructor can't be a generator.",DeclarationMissingInitializer:({kind})=>`Missing initializer in ${kind} declaration.`,DecoratorArgumentsOutsideParentheses:"Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.",DecoratorBeforeExport:"Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.",DecoratorsBeforeAfterExport:"Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.",DecoratorConstructor:"Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",DecoratorExportClass:"Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.",DecoratorSemicolon:"Decorators must not be followed by a semicolon.",DecoratorStaticBlock:"Decorators can't be used with a static block.",DeferImportRequiresNamespace:'Only `import defer * as x from "./module"` is valid.',DeletePrivateField:"Deleting a private field is not allowed.",DestructureNamedImport:"ES2015 named imports do not destructure. Use another statement for destructuring after the import.",DuplicateConstructor:"Duplicate constructor in the same class.",DuplicateDefaultExport:"Only one default export allowed per module.",DuplicateExport:({exportName})=>`\`${exportName}\` has already been exported. Exported identifiers must be unique.`,DuplicateProto:"Redefinition of __proto__ property.",DuplicateRegExpFlags:"Duplicate regular expression flag.",DynamicImportPhaseRequiresImportExpressions:({phase})=>`'import.${phase}(...)' can only be parsed when using the 'createImportExpressions' option.`,ElementAfterRest:"Rest element must be last element.",EscapedCharNotAnIdentifier:"Invalid Unicode escape.",ExportBindingIsString:({localName,exportName})=>`A string literal cannot be used as an exported binding without \`from\`.\n- Did you mean \`export { '${localName}' as '${exportName}' } from 'some-module'\`?`,ExportDefaultFromAsIdentifier:"'from' is not allowed as an identifier after 'export default'.",ForInOfLoopInitializer:({type})=>`'${"ForInStatement"===type?"for-in":"for-of"}' loop variable declaration may not have an initializer.`,ForInUsing:"For-in loop may not start with 'using' declaration.",ForOfAsync:"The left-hand side of a for-of loop may not be 'async'.",ForOfLet:"The left-hand side of a for-of loop may not start with 'let'.",GeneratorInSingleStatementContext:"Generators can only be declared at the top level or inside a block.",IllegalBreakContinue:({type})=>`Unsyntactic ${"BreakStatement"===type?"break":"continue"}.`,IllegalLanguageModeDirective:"Illegal 'use strict' directive in function with non-simple parameter list.",IllegalReturn:"'return' outside of function.",ImportAttributesUseAssert:"The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedImportAssert` parser plugin to suppress this error.",ImportBindingIsString:({importName})=>`A string literal cannot be used as an imported binding.\n- Did you mean \`import { "${importName}" as foo }\`?`,ImportCallArity:"`import()` requires exactly one or two arguments.",ImportCallNotNewExpression:"Cannot use new with import(...).",ImportCallSpreadArgument:"`...` is not allowed in `import()`.",ImportJSONBindingNotDefault:"A JSON module can only be imported with `default`.",ImportReflectionHasAssertion:"`import module x` cannot have assertions.",ImportReflectionNotBinding:'Only `import module x from "./module"` is valid.',IncompatibleRegExpUVFlags:"The 'u' and 'v' regular expression flags cannot be enabled at the same time.",InvalidBigIntLiteral:"Invalid BigIntLiteral.",InvalidCodePoint:"Code point out of bounds.",InvalidCoverInitializedName:"Invalid shorthand property initializer.",InvalidDecimal:"Invalid decimal.",InvalidDigit:({radix})=>`Expected number in radix ${radix}.`,InvalidEscapeSequence:"Bad character escape sequence.",InvalidEscapeSequenceTemplate:"Invalid escape sequence in template.",InvalidEscapedReservedWord:({reservedWord})=>`Escape sequence in keyword ${reservedWord}.`,InvalidIdentifier:({identifierName})=>`Invalid identifier ${identifierName}.`,InvalidLhs:({ancestor})=>`Invalid left-hand side in ${toNodeDescription(ancestor)}.`,InvalidLhsBinding:({ancestor})=>`Binding invalid left-hand side in ${toNodeDescription(ancestor)}.`,InvalidLhsOptionalChaining:({ancestor})=>`Invalid optional chaining in the left-hand side of ${toNodeDescription(ancestor)}.`,InvalidNumber:"Invalid number.",InvalidOrMissingExponent:"Floating-point numbers require a valid exponent after the 'e'.",InvalidOrUnexpectedToken:({unexpected})=>`Unexpected character '${unexpected}'.`,InvalidParenthesizedAssignment:"Invalid parenthesized assignment pattern.",InvalidPrivateFieldResolution:({identifierName})=>`Private name #${identifierName} is not defined.`,InvalidPropertyBindingPattern:"Binding member expression.",InvalidRecordProperty:"Only properties and spread elements are allowed in record definitions.",InvalidRestAssignmentPattern:"Invalid rest operator's argument.",LabelRedeclaration:({labelName})=>`Label '${labelName}' is already declared.`,LetInLexicalBinding:"'let' is disallowed as a lexically bound name.",LineTerminatorBeforeArrow:"No line break is allowed before '=>'.",MalformedRegExpFlags:"Invalid regular expression flag.",MissingClassName:"A class name is required.",MissingEqInAssignment:"Only '=' operator can be used for specifying default value.",MissingSemicolon:"Missing semicolon.",MissingPlugin:({missingPlugin})=>`This experimental syntax requires enabling the parser plugin: ${missingPlugin.map((name=>JSON.stringify(name))).join(", ")}.`,MissingOneOfPlugins:({missingPlugin})=>`This experimental syntax requires enabling one of the following parser plugin(s): ${missingPlugin.map((name=>JSON.stringify(name))).join(", ")}.`,MissingUnicodeEscape:"Expecting Unicode escape sequence \\uXXXX.",MixingCoalesceWithLogical:"Nullish coalescing operator(??) requires parens when mixing with logical operators.",ModuleAttributeDifferentFromType:"The only accepted module attribute is `type`.",ModuleAttributeInvalidValue:"Only string literals are allowed as module attribute values.",ModuleAttributesWithDuplicateKeys:({key})=>`Duplicate key "${key}" is not allowed in module attributes.`,ModuleExportNameHasLoneSurrogate:({surrogateCharCode})=>`An export name cannot include a lone surrogate, found '\\u${surrogateCharCode.toString(16)}'.`,ModuleExportUndefined:({localName})=>`Export '${localName}' is not defined.`,MultipleDefaultsInSwitch:"Multiple default clauses.",NewlineAfterThrow:"Illegal newline after throw.",NoCatchOrFinally:"Missing catch or finally clause.",NumberIdentifier:"Identifier directly after number.",NumericSeparatorInEscapeSequence:"Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",ObsoleteAwaitStar:"'await*' has been removed from the async functions proposal. Use Promise.all() instead.",OptionalChainingNoNew:"Constructors in/after an Optional Chain are not allowed.",OptionalChainingNoTemplate:"Tagged Template Literals are not allowed in optionalChain.",OverrideOnConstructor:"'override' modifier cannot appear on a constructor declaration.",ParamDupe:"Argument name clash.",PatternHasAccessor:"Object pattern can't contain getter or setter.",PatternHasMethod:"Object pattern can't contain methods.",PrivateInExpectedIn:({identifierName})=>`Private names are only allowed in property accesses (\`obj.#${identifierName}\`) or in \`in\` expressions (\`#${identifierName} in obj\`).`,PrivateNameRedeclaration:({identifierName})=>`Duplicate private name #${identifierName}.`,RecordExpressionBarIncorrectEndSyntaxType:"Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",RecordExpressionBarIncorrectStartSyntaxType:"Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",RecordExpressionHashIncorrectStartSyntaxType:"Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",RecordNoProto:"'__proto__' is not allowed in Record expressions.",RestTrailingComma:"Unexpected trailing comma after rest element.",SloppyFunction:"In non-strict mode code, functions can only be declared at top level or inside a block.",SloppyFunctionAnnexB:"In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",SourcePhaseImportRequiresDefault:'Only `import source x from "./module"` is valid.',StaticPrototype:"Classes may not have static property named prototype.",SuperNotAllowed:"`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",SuperPrivateField:"Private fields can't be accessed on super.",TrailingDecorator:"Decorators must be attached to a class element.",TupleExpressionBarIncorrectEndSyntaxType:"Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",TupleExpressionBarIncorrectStartSyntaxType:"Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",TupleExpressionHashIncorrectStartSyntaxType:"Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",UnexpectedArgumentPlaceholder:"Unexpected argument placeholder.",UnexpectedAwaitAfterPipelineBody:'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',UnexpectedDigitAfterHash:"Unexpected digit after hash token.",UnexpectedImportExport:"'import' and 'export' may only appear at the top level.",UnexpectedKeyword:({keyword})=>`Unexpected keyword '${keyword}'.`,UnexpectedLeadingDecorator:"Leading decorators must be attached to a class declaration.",UnexpectedLexicalDeclaration:"Lexical declaration cannot appear in a single-statement context.",UnexpectedNewTarget:"`new.target` can only be used in functions or class properties.",UnexpectedNumericSeparator:"A numeric separator is only allowed between two digits.",UnexpectedPrivateField:"Unexpected private name.",UnexpectedReservedWord:({reservedWord})=>`Unexpected reserved word '${reservedWord}'.`,UnexpectedSuper:"'super' is only allowed in object methods and classes.",UnexpectedToken:({expected,unexpected})=>`Unexpected token${unexpected?` '${unexpected}'.`:""}${expected?`, expected "${expected}"`:""}`,UnexpectedTokenUnaryExponentiation:"Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",UnexpectedUsingDeclaration:"Using declaration cannot appear in the top level when source type is `script`.",UnsupportedBind:"Binding should be performed on object property.",UnsupportedDecoratorExport:"A decorated export must export a class declaration.",UnsupportedDefaultExport:"Only expressions, functions or classes are allowed as the `default` export.",UnsupportedImport:"`import` can only be used in `import()` or `import.meta`.",UnsupportedMetaProperty:({target,onlyValidPropertyName})=>`The only valid meta property for ${target} is ${target}.${onlyValidPropertyName}.`,UnsupportedParameterDecorator:"Decorators cannot be used to decorate parameters.",UnsupportedPropertyDecorator:"Decorators cannot be used to decorate object literal properties.",UnsupportedSuper:"'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",UnterminatedComment:"Unterminated comment.",UnterminatedRegExp:"Unterminated regular expression.",UnterminatedString:"Unterminated string constant.",UnterminatedTemplate:"Unterminated template.",UsingDeclarationExport:"Using declaration cannot be exported.",UsingDeclarationHasBindingPattern:"Using declaration cannot have destructuring patterns.",VarRedeclaration:({identifierName})=>`Identifier '${identifierName}' has already been declared.`,YieldBindingIdentifier:"Can not use 'yield' as identifier inside a generator.",YieldInParameter:"Yield expression is not allowed in formal parameters.",ZeroDigitNumericSeparator:"Numeric separator can not be used after leading 0."};const UnparenthesizedPipeBodyDescriptions=new Set(["ArrowFunctionExpression","AssignmentExpression","ConditionalExpression","YieldExpression"]);var PipelineOperatorErrors={PipeBodyIsTighter:"Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",PipeTopicRequiresHackPipes:'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',PipeTopicUnbound:"Topic reference is unbound; it must be inside a pipe body.",PipeTopicUnconfiguredToken:({token})=>`Invalid topic token ${token}. In order to use ${token} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${token}" }.`,PipeTopicUnused:"Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",PipeUnparenthesizedBody:({type})=>`Hack-style pipe body cannot be an unparenthesized ${toNodeDescription({type})}; please wrap it in parentheses.`,PipelineBodyNoArrow:'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',PipelineBodySequenceExpression:"Pipeline body may not be a comma-separated sequence expression.",PipelineHeadSequenceExpression:"Pipeline head should not be a comma-separated sequence expression.",PipelineTopicUnused:"Pipeline is in topic style but does not use topic reference.",PrimaryTopicNotAllowed:"Topic reference was used in a lexical context without topic binding.",PrimaryTopicRequiresSmartPipeline:'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'};const _excluded=["message"];function defineHidden(obj,key,value){Object.defineProperty(obj,key,{enumerable:false,configurable:true,value});}function toParseErrorConstructor({toMessage,code,reasonCode,syntaxPlugin}){const hasMissingPlugin="MissingPlugin"===reasonCode||"MissingOneOfPlugins"===reasonCode;{const oldReasonCodes={AccessorCannotDeclareThisParameter:"AccesorCannotDeclareThisParameter",AccessorCannotHaveTypeParameters:"AccesorCannotHaveTypeParameters",ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference:"ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference",SetAccessorCannotHaveOptionalParameter:"SetAccesorCannotHaveOptionalParameter",SetAccessorCannotHaveRestParameter:"SetAccesorCannotHaveRestParameter",SetAccessorCannotHaveReturnType:"SetAccesorCannotHaveReturnType"};oldReasonCodes[reasonCode]&&(reasonCode=oldReasonCodes[reasonCode]);}return function constructor(loc,details){const error=new SyntaxError;return error.code=code,error.reasonCode=reasonCode,error.loc=loc,error.pos=loc.index,error.syntaxPlugin=syntaxPlugin,hasMissingPlugin&&(error.missingPlugin=details.missingPlugin),defineHidden(error,"clone",(function(overrides={}){var _overrides$loc;const{line,column,index}=null!=(_overrides$loc=overrides.loc)?_overrides$loc:loc;return constructor(new Position(line,column,index),Object.assign({},details,overrides.details))})),defineHidden(error,"details",details),Object.defineProperty(error,"message",{configurable:true,get(){const message=`${toMessage(details)} (${loc.line}:${loc.column})`;return this.message=message,message},set(value){Object.defineProperty(this,"message",{value,writable:true});}}),error}}function ParseErrorEnum(argument,syntaxPlugin){if(Array.isArray(argument))return parseErrorTemplates=>ParseErrorEnum(parseErrorTemplates,argument[0]);const ParseErrorConstructors={};for(const reasonCode of Object.keys(argument)){const template=argument[reasonCode],_ref="string"==typeof template?{message:()=>template}:"function"==typeof template?{message:template}:template,{message}=_ref,rest=_objectWithoutPropertiesLoose(_ref,_excluded),toMessage="string"==typeof message?()=>message:message;ParseErrorConstructors[reasonCode]=toParseErrorConstructor(Object.assign({code:"BABEL_PARSER_SYNTAX_ERROR",reasonCode,toMessage},syntaxPlugin?{syntaxPlugin}:{},rest));}return ParseErrorConstructors}const Errors=Object.assign({},ParseErrorEnum(ModuleErrors),ParseErrorEnum(StandardErrors),ParseErrorEnum({StrictDelete:"Deleting local variable in strict mode.",StrictEvalArguments:({referenceName})=>`Assigning to '${referenceName}' in strict mode.`,StrictEvalArgumentsBinding:({bindingName})=>`Binding '${bindingName}' in strict mode.`,StrictFunction:"In strict mode code, functions can only be declared at top level or inside a block.",StrictNumericEscape:"The only valid numeric escape in strict mode is '\\0'.",StrictOctalLiteral:"Legacy octal literals are not allowed in strict mode.",StrictWith:"'with' in strict mode."}),ParseErrorEnum`pipelineOperator`(PipelineOperatorErrors)),{defineProperty}=Object,toUnenumerable=(object,key)=>{object&&defineProperty(object,key,{enumerable:false,value:object[key]});};function toESTreeLocation(node){return toUnenumerable(node.loc.start,"index"),toUnenumerable(node.loc.end,"index"),node}class TokContext{constructor(token,preserveSpace){this.token=void 0,this.preserveSpace=void 0,this.token=token,this.preserveSpace=!!preserveSpace;}}const types={brace:new TokContext("{"),j_oTag:new TokContext("<tag"),j_cTag:new TokContext("</tag"),j_expr:new TokContext("<tag>...</tag>",true)};types.template=new TokContext("`",true);class ExportedTokenType{constructor(label,conf={}){this.label=void 0,this.keyword=void 0,this.beforeExpr=void 0,this.startsExpr=void 0,this.rightAssociative=void 0,this.isLoop=void 0,this.isAssign=void 0,this.prefix=void 0,this.postfix=void 0,this.binop=void 0,this.label=label,this.keyword=conf.keyword,this.beforeExpr=!!conf.beforeExpr,this.startsExpr=!!conf.startsExpr,this.rightAssociative=!!conf.rightAssociative,this.isLoop=!!conf.isLoop,this.isAssign=!!conf.isAssign,this.prefix=!!conf.prefix,this.postfix=!!conf.postfix,this.binop=null!=conf.binop?conf.binop:null,this.updateContext=null;}}const keywords$1=new Map;function createKeyword(name,options={}){options.keyword=name;const token=createToken(name,options);return keywords$1.set(name,token),token}function createBinop(name,binop){return createToken(name,{beforeExpr:true,binop})}let tokenTypeCounter=-1;const tokenTypes=[],tokenLabels=[],tokenBinops=[],tokenBeforeExprs=[],tokenStartsExprs=[],tokenPrefixes=[];function createToken(name,options={}){var _options$binop,_options$beforeExpr,_options$startsExpr,_options$prefix;return ++tokenTypeCounter,tokenLabels.push(name),tokenBinops.push(null!=(_options$binop=options.binop)?_options$binop:-1),tokenBeforeExprs.push(null!=(_options$beforeExpr=options.beforeExpr)&&_options$beforeExpr),tokenStartsExprs.push(null!=(_options$startsExpr=options.startsExpr)&&_options$startsExpr),tokenPrefixes.push(null!=(_options$prefix=options.prefix)&&_options$prefix),tokenTypes.push(new ExportedTokenType(name,options)),tokenTypeCounter}function createKeywordLike(name,options={}){var _options$binop2,_options$beforeExpr2,_options$startsExpr2,_options$prefix2;return ++tokenTypeCounter,keywords$1.set(name,tokenTypeCounter),tokenLabels.push(name),tokenBinops.push(null!=(_options$binop2=options.binop)?_options$binop2:-1),tokenBeforeExprs.push(null!=(_options$beforeExpr2=options.beforeExpr)&&_options$beforeExpr2),tokenStartsExprs.push(null!=(_options$startsExpr2=options.startsExpr)&&_options$startsExpr2),tokenPrefixes.push(null!=(_options$prefix2=options.prefix)&&_options$prefix2),tokenTypes.push(new ExportedTokenType("name",options)),tokenTypeCounter}const tt={bracketL:createToken("[",{beforeExpr:true,startsExpr:true}),bracketHashL:createToken("#[",{beforeExpr:true,startsExpr:true}),bracketBarL:createToken("[|",{beforeExpr:true,startsExpr:true}),bracketR:createToken("]"),bracketBarR:createToken("|]"),braceL:createToken("{",{beforeExpr:true,startsExpr:true}),braceBarL:createToken("{|",{beforeExpr:true,startsExpr:true}),braceHashL:createToken("#{",{beforeExpr:true,startsExpr:true}),braceR:createToken("}"),braceBarR:createToken("|}"),parenL:createToken("(",{beforeExpr:true,startsExpr:true}),parenR:createToken(")"),comma:createToken(",",{beforeExpr:true}),semi:createToken(";",{beforeExpr:true}),colon:createToken(":",{beforeExpr:true}),doubleColon:createToken("::",{beforeExpr:true}),dot:createToken("."),question:createToken("?",{beforeExpr:true}),questionDot:createToken("?."),arrow:createToken("=>",{beforeExpr:true}),template:createToken("template"),ellipsis:createToken("...",{beforeExpr:true}),backQuote:createToken("`",{startsExpr:true}),dollarBraceL:createToken("${",{beforeExpr:true,startsExpr:true}),templateTail:createToken("...`",{startsExpr:true}),templateNonTail:createToken("...${",{beforeExpr:true,startsExpr:true}),at:createToken("@"),hash:createToken("#",{startsExpr:true}),interpreterDirective:createToken("#!..."),eq:createToken("=",{beforeExpr:true,isAssign:true}),assign:createToken("_=",{beforeExpr:true,isAssign:true}),slashAssign:createToken("_=",{beforeExpr:true,isAssign:true}),xorAssign:createToken("_=",{beforeExpr:true,isAssign:true}),moduloAssign:createToken("_=",{beforeExpr:true,isAssign:true}),incDec:createToken("++/--",{prefix:true,postfix:true,startsExpr:true}),bang:createToken("!",{beforeExpr:true,prefix:true,startsExpr:true}),tilde:createToken("~",{beforeExpr:true,prefix:true,startsExpr:true}),doubleCaret:createToken("^^",{startsExpr:true}),doubleAt:createToken("@@",{startsExpr:true}),pipeline:createBinop("|>",0),nullishCoalescing:createBinop("??",1),logicalOR:createBinop("||",1),logicalAND:createBinop("&&",2),bitwiseOR:createBinop("|",3),bitwiseXOR:createBinop("^",4),bitwiseAND:createBinop("&",5),equality:createBinop("==/!=/===/!==",6),lt:createBinop("</>/<=/>=",7),gt:createBinop("</>/<=/>=",7),relational:createBinop("</>/<=/>=",7),bitShift:createBinop("<</>>/>>>",8),bitShiftL:createBinop("<</>>/>>>",8),bitShiftR:createBinop("<</>>/>>>",8),plusMin:createToken("+/-",{beforeExpr:true,binop:9,prefix:true,startsExpr:true}),modulo:createToken("%",{binop:10,startsExpr:true}),star:createToken("*",{binop:10}),slash:createBinop("/",10),exponent:createToken("**",{beforeExpr:true,binop:11,rightAssociative:true}),_in:createKeyword("in",{beforeExpr:true,binop:7}),_instanceof:createKeyword("instanceof",{beforeExpr:true,binop:7}),_break:createKeyword("break"),_case:createKeyword("case",{beforeExpr:true}),_catch:createKeyword("catch"),_continue:createKeyword("continue"),_debugger:createKeyword("debugger"),_default:createKeyword("default",{beforeExpr:true}),_else:createKeyword("else",{beforeExpr:true}),_finally:createKeyword("finally"),_function:createKeyword("function",{startsExpr:true}),_if:createKeyword("if"),_return:createKeyword("return",{beforeExpr:true}),_switch:createKeyword("switch"),_throw:createKeyword("throw",{beforeExpr:true,prefix:true,startsExpr:true}),_try:createKeyword("try"),_var:createKeyword("var"),_const:createKeyword("const"),_with:createKeyword("with"),_new:createKeyword("new",{beforeExpr:true,startsExpr:true}),_this:createKeyword("this",{startsExpr:true}),_super:createKeyword("super",{startsExpr:true}),_class:createKeyword("class",{startsExpr:true}),_extends:createKeyword("extends",{beforeExpr:true}),_export:createKeyword("export"),_import:createKeyword("import",{startsExpr:true}),_null:createKeyword("null",{startsExpr:true}),_true:createKeyword("true",{startsExpr:true}),_false:createKeyword("false",{startsExpr:true}),_typeof:createKeyword("typeof",{beforeExpr:true,prefix:true,startsExpr:true}),_void:createKeyword("void",{beforeExpr:true,prefix:true,startsExpr:true}),_delete:createKeyword("delete",{beforeExpr:true,prefix:true,startsExpr:true}),_do:createKeyword("do",{isLoop:true,beforeExpr:true}),_for:createKeyword("for",{isLoop:true}),_while:createKeyword("while",{isLoop:true}),_as:createKeywordLike("as",{startsExpr:true}),_assert:createKeywordLike("assert",{startsExpr:true}),_async:createKeywordLike("async",{startsExpr:true}),_await:createKeywordLike("await",{startsExpr:true}),_defer:createKeywordLike("defer",{startsExpr:true}),_from:createKeywordLike("from",{startsExpr:true}),_get:createKeywordLike("get",{startsExpr:true}),_let:createKeywordLike("let",{startsExpr:true}),_meta:createKeywordLike("meta",{startsExpr:true}),_of:createKeywordLike("of",{startsExpr:true}),_sent:createKeywordLike("sent",{startsExpr:true}),_set:createKeywordLike("set",{startsExpr:true}),_source:createKeywordLike("source",{startsExpr:true}),_static:createKeywordLike("static",{startsExpr:true}),_using:createKeywordLike("using",{startsExpr:true}),_yield:createKeywordLike("yield",{startsExpr:true}),_asserts:createKeywordLike("asserts",{startsExpr:true}),_checks:createKeywordLike("checks",{startsExpr:true}),_exports:createKeywordLike("exports",{startsExpr:true}),_global:createKeywordLike("global",{startsExpr:true}),_implements:createKeywordLike("implements",{startsExpr:true}),_intrinsic:createKeywordLike("intrinsic",{startsExpr:true}),_infer:createKeywordLike("infer",{startsExpr:true}),_is:createKeywordLike("is",{startsExpr:true}),_mixins:createKeywordLike("mixins",{startsExpr:true}),_proto:createKeywordLike("proto",{startsExpr:true}),_require:createKeywordLike("require",{startsExpr:true}),_satisfies:createKeywordLike("satisfies",{startsExpr:true}),_keyof:createKeywordLike("keyof",{startsExpr:true}),_readonly:createKeywordLike("readonly",{startsExpr:true}),_unique:createKeywordLike("unique",{startsExpr:true}),_abstract:createKeywordLike("abstract",{startsExpr:true}),_declare:createKeywordLike("declare",{startsExpr:true}),_enum:createKeywordLike("enum",{startsExpr:true}),_module:createKeywordLike("module",{startsExpr:true}),_namespace:createKeywordLike("namespace",{startsExpr:true}),_interface:createKeywordLike("interface",{startsExpr:true}),_type:createKeywordLike("type",{startsExpr:true}),_opaque:createKeywordLike("opaque",{startsExpr:true}),name:createToken("name",{startsExpr:true}),placeholder:createToken("%%",{startsExpr:true}),string:createToken("string",{startsExpr:true}),num:createToken("num",{startsExpr:true}),bigint:createToken("bigint",{startsExpr:true}),decimal:createToken("decimal",{startsExpr:true}),regexp:createToken("regexp",{startsExpr:true}),privateName:createToken("#name",{startsExpr:true}),eof:createToken("eof"),jsxName:createToken("jsxName"),jsxText:createToken("jsxText",{beforeExpr:true}),jsxTagStart:createToken("jsxTagStart",{startsExpr:true}),jsxTagEnd:createToken("jsxTagEnd")};function tokenIsIdentifier(token){return token>=93&&token<=133}function tokenIsKeywordOrIdentifier(token){return token>=58&&token<=133}function tokenIsLiteralPropertyName(token){return token>=58&&token<=137}function tokenCanStartExpression(token){return tokenStartsExprs[token]}function tokenIsFlowInterfaceOrTypeOrOpaque(token){return token>=129&&token<=131}function tokenIsKeyword(token){return token>=58&&token<=92}function tokenLabelName(token){return tokenLabels[token]}function tokenOperatorPrecedence(token){return tokenBinops[token]}function tokenIsTemplate(token){return token>=24&&token<=25}function getExportedToken(token){return tokenTypes[token]}tokenTypes[8].updateContext=context=>{context.pop();},tokenTypes[5].updateContext=tokenTypes[7].updateContext=tokenTypes[23].updateContext=context=>{context.push(types.brace);},tokenTypes[22].updateContext=context=>{context[context.length-1]===types.template?context.pop():context.push(types.template);},tokenTypes[143].updateContext=context=>{context.push(types.j_expr,types.j_oTag);};let nonASCIIidentifierStartChars="------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------",nonASCIIidentifierChars="-----------------------------------------------------------------------------------------------------------------------------------------------------";const nonASCIIidentifierStart=new RegExp("["+nonASCIIidentifierStartChars+"]"),nonASCIIidentifier=new RegExp("["+nonASCIIidentifierStartChars+nonASCIIidentifierChars+"]");nonASCIIidentifierStartChars=nonASCIIidentifierChars=null;const astralIdentifierStartCodes=[0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,13,10,2,14,2,6,2,1,2,10,2,14,2,6,2,1,4,51,13,310,10,21,11,7,25,5,2,41,2,8,70,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,39,27,10,22,251,41,7,1,17,2,60,28,11,0,9,21,43,17,47,20,28,22,13,52,58,1,3,0,14,44,33,24,27,35,30,0,3,0,9,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,20,1,64,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,31,9,2,0,3,0,2,37,2,0,26,0,2,0,45,52,19,3,21,2,31,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,38,6,186,43,117,63,32,7,3,0,3,7,2,1,2,23,16,0,2,0,95,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,19,72,200,32,32,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,16,0,2,12,2,33,125,0,80,921,103,110,18,195,2637,96,16,1071,18,5,26,3994,6,582,6842,29,1763,568,8,30,18,78,18,29,19,47,17,3,32,20,6,18,433,44,212,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,1237,42,9,8936,3,2,6,2,1,2,290,16,0,30,2,3,0,15,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,1845,30,7,5,262,61,147,44,11,6,17,0,322,29,19,43,485,27,229,29,3,0,496,6,2,3,2,1,2,14,2,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42719,33,4153,7,221,3,5761,15,7472,16,621,2467,541,1507,4938,6,4191],astralIdentifierCodes=[509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,7,9,32,4,318,1,80,3,71,10,50,3,123,2,54,14,32,10,3,1,11,3,46,10,8,0,46,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,2,11,83,11,7,0,3,0,158,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,68,8,2,0,3,0,2,3,2,4,2,0,15,1,83,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,7,19,58,14,5,9,243,14,166,9,71,5,2,1,3,3,2,0,2,1,13,9,120,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,343,9,54,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,10,1,2,0,49,6,4,4,14,10,5350,0,7,14,11465,27,2343,9,87,9,39,4,60,6,26,9,535,9,470,0,2,54,8,3,82,0,12,1,19628,1,4178,9,519,45,3,22,543,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,101,0,161,6,10,9,357,0,62,13,499,13,245,1,2,9,726,6,110,6,6,9,4759,9,787719,239];function isInAstralSet(code,set){let pos=65536;for(let i=0,length=set.length;i<length;i+=2){if(pos+=set[i],pos>code)return  false;if(pos+=set[i+1],pos>=code)return  true}return  false}function isIdentifierStart(code){return code<65?36===code:code<=90||(code<97?95===code:code<=122||(code<=65535?code>=170&&nonASCIIidentifierStart.test(String.fromCharCode(code)):isInAstralSet(code,astralIdentifierStartCodes)))}function isIdentifierChar(code){return code<48?36===code:code<58||!(code<65)&&(code<=90||(code<97?95===code:code<=122||(code<=65535?code>=170&&nonASCIIidentifier.test(String.fromCharCode(code)):isInAstralSet(code,astralIdentifierStartCodes)||isInAstralSet(code,astralIdentifierCodes))))}const reservedWords_strict=["implements","interface","let","package","private","protected","public","static","yield"],reservedWords_strictBind=["eval","arguments"],keywords=new Set(["break","case","catch","continue","debugger","default","do","else","finally","for","function","if","return","switch","throw","try","var","const","while","with","new","this","super","class","extends","export","import","null","true","false","in","instanceof","typeof","void","delete"]),reservedWordsStrictSet=new Set(reservedWords_strict),reservedWordsStrictBindSet=new Set(reservedWords_strictBind);function isReservedWord(word,inModule){return inModule&&"await"===word||"enum"===word}function isStrictReservedWord(word,inModule){return isReservedWord(word,inModule)||reservedWordsStrictSet.has(word)}function isStrictBindOnlyReservedWord(word){return reservedWordsStrictBindSet.has(word)}function isStrictBindReservedWord(word,inModule){return isStrictReservedWord(word,inModule)||isStrictBindOnlyReservedWord(word)}const reservedWordLikeSet=new Set(["break","case","catch","continue","debugger","default","do","else","finally","for","function","if","return","switch","throw","try","var","const","while","with","new","this","super","class","extends","export","import","null","true","false","in","instanceof","typeof","void","delete","implements","interface","let","package","private","protected","public","static","yield","eval","arguments","enum","await"]);class Scope{constructor(flags){this.flags=0,this.names=new Map,this.firstLexicalName="",this.flags=flags;}}class ScopeHandler{constructor(parser,inModule){this.parser=void 0,this.scopeStack=[],this.inModule=void 0,this.undefinedExports=new Map,this.parser=parser,this.inModule=inModule;}get inTopLevel(){return (1&this.currentScope().flags)>0}get inFunction(){return (2&this.currentVarScopeFlags())>0}get allowSuper(){return (16&this.currentThisScopeFlags())>0}get allowDirectSuper(){return (32&this.currentThisScopeFlags())>0}get inClass(){return (64&this.currentThisScopeFlags())>0}get inClassAndNotInNonArrowFunction(){const flags=this.currentThisScopeFlags();return (64&flags)>0&&!(2&flags)}get inStaticBlock(){for(let i=this.scopeStack.length-1;;i--){const{flags}=this.scopeStack[i];if(128&flags)return  true;if(451&flags)return  false}}get inNonArrowFunction(){return (2&this.currentThisScopeFlags())>0}get treatFunctionsAsVar(){return this.treatFunctionsAsVarInScope(this.currentScope())}createScope(flags){return new Scope(flags)}enter(flags){this.scopeStack.push(this.createScope(flags));}exit(){return this.scopeStack.pop().flags}treatFunctionsAsVarInScope(scope){return !!(130&scope.flags||!this.parser.inModule&&1&scope.flags)}declareName(name,bindingType,loc){let scope=this.currentScope();if(8&bindingType||16&bindingType){this.checkRedeclarationInScope(scope,name,bindingType,loc);let type=scope.names.get(name)||0;16&bindingType?type|=4:(scope.firstLexicalName||(scope.firstLexicalName=name),type|=2),scope.names.set(name,type),8&bindingType&&this.maybeExportDefined(scope,name);}else if(4&bindingType)for(let i=this.scopeStack.length-1;i>=0&&(scope=this.scopeStack[i],this.checkRedeclarationInScope(scope,name,bindingType,loc),scope.names.set(name,1|(scope.names.get(name)||0)),this.maybeExportDefined(scope,name),!(387&scope.flags));--i);this.parser.inModule&&1&scope.flags&&this.undefinedExports.delete(name);}maybeExportDefined(scope,name){this.parser.inModule&&1&scope.flags&&this.undefinedExports.delete(name);}checkRedeclarationInScope(scope,name,bindingType,loc){this.isRedeclaredInScope(scope,name,bindingType)&&this.parser.raise(Errors.VarRedeclaration,loc,{identifierName:name});}isRedeclaredInScope(scope,name,bindingType){if(!(1&bindingType))return  false;if(8&bindingType)return scope.names.has(name);const type=scope.names.get(name);return 16&bindingType?(2&type)>0||!this.treatFunctionsAsVarInScope(scope)&&(1&type)>0:(2&type)>0&&!(8&scope.flags&&scope.firstLexicalName===name)||!this.treatFunctionsAsVarInScope(scope)&&(4&type)>0}checkLocalExport(id){const{name}=id;this.scopeStack[0].names.has(name)||this.undefinedExports.set(name,id.loc.start);}currentScope(){return this.scopeStack[this.scopeStack.length-1]}currentVarScopeFlags(){for(let i=this.scopeStack.length-1;;i--){const{flags}=this.scopeStack[i];if(387&flags)return flags}}currentThisScopeFlags(){for(let i=this.scopeStack.length-1;;i--){const{flags}=this.scopeStack[i];if(451&flags&&!(4&flags))return flags}}}class FlowScope extends Scope{constructor(...args){super(...args),this.declareFunctions=new Set;}}class FlowScopeHandler extends ScopeHandler{createScope(flags){return new FlowScope(flags)}declareName(name,bindingType,loc){const scope=this.currentScope();if(2048&bindingType)return this.checkRedeclarationInScope(scope,name,bindingType,loc),this.maybeExportDefined(scope,name),void scope.declareFunctions.add(name);super.declareName(name,bindingType,loc);}isRedeclaredInScope(scope,name,bindingType){if(super.isRedeclaredInScope(scope,name,bindingType))return  true;if(2048&bindingType&&!scope.declareFunctions.has(name)){const type=scope.names.get(name);return (4&type)>0||(2&type)>0}return  false}checkLocalExport(id){this.scopeStack[0].declareFunctions.has(id.name)||super.checkLocalExport(id);}}class BaseParser{constructor(){this.sawUnambiguousESM=false,this.ambiguousScriptDifferentAst=false;}sourceToOffsetPos(sourcePos){return sourcePos+this.startIndex}offsetToSourcePos(offsetPos){return offsetPos-this.startIndex}hasPlugin(pluginConfig){if("string"==typeof pluginConfig)return this.plugins.has(pluginConfig);{const[pluginName,pluginOptions]=pluginConfig;if(!this.hasPlugin(pluginName))return  false;const actualOptions=this.plugins.get(pluginName);for(const key of Object.keys(pluginOptions))if((null==actualOptions?void 0:actualOptions[key])!==pluginOptions[key])return  false;return  true}}getPluginOption(plugin,name){var _this$plugins$get;return null==(_this$plugins$get=this.plugins.get(plugin))?void 0:_this$plugins$get[name]}}function setTrailingComments(node,comments){ void 0===node.trailingComments?node.trailingComments=comments:node.trailingComments.unshift(...comments);}function setInnerComments(node,comments){ void 0===node.innerComments?node.innerComments=comments:node.innerComments.unshift(...comments);}function adjustInnerComments(node,elements,commentWS){let lastElement=null,i=elements.length;for(;null===lastElement&&i>0;)lastElement=elements[--i];null===lastElement||lastElement.start>commentWS.start?setInnerComments(node,commentWS.comments):setTrailingComments(lastElement,commentWS.comments);}class CommentsParser extends BaseParser{addComment(comment){this.filename&&(comment.loc.filename=this.filename);const{commentsLen}=this.state;this.comments.length!==commentsLen&&(this.comments.length=commentsLen),this.comments.push(comment),this.state.commentsLen++;}processComment(node){const{commentStack}=this.state,commentStackLength=commentStack.length;if(0===commentStackLength)return;let i=commentStackLength-1;const lastCommentWS=commentStack[i];lastCommentWS.start===node.end&&(lastCommentWS.leadingNode=node,i--);const{start:nodeStart}=node;for(;i>=0;i--){const commentWS=commentStack[i],commentEnd=commentWS.end;if(!(commentEnd>nodeStart)){commentEnd===nodeStart&&(commentWS.trailingNode=node);break}commentWS.containingNode=node,this.finalizeComment(commentWS),commentStack.splice(i,1);}}finalizeComment(commentWS){const{comments}=commentWS;if(null!==commentWS.leadingNode||null!==commentWS.trailingNode)null!==commentWS.leadingNode&&setTrailingComments(commentWS.leadingNode,comments),null!==commentWS.trailingNode&&function(node,comments){ void 0===node.leadingComments?node.leadingComments=comments:node.leadingComments.unshift(...comments);}(commentWS.trailingNode,comments);else {const{containingNode:node,start:commentStart}=commentWS;if(44===this.input.charCodeAt(this.offsetToSourcePos(commentStart)-1))switch(node.type){case "ObjectExpression":case "ObjectPattern":case "RecordExpression":adjustInnerComments(node,node.properties,commentWS);break;case "CallExpression":case "OptionalCallExpression":adjustInnerComments(node,node.arguments,commentWS);break;case "FunctionDeclaration":case "FunctionExpression":case "ArrowFunctionExpression":case "ObjectMethod":case "ClassMethod":case "ClassPrivateMethod":adjustInnerComments(node,node.params,commentWS);break;case "ArrayExpression":case "ArrayPattern":case "TupleExpression":adjustInnerComments(node,node.elements,commentWS);break;case "ExportNamedDeclaration":case "ImportDeclaration":adjustInnerComments(node,node.specifiers,commentWS);break;default:setInnerComments(node,comments);}else setInnerComments(node,comments);}}finalizeRemainingComments(){const{commentStack}=this.state;for(let i=commentStack.length-1;i>=0;i--)this.finalizeComment(commentStack[i]);this.state.commentStack=[];}resetPreviousNodeTrailingComments(node){const{commentStack}=this.state,{length}=commentStack;if(0===length)return;const commentWS=commentStack[length-1];commentWS.leadingNode===node&&(commentWS.leadingNode=null);}resetPreviousIdentifierLeadingComments(node){const{commentStack}=this.state,{length}=commentStack;0!==length&&(commentStack[length-1].trailingNode===node?commentStack[length-1].trailingNode=null:length>=2&&commentStack[length-2].trailingNode===node&&(commentStack[length-2].trailingNode=null));}takeSurroundingComments(node,start,end){const{commentStack}=this.state,commentStackLength=commentStack.length;if(0===commentStackLength)return;let i=commentStackLength-1;for(;i>=0;i--){const commentWS=commentStack[i],commentEnd=commentWS.end;if(commentWS.start===end)commentWS.leadingNode=node;else if(commentEnd===start)commentWS.trailingNode=node;else if(commentEnd<start)break}}}const lineBreakG=new RegExp(/\r\n|[\r\n\u2028\u2029]/.source,"g");function isNewLine(code){switch(code){case 10:case 13:case 8232:case 8233:return  true;default:return  false}}function hasNewLine(input,start,end){for(let i=start;i<end;i++)if(isNewLine(input.charCodeAt(i)))return  true;return  false}const skipWhiteSpace=/(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g,skipWhiteSpaceInLine=/(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g;function isWhitespace(code){switch(code){case 9:case 11:case 12:case 32:case 160:case 5760:case 8192:case 8193:case 8194:case 8195:case 8196:case 8197:case 8198:case 8199:case 8200:case 8201:case 8202:case 8239:case 8287:case 12288:case 65279:return  true;default:return  false}}class State{constructor(){this.flags=1024,this.startIndex=void 0,this.curLine=void 0,this.lineStart=void 0,this.startLoc=void 0,this.endLoc=void 0,this.errors=[],this.potentialArrowAt=-1,this.noArrowAt=[],this.noArrowParamsConversionAt=[],this.topicContext={maxNumOfResolvableTopics:0,maxTopicIndex:null},this.labels=[],this.commentsLen=0,this.commentStack=[],this.pos=0,this.type=140,this.value=null,this.start=0,this.end=0,this.lastTokEndLoc=null,this.lastTokStartLoc=null,this.context=[types.brace],this.firstInvalidTemplateEscapePos=null,this.strictErrors=new Map,this.tokensLength=0;}get strict(){return (1&this.flags)>0}set strict(v){v?this.flags|=1:this.flags&=-2;}init({strictMode,sourceType,startIndex,startLine,startColumn}){this.strict=false!==strictMode&&(true===strictMode||"module"===sourceType),this.startIndex=startIndex,this.curLine=startLine,this.lineStart=-startColumn,this.startLoc=this.endLoc=new Position(startLine,startColumn,startIndex);}get maybeInArrowParameters(){return (2&this.flags)>0}set maybeInArrowParameters(v){v?this.flags|=2:this.flags&=-3;}get inType(){return (4&this.flags)>0}set inType(v){v?this.flags|=4:this.flags&=-5;}get noAnonFunctionType(){return (8&this.flags)>0}set noAnonFunctionType(v){v?this.flags|=8:this.flags&=-9;}get hasFlowComment(){return (16&this.flags)>0}set hasFlowComment(v){v?this.flags|=16:this.flags&=-17;}get isAmbientContext(){return (32&this.flags)>0}set isAmbientContext(v){v?this.flags|=32:this.flags&=-33;}get inAbstractClass(){return (64&this.flags)>0}set inAbstractClass(v){v?this.flags|=64:this.flags&=-65;}get inDisallowConditionalTypesContext(){return (128&this.flags)>0}set inDisallowConditionalTypesContext(v){v?this.flags|=128:this.flags&=-129;}get soloAwait(){return (256&this.flags)>0}set soloAwait(v){v?this.flags|=256:this.flags&=-257;}get inFSharpPipelineDirectBody(){return (512&this.flags)>0}set inFSharpPipelineDirectBody(v){v?this.flags|=512:this.flags&=-513;}get canStartJSXElement(){return (1024&this.flags)>0}set canStartJSXElement(v){v?this.flags|=1024:this.flags&=-1025;}get containsEsc(){return (2048&this.flags)>0}set containsEsc(v){v?this.flags|=2048:this.flags&=-2049;}get hasTopLevelAwait(){return (4096&this.flags)>0}set hasTopLevelAwait(v){v?this.flags|=4096:this.flags&=-4097;}curPosition(){return new Position(this.curLine,this.pos-this.lineStart,this.pos+this.startIndex)}clone(){const state=new State;return state.flags=this.flags,state.startIndex=this.startIndex,state.curLine=this.curLine,state.lineStart=this.lineStart,state.startLoc=this.startLoc,state.endLoc=this.endLoc,state.errors=this.errors.slice(),state.potentialArrowAt=this.potentialArrowAt,state.noArrowAt=this.noArrowAt.slice(),state.noArrowParamsConversionAt=this.noArrowParamsConversionAt.slice(),state.topicContext=this.topicContext,state.labels=this.labels.slice(),state.commentsLen=this.commentsLen,state.commentStack=this.commentStack.slice(),state.pos=this.pos,state.type=this.type,state.value=this.value,state.start=this.start,state.end=this.end,state.lastTokEndLoc=this.lastTokEndLoc,state.lastTokStartLoc=this.lastTokStartLoc,state.context=this.context.slice(),state.firstInvalidTemplateEscapePos=this.firstInvalidTemplateEscapePos,state.strictErrors=this.strictErrors,state.tokensLength=this.tokensLength,state}}var _isDigit=function(code){return code>=48&&code<=57};const forbiddenNumericSeparatorSiblings={decBinOct:new Set([46,66,69,79,95,98,101,111]),hex:new Set([46,88,95,120])},isAllowedNumericSeparatorSibling={bin:ch=>48===ch||49===ch,oct:ch=>ch>=48&&ch<=55,dec:ch=>ch>=48&&ch<=57,hex:ch=>ch>=48&&ch<=57||ch>=65&&ch<=70||ch>=97&&ch<=102};function readStringContents(type,input,pos,lineStart,curLine,errors){const initialPos=pos,initialLineStart=lineStart,initialCurLine=curLine;let out="",firstInvalidLoc=null,chunkStart=pos;const{length}=input;for(;;){if(pos>=length){errors.unterminated(initialPos,initialLineStart,initialCurLine),out+=input.slice(chunkStart,pos);break}const ch=input.charCodeAt(pos);if(isStringEnd(type,ch,input,pos)){out+=input.slice(chunkStart,pos);break}if(92===ch){out+=input.slice(chunkStart,pos);const res=readEscapedChar(input,pos,lineStart,curLine,"template"===type,errors);null!==res.ch||firstInvalidLoc?out+=res.ch:firstInvalidLoc={pos,lineStart,curLine},({pos,lineStart,curLine}=res),chunkStart=pos;}else 8232===ch||8233===ch?(++curLine,lineStart=++pos):10===ch||13===ch?"template"===type?(out+=input.slice(chunkStart,pos)+"\n",++pos,13===ch&&10===input.charCodeAt(pos)&&++pos,++curLine,chunkStart=lineStart=pos):errors.unterminated(initialPos,initialLineStart,initialCurLine):++pos;}return {pos,str:out,firstInvalidLoc,lineStart,curLine,containsInvalid:!!firstInvalidLoc}}function isStringEnd(type,ch,input,pos){return "template"===type?96===ch||36===ch&&123===input.charCodeAt(pos+1):ch===("double"===type?34:39)}function readEscapedChar(input,pos,lineStart,curLine,inTemplate,errors){const throwOnInvalid=!inTemplate;pos++;const res=ch=>({pos,ch,lineStart,curLine}),ch=input.charCodeAt(pos++);switch(ch){case 110:return res("\n");case 114:return res("\r");case 120:{let code;return ({code,pos}=readHexChar(input,pos,lineStart,curLine,2,false,throwOnInvalid,errors)),res(null===code?null:String.fromCharCode(code))}case 117:{let code;return ({code,pos}=readCodePoint(input,pos,lineStart,curLine,throwOnInvalid,errors)),res(null===code?null:String.fromCodePoint(code))}case 116:return res("\t");case 98:return res("\b");case 118:return res("\v");case 102:return res("\f");case 13:10===input.charCodeAt(pos)&&++pos;case 10:lineStart=pos,++curLine;case 8232:case 8233:return res("");case 56:case 57:if(inTemplate)return res(null);errors.strictNumericEscape(pos-1,lineStart,curLine);default:if(ch>=48&&ch<=55){const startPos=pos-1;let octalStr=/^[0-7]+/.exec(input.slice(startPos,pos+2))[0],octal=parseInt(octalStr,8);octal>255&&(octalStr=octalStr.slice(0,-1),octal=parseInt(octalStr,8)),pos+=octalStr.length-1;const next=input.charCodeAt(pos);if("0"!==octalStr||56===next||57===next){if(inTemplate)return res(null);errors.strictNumericEscape(startPos,lineStart,curLine);}return res(String.fromCharCode(octal))}return res(String.fromCharCode(ch))}}function readHexChar(input,pos,lineStart,curLine,len,forceLen,throwOnInvalid,errors){const initialPos=pos;let n;return ({n,pos}=readInt(input,pos,lineStart,curLine,16,len,forceLen,false,errors,!throwOnInvalid)),null===n&&(throwOnInvalid?errors.invalidEscapeSequence(initialPos,lineStart,curLine):pos=initialPos-1),{code:n,pos}}function readInt(input,pos,lineStart,curLine,radix,len,forceLen,allowNumSeparator,errors,bailOnError){const start=pos,forbiddenSiblings=16===radix?forbiddenNumericSeparatorSiblings.hex:forbiddenNumericSeparatorSiblings.decBinOct,isAllowedSibling=16===radix?isAllowedNumericSeparatorSibling.hex:10===radix?isAllowedNumericSeparatorSibling.dec:8===radix?isAllowedNumericSeparatorSibling.oct:isAllowedNumericSeparatorSibling.bin;let invalid=false,total=0;for(let i=0,e=null==len?1/0:len;i<e;++i){const code=input.charCodeAt(pos);let val;if(95!==code||"bail"===allowNumSeparator){if(val=code>=97?code-97+10:code>=65?code-65+10:_isDigit(code)?code-48:1/0,val>=radix){if(val<=9&&bailOnError)return {n:null,pos};if(val<=9&&errors.invalidDigit(pos,lineStart,curLine,radix))val=0;else {if(!forceLen)break;val=0,invalid=true;}}++pos,total=total*radix+val;}else {const prev=input.charCodeAt(pos-1),next=input.charCodeAt(pos+1);if(allowNumSeparator){if(Number.isNaN(next)||!isAllowedSibling(next)||forbiddenSiblings.has(prev)||forbiddenSiblings.has(next)){if(bailOnError)return {n:null,pos};errors.unexpectedNumericSeparator(pos,lineStart,curLine);}}else {if(bailOnError)return {n:null,pos};errors.numericSeparatorInEscapeSequence(pos,lineStart,curLine);}++pos;}}return pos===start||null!=len&&pos-start!==len||invalid?{n:null,pos}:{n:total,pos}}function readCodePoint(input,pos,lineStart,curLine,throwOnInvalid,errors){let code;if(123===input.charCodeAt(pos)){if(++pos,({code,pos}=readHexChar(input,pos,lineStart,curLine,input.indexOf("}",pos)-pos,true,throwOnInvalid,errors)),++pos,null!==code&&code>1114111){if(!throwOnInvalid)return {code:null,pos};errors.invalidCodePoint(pos,lineStart,curLine);}}else ({code,pos}=readHexChar(input,pos,lineStart,curLine,4,false,throwOnInvalid,errors));return {code,pos}}function buildPosition(pos,lineStart,curLine){return new Position(curLine,pos-lineStart,pos)}const VALID_REGEX_FLAGS=new Set([103,109,115,105,121,117,100,118]);class Token{constructor(state){const startIndex=state.startIndex||0;this.type=state.type,this.value=state.value,this.start=startIndex+state.start,this.end=startIndex+state.end,this.loc=new SourceLocation(state.startLoc,state.endLoc);}}class Tokenizer extends CommentsParser{constructor(options,input){super(),this.isLookahead=void 0,this.tokens=[],this.errorHandlers_readInt={invalidDigit:(pos,lineStart,curLine,radix)=>!!this.options.errorRecovery&&(this.raise(Errors.InvalidDigit,buildPosition(pos,lineStart,curLine),{radix}),true),numericSeparatorInEscapeSequence:this.errorBuilder(Errors.NumericSeparatorInEscapeSequence),unexpectedNumericSeparator:this.errorBuilder(Errors.UnexpectedNumericSeparator)},this.errorHandlers_readCodePoint=Object.assign({},this.errorHandlers_readInt,{invalidEscapeSequence:this.errorBuilder(Errors.InvalidEscapeSequence),invalidCodePoint:this.errorBuilder(Errors.InvalidCodePoint)}),this.errorHandlers_readStringContents_string=Object.assign({},this.errorHandlers_readCodePoint,{strictNumericEscape:(pos,lineStart,curLine)=>{this.recordStrictModeErrors(Errors.StrictNumericEscape,buildPosition(pos,lineStart,curLine));},unterminated:(pos,lineStart,curLine)=>{throw this.raise(Errors.UnterminatedString,buildPosition(pos-1,lineStart,curLine))}}),this.errorHandlers_readStringContents_template=Object.assign({},this.errorHandlers_readCodePoint,{strictNumericEscape:this.errorBuilder(Errors.StrictNumericEscape),unterminated:(pos,lineStart,curLine)=>{throw this.raise(Errors.UnterminatedTemplate,buildPosition(pos,lineStart,curLine))}}),this.state=new State,this.state.init(options),this.input=input,this.length=input.length,this.comments=[],this.isLookahead=false;}pushToken(token){this.tokens.length=this.state.tokensLength,this.tokens.push(token),++this.state.tokensLength;}next(){this.checkKeywordEscapes(),this.options.tokens&&this.pushToken(new Token(this.state)),this.state.lastTokEndLoc=this.state.endLoc,this.state.lastTokStartLoc=this.state.startLoc,this.nextToken();}eat(type){return !!this.match(type)&&(this.next(),true)}match(type){return this.state.type===type}createLookaheadState(state){return {pos:state.pos,value:null,type:state.type,start:state.start,end:state.end,context:[this.curContext()],inType:state.inType,startLoc:state.startLoc,lastTokEndLoc:state.lastTokEndLoc,curLine:state.curLine,lineStart:state.lineStart,curPosition:state.curPosition}}lookahead(){const old=this.state;this.state=this.createLookaheadState(old),this.isLookahead=true,this.nextToken(),this.isLookahead=false;const curr=this.state;return this.state=old,curr}nextTokenStart(){return this.nextTokenStartSince(this.state.pos)}nextTokenStartSince(pos){return skipWhiteSpace.lastIndex=pos,skipWhiteSpace.test(this.input)?skipWhiteSpace.lastIndex:pos}lookaheadCharCode(){return this.input.charCodeAt(this.nextTokenStart())}nextTokenInLineStart(){return this.nextTokenInLineStartSince(this.state.pos)}nextTokenInLineStartSince(pos){return skipWhiteSpaceInLine.lastIndex=pos,skipWhiteSpaceInLine.test(this.input)?skipWhiteSpaceInLine.lastIndex:pos}lookaheadInLineCharCode(){return this.input.charCodeAt(this.nextTokenInLineStart())}codePointAtPos(pos){let cp=this.input.charCodeAt(pos);if(55296==(64512&cp)&&++pos<this.input.length){const trail=this.input.charCodeAt(pos);56320==(64512&trail)&&(cp=65536+((1023&cp)<<10)+(1023&trail));}return cp}setStrict(strict){this.state.strict=strict,strict&&(this.state.strictErrors.forEach((([toParseError,at])=>this.raise(toParseError,at))),this.state.strictErrors.clear());}curContext(){return this.state.context[this.state.context.length-1]}nextToken(){this.skipSpace(),this.state.start=this.state.pos,this.isLookahead||(this.state.startLoc=this.state.curPosition()),this.state.pos>=this.length?this.finishToken(140):this.getTokenFromCode(this.codePointAtPos(this.state.pos));}skipBlockComment(commentEnd){let startLoc;this.isLookahead||(startLoc=this.state.curPosition());const start=this.state.pos,end=this.input.indexOf(commentEnd,start+2);if(-1===end)throw this.raise(Errors.UnterminatedComment,this.state.curPosition());for(this.state.pos=end+commentEnd.length,lineBreakG.lastIndex=start+2;lineBreakG.test(this.input)&&lineBreakG.lastIndex<=end;)++this.state.curLine,this.state.lineStart=lineBreakG.lastIndex;if(this.isLookahead)return;const comment={type:"CommentBlock",value:this.input.slice(start+2,end),start:this.sourceToOffsetPos(start),end:this.sourceToOffsetPos(end+commentEnd.length),loc:new SourceLocation(startLoc,this.state.curPosition())};return this.options.tokens&&this.pushToken(comment),comment}skipLineComment(startSkip){const start=this.state.pos;let startLoc;this.isLookahead||(startLoc=this.state.curPosition());let ch=this.input.charCodeAt(this.state.pos+=startSkip);if(this.state.pos<this.length)for(;!isNewLine(ch)&&++this.state.pos<this.length;)ch=this.input.charCodeAt(this.state.pos);if(this.isLookahead)return;const end=this.state.pos,comment={type:"CommentLine",value:this.input.slice(start+startSkip,end),start:this.sourceToOffsetPos(start),end:this.sourceToOffsetPos(end),loc:new SourceLocation(startLoc,this.state.curPosition())};return this.options.tokens&&this.pushToken(comment),comment}skipSpace(){const spaceStart=this.state.pos,comments=[];loop:for(;this.state.pos<this.length;){const ch=this.input.charCodeAt(this.state.pos);switch(ch){case 32:case 160:case 9:++this.state.pos;break;case 13:10===this.input.charCodeAt(this.state.pos+1)&&++this.state.pos;case 10:case 8232:case 8233:++this.state.pos,++this.state.curLine,this.state.lineStart=this.state.pos;break;case 47:switch(this.input.charCodeAt(this.state.pos+1)){case 42:{const comment=this.skipBlockComment("*/");void 0!==comment&&(this.addComment(comment),this.options.attachComment&&comments.push(comment));break}case 47:{const comment=this.skipLineComment(2);void 0!==comment&&(this.addComment(comment),this.options.attachComment&&comments.push(comment));break}default:break loop}break;default:if(isWhitespace(ch))++this.state.pos;else if(45===ch&&!this.inModule&&this.options.annexB){const pos=this.state.pos;if(45!==this.input.charCodeAt(pos+1)||62!==this.input.charCodeAt(pos+2)||!(0===spaceStart||this.state.lineStart>spaceStart))break loop;{const comment=this.skipLineComment(3);void 0!==comment&&(this.addComment(comment),this.options.attachComment&&comments.push(comment));}}else {if(60!==ch||this.inModule||!this.options.annexB)break loop;{const pos=this.state.pos;if(33!==this.input.charCodeAt(pos+1)||45!==this.input.charCodeAt(pos+2)||45!==this.input.charCodeAt(pos+3))break loop;{const comment=this.skipLineComment(4);void 0!==comment&&(this.addComment(comment),this.options.attachComment&&comments.push(comment));}}}}}if(comments.length>0){const end=this.state.pos,commentWhitespace={start:this.sourceToOffsetPos(spaceStart),end:this.sourceToOffsetPos(end),comments,leadingNode:null,trailingNode:null,containingNode:null};this.state.commentStack.push(commentWhitespace);}}finishToken(type,val){this.state.end=this.state.pos,this.state.endLoc=this.state.curPosition();const prevType=this.state.type;this.state.type=type,this.state.value=val,this.isLookahead||this.updateContext(prevType);}replaceToken(type){this.state.type=type,this.updateContext();}readToken_numberSign(){if(0===this.state.pos&&this.readToken_interpreter())return;const nextPos=this.state.pos+1,next=this.codePointAtPos(nextPos);if(next>=48&&next<=57)throw this.raise(Errors.UnexpectedDigitAfterHash,this.state.curPosition());if(123===next||91===next&&this.hasPlugin("recordAndTuple")){if(this.expectPlugin("recordAndTuple"),"bar"===this.getPluginOption("recordAndTuple","syntaxType"))throw this.raise(123===next?Errors.RecordExpressionHashIncorrectStartSyntaxType:Errors.TupleExpressionHashIncorrectStartSyntaxType,this.state.curPosition());this.state.pos+=2,123===next?this.finishToken(7):this.finishToken(1);}else isIdentifierStart(next)?(++this.state.pos,this.finishToken(139,this.readWord1(next))):92===next?(++this.state.pos,this.finishToken(139,this.readWord1())):this.finishOp(27,1);}readToken_dot(){const next=this.input.charCodeAt(this.state.pos+1);next>=48&&next<=57?this.readNumber(true):46===next&&46===this.input.charCodeAt(this.state.pos+2)?(this.state.pos+=3,this.finishToken(21)):(++this.state.pos,this.finishToken(16));}readToken_slash(){61===this.input.charCodeAt(this.state.pos+1)?this.finishOp(31,2):this.finishOp(56,1);}readToken_interpreter(){if(0!==this.state.pos||this.length<2)return  false;let ch=this.input.charCodeAt(this.state.pos+1);if(33!==ch)return  false;const start=this.state.pos;for(this.state.pos+=1;!isNewLine(ch)&&++this.state.pos<this.length;)ch=this.input.charCodeAt(this.state.pos);const value=this.input.slice(start+2,this.state.pos);return this.finishToken(28,value),true}readToken_mult_modulo(code){let type=42===code?55:54,width=1,next=this.input.charCodeAt(this.state.pos+1);42===code&&42===next&&(width++,next=this.input.charCodeAt(this.state.pos+2),type=57),61!==next||this.state.inType||(width++,type=37===code?33:30),this.finishOp(type,width);}readToken_pipe_amp(code){const next=this.input.charCodeAt(this.state.pos+1);if(next!==code){if(124===code){if(62===next)return void this.finishOp(39,2);if(this.hasPlugin("recordAndTuple")&&125===next){if("bar"!==this.getPluginOption("recordAndTuple","syntaxType"))throw this.raise(Errors.RecordExpressionBarIncorrectEndSyntaxType,this.state.curPosition());return this.state.pos+=2,void this.finishToken(9)}if(this.hasPlugin("recordAndTuple")&&93===next){if("bar"!==this.getPluginOption("recordAndTuple","syntaxType"))throw this.raise(Errors.TupleExpressionBarIncorrectEndSyntaxType,this.state.curPosition());return this.state.pos+=2,void this.finishToken(4)}}61!==next?this.finishOp(124===code?43:45,1):this.finishOp(30,2);}else 61===this.input.charCodeAt(this.state.pos+2)?this.finishOp(30,3):this.finishOp(124===code?41:42,2);}readToken_caret(){const next=this.input.charCodeAt(this.state.pos+1);if(61!==next||this.state.inType)if(94===next&&this.hasPlugin(["pipelineOperator",{proposal:"hack",topicToken:"^^"}])){this.finishOp(37,2);94===this.input.codePointAt(this.state.pos)&&this.unexpected();}else this.finishOp(44,1);else this.finishOp(32,2);}readToken_atSign(){64===this.input.charCodeAt(this.state.pos+1)&&this.hasPlugin(["pipelineOperator",{proposal:"hack",topicToken:"@@"}])?this.finishOp(38,2):this.finishOp(26,1);}readToken_plus_min(code){const next=this.input.charCodeAt(this.state.pos+1);next!==code?61===next?this.finishOp(30,2):this.finishOp(53,1):this.finishOp(34,2);}readToken_lt(){const{pos}=this.state,next=this.input.charCodeAt(pos+1);if(60===next)return 61===this.input.charCodeAt(pos+2)?void this.finishOp(30,3):void this.finishOp(51,2);61!==next?this.finishOp(47,1):this.finishOp(49,2);}readToken_gt(){const{pos}=this.state,next=this.input.charCodeAt(pos+1);if(62===next){const size=62===this.input.charCodeAt(pos+2)?3:2;return 61===this.input.charCodeAt(pos+size)?void this.finishOp(30,size+1):void this.finishOp(52,size)}61!==next?this.finishOp(48,1):this.finishOp(49,2);}readToken_eq_excl(code){const next=this.input.charCodeAt(this.state.pos+1);if(61!==next)return 61===code&&62===next?(this.state.pos+=2,void this.finishToken(19)):void this.finishOp(61===code?29:35,1);this.finishOp(46,61===this.input.charCodeAt(this.state.pos+2)?3:2);}readToken_question(){const next=this.input.charCodeAt(this.state.pos+1),next2=this.input.charCodeAt(this.state.pos+2);63===next?61===next2?this.finishOp(30,3):this.finishOp(40,2):46!==next||next2>=48&&next2<=57?(++this.state.pos,this.finishToken(17)):(this.state.pos+=2,this.finishToken(18));}getTokenFromCode(code){switch(code){case 46:return void this.readToken_dot();case 40:return ++this.state.pos,void this.finishToken(10);case 41:return ++this.state.pos,void this.finishToken(11);case 59:return ++this.state.pos,void this.finishToken(13);case 44:return ++this.state.pos,void this.finishToken(12);case 91:if(this.hasPlugin("recordAndTuple")&&124===this.input.charCodeAt(this.state.pos+1)){if("bar"!==this.getPluginOption("recordAndTuple","syntaxType"))throw this.raise(Errors.TupleExpressionBarIncorrectStartSyntaxType,this.state.curPosition());this.state.pos+=2,this.finishToken(2);}else ++this.state.pos,this.finishToken(0);return;case 93:return ++this.state.pos,void this.finishToken(3);case 123:if(this.hasPlugin("recordAndTuple")&&124===this.input.charCodeAt(this.state.pos+1)){if("bar"!==this.getPluginOption("recordAndTuple","syntaxType"))throw this.raise(Errors.RecordExpressionBarIncorrectStartSyntaxType,this.state.curPosition());this.state.pos+=2,this.finishToken(6);}else ++this.state.pos,this.finishToken(5);return;case 125:return ++this.state.pos,void this.finishToken(8);case 58:return void(this.hasPlugin("functionBind")&&58===this.input.charCodeAt(this.state.pos+1)?this.finishOp(15,2):(++this.state.pos,this.finishToken(14)));case 63:return void this.readToken_question();case 96:return void this.readTemplateToken();case 48:{const next=this.input.charCodeAt(this.state.pos+1);if(120===next||88===next)return void this.readRadixNumber(16);if(111===next||79===next)return void this.readRadixNumber(8);if(98===next||66===next)return void this.readRadixNumber(2)}case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:return void this.readNumber(false);case 34:case 39:return void this.readString(code);case 47:return void this.readToken_slash();case 37:case 42:return void this.readToken_mult_modulo(code);case 124:case 38:return void this.readToken_pipe_amp(code);case 94:return void this.readToken_caret();case 43:case 45:return void this.readToken_plus_min(code);case 60:return void this.readToken_lt();case 62:return void this.readToken_gt();case 61:case 33:return void this.readToken_eq_excl(code);case 126:return void this.finishOp(36,1);case 64:return void this.readToken_atSign();case 35:return void this.readToken_numberSign();case 92:return void this.readWord();default:if(isIdentifierStart(code))return void this.readWord(code)}throw this.raise(Errors.InvalidOrUnexpectedToken,this.state.curPosition(),{unexpected:String.fromCodePoint(code)})}finishOp(type,size){const str=this.input.slice(this.state.pos,this.state.pos+size);this.state.pos+=size,this.finishToken(type,str);}readRegexp(){const startLoc=this.state.startLoc,start=this.state.start+1;let escaped,inClass,{pos}=this.state;for(;;++pos){if(pos>=this.length)throw this.raise(Errors.UnterminatedRegExp,createPositionWithColumnOffset(startLoc,1));const ch=this.input.charCodeAt(pos);if(isNewLine(ch))throw this.raise(Errors.UnterminatedRegExp,createPositionWithColumnOffset(startLoc,1));if(escaped)escaped=false;else {if(91===ch)inClass=true;else if(93===ch&&inClass)inClass=false;else if(47===ch&&!inClass)break;escaped=92===ch;}}const content=this.input.slice(start,pos);++pos;let mods="";const nextPos=()=>createPositionWithColumnOffset(startLoc,pos+2-start);for(;pos<this.length;){const cp=this.codePointAtPos(pos),char=String.fromCharCode(cp);if(VALID_REGEX_FLAGS.has(cp))118===cp?mods.includes("u")&&this.raise(Errors.IncompatibleRegExpUVFlags,nextPos()):117===cp&&mods.includes("v")&&this.raise(Errors.IncompatibleRegExpUVFlags,nextPos()),mods.includes(char)&&this.raise(Errors.DuplicateRegExpFlags,nextPos());else {if(!isIdentifierChar(cp)&&92!==cp)break;this.raise(Errors.MalformedRegExpFlags,nextPos());}++pos,mods+=char;}this.state.pos=pos,this.finishToken(138,{pattern:content,flags:mods});}readInt(radix,len,forceLen=false,allowNumSeparator=true){const{n,pos}=readInt(this.input,this.state.pos,this.state.lineStart,this.state.curLine,radix,len,forceLen,allowNumSeparator,this.errorHandlers_readInt,false);return this.state.pos=pos,n}readRadixNumber(radix){const start=this.state.pos,startLoc=this.state.curPosition();let isBigInt=false;this.state.pos+=2;const val=this.readInt(radix);null==val&&this.raise(Errors.InvalidDigit,createPositionWithColumnOffset(startLoc,2),{radix});const next=this.input.charCodeAt(this.state.pos);if(110===next)++this.state.pos,isBigInt=true;else if(109===next)throw this.raise(Errors.InvalidDecimal,startLoc);if(isIdentifierStart(this.codePointAtPos(this.state.pos)))throw this.raise(Errors.NumberIdentifier,this.state.curPosition());if(isBigInt){const str=this.input.slice(start,this.state.pos).replace(/[_n]/g,"");this.finishToken(136,str);}else this.finishToken(135,val);}readNumber(startsWithDot){const start=this.state.pos,startLoc=this.state.curPosition();let isFloat=false,isBigInt=false,hasExponent=false,isOctal=false;startsWithDot||null!==this.readInt(10)||this.raise(Errors.InvalidNumber,this.state.curPosition());const hasLeadingZero=this.state.pos-start>=2&&48===this.input.charCodeAt(start);if(hasLeadingZero){const integer=this.input.slice(start,this.state.pos);if(this.recordStrictModeErrors(Errors.StrictOctalLiteral,startLoc),!this.state.strict){const underscorePos=integer.indexOf("_");underscorePos>0&&this.raise(Errors.ZeroDigitNumericSeparator,createPositionWithColumnOffset(startLoc,underscorePos));}isOctal=hasLeadingZero&&!/[89]/.test(integer);}let next=this.input.charCodeAt(this.state.pos);if(46!==next||isOctal||(++this.state.pos,this.readInt(10),isFloat=true,next=this.input.charCodeAt(this.state.pos)),69!==next&&101!==next||isOctal||(next=this.input.charCodeAt(++this.state.pos),43!==next&&45!==next||++this.state.pos,null===this.readInt(10)&&this.raise(Errors.InvalidOrMissingExponent,startLoc),isFloat=true,hasExponent=true,next=this.input.charCodeAt(this.state.pos)),110===next&&((isFloat||hasLeadingZero)&&this.raise(Errors.InvalidBigIntLiteral,startLoc),++this.state.pos,isBigInt=true),109===next){this.expectPlugin("decimal",this.state.curPosition()),(hasExponent||hasLeadingZero)&&this.raise(Errors.InvalidDecimal,startLoc),++this.state.pos;var isDecimal=true;}if(isIdentifierStart(this.codePointAtPos(this.state.pos)))throw this.raise(Errors.NumberIdentifier,this.state.curPosition());const str=this.input.slice(start,this.state.pos).replace(/[_mn]/g,"");if(isBigInt)return void this.finishToken(136,str);if(isDecimal)return void this.finishToken(137,str);const val=isOctal?parseInt(str,8):parseFloat(str);this.finishToken(135,val);}readCodePoint(throwOnInvalid){const{code,pos}=readCodePoint(this.input,this.state.pos,this.state.lineStart,this.state.curLine,throwOnInvalid,this.errorHandlers_readCodePoint);return this.state.pos=pos,code}readString(quote){const{str,pos,curLine,lineStart}=readStringContents(34===quote?"double":"single",this.input,this.state.pos+1,this.state.lineStart,this.state.curLine,this.errorHandlers_readStringContents_string);this.state.pos=pos+1,this.state.lineStart=lineStart,this.state.curLine=curLine,this.finishToken(134,str);}readTemplateContinuation(){this.match(8)||this.unexpected(null,8),this.state.pos--,this.readTemplateToken();}readTemplateToken(){const opening=this.input[this.state.pos],{str,firstInvalidLoc,pos,curLine,lineStart}=readStringContents("template",this.input,this.state.pos+1,this.state.lineStart,this.state.curLine,this.errorHandlers_readStringContents_template);this.state.pos=pos+1,this.state.lineStart=lineStart,this.state.curLine=curLine,firstInvalidLoc&&(this.state.firstInvalidTemplateEscapePos=new Position(firstInvalidLoc.curLine,firstInvalidLoc.pos-firstInvalidLoc.lineStart,this.sourceToOffsetPos(firstInvalidLoc.pos))),96===this.input.codePointAt(pos)?this.finishToken(24,firstInvalidLoc?null:opening+str+"`"):(this.state.pos++,this.finishToken(25,firstInvalidLoc?null:opening+str+"${"));}recordStrictModeErrors(toParseError,at){const index=at.index;this.state.strict&&!this.state.strictErrors.has(index)?this.raise(toParseError,at):this.state.strictErrors.set(index,[toParseError,at]);}readWord1(firstCode){this.state.containsEsc=false;let word="";const start=this.state.pos;let chunkStart=this.state.pos;for(void 0!==firstCode&&(this.state.pos+=firstCode<=65535?1:2);this.state.pos<this.length;){const ch=this.codePointAtPos(this.state.pos);if(isIdentifierChar(ch))this.state.pos+=ch<=65535?1:2;else {if(92!==ch)break;{this.state.containsEsc=true,word+=this.input.slice(chunkStart,this.state.pos);const escStart=this.state.curPosition(),identifierCheck=this.state.pos===start?isIdentifierStart:isIdentifierChar;if(117!==this.input.charCodeAt(++this.state.pos)){this.raise(Errors.MissingUnicodeEscape,this.state.curPosition()),chunkStart=this.state.pos-1;continue}++this.state.pos;const esc=this.readCodePoint(true);null!==esc&&(identifierCheck(esc)||this.raise(Errors.EscapedCharNotAnIdentifier,escStart),word+=String.fromCodePoint(esc)),chunkStart=this.state.pos;}}}return word+this.input.slice(chunkStart,this.state.pos)}readWord(firstCode){const word=this.readWord1(firstCode),type=keywords$1.get(word);void 0!==type?this.finishToken(type,tokenLabelName(type)):this.finishToken(132,word);}checkKeywordEscapes(){const{type}=this.state;tokenIsKeyword(type)&&this.state.containsEsc&&this.raise(Errors.InvalidEscapedReservedWord,this.state.startLoc,{reservedWord:tokenLabelName(type)});}raise(toParseError,at,details={}){const error=toParseError(at instanceof Position?at:at.loc.start,details);if(!this.options.errorRecovery)throw error;return this.isLookahead||this.state.errors.push(error),error}raiseOverwrite(toParseError,at,details={}){const loc=at instanceof Position?at:at.loc.start,pos=loc.index,errors=this.state.errors;for(let i=errors.length-1;i>=0;i--){const error=errors[i];if(error.loc.index===pos)return errors[i]=toParseError(loc,details);if(error.loc.index<pos)break}return this.raise(toParseError,at,details)}updateContext(prevType){}unexpected(loc,type){throw this.raise(Errors.UnexpectedToken,null!=loc?loc:this.state.startLoc,{expected:type?tokenLabelName(type):null})}expectPlugin(pluginName,loc){if(this.hasPlugin(pluginName))return  true;throw this.raise(Errors.MissingPlugin,null!=loc?loc:this.state.startLoc,{missingPlugin:[pluginName]})}expectOnePlugin(pluginNames){if(!pluginNames.some((name=>this.hasPlugin(name))))throw this.raise(Errors.MissingOneOfPlugins,this.state.startLoc,{missingPlugin:pluginNames})}errorBuilder(error){return (pos,lineStart,curLine)=>{this.raise(error,buildPosition(pos,lineStart,curLine));}}}class ClassScope{constructor(){this.privateNames=new Set,this.loneAccessors=new Map,this.undefinedPrivateNames=new Map;}}class ClassScopeHandler{constructor(parser){this.parser=void 0,this.stack=[],this.undefinedPrivateNames=new Map,this.parser=parser;}current(){return this.stack[this.stack.length-1]}enter(){this.stack.push(new ClassScope);}exit(){const oldClassScope=this.stack.pop(),current=this.current();for(const[name,loc]of Array.from(oldClassScope.undefinedPrivateNames))current?current.undefinedPrivateNames.has(name)||current.undefinedPrivateNames.set(name,loc):this.parser.raise(Errors.InvalidPrivateFieldResolution,loc,{identifierName:name});}declarePrivateName(name,elementType,loc){const{privateNames,loneAccessors,undefinedPrivateNames}=this.current();let redefined=privateNames.has(name);if(3&elementType){const accessor=redefined&&loneAccessors.get(name);if(accessor){redefined=(3&accessor)===(3&elementType)||(4&accessor)!==(4&elementType),redefined||loneAccessors.delete(name);}else redefined||loneAccessors.set(name,elementType);}redefined&&this.parser.raise(Errors.PrivateNameRedeclaration,loc,{identifierName:name}),privateNames.add(name),undefinedPrivateNames.delete(name);}usePrivateName(name,loc){let classScope;for(classScope of this.stack)if(classScope.privateNames.has(name))return;classScope?classScope.undefinedPrivateNames.set(name,loc):this.parser.raise(Errors.InvalidPrivateFieldResolution,loc,{identifierName:name});}}class ExpressionScope{constructor(type=0){this.type=type;}canBeArrowParameterDeclaration(){return 2===this.type||1===this.type}isCertainlyParameterDeclaration(){return 3===this.type}}class ArrowHeadParsingScope extends ExpressionScope{constructor(type){super(type),this.declarationErrors=new Map;}recordDeclarationError(ParsingErrorClass,at){const index=at.index;this.declarationErrors.set(index,[ParsingErrorClass,at]);}clearDeclarationError(index){this.declarationErrors.delete(index);}iterateErrors(iterator){this.declarationErrors.forEach(iterator);}}class ExpressionScopeHandler{constructor(parser){this.parser=void 0,this.stack=[new ExpressionScope],this.parser=parser;}enter(scope){this.stack.push(scope);}exit(){this.stack.pop();}recordParameterInitializerError(toParseError,node){const origin=node.loc.start,{stack}=this;let i=stack.length-1,scope=stack[i];for(;!scope.isCertainlyParameterDeclaration();){if(!scope.canBeArrowParameterDeclaration())return;scope.recordDeclarationError(toParseError,origin),scope=stack[--i];}this.parser.raise(toParseError,origin);}recordArrowParameterBindingError(error,node){const{stack}=this,scope=stack[stack.length-1],origin=node.loc.start;if(scope.isCertainlyParameterDeclaration())this.parser.raise(error,origin);else {if(!scope.canBeArrowParameterDeclaration())return;scope.recordDeclarationError(error,origin);}}recordAsyncArrowParametersError(at){const{stack}=this;let i=stack.length-1,scope=stack[i];for(;scope.canBeArrowParameterDeclaration();)2===scope.type&&scope.recordDeclarationError(Errors.AwaitBindingIdentifier,at),scope=stack[--i];}validateAsPattern(){const{stack}=this,currentScope=stack[stack.length-1];currentScope.canBeArrowParameterDeclaration()&&currentScope.iterateErrors((([toParseError,loc])=>{this.parser.raise(toParseError,loc);let i=stack.length-2,scope=stack[i];for(;scope.canBeArrowParameterDeclaration();)scope.clearDeclarationError(loc.index),scope=stack[--i];}));}}function newExpressionScope(){return new ExpressionScope}class ProductionParameterHandler{constructor(){this.stacks=[];}enter(flags){this.stacks.push(flags);}exit(){this.stacks.pop();}currentFlags(){return this.stacks[this.stacks.length-1]}get hasAwait(){return (2&this.currentFlags())>0}get hasYield(){return (1&this.currentFlags())>0}get hasReturn(){return (4&this.currentFlags())>0}get hasIn(){return (8&this.currentFlags())>0}}function functionFlags(isAsync,isGenerator){return (isAsync?2:0)|(isGenerator?1:0)}class UtilParser extends Tokenizer{addExtra(node,key,value,enumerable=true){if(!node)return;let{extra}=node;null==extra&&(extra={},node.extra=extra),enumerable?extra[key]=value:Object.defineProperty(extra,key,{enumerable,value});}isContextual(token){return this.state.type===token&&!this.state.containsEsc}isUnparsedContextual(nameStart,name){const nameEnd=nameStart+name.length;if(this.input.slice(nameStart,nameEnd)===name){const nextCh=this.input.charCodeAt(nameEnd);return !(isIdentifierChar(nextCh)||55296==(64512&nextCh))}return  false}isLookaheadContextual(name){const next=this.nextTokenStart();return this.isUnparsedContextual(next,name)}eatContextual(token){return !!this.isContextual(token)&&(this.next(),true)}expectContextual(token,toParseError){if(!this.eatContextual(token)){if(null!=toParseError)throw this.raise(toParseError,this.state.startLoc);this.unexpected(null,token);}}canInsertSemicolon(){return this.match(140)||this.match(8)||this.hasPrecedingLineBreak()}hasPrecedingLineBreak(){return hasNewLine(this.input,this.offsetToSourcePos(this.state.lastTokEndLoc.index),this.state.start)}hasFollowingLineBreak(){return hasNewLine(this.input,this.state.end,this.nextTokenStart())}isLineTerminator(){return this.eat(13)||this.canInsertSemicolon()}semicolon(allowAsi=true){(allowAsi?this.isLineTerminator():this.eat(13))||this.raise(Errors.MissingSemicolon,this.state.lastTokEndLoc);}expect(type,loc){this.eat(type)||this.unexpected(loc,type);}tryParse(fn,oldState=this.state.clone()){const abortSignal={node:null};try{const node=fn(((node=null)=>{throw abortSignal.node=node,abortSignal}));if(this.state.errors.length>oldState.errors.length){const failState=this.state;return this.state=oldState,this.state.tokensLength=failState.tokensLength,{node,error:failState.errors[oldState.errors.length],thrown:!1,aborted:!1,failState}}return {node,error:null,thrown:!1,aborted:!1,failState:null}}catch(error){const failState=this.state;if(this.state=oldState,error instanceof SyntaxError)return {node:null,error,thrown:true,aborted:false,failState};if(error===abortSignal)return {node:abortSignal.node,error:null,thrown:false,aborted:true,failState};throw error}}checkExpressionErrors(refExpressionErrors,andThrow){if(!refExpressionErrors)return  false;const{shorthandAssignLoc,doubleProtoLoc,privateKeyLoc,optionalParametersLoc}=refExpressionErrors;if(!andThrow)return !!(shorthandAssignLoc||doubleProtoLoc||optionalParametersLoc||privateKeyLoc);null!=shorthandAssignLoc&&this.raise(Errors.InvalidCoverInitializedName,shorthandAssignLoc),null!=doubleProtoLoc&&this.raise(Errors.DuplicateProto,doubleProtoLoc),null!=privateKeyLoc&&this.raise(Errors.UnexpectedPrivateField,privateKeyLoc),null!=optionalParametersLoc&&this.unexpected(optionalParametersLoc);}isLiteralPropertyName(){return tokenIsLiteralPropertyName(this.state.type)}isPrivateName(node){return "PrivateName"===node.type}getPrivateNameSV(node){return node.id.name}hasPropertyAsPrivateName(node){return ("MemberExpression"===node.type||"OptionalMemberExpression"===node.type)&&this.isPrivateName(node.property)}isObjectProperty(node){return "ObjectProperty"===node.type}isObjectMethod(node){return "ObjectMethod"===node.type}initializeScopes(inModule="module"===this.options.sourceType){const oldLabels=this.state.labels;this.state.labels=[];const oldExportedIdentifiers=this.exportedIdentifiers;this.exportedIdentifiers=new Set;const oldInModule=this.inModule;this.inModule=inModule;const oldScope=this.scope,ScopeHandler=this.getScopeHandler();this.scope=new ScopeHandler(this,inModule);const oldProdParam=this.prodParam;this.prodParam=new ProductionParameterHandler;const oldClassScope=this.classScope;this.classScope=new ClassScopeHandler(this);const oldExpressionScope=this.expressionScope;return this.expressionScope=new ExpressionScopeHandler(this),()=>{this.state.labels=oldLabels,this.exportedIdentifiers=oldExportedIdentifiers,this.inModule=oldInModule,this.scope=oldScope,this.prodParam=oldProdParam,this.classScope=oldClassScope,this.expressionScope=oldExpressionScope;}}enterInitialScopes(){let paramFlags=0;this.inModule&&(paramFlags|=2),this.scope.enter(1),this.prodParam.enter(paramFlags);}checkDestructuringPrivate(refExpressionErrors){const{privateKeyLoc}=refExpressionErrors;null!==privateKeyLoc&&this.expectPlugin("destructuringPrivate",privateKeyLoc);}}class ExpressionErrors{constructor(){this.shorthandAssignLoc=null,this.doubleProtoLoc=null,this.privateKeyLoc=null,this.optionalParametersLoc=null;}}class Node{constructor(parser,pos,loc){this.type="",this.start=pos,this.end=0,this.loc=new SourceLocation(loc),null!=parser&&parser.options.ranges&&(this.range=[pos,0]),null!=parser&&parser.filename&&(this.loc.filename=parser.filename);}}const NodePrototype=Node.prototype;function cloneIdentifier(node){const{type,start,end,loc,range,extra,name}=node,cloned=Object.create(NodePrototype);return cloned.type=type,cloned.start=start,cloned.end=end,cloned.loc=loc,cloned.range=range,cloned.extra=extra,cloned.name=name,"Placeholder"===type&&(cloned.expectedNode=node.expectedNode),cloned}function cloneStringLiteral(node){const{type,start,end,loc,range,extra}=node;if("Placeholder"===type)return function(node){return cloneIdentifier(node)}(node);const cloned=Object.create(NodePrototype);return cloned.type=type,cloned.start=start,cloned.end=end,cloned.loc=loc,cloned.range=range,void 0!==node.raw?cloned.raw=node.raw:cloned.extra=extra,cloned.value=node.value,cloned}NodePrototype.__clone=function(){const newNode=new Node(void 0,this.start,this.loc.start),keys=Object.keys(this);for(let i=0,length=keys.length;i<length;i++){const key=keys[i];"leadingComments"!==key&&"trailingComments"!==key&&"innerComments"!==key&&(newNode[key]=this[key]);}return newNode};class NodeUtils extends UtilParser{startNode(){const loc=this.state.startLoc;return new Node(this,loc.index,loc)}startNodeAt(loc){return new Node(this,loc.index,loc)}startNodeAtNode(type){return this.startNodeAt(type.loc.start)}finishNode(node,type){return this.finishNodeAt(node,type,this.state.lastTokEndLoc)}finishNodeAt(node,type,endLoc){return node.type=type,node.end=endLoc.index,node.loc.end=endLoc,this.options.ranges&&(node.range[1]=endLoc.index),this.options.attachComment&&this.processComment(node),node}resetStartLocation(node,startLoc){node.start=startLoc.index,node.loc.start=startLoc,this.options.ranges&&(node.range[0]=startLoc.index);}resetEndLocation(node,endLoc=this.state.lastTokEndLoc){node.end=endLoc.index,node.loc.end=endLoc,this.options.ranges&&(node.range[1]=endLoc.index);}resetStartLocationFromNode(node,locationNode){this.resetStartLocation(node,locationNode.loc.start);}}const reservedTypes=new Set(["_","any","bool","boolean","empty","extends","false","interface","mixed","null","number","static","string","true","typeof","void"]),FlowErrors=ParseErrorEnum`flow`({AmbiguousConditionalArrow:"Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",AmbiguousDeclareModuleKind:"Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",AssignReservedType:({reservedType})=>`Cannot overwrite reserved type ${reservedType}.`,DeclareClassElement:"The `declare` modifier can only appear on class fields.",DeclareClassFieldInitializer:"Initializers are not allowed in fields with the `declare` modifier.",DuplicateDeclareModuleExports:"Duplicate `declare module.exports` statement.",EnumBooleanMemberNotInitialized:({memberName,enumName})=>`Boolean enum members need to be initialized. Use either \`${memberName} = true,\` or \`${memberName} = false,\` in enum \`${enumName}\`.`,EnumDuplicateMemberName:({memberName,enumName})=>`Enum member names need to be unique, but the name \`${memberName}\` has already been used before in enum \`${enumName}\`.`,EnumInconsistentMemberValues:({enumName})=>`Enum \`${enumName}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,EnumInvalidExplicitType:({invalidEnumType,enumName})=>`Enum type \`${invalidEnumType}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,EnumInvalidExplicitTypeUnknownSupplied:({enumName})=>`Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,EnumInvalidMemberInitializerPrimaryType:({enumName,memberName,explicitType})=>`Enum \`${enumName}\` has type \`${explicitType}\`, so the initializer of \`${memberName}\` needs to be a ${explicitType} literal.`,EnumInvalidMemberInitializerSymbolType:({enumName,memberName})=>`Symbol enum members cannot be initialized. Use \`${memberName},\` in enum \`${enumName}\`.`,EnumInvalidMemberInitializerUnknownType:({enumName,memberName})=>`The enum member initializer for \`${memberName}\` needs to be a literal (either a boolean, number, or string) in enum \`${enumName}\`.`,EnumInvalidMemberName:({enumName,memberName,suggestion})=>`Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${memberName}\`, consider using \`${suggestion}\`, in enum \`${enumName}\`.`,EnumNumberMemberNotInitialized:({enumName,memberName})=>`Number enum members need to be initialized, e.g. \`${memberName} = 1\` in enum \`${enumName}\`.`,EnumStringMemberInconsistentlyInitialized:({enumName})=>`String enum members need to consistently either all use initializers, or use no initializers, in enum \`${enumName}\`.`,GetterMayNotHaveThisParam:"A getter cannot have a `this` parameter.",ImportReflectionHasImportType:"An `import module` declaration can not use `type` or `typeof` keyword.",ImportTypeShorthandOnlyInPureImport:"The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",InexactInsideExact:"Explicit inexact syntax cannot appear inside an explicit exact object type.",InexactInsideNonObject:"Explicit inexact syntax cannot appear in class or interface definitions.",InexactVariance:"Explicit inexact syntax cannot have variance.",InvalidNonTypeImportInDeclareModule:"Imports within a `declare module` body must always be `import type` or `import typeof`.",MissingTypeParamDefault:"Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",NestedDeclareModule:"`declare module` cannot be used inside another `declare module`.",NestedFlowComment:"Cannot have a flow comment inside another flow comment.",PatternIsOptional:Object.assign({message:"A binding pattern parameter cannot be optional in an implementation signature."},{reasonCode:"OptionalBindingPattern"}),SetterMayNotHaveThisParam:"A setter cannot have a `this` parameter.",SpreadVariance:"Spread properties cannot have variance.",ThisParamAnnotationRequired:"A type annotation is required for the `this` parameter.",ThisParamBannedInConstructor:"Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",ThisParamMayNotBeOptional:"The `this` parameter cannot be optional.",ThisParamMustBeFirst:"The `this` parameter must be the first function parameter.",ThisParamNoDefault:"The `this` parameter may not have a default value.",TypeBeforeInitializer:"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",TypeCastInPattern:"The type cast expression is expected to be wrapped with parenthesis.",UnexpectedExplicitInexactInObject:"Explicit inexact syntax must appear at the end of an inexact object.",UnexpectedReservedType:({reservedType})=>`Unexpected reserved type ${reservedType}.`,UnexpectedReservedUnderscore:"`_` is only allowed as a type argument to call or new.",UnexpectedSpaceBetweenModuloChecks:"Spaces between `%` and `checks` are not allowed here.",UnexpectedSpreadType:"Spread operator cannot appear in class or interface definitions.",UnexpectedSubtractionOperand:'Unexpected token, expected "number" or "bigint".',UnexpectedTokenAfterTypeParameter:"Expected an arrow function after this type parameter declaration.",UnexpectedTypeParameterBeforeAsyncArrowFunction:"Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",UnsupportedDeclareExportKind:({unsupportedExportKind,suggestion})=>`\`declare export ${unsupportedExportKind}\` is not supported. Use \`${suggestion}\` instead.`,UnsupportedStatementInDeclareModule:"Only declares and type imports are allowed inside declare module.",UnterminatedFlowComment:"Unterminated flow-comment."});function hasTypeImportKind(node){return "type"===node.importKind||"typeof"===node.importKind}const exportSuggestions={const:"declare export var",let:"declare export var",type:"export type",interface:"export interface"};const FLOW_PRAGMA_REGEX=/\*?\s*@((?:no)?flow)\b/;const entities={__proto__:null,quot:'"',amp:"&",apos:"'",lt:"<",gt:">",nbsp:"",iexcl:"",cent:"",pound:"",curren:"",yen:"",brvbar:"",sect:"",uml:"",copy:"",ordf:"",laquo:"",not:"",shy:"",reg:"",macr:"",deg:"",plusmn:"",sup2:"",sup3:"",acute:"",micro:"",para:"",middot:"",cedil:"",sup1:"",ordm:"",raquo:"",frac14:"",frac12:"",frac34:"",iquest:"",Agrave:"",Aacute:"",Acirc:"",Atilde:"",Auml:"",Aring:"",AElig:"",Ccedil:"",Egrave:"",Eacute:"",Ecirc:"",Euml:"",Igrave:"",Iacute:"",Icirc:"",Iuml:"",ETH:"",Ntilde:"",Ograve:"",Oacute:"",Ocirc:"",Otilde:"",Ouml:"",times:"",Oslash:"",Ugrave:"",Uacute:"",Ucirc:"",Uuml:"",Yacute:"",THORN:"",szlig:"",agrave:"",aacute:"",acirc:"",atilde:"",auml:"",aring:"",aelig:"",ccedil:"",egrave:"",eacute:"",ecirc:"",euml:"",igrave:"",iacute:"",icirc:"",iuml:"",eth:"",ntilde:"",ograve:"",oacute:"",ocirc:"",otilde:"",ouml:"",divide:"",oslash:"",ugrave:"",uacute:"",ucirc:"",uuml:"",yacute:"",thorn:"",yuml:"",OElig:"",oelig:"",Scaron:"",scaron:"",Yuml:"",fnof:"",circ:"",tilde:"",Alpha:"",Beta:"",Gamma:"",Delta:"",Epsilon:"",Zeta:"",Eta:"",Theta:"",Iota:"",Kappa:"",Lambda:"",Mu:"",Nu:"",Xi:"",Omicron:"",Pi:"",Rho:"",Sigma:"",Tau:"",Upsilon:"",Phi:"",Chi:"",Psi:"",Omega:"",alpha:"",beta:"",gamma:"",delta:"",epsilon:"",zeta:"",eta:"",theta:"",iota:"",kappa:"",lambda:"",mu:"",nu:"",xi:"",omicron:"",pi:"",rho:"",sigmaf:"",sigma:"",tau:"",upsilon:"",phi:"",chi:"",psi:"",omega:"",thetasym:"",upsih:"",piv:"",ensp:"",emsp:"",thinsp:"",zwnj:"",zwj:"",lrm:"",rlm:"",ndash:"",mdash:"",lsquo:"",rsquo:"",sbquo:"",ldquo:"",rdquo:"",bdquo:"",dagger:"",Dagger:"",bull:"",hellip:"",permil:"",prime:"",Prime:"",lsaquo:"",rsaquo:"",oline:"",frasl:"",euro:"",image:"",weierp:"",real:"",trade:"",alefsym:"",larr:"",uarr:"",rarr:"",darr:"",harr:"",crarr:"",lArr:"",uArr:"",rArr:"",dArr:"",hArr:"",forall:"",part:"",exist:"",empty:"",nabla:"",isin:"",notin:"",ni:"",prod:"",sum:"",minus:"",lowast:"",radic:"",prop:"",infin:"",ang:"",and:"",or:"",cap:"",cup:"",int:"",there4:"",sim:"",cong:"",asymp:"",ne:"",equiv:"",le:"",ge:"",sub:"",sup:"",nsub:"",sube:"",supe:"",oplus:"",otimes:"",perp:"",sdot:"",lceil:"",rceil:"",lfloor:"",rfloor:"",lang:"",rang:"",loz:"",spades:"",clubs:"",hearts:"",diams:""},JsxErrors=ParseErrorEnum`jsx`({AttributeIsEmpty:"JSX attributes must only be assigned a non-empty expression.",MissingClosingTagElement:({openingTagName})=>`Expected corresponding JSX closing tag for <${openingTagName}>.`,MissingClosingTagFragment:"Expected corresponding JSX closing tag for <>.",UnexpectedSequenceExpression:"Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",UnexpectedToken:({unexpected,HTMLEntity})=>`Unexpected token \`${unexpected}\`. Did you mean \`${HTMLEntity}\` or \`{'${unexpected}'}\`?`,UnsupportedJsxValue:"JSX value should be either an expression or a quoted JSX text.",UnterminatedJsxContent:"Unterminated JSX contents.",UnwrappedAdjacentJSXElements:"Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"});function isFragment(object){return !!object&&("JSXOpeningFragment"===object.type||"JSXClosingFragment"===object.type)}function getQualifiedJSXName(object){if("JSXIdentifier"===object.type)return object.name;if("JSXNamespacedName"===object.type)return object.namespace.name+":"+object.name.name;if("JSXMemberExpression"===object.type)return getQualifiedJSXName(object.object)+"."+getQualifiedJSXName(object.property);throw new Error("Node had unexpected type: "+object.type)}class TypeScriptScope extends Scope{constructor(...args){super(...args),this.tsNames=new Map;}}class TypeScriptScopeHandler extends ScopeHandler{constructor(...args){super(...args),this.importsStack=[];}createScope(flags){return this.importsStack.push(new Set),new TypeScriptScope(flags)}enter(flags){256===flags&&this.importsStack.push(new Set),super.enter(flags);}exit(){const flags=super.exit();return 256===flags&&this.importsStack.pop(),flags}hasImport(name,allowShadow){const len=this.importsStack.length;if(this.importsStack[len-1].has(name))return  true;if(!allowShadow&&len>1)for(let i=0;i<len-1;i++)if(this.importsStack[i].has(name))return  true;return  false}declareName(name,bindingType,loc){if(4096&bindingType)return this.hasImport(name,true)&&this.parser.raise(Errors.VarRedeclaration,loc,{identifierName:name}),void this.importsStack[this.importsStack.length-1].add(name);const scope=this.currentScope();let type=scope.tsNames.get(name)||0;if(1024&bindingType)return this.maybeExportDefined(scope,name),void scope.tsNames.set(name,16|type);super.declareName(name,bindingType,loc),2&bindingType&&(1&bindingType||(this.checkRedeclarationInScope(scope,name,bindingType,loc),this.maybeExportDefined(scope,name)),type|=1),256&bindingType&&(type|=2),512&bindingType&&(type|=4),128&bindingType&&(type|=8),type&&scope.tsNames.set(name,type);}isRedeclaredInScope(scope,name,bindingType){const type=scope.tsNames.get(name);if((2&type)>0){if(256&bindingType){return !!(512&bindingType)!==(4&type)>0}return  true}return 128&bindingType&&(8&type)>0?!!(2&scope.names.get(name))&&!!(1&bindingType):!!(2&bindingType&&(1&type)>0)||super.isRedeclaredInScope(scope,name,bindingType)}checkLocalExport(id){const{name}=id;if(this.hasImport(name))return;for(let i=this.scopeStack.length-1;i>=0;i--){const type=this.scopeStack[i].tsNames.get(name);if((1&type)>0||(16&type)>0)return}super.checkLocalExport(id);}}const unwrapParenthesizedExpression=node=>"ParenthesizedExpression"===node.type?unwrapParenthesizedExpression(node.expression):node;class LValParser extends NodeUtils{toAssignable(node,isLHS=false){var _node$extra,_node$extra3;let parenthesized;switch(("ParenthesizedExpression"===node.type||null!=(_node$extra=node.extra)&&_node$extra.parenthesized)&&(parenthesized=unwrapParenthesizedExpression(node),isLHS?"Identifier"===parenthesized.type?this.expressionScope.recordArrowParameterBindingError(Errors.InvalidParenthesizedAssignment,node):"MemberExpression"===parenthesized.type||this.isOptionalMemberExpression(parenthesized)||this.raise(Errors.InvalidParenthesizedAssignment,node):this.raise(Errors.InvalidParenthesizedAssignment,node)),node.type){case "Identifier":case "ObjectPattern":case "ArrayPattern":case "AssignmentPattern":case "RestElement":break;case "ObjectExpression":node.type="ObjectPattern";for(let i=0,length=node.properties.length,last=length-1;i<length;i++){var _node$extra2;const prop=node.properties[i],isLast=i===last;this.toAssignableObjectExpressionProp(prop,isLast,isLHS),isLast&&"RestElement"===prop.type&&null!=(_node$extra2=node.extra)&&_node$extra2.trailingCommaLoc&&this.raise(Errors.RestTrailingComma,node.extra.trailingCommaLoc);}break;case "ObjectProperty":{const{key,value}=node;this.isPrivateName(key)&&this.classScope.usePrivateName(this.getPrivateNameSV(key),key.loc.start),this.toAssignable(value,isLHS);break}case "SpreadElement":throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");case "ArrayExpression":node.type="ArrayPattern",this.toAssignableList(node.elements,null==(_node$extra3=node.extra)?void 0:_node$extra3.trailingCommaLoc,isLHS);break;case "AssignmentExpression":"="!==node.operator&&this.raise(Errors.MissingEqInAssignment,node.left.loc.end),node.type="AssignmentPattern",delete node.operator,this.toAssignable(node.left,isLHS);break;case "ParenthesizedExpression":this.toAssignable(parenthesized,isLHS);}}toAssignableObjectExpressionProp(prop,isLast,isLHS){if("ObjectMethod"===prop.type)this.raise("get"===prop.kind||"set"===prop.kind?Errors.PatternHasAccessor:Errors.PatternHasMethod,prop.key);else if("SpreadElement"===prop.type){prop.type="RestElement";const arg=prop.argument;this.checkToRestConversion(arg,false),this.toAssignable(arg,isLHS),isLast||this.raise(Errors.RestTrailingComma,prop);}else this.toAssignable(prop,isLHS);}toAssignableList(exprList,trailingCommaLoc,isLHS){const end=exprList.length-1;for(let i=0;i<=end;i++){const elt=exprList[i];if(elt){if("SpreadElement"===elt.type){elt.type="RestElement";const arg=elt.argument;this.checkToRestConversion(arg,true),this.toAssignable(arg,isLHS);}else this.toAssignable(elt,isLHS);"RestElement"===elt.type&&(i<end?this.raise(Errors.RestTrailingComma,elt):trailingCommaLoc&&this.raise(Errors.RestTrailingComma,trailingCommaLoc));}}}isAssignable(node,isBinding){switch(node.type){case "Identifier":case "ObjectPattern":case "ArrayPattern":case "AssignmentPattern":case "RestElement":return  true;case "ObjectExpression":{const last=node.properties.length-1;return node.properties.every(((prop,i)=>"ObjectMethod"!==prop.type&&(i===last||"SpreadElement"!==prop.type)&&this.isAssignable(prop)))}case "ObjectProperty":return this.isAssignable(node.value);case "SpreadElement":return this.isAssignable(node.argument);case "ArrayExpression":return node.elements.every((element=>null===element||this.isAssignable(element)));case "AssignmentExpression":return "="===node.operator;case "ParenthesizedExpression":return this.isAssignable(node.expression);case "MemberExpression":case "OptionalMemberExpression":return !isBinding;default:return  false}}toReferencedList(exprList,isParenthesizedExpr){return exprList}toReferencedListDeep(exprList,isParenthesizedExpr){this.toReferencedList(exprList,isParenthesizedExpr);for(const expr of exprList)"ArrayExpression"===(null==expr?void 0:expr.type)&&this.toReferencedListDeep(expr.elements);}parseSpread(refExpressionErrors){const node=this.startNode();return this.next(),node.argument=this.parseMaybeAssignAllowIn(refExpressionErrors,void 0),this.finishNode(node,"SpreadElement")}parseRestBinding(){const node=this.startNode();return this.next(),node.argument=this.parseBindingAtom(),this.finishNode(node,"RestElement")}parseBindingAtom(){switch(this.state.type){case 0:{const node=this.startNode();return this.next(),node.elements=this.parseBindingList(3,93,1),this.finishNode(node,"ArrayPattern")}case 5:return this.parseObjectLike(8,true)}return this.parseIdentifier()}parseBindingList(close,closeCharCode,flags){const allowEmpty=1&flags,elts=[];let first=true;for(;!this.eat(close);)if(first?first=false:this.expect(12),allowEmpty&&this.match(12))elts.push(null);else {if(this.eat(close))break;if(this.match(21)){let rest=this.parseRestBinding();if((this.hasPlugin("flow")||2&flags)&&(rest=this.parseFunctionParamType(rest)),elts.push(rest),!this.checkCommaAfterRest(closeCharCode)){this.expect(close);break}}else {const decorators=[];for(this.match(26)&&this.hasPlugin("decorators")&&this.raise(Errors.UnsupportedParameterDecorator,this.state.startLoc);this.match(26);)decorators.push(this.parseDecorator());elts.push(this.parseAssignableListItem(flags,decorators));}}return elts}parseBindingRestProperty(prop){return this.next(),prop.argument=this.parseIdentifier(),this.checkCommaAfterRest(125),this.finishNode(prop,"RestElement")}parseBindingProperty(){const{type,startLoc}=this.state;if(21===type)return this.parseBindingRestProperty(this.startNode());const prop=this.startNode();return 139===type?(this.expectPlugin("destructuringPrivate",startLoc),this.classScope.usePrivateName(this.state.value,startLoc),prop.key=this.parsePrivateName()):this.parsePropertyName(prop),prop.method=false,this.parseObjPropValue(prop,startLoc,false,false,true,false)}parseAssignableListItem(flags,decorators){const left=this.parseMaybeDefault();(this.hasPlugin("flow")||2&flags)&&this.parseFunctionParamType(left);const elt=this.parseMaybeDefault(left.loc.start,left);return decorators.length&&(left.decorators=decorators),elt}parseFunctionParamType(param){return param}parseMaybeDefault(startLoc,left){var _left;if(null!=startLoc||(startLoc=this.state.startLoc),left=null!=(_left=left)?_left:this.parseBindingAtom(),!this.eat(29))return left;const node=this.startNodeAt(startLoc);return node.left=left,node.right=this.parseMaybeAssignAllowIn(),this.finishNode(node,"AssignmentPattern")}isValidLVal(type,isUnparenthesizedInAssign,binding){switch(type){case "AssignmentPattern":return "left";case "RestElement":return "argument";case "ObjectProperty":return "value";case "ParenthesizedExpression":return "expression";case "ArrayPattern":return "elements";case "ObjectPattern":return "properties"}return  false}isOptionalMemberExpression(expression){return "OptionalMemberExpression"===expression.type}checkLVal(expression,ancestor,binding=64,checkClashes=false,strictModeChanged=false,hasParenthesizedAncestor=false){var _expression$extra;const type=expression.type;if(this.isObjectMethod(expression))return;const isOptionalMemberExpression=this.isOptionalMemberExpression(expression);if(isOptionalMemberExpression||"MemberExpression"===type)return isOptionalMemberExpression&&(this.expectPlugin("optionalChainingAssign",expression.loc.start),"AssignmentExpression"!==ancestor.type&&this.raise(Errors.InvalidLhsOptionalChaining,expression,{ancestor})),void(64!==binding&&this.raise(Errors.InvalidPropertyBindingPattern,expression));if("Identifier"===type){this.checkIdentifier(expression,binding,strictModeChanged);const{name}=expression;return void(checkClashes&&(checkClashes.has(name)?this.raise(Errors.ParamDupe,expression):checkClashes.add(name)))}const validity=this.isValidLVal(type,!(hasParenthesizedAncestor||null!=(_expression$extra=expression.extra)&&_expression$extra.parenthesized)&&"AssignmentExpression"===ancestor.type,binding);if(true===validity)return;if(false===validity){const ParseErrorClass=64===binding?Errors.InvalidLhs:Errors.InvalidLhsBinding;return void this.raise(ParseErrorClass,expression,{ancestor})}let key,isParenthesizedExpression;"string"==typeof validity?(key=validity,isParenthesizedExpression="ParenthesizedExpression"===type):[key,isParenthesizedExpression]=validity;const nextAncestor="ArrayPattern"===type||"ObjectPattern"===type?{type}:ancestor,val=expression[key];if(Array.isArray(val))for(const child of val)child&&this.checkLVal(child,nextAncestor,binding,checkClashes,strictModeChanged,isParenthesizedExpression);else val&&this.checkLVal(val,nextAncestor,binding,checkClashes,strictModeChanged,isParenthesizedExpression);}checkIdentifier(at,bindingType,strictModeChanged=false){this.state.strict&&(strictModeChanged?isStrictBindReservedWord(at.name,this.inModule):isStrictBindOnlyReservedWord(at.name))&&(64===bindingType?this.raise(Errors.StrictEvalArguments,at,{referenceName:at.name}):this.raise(Errors.StrictEvalArgumentsBinding,at,{bindingName:at.name})),8192&bindingType&&"let"===at.name&&this.raise(Errors.LetInLexicalBinding,at),64&bindingType||this.declareNameFromIdentifier(at,bindingType);}declareNameFromIdentifier(identifier,binding){this.scope.declareName(identifier.name,binding,identifier.loc.start);}checkToRestConversion(node,allowPattern){switch(node.type){case "ParenthesizedExpression":this.checkToRestConversion(node.expression,allowPattern);break;case "Identifier":case "MemberExpression":break;case "ArrayExpression":case "ObjectExpression":if(allowPattern)break;default:this.raise(Errors.InvalidRestAssignmentPattern,node);}}checkCommaAfterRest(close){return !!this.match(12)&&(this.raise(this.lookaheadCharCode()===close?Errors.RestTrailingComma:Errors.ElementAfterRest,this.state.startLoc),true)}}function assert(x){if(!x)throw new Error("Assert fail")}const TSErrors=ParseErrorEnum`typescript`({AbstractMethodHasImplementation:({methodName})=>`Method '${methodName}' cannot have an implementation because it is marked abstract.`,AbstractPropertyHasInitializer:({propertyName})=>`Property '${propertyName}' cannot have an initializer because it is marked abstract.`,AccessorCannotBeOptional:"An 'accessor' property cannot be declared optional.",AccessorCannotDeclareThisParameter:"'get' and 'set' accessors cannot declare 'this' parameters.",AccessorCannotHaveTypeParameters:"An accessor cannot have type parameters.",ClassMethodHasDeclare:"Class methods cannot have the 'declare' modifier.",ClassMethodHasReadonly:"Class methods cannot have the 'readonly' modifier.",ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference:"A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",ConstructorHasTypeParameters:"Type parameters cannot appear on a constructor declaration.",DeclareAccessor:({kind})=>`'declare' is not allowed in ${kind}ters.`,DeclareClassFieldHasInitializer:"Initializers are not allowed in ambient contexts.",DeclareFunctionHasImplementation:"An implementation cannot be declared in ambient contexts.",DuplicateAccessibilityModifier:({modifier})=>"Accessibility modifier already seen.",DuplicateModifier:({modifier})=>`Duplicate modifier: '${modifier}'.`,EmptyHeritageClauseType:({token})=>`'${token}' list cannot be empty.`,EmptyTypeArguments:"Type argument list cannot be empty.",EmptyTypeParameters:"Type parameter list cannot be empty.",ExpectedAmbientAfterExportDeclare:"'export declare' must be followed by an ambient declaration.",ImportAliasHasImportType:"An import alias can not use 'import type'.",ImportReflectionHasImportType:"An `import module` declaration can not use `type` modifier",IncompatibleModifiers:({modifiers})=>`'${modifiers[0]}' modifier cannot be used with '${modifiers[1]}' modifier.`,IndexSignatureHasAbstract:"Index signatures cannot have the 'abstract' modifier.",IndexSignatureHasAccessibility:({modifier})=>`Index signatures cannot have an accessibility modifier ('${modifier}').`,IndexSignatureHasDeclare:"Index signatures cannot have the 'declare' modifier.",IndexSignatureHasOverride:"'override' modifier cannot appear on an index signature.",IndexSignatureHasStatic:"Index signatures cannot have the 'static' modifier.",InitializerNotAllowedInAmbientContext:"Initializers are not allowed in ambient contexts.",InvalidModifierOnTypeMember:({modifier})=>`'${modifier}' modifier cannot appear on a type member.`,InvalidModifierOnTypeParameter:({modifier})=>`'${modifier}' modifier cannot appear on a type parameter.`,InvalidModifierOnTypeParameterPositions:({modifier})=>`'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`,InvalidModifiersOrder:({orderedModifiers})=>`'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`,InvalidPropertyAccessAfterInstantiationExpression:"Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.",InvalidTupleMemberLabel:"Tuple members must be labeled with a simple identifier.",MissingInterfaceName:"'interface' declarations must be followed by an identifier.",NonAbstractClassHasAbstractMethod:"Abstract methods can only appear within an abstract class.",NonClassMethodPropertyHasAbstractModifer:"'abstract' modifier can only appear on a class, method, or property declaration.",OptionalTypeBeforeRequired:"A required element cannot follow an optional element.",OverrideNotInSubClass:"This member cannot have an 'override' modifier because its containing class does not extend another class.",PatternIsOptional:"A binding pattern parameter cannot be optional in an implementation signature.",PrivateElementHasAbstract:"Private elements cannot have the 'abstract' modifier.",PrivateElementHasAccessibility:({modifier})=>`Private elements cannot have an accessibility modifier ('${modifier}').`,ReadonlyForMethodSignature:"'readonly' modifier can only appear on a property declaration or index signature.",ReservedArrowTypeParam:"This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",ReservedTypeAssertion:"This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",SetAccessorCannotHaveOptionalParameter:"A 'set' accessor cannot have an optional parameter.",SetAccessorCannotHaveRestParameter:"A 'set' accessor cannot have rest parameter.",SetAccessorCannotHaveReturnType:"A 'set' accessor cannot have a return type annotation.",SingleTypeParameterWithoutTrailingComma:({typeParameterName})=>`Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`,StaticBlockCannotHaveModifier:"Static class blocks cannot have any modifier.",TupleOptionalAfterType:"A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).",TypeAnnotationAfterAssign:"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",TypeImportCannotSpecifyDefaultAndNamed:"A type-only import can specify a default import or named bindings, but not both.",TypeModifierIsUsedInTypeExports:"The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",TypeModifierIsUsedInTypeImports:"The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",UnexpectedParameterModifier:"A parameter property is only allowed in a constructor implementation.",UnexpectedReadonly:"'readonly' type modifier is only permitted on array and tuple literal types.",UnexpectedTypeAnnotation:"Did not expect a type annotation here.",UnexpectedTypeCastInParameter:"Unexpected type cast in parameter position.",UnsupportedImportTypeArgument:"Argument in a type import must be a string literal.",UnsupportedParameterPropertyKind:"A parameter property may not be declared using a binding pattern.",UnsupportedSignatureParameterKind:({type})=>`Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.`});function tsIsAccessModifier(modifier){return "private"===modifier||"public"===modifier||"protected"===modifier}function tsIsVarianceAnnotations(modifier){return "in"===modifier||"out"===modifier}function isPossiblyLiteralEnum(expression){if("MemberExpression"!==expression.type)return  false;const{computed,property}=expression;return (!computed||"StringLiteral"===property.type||!("TemplateLiteral"!==property.type||property.expressions.length>0))&&isUncomputedMemberExpressionChain(expression.object)}function isValidAmbientConstInitializer(expression,estree){var _expression$extra;const{type}=expression;if(null!=(_expression$extra=expression.extra)&&_expression$extra.parenthesized)return  false;if(estree){if("Literal"===type){const{value}=expression;if("string"==typeof value||"boolean"==typeof value)return  true}}else if("StringLiteral"===type||"BooleanLiteral"===type)return  true;return !(!isNumber(expression,estree)&&!function(expression,estree){if("UnaryExpression"===expression.type){const{operator,argument}=expression;if("-"===operator&&isNumber(argument,estree))return  true}return  false}(expression,estree))||("TemplateLiteral"===type&&0===expression.expressions.length||!!isPossiblyLiteralEnum(expression))}function isNumber(expression,estree){return estree?"Literal"===expression.type&&("number"==typeof expression.value||"bigint"in expression):"NumericLiteral"===expression.type||"BigIntLiteral"===expression.type}function isUncomputedMemberExpressionChain(expression){return "Identifier"===expression.type||"MemberExpression"===expression.type&&!expression.computed&&isUncomputedMemberExpressionChain(expression.object)}const PlaceholderErrors=ParseErrorEnum`placeholders`({ClassNameIsRequired:"A class name is required.",UnexpectedSpace:"Unexpected space in placeholder."});const PIPELINE_PROPOSALS=["minimal","fsharp","hack","smart"],TOPIC_TOKENS=["^^","@@","^","%","#"];const mixinPlugins={estree:superClass=>class extends superClass{parse(){const file=toESTreeLocation(super.parse());return this.options.tokens&&(file.tokens=file.tokens.map(toESTreeLocation)),file}parseRegExpLiteral({pattern,flags}){let regex=null;try{regex=new RegExp(pattern,flags);}catch(_){}const node=this.estreeParseLiteral(regex);return node.regex={pattern,flags},node}parseBigIntLiteral(value){let bigInt;try{bigInt=BigInt(value);}catch(_unused){bigInt=null;}const node=this.estreeParseLiteral(bigInt);return node.bigint=String(node.value||value),node}parseDecimalLiteral(value){const node=this.estreeParseLiteral(null);return node.decimal=String(node.value||value),node}estreeParseLiteral(value){return this.parseLiteral(value,"Literal")}parseStringLiteral(value){return this.estreeParseLiteral(value)}parseNumericLiteral(value){return this.estreeParseLiteral(value)}parseNullLiteral(){return this.estreeParseLiteral(null)}parseBooleanLiteral(value){return this.estreeParseLiteral(value)}directiveToStmt(directive){const expression=directive.value;delete directive.value,expression.type="Literal",expression.raw=expression.extra.raw,expression.value=expression.extra.expressionValue;const stmt=directive;return stmt.type="ExpressionStatement",stmt.expression=expression,stmt.directive=expression.extra.rawValue,delete expression.extra,stmt}initFunction(node,isAsync){super.initFunction(node,isAsync),node.expression=false;}checkDeclaration(node){null!=node&&this.isObjectProperty(node)?this.checkDeclaration(node.value):super.checkDeclaration(node);}getObjectOrClassMethodParams(method){return method.value.params}isValidDirective(stmt){var _stmt$expression$extr;return "ExpressionStatement"===stmt.type&&"Literal"===stmt.expression.type&&"string"==typeof stmt.expression.value&&!(null!=(_stmt$expression$extr=stmt.expression.extra)&&_stmt$expression$extr.parenthesized)}parseBlockBody(node,allowDirectives,topLevel,end,afterBlockParse){super.parseBlockBody(node,allowDirectives,topLevel,end,afterBlockParse);const directiveStatements=node.directives.map((d=>this.directiveToStmt(d)));node.body=directiveStatements.concat(node.body),delete node.directives;}pushClassMethod(classBody,method,isGenerator,isAsync,isConstructor,allowsDirectSuper){this.parseMethod(method,isGenerator,isAsync,isConstructor,allowsDirectSuper,"ClassMethod",true),method.typeParameters&&(method.value.typeParameters=method.typeParameters,delete method.typeParameters),classBody.body.push(method);}parsePrivateName(){const node=super.parsePrivateName();return this.getPluginOption("estree","classFeatures")?this.convertPrivateNameToPrivateIdentifier(node):node}convertPrivateNameToPrivateIdentifier(node){const name=super.getPrivateNameSV(node);return delete node.id,node.name=name,node.type="PrivateIdentifier",node}isPrivateName(node){return this.getPluginOption("estree","classFeatures")?"PrivateIdentifier"===node.type:super.isPrivateName(node)}getPrivateNameSV(node){return this.getPluginOption("estree","classFeatures")?node.name:super.getPrivateNameSV(node)}parseLiteral(value,type){const node=super.parseLiteral(value,type);return node.raw=node.extra.raw,delete node.extra,node}parseFunctionBody(node,allowExpression,isMethod=false){super.parseFunctionBody(node,allowExpression,isMethod),node.expression="BlockStatement"!==node.body.type;}parseMethod(node,isGenerator,isAsync,isConstructor,allowDirectSuper,type,inClassScope=false){let funcNode=this.startNode();return funcNode.kind=node.kind,funcNode=super.parseMethod(funcNode,isGenerator,isAsync,isConstructor,allowDirectSuper,type,inClassScope),funcNode.type="FunctionExpression",delete funcNode.kind,node.value=funcNode,"ClassPrivateMethod"===type&&(node.computed=false),this.finishNode(node,"MethodDefinition")}nameIsConstructor(key){return "Literal"===key.type?"constructor"===key.value:super.nameIsConstructor(key)}parseClassProperty(...args){const propertyNode=super.parseClassProperty(...args);return this.getPluginOption("estree","classFeatures")?(propertyNode.type="PropertyDefinition",propertyNode):propertyNode}parseClassPrivateProperty(...args){const propertyNode=super.parseClassPrivateProperty(...args);return this.getPluginOption("estree","classFeatures")?(propertyNode.type="PropertyDefinition",propertyNode.computed=false,propertyNode):propertyNode}parseObjectMethod(prop,isGenerator,isAsync,isPattern,isAccessor){const node=super.parseObjectMethod(prop,isGenerator,isAsync,isPattern,isAccessor);return node&&(node.type="Property","method"===node.kind&&(node.kind="init"),node.shorthand=false),node}parseObjectProperty(prop,startLoc,isPattern,refExpressionErrors){const node=super.parseObjectProperty(prop,startLoc,isPattern,refExpressionErrors);return node&&(node.kind="init",node.type="Property"),node}isValidLVal(type,isUnparenthesizedInAssign,binding){return "Property"===type?"value":super.isValidLVal(type,isUnparenthesizedInAssign,binding)}isAssignable(node,isBinding){return null!=node&&this.isObjectProperty(node)?this.isAssignable(node.value,isBinding):super.isAssignable(node,isBinding)}toAssignable(node,isLHS=false){if(null!=node&&this.isObjectProperty(node)){const{key,value}=node;this.isPrivateName(key)&&this.classScope.usePrivateName(this.getPrivateNameSV(key),key.loc.start),this.toAssignable(value,isLHS);}else super.toAssignable(node,isLHS);}toAssignableObjectExpressionProp(prop,isLast,isLHS){"Property"!==prop.type||"get"!==prop.kind&&"set"!==prop.kind?"Property"===prop.type&&prop.method?this.raise(Errors.PatternHasMethod,prop.key):super.toAssignableObjectExpressionProp(prop,isLast,isLHS):this.raise(Errors.PatternHasAccessor,prop.key);}finishCallExpression(unfinished,optional){const node=super.finishCallExpression(unfinished,optional);var _ref,_ref2;"Import"===node.callee.type&&(node.type="ImportExpression",node.source=node.arguments[0],node.options=null!=(_ref=node.arguments[1])?_ref:null,node.attributes=null!=(_ref2=node.arguments[1])?_ref2:null,delete node.arguments,delete node.callee);return node}toReferencedArguments(node){"ImportExpression"!==node.type&&super.toReferencedArguments(node);}parseExport(unfinished,decorators){const exportStartLoc=this.state.lastTokStartLoc,node=super.parseExport(unfinished,decorators);switch(node.type){case "ExportAllDeclaration":node.exported=null;break;case "ExportNamedDeclaration":1===node.specifiers.length&&"ExportNamespaceSpecifier"===node.specifiers[0].type&&(node.type="ExportAllDeclaration",node.exported=node.specifiers[0].exported,delete node.specifiers);case "ExportDefaultDeclaration":{var _declaration$decorato;const{declaration}=node;"ClassDeclaration"===(null==declaration?void 0:declaration.type)&&(null==(_declaration$decorato=declaration.decorators)?void 0:_declaration$decorato.length)>0&&declaration.start===node.start&&this.resetStartLocation(node,exportStartLoc);}}return node}parseSubscript(base,startLoc,noCalls,state){const node=super.parseSubscript(base,startLoc,noCalls,state);if(state.optionalChainMember){if("OptionalMemberExpression"!==node.type&&"OptionalCallExpression"!==node.type||(node.type=node.type.substring(8)),state.stop){const chain=this.startNodeAtNode(node);return chain.expression=node,this.finishNode(chain,"ChainExpression")}}else "MemberExpression"!==node.type&&"CallExpression"!==node.type||(node.optional=false);return node}isOptionalMemberExpression(node){return "ChainExpression"===node.type?"MemberExpression"===node.expression.type:super.isOptionalMemberExpression(node)}hasPropertyAsPrivateName(node){return "ChainExpression"===node.type&&(node=node.expression),super.hasPropertyAsPrivateName(node)}isObjectProperty(node){return "Property"===node.type&&"init"===node.kind&&!node.method}isObjectMethod(node){return "Property"===node.type&&(node.method||"get"===node.kind||"set"===node.kind)}finishNodeAt(node,type,endLoc){return toESTreeLocation(super.finishNodeAt(node,type,endLoc))}resetStartLocation(node,startLoc){super.resetStartLocation(node,startLoc),toESTreeLocation(node);}resetEndLocation(node,endLoc=this.state.lastTokEndLoc){super.resetEndLocation(node,endLoc),toESTreeLocation(node);}},jsx:superClass=>class extends superClass{jsxReadToken(){let out="",chunkStart=this.state.pos;for(;;){if(this.state.pos>=this.length)throw this.raise(JsxErrors.UnterminatedJsxContent,this.state.startLoc);const ch=this.input.charCodeAt(this.state.pos);switch(ch){case 60:case 123:return this.state.pos===this.state.start?void(60===ch&&this.state.canStartJSXElement?(++this.state.pos,this.finishToken(143)):super.getTokenFromCode(ch)):(out+=this.input.slice(chunkStart,this.state.pos),void this.finishToken(142,out));case 38:out+=this.input.slice(chunkStart,this.state.pos),out+=this.jsxReadEntity(),chunkStart=this.state.pos;break;default:isNewLine(ch)?(out+=this.input.slice(chunkStart,this.state.pos),out+=this.jsxReadNewLine(true),chunkStart=this.state.pos):++this.state.pos;}}}jsxReadNewLine(normalizeCRLF){const ch=this.input.charCodeAt(this.state.pos);let out;return ++this.state.pos,13===ch&&10===this.input.charCodeAt(this.state.pos)?(++this.state.pos,out=normalizeCRLF?"\n":"\r\n"):out=String.fromCharCode(ch),++this.state.curLine,this.state.lineStart=this.state.pos,out}jsxReadString(quote){let out="",chunkStart=++this.state.pos;for(;;){if(this.state.pos>=this.length)throw this.raise(Errors.UnterminatedString,this.state.startLoc);const ch=this.input.charCodeAt(this.state.pos);if(ch===quote)break;38===ch?(out+=this.input.slice(chunkStart,this.state.pos),out+=this.jsxReadEntity(),chunkStart=this.state.pos):isNewLine(ch)?(out+=this.input.slice(chunkStart,this.state.pos),out+=this.jsxReadNewLine(false),chunkStart=this.state.pos):++this.state.pos;}out+=this.input.slice(chunkStart,this.state.pos++),this.finishToken(134,out);}jsxReadEntity(){const startPos=++this.state.pos;if(35===this.codePointAtPos(this.state.pos)){++this.state.pos;let radix=10;120===this.codePointAtPos(this.state.pos)&&(radix=16,++this.state.pos);const codePoint=this.readInt(radix,void 0,false,"bail");if(null!==codePoint&&59===this.codePointAtPos(this.state.pos))return ++this.state.pos,String.fromCodePoint(codePoint)}else {let count=0,semi=false;for(;count++<10&&this.state.pos<this.length&&!(semi=59===this.codePointAtPos(this.state.pos));)++this.state.pos;if(semi){const desc=this.input.slice(startPos,this.state.pos),entity=entities[desc];if(++this.state.pos,entity)return entity}}return this.state.pos=startPos,"&"}jsxReadWord(){let ch;const start=this.state.pos;do{ch=this.input.charCodeAt(++this.state.pos);}while(isIdentifierChar(ch)||45===ch);this.finishToken(141,this.input.slice(start,this.state.pos));}jsxParseIdentifier(){const node=this.startNode();return this.match(141)?node.name=this.state.value:tokenIsKeyword(this.state.type)?node.name=tokenLabelName(this.state.type):this.unexpected(),this.next(),this.finishNode(node,"JSXIdentifier")}jsxParseNamespacedName(){const startLoc=this.state.startLoc,name=this.jsxParseIdentifier();if(!this.eat(14))return name;const node=this.startNodeAt(startLoc);return node.namespace=name,node.name=this.jsxParseIdentifier(),this.finishNode(node,"JSXNamespacedName")}jsxParseElementName(){const startLoc=this.state.startLoc;let node=this.jsxParseNamespacedName();if("JSXNamespacedName"===node.type)return node;for(;this.eat(16);){const newNode=this.startNodeAt(startLoc);newNode.object=node,newNode.property=this.jsxParseIdentifier(),node=this.finishNode(newNode,"JSXMemberExpression");}return node}jsxParseAttributeValue(){let node;switch(this.state.type){case 5:return node=this.startNode(),this.setContext(types.brace),this.next(),node=this.jsxParseExpressionContainer(node,types.j_oTag),"JSXEmptyExpression"===node.expression.type&&this.raise(JsxErrors.AttributeIsEmpty,node),node;case 143:case 134:return this.parseExprAtom();default:throw this.raise(JsxErrors.UnsupportedJsxValue,this.state.startLoc)}}jsxParseEmptyExpression(){const node=this.startNodeAt(this.state.lastTokEndLoc);return this.finishNodeAt(node,"JSXEmptyExpression",this.state.startLoc)}jsxParseSpreadChild(node){return this.next(),node.expression=this.parseExpression(),this.setContext(types.j_expr),this.state.canStartJSXElement=true,this.expect(8),this.finishNode(node,"JSXSpreadChild")}jsxParseExpressionContainer(node,previousContext){if(this.match(8))node.expression=this.jsxParseEmptyExpression();else {const expression=this.parseExpression();node.expression=expression;}return this.setContext(previousContext),this.state.canStartJSXElement=true,this.expect(8),this.finishNode(node,"JSXExpressionContainer")}jsxParseAttribute(){const node=this.startNode();return this.match(5)?(this.setContext(types.brace),this.next(),this.expect(21),node.argument=this.parseMaybeAssignAllowIn(),this.setContext(types.j_oTag),this.state.canStartJSXElement=true,this.expect(8),this.finishNode(node,"JSXSpreadAttribute")):(node.name=this.jsxParseNamespacedName(),node.value=this.eat(29)?this.jsxParseAttributeValue():null,this.finishNode(node,"JSXAttribute"))}jsxParseOpeningElementAt(startLoc){const node=this.startNodeAt(startLoc);return this.eat(144)?this.finishNode(node,"JSXOpeningFragment"):(node.name=this.jsxParseElementName(),this.jsxParseOpeningElementAfterName(node))}jsxParseOpeningElementAfterName(node){const attributes=[];for(;!this.match(56)&&!this.match(144);)attributes.push(this.jsxParseAttribute());return node.attributes=attributes,node.selfClosing=this.eat(56),this.expect(144),this.finishNode(node,"JSXOpeningElement")}jsxParseClosingElementAt(startLoc){const node=this.startNodeAt(startLoc);return this.eat(144)?this.finishNode(node,"JSXClosingFragment"):(node.name=this.jsxParseElementName(),this.expect(144),this.finishNode(node,"JSXClosingElement"))}jsxParseElementAt(startLoc){const node=this.startNodeAt(startLoc),children=[],openingElement=this.jsxParseOpeningElementAt(startLoc);let closingElement=null;if(!openingElement.selfClosing){contents:for(;;)switch(this.state.type){case 143:if(startLoc=this.state.startLoc,this.next(),this.eat(56)){closingElement=this.jsxParseClosingElementAt(startLoc);break contents}children.push(this.jsxParseElementAt(startLoc));break;case 142:children.push(this.parseLiteral(this.state.value,"JSXText"));break;case 5:{const node=this.startNode();this.setContext(types.brace),this.next(),this.match(21)?children.push(this.jsxParseSpreadChild(node)):children.push(this.jsxParseExpressionContainer(node,types.j_expr));break}default:this.unexpected();}isFragment(openingElement)&&!isFragment(closingElement)&&null!==closingElement?this.raise(JsxErrors.MissingClosingTagFragment,closingElement):!isFragment(openingElement)&&isFragment(closingElement)?this.raise(JsxErrors.MissingClosingTagElement,closingElement,{openingTagName:getQualifiedJSXName(openingElement.name)}):isFragment(openingElement)||isFragment(closingElement)||getQualifiedJSXName(closingElement.name)!==getQualifiedJSXName(openingElement.name)&&this.raise(JsxErrors.MissingClosingTagElement,closingElement,{openingTagName:getQualifiedJSXName(openingElement.name)});}if(isFragment(openingElement)?(node.openingFragment=openingElement,node.closingFragment=closingElement):(node.openingElement=openingElement,node.closingElement=closingElement),node.children=children,this.match(47))throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements,this.state.startLoc);return isFragment(openingElement)?this.finishNode(node,"JSXFragment"):this.finishNode(node,"JSXElement")}jsxParseElement(){const startLoc=this.state.startLoc;return this.next(),this.jsxParseElementAt(startLoc)}setContext(newContext){const{context}=this.state;context[context.length-1]=newContext;}parseExprAtom(refExpressionErrors){return this.match(143)?this.jsxParseElement():this.match(47)&&33!==this.input.charCodeAt(this.state.pos)?(this.replaceToken(143),this.jsxParseElement()):super.parseExprAtom(refExpressionErrors)}skipSpace(){this.curContext().preserveSpace||super.skipSpace();}getTokenFromCode(code){const context=this.curContext();if(context!==types.j_expr){if(context===types.j_oTag||context===types.j_cTag){if(isIdentifierStart(code))return void this.jsxReadWord();if(62===code)return ++this.state.pos,void this.finishToken(144);if((34===code||39===code)&&context===types.j_oTag)return void this.jsxReadString(code)}if(60===code&&this.state.canStartJSXElement&&33!==this.input.charCodeAt(this.state.pos+1))return ++this.state.pos,void this.finishToken(143);super.getTokenFromCode(code);}else this.jsxReadToken();}updateContext(prevType){const{context,type}=this.state;if(56===type&&143===prevType)context.splice(-2,2,types.j_cTag),this.state.canStartJSXElement=false;else if(143===type)context.push(types.j_oTag);else if(144===type){const out=context[context.length-1];out===types.j_oTag&&56===prevType||out===types.j_cTag?(context.pop(),this.state.canStartJSXElement=context[context.length-1]===types.j_expr):(this.setContext(types.j_expr),this.state.canStartJSXElement=true);}else this.state.canStartJSXElement=tokenBeforeExprs[type];}},flow:superClass=>class extends superClass{constructor(...args){super(...args),this.flowPragma=void 0;}getScopeHandler(){return FlowScopeHandler}shouldParseTypes(){return this.getPluginOption("flow","all")||"flow"===this.flowPragma}finishToken(type,val){134!==type&&13!==type&&28!==type&&void 0===this.flowPragma&&(this.flowPragma=null),super.finishToken(type,val);}addComment(comment){if(void 0===this.flowPragma){const matches=FLOW_PRAGMA_REGEX.exec(comment.value);if(matches)if("flow"===matches[1])this.flowPragma="flow";else {if("noflow"!==matches[1])throw new Error("Unexpected flow pragma");this.flowPragma="noflow";}}super.addComment(comment);}flowParseTypeInitialiser(tok){const oldInType=this.state.inType;this.state.inType=true,this.expect(tok||14);const type=this.flowParseType();return this.state.inType=oldInType,type}flowParsePredicate(){const node=this.startNode(),moduloLoc=this.state.startLoc;return this.next(),this.expectContextual(110),this.state.lastTokStartLoc.index>moduloLoc.index+1&&this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks,moduloLoc),this.eat(10)?(node.value=super.parseExpression(),this.expect(11),this.finishNode(node,"DeclaredPredicate")):this.finishNode(node,"InferredPredicate")}flowParseTypeAndPredicateInitialiser(){const oldInType=this.state.inType;this.state.inType=true,this.expect(14);let type=null,predicate=null;return this.match(54)?(this.state.inType=oldInType,predicate=this.flowParsePredicate()):(type=this.flowParseType(),this.state.inType=oldInType,this.match(54)&&(predicate=this.flowParsePredicate())),[type,predicate]}flowParseDeclareClass(node){return this.next(),this.flowParseInterfaceish(node,true),this.finishNode(node,"DeclareClass")}flowParseDeclareFunction(node){this.next();const id=node.id=this.parseIdentifier(),typeNode=this.startNode(),typeContainer=this.startNode();this.match(47)?typeNode.typeParameters=this.flowParseTypeParameterDeclaration():typeNode.typeParameters=null,this.expect(10);const tmp=this.flowParseFunctionTypeParams();return typeNode.params=tmp.params,typeNode.rest=tmp.rest,typeNode.this=tmp._this,this.expect(11),[typeNode.returnType,node.predicate]=this.flowParseTypeAndPredicateInitialiser(),typeContainer.typeAnnotation=this.finishNode(typeNode,"FunctionTypeAnnotation"),id.typeAnnotation=this.finishNode(typeContainer,"TypeAnnotation"),this.resetEndLocation(id),this.semicolon(),this.scope.declareName(node.id.name,2048,node.id.loc.start),this.finishNode(node,"DeclareFunction")}flowParseDeclare(node,insideModule){return this.match(80)?this.flowParseDeclareClass(node):this.match(68)?this.flowParseDeclareFunction(node):this.match(74)?this.flowParseDeclareVariable(node):this.eatContextual(127)?this.match(16)?this.flowParseDeclareModuleExports(node):(insideModule&&this.raise(FlowErrors.NestedDeclareModule,this.state.lastTokStartLoc),this.flowParseDeclareModule(node)):this.isContextual(130)?this.flowParseDeclareTypeAlias(node):this.isContextual(131)?this.flowParseDeclareOpaqueType(node):this.isContextual(129)?this.flowParseDeclareInterface(node):this.match(82)?this.flowParseDeclareExportDeclaration(node,insideModule):void this.unexpected()}flowParseDeclareVariable(node){return this.next(),node.id=this.flowParseTypeAnnotatableIdentifier(true),this.scope.declareName(node.id.name,5,node.id.loc.start),this.semicolon(),this.finishNode(node,"DeclareVariable")}flowParseDeclareModule(node){this.scope.enter(0),this.match(134)?node.id=super.parseExprAtom():node.id=this.parseIdentifier();const bodyNode=node.body=this.startNode(),body=bodyNode.body=[];for(this.expect(5);!this.match(8);){let bodyNode=this.startNode();this.match(83)?(this.next(),this.isContextual(130)||this.match(87)||this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule,this.state.lastTokStartLoc),super.parseImport(bodyNode)):(this.expectContextual(125,FlowErrors.UnsupportedStatementInDeclareModule),bodyNode=this.flowParseDeclare(bodyNode,true)),body.push(bodyNode);}this.scope.exit(),this.expect(8),this.finishNode(bodyNode,"BlockStatement");let kind=null,hasModuleExport=false;return body.forEach((bodyElement=>{!function(bodyElement){return "DeclareExportAllDeclaration"===bodyElement.type||"DeclareExportDeclaration"===bodyElement.type&&(!bodyElement.declaration||"TypeAlias"!==bodyElement.declaration.type&&"InterfaceDeclaration"!==bodyElement.declaration.type)}(bodyElement)?"DeclareModuleExports"===bodyElement.type&&(hasModuleExport&&this.raise(FlowErrors.DuplicateDeclareModuleExports,bodyElement),"ES"===kind&&this.raise(FlowErrors.AmbiguousDeclareModuleKind,bodyElement),kind="CommonJS",hasModuleExport=true):("CommonJS"===kind&&this.raise(FlowErrors.AmbiguousDeclareModuleKind,bodyElement),kind="ES");})),node.kind=kind||"CommonJS",this.finishNode(node,"DeclareModule")}flowParseDeclareExportDeclaration(node,insideModule){if(this.expect(82),this.eat(65))return this.match(68)||this.match(80)?node.declaration=this.flowParseDeclare(this.startNode()):(node.declaration=this.flowParseType(),this.semicolon()),node.default=true,this.finishNode(node,"DeclareExportDeclaration");if(this.match(75)||this.isLet()||(this.isContextual(130)||this.isContextual(129))&&!insideModule){const label=this.state.value;throw this.raise(FlowErrors.UnsupportedDeclareExportKind,this.state.startLoc,{unsupportedExportKind:label,suggestion:exportSuggestions[label]})}return this.match(74)||this.match(68)||this.match(80)||this.isContextual(131)?(node.declaration=this.flowParseDeclare(this.startNode()),node.default=false,this.finishNode(node,"DeclareExportDeclaration")):this.match(55)||this.match(5)||this.isContextual(129)||this.isContextual(130)||this.isContextual(131)?("ExportNamedDeclaration"===(node=this.parseExport(node,null)).type&&(node.type="ExportDeclaration",node.default=false,delete node.exportKind),node.type="Declare"+node.type,node):void this.unexpected()}flowParseDeclareModuleExports(node){return this.next(),this.expectContextual(111),node.typeAnnotation=this.flowParseTypeAnnotation(),this.semicolon(),this.finishNode(node,"DeclareModuleExports")}flowParseDeclareTypeAlias(node){this.next();const finished=this.flowParseTypeAlias(node);return finished.type="DeclareTypeAlias",finished}flowParseDeclareOpaqueType(node){this.next();const finished=this.flowParseOpaqueType(node,true);return finished.type="DeclareOpaqueType",finished}flowParseDeclareInterface(node){return this.next(),this.flowParseInterfaceish(node,false),this.finishNode(node,"DeclareInterface")}flowParseInterfaceish(node,isClass){if(node.id=this.flowParseRestrictedIdentifier(!isClass,true),this.scope.declareName(node.id.name,isClass?17:8201,node.id.loc.start),this.match(47)?node.typeParameters=this.flowParseTypeParameterDeclaration():node.typeParameters=null,node.extends=[],this.eat(81))do{node.extends.push(this.flowParseInterfaceExtends());}while(!isClass&&this.eat(12));if(isClass){if(node.implements=[],node.mixins=[],this.eatContextual(117))do{node.mixins.push(this.flowParseInterfaceExtends());}while(this.eat(12));if(this.eatContextual(113))do{node.implements.push(this.flowParseInterfaceExtends());}while(this.eat(12))}node.body=this.flowParseObjectType({allowStatic:isClass,allowExact:false,allowSpread:false,allowProto:isClass,allowInexact:false});}flowParseInterfaceExtends(){const node=this.startNode();return node.id=this.flowParseQualifiedTypeIdentifier(),this.match(47)?node.typeParameters=this.flowParseTypeParameterInstantiation():node.typeParameters=null,this.finishNode(node,"InterfaceExtends")}flowParseInterface(node){return this.flowParseInterfaceish(node,false),this.finishNode(node,"InterfaceDeclaration")}checkNotUnderscore(word){"_"===word&&this.raise(FlowErrors.UnexpectedReservedUnderscore,this.state.startLoc);}checkReservedType(word,startLoc,declaration){reservedTypes.has(word)&&this.raise(declaration?FlowErrors.AssignReservedType:FlowErrors.UnexpectedReservedType,startLoc,{reservedType:word});}flowParseRestrictedIdentifier(liberal,declaration){return this.checkReservedType(this.state.value,this.state.startLoc,declaration),this.parseIdentifier(liberal)}flowParseTypeAlias(node){return node.id=this.flowParseRestrictedIdentifier(false,true),this.scope.declareName(node.id.name,8201,node.id.loc.start),this.match(47)?node.typeParameters=this.flowParseTypeParameterDeclaration():node.typeParameters=null,node.right=this.flowParseTypeInitialiser(29),this.semicolon(),this.finishNode(node,"TypeAlias")}flowParseOpaqueType(node,declare){return this.expectContextual(130),node.id=this.flowParseRestrictedIdentifier(true,true),this.scope.declareName(node.id.name,8201,node.id.loc.start),this.match(47)?node.typeParameters=this.flowParseTypeParameterDeclaration():node.typeParameters=null,node.supertype=null,this.match(14)&&(node.supertype=this.flowParseTypeInitialiser(14)),node.impltype=null,declare||(node.impltype=this.flowParseTypeInitialiser(29)),this.semicolon(),this.finishNode(node,"OpaqueType")}flowParseTypeParameter(requireDefault=false){const nodeStartLoc=this.state.startLoc,node=this.startNode(),variance=this.flowParseVariance(),ident=this.flowParseTypeAnnotatableIdentifier();return node.name=ident.name,node.variance=variance,node.bound=ident.typeAnnotation,this.match(29)?(this.eat(29),node.default=this.flowParseType()):requireDefault&&this.raise(FlowErrors.MissingTypeParamDefault,nodeStartLoc),this.finishNode(node,"TypeParameter")}flowParseTypeParameterDeclaration(){const oldInType=this.state.inType,node=this.startNode();node.params=[],this.state.inType=true,this.match(47)||this.match(143)?this.next():this.unexpected();let defaultRequired=false;do{const typeParameter=this.flowParseTypeParameter(defaultRequired);node.params.push(typeParameter),typeParameter.default&&(defaultRequired=true),this.match(48)||this.expect(12);}while(!this.match(48));return this.expect(48),this.state.inType=oldInType,this.finishNode(node,"TypeParameterDeclaration")}flowParseTypeParameterInstantiation(){const node=this.startNode(),oldInType=this.state.inType;node.params=[],this.state.inType=true,this.expect(47);const oldNoAnonFunctionType=this.state.noAnonFunctionType;for(this.state.noAnonFunctionType=false;!this.match(48);)node.params.push(this.flowParseType()),this.match(48)||this.expect(12);return this.state.noAnonFunctionType=oldNoAnonFunctionType,this.expect(48),this.state.inType=oldInType,this.finishNode(node,"TypeParameterInstantiation")}flowParseTypeParameterInstantiationCallOrNew(){const node=this.startNode(),oldInType=this.state.inType;for(node.params=[],this.state.inType=true,this.expect(47);!this.match(48);)node.params.push(this.flowParseTypeOrImplicitInstantiation()),this.match(48)||this.expect(12);return this.expect(48),this.state.inType=oldInType,this.finishNode(node,"TypeParameterInstantiation")}flowParseInterfaceType(){const node=this.startNode();if(this.expectContextual(129),node.extends=[],this.eat(81))do{node.extends.push(this.flowParseInterfaceExtends());}while(this.eat(12));return node.body=this.flowParseObjectType({allowStatic:false,allowExact:false,allowSpread:false,allowProto:false,allowInexact:false}),this.finishNode(node,"InterfaceTypeAnnotation")}flowParseObjectPropertyKey(){return this.match(135)||this.match(134)?super.parseExprAtom():this.parseIdentifier(true)}flowParseObjectTypeIndexer(node,isStatic,variance){return node.static=isStatic,14===this.lookahead().type?(node.id=this.flowParseObjectPropertyKey(),node.key=this.flowParseTypeInitialiser()):(node.id=null,node.key=this.flowParseType()),this.expect(3),node.value=this.flowParseTypeInitialiser(),node.variance=variance,this.finishNode(node,"ObjectTypeIndexer")}flowParseObjectTypeInternalSlot(node,isStatic){return node.static=isStatic,node.id=this.flowParseObjectPropertyKey(),this.expect(3),this.expect(3),this.match(47)||this.match(10)?(node.method=true,node.optional=false,node.value=this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start))):(node.method=false,this.eat(17)&&(node.optional=true),node.value=this.flowParseTypeInitialiser()),this.finishNode(node,"ObjectTypeInternalSlot")}flowParseObjectTypeMethodish(node){for(node.params=[],node.rest=null,node.typeParameters=null,node.this=null,this.match(47)&&(node.typeParameters=this.flowParseTypeParameterDeclaration()),this.expect(10),this.match(78)&&(node.this=this.flowParseFunctionTypeParam(true),node.this.name=null,this.match(11)||this.expect(12));!this.match(11)&&!this.match(21);)node.params.push(this.flowParseFunctionTypeParam(false)),this.match(11)||this.expect(12);return this.eat(21)&&(node.rest=this.flowParseFunctionTypeParam(false)),this.expect(11),node.returnType=this.flowParseTypeInitialiser(),this.finishNode(node,"FunctionTypeAnnotation")}flowParseObjectTypeCallProperty(node,isStatic){const valueNode=this.startNode();return node.static=isStatic,node.value=this.flowParseObjectTypeMethodish(valueNode),this.finishNode(node,"ObjectTypeCallProperty")}flowParseObjectType({allowStatic,allowExact,allowSpread,allowProto,allowInexact}){const oldInType=this.state.inType;this.state.inType=true;const nodeStart=this.startNode();let endDelim,exact;nodeStart.callProperties=[],nodeStart.properties=[],nodeStart.indexers=[],nodeStart.internalSlots=[];let inexact=false;for(allowExact&&this.match(6)?(this.expect(6),endDelim=9,exact=true):(this.expect(5),endDelim=8,exact=false),nodeStart.exact=exact;!this.match(endDelim);){let isStatic=false,protoStartLoc=null,inexactStartLoc=null;const node=this.startNode();if(allowProto&&this.isContextual(118)){const lookahead=this.lookahead();14!==lookahead.type&&17!==lookahead.type&&(this.next(),protoStartLoc=this.state.startLoc,allowStatic=false);}if(allowStatic&&this.isContextual(106)){const lookahead=this.lookahead();14!==lookahead.type&&17!==lookahead.type&&(this.next(),isStatic=true);}const variance=this.flowParseVariance();if(this.eat(0))null!=protoStartLoc&&this.unexpected(protoStartLoc),this.eat(0)?(variance&&this.unexpected(variance.loc.start),nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node,isStatic))):nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node,isStatic,variance));else if(this.match(10)||this.match(47))null!=protoStartLoc&&this.unexpected(protoStartLoc),variance&&this.unexpected(variance.loc.start),nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node,isStatic));else {let kind="init";if(this.isContextual(99)||this.isContextual(104)){tokenIsLiteralPropertyName(this.lookahead().type)&&(kind=this.state.value,this.next());}const propOrInexact=this.flowParseObjectTypeProperty(node,isStatic,protoStartLoc,variance,kind,allowSpread,null!=allowInexact?allowInexact:!exact);null===propOrInexact?(inexact=true,inexactStartLoc=this.state.lastTokStartLoc):nodeStart.properties.push(propOrInexact);}this.flowObjectTypeSemicolon(),!inexactStartLoc||this.match(8)||this.match(9)||this.raise(FlowErrors.UnexpectedExplicitInexactInObject,inexactStartLoc);}this.expect(endDelim),allowSpread&&(nodeStart.inexact=inexact);const out=this.finishNode(nodeStart,"ObjectTypeAnnotation");return this.state.inType=oldInType,out}flowParseObjectTypeProperty(node,isStatic,protoStartLoc,variance,kind,allowSpread,allowInexact){if(this.eat(21)){return this.match(12)||this.match(13)||this.match(8)||this.match(9)?(allowSpread?allowInexact||this.raise(FlowErrors.InexactInsideExact,this.state.lastTokStartLoc):this.raise(FlowErrors.InexactInsideNonObject,this.state.lastTokStartLoc),variance&&this.raise(FlowErrors.InexactVariance,variance),null):(allowSpread||this.raise(FlowErrors.UnexpectedSpreadType,this.state.lastTokStartLoc),null!=protoStartLoc&&this.unexpected(protoStartLoc),variance&&this.raise(FlowErrors.SpreadVariance,variance),node.argument=this.flowParseType(),this.finishNode(node,"ObjectTypeSpreadProperty"))}{node.key=this.flowParseObjectPropertyKey(),node.static=isStatic,node.proto=null!=protoStartLoc,node.kind=kind;let optional=false;return this.match(47)||this.match(10)?(node.method=true,null!=protoStartLoc&&this.unexpected(protoStartLoc),variance&&this.unexpected(variance.loc.start),node.value=this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start)),"get"!==kind&&"set"!==kind||this.flowCheckGetterSetterParams(node),!allowSpread&&"constructor"===node.key.name&&node.value.this&&this.raise(FlowErrors.ThisParamBannedInConstructor,node.value.this)):("init"!==kind&&this.unexpected(),node.method=false,this.eat(17)&&(optional=true),node.value=this.flowParseTypeInitialiser(),node.variance=variance),node.optional=optional,this.finishNode(node,"ObjectTypeProperty")}}flowCheckGetterSetterParams(property){const paramCount="get"===property.kind?0:1,length=property.value.params.length+(property.value.rest?1:0);property.value.this&&this.raise("get"===property.kind?FlowErrors.GetterMayNotHaveThisParam:FlowErrors.SetterMayNotHaveThisParam,property.value.this),length!==paramCount&&this.raise("get"===property.kind?Errors.BadGetterArity:Errors.BadSetterArity,property),"set"===property.kind&&property.value.rest&&this.raise(Errors.BadSetterRestParameter,property);}flowObjectTypeSemicolon(){this.eat(13)||this.eat(12)||this.match(8)||this.match(9)||this.unexpected();}flowParseQualifiedTypeIdentifier(startLoc,id){null!=startLoc||(startLoc=this.state.startLoc);let node=id||this.flowParseRestrictedIdentifier(true);for(;this.eat(16);){const node2=this.startNodeAt(startLoc);node2.qualification=node,node2.id=this.flowParseRestrictedIdentifier(true),node=this.finishNode(node2,"QualifiedTypeIdentifier");}return node}flowParseGenericType(startLoc,id){const node=this.startNodeAt(startLoc);return node.typeParameters=null,node.id=this.flowParseQualifiedTypeIdentifier(startLoc,id),this.match(47)&&(node.typeParameters=this.flowParseTypeParameterInstantiation()),this.finishNode(node,"GenericTypeAnnotation")}flowParseTypeofType(){const node=this.startNode();return this.expect(87),node.argument=this.flowParsePrimaryType(),this.finishNode(node,"TypeofTypeAnnotation")}flowParseTupleType(){const node=this.startNode();for(node.types=[],this.expect(0);this.state.pos<this.length&&!this.match(3)&&(node.types.push(this.flowParseType()),!this.match(3));)this.expect(12);return this.expect(3),this.finishNode(node,"TupleTypeAnnotation")}flowParseFunctionTypeParam(first){let name=null,optional=false,typeAnnotation=null;const node=this.startNode(),lh=this.lookahead(),isThis=78===this.state.type;return 14===lh.type||17===lh.type?(isThis&&!first&&this.raise(FlowErrors.ThisParamMustBeFirst,node),name=this.parseIdentifier(isThis),this.eat(17)&&(optional=true,isThis&&this.raise(FlowErrors.ThisParamMayNotBeOptional,node)),typeAnnotation=this.flowParseTypeInitialiser()):typeAnnotation=this.flowParseType(),node.name=name,node.optional=optional,node.typeAnnotation=typeAnnotation,this.finishNode(node,"FunctionTypeParam")}reinterpretTypeAsFunctionTypeParam(type){const node=this.startNodeAt(type.loc.start);return node.name=null,node.optional=false,node.typeAnnotation=type,this.finishNode(node,"FunctionTypeParam")}flowParseFunctionTypeParams(params=[]){let rest=null,_this=null;for(this.match(78)&&(_this=this.flowParseFunctionTypeParam(true),_this.name=null,this.match(11)||this.expect(12));!this.match(11)&&!this.match(21);)params.push(this.flowParseFunctionTypeParam(false)),this.match(11)||this.expect(12);return this.eat(21)&&(rest=this.flowParseFunctionTypeParam(false)),{params,rest,_this}}flowIdentToTypeAnnotation(startLoc,node,id){switch(id.name){case "any":return this.finishNode(node,"AnyTypeAnnotation");case "bool":case "boolean":return this.finishNode(node,"BooleanTypeAnnotation");case "mixed":return this.finishNode(node,"MixedTypeAnnotation");case "empty":return this.finishNode(node,"EmptyTypeAnnotation");case "number":return this.finishNode(node,"NumberTypeAnnotation");case "string":return this.finishNode(node,"StringTypeAnnotation");case "symbol":return this.finishNode(node,"SymbolTypeAnnotation");default:return this.checkNotUnderscore(id.name),this.flowParseGenericType(startLoc,id)}}flowParsePrimaryType(){const startLoc=this.state.startLoc,node=this.startNode();let tmp,type,isGroupedType=false;const oldNoAnonFunctionType=this.state.noAnonFunctionType;switch(this.state.type){case 5:return this.flowParseObjectType({allowStatic:false,allowExact:false,allowSpread:true,allowProto:false,allowInexact:true});case 6:return this.flowParseObjectType({allowStatic:false,allowExact:true,allowSpread:true,allowProto:false,allowInexact:false});case 0:return this.state.noAnonFunctionType=false,type=this.flowParseTupleType(),this.state.noAnonFunctionType=oldNoAnonFunctionType,type;case 47:{const node=this.startNode();return node.typeParameters=this.flowParseTypeParameterDeclaration(),this.expect(10),tmp=this.flowParseFunctionTypeParams(),node.params=tmp.params,node.rest=tmp.rest,node.this=tmp._this,this.expect(11),this.expect(19),node.returnType=this.flowParseType(),this.finishNode(node,"FunctionTypeAnnotation")}case 10:{const node=this.startNode();if(this.next(),!this.match(11)&&!this.match(21))if(tokenIsIdentifier(this.state.type)||this.match(78)){const token=this.lookahead().type;isGroupedType=17!==token&&14!==token;}else isGroupedType=true;if(isGroupedType){if(this.state.noAnonFunctionType=false,type=this.flowParseType(),this.state.noAnonFunctionType=oldNoAnonFunctionType,this.state.noAnonFunctionType||!(this.match(12)||this.match(11)&&19===this.lookahead().type))return this.expect(11),type;this.eat(12);}return tmp=type?this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]):this.flowParseFunctionTypeParams(),node.params=tmp.params,node.rest=tmp.rest,node.this=tmp._this,this.expect(11),this.expect(19),node.returnType=this.flowParseType(),node.typeParameters=null,this.finishNode(node,"FunctionTypeAnnotation")}case 134:return this.parseLiteral(this.state.value,"StringLiteralTypeAnnotation");case 85:case 86:return node.value=this.match(85),this.next(),this.finishNode(node,"BooleanLiteralTypeAnnotation");case 53:if("-"===this.state.value){if(this.next(),this.match(135))return this.parseLiteralAtNode(-this.state.value,"NumberLiteralTypeAnnotation",node);if(this.match(136))return this.parseLiteralAtNode(-this.state.value,"BigIntLiteralTypeAnnotation",node);throw this.raise(FlowErrors.UnexpectedSubtractionOperand,this.state.startLoc)}return void this.unexpected();case 135:return this.parseLiteral(this.state.value,"NumberLiteralTypeAnnotation");case 136:return this.parseLiteral(this.state.value,"BigIntLiteralTypeAnnotation");case 88:return this.next(),this.finishNode(node,"VoidTypeAnnotation");case 84:return this.next(),this.finishNode(node,"NullLiteralTypeAnnotation");case 78:return this.next(),this.finishNode(node,"ThisTypeAnnotation");case 55:return this.next(),this.finishNode(node,"ExistsTypeAnnotation");case 87:return this.flowParseTypeofType();default:if(tokenIsKeyword(this.state.type)){const label=tokenLabelName(this.state.type);return this.next(),super.createIdentifier(node,label)}if(tokenIsIdentifier(this.state.type))return this.isContextual(129)?this.flowParseInterfaceType():this.flowIdentToTypeAnnotation(startLoc,node,this.parseIdentifier())}this.unexpected();}flowParsePostfixType(){const startLoc=this.state.startLoc;let type=this.flowParsePrimaryType(),seenOptionalIndexedAccess=false;for(;(this.match(0)||this.match(18))&&!this.canInsertSemicolon();){const node=this.startNodeAt(startLoc),optional=this.eat(18);seenOptionalIndexedAccess=seenOptionalIndexedAccess||optional,this.expect(0),!optional&&this.match(3)?(node.elementType=type,this.next(),type=this.finishNode(node,"ArrayTypeAnnotation")):(node.objectType=type,node.indexType=this.flowParseType(),this.expect(3),seenOptionalIndexedAccess?(node.optional=optional,type=this.finishNode(node,"OptionalIndexedAccessType")):type=this.finishNode(node,"IndexedAccessType"));}return type}flowParsePrefixType(){const node=this.startNode();return this.eat(17)?(node.typeAnnotation=this.flowParsePrefixType(),this.finishNode(node,"NullableTypeAnnotation")):this.flowParsePostfixType()}flowParseAnonFunctionWithoutParens(){const param=this.flowParsePrefixType();if(!this.state.noAnonFunctionType&&this.eat(19)){const node=this.startNodeAt(param.loc.start);return node.params=[this.reinterpretTypeAsFunctionTypeParam(param)],node.rest=null,node.this=null,node.returnType=this.flowParseType(),node.typeParameters=null,this.finishNode(node,"FunctionTypeAnnotation")}return param}flowParseIntersectionType(){const node=this.startNode();this.eat(45);const type=this.flowParseAnonFunctionWithoutParens();for(node.types=[type];this.eat(45);)node.types.push(this.flowParseAnonFunctionWithoutParens());return 1===node.types.length?type:this.finishNode(node,"IntersectionTypeAnnotation")}flowParseUnionType(){const node=this.startNode();this.eat(43);const type=this.flowParseIntersectionType();for(node.types=[type];this.eat(43);)node.types.push(this.flowParseIntersectionType());return 1===node.types.length?type:this.finishNode(node,"UnionTypeAnnotation")}flowParseType(){const oldInType=this.state.inType;this.state.inType=true;const type=this.flowParseUnionType();return this.state.inType=oldInType,type}flowParseTypeOrImplicitInstantiation(){if(132===this.state.type&&"_"===this.state.value){const startLoc=this.state.startLoc,node=this.parseIdentifier();return this.flowParseGenericType(startLoc,node)}return this.flowParseType()}flowParseTypeAnnotation(){const node=this.startNode();return node.typeAnnotation=this.flowParseTypeInitialiser(),this.finishNode(node,"TypeAnnotation")}flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride){const ident=allowPrimitiveOverride?this.parseIdentifier():this.flowParseRestrictedIdentifier();return this.match(14)&&(ident.typeAnnotation=this.flowParseTypeAnnotation(),this.resetEndLocation(ident)),ident}typeCastToParameter(node){return node.expression.typeAnnotation=node.typeAnnotation,this.resetEndLocation(node.expression,node.typeAnnotation.loc.end),node.expression}flowParseVariance(){let variance=null;return this.match(53)?(variance=this.startNode(),"+"===this.state.value?variance.kind="plus":variance.kind="minus",this.next(),this.finishNode(variance,"Variance")):variance}parseFunctionBody(node,allowExpressionBody,isMethod=false){allowExpressionBody?this.forwardNoArrowParamsConversionAt(node,(()=>super.parseFunctionBody(node,true,isMethod))):super.parseFunctionBody(node,false,isMethod);}parseFunctionBodyAndFinish(node,type,isMethod=false){if(this.match(14)){const typeNode=this.startNode();[typeNode.typeAnnotation,node.predicate]=this.flowParseTypeAndPredicateInitialiser(),node.returnType=typeNode.typeAnnotation?this.finishNode(typeNode,"TypeAnnotation"):null;}return super.parseFunctionBodyAndFinish(node,type,isMethod)}parseStatementLike(flags){if(this.state.strict&&this.isContextual(129)){if(tokenIsKeywordOrIdentifier(this.lookahead().type)){const node=this.startNode();return this.next(),this.flowParseInterface(node)}}else if(this.isContextual(126)){const node=this.startNode();return this.next(),this.flowParseEnumDeclaration(node)}const stmt=super.parseStatementLike(flags);return void 0!==this.flowPragma||this.isValidDirective(stmt)||(this.flowPragma=null),stmt}parseExpressionStatement(node,expr,decorators){if("Identifier"===expr.type)if("declare"===expr.name){if(this.match(80)||tokenIsIdentifier(this.state.type)||this.match(68)||this.match(74)||this.match(82))return this.flowParseDeclare(node)}else if(tokenIsIdentifier(this.state.type)){if("interface"===expr.name)return this.flowParseInterface(node);if("type"===expr.name)return this.flowParseTypeAlias(node);if("opaque"===expr.name)return this.flowParseOpaqueType(node,false)}return super.parseExpressionStatement(node,expr,decorators)}shouldParseExportDeclaration(){const{type}=this.state;return 126===type||tokenIsFlowInterfaceOrTypeOrOpaque(type)?!this.state.containsEsc:super.shouldParseExportDeclaration()}isExportDefaultSpecifier(){const{type}=this.state;return 126===type||tokenIsFlowInterfaceOrTypeOrOpaque(type)?this.state.containsEsc:super.isExportDefaultSpecifier()}parseExportDefaultExpression(){if(this.isContextual(126)){const node=this.startNode();return this.next(),this.flowParseEnumDeclaration(node)}return super.parseExportDefaultExpression()}parseConditional(expr,startLoc,refExpressionErrors){if(!this.match(17))return expr;if(this.state.maybeInArrowParameters){const nextCh=this.lookaheadCharCode();if(44===nextCh||61===nextCh||58===nextCh||41===nextCh)return this.setOptionalParametersError(refExpressionErrors),expr}this.expect(17);const state=this.state.clone(),originalNoArrowAt=this.state.noArrowAt,node=this.startNodeAt(startLoc);let{consequent,failed}=this.tryParseConditionalConsequent(),[valid,invalid]=this.getArrowLikeExpressions(consequent);if(failed||invalid.length>0){const noArrowAt=[...originalNoArrowAt];if(invalid.length>0){this.state=state,this.state.noArrowAt=noArrowAt;for(let i=0;i<invalid.length;i++)noArrowAt.push(invalid[i].start);(({consequent,failed}=this.tryParseConditionalConsequent())),[valid,invalid]=this.getArrowLikeExpressions(consequent);}failed&&valid.length>1&&this.raise(FlowErrors.AmbiguousConditionalArrow,state.startLoc),failed&&1===valid.length&&(this.state=state,noArrowAt.push(valid[0].start),this.state.noArrowAt=noArrowAt,({consequent,failed}=this.tryParseConditionalConsequent()));}return this.getArrowLikeExpressions(consequent,true),this.state.noArrowAt=originalNoArrowAt,this.expect(14),node.test=expr,node.consequent=consequent,node.alternate=this.forwardNoArrowParamsConversionAt(node,(()=>this.parseMaybeAssign(void 0,void 0))),this.finishNode(node,"ConditionalExpression")}tryParseConditionalConsequent(){this.state.noArrowParamsConversionAt.push(this.state.start);const consequent=this.parseMaybeAssignAllowIn(),failed=!this.match(14);return this.state.noArrowParamsConversionAt.pop(),{consequent,failed}}getArrowLikeExpressions(node,disallowInvalid){const stack=[node],arrows=[];for(;0!==stack.length;){const node=stack.pop();"ArrowFunctionExpression"===node.type&&"BlockStatement"!==node.body.type?(node.typeParameters||!node.returnType?this.finishArrowValidation(node):arrows.push(node),stack.push(node.body)):"ConditionalExpression"===node.type&&(stack.push(node.consequent),stack.push(node.alternate));}return disallowInvalid?(arrows.forEach((node=>this.finishArrowValidation(node))),[arrows,[]]):function(list,test){const list1=[],list2=[];for(let i=0;i<list.length;i++)(test(list[i],i,list)?list1:list2).push(list[i]);return [list1,list2]}(arrows,(node=>node.params.every((param=>this.isAssignable(param,true)))))}finishArrowValidation(node){var _node$extra;this.toAssignableList(node.params,null==(_node$extra=node.extra)?void 0:_node$extra.trailingCommaLoc,false),this.scope.enter(6),super.checkParams(node,false,true),this.scope.exit();}forwardNoArrowParamsConversionAt(node,parse){let result;return this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start))?(this.state.noArrowParamsConversionAt.push(this.state.start),result=parse(),this.state.noArrowParamsConversionAt.pop()):result=parse(),result}parseParenItem(node,startLoc){const newNode=super.parseParenItem(node,startLoc);if(this.eat(17)&&(newNode.optional=true,this.resetEndLocation(node)),this.match(14)){const typeCastNode=this.startNodeAt(startLoc);return typeCastNode.expression=newNode,typeCastNode.typeAnnotation=this.flowParseTypeAnnotation(),this.finishNode(typeCastNode,"TypeCastExpression")}return newNode}assertModuleNodeAllowed(node){"ImportDeclaration"===node.type&&("type"===node.importKind||"typeof"===node.importKind)||"ExportNamedDeclaration"===node.type&&"type"===node.exportKind||"ExportAllDeclaration"===node.type&&"type"===node.exportKind||super.assertModuleNodeAllowed(node);}parseExportDeclaration(node){if(this.isContextual(130)){node.exportKind="type";const declarationNode=this.startNode();return this.next(),this.match(5)?(node.specifiers=this.parseExportSpecifiers(true),super.parseExportFrom(node),null):this.flowParseTypeAlias(declarationNode)}if(this.isContextual(131)){node.exportKind="type";const declarationNode=this.startNode();return this.next(),this.flowParseOpaqueType(declarationNode,false)}if(this.isContextual(129)){node.exportKind="type";const declarationNode=this.startNode();return this.next(),this.flowParseInterface(declarationNode)}if(this.isContextual(126)){node.exportKind="value";const declarationNode=this.startNode();return this.next(),this.flowParseEnumDeclaration(declarationNode)}return super.parseExportDeclaration(node)}eatExportStar(node){return !!super.eatExportStar(node)||!(!this.isContextual(130)||55!==this.lookahead().type)&&(node.exportKind="type",this.next(),this.next(),true)}maybeParseExportNamespaceSpecifier(node){const{startLoc}=this.state,hasNamespace=super.maybeParseExportNamespaceSpecifier(node);return hasNamespace&&"type"===node.exportKind&&this.unexpected(startLoc),hasNamespace}parseClassId(node,isStatement,optionalId){super.parseClassId(node,isStatement,optionalId),this.match(47)&&(node.typeParameters=this.flowParseTypeParameterDeclaration());}parseClassMember(classBody,member,state){const{startLoc}=this.state;if(this.isContextual(125)){if(super.parseClassMemberFromModifier(classBody,member))return;member.declare=true;}super.parseClassMember(classBody,member,state),member.declare&&("ClassProperty"!==member.type&&"ClassPrivateProperty"!==member.type&&"PropertyDefinition"!==member.type?this.raise(FlowErrors.DeclareClassElement,startLoc):member.value&&this.raise(FlowErrors.DeclareClassFieldInitializer,member.value));}isIterator(word){return "iterator"===word||"asyncIterator"===word}readIterator(){const word=super.readWord1(),fullWord="@@"+word;this.isIterator(word)&&this.state.inType||this.raise(Errors.InvalidIdentifier,this.state.curPosition(),{identifierName:fullWord}),this.finishToken(132,fullWord);}getTokenFromCode(code){const next=this.input.charCodeAt(this.state.pos+1);123===code&&124===next?this.finishOp(6,2):!this.state.inType||62!==code&&60!==code?this.state.inType&&63===code?46===next?this.finishOp(18,2):this.finishOp(17,1):!function(current,next,next2){return 64===current&&64===next&&isIdentifierStart(next2)}(code,next,this.input.charCodeAt(this.state.pos+2))?super.getTokenFromCode(code):(this.state.pos+=2,this.readIterator()):this.finishOp(62===code?48:47,1);}isAssignable(node,isBinding){return "TypeCastExpression"===node.type?this.isAssignable(node.expression,isBinding):super.isAssignable(node,isBinding)}toAssignable(node,isLHS=false){isLHS||"AssignmentExpression"!==node.type||"TypeCastExpression"!==node.left.type||(node.left=this.typeCastToParameter(node.left)),super.toAssignable(node,isLHS);}toAssignableList(exprList,trailingCommaLoc,isLHS){for(let i=0;i<exprList.length;i++){const expr=exprList[i];"TypeCastExpression"===(null==expr?void 0:expr.type)&&(exprList[i]=this.typeCastToParameter(expr));}super.toAssignableList(exprList,trailingCommaLoc,isLHS);}toReferencedList(exprList,isParenthesizedExpr){for(let i=0;i<exprList.length;i++){var _expr$extra;const expr=exprList[i];!expr||"TypeCastExpression"!==expr.type||null!=(_expr$extra=expr.extra)&&_expr$extra.parenthesized||!(exprList.length>1)&&isParenthesizedExpr||this.raise(FlowErrors.TypeCastInPattern,expr.typeAnnotation);}return exprList}parseArrayLike(close,canBePattern,isTuple,refExpressionErrors){const node=super.parseArrayLike(close,canBePattern,isTuple,refExpressionErrors);return canBePattern&&!this.state.maybeInArrowParameters&&this.toReferencedList(node.elements),node}isValidLVal(type,isParenthesized,binding){return "TypeCastExpression"===type||super.isValidLVal(type,isParenthesized,binding)}parseClassProperty(node){return this.match(14)&&(node.typeAnnotation=this.flowParseTypeAnnotation()),super.parseClassProperty(node)}parseClassPrivateProperty(node){return this.match(14)&&(node.typeAnnotation=this.flowParseTypeAnnotation()),super.parseClassPrivateProperty(node)}isClassMethod(){return this.match(47)||super.isClassMethod()}isClassProperty(){return this.match(14)||super.isClassProperty()}isNonstaticConstructor(method){return !this.match(14)&&super.isNonstaticConstructor(method)}pushClassMethod(classBody,method,isGenerator,isAsync,isConstructor,allowsDirectSuper){if(method.variance&&this.unexpected(method.variance.loc.start),delete method.variance,this.match(47)&&(method.typeParameters=this.flowParseTypeParameterDeclaration()),super.pushClassMethod(classBody,method,isGenerator,isAsync,isConstructor,allowsDirectSuper),method.params&&isConstructor){const params=method.params;params.length>0&&this.isThisParam(params[0])&&this.raise(FlowErrors.ThisParamBannedInConstructor,method);}else if("MethodDefinition"===method.type&&isConstructor&&method.value.params){const params=method.value.params;params.length>0&&this.isThisParam(params[0])&&this.raise(FlowErrors.ThisParamBannedInConstructor,method);}}pushClassPrivateMethod(classBody,method,isGenerator,isAsync){method.variance&&this.unexpected(method.variance.loc.start),delete method.variance,this.match(47)&&(method.typeParameters=this.flowParseTypeParameterDeclaration()),super.pushClassPrivateMethod(classBody,method,isGenerator,isAsync);}parseClassSuper(node){if(super.parseClassSuper(node),node.superClass&&this.match(47)&&(node.superTypeParameters=this.flowParseTypeParameterInstantiation()),this.isContextual(113)){this.next();const implemented=node.implements=[];do{const node=this.startNode();node.id=this.flowParseRestrictedIdentifier(true),this.match(47)?node.typeParameters=this.flowParseTypeParameterInstantiation():node.typeParameters=null,implemented.push(this.finishNode(node,"ClassImplements"));}while(this.eat(12))}}checkGetterSetterParams(method){super.checkGetterSetterParams(method);const params=this.getObjectOrClassMethodParams(method);if(params.length>0){const param=params[0];this.isThisParam(param)&&"get"===method.kind?this.raise(FlowErrors.GetterMayNotHaveThisParam,param):this.isThisParam(param)&&this.raise(FlowErrors.SetterMayNotHaveThisParam,param);}}parsePropertyNamePrefixOperator(node){node.variance=this.flowParseVariance();}parseObjPropValue(prop,startLoc,isGenerator,isAsync,isPattern,isAccessor,refExpressionErrors){let typeParameters;prop.variance&&this.unexpected(prop.variance.loc.start),delete prop.variance,this.match(47)&&!isAccessor&&(typeParameters=this.flowParseTypeParameterDeclaration(),this.match(10)||this.unexpected());const result=super.parseObjPropValue(prop,startLoc,isGenerator,isAsync,isPattern,isAccessor,refExpressionErrors);return typeParameters&&((result.value||result).typeParameters=typeParameters),result}parseFunctionParamType(param){return this.eat(17)&&("Identifier"!==param.type&&this.raise(FlowErrors.PatternIsOptional,param),this.isThisParam(param)&&this.raise(FlowErrors.ThisParamMayNotBeOptional,param),param.optional=true),this.match(14)?param.typeAnnotation=this.flowParseTypeAnnotation():this.isThisParam(param)&&this.raise(FlowErrors.ThisParamAnnotationRequired,param),this.match(29)&&this.isThisParam(param)&&this.raise(FlowErrors.ThisParamNoDefault,param),this.resetEndLocation(param),param}parseMaybeDefault(startLoc,left){const node=super.parseMaybeDefault(startLoc,left);return "AssignmentPattern"===node.type&&node.typeAnnotation&&node.right.start<node.typeAnnotation.start&&this.raise(FlowErrors.TypeBeforeInitializer,node.typeAnnotation),node}checkImportReflection(node){super.checkImportReflection(node),node.module&&"value"!==node.importKind&&this.raise(FlowErrors.ImportReflectionHasImportType,node.specifiers[0].loc.start);}parseImportSpecifierLocal(node,specifier,type){specifier.local=hasTypeImportKind(node)?this.flowParseRestrictedIdentifier(true,true):this.parseIdentifier(),node.specifiers.push(this.finishImportSpecifier(specifier,type));}isPotentialImportPhase(isExport){if(super.isPotentialImportPhase(isExport))return  true;if(this.isContextual(130)){if(!isExport)return  true;const ch=this.lookaheadCharCode();return 123===ch||42===ch}return !isExport&&this.isContextual(87)}applyImportPhase(node,isExport,phase,loc){if(super.applyImportPhase(node,isExport,phase,loc),isExport){if(!phase&&this.match(65))return;node.exportKind="type"===phase?phase:"value";}else "type"===phase&&this.match(55)&&this.unexpected(),node.importKind="type"===phase||"typeof"===phase?phase:"value";}parseImportSpecifier(specifier,importedIsString,isInTypeOnlyImport,isMaybeTypeOnly,bindingType){const firstIdent=specifier.imported;let specifierTypeKind=null;"Identifier"===firstIdent.type&&("type"===firstIdent.name?specifierTypeKind="type":"typeof"===firstIdent.name&&(specifierTypeKind="typeof"));let isBinding=false;if(this.isContextual(93)&&!this.isLookaheadContextual("as")){const as_ident=this.parseIdentifier(true);null===specifierTypeKind||tokenIsKeywordOrIdentifier(this.state.type)?(specifier.imported=firstIdent,specifier.importKind=null,specifier.local=this.parseIdentifier()):(specifier.imported=as_ident,specifier.importKind=specifierTypeKind,specifier.local=cloneIdentifier(as_ident));}else {if(null!==specifierTypeKind&&tokenIsKeywordOrIdentifier(this.state.type))specifier.imported=this.parseIdentifier(true),specifier.importKind=specifierTypeKind;else {if(importedIsString)throw this.raise(Errors.ImportBindingIsString,specifier,{importName:firstIdent.value});specifier.imported=firstIdent,specifier.importKind=null;}this.eatContextual(93)?specifier.local=this.parseIdentifier():(isBinding=true,specifier.local=cloneIdentifier(specifier.imported));}const specifierIsTypeImport=hasTypeImportKind(specifier);return isInTypeOnlyImport&&specifierIsTypeImport&&this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport,specifier),(isInTypeOnlyImport||specifierIsTypeImport)&&this.checkReservedType(specifier.local.name,specifier.local.loc.start,true),!isBinding||isInTypeOnlyImport||specifierIsTypeImport||this.checkReservedWord(specifier.local.name,specifier.loc.start,true,true),this.finishImportSpecifier(specifier,"ImportSpecifier")}parseBindingAtom(){return 78===this.state.type?this.parseIdentifier(true):super.parseBindingAtom()}parseFunctionParams(node,isConstructor){const kind=node.kind;"get"!==kind&&"set"!==kind&&this.match(47)&&(node.typeParameters=this.flowParseTypeParameterDeclaration()),super.parseFunctionParams(node,isConstructor);}parseVarId(decl,kind){super.parseVarId(decl,kind),this.match(14)&&(decl.id.typeAnnotation=this.flowParseTypeAnnotation(),this.resetEndLocation(decl.id));}parseAsyncArrowFromCallExpression(node,call){if(this.match(14)){const oldNoAnonFunctionType=this.state.noAnonFunctionType;this.state.noAnonFunctionType=true,node.returnType=this.flowParseTypeAnnotation(),this.state.noAnonFunctionType=oldNoAnonFunctionType;}return super.parseAsyncArrowFromCallExpression(node,call)}shouldParseAsyncArrow(){return this.match(14)||super.shouldParseAsyncArrow()}parseMaybeAssign(refExpressionErrors,afterLeftParse){var _jsx;let jsx,state=null;if(this.hasPlugin("jsx")&&(this.match(143)||this.match(47))){if(state=this.state.clone(),jsx=this.tryParse((()=>super.parseMaybeAssign(refExpressionErrors,afterLeftParse)),state),!jsx.error)return jsx.node;const{context}=this.state,currentContext=context[context.length-1];currentContext!==types.j_oTag&&currentContext!==types.j_expr||context.pop();}if(null!=(_jsx=jsx)&&_jsx.error||this.match(47)){var _jsx2,_jsx3;let typeParameters;state=state||this.state.clone();const arrow=this.tryParse((abort=>{var _arrowExpression$extr;typeParameters=this.flowParseTypeParameterDeclaration();const arrowExpression=this.forwardNoArrowParamsConversionAt(typeParameters,(()=>{const result=super.parseMaybeAssign(refExpressionErrors,afterLeftParse);return this.resetStartLocationFromNode(result,typeParameters),result}));null!=(_arrowExpression$extr=arrowExpression.extra)&&_arrowExpression$extr.parenthesized&&abort();const expr=this.maybeUnwrapTypeCastExpression(arrowExpression);return "ArrowFunctionExpression"!==expr.type&&abort(),expr.typeParameters=typeParameters,this.resetStartLocationFromNode(expr,typeParameters),arrowExpression}),state);let arrowExpression=null;if(arrow.node&&"ArrowFunctionExpression"===this.maybeUnwrapTypeCastExpression(arrow.node).type){if(!arrow.error&&!arrow.aborted)return arrow.node.async&&this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction,typeParameters),arrow.node;arrowExpression=arrow.node;}if(null!=(_jsx2=jsx)&&_jsx2.node)return this.state=jsx.failState,jsx.node;if(arrowExpression)return this.state=arrow.failState,arrowExpression;if(null!=(_jsx3=jsx)&&_jsx3.thrown)throw jsx.error;if(arrow.thrown)throw arrow.error;throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter,typeParameters)}return super.parseMaybeAssign(refExpressionErrors,afterLeftParse)}parseArrow(node){if(this.match(14)){const result=this.tryParse((()=>{const oldNoAnonFunctionType=this.state.noAnonFunctionType;this.state.noAnonFunctionType=true;const typeNode=this.startNode();return [typeNode.typeAnnotation,node.predicate]=this.flowParseTypeAndPredicateInitialiser(),this.state.noAnonFunctionType=oldNoAnonFunctionType,this.canInsertSemicolon()&&this.unexpected(),this.match(19)||this.unexpected(),typeNode}));if(result.thrown)return null;result.error&&(this.state=result.failState),node.returnType=result.node.typeAnnotation?this.finishNode(result.node,"TypeAnnotation"):null;}return super.parseArrow(node)}shouldParseArrow(params){return this.match(14)||super.shouldParseArrow(params)}setArrowFunctionParameters(node,params){this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start))?node.params=params:super.setArrowFunctionParameters(node,params);}checkParams(node,allowDuplicates,isArrowFunction,strictModeChanged=true){if(!isArrowFunction||!this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start))){for(let i=0;i<node.params.length;i++)this.isThisParam(node.params[i])&&i>0&&this.raise(FlowErrors.ThisParamMustBeFirst,node.params[i]);super.checkParams(node,allowDuplicates,isArrowFunction,strictModeChanged);}}parseParenAndDistinguishExpression(canBeArrow){return super.parseParenAndDistinguishExpression(canBeArrow&&!this.state.noArrowAt.includes(this.sourceToOffsetPos(this.state.start)))}parseSubscripts(base,startLoc,noCalls){if("Identifier"===base.type&&"async"===base.name&&this.state.noArrowAt.includes(startLoc.index)){this.next();const node=this.startNodeAt(startLoc);node.callee=base,node.arguments=super.parseCallExpressionArguments(11),base=this.finishNode(node,"CallExpression");}else if("Identifier"===base.type&&"async"===base.name&&this.match(47)){const state=this.state.clone(),arrow=this.tryParse((abort=>this.parseAsyncArrowWithTypeParameters(startLoc)||abort()),state);if(!arrow.error&&!arrow.aborted)return arrow.node;const result=this.tryParse((()=>super.parseSubscripts(base,startLoc,noCalls)),state);if(result.node&&!result.error)return result.node;if(arrow.node)return this.state=arrow.failState,arrow.node;if(result.node)return this.state=result.failState,result.node;throw arrow.error||result.error}return super.parseSubscripts(base,startLoc,noCalls)}parseSubscript(base,startLoc,noCalls,subscriptState){if(this.match(18)&&this.isLookaheadToken_lt()){if(subscriptState.optionalChainMember=true,noCalls)return subscriptState.stop=true,base;this.next();const node=this.startNodeAt(startLoc);return node.callee=base,node.typeArguments=this.flowParseTypeParameterInstantiation(),this.expect(10),node.arguments=this.parseCallExpressionArguments(11),node.optional=true,this.finishCallExpression(node,true)}if(!noCalls&&this.shouldParseTypes()&&this.match(47)){const node=this.startNodeAt(startLoc);node.callee=base;const result=this.tryParse((()=>(node.typeArguments=this.flowParseTypeParameterInstantiationCallOrNew(),this.expect(10),node.arguments=super.parseCallExpressionArguments(11),subscriptState.optionalChainMember&&(node.optional=false),this.finishCallExpression(node,subscriptState.optionalChainMember))));if(result.node)return result.error&&(this.state=result.failState),result.node}return super.parseSubscript(base,startLoc,noCalls,subscriptState)}parseNewCallee(node){super.parseNewCallee(node);let targs=null;this.shouldParseTypes()&&this.match(47)&&(targs=this.tryParse((()=>this.flowParseTypeParameterInstantiationCallOrNew())).node),node.typeArguments=targs;}parseAsyncArrowWithTypeParameters(startLoc){const node=this.startNodeAt(startLoc);if(this.parseFunctionParams(node,false),this.parseArrow(node))return super.parseArrowExpression(node,void 0,true)}readToken_mult_modulo(code){const next=this.input.charCodeAt(this.state.pos+1);if(42===code&&47===next&&this.state.hasFlowComment)return this.state.hasFlowComment=false,this.state.pos+=2,void this.nextToken();super.readToken_mult_modulo(code);}readToken_pipe_amp(code){const next=this.input.charCodeAt(this.state.pos+1);124!==code||125!==next?super.readToken_pipe_amp(code):this.finishOp(9,2);}parseTopLevel(file,program){const fileNode=super.parseTopLevel(file,program);return this.state.hasFlowComment&&this.raise(FlowErrors.UnterminatedFlowComment,this.state.curPosition()),fileNode}skipBlockComment(){if(!this.hasPlugin("flowComments")||!this.skipFlowComment())return super.skipBlockComment(this.state.hasFlowComment?"*-/":"*/");{if(this.state.hasFlowComment)throw this.raise(FlowErrors.NestedFlowComment,this.state.startLoc);this.hasFlowCommentCompletion();const commentSkip=this.skipFlowComment();commentSkip&&(this.state.pos+=commentSkip,this.state.hasFlowComment=true);}}skipFlowComment(){const{pos}=this.state;let shiftToFirstNonWhiteSpace=2;for(;[32,9].includes(this.input.charCodeAt(pos+shiftToFirstNonWhiteSpace));)shiftToFirstNonWhiteSpace++;const ch2=this.input.charCodeAt(shiftToFirstNonWhiteSpace+pos),ch3=this.input.charCodeAt(shiftToFirstNonWhiteSpace+pos+1);return 58===ch2&&58===ch3?shiftToFirstNonWhiteSpace+2:"flow-include"===this.input.slice(shiftToFirstNonWhiteSpace+pos,shiftToFirstNonWhiteSpace+pos+12)?shiftToFirstNonWhiteSpace+12:58===ch2&&58!==ch3&&shiftToFirstNonWhiteSpace}hasFlowCommentCompletion(){if(-1===this.input.indexOf("*/",this.state.pos))throw this.raise(Errors.UnterminatedComment,this.state.curPosition())}flowEnumErrorBooleanMemberNotInitialized(loc,{enumName,memberName}){this.raise(FlowErrors.EnumBooleanMemberNotInitialized,loc,{memberName,enumName});}flowEnumErrorInvalidMemberInitializer(loc,enumContext){return this.raise(enumContext.explicitType?"symbol"===enumContext.explicitType?FlowErrors.EnumInvalidMemberInitializerSymbolType:FlowErrors.EnumInvalidMemberInitializerPrimaryType:FlowErrors.EnumInvalidMemberInitializerUnknownType,loc,enumContext)}flowEnumErrorNumberMemberNotInitialized(loc,details){this.raise(FlowErrors.EnumNumberMemberNotInitialized,loc,details);}flowEnumErrorStringMemberInconsistentlyInitialized(node,details){this.raise(FlowErrors.EnumStringMemberInconsistentlyInitialized,node,details);}flowEnumMemberInit(){const startLoc=this.state.startLoc,endOfInit=()=>this.match(12)||this.match(8);switch(this.state.type){case 135:{const literal=this.parseNumericLiteral(this.state.value);return endOfInit()?{type:"number",loc:literal.loc.start,value:literal}:{type:"invalid",loc:startLoc}}case 134:{const literal=this.parseStringLiteral(this.state.value);return endOfInit()?{type:"string",loc:literal.loc.start,value:literal}:{type:"invalid",loc:startLoc}}case 85:case 86:{const literal=this.parseBooleanLiteral(this.match(85));return endOfInit()?{type:"boolean",loc:literal.loc.start,value:literal}:{type:"invalid",loc:startLoc}}default:return {type:"invalid",loc:startLoc}}}flowEnumMemberRaw(){const loc=this.state.startLoc;return {id:this.parseIdentifier(true),init:this.eat(29)?this.flowEnumMemberInit():{type:"none",loc}}}flowEnumCheckExplicitTypeMismatch(loc,context,expectedType){const{explicitType}=context;null!==explicitType&&explicitType!==expectedType&&this.flowEnumErrorInvalidMemberInitializer(loc,context);}flowEnumMembers({enumName,explicitType}){const seenNames=new Set,members={booleanMembers:[],numberMembers:[],stringMembers:[],defaultedMembers:[]};let hasUnknownMembers=false;for(;!this.match(8);){if(this.eat(21)){hasUnknownMembers=true;break}const memberNode=this.startNode(),{id,init}=this.flowEnumMemberRaw(),memberName=id.name;if(""===memberName)continue;/^[a-z]/.test(memberName)&&this.raise(FlowErrors.EnumInvalidMemberName,id,{memberName,suggestion:memberName[0].toUpperCase()+memberName.slice(1),enumName}),seenNames.has(memberName)&&this.raise(FlowErrors.EnumDuplicateMemberName,id,{memberName,enumName}),seenNames.add(memberName);const context={enumName,explicitType,memberName};switch(memberNode.id=id,init.type){case "boolean":this.flowEnumCheckExplicitTypeMismatch(init.loc,context,"boolean"),memberNode.init=init.value,members.booleanMembers.push(this.finishNode(memberNode,"EnumBooleanMember"));break;case "number":this.flowEnumCheckExplicitTypeMismatch(init.loc,context,"number"),memberNode.init=init.value,members.numberMembers.push(this.finishNode(memberNode,"EnumNumberMember"));break;case "string":this.flowEnumCheckExplicitTypeMismatch(init.loc,context,"string"),memberNode.init=init.value,members.stringMembers.push(this.finishNode(memberNode,"EnumStringMember"));break;case "invalid":throw this.flowEnumErrorInvalidMemberInitializer(init.loc,context);case "none":switch(explicitType){case "boolean":this.flowEnumErrorBooleanMemberNotInitialized(init.loc,context);break;case "number":this.flowEnumErrorNumberMemberNotInitialized(init.loc,context);break;default:members.defaultedMembers.push(this.finishNode(memberNode,"EnumDefaultedMember"));}}this.match(8)||this.expect(12);}return {members,hasUnknownMembers}}flowEnumStringMembers(initializedMembers,defaultedMembers,{enumName}){if(0===initializedMembers.length)return defaultedMembers;if(0===defaultedMembers.length)return initializedMembers;if(defaultedMembers.length>initializedMembers.length){for(const member of initializedMembers)this.flowEnumErrorStringMemberInconsistentlyInitialized(member,{enumName});return defaultedMembers}for(const member of defaultedMembers)this.flowEnumErrorStringMemberInconsistentlyInitialized(member,{enumName});return initializedMembers}flowEnumParseExplicitType({enumName}){if(!this.eatContextual(102))return null;if(!tokenIsIdentifier(this.state.type))throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied,this.state.startLoc,{enumName});const{value}=this.state;return this.next(),"boolean"!==value&&"number"!==value&&"string"!==value&&"symbol"!==value&&this.raise(FlowErrors.EnumInvalidExplicitType,this.state.startLoc,{enumName,invalidEnumType:value}),value}flowEnumBody(node,id){const enumName=id.name,nameLoc=id.loc.start,explicitType=this.flowEnumParseExplicitType({enumName});this.expect(5);const{members,hasUnknownMembers}=this.flowEnumMembers({enumName,explicitType});switch(node.hasUnknownMembers=hasUnknownMembers,explicitType){case "boolean":return node.explicitType=true,node.members=members.booleanMembers,this.expect(8),this.finishNode(node,"EnumBooleanBody");case "number":return node.explicitType=true,node.members=members.numberMembers,this.expect(8),this.finishNode(node,"EnumNumberBody");case "string":return node.explicitType=true,node.members=this.flowEnumStringMembers(members.stringMembers,members.defaultedMembers,{enumName}),this.expect(8),this.finishNode(node,"EnumStringBody");case "symbol":return node.members=members.defaultedMembers,this.expect(8),this.finishNode(node,"EnumSymbolBody");default:{const empty=()=>(node.members=[],this.expect(8),this.finishNode(node,"EnumStringBody"));node.explicitType=false;const boolsLen=members.booleanMembers.length,numsLen=members.numberMembers.length,strsLen=members.stringMembers.length,defaultedLen=members.defaultedMembers.length;if(boolsLen||numsLen||strsLen||defaultedLen){if(boolsLen||numsLen){if(!numsLen&&!strsLen&&boolsLen>=defaultedLen){for(const member of members.defaultedMembers)this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start,{enumName,memberName:member.id.name});return node.members=members.booleanMembers,this.expect(8),this.finishNode(node,"EnumBooleanBody")}if(!boolsLen&&!strsLen&&numsLen>=defaultedLen){for(const member of members.defaultedMembers)this.flowEnumErrorNumberMemberNotInitialized(member.loc.start,{enumName,memberName:member.id.name});return node.members=members.numberMembers,this.expect(8),this.finishNode(node,"EnumNumberBody")}return this.raise(FlowErrors.EnumInconsistentMemberValues,nameLoc,{enumName}),empty()}return node.members=this.flowEnumStringMembers(members.stringMembers,members.defaultedMembers,{enumName}),this.expect(8),this.finishNode(node,"EnumStringBody")}return empty()}}}flowParseEnumDeclaration(node){const id=this.parseIdentifier();return node.id=id,node.body=this.flowEnumBody(this.startNode(),id),this.finishNode(node,"EnumDeclaration")}isLookaheadToken_lt(){const next=this.nextTokenStart();if(60===this.input.charCodeAt(next)){const afterNext=this.input.charCodeAt(next+1);return 60!==afterNext&&61!==afterNext}return  false}maybeUnwrapTypeCastExpression(node){return "TypeCastExpression"===node.type?node.expression:node}},typescript:superClass=>class extends superClass{constructor(...args){super(...args),this.tsParseInOutModifiers=this.tsParseModifiers.bind(this,{allowedModifiers:["in","out"],disallowedModifiers:["const","public","private","protected","readonly","declare","abstract","override"],errorTemplate:TSErrors.InvalidModifierOnTypeParameter}),this.tsParseConstModifier=this.tsParseModifiers.bind(this,{allowedModifiers:["const"],disallowedModifiers:["in","out"],errorTemplate:TSErrors.InvalidModifierOnTypeParameterPositions}),this.tsParseInOutConstModifiers=this.tsParseModifiers.bind(this,{allowedModifiers:["in","out","const"],disallowedModifiers:["public","private","protected","readonly","declare","abstract","override"],errorTemplate:TSErrors.InvalidModifierOnTypeParameter});}getScopeHandler(){return TypeScriptScopeHandler}tsIsIdentifier(){return tokenIsIdentifier(this.state.type)}tsTokenCanFollowModifier(){return this.match(0)||this.match(5)||this.match(55)||this.match(21)||this.match(139)||this.isLiteralPropertyName()}tsNextTokenOnSameLineAndCanFollowModifier(){return this.next(),!this.hasPrecedingLineBreak()&&this.tsTokenCanFollowModifier()}tsNextTokenCanFollowModifier(){return this.match(106)?(this.next(),this.tsTokenCanFollowModifier()):this.tsNextTokenOnSameLineAndCanFollowModifier()}tsParseModifier(allowedModifiers,stopOnStartOfClassStaticBlock){if(!tokenIsIdentifier(this.state.type)&&58!==this.state.type&&75!==this.state.type)return;const modifier=this.state.value;if(allowedModifiers.includes(modifier)){if(stopOnStartOfClassStaticBlock&&this.tsIsStartOfStaticBlocks())return;if(this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))return modifier}}tsParseModifiers({allowedModifiers,disallowedModifiers,stopOnStartOfClassStaticBlock,errorTemplate=TSErrors.InvalidModifierOnTypeMember},modified){const enforceOrder=(loc,modifier,before,after)=>{modifier===before&&modified[after]&&this.raise(TSErrors.InvalidModifiersOrder,loc,{orderedModifiers:[before,after]});},incompatible=(loc,modifier,mod1,mod2)=>{(modified[mod1]&&modifier===mod2||modified[mod2]&&modifier===mod1)&&this.raise(TSErrors.IncompatibleModifiers,loc,{modifiers:[mod1,mod2]});};for(;;){const{startLoc}=this.state,modifier=this.tsParseModifier(allowedModifiers.concat(null!=disallowedModifiers?disallowedModifiers:[]),stopOnStartOfClassStaticBlock);if(!modifier)break;tsIsAccessModifier(modifier)?modified.accessibility?this.raise(TSErrors.DuplicateAccessibilityModifier,startLoc,{modifier}):(enforceOrder(startLoc,modifier,modifier,"override"),enforceOrder(startLoc,modifier,modifier,"static"),enforceOrder(startLoc,modifier,modifier,"readonly"),modified.accessibility=modifier):tsIsVarianceAnnotations(modifier)?(modified[modifier]&&this.raise(TSErrors.DuplicateModifier,startLoc,{modifier}),modified[modifier]=true,enforceOrder(startLoc,modifier,"in","out")):(hasOwnProperty.call(modified,modifier)?this.raise(TSErrors.DuplicateModifier,startLoc,{modifier}):(enforceOrder(startLoc,modifier,"static","readonly"),enforceOrder(startLoc,modifier,"static","override"),enforceOrder(startLoc,modifier,"override","readonly"),enforceOrder(startLoc,modifier,"abstract","override"),incompatible(startLoc,modifier,"declare","override"),incompatible(startLoc,modifier,"static","abstract")),modified[modifier]=true),null!=disallowedModifiers&&disallowedModifiers.includes(modifier)&&this.raise(errorTemplate,startLoc,{modifier});}}tsIsListTerminator(kind){switch(kind){case "EnumMembers":case "TypeMembers":return this.match(8);case "HeritageClauseElement":return this.match(5);case "TupleElementTypes":return this.match(3);case "TypeParametersOrArguments":return this.match(48)}}tsParseList(kind,parseElement){const result=[];for(;!this.tsIsListTerminator(kind);)result.push(parseElement());return result}tsParseDelimitedList(kind,parseElement,refTrailingCommaPos){return function(x){if(null==x)throw new Error(`Unexpected ${x} value.`);return x}(this.tsParseDelimitedListWorker(kind,parseElement,true,refTrailingCommaPos))}tsParseDelimitedListWorker(kind,parseElement,expectSuccess,refTrailingCommaPos){const result=[];let trailingCommaPos=-1;for(;!this.tsIsListTerminator(kind);){trailingCommaPos=-1;const element=parseElement();if(null==element)return;if(result.push(element),!this.eat(12)){if(this.tsIsListTerminator(kind))break;return void(expectSuccess&&this.expect(12))}trailingCommaPos=this.state.lastTokStartLoc.index;}return refTrailingCommaPos&&(refTrailingCommaPos.value=trailingCommaPos),result}tsParseBracketedList(kind,parseElement,bracket,skipFirstToken,refTrailingCommaPos){skipFirstToken||(bracket?this.expect(0):this.expect(47));const result=this.tsParseDelimitedList(kind,parseElement,refTrailingCommaPos);return bracket?this.expect(3):this.expect(48),result}tsParseImportType(){const node=this.startNode();return this.expect(83),this.expect(10),this.match(134)||this.raise(TSErrors.UnsupportedImportTypeArgument,this.state.startLoc),node.argument=super.parseExprAtom(),this.eat(12)&&!this.match(11)?(node.options=super.parseMaybeAssignAllowIn(),this.eat(12)):node.options=null,this.expect(11),this.eat(16)&&(node.qualifier=this.tsParseEntityName()),this.match(47)&&(node.typeParameters=this.tsParseTypeArguments()),this.finishNode(node,"TSImportType")}tsParseEntityName(allowReservedWords=true){let entity=this.parseIdentifier(allowReservedWords);for(;this.eat(16);){const node=this.startNodeAtNode(entity);node.left=entity,node.right=this.parseIdentifier(allowReservedWords),entity=this.finishNode(node,"TSQualifiedName");}return entity}tsParseTypeReference(){const node=this.startNode();return node.typeName=this.tsParseEntityName(),!this.hasPrecedingLineBreak()&&this.match(47)&&(node.typeParameters=this.tsParseTypeArguments()),this.finishNode(node,"TSTypeReference")}tsParseThisTypePredicate(lhs){this.next();const node=this.startNodeAtNode(lhs);return node.parameterName=lhs,node.typeAnnotation=this.tsParseTypeAnnotation(false),node.asserts=false,this.finishNode(node,"TSTypePredicate")}tsParseThisTypeNode(){const node=this.startNode();return this.next(),this.finishNode(node,"TSThisType")}tsParseTypeQuery(){const node=this.startNode();return this.expect(87),this.match(83)?node.exprName=this.tsParseImportType():node.exprName=this.tsParseEntityName(),!this.hasPrecedingLineBreak()&&this.match(47)&&(node.typeParameters=this.tsParseTypeArguments()),this.finishNode(node,"TSTypeQuery")}tsParseTypeParameter(parseModifiers){const node=this.startNode();return parseModifiers(node),node.name=this.tsParseTypeParameterName(),node.constraint=this.tsEatThenParseType(81),node.default=this.tsEatThenParseType(29),this.finishNode(node,"TSTypeParameter")}tsTryParseTypeParameters(parseModifiers){if(this.match(47))return this.tsParseTypeParameters(parseModifiers)}tsParseTypeParameters(parseModifiers){const node=this.startNode();this.match(47)||this.match(143)?this.next():this.unexpected();const refTrailingCommaPos={value:-1};return node.params=this.tsParseBracketedList("TypeParametersOrArguments",this.tsParseTypeParameter.bind(this,parseModifiers),false,true,refTrailingCommaPos),0===node.params.length&&this.raise(TSErrors.EmptyTypeParameters,node),-1!==refTrailingCommaPos.value&&this.addExtra(node,"trailingComma",refTrailingCommaPos.value),this.finishNode(node,"TSTypeParameterDeclaration")}tsFillSignature(returnToken,signature){const returnTokenRequired=19===returnToken;signature.typeParameters=this.tsTryParseTypeParameters(this.tsParseConstModifier),this.expect(10),signature.parameters=this.tsParseBindingListForSignature(),(returnTokenRequired||this.match(returnToken))&&(signature.typeAnnotation=this.tsParseTypeOrTypePredicateAnnotation(returnToken));}tsParseBindingListForSignature(){const list=super.parseBindingList(11,41,2);for(const pattern of list){const{type}=pattern;"AssignmentPattern"!==type&&"TSParameterProperty"!==type||this.raise(TSErrors.UnsupportedSignatureParameterKind,pattern,{type});}return list}tsParseTypeMemberSemicolon(){this.eat(12)||this.isLineTerminator()||this.expect(13);}tsParseSignatureMember(kind,node){return this.tsFillSignature(14,node),this.tsParseTypeMemberSemicolon(),this.finishNode(node,kind)}tsIsUnambiguouslyIndexSignature(){return this.next(),!!tokenIsIdentifier(this.state.type)&&(this.next(),this.match(14))}tsTryParseIndexSignature(node){if(!this.match(0)||!this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))return;this.expect(0);const id=this.parseIdentifier();id.typeAnnotation=this.tsParseTypeAnnotation(),this.resetEndLocation(id),this.expect(3),node.parameters=[id];const type=this.tsTryParseTypeAnnotation();return type&&(node.typeAnnotation=type),this.tsParseTypeMemberSemicolon(),this.finishNode(node,"TSIndexSignature")}tsParsePropertyOrMethodSignature(node,readonly){this.eat(17)&&(node.optional=true);const nodeAny=node;if(this.match(10)||this.match(47)){readonly&&this.raise(TSErrors.ReadonlyForMethodSignature,node);const method=nodeAny;method.kind&&this.match(47)&&this.raise(TSErrors.AccessorCannotHaveTypeParameters,this.state.curPosition()),this.tsFillSignature(14,method),this.tsParseTypeMemberSemicolon();const paramsKey="parameters",returnTypeKey="typeAnnotation";if("get"===method.kind)method[paramsKey].length>0&&(this.raise(Errors.BadGetterArity,this.state.curPosition()),this.isThisParam(method[paramsKey][0])&&this.raise(TSErrors.AccessorCannotDeclareThisParameter,this.state.curPosition()));else if("set"===method.kind){if(1!==method[paramsKey].length)this.raise(Errors.BadSetterArity,this.state.curPosition());else {const firstParameter=method[paramsKey][0];this.isThisParam(firstParameter)&&this.raise(TSErrors.AccessorCannotDeclareThisParameter,this.state.curPosition()),"Identifier"===firstParameter.type&&firstParameter.optional&&this.raise(TSErrors.SetAccessorCannotHaveOptionalParameter,this.state.curPosition()),"RestElement"===firstParameter.type&&this.raise(TSErrors.SetAccessorCannotHaveRestParameter,this.state.curPosition());}method[returnTypeKey]&&this.raise(TSErrors.SetAccessorCannotHaveReturnType,method[returnTypeKey]);}else method.kind="method";return this.finishNode(method,"TSMethodSignature")}{const property=nodeAny;readonly&&(property.readonly=true);const type=this.tsTryParseTypeAnnotation();return type&&(property.typeAnnotation=type),this.tsParseTypeMemberSemicolon(),this.finishNode(property,"TSPropertySignature")}}tsParseTypeMember(){const node=this.startNode();if(this.match(10)||this.match(47))return this.tsParseSignatureMember("TSCallSignatureDeclaration",node);if(this.match(77)){const id=this.startNode();return this.next(),this.match(10)||this.match(47)?this.tsParseSignatureMember("TSConstructSignatureDeclaration",node):(node.key=this.createIdentifier(id,"new"),this.tsParsePropertyOrMethodSignature(node,false))}this.tsParseModifiers({allowedModifiers:["readonly"],disallowedModifiers:["declare","abstract","private","protected","public","static","override"]},node);const idx=this.tsTryParseIndexSignature(node);return idx||(super.parsePropertyName(node),node.computed||"Identifier"!==node.key.type||"get"!==node.key.name&&"set"!==node.key.name||!this.tsTokenCanFollowModifier()||(node.kind=node.key.name,super.parsePropertyName(node)),this.tsParsePropertyOrMethodSignature(node,!!node.readonly))}tsParseTypeLiteral(){const node=this.startNode();return node.members=this.tsParseObjectTypeMembers(),this.finishNode(node,"TSTypeLiteral")}tsParseObjectTypeMembers(){this.expect(5);const members=this.tsParseList("TypeMembers",this.tsParseTypeMember.bind(this));return this.expect(8),members}tsIsStartOfMappedType(){return this.next(),this.eat(53)?this.isContextual(122):(this.isContextual(122)&&this.next(),!!this.match(0)&&(this.next(),!!this.tsIsIdentifier()&&(this.next(),this.match(58))))}tsParseMappedType(){const node=this.startNode();this.expect(5),this.match(53)?(node.readonly=this.state.value,this.next(),this.expectContextual(122)):this.eatContextual(122)&&(node.readonly=true),this.expect(0);{const typeParameter=this.startNode();typeParameter.name=this.tsParseTypeParameterName(),typeParameter.constraint=this.tsExpectThenParseType(58),node.typeParameter=this.finishNode(typeParameter,"TSTypeParameter");}return node.nameType=this.eatContextual(93)?this.tsParseType():null,this.expect(3),this.match(53)?(node.optional=this.state.value,this.next(),this.expect(17)):this.eat(17)&&(node.optional=true),node.typeAnnotation=this.tsTryParseType(),this.semicolon(),this.expect(8),this.finishNode(node,"TSMappedType")}tsParseTupleType(){const node=this.startNode();node.elementTypes=this.tsParseBracketedList("TupleElementTypes",this.tsParseTupleElementType.bind(this),true,false);let seenOptionalElement=false;return node.elementTypes.forEach((elementNode=>{const{type}=elementNode;!seenOptionalElement||"TSRestType"===type||"TSOptionalType"===type||"TSNamedTupleMember"===type&&elementNode.optional||this.raise(TSErrors.OptionalTypeBeforeRequired,elementNode),seenOptionalElement||(seenOptionalElement="TSNamedTupleMember"===type&&elementNode.optional||"TSOptionalType"===type);})),this.finishNode(node,"TSTupleType")}tsParseTupleElementType(){const{startLoc}=this.state,rest=this.eat(21);let labeled,label,optional,type;const chAfterWord=tokenIsKeywordOrIdentifier(this.state.type)?this.lookaheadCharCode():null;if(58===chAfterWord)labeled=true,optional=false,label=this.parseIdentifier(true),this.expect(14),type=this.tsParseType();else if(63===chAfterWord){optional=true;const startLoc=this.state.startLoc,wordName=this.state.value,typeOrLabel=this.tsParseNonArrayType();58===this.lookaheadCharCode()?(labeled=true,label=this.createIdentifier(this.startNodeAt(startLoc),wordName),this.expect(17),this.expect(14),type=this.tsParseType()):(labeled=false,type=typeOrLabel,this.expect(17));}else type=this.tsParseType(),optional=this.eat(17),labeled=this.eat(14);if(labeled){let labeledNode;label?(labeledNode=this.startNodeAtNode(label),labeledNode.optional=optional,labeledNode.label=label,labeledNode.elementType=type,this.eat(17)&&(labeledNode.optional=true,this.raise(TSErrors.TupleOptionalAfterType,this.state.lastTokStartLoc))):(labeledNode=this.startNodeAtNode(type),labeledNode.optional=optional,this.raise(TSErrors.InvalidTupleMemberLabel,type),labeledNode.label=type,labeledNode.elementType=this.tsParseType()),type=this.finishNode(labeledNode,"TSNamedTupleMember");}else if(optional){const optionalTypeNode=this.startNodeAtNode(type);optionalTypeNode.typeAnnotation=type,type=this.finishNode(optionalTypeNode,"TSOptionalType");}if(rest){const restNode=this.startNodeAt(startLoc);restNode.typeAnnotation=type,type=this.finishNode(restNode,"TSRestType");}return type}tsParseParenthesizedType(){const node=this.startNode();return this.expect(10),node.typeAnnotation=this.tsParseType(),this.expect(11),this.finishNode(node,"TSParenthesizedType")}tsParseFunctionOrConstructorType(type,abstract){const node=this.startNode();return "TSConstructorType"===type&&(node.abstract=!!abstract,abstract&&this.next(),this.next()),this.tsInAllowConditionalTypesContext((()=>this.tsFillSignature(19,node))),this.finishNode(node,type)}tsParseLiteralTypeNode(){const node=this.startNode();switch(this.state.type){case 135:case 136:case 134:case 85:case 86:node.literal=super.parseExprAtom();break;default:this.unexpected();}return this.finishNode(node,"TSLiteralType")}tsParseTemplateLiteralType(){const node=this.startNode();return node.literal=super.parseTemplate(false),this.finishNode(node,"TSLiteralType")}parseTemplateSubstitution(){return this.state.inType?this.tsParseType():super.parseTemplateSubstitution()}tsParseThisTypeOrThisTypePredicate(){const thisKeyword=this.tsParseThisTypeNode();return this.isContextual(116)&&!this.hasPrecedingLineBreak()?this.tsParseThisTypePredicate(thisKeyword):thisKeyword}tsParseNonArrayType(){switch(this.state.type){case 134:case 135:case 136:case 85:case 86:return this.tsParseLiteralTypeNode();case 53:if("-"===this.state.value){const node=this.startNode(),nextToken=this.lookahead();return 135!==nextToken.type&&136!==nextToken.type&&this.unexpected(),node.literal=this.parseMaybeUnary(),this.finishNode(node,"TSLiteralType")}break;case 78:return this.tsParseThisTypeOrThisTypePredicate();case 87:return this.tsParseTypeQuery();case 83:return this.tsParseImportType();case 5:return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this))?this.tsParseMappedType():this.tsParseTypeLiteral();case 0:return this.tsParseTupleType();case 10:return this.tsParseParenthesizedType();case 25:case 24:return this.tsParseTemplateLiteralType();default:{const{type}=this.state;if(tokenIsIdentifier(type)||88===type||84===type){const nodeType=88===type?"TSVoidKeyword":84===type?"TSNullKeyword":function(value){switch(value){case "any":return "TSAnyKeyword";case "boolean":return "TSBooleanKeyword";case "bigint":return "TSBigIntKeyword";case "never":return "TSNeverKeyword";case "number":return "TSNumberKeyword";case "object":return "TSObjectKeyword";case "string":return "TSStringKeyword";case "symbol":return "TSSymbolKeyword";case "undefined":return "TSUndefinedKeyword";case "unknown":return "TSUnknownKeyword";default:return}}(this.state.value);if(void 0!==nodeType&&46!==this.lookaheadCharCode()){const node=this.startNode();return this.next(),this.finishNode(node,nodeType)}return this.tsParseTypeReference()}}}this.unexpected();}tsParseArrayTypeOrHigher(){let type=this.tsParseNonArrayType();for(;!this.hasPrecedingLineBreak()&&this.eat(0);)if(this.match(3)){const node=this.startNodeAtNode(type);node.elementType=type,this.expect(3),type=this.finishNode(node,"TSArrayType");}else {const node=this.startNodeAtNode(type);node.objectType=type,node.indexType=this.tsParseType(),this.expect(3),type=this.finishNode(node,"TSIndexedAccessType");}return type}tsParseTypeOperator(){const node=this.startNode(),operator=this.state.value;return this.next(),node.operator=operator,node.typeAnnotation=this.tsParseTypeOperatorOrHigher(),"readonly"===operator&&this.tsCheckTypeAnnotationForReadOnly(node),this.finishNode(node,"TSTypeOperator")}tsCheckTypeAnnotationForReadOnly(node){switch(node.typeAnnotation.type){case "TSTupleType":case "TSArrayType":return;default:this.raise(TSErrors.UnexpectedReadonly,node);}}tsParseInferType(){const node=this.startNode();this.expectContextual(115);const typeParameter=this.startNode();return typeParameter.name=this.tsParseTypeParameterName(),typeParameter.constraint=this.tsTryParse((()=>this.tsParseConstraintForInferType())),node.typeParameter=this.finishNode(typeParameter,"TSTypeParameter"),this.finishNode(node,"TSInferType")}tsParseConstraintForInferType(){if(this.eat(81)){const constraint=this.tsInDisallowConditionalTypesContext((()=>this.tsParseType()));if(this.state.inDisallowConditionalTypesContext||!this.match(17))return constraint}}tsParseTypeOperatorOrHigher(){var token;return (token=this.state.type)>=121&&token<=123&&!this.state.containsEsc?this.tsParseTypeOperator():this.isContextual(115)?this.tsParseInferType():this.tsInAllowConditionalTypesContext((()=>this.tsParseArrayTypeOrHigher()))}tsParseUnionOrIntersectionType(kind,parseConstituentType,operator){const node=this.startNode(),hasLeadingOperator=this.eat(operator),types=[];do{types.push(parseConstituentType());}while(this.eat(operator));return 1!==types.length||hasLeadingOperator?(node.types=types,this.finishNode(node,kind)):types[0]}tsParseIntersectionTypeOrHigher(){return this.tsParseUnionOrIntersectionType("TSIntersectionType",this.tsParseTypeOperatorOrHigher.bind(this),45)}tsParseUnionTypeOrHigher(){return this.tsParseUnionOrIntersectionType("TSUnionType",this.tsParseIntersectionTypeOrHigher.bind(this),43)}tsIsStartOfFunctionType(){return !!this.match(47)||this.match(10)&&this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this))}tsSkipParameterStart(){if(tokenIsIdentifier(this.state.type)||this.match(78))return this.next(),true;if(this.match(5)){const{errors}=this.state,previousErrorCount=errors.length;try{return this.parseObjectLike(8,!0),errors.length===previousErrorCount}catch(_unused){return  false}}if(this.match(0)){this.next();const{errors}=this.state,previousErrorCount=errors.length;try{return super.parseBindingList(3,93,1),errors.length===previousErrorCount}catch(_unused2){return  false}}return  false}tsIsUnambiguouslyStartOfFunctionType(){if(this.next(),this.match(11)||this.match(21))return  true;if(this.tsSkipParameterStart()){if(this.match(14)||this.match(12)||this.match(17)||this.match(29))return  true;if(this.match(11)&&(this.next(),this.match(19)))return  true}return  false}tsParseTypeOrTypePredicateAnnotation(returnToken){return this.tsInType((()=>{const t=this.startNode();this.expect(returnToken);const node=this.startNode(),asserts=!!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));if(asserts&&this.match(78)){let thisTypePredicate=this.tsParseThisTypeOrThisTypePredicate();return "TSThisType"===thisTypePredicate.type?(node.parameterName=thisTypePredicate,node.asserts=true,node.typeAnnotation=null,thisTypePredicate=this.finishNode(node,"TSTypePredicate")):(this.resetStartLocationFromNode(thisTypePredicate,node),thisTypePredicate.asserts=true),t.typeAnnotation=thisTypePredicate,this.finishNode(t,"TSTypeAnnotation")}const typePredicateVariable=this.tsIsIdentifier()&&this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));if(!typePredicateVariable)return asserts?(node.parameterName=this.parseIdentifier(),node.asserts=asserts,node.typeAnnotation=null,t.typeAnnotation=this.finishNode(node,"TSTypePredicate"),this.finishNode(t,"TSTypeAnnotation")):this.tsParseTypeAnnotation(false,t);const type=this.tsParseTypeAnnotation(false);return node.parameterName=typePredicateVariable,node.typeAnnotation=type,node.asserts=asserts,t.typeAnnotation=this.finishNode(node,"TSTypePredicate"),this.finishNode(t,"TSTypeAnnotation")}))}tsTryParseTypeOrTypePredicateAnnotation(){if(this.match(14))return this.tsParseTypeOrTypePredicateAnnotation(14)}tsTryParseTypeAnnotation(){if(this.match(14))return this.tsParseTypeAnnotation()}tsTryParseType(){return this.tsEatThenParseType(14)}tsParseTypePredicatePrefix(){const id=this.parseIdentifier();if(this.isContextual(116)&&!this.hasPrecedingLineBreak())return this.next(),id}tsParseTypePredicateAsserts(){if(109!==this.state.type)return  false;const containsEsc=this.state.containsEsc;return this.next(),!(!tokenIsIdentifier(this.state.type)&&!this.match(78))&&(containsEsc&&this.raise(Errors.InvalidEscapedReservedWord,this.state.lastTokStartLoc,{reservedWord:"asserts"}),true)}tsParseTypeAnnotation(eatColon=true,t=this.startNode()){return this.tsInType((()=>{eatColon&&this.expect(14),t.typeAnnotation=this.tsParseType();})),this.finishNode(t,"TSTypeAnnotation")}tsParseType(){assert(this.state.inType);const type=this.tsParseNonConditionalType();if(this.state.inDisallowConditionalTypesContext||this.hasPrecedingLineBreak()||!this.eat(81))return type;const node=this.startNodeAtNode(type);return node.checkType=type,node.extendsType=this.tsInDisallowConditionalTypesContext((()=>this.tsParseNonConditionalType())),this.expect(17),node.trueType=this.tsInAllowConditionalTypesContext((()=>this.tsParseType())),this.expect(14),node.falseType=this.tsInAllowConditionalTypesContext((()=>this.tsParseType())),this.finishNode(node,"TSConditionalType")}isAbstractConstructorSignature(){return this.isContextual(124)&&77===this.lookahead().type}tsParseNonConditionalType(){return this.tsIsStartOfFunctionType()?this.tsParseFunctionOrConstructorType("TSFunctionType"):this.match(77)?this.tsParseFunctionOrConstructorType("TSConstructorType"):this.isAbstractConstructorSignature()?this.tsParseFunctionOrConstructorType("TSConstructorType",true):this.tsParseUnionTypeOrHigher()}tsParseTypeAssertion(){this.getPluginOption("typescript","disallowAmbiguousJSXLike")&&this.raise(TSErrors.ReservedTypeAssertion,this.state.startLoc);const node=this.startNode();return node.typeAnnotation=this.tsInType((()=>(this.next(),this.match(75)?this.tsParseTypeReference():this.tsParseType()))),this.expect(48),node.expression=this.parseMaybeUnary(),this.finishNode(node,"TSTypeAssertion")}tsParseHeritageClause(token){const originalStartLoc=this.state.startLoc,delimitedList=this.tsParseDelimitedList("HeritageClauseElement",(()=>{const node=this.startNode();return node.expression=this.tsParseEntityName(),this.match(47)&&(node.typeParameters=this.tsParseTypeArguments()),this.finishNode(node,"TSExpressionWithTypeArguments")}));return delimitedList.length||this.raise(TSErrors.EmptyHeritageClauseType,originalStartLoc,{token}),delimitedList}tsParseInterfaceDeclaration(node,properties={}){if(this.hasFollowingLineBreak())return null;this.expectContextual(129),properties.declare&&(node.declare=true),tokenIsIdentifier(this.state.type)?(node.id=this.parseIdentifier(),this.checkIdentifier(node.id,130)):(node.id=null,this.raise(TSErrors.MissingInterfaceName,this.state.startLoc)),node.typeParameters=this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers),this.eat(81)&&(node.extends=this.tsParseHeritageClause("extends"));const body=this.startNode();return body.body=this.tsInType(this.tsParseObjectTypeMembers.bind(this)),node.body=this.finishNode(body,"TSInterfaceBody"),this.finishNode(node,"TSInterfaceDeclaration")}tsParseTypeAliasDeclaration(node){return node.id=this.parseIdentifier(),this.checkIdentifier(node.id,2),node.typeAnnotation=this.tsInType((()=>{if(node.typeParameters=this.tsTryParseTypeParameters(this.tsParseInOutModifiers),this.expect(29),this.isContextual(114)&&16!==this.lookahead().type){const node=this.startNode();return this.next(),this.finishNode(node,"TSIntrinsicKeyword")}return this.tsParseType()})),this.semicolon(),this.finishNode(node,"TSTypeAliasDeclaration")}tsInNoContext(cb){const oldContext=this.state.context;this.state.context=[oldContext[0]];try{return cb()}finally{this.state.context=oldContext;}}tsInType(cb){const oldInType=this.state.inType;this.state.inType=true;try{return cb()}finally{this.state.inType=oldInType;}}tsInDisallowConditionalTypesContext(cb){const oldInDisallowConditionalTypesContext=this.state.inDisallowConditionalTypesContext;this.state.inDisallowConditionalTypesContext=true;try{return cb()}finally{this.state.inDisallowConditionalTypesContext=oldInDisallowConditionalTypesContext;}}tsInAllowConditionalTypesContext(cb){const oldInDisallowConditionalTypesContext=this.state.inDisallowConditionalTypesContext;this.state.inDisallowConditionalTypesContext=false;try{return cb()}finally{this.state.inDisallowConditionalTypesContext=oldInDisallowConditionalTypesContext;}}tsEatThenParseType(token){if(this.match(token))return this.tsNextThenParseType()}tsExpectThenParseType(token){return this.tsInType((()=>(this.expect(token),this.tsParseType())))}tsNextThenParseType(){return this.tsInType((()=>(this.next(),this.tsParseType())))}tsParseEnumMember(){const node=this.startNode();return node.id=this.match(134)?super.parseStringLiteral(this.state.value):this.parseIdentifier(true),this.eat(29)&&(node.initializer=super.parseMaybeAssignAllowIn()),this.finishNode(node,"TSEnumMember")}tsParseEnumDeclaration(node,properties={}){return properties.const&&(node.const=true),properties.declare&&(node.declare=true),this.expectContextual(126),node.id=this.parseIdentifier(),this.checkIdentifier(node.id,node.const?8971:8459),this.expect(5),node.members=this.tsParseDelimitedList("EnumMembers",this.tsParseEnumMember.bind(this)),this.expect(8),this.finishNode(node,"TSEnumDeclaration")}tsParseModuleBlock(){const node=this.startNode();return this.scope.enter(0),this.expect(5),super.parseBlockOrModuleBlockBody(node.body=[],void 0,true,8),this.scope.exit(),this.finishNode(node,"TSModuleBlock")}tsParseModuleOrNamespaceDeclaration(node,nested=false){if(node.id=this.parseIdentifier(),nested||this.checkIdentifier(node.id,1024),this.eat(16)){const inner=this.startNode();this.tsParseModuleOrNamespaceDeclaration(inner,true),node.body=inner;}else this.scope.enter(256),this.prodParam.enter(0),node.body=this.tsParseModuleBlock(),this.prodParam.exit(),this.scope.exit();return this.finishNode(node,"TSModuleDeclaration")}tsParseAmbientExternalModuleDeclaration(node){return this.isContextual(112)?(node.kind="global",node.global=true,node.id=this.parseIdentifier()):this.match(134)?(node.kind="module",node.id=super.parseStringLiteral(this.state.value)):this.unexpected(),this.match(5)?(this.scope.enter(256),this.prodParam.enter(0),node.body=this.tsParseModuleBlock(),this.prodParam.exit(),this.scope.exit()):this.semicolon(),this.finishNode(node,"TSModuleDeclaration")}tsParseImportEqualsDeclaration(node,maybeDefaultIdentifier,isExport){node.isExport=isExport||false,node.id=maybeDefaultIdentifier||this.parseIdentifier(),this.checkIdentifier(node.id,4096),this.expect(29);const moduleReference=this.tsParseModuleReference();return "type"===node.importKind&&"TSExternalModuleReference"!==moduleReference.type&&this.raise(TSErrors.ImportAliasHasImportType,moduleReference),node.moduleReference=moduleReference,this.semicolon(),this.finishNode(node,"TSImportEqualsDeclaration")}tsIsExternalModuleReference(){return this.isContextual(119)&&40===this.lookaheadCharCode()}tsParseModuleReference(){return this.tsIsExternalModuleReference()?this.tsParseExternalModuleReference():this.tsParseEntityName(false)}tsParseExternalModuleReference(){const node=this.startNode();return this.expectContextual(119),this.expect(10),this.match(134)||this.unexpected(),node.expression=super.parseExprAtom(),this.expect(11),this.sawUnambiguousESM=true,this.finishNode(node,"TSExternalModuleReference")}tsLookAhead(f){const state=this.state.clone(),res=f();return this.state=state,res}tsTryParseAndCatch(f){const result=this.tryParse((abort=>f()||abort()));if(!result.aborted&&result.node)return result.error&&(this.state=result.failState),result.node}tsTryParse(f){const state=this.state.clone(),result=f();if(void 0!==result&&false!==result)return result;this.state=state;}tsTryParseDeclare(nany){if(this.isLineTerminator())return;let kind,startType=this.state.type;return this.isContextual(100)&&(startType=74,kind="let"),this.tsInAmbientContext((()=>{switch(startType){case 68:return nany.declare=true,super.parseFunctionStatement(nany,false,false);case 80:return nany.declare=true,this.parseClass(nany,true,false);case 126:return this.tsParseEnumDeclaration(nany,{declare:true});case 112:return this.tsParseAmbientExternalModuleDeclaration(nany);case 75:case 74:return this.match(75)&&this.isLookaheadContextual("enum")?(this.expect(75),this.tsParseEnumDeclaration(nany,{const:true,declare:true})):(nany.declare=true,this.parseVarStatement(nany,kind||this.state.value,true));case 129:{const result=this.tsParseInterfaceDeclaration(nany,{declare:true});if(result)return result}default:if(tokenIsIdentifier(startType))return this.tsParseDeclaration(nany,this.state.value,true,null)}}))}tsTryParseExportDeclaration(){return this.tsParseDeclaration(this.startNode(),this.state.value,true,null)}tsParseExpressionStatement(node,expr,decorators){switch(expr.name){case "declare":{const declaration=this.tsTryParseDeclare(node);return declaration&&(declaration.declare=true),declaration}case "global":if(this.match(5)){this.scope.enter(256),this.prodParam.enter(0);const mod=node;return mod.kind="global",node.global=true,mod.id=expr,mod.body=this.tsParseModuleBlock(),this.scope.exit(),this.prodParam.exit(),this.finishNode(mod,"TSModuleDeclaration")}break;default:return this.tsParseDeclaration(node,expr.name,false,decorators)}}tsParseDeclaration(node,value,next,decorators){switch(value){case "abstract":if(this.tsCheckLineTerminator(next)&&(this.match(80)||tokenIsIdentifier(this.state.type)))return this.tsParseAbstractDeclaration(node,decorators);break;case "module":if(this.tsCheckLineTerminator(next)){if(this.match(134))return this.tsParseAmbientExternalModuleDeclaration(node);if(tokenIsIdentifier(this.state.type))return node.kind="module",this.tsParseModuleOrNamespaceDeclaration(node)}break;case "namespace":if(this.tsCheckLineTerminator(next)&&tokenIsIdentifier(this.state.type))return node.kind="namespace",this.tsParseModuleOrNamespaceDeclaration(node);break;case "type":if(this.tsCheckLineTerminator(next)&&tokenIsIdentifier(this.state.type))return this.tsParseTypeAliasDeclaration(node)}}tsCheckLineTerminator(next){return next?!this.hasFollowingLineBreak()&&(this.next(),true):!this.isLineTerminator()}tsTryParseGenericAsyncArrowFunction(startLoc){if(!this.match(47))return;const oldMaybeInArrowParameters=this.state.maybeInArrowParameters;this.state.maybeInArrowParameters=true;const res=this.tsTryParseAndCatch((()=>{const node=this.startNodeAt(startLoc);return node.typeParameters=this.tsParseTypeParameters(this.tsParseConstModifier),super.parseFunctionParams(node),node.returnType=this.tsTryParseTypeOrTypePredicateAnnotation(),this.expect(19),node}));return this.state.maybeInArrowParameters=oldMaybeInArrowParameters,res?super.parseArrowExpression(res,null,true):void 0}tsParseTypeArgumentsInExpression(){if(47===this.reScan_lt())return this.tsParseTypeArguments()}tsParseTypeArguments(){const node=this.startNode();return node.params=this.tsInType((()=>this.tsInNoContext((()=>(this.expect(47),this.tsParseDelimitedList("TypeParametersOrArguments",this.tsParseType.bind(this))))))),0===node.params.length?this.raise(TSErrors.EmptyTypeArguments,node):this.state.inType||this.curContext()!==types.brace||this.reScan_lt_gt(),this.expect(48),this.finishNode(node,"TSTypeParameterInstantiation")}tsIsDeclarationStart(){return (token=this.state.type)>=124&&token<=130;var token;}isExportDefaultSpecifier(){return !this.tsIsDeclarationStart()&&super.isExportDefaultSpecifier()}parseAssignableListItem(flags,decorators){const startLoc=this.state.startLoc,modified={};this.tsParseModifiers({allowedModifiers:["public","private","protected","override","readonly"]},modified);const accessibility=modified.accessibility,override=modified.override,readonly=modified.readonly;4&flags||!(accessibility||readonly||override)||this.raise(TSErrors.UnexpectedParameterModifier,startLoc);const left=this.parseMaybeDefault();2&flags&&this.parseFunctionParamType(left);const elt=this.parseMaybeDefault(left.loc.start,left);if(accessibility||readonly||override){const pp=this.startNodeAt(startLoc);return decorators.length&&(pp.decorators=decorators),accessibility&&(pp.accessibility=accessibility),readonly&&(pp.readonly=readonly),override&&(pp.override=override),"Identifier"!==elt.type&&"AssignmentPattern"!==elt.type&&this.raise(TSErrors.UnsupportedParameterPropertyKind,pp),pp.parameter=elt,this.finishNode(pp,"TSParameterProperty")}return decorators.length&&(left.decorators=decorators),elt}isSimpleParameter(node){return "TSParameterProperty"===node.type&&super.isSimpleParameter(node.parameter)||super.isSimpleParameter(node)}tsDisallowOptionalPattern(node){for(const param of node.params)"Identifier"!==param.type&&param.optional&&!this.state.isAmbientContext&&this.raise(TSErrors.PatternIsOptional,param);}setArrowFunctionParameters(node,params,trailingCommaLoc){super.setArrowFunctionParameters(node,params,trailingCommaLoc),this.tsDisallowOptionalPattern(node);}parseFunctionBodyAndFinish(node,type,isMethod=false){this.match(14)&&(node.returnType=this.tsParseTypeOrTypePredicateAnnotation(14));const bodilessType="FunctionDeclaration"===type?"TSDeclareFunction":"ClassMethod"===type||"ClassPrivateMethod"===type?"TSDeclareMethod":void 0;return bodilessType&&!this.match(5)&&this.isLineTerminator()?this.finishNode(node,bodilessType):"TSDeclareFunction"===bodilessType&&this.state.isAmbientContext&&(this.raise(TSErrors.DeclareFunctionHasImplementation,node),node.declare)?super.parseFunctionBodyAndFinish(node,bodilessType,isMethod):(this.tsDisallowOptionalPattern(node),super.parseFunctionBodyAndFinish(node,type,isMethod))}registerFunctionStatementId(node){!node.body&&node.id?this.checkIdentifier(node.id,1024):super.registerFunctionStatementId(node);}tsCheckForInvalidTypeCasts(items){items.forEach((node=>{"TSTypeCastExpression"===(null==node?void 0:node.type)&&this.raise(TSErrors.UnexpectedTypeAnnotation,node.typeAnnotation);}));}toReferencedList(exprList,isInParens){return this.tsCheckForInvalidTypeCasts(exprList),exprList}parseArrayLike(close,canBePattern,isTuple,refExpressionErrors){const node=super.parseArrayLike(close,canBePattern,isTuple,refExpressionErrors);return "ArrayExpression"===node.type&&this.tsCheckForInvalidTypeCasts(node.elements),node}parseSubscript(base,startLoc,noCalls,state){if(!this.hasPrecedingLineBreak()&&this.match(35)){this.state.canStartJSXElement=false,this.next();const nonNullExpression=this.startNodeAt(startLoc);return nonNullExpression.expression=base,this.finishNode(nonNullExpression,"TSNonNullExpression")}let isOptionalCall=false;if(this.match(18)&&60===this.lookaheadCharCode()){if(noCalls)return state.stop=true,base;state.optionalChainMember=isOptionalCall=true,this.next();}if(this.match(47)||this.match(51)){let missingParenErrorLoc;const result=this.tsTryParseAndCatch((()=>{if(!noCalls&&this.atPossibleAsyncArrow(base)){const asyncArrowFn=this.tsTryParseGenericAsyncArrowFunction(startLoc);if(asyncArrowFn)return asyncArrowFn}const typeArguments=this.tsParseTypeArgumentsInExpression();if(!typeArguments)return;if(isOptionalCall&&!this.match(10))return void(missingParenErrorLoc=this.state.curPosition());if(tokenIsTemplate(this.state.type)){const result=super.parseTaggedTemplateExpression(base,startLoc,state);return result.typeParameters=typeArguments,result}if(!noCalls&&this.eat(10)){const node=this.startNodeAt(startLoc);return node.callee=base,node.arguments=this.parseCallExpressionArguments(11),this.tsCheckForInvalidTypeCasts(node.arguments),node.typeParameters=typeArguments,state.optionalChainMember&&(node.optional=isOptionalCall),this.finishCallExpression(node,state.optionalChainMember)}const tokenType=this.state.type;if(48===tokenType||52===tokenType||10!==tokenType&&tokenCanStartExpression(tokenType)&&!this.hasPrecedingLineBreak())return;const node=this.startNodeAt(startLoc);return node.expression=base,node.typeParameters=typeArguments,this.finishNode(node,"TSInstantiationExpression")}));if(missingParenErrorLoc&&this.unexpected(missingParenErrorLoc,10),result)return "TSInstantiationExpression"===result.type&&(this.match(16)||this.match(18)&&40!==this.lookaheadCharCode())&&this.raise(TSErrors.InvalidPropertyAccessAfterInstantiationExpression,this.state.startLoc),result}return super.parseSubscript(base,startLoc,noCalls,state)}parseNewCallee(node){var _callee$extra;super.parseNewCallee(node);const{callee}=node;"TSInstantiationExpression"!==callee.type||null!=(_callee$extra=callee.extra)&&_callee$extra.parenthesized||(node.typeParameters=callee.typeParameters,node.callee=callee.expression);}parseExprOp(left,leftStartLoc,minPrec){let isSatisfies;if(tokenOperatorPrecedence(58)>minPrec&&!this.hasPrecedingLineBreak()&&(this.isContextual(93)||(isSatisfies=this.isContextual(120)))){const node=this.startNodeAt(leftStartLoc);return node.expression=left,node.typeAnnotation=this.tsInType((()=>(this.next(),this.match(75)?(isSatisfies&&this.raise(Errors.UnexpectedKeyword,this.state.startLoc,{keyword:"const"}),this.tsParseTypeReference()):this.tsParseType()))),this.finishNode(node,isSatisfies?"TSSatisfiesExpression":"TSAsExpression"),this.reScan_lt_gt(),this.parseExprOp(node,leftStartLoc,minPrec)}return super.parseExprOp(left,leftStartLoc,minPrec)}checkReservedWord(word,startLoc,checkKeywords,isBinding){this.state.isAmbientContext||super.checkReservedWord(word,startLoc,checkKeywords,isBinding);}checkImportReflection(node){super.checkImportReflection(node),node.module&&"value"!==node.importKind&&this.raise(TSErrors.ImportReflectionHasImportType,node.specifiers[0].loc.start);}checkDuplicateExports(){}isPotentialImportPhase(isExport){if(super.isPotentialImportPhase(isExport))return  true;if(this.isContextual(130)){const ch=this.lookaheadCharCode();return isExport?123===ch||42===ch:61!==ch}return !isExport&&this.isContextual(87)}applyImportPhase(node,isExport,phase,loc){super.applyImportPhase(node,isExport,phase,loc),isExport?node.exportKind="type"===phase?"type":"value":node.importKind="type"===phase||"typeof"===phase?phase:"value";}parseImport(node){if(this.match(134))return node.importKind="value",super.parseImport(node);let importNode;if(tokenIsIdentifier(this.state.type)&&61===this.lookaheadCharCode())return node.importKind="value",this.tsParseImportEqualsDeclaration(node);if(this.isContextual(130)){const maybeDefaultIdentifier=this.parseMaybeImportPhase(node,false);if(61===this.lookaheadCharCode())return this.tsParseImportEqualsDeclaration(node,maybeDefaultIdentifier);importNode=super.parseImportSpecifiersAndAfter(node,maybeDefaultIdentifier);}else importNode=super.parseImport(node);return "type"===importNode.importKind&&importNode.specifiers.length>1&&"ImportDefaultSpecifier"===importNode.specifiers[0].type&&this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed,importNode),importNode}parseExport(node,decorators){if(this.match(83)){this.next();const nodeImportEquals=node;let maybeDefaultIdentifier=null;return this.isContextual(130)&&this.isPotentialImportPhase(false)?maybeDefaultIdentifier=this.parseMaybeImportPhase(nodeImportEquals,false):nodeImportEquals.importKind="value",this.tsParseImportEqualsDeclaration(nodeImportEquals,maybeDefaultIdentifier,true)}if(this.eat(29)){const assign=node;return assign.expression=super.parseExpression(),this.semicolon(),this.sawUnambiguousESM=true,this.finishNode(assign,"TSExportAssignment")}if(this.eatContextual(93)){const decl=node;return this.expectContextual(128),decl.id=this.parseIdentifier(),this.semicolon(),this.finishNode(decl,"TSNamespaceExportDeclaration")}return super.parseExport(node,decorators)}isAbstractClass(){return this.isContextual(124)&&80===this.lookahead().type}parseExportDefaultExpression(){if(this.isAbstractClass()){const cls=this.startNode();return this.next(),cls.abstract=true,this.parseClass(cls,true,true)}if(this.match(129)){const result=this.tsParseInterfaceDeclaration(this.startNode());if(result)return result}return super.parseExportDefaultExpression()}parseVarStatement(node,kind,allowMissingInitializer=false){const{isAmbientContext}=this.state,declaration=super.parseVarStatement(node,kind,allowMissingInitializer||isAmbientContext);if(!isAmbientContext)return declaration;for(const{id,init}of declaration.declarations)init&&("const"!==kind||id.typeAnnotation?this.raise(TSErrors.InitializerNotAllowedInAmbientContext,init):isValidAmbientConstInitializer(init,this.hasPlugin("estree"))||this.raise(TSErrors.ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference,init));return declaration}parseStatementContent(flags,decorators){if(this.match(75)&&this.isLookaheadContextual("enum")){const node=this.startNode();return this.expect(75),this.tsParseEnumDeclaration(node,{const:true})}if(this.isContextual(126))return this.tsParseEnumDeclaration(this.startNode());if(this.isContextual(129)){const result=this.tsParseInterfaceDeclaration(this.startNode());if(result)return result}return super.parseStatementContent(flags,decorators)}parseAccessModifier(){return this.tsParseModifier(["public","protected","private"])}tsHasSomeModifiers(member,modifiers){return modifiers.some((modifier=>tsIsAccessModifier(modifier)?member.accessibility===modifier:!!member[modifier]))}tsIsStartOfStaticBlocks(){return this.isContextual(106)&&123===this.lookaheadCharCode()}parseClassMember(classBody,member,state){const modifiers=["declare","private","public","protected","override","abstract","readonly","static"];this.tsParseModifiers({allowedModifiers:modifiers,disallowedModifiers:["in","out"],stopOnStartOfClassStaticBlock:true,errorTemplate:TSErrors.InvalidModifierOnTypeParameterPositions},member);const callParseClassMemberWithIsStatic=()=>{this.tsIsStartOfStaticBlocks()?(this.next(),this.next(),this.tsHasSomeModifiers(member,modifiers)&&this.raise(TSErrors.StaticBlockCannotHaveModifier,this.state.curPosition()),super.parseClassStaticBlock(classBody,member)):this.parseClassMemberWithIsStatic(classBody,member,state,!!member.static);};member.declare?this.tsInAmbientContext(callParseClassMemberWithIsStatic):callParseClassMemberWithIsStatic();}parseClassMemberWithIsStatic(classBody,member,state,isStatic){const idx=this.tsTryParseIndexSignature(member);if(idx)return classBody.body.push(idx),member.abstract&&this.raise(TSErrors.IndexSignatureHasAbstract,member),member.accessibility&&this.raise(TSErrors.IndexSignatureHasAccessibility,member,{modifier:member.accessibility}),member.declare&&this.raise(TSErrors.IndexSignatureHasDeclare,member),void(member.override&&this.raise(TSErrors.IndexSignatureHasOverride,member));!this.state.inAbstractClass&&member.abstract&&this.raise(TSErrors.NonAbstractClassHasAbstractMethod,member),member.override&&(state.hadSuperClass||this.raise(TSErrors.OverrideNotInSubClass,member)),super.parseClassMemberWithIsStatic(classBody,member,state,isStatic);}parsePostMemberNameModifiers(methodOrProp){this.eat(17)&&(methodOrProp.optional=true),methodOrProp.readonly&&this.match(10)&&this.raise(TSErrors.ClassMethodHasReadonly,methodOrProp),methodOrProp.declare&&this.match(10)&&this.raise(TSErrors.ClassMethodHasDeclare,methodOrProp);}parseExpressionStatement(node,expr,decorators){return ("Identifier"===expr.type?this.tsParseExpressionStatement(node,expr,decorators):void 0)||super.parseExpressionStatement(node,expr,decorators)}shouldParseExportDeclaration(){return !!this.tsIsDeclarationStart()||super.shouldParseExportDeclaration()}parseConditional(expr,startLoc,refExpressionErrors){if(!this.state.maybeInArrowParameters||!this.match(17))return super.parseConditional(expr,startLoc,refExpressionErrors);const result=this.tryParse((()=>super.parseConditional(expr,startLoc)));return result.node?(result.error&&(this.state=result.failState),result.node):(result.error&&super.setOptionalParametersError(refExpressionErrors,result.error),expr)}parseParenItem(node,startLoc){const newNode=super.parseParenItem(node,startLoc);if(this.eat(17)&&(newNode.optional=true,this.resetEndLocation(node)),this.match(14)){const typeCastNode=this.startNodeAt(startLoc);return typeCastNode.expression=node,typeCastNode.typeAnnotation=this.tsParseTypeAnnotation(),this.finishNode(typeCastNode,"TSTypeCastExpression")}return node}parseExportDeclaration(node){if(!this.state.isAmbientContext&&this.isContextual(125))return this.tsInAmbientContext((()=>this.parseExportDeclaration(node)));const startLoc=this.state.startLoc,isDeclare=this.eatContextual(125);if(isDeclare&&(this.isContextual(125)||!this.shouldParseExportDeclaration()))throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare,this.state.startLoc);const declaration=tokenIsIdentifier(this.state.type)&&this.tsTryParseExportDeclaration()||super.parseExportDeclaration(node);return declaration?(("TSInterfaceDeclaration"===declaration.type||"TSTypeAliasDeclaration"===declaration.type||isDeclare)&&(node.exportKind="type"),isDeclare&&(this.resetStartLocation(declaration,startLoc),declaration.declare=true),declaration):null}parseClassId(node,isStatement,optionalId,bindingType){if((!isStatement||optionalId)&&this.isContextual(113))return;super.parseClassId(node,isStatement,optionalId,node.declare?1024:8331);const typeParameters=this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);typeParameters&&(node.typeParameters=typeParameters);}parseClassPropertyAnnotation(node){node.optional||(this.eat(35)?node.definite=true:this.eat(17)&&(node.optional=true));const type=this.tsTryParseTypeAnnotation();type&&(node.typeAnnotation=type);}parseClassProperty(node){if(this.parseClassPropertyAnnotation(node),this.state.isAmbientContext&&(!node.readonly||node.typeAnnotation)&&this.match(29)&&this.raise(TSErrors.DeclareClassFieldHasInitializer,this.state.startLoc),node.abstract&&this.match(29)){const{key}=node;this.raise(TSErrors.AbstractPropertyHasInitializer,this.state.startLoc,{propertyName:"Identifier"!==key.type||node.computed?`[${this.input.slice(this.offsetToSourcePos(key.start),this.offsetToSourcePos(key.end))}]`:key.name});}return super.parseClassProperty(node)}parseClassPrivateProperty(node){return node.abstract&&this.raise(TSErrors.PrivateElementHasAbstract,node),node.accessibility&&this.raise(TSErrors.PrivateElementHasAccessibility,node,{modifier:node.accessibility}),this.parseClassPropertyAnnotation(node),super.parseClassPrivateProperty(node)}parseClassAccessorProperty(node){return this.parseClassPropertyAnnotation(node),node.optional&&this.raise(TSErrors.AccessorCannotBeOptional,node),super.parseClassAccessorProperty(node)}pushClassMethod(classBody,method,isGenerator,isAsync,isConstructor,allowsDirectSuper){const typeParameters=this.tsTryParseTypeParameters(this.tsParseConstModifier);typeParameters&&isConstructor&&this.raise(TSErrors.ConstructorHasTypeParameters,typeParameters);const{declare=false,kind}=method;!declare||"get"!==kind&&"set"!==kind||this.raise(TSErrors.DeclareAccessor,method,{kind}),typeParameters&&(method.typeParameters=typeParameters),super.pushClassMethod(classBody,method,isGenerator,isAsync,isConstructor,allowsDirectSuper);}pushClassPrivateMethod(classBody,method,isGenerator,isAsync){const typeParameters=this.tsTryParseTypeParameters(this.tsParseConstModifier);typeParameters&&(method.typeParameters=typeParameters),super.pushClassPrivateMethod(classBody,method,isGenerator,isAsync);}declareClassPrivateMethodInScope(node,kind){"TSDeclareMethod"!==node.type&&("MethodDefinition"!==node.type||hasOwnProperty.call(node.value,"body"))&&super.declareClassPrivateMethodInScope(node,kind);}parseClassSuper(node){super.parseClassSuper(node),node.superClass&&(this.match(47)||this.match(51))&&(node.superTypeParameters=this.tsParseTypeArgumentsInExpression()),this.eatContextual(113)&&(node.implements=this.tsParseHeritageClause("implements"));}parseObjPropValue(prop,startLoc,isGenerator,isAsync,isPattern,isAccessor,refExpressionErrors){const typeParameters=this.tsTryParseTypeParameters(this.tsParseConstModifier);return typeParameters&&(prop.typeParameters=typeParameters),super.parseObjPropValue(prop,startLoc,isGenerator,isAsync,isPattern,isAccessor,refExpressionErrors)}parseFunctionParams(node,isConstructor){const typeParameters=this.tsTryParseTypeParameters(this.tsParseConstModifier);typeParameters&&(node.typeParameters=typeParameters),super.parseFunctionParams(node,isConstructor);}parseVarId(decl,kind){super.parseVarId(decl,kind),"Identifier"===decl.id.type&&!this.hasPrecedingLineBreak()&&this.eat(35)&&(decl.definite=true);const type=this.tsTryParseTypeAnnotation();type&&(decl.id.typeAnnotation=type,this.resetEndLocation(decl.id));}parseAsyncArrowFromCallExpression(node,call){return this.match(14)&&(node.returnType=this.tsParseTypeAnnotation()),super.parseAsyncArrowFromCallExpression(node,call)}parseMaybeAssign(refExpressionErrors,afterLeftParse){var _jsx,_jsx2,_typeCast,_jsx3,_typeCast2;let state,jsx,typeCast,typeParameters;if(this.hasPlugin("jsx")&&(this.match(143)||this.match(47))){if(state=this.state.clone(),jsx=this.tryParse((()=>super.parseMaybeAssign(refExpressionErrors,afterLeftParse)),state),!jsx.error)return jsx.node;const{context}=this.state,currentContext=context[context.length-1];currentContext!==types.j_oTag&&currentContext!==types.j_expr||context.pop();}if(!(null!=(_jsx=jsx)&&_jsx.error||this.match(47)))return super.parseMaybeAssign(refExpressionErrors,afterLeftParse);state&&state!==this.state||(state=this.state.clone());const arrow=this.tryParse((abort=>{var _expr$extra,_typeParameters;typeParameters=this.tsParseTypeParameters(this.tsParseConstModifier);const expr=super.parseMaybeAssign(refExpressionErrors,afterLeftParse);return ("ArrowFunctionExpression"!==expr.type||null!=(_expr$extra=expr.extra)&&_expr$extra.parenthesized)&&abort(),0!==(null==(_typeParameters=typeParameters)?void 0:_typeParameters.params.length)&&this.resetStartLocationFromNode(expr,typeParameters),expr.typeParameters=typeParameters,expr}),state);if(!arrow.error&&!arrow.aborted)return typeParameters&&this.reportReservedArrowTypeParam(typeParameters),arrow.node;if(!jsx&&(assert(!this.hasPlugin("jsx")),typeCast=this.tryParse((()=>super.parseMaybeAssign(refExpressionErrors,afterLeftParse)),state),!typeCast.error))return typeCast.node;if(null!=(_jsx2=jsx)&&_jsx2.node)return this.state=jsx.failState,jsx.node;if(arrow.node)return this.state=arrow.failState,typeParameters&&this.reportReservedArrowTypeParam(typeParameters),arrow.node;if(null!=(_typeCast=typeCast)&&_typeCast.node)return this.state=typeCast.failState,typeCast.node;throw (null==(_jsx3=jsx)?void 0:_jsx3.error)||arrow.error||(null==(_typeCast2=typeCast)?void 0:_typeCast2.error)}reportReservedArrowTypeParam(node){var _node$extra;1!==node.params.length||node.params[0].constraint||null!=(_node$extra=node.extra)&&_node$extra.trailingComma||!this.getPluginOption("typescript","disallowAmbiguousJSXLike")||this.raise(TSErrors.ReservedArrowTypeParam,node);}parseMaybeUnary(refExpressionErrors,sawUnary){return !this.hasPlugin("jsx")&&this.match(47)?this.tsParseTypeAssertion():super.parseMaybeUnary(refExpressionErrors,sawUnary)}parseArrow(node){if(this.match(14)){const result=this.tryParse((abort=>{const returnType=this.tsParseTypeOrTypePredicateAnnotation(14);return !this.canInsertSemicolon()&&this.match(19)||abort(),returnType}));if(result.aborted)return;result.thrown||(result.error&&(this.state=result.failState),node.returnType=result.node);}return super.parseArrow(node)}parseFunctionParamType(param){this.eat(17)&&(param.optional=true);const type=this.tsTryParseTypeAnnotation();return type&&(param.typeAnnotation=type),this.resetEndLocation(param),param}isAssignable(node,isBinding){switch(node.type){case "TSTypeCastExpression":return this.isAssignable(node.expression,isBinding);case "TSParameterProperty":return  true;default:return super.isAssignable(node,isBinding)}}toAssignable(node,isLHS=false){switch(node.type){case "ParenthesizedExpression":this.toAssignableParenthesizedExpression(node,isLHS);break;case "TSAsExpression":case "TSSatisfiesExpression":case "TSNonNullExpression":case "TSTypeAssertion":isLHS?this.expressionScope.recordArrowParameterBindingError(TSErrors.UnexpectedTypeCastInParameter,node):this.raise(TSErrors.UnexpectedTypeCastInParameter,node),this.toAssignable(node.expression,isLHS);break;case "AssignmentExpression":isLHS||"TSTypeCastExpression"!==node.left.type||(node.left=this.typeCastToParameter(node.left));default:super.toAssignable(node,isLHS);}}toAssignableParenthesizedExpression(node,isLHS){switch(node.expression.type){case "TSAsExpression":case "TSSatisfiesExpression":case "TSNonNullExpression":case "TSTypeAssertion":case "ParenthesizedExpression":this.toAssignable(node.expression,isLHS);break;default:super.toAssignable(node,isLHS);}}checkToRestConversion(node,allowPattern){switch(node.type){case "TSAsExpression":case "TSSatisfiesExpression":case "TSTypeAssertion":case "TSNonNullExpression":this.checkToRestConversion(node.expression,false);break;default:super.checkToRestConversion(node,allowPattern);}}isValidLVal(type,isUnparenthesizedInAssign,binding){switch(type){case "TSTypeCastExpression":return  true;case "TSParameterProperty":return "parameter";case "TSNonNullExpression":case "TSInstantiationExpression":return "expression";case "TSAsExpression":case "TSSatisfiesExpression":case "TSTypeAssertion":return (64!==binding||!isUnparenthesizedInAssign)&&["expression",true];default:return super.isValidLVal(type,isUnparenthesizedInAssign,binding)}}parseBindingAtom(){return 78===this.state.type?this.parseIdentifier(true):super.parseBindingAtom()}parseMaybeDecoratorArguments(expr){if(this.match(47)||this.match(51)){const typeArguments=this.tsParseTypeArgumentsInExpression();if(this.match(10)){const call=super.parseMaybeDecoratorArguments(expr);return call.typeParameters=typeArguments,call}this.unexpected(null,10);}return super.parseMaybeDecoratorArguments(expr)}checkCommaAfterRest(close){return this.state.isAmbientContext&&this.match(12)&&this.lookaheadCharCode()===close?(this.next(),false):super.checkCommaAfterRest(close)}isClassMethod(){return this.match(47)||super.isClassMethod()}isClassProperty(){return this.match(35)||this.match(14)||super.isClassProperty()}parseMaybeDefault(startLoc,left){const node=super.parseMaybeDefault(startLoc,left);return "AssignmentPattern"===node.type&&node.typeAnnotation&&node.right.start<node.typeAnnotation.start&&this.raise(TSErrors.TypeAnnotationAfterAssign,node.typeAnnotation),node}getTokenFromCode(code){if(this.state.inType){if(62===code)return void this.finishOp(48,1);if(60===code)return void this.finishOp(47,1)}super.getTokenFromCode(code);}reScan_lt_gt(){const{type}=this.state;47===type?(this.state.pos-=1,this.readToken_lt()):48===type&&(this.state.pos-=1,this.readToken_gt());}reScan_lt(){const{type}=this.state;return 51===type?(this.state.pos-=2,this.finishOp(47,1),47):type}toAssignableList(exprList,trailingCommaLoc,isLHS){for(let i=0;i<exprList.length;i++){const expr=exprList[i];"TSTypeCastExpression"===(null==expr?void 0:expr.type)&&(exprList[i]=this.typeCastToParameter(expr));}super.toAssignableList(exprList,trailingCommaLoc,isLHS);}typeCastToParameter(node){return node.expression.typeAnnotation=node.typeAnnotation,this.resetEndLocation(node.expression,node.typeAnnotation.loc.end),node.expression}shouldParseArrow(params){return this.match(14)?params.every((expr=>this.isAssignable(expr,true))):super.shouldParseArrow(params)}shouldParseAsyncArrow(){return this.match(14)||super.shouldParseAsyncArrow()}canHaveLeadingDecorator(){return super.canHaveLeadingDecorator()||this.isAbstractClass()}jsxParseOpeningElementAfterName(node){if(this.match(47)||this.match(51)){const typeArguments=this.tsTryParseAndCatch((()=>this.tsParseTypeArgumentsInExpression()));typeArguments&&(node.typeParameters=typeArguments);}return super.jsxParseOpeningElementAfterName(node)}getGetterSetterExpectedParamCount(method){const baseCount=super.getGetterSetterExpectedParamCount(method),firstParam=this.getObjectOrClassMethodParams(method)[0];return firstParam&&this.isThisParam(firstParam)?baseCount+1:baseCount}parseCatchClauseParam(){const param=super.parseCatchClauseParam(),type=this.tsTryParseTypeAnnotation();return type&&(param.typeAnnotation=type,this.resetEndLocation(param)),param}tsInAmbientContext(cb){const{isAmbientContext:oldIsAmbientContext,strict:oldStrict}=this.state;this.state.isAmbientContext=true,this.state.strict=false;try{return cb()}finally{this.state.isAmbientContext=oldIsAmbientContext,this.state.strict=oldStrict;}}parseClass(node,isStatement,optionalId){const oldInAbstractClass=this.state.inAbstractClass;this.state.inAbstractClass=!!node.abstract;try{return super.parseClass(node,isStatement,optionalId)}finally{this.state.inAbstractClass=oldInAbstractClass;}}tsParseAbstractDeclaration(node,decorators){if(this.match(80))return node.abstract=true,this.maybeTakeDecorators(decorators,this.parseClass(node,true,false));if(this.isContextual(129)){if(!this.hasFollowingLineBreak())return node.abstract=true,this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifer,node),this.tsParseInterfaceDeclaration(node)}else this.unexpected(null,80);}parseMethod(node,isGenerator,isAsync,isConstructor,allowDirectSuper,type,inClassScope){const method=super.parseMethod(node,isGenerator,isAsync,isConstructor,allowDirectSuper,type,inClassScope);if(method.abstract){if(this.hasPlugin("estree")?!!method.value.body:!!method.body){const{key}=method;this.raise(TSErrors.AbstractMethodHasImplementation,method,{methodName:"Identifier"!==key.type||method.computed?`[${this.input.slice(this.offsetToSourcePos(key.start),this.offsetToSourcePos(key.end))}]`:key.name});}}return method}tsParseTypeParameterName(){return this.parseIdentifier().name}shouldParseAsAmbientContext(){return !!this.getPluginOption("typescript","dts")}parse(){return this.shouldParseAsAmbientContext()&&(this.state.isAmbientContext=true),super.parse()}getExpression(){return this.shouldParseAsAmbientContext()&&(this.state.isAmbientContext=true),super.getExpression()}parseExportSpecifier(node,isString,isInTypeExport,isMaybeTypeOnly){return !isString&&isMaybeTypeOnly?(this.parseTypeOnlyImportExportSpecifier(node,false,isInTypeExport),this.finishNode(node,"ExportSpecifier")):(node.exportKind="value",super.parseExportSpecifier(node,isString,isInTypeExport,isMaybeTypeOnly))}parseImportSpecifier(specifier,importedIsString,isInTypeOnlyImport,isMaybeTypeOnly,bindingType){return !importedIsString&&isMaybeTypeOnly?(this.parseTypeOnlyImportExportSpecifier(specifier,true,isInTypeOnlyImport),this.finishNode(specifier,"ImportSpecifier")):(specifier.importKind="value",super.parseImportSpecifier(specifier,importedIsString,isInTypeOnlyImport,isMaybeTypeOnly,isInTypeOnlyImport?4098:4096))}parseTypeOnlyImportExportSpecifier(node,isImport,isInTypeOnlyImportExport){const leftOfAsKey=isImport?"imported":"local",rightOfAsKey=isImport?"local":"exported";let rightOfAs,leftOfAs=node[leftOfAsKey],hasTypeSpecifier=false,canParseAsKeyword=true;const loc=leftOfAs.loc.start;if(this.isContextual(93)){const firstAs=this.parseIdentifier();if(this.isContextual(93)){const secondAs=this.parseIdentifier();tokenIsKeywordOrIdentifier(this.state.type)?(hasTypeSpecifier=true,leftOfAs=firstAs,rightOfAs=isImport?this.parseIdentifier():this.parseModuleExportName(),canParseAsKeyword=false):(rightOfAs=secondAs,canParseAsKeyword=false);}else tokenIsKeywordOrIdentifier(this.state.type)?(canParseAsKeyword=false,rightOfAs=isImport?this.parseIdentifier():this.parseModuleExportName()):(hasTypeSpecifier=true,leftOfAs=firstAs);}else tokenIsKeywordOrIdentifier(this.state.type)&&(hasTypeSpecifier=true,isImport?(leftOfAs=this.parseIdentifier(true),this.isContextual(93)||this.checkReservedWord(leftOfAs.name,leftOfAs.loc.start,true,true)):leftOfAs=this.parseModuleExportName());hasTypeSpecifier&&isInTypeOnlyImportExport&&this.raise(isImport?TSErrors.TypeModifierIsUsedInTypeImports:TSErrors.TypeModifierIsUsedInTypeExports,loc),node[leftOfAsKey]=leftOfAs,node[rightOfAsKey]=rightOfAs;node[isImport?"importKind":"exportKind"]=hasTypeSpecifier?"type":"value",canParseAsKeyword&&this.eatContextual(93)&&(node[rightOfAsKey]=isImport?this.parseIdentifier():this.parseModuleExportName()),node[rightOfAsKey]||(node[rightOfAsKey]=cloneIdentifier(node[leftOfAsKey])),isImport&&this.checkIdentifier(node[rightOfAsKey],hasTypeSpecifier?4098:4096);}},v8intrinsic:superClass=>class extends superClass{parseV8Intrinsic(){if(this.match(54)){const v8IntrinsicStartLoc=this.state.startLoc,node=this.startNode();if(this.next(),tokenIsIdentifier(this.state.type)){const name=this.parseIdentifierName(),identifier=this.createIdentifier(node,name);if(identifier.type="V8IntrinsicIdentifier",this.match(10))return identifier}this.unexpected(v8IntrinsicStartLoc);}}parseExprAtom(refExpressionErrors){return this.parseV8Intrinsic()||super.parseExprAtom(refExpressionErrors)}},placeholders:superClass=>class extends superClass{parsePlaceholder(expectedNode){if(this.match(133)){const node=this.startNode();return this.next(),this.assertNoSpace(),node.name=super.parseIdentifier(true),this.assertNoSpace(),this.expect(133),this.finishPlaceholder(node,expectedNode)}}finishPlaceholder(node,expectedNode){let placeholder=node;return placeholder.expectedNode&&placeholder.type||(placeholder=this.finishNode(placeholder,"Placeholder")),placeholder.expectedNode=expectedNode,placeholder}getTokenFromCode(code){37===code&&37===this.input.charCodeAt(this.state.pos+1)?this.finishOp(133,2):super.getTokenFromCode(code);}parseExprAtom(refExpressionErrors){return this.parsePlaceholder("Expression")||super.parseExprAtom(refExpressionErrors)}parseIdentifier(liberal){return this.parsePlaceholder("Identifier")||super.parseIdentifier(liberal)}checkReservedWord(word,startLoc,checkKeywords,isBinding){ void 0!==word&&super.checkReservedWord(word,startLoc,checkKeywords,isBinding);}parseBindingAtom(){return this.parsePlaceholder("Pattern")||super.parseBindingAtom()}isValidLVal(type,isParenthesized,binding){return "Placeholder"===type||super.isValidLVal(type,isParenthesized,binding)}toAssignable(node,isLHS){node&&"Placeholder"===node.type&&"Expression"===node.expectedNode?node.expectedNode="Pattern":super.toAssignable(node,isLHS);}chStartsBindingIdentifier(ch,pos){if(super.chStartsBindingIdentifier(ch,pos))return  true;return 133===this.lookahead().type}verifyBreakContinue(node,isBreak){node.label&&"Placeholder"===node.label.type||super.verifyBreakContinue(node,isBreak);}parseExpressionStatement(node,expr){var _expr$extra;if("Placeholder"!==expr.type||null!=(_expr$extra=expr.extra)&&_expr$extra.parenthesized)return super.parseExpressionStatement(node,expr);if(this.match(14)){const stmt=node;return stmt.label=this.finishPlaceholder(expr,"Identifier"),this.next(),stmt.body=super.parseStatementOrSloppyAnnexBFunctionDeclaration(),this.finishNode(stmt,"LabeledStatement")}this.semicolon();const stmtPlaceholder=node;return stmtPlaceholder.name=expr.name,this.finishPlaceholder(stmtPlaceholder,"Statement")}parseBlock(allowDirectives,createNewLexicalScope,afterBlockParse){return this.parsePlaceholder("BlockStatement")||super.parseBlock(allowDirectives,createNewLexicalScope,afterBlockParse)}parseFunctionId(requireId){return this.parsePlaceholder("Identifier")||super.parseFunctionId(requireId)}parseClass(node,isStatement,optionalId){const type=isStatement?"ClassDeclaration":"ClassExpression";this.next();const oldStrict=this.state.strict,placeholder=this.parsePlaceholder("Identifier");if(placeholder){if(!(this.match(81)||this.match(133)||this.match(5))){if(optionalId||!isStatement)return node.id=null,node.body=this.finishPlaceholder(placeholder,"ClassBody"),this.finishNode(node,type);throw this.raise(PlaceholderErrors.ClassNameIsRequired,this.state.startLoc)}node.id=placeholder;}else this.parseClassId(node,isStatement,optionalId);return super.parseClassSuper(node),node.body=this.parsePlaceholder("ClassBody")||super.parseClassBody(!!node.superClass,oldStrict),this.finishNode(node,type)}parseExport(node,decorators){const placeholder=this.parsePlaceholder("Identifier");if(!placeholder)return super.parseExport(node,decorators);const node2=node;if(!this.isContextual(98)&&!this.match(12))return node2.specifiers=[],node2.source=null,node2.declaration=this.finishPlaceholder(placeholder,"Declaration"),this.finishNode(node2,"ExportNamedDeclaration");this.expectPlugin("exportDefaultFrom");const specifier=this.startNode();return specifier.exported=placeholder,node2.specifiers=[this.finishNode(specifier,"ExportDefaultSpecifier")],super.parseExport(node2,decorators)}isExportDefaultSpecifier(){if(this.match(65)){const next=this.nextTokenStart();if(this.isUnparsedContextual(next,"from")&&this.input.startsWith(tokenLabelName(133),this.nextTokenStartSince(next+4)))return  true}return super.isExportDefaultSpecifier()}maybeParseExportDefaultSpecifier(node,maybeDefaultIdentifier){var _specifiers;return !(null==(_specifiers=node.specifiers)||!_specifiers.length)||super.maybeParseExportDefaultSpecifier(node,maybeDefaultIdentifier)}checkExport(node){const{specifiers}=node;null!=specifiers&&specifiers.length&&(node.specifiers=specifiers.filter((node=>"Placeholder"===node.exported.type))),super.checkExport(node),node.specifiers=specifiers;}parseImport(node){const placeholder=this.parsePlaceholder("Identifier");if(!placeholder)return super.parseImport(node);if(node.specifiers=[],!this.isContextual(98)&&!this.match(12))return node.source=this.finishPlaceholder(placeholder,"StringLiteral"),this.semicolon(),this.finishNode(node,"ImportDeclaration");const specifier=this.startNodeAtNode(placeholder);if(specifier.local=placeholder,node.specifiers.push(this.finishNode(specifier,"ImportDefaultSpecifier")),this.eat(12)){this.maybeParseStarImportSpecifier(node)||this.parseNamedImportSpecifiers(node);}return this.expectContextual(98),node.source=this.parseImportSource(),this.semicolon(),this.finishNode(node,"ImportDeclaration")}parseImportSource(){return this.parsePlaceholder("StringLiteral")||super.parseImportSource()}assertNoSpace(){this.state.start>this.offsetToSourcePos(this.state.lastTokEndLoc.index)&&this.raise(PlaceholderErrors.UnexpectedSpace,this.state.lastTokEndLoc);}}},mixinPluginNames=Object.keys(mixinPlugins);class ExpressionParser extends LValParser{checkProto(prop,isRecord,protoRef,refExpressionErrors){if("SpreadElement"===prop.type||this.isObjectMethod(prop)||prop.computed||prop.shorthand)return;const key=prop.key;if("__proto__"===("Identifier"===key.type?key.name:key.value)){if(isRecord)return void this.raise(Errors.RecordNoProto,key);protoRef.used&&(refExpressionErrors?null===refExpressionErrors.doubleProtoLoc&&(refExpressionErrors.doubleProtoLoc=key.loc.start):this.raise(Errors.DuplicateProto,key)),protoRef.used=true;}}shouldExitDescending(expr,potentialArrowAt){return "ArrowFunctionExpression"===expr.type&&this.offsetToSourcePos(expr.start)===potentialArrowAt}getExpression(){this.enterInitialScopes(),this.nextToken();const expr=this.parseExpression();return this.match(140)||this.unexpected(),this.finalizeRemainingComments(),expr.comments=this.comments,expr.errors=this.state.errors,this.options.tokens&&(expr.tokens=this.tokens),expr}parseExpression(disallowIn,refExpressionErrors){return disallowIn?this.disallowInAnd((()=>this.parseExpressionBase(refExpressionErrors))):this.allowInAnd((()=>this.parseExpressionBase(refExpressionErrors)))}parseExpressionBase(refExpressionErrors){const startLoc=this.state.startLoc,expr=this.parseMaybeAssign(refExpressionErrors);if(this.match(12)){const node=this.startNodeAt(startLoc);for(node.expressions=[expr];this.eat(12);)node.expressions.push(this.parseMaybeAssign(refExpressionErrors));return this.toReferencedList(node.expressions),this.finishNode(node,"SequenceExpression")}return expr}parseMaybeAssignDisallowIn(refExpressionErrors,afterLeftParse){return this.disallowInAnd((()=>this.parseMaybeAssign(refExpressionErrors,afterLeftParse)))}parseMaybeAssignAllowIn(refExpressionErrors,afterLeftParse){return this.allowInAnd((()=>this.parseMaybeAssign(refExpressionErrors,afterLeftParse)))}setOptionalParametersError(refExpressionErrors,resultError){var _resultError$loc;refExpressionErrors.optionalParametersLoc=null!=(_resultError$loc=null==resultError?void 0:resultError.loc)?_resultError$loc:this.state.startLoc;}parseMaybeAssign(refExpressionErrors,afterLeftParse){const startLoc=this.state.startLoc;if(this.isContextual(108)&&this.prodParam.hasYield){let left=this.parseYield();return afterLeftParse&&(left=afterLeftParse.call(this,left,startLoc)),left}let ownExpressionErrors;refExpressionErrors?ownExpressionErrors=false:(refExpressionErrors=new ExpressionErrors,ownExpressionErrors=true);const{type}=this.state;(10===type||tokenIsIdentifier(type))&&(this.state.potentialArrowAt=this.state.start);let left=this.parseMaybeConditional(refExpressionErrors);if(afterLeftParse&&(left=afterLeftParse.call(this,left,startLoc)),(token=this.state.type)>=29&&token<=33){const node=this.startNodeAt(startLoc),operator=this.state.value;if(node.operator=operator,this.match(29)){this.toAssignable(left,true),node.left=left;const startIndex=startLoc.index;null!=refExpressionErrors.doubleProtoLoc&&refExpressionErrors.doubleProtoLoc.index>=startIndex&&(refExpressionErrors.doubleProtoLoc=null),null!=refExpressionErrors.shorthandAssignLoc&&refExpressionErrors.shorthandAssignLoc.index>=startIndex&&(refExpressionErrors.shorthandAssignLoc=null),null!=refExpressionErrors.privateKeyLoc&&refExpressionErrors.privateKeyLoc.index>=startIndex&&(this.checkDestructuringPrivate(refExpressionErrors),refExpressionErrors.privateKeyLoc=null);}else node.left=left;return this.next(),node.right=this.parseMaybeAssign(),this.checkLVal(left,this.finishNode(node,"AssignmentExpression")),node}var token;return ownExpressionErrors&&this.checkExpressionErrors(refExpressionErrors,true),left}parseMaybeConditional(refExpressionErrors){const startLoc=this.state.startLoc,potentialArrowAt=this.state.potentialArrowAt,expr=this.parseExprOps(refExpressionErrors);return this.shouldExitDescending(expr,potentialArrowAt)?expr:this.parseConditional(expr,startLoc,refExpressionErrors)}parseConditional(expr,startLoc,refExpressionErrors){if(this.eat(17)){const node=this.startNodeAt(startLoc);return node.test=expr,node.consequent=this.parseMaybeAssignAllowIn(),this.expect(14),node.alternate=this.parseMaybeAssign(),this.finishNode(node,"ConditionalExpression")}return expr}parseMaybeUnaryOrPrivate(refExpressionErrors){return this.match(139)?this.parsePrivateName():this.parseMaybeUnary(refExpressionErrors)}parseExprOps(refExpressionErrors){const startLoc=this.state.startLoc,potentialArrowAt=this.state.potentialArrowAt,expr=this.parseMaybeUnaryOrPrivate(refExpressionErrors);return this.shouldExitDescending(expr,potentialArrowAt)?expr:this.parseExprOp(expr,startLoc,-1)}parseExprOp(left,leftStartLoc,minPrec){if(this.isPrivateName(left)){const value=this.getPrivateNameSV(left);(minPrec>=tokenOperatorPrecedence(58)||!this.prodParam.hasIn||!this.match(58))&&this.raise(Errors.PrivateInExpectedIn,left,{identifierName:value}),this.classScope.usePrivateName(value,left.loc.start);}const op=this.state.type;if((token=op)>=39&&token<=59&&(this.prodParam.hasIn||!this.match(58))){let prec=tokenOperatorPrecedence(op);if(prec>minPrec){if(39===op){if(this.expectPlugin("pipelineOperator"),this.state.inFSharpPipelineDirectBody)return left;this.checkPipelineAtInfixOperator(left,leftStartLoc);}const node=this.startNodeAt(leftStartLoc);node.left=left,node.operator=this.state.value;const logical=41===op||42===op,coalesce=40===op;if(coalesce&&(prec=tokenOperatorPrecedence(42)),this.next(),39===op&&this.hasPlugin(["pipelineOperator",{proposal:"minimal"}])&&96===this.state.type&&this.prodParam.hasAwait)throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody,this.state.startLoc);node.right=this.parseExprOpRightExpr(op,prec);const finishedNode=this.finishNode(node,logical||coalesce?"LogicalExpression":"BinaryExpression"),nextOp=this.state.type;if(coalesce&&(41===nextOp||42===nextOp)||logical&&40===nextOp)throw this.raise(Errors.MixingCoalesceWithLogical,this.state.startLoc);return this.parseExprOp(finishedNode,leftStartLoc,minPrec)}}var token;return left}parseExprOpRightExpr(op,prec){const startLoc=this.state.startLoc;if(39===op)switch(this.getPluginOption("pipelineOperator","proposal")){case "hack":return this.withTopicBindingContext((()=>this.parseHackPipeBody()));case "smart":return this.withTopicBindingContext((()=>{if(this.prodParam.hasYield&&this.isContextual(108))throw this.raise(Errors.PipeBodyIsTighter,this.state.startLoc);return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(op,prec),startLoc)}));case "fsharp":return this.withSoloAwaitPermittingContext((()=>this.parseFSharpPipelineBody(prec)))}return this.parseExprOpBaseRightExpr(op,prec)}parseExprOpBaseRightExpr(op,prec){const startLoc=this.state.startLoc;return this.parseExprOp(this.parseMaybeUnaryOrPrivate(),startLoc,57===op?prec-1:prec)}parseHackPipeBody(){var _body$extra;const{startLoc}=this.state,body=this.parseMaybeAssign();return !UnparenthesizedPipeBodyDescriptions.has(body.type)||null!=(_body$extra=body.extra)&&_body$extra.parenthesized||this.raise(Errors.PipeUnparenthesizedBody,startLoc,{type:body.type}),this.topicReferenceWasUsedInCurrentContext()||this.raise(Errors.PipeTopicUnused,startLoc),body}checkExponentialAfterUnary(node){this.match(57)&&this.raise(Errors.UnexpectedTokenUnaryExponentiation,node.argument);}parseMaybeUnary(refExpressionErrors,sawUnary){const startLoc=this.state.startLoc,isAwait=this.isContextual(96);if(isAwait&&this.recordAwaitIfAllowed()){this.next();const expr=this.parseAwait(startLoc);return sawUnary||this.checkExponentialAfterUnary(expr),expr}const update=this.match(34),node=this.startNode();if(token=this.state.type,tokenPrefixes[token]){node.operator=this.state.value,node.prefix=true,this.match(72)&&this.expectPlugin("throwExpressions");const isDelete=this.match(89);if(this.next(),node.argument=this.parseMaybeUnary(null,true),this.checkExpressionErrors(refExpressionErrors,true),this.state.strict&&isDelete){const arg=node.argument;"Identifier"===arg.type?this.raise(Errors.StrictDelete,node):this.hasPropertyAsPrivateName(arg)&&this.raise(Errors.DeletePrivateField,node);}if(!update)return sawUnary||this.checkExponentialAfterUnary(node),this.finishNode(node,"UnaryExpression")}var token;const expr=this.parseUpdate(node,update,refExpressionErrors);if(isAwait){const{type}=this.state;if((this.hasPlugin("v8intrinsic")?tokenCanStartExpression(type):tokenCanStartExpression(type)&&!this.match(54))&&!this.isAmbiguousAwait())return this.raiseOverwrite(Errors.AwaitNotInAsyncContext,startLoc),this.parseAwait(startLoc)}return expr}parseUpdate(node,update,refExpressionErrors){if(update){const updateExpressionNode=node;return this.checkLVal(updateExpressionNode.argument,this.finishNode(updateExpressionNode,"UpdateExpression")),node}const startLoc=this.state.startLoc;let expr=this.parseExprSubscripts(refExpressionErrors);if(this.checkExpressionErrors(refExpressionErrors,false))return expr;for(;34===this.state.type&&!this.canInsertSemicolon();){const node=this.startNodeAt(startLoc);node.operator=this.state.value,node.prefix=false,node.argument=expr,this.next(),this.checkLVal(expr,expr=this.finishNode(node,"UpdateExpression"));}return expr}parseExprSubscripts(refExpressionErrors){const startLoc=this.state.startLoc,potentialArrowAt=this.state.potentialArrowAt,expr=this.parseExprAtom(refExpressionErrors);return this.shouldExitDescending(expr,potentialArrowAt)?expr:this.parseSubscripts(expr,startLoc)}parseSubscripts(base,startLoc,noCalls){const state={optionalChainMember:false,maybeAsyncArrow:this.atPossibleAsyncArrow(base),stop:false};do{base=this.parseSubscript(base,startLoc,noCalls,state),state.maybeAsyncArrow=false;}while(!state.stop);return base}parseSubscript(base,startLoc,noCalls,state){const{type}=this.state;if(!noCalls&&15===type)return this.parseBind(base,startLoc,noCalls,state);if(tokenIsTemplate(type))return this.parseTaggedTemplateExpression(base,startLoc,state);let optional=false;if(18===type){if(noCalls&&(this.raise(Errors.OptionalChainingNoNew,this.state.startLoc),40===this.lookaheadCharCode()))return state.stop=true,base;state.optionalChainMember=optional=true,this.next();}if(!noCalls&&this.match(10))return this.parseCoverCallAndAsyncArrowHead(base,startLoc,state,optional);{const computed=this.eat(0);return computed||optional||this.eat(16)?this.parseMember(base,startLoc,state,computed,optional):(state.stop=true,base)}}parseMember(base,startLoc,state,computed,optional){const node=this.startNodeAt(startLoc);return node.object=base,node.computed=computed,computed?(node.property=this.parseExpression(),this.expect(3)):this.match(139)?("Super"===base.type&&this.raise(Errors.SuperPrivateField,startLoc),this.classScope.usePrivateName(this.state.value,this.state.startLoc),node.property=this.parsePrivateName()):node.property=this.parseIdentifier(true),state.optionalChainMember?(node.optional=optional,this.finishNode(node,"OptionalMemberExpression")):this.finishNode(node,"MemberExpression")}parseBind(base,startLoc,noCalls,state){const node=this.startNodeAt(startLoc);return node.object=base,this.next(),node.callee=this.parseNoCallExpr(),state.stop=true,this.parseSubscripts(this.finishNode(node,"BindExpression"),startLoc,noCalls)}parseCoverCallAndAsyncArrowHead(base,startLoc,state,optional){const oldMaybeInArrowParameters=this.state.maybeInArrowParameters;let refExpressionErrors=null;this.state.maybeInArrowParameters=true,this.next();const node=this.startNodeAt(startLoc);node.callee=base;const{maybeAsyncArrow,optionalChainMember}=state;maybeAsyncArrow&&(this.expressionScope.enter(new ArrowHeadParsingScope(2)),refExpressionErrors=new ExpressionErrors),optionalChainMember&&(node.optional=optional),node.arguments=optional?this.parseCallExpressionArguments(11):this.parseCallExpressionArguments(11,"Super"!==base.type,node,refExpressionErrors);let finishedNode=this.finishCallExpression(node,optionalChainMember);return maybeAsyncArrow&&this.shouldParseAsyncArrow()&&!optional?(state.stop=true,this.checkDestructuringPrivate(refExpressionErrors),this.expressionScope.validateAsPattern(),this.expressionScope.exit(),finishedNode=this.parseAsyncArrowFromCallExpression(this.startNodeAt(startLoc),finishedNode)):(maybeAsyncArrow&&(this.checkExpressionErrors(refExpressionErrors,true),this.expressionScope.exit()),this.toReferencedArguments(finishedNode)),this.state.maybeInArrowParameters=oldMaybeInArrowParameters,finishedNode}toReferencedArguments(node,isParenthesizedExpr){this.toReferencedListDeep(node.arguments,isParenthesizedExpr);}parseTaggedTemplateExpression(base,startLoc,state){const node=this.startNodeAt(startLoc);return node.tag=base,node.quasi=this.parseTemplate(true),state.optionalChainMember&&this.raise(Errors.OptionalChainingNoTemplate,startLoc),this.finishNode(node,"TaggedTemplateExpression")}atPossibleAsyncArrow(base){return "Identifier"===base.type&&"async"===base.name&&this.state.lastTokEndLoc.index===base.end&&!this.canInsertSemicolon()&&base.end-base.start==5&&this.offsetToSourcePos(base.start)===this.state.potentialArrowAt}finishCallExpression(node,optional){if("Import"===node.callee.type)if(0===node.arguments.length||node.arguments.length>2)this.raise(Errors.ImportCallArity,node);else for(const arg of node.arguments)"SpreadElement"===arg.type&&this.raise(Errors.ImportCallSpreadArgument,arg);return this.finishNode(node,optional?"OptionalCallExpression":"CallExpression")}parseCallExpressionArguments(close,allowPlaceholder,nodeForExtra,refExpressionErrors){const elts=[];let first=true;const oldInFSharpPipelineDirectBody=this.state.inFSharpPipelineDirectBody;for(this.state.inFSharpPipelineDirectBody=false;!this.eat(close);){if(first)first=false;else if(this.expect(12),this.match(close)){nodeForExtra&&this.addTrailingCommaExtraToNode(nodeForExtra),this.next();break}elts.push(this.parseExprListItem(false,refExpressionErrors,allowPlaceholder));}return this.state.inFSharpPipelineDirectBody=oldInFSharpPipelineDirectBody,elts}shouldParseAsyncArrow(){return this.match(19)&&!this.canInsertSemicolon()}parseAsyncArrowFromCallExpression(node,call){var _call$extra;return this.resetPreviousNodeTrailingComments(call),this.expect(19),this.parseArrowExpression(node,call.arguments,true,null==(_call$extra=call.extra)?void 0:_call$extra.trailingCommaLoc),call.innerComments&&setInnerComments(node,call.innerComments),call.callee.trailingComments&&setInnerComments(node,call.callee.trailingComments),node}parseNoCallExpr(){const startLoc=this.state.startLoc;return this.parseSubscripts(this.parseExprAtom(),startLoc,true)}parseExprAtom(refExpressionErrors){let node,decorators=null;const{type}=this.state;switch(type){case 79:return this.parseSuper();case 83:return node=this.startNode(),this.next(),this.match(16)?this.parseImportMetaProperty(node):this.match(10)?this.options.createImportExpressions?this.parseImportCall(node):this.finishNode(node,"Import"):(this.raise(Errors.UnsupportedImport,this.state.lastTokStartLoc),this.finishNode(node,"Import"));case 78:return node=this.startNode(),this.next(),this.finishNode(node,"ThisExpression");case 90:return this.parseDo(this.startNode(),false);case 56:case 31:return this.readRegexp(),this.parseRegExpLiteral(this.state.value);case 135:return this.parseNumericLiteral(this.state.value);case 136:return this.parseBigIntLiteral(this.state.value);case 134:return this.parseStringLiteral(this.state.value);case 84:return this.parseNullLiteral();case 85:return this.parseBooleanLiteral(true);case 86:return this.parseBooleanLiteral(false);case 10:{const canBeArrow=this.state.potentialArrowAt===this.state.start;return this.parseParenAndDistinguishExpression(canBeArrow)}case 2:case 1:return this.parseArrayLike(2===this.state.type?4:3,false,true);case 0:return this.parseArrayLike(3,true,false,refExpressionErrors);case 6:case 7:return this.parseObjectLike(6===this.state.type?9:8,false,true);case 5:return this.parseObjectLike(8,false,false,refExpressionErrors);case 68:return this.parseFunctionOrFunctionSent();case 26:decorators=this.parseDecorators();case 80:return this.parseClass(this.maybeTakeDecorators(decorators,this.startNode()),false);case 77:return this.parseNewOrNewTarget();case 25:case 24:return this.parseTemplate(false);case 15:{node=this.startNode(),this.next(),node.object=null;const callee=node.callee=this.parseNoCallExpr();if("MemberExpression"===callee.type)return this.finishNode(node,"BindExpression");throw this.raise(Errors.UnsupportedBind,callee)}case 139:return this.raise(Errors.PrivateInExpectedIn,this.state.startLoc,{identifierName:this.state.value}),this.parsePrivateName();case 33:return this.parseTopicReferenceThenEqualsSign(54,"%");case 32:return this.parseTopicReferenceThenEqualsSign(44,"^");case 37:case 38:return this.parseTopicReference("hack");case 44:case 54:case 27:{const pipeProposal=this.getPluginOption("pipelineOperator","proposal");if(pipeProposal)return this.parseTopicReference(pipeProposal);this.unexpected();break}case 47:{const lookaheadCh=this.input.codePointAt(this.nextTokenStart());isIdentifierStart(lookaheadCh)||62===lookaheadCh?this.expectOnePlugin(["jsx","flow","typescript"]):this.unexpected();break}default:if(137===type)return this.parseDecimalLiteral(this.state.value);if(tokenIsIdentifier(type)){if(this.isContextual(127)&&123===this.lookaheadInLineCharCode())return this.parseModuleExpression();const canBeArrow=this.state.potentialArrowAt===this.state.start,containsEsc=this.state.containsEsc,id=this.parseIdentifier();if(!containsEsc&&"async"===id.name&&!this.canInsertSemicolon()){const{type}=this.state;if(68===type)return this.resetPreviousNodeTrailingComments(id),this.next(),this.parseAsyncFunctionExpression(this.startNodeAtNode(id));if(tokenIsIdentifier(type))return 61===this.lookaheadCharCode()?this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id)):id;if(90===type)return this.resetPreviousNodeTrailingComments(id),this.parseDo(this.startNodeAtNode(id),true)}return canBeArrow&&this.match(19)&&!this.canInsertSemicolon()?(this.next(),this.parseArrowExpression(this.startNodeAtNode(id),[id],false)):id}this.unexpected();}}parseTopicReferenceThenEqualsSign(topicTokenType,topicTokenValue){const pipeProposal=this.getPluginOption("pipelineOperator","proposal");if(pipeProposal)return this.state.type=topicTokenType,this.state.value=topicTokenValue,this.state.pos--,this.state.end--,this.state.endLoc=createPositionWithColumnOffset(this.state.endLoc,-1),this.parseTopicReference(pipeProposal);this.unexpected();}parseTopicReference(pipeProposal){const node=this.startNode(),startLoc=this.state.startLoc,tokenType=this.state.type;return this.next(),this.finishTopicReference(node,startLoc,pipeProposal,tokenType)}finishTopicReference(node,startLoc,pipeProposal,tokenType){if(this.testTopicReferenceConfiguration(pipeProposal,startLoc,tokenType)){const nodeType="smart"===pipeProposal?"PipelinePrimaryTopicReference":"TopicReference";return this.topicReferenceIsAllowedInCurrentContext()||this.raise("smart"===pipeProposal?Errors.PrimaryTopicNotAllowed:Errors.PipeTopicUnbound,startLoc),this.registerTopicReference(),this.finishNode(node,nodeType)}throw this.raise(Errors.PipeTopicUnconfiguredToken,startLoc,{token:tokenLabelName(tokenType)})}testTopicReferenceConfiguration(pipeProposal,startLoc,tokenType){switch(pipeProposal){case "hack":return this.hasPlugin(["pipelineOperator",{topicToken:tokenLabelName(tokenType)}]);case "smart":return 27===tokenType;default:throw this.raise(Errors.PipeTopicRequiresHackPipes,startLoc)}}parseAsyncArrowUnaryFunction(node){this.prodParam.enter(functionFlags(true,this.prodParam.hasYield));const params=[this.parseIdentifier()];return this.prodParam.exit(),this.hasPrecedingLineBreak()&&this.raise(Errors.LineTerminatorBeforeArrow,this.state.curPosition()),this.expect(19),this.parseArrowExpression(node,params,true)}parseDo(node,isAsync){this.expectPlugin("doExpressions"),isAsync&&this.expectPlugin("asyncDoExpressions"),node.async=isAsync,this.next();const oldLabels=this.state.labels;return this.state.labels=[],isAsync?(this.prodParam.enter(2),node.body=this.parseBlock(),this.prodParam.exit()):node.body=this.parseBlock(),this.state.labels=oldLabels,this.finishNode(node,"DoExpression")}parseSuper(){const node=this.startNode();return this.next(),!this.match(10)||this.scope.allowDirectSuper||this.options.allowSuperOutsideMethod?this.scope.allowSuper||this.options.allowSuperOutsideMethod||this.raise(Errors.UnexpectedSuper,node):this.raise(Errors.SuperNotAllowed,node),this.match(10)||this.match(0)||this.match(16)||this.raise(Errors.UnsupportedSuper,node),this.finishNode(node,"Super")}parsePrivateName(){const node=this.startNode(),id=this.startNodeAt(createPositionWithColumnOffset(this.state.startLoc,1)),name=this.state.value;return this.next(),node.id=this.createIdentifier(id,name),this.finishNode(node,"PrivateName")}parseFunctionOrFunctionSent(){const node=this.startNode();if(this.next(),this.prodParam.hasYield&&this.match(16)){const meta=this.createIdentifier(this.startNodeAtNode(node),"function");return this.next(),this.match(103)?this.expectPlugin("functionSent"):this.hasPlugin("functionSent")||this.unexpected(),this.parseMetaProperty(node,meta,"sent")}return this.parseFunction(node)}parseMetaProperty(node,meta,propertyName){node.meta=meta;const containsEsc=this.state.containsEsc;return node.property=this.parseIdentifier(true),(node.property.name!==propertyName||containsEsc)&&this.raise(Errors.UnsupportedMetaProperty,node.property,{target:meta.name,onlyValidPropertyName:propertyName}),this.finishNode(node,"MetaProperty")}parseImportMetaProperty(node){const id=this.createIdentifier(this.startNodeAtNode(node),"import");if(this.next(),this.isContextual(101))this.inModule||this.raise(Errors.ImportMetaOutsideModule,id),this.sawUnambiguousESM=true;else if(this.isContextual(105)||this.isContextual(97)){const isSource=this.isContextual(105);if(isSource||this.unexpected(),this.expectPlugin(isSource?"sourcePhaseImports":"deferredImportEvaluation"),!this.options.createImportExpressions)throw this.raise(Errors.DynamicImportPhaseRequiresImportExpressions,this.state.startLoc,{phase:this.state.value});return this.next(),node.phase=isSource?"source":"defer",this.parseImportCall(node)}return this.parseMetaProperty(node,id,"meta")}parseLiteralAtNode(value,type,node){return this.addExtra(node,"rawValue",value),this.addExtra(node,"raw",this.input.slice(this.offsetToSourcePos(node.start),this.state.end)),node.value=value,this.next(),this.finishNode(node,type)}parseLiteral(value,type){const node=this.startNode();return this.parseLiteralAtNode(value,type,node)}parseStringLiteral(value){return this.parseLiteral(value,"StringLiteral")}parseNumericLiteral(value){return this.parseLiteral(value,"NumericLiteral")}parseBigIntLiteral(value){return this.parseLiteral(value,"BigIntLiteral")}parseDecimalLiteral(value){return this.parseLiteral(value,"DecimalLiteral")}parseRegExpLiteral(value){const node=this.startNode();return this.addExtra(node,"raw",this.input.slice(this.offsetToSourcePos(node.start),this.state.end)),node.pattern=value.pattern,node.flags=value.flags,this.next(),this.finishNode(node,"RegExpLiteral")}parseBooleanLiteral(value){const node=this.startNode();return node.value=value,this.next(),this.finishNode(node,"BooleanLiteral")}parseNullLiteral(){const node=this.startNode();return this.next(),this.finishNode(node,"NullLiteral")}parseParenAndDistinguishExpression(canBeArrow){const startLoc=this.state.startLoc;let val;this.next(),this.expressionScope.enter(new ArrowHeadParsingScope(1));const oldMaybeInArrowParameters=this.state.maybeInArrowParameters,oldInFSharpPipelineDirectBody=this.state.inFSharpPipelineDirectBody;this.state.maybeInArrowParameters=true,this.state.inFSharpPipelineDirectBody=false;const innerStartLoc=this.state.startLoc,exprList=[],refExpressionErrors=new ExpressionErrors;let spreadStartLoc,optionalCommaStartLoc,first=true;for(;!this.match(11);){if(first)first=false;else if(this.expect(12,null===refExpressionErrors.optionalParametersLoc?null:refExpressionErrors.optionalParametersLoc),this.match(11)){optionalCommaStartLoc=this.state.startLoc;break}if(this.match(21)){const spreadNodeStartLoc=this.state.startLoc;if(spreadStartLoc=this.state.startLoc,exprList.push(this.parseParenItem(this.parseRestBinding(),spreadNodeStartLoc)),!this.checkCommaAfterRest(41))break}else exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors,this.parseParenItem));}const innerEndLoc=this.state.lastTokEndLoc;this.expect(11),this.state.maybeInArrowParameters=oldMaybeInArrowParameters,this.state.inFSharpPipelineDirectBody=oldInFSharpPipelineDirectBody;let arrowNode=this.startNodeAt(startLoc);return canBeArrow&&this.shouldParseArrow(exprList)&&(arrowNode=this.parseArrow(arrowNode))?(this.checkDestructuringPrivate(refExpressionErrors),this.expressionScope.validateAsPattern(),this.expressionScope.exit(),this.parseArrowExpression(arrowNode,exprList,false),arrowNode):(this.expressionScope.exit(),exprList.length||this.unexpected(this.state.lastTokStartLoc),optionalCommaStartLoc&&this.unexpected(optionalCommaStartLoc),spreadStartLoc&&this.unexpected(spreadStartLoc),this.checkExpressionErrors(refExpressionErrors,true),this.toReferencedListDeep(exprList,true),exprList.length>1?(val=this.startNodeAt(innerStartLoc),val.expressions=exprList,this.finishNode(val,"SequenceExpression"),this.resetEndLocation(val,innerEndLoc)):val=exprList[0],this.wrapParenthesis(startLoc,val))}wrapParenthesis(startLoc,expression){if(!this.options.createParenthesizedExpressions)return this.addExtra(expression,"parenthesized",true),this.addExtra(expression,"parenStart",startLoc.index),this.takeSurroundingComments(expression,startLoc.index,this.state.lastTokEndLoc.index),expression;const parenExpression=this.startNodeAt(startLoc);return parenExpression.expression=expression,this.finishNode(parenExpression,"ParenthesizedExpression")}shouldParseArrow(params){return !this.canInsertSemicolon()}parseArrow(node){if(this.eat(19))return node}parseParenItem(node,startLoc){return node}parseNewOrNewTarget(){const node=this.startNode();if(this.next(),this.match(16)){const meta=this.createIdentifier(this.startNodeAtNode(node),"new");this.next();const metaProp=this.parseMetaProperty(node,meta,"target");return this.scope.inNonArrowFunction||this.scope.inClass||this.options.allowNewTargetOutsideFunction||this.raise(Errors.UnexpectedNewTarget,metaProp),metaProp}return this.parseNew(node)}parseNew(node){if(this.parseNewCallee(node),this.eat(10)){const args=this.parseExprList(11);this.toReferencedList(args),node.arguments=args;}else node.arguments=[];return this.finishNode(node,"NewExpression")}parseNewCallee(node){const isImport=this.match(83),callee=this.parseNoCallExpr();node.callee=callee,!isImport||"Import"!==callee.type&&"ImportExpression"!==callee.type||this.raise(Errors.ImportCallNotNewExpression,callee);}parseTemplateElement(isTagged){const{start,startLoc,end,value}=this.state,elemStart=start+1,elem=this.startNodeAt(createPositionWithColumnOffset(startLoc,1));null===value&&(isTagged||this.raise(Errors.InvalidEscapeSequenceTemplate,createPositionWithColumnOffset(this.state.firstInvalidTemplateEscapePos,1)));const isTail=this.match(24),endOffset=isTail?-1:-2,elemEnd=end+endOffset;elem.value={raw:this.input.slice(elemStart,elemEnd).replace(/\r\n?/g,"\n"),cooked:null===value?null:value.slice(1,endOffset)},elem.tail=isTail,this.next();const finishedNode=this.finishNode(elem,"TemplateElement");return this.resetEndLocation(finishedNode,createPositionWithColumnOffset(this.state.lastTokEndLoc,endOffset)),finishedNode}parseTemplate(isTagged){const node=this.startNode();let curElt=this.parseTemplateElement(isTagged);const quasis=[curElt],substitutions=[];for(;!curElt.tail;)substitutions.push(this.parseTemplateSubstitution()),this.readTemplateContinuation(),quasis.push(curElt=this.parseTemplateElement(isTagged));return node.expressions=substitutions,node.quasis=quasis,this.finishNode(node,"TemplateLiteral")}parseTemplateSubstitution(){return this.parseExpression()}parseObjectLike(close,isPattern,isRecord,refExpressionErrors){isRecord&&this.expectPlugin("recordAndTuple");const oldInFSharpPipelineDirectBody=this.state.inFSharpPipelineDirectBody;this.state.inFSharpPipelineDirectBody=false;const propHash=Object.create(null);let first=true;const node=this.startNode();for(node.properties=[],this.next();!this.match(close);){if(first)first=false;else if(this.expect(12),this.match(close)){this.addTrailingCommaExtraToNode(node);break}let prop;isPattern?prop=this.parseBindingProperty():(prop=this.parsePropertyDefinition(refExpressionErrors),this.checkProto(prop,isRecord,propHash,refExpressionErrors)),isRecord&&!this.isObjectProperty(prop)&&"SpreadElement"!==prop.type&&this.raise(Errors.InvalidRecordProperty,prop),prop.shorthand&&this.addExtra(prop,"shorthand",true),node.properties.push(prop);}this.next(),this.state.inFSharpPipelineDirectBody=oldInFSharpPipelineDirectBody;let type="ObjectExpression";return isPattern?type="ObjectPattern":isRecord&&(type="RecordExpression"),this.finishNode(node,type)}addTrailingCommaExtraToNode(node){this.addExtra(node,"trailingComma",this.state.lastTokStartLoc.index),this.addExtra(node,"trailingCommaLoc",this.state.lastTokStartLoc,false);}maybeAsyncOrAccessorProp(prop){return !prop.computed&&"Identifier"===prop.key.type&&(this.isLiteralPropertyName()||this.match(0)||this.match(55))}parsePropertyDefinition(refExpressionErrors){let decorators=[];if(this.match(26))for(this.hasPlugin("decorators")&&this.raise(Errors.UnsupportedPropertyDecorator,this.state.startLoc);this.match(26);)decorators.push(this.parseDecorator());const prop=this.startNode();let startLoc,isAsync=false,isAccessor=false;if(this.match(21))return decorators.length&&this.unexpected(),this.parseSpread();decorators.length&&(prop.decorators=decorators,decorators=[]),prop.method=false,refExpressionErrors&&(startLoc=this.state.startLoc);let isGenerator=this.eat(55);this.parsePropertyNamePrefixOperator(prop);const containsEsc=this.state.containsEsc;if(this.parsePropertyName(prop,refExpressionErrors),!isGenerator&&!containsEsc&&this.maybeAsyncOrAccessorProp(prop)){const{key}=prop,keyName=key.name;"async"!==keyName||this.hasPrecedingLineBreak()||(isAsync=true,this.resetPreviousNodeTrailingComments(key),isGenerator=this.eat(55),this.parsePropertyName(prop)),"get"!==keyName&&"set"!==keyName||(isAccessor=true,this.resetPreviousNodeTrailingComments(key),prop.kind=keyName,this.match(55)&&(isGenerator=true,this.raise(Errors.AccessorIsGenerator,this.state.curPosition(),{kind:keyName}),this.next()),this.parsePropertyName(prop));}return this.parseObjPropValue(prop,startLoc,isGenerator,isAsync,false,isAccessor,refExpressionErrors)}getGetterSetterExpectedParamCount(method){return "get"===method.kind?0:1}getObjectOrClassMethodParams(method){return method.params}checkGetterSetterParams(method){var _params;const paramCount=this.getGetterSetterExpectedParamCount(method),params=this.getObjectOrClassMethodParams(method);params.length!==paramCount&&this.raise("get"===method.kind?Errors.BadGetterArity:Errors.BadSetterArity,method),"set"===method.kind&&"RestElement"===(null==(_params=params[params.length-1])?void 0:_params.type)&&this.raise(Errors.BadSetterRestParameter,method);}parseObjectMethod(prop,isGenerator,isAsync,isPattern,isAccessor){if(isAccessor){const finishedProp=this.parseMethod(prop,isGenerator,false,false,false,"ObjectMethod");return this.checkGetterSetterParams(finishedProp),finishedProp}if(isAsync||isGenerator||this.match(10))return isPattern&&this.unexpected(),prop.kind="method",prop.method=true,this.parseMethod(prop,isGenerator,isAsync,false,false,"ObjectMethod")}parseObjectProperty(prop,startLoc,isPattern,refExpressionErrors){if(prop.shorthand=false,this.eat(14))return prop.value=isPattern?this.parseMaybeDefault(this.state.startLoc):this.parseMaybeAssignAllowIn(refExpressionErrors),this.finishNode(prop,"ObjectProperty");if(!prop.computed&&"Identifier"===prop.key.type){if(this.checkReservedWord(prop.key.name,prop.key.loc.start,true,false),isPattern)prop.value=this.parseMaybeDefault(startLoc,cloneIdentifier(prop.key));else if(this.match(29)){const shorthandAssignLoc=this.state.startLoc;null!=refExpressionErrors?null===refExpressionErrors.shorthandAssignLoc&&(refExpressionErrors.shorthandAssignLoc=shorthandAssignLoc):this.raise(Errors.InvalidCoverInitializedName,shorthandAssignLoc),prop.value=this.parseMaybeDefault(startLoc,cloneIdentifier(prop.key));}else prop.value=cloneIdentifier(prop.key);return prop.shorthand=true,this.finishNode(prop,"ObjectProperty")}}parseObjPropValue(prop,startLoc,isGenerator,isAsync,isPattern,isAccessor,refExpressionErrors){const node=this.parseObjectMethod(prop,isGenerator,isAsync,isPattern,isAccessor)||this.parseObjectProperty(prop,startLoc,isPattern,refExpressionErrors);return node||this.unexpected(),node}parsePropertyName(prop,refExpressionErrors){if(this.eat(0))prop.computed=true,prop.key=this.parseMaybeAssignAllowIn(),this.expect(3);else {const{type,value}=this.state;let key;if(tokenIsKeywordOrIdentifier(type))key=this.parseIdentifier(true);else switch(type){case 135:key=this.parseNumericLiteral(value);break;case 134:key=this.parseStringLiteral(value);break;case 136:key=this.parseBigIntLiteral(value);break;case 139:{const privateKeyLoc=this.state.startLoc;null!=refExpressionErrors?null===refExpressionErrors.privateKeyLoc&&(refExpressionErrors.privateKeyLoc=privateKeyLoc):this.raise(Errors.UnexpectedPrivateField,privateKeyLoc),key=this.parsePrivateName();break}default:if(137===type){key=this.parseDecimalLiteral(value);break}this.unexpected();}prop.key=key,139!==type&&(prop.computed=false);}}initFunction(node,isAsync){node.id=null,node.generator=false,node.async=isAsync;}parseMethod(node,isGenerator,isAsync,isConstructor,allowDirectSuper,type,inClassScope=false){this.initFunction(node,isAsync),node.generator=isGenerator,this.scope.enter(18|(inClassScope?64:0)|(allowDirectSuper?32:0)),this.prodParam.enter(functionFlags(isAsync,node.generator)),this.parseFunctionParams(node,isConstructor);const finishedNode=this.parseFunctionBodyAndFinish(node,type,true);return this.prodParam.exit(),this.scope.exit(),finishedNode}parseArrayLike(close,canBePattern,isTuple,refExpressionErrors){isTuple&&this.expectPlugin("recordAndTuple");const oldInFSharpPipelineDirectBody=this.state.inFSharpPipelineDirectBody;this.state.inFSharpPipelineDirectBody=false;const node=this.startNode();return this.next(),node.elements=this.parseExprList(close,!isTuple,refExpressionErrors,node),this.state.inFSharpPipelineDirectBody=oldInFSharpPipelineDirectBody,this.finishNode(node,isTuple?"TupleExpression":"ArrayExpression")}parseArrowExpression(node,params,isAsync,trailingCommaLoc){this.scope.enter(6);let flags=functionFlags(isAsync,false);!this.match(5)&&this.prodParam.hasIn&&(flags|=8),this.prodParam.enter(flags),this.initFunction(node,isAsync);const oldMaybeInArrowParameters=this.state.maybeInArrowParameters;return params&&(this.state.maybeInArrowParameters=true,this.setArrowFunctionParameters(node,params,trailingCommaLoc)),this.state.maybeInArrowParameters=false,this.parseFunctionBody(node,true),this.prodParam.exit(),this.scope.exit(),this.state.maybeInArrowParameters=oldMaybeInArrowParameters,this.finishNode(node,"ArrowFunctionExpression")}setArrowFunctionParameters(node,params,trailingCommaLoc){this.toAssignableList(params,trailingCommaLoc,false),node.params=params;}parseFunctionBodyAndFinish(node,type,isMethod=false){return this.parseFunctionBody(node,false,isMethod),this.finishNode(node,type)}parseFunctionBody(node,allowExpression,isMethod=false){const isExpression=allowExpression&&!this.match(5);if(this.expressionScope.enter(newExpressionScope()),isExpression)node.body=this.parseMaybeAssign(),this.checkParams(node,false,allowExpression,false);else {const oldStrict=this.state.strict,oldLabels=this.state.labels;this.state.labels=[],this.prodParam.enter(4|this.prodParam.currentFlags()),node.body=this.parseBlock(true,false,(hasStrictModeDirective=>{const nonSimple=!this.isSimpleParamList(node.params);hasStrictModeDirective&&nonSimple&&this.raise(Errors.IllegalLanguageModeDirective,"method"!==node.kind&&"constructor"!==node.kind||!node.key?node:node.key.loc.end);const strictModeChanged=!oldStrict&&this.state.strict;this.checkParams(node,!(this.state.strict||allowExpression||isMethod||nonSimple),allowExpression,strictModeChanged),this.state.strict&&node.id&&this.checkIdentifier(node.id,65,strictModeChanged);})),this.prodParam.exit(),this.state.labels=oldLabels;}this.expressionScope.exit();}isSimpleParameter(node){return "Identifier"===node.type}isSimpleParamList(params){for(let i=0,len=params.length;i<len;i++)if(!this.isSimpleParameter(params[i]))return  false;return  true}checkParams(node,allowDuplicates,isArrowFunction,strictModeChanged=true){const checkClashes=!allowDuplicates&&new Set,formalParameters={type:"FormalParameters"};for(const param of node.params)this.checkLVal(param,formalParameters,5,checkClashes,strictModeChanged);}parseExprList(close,allowEmpty,refExpressionErrors,nodeForExtra){const elts=[];let first=true;for(;!this.eat(close);){if(first)first=false;else if(this.expect(12),this.match(close)){nodeForExtra&&this.addTrailingCommaExtraToNode(nodeForExtra),this.next();break}elts.push(this.parseExprListItem(allowEmpty,refExpressionErrors));}return elts}parseExprListItem(allowEmpty,refExpressionErrors,allowPlaceholder){let elt;if(this.match(12))allowEmpty||this.raise(Errors.UnexpectedToken,this.state.curPosition(),{unexpected:","}),elt=null;else if(this.match(21)){const spreadNodeStartLoc=this.state.startLoc;elt=this.parseParenItem(this.parseSpread(refExpressionErrors),spreadNodeStartLoc);}else if(this.match(17)){this.expectPlugin("partialApplication"),allowPlaceholder||this.raise(Errors.UnexpectedArgumentPlaceholder,this.state.startLoc);const node=this.startNode();this.next(),elt=this.finishNode(node,"ArgumentPlaceholder");}else elt=this.parseMaybeAssignAllowIn(refExpressionErrors,this.parseParenItem);return elt}parseIdentifier(liberal){const node=this.startNode(),name=this.parseIdentifierName(liberal);return this.createIdentifier(node,name)}createIdentifier(node,name){return node.name=name,node.loc.identifierName=name,this.finishNode(node,"Identifier")}parseIdentifierName(liberal){let name;const{startLoc,type}=this.state;tokenIsKeywordOrIdentifier(type)?name=this.state.value:this.unexpected();const tokenIsKeyword=type<=92;return liberal?tokenIsKeyword&&this.replaceToken(132):this.checkReservedWord(name,startLoc,tokenIsKeyword,false),this.next(),name}checkReservedWord(word,startLoc,checkKeywords,isBinding){if(word.length>10)return;if(!function(word){return reservedWordLikeSet.has(word)}(word))return;if(checkKeywords&&function(word){return keywords.has(word)}(word))return void this.raise(Errors.UnexpectedKeyword,startLoc,{keyword:word});if((this.state.strict?isBinding?isStrictBindReservedWord:isStrictReservedWord:isReservedWord)(word,this.inModule))this.raise(Errors.UnexpectedReservedWord,startLoc,{reservedWord:word});else if("yield"===word){if(this.prodParam.hasYield)return void this.raise(Errors.YieldBindingIdentifier,startLoc)}else if("await"===word){if(this.prodParam.hasAwait)return void this.raise(Errors.AwaitBindingIdentifier,startLoc);if(this.scope.inStaticBlock)return void this.raise(Errors.AwaitBindingIdentifierInStaticBlock,startLoc);this.expressionScope.recordAsyncArrowParametersError(startLoc);}else if("arguments"===word&&this.scope.inClassAndNotInNonArrowFunction)return void this.raise(Errors.ArgumentsInClass,startLoc)}recordAwaitIfAllowed(){const isAwaitAllowed=this.prodParam.hasAwait||this.options.allowAwaitOutsideFunction&&!this.scope.inFunction;return isAwaitAllowed&&!this.scope.inFunction&&(this.state.hasTopLevelAwait=true),isAwaitAllowed}parseAwait(startLoc){const node=this.startNodeAt(startLoc);return this.expressionScope.recordParameterInitializerError(Errors.AwaitExpressionFormalParameter,node),this.eat(55)&&this.raise(Errors.ObsoleteAwaitStar,node),this.scope.inFunction||this.options.allowAwaitOutsideFunction||(this.isAmbiguousAwait()?this.ambiguousScriptDifferentAst=true:this.sawUnambiguousESM=true),this.state.soloAwait||(node.argument=this.parseMaybeUnary(null,true)),this.finishNode(node,"AwaitExpression")}isAmbiguousAwait(){if(this.hasPrecedingLineBreak())return  true;const{type}=this.state;return 53===type||10===type||0===type||tokenIsTemplate(type)||102===type&&!this.state.containsEsc||138===type||56===type||this.hasPlugin("v8intrinsic")&&54===type}parseYield(){const node=this.startNode();this.expressionScope.recordParameterInitializerError(Errors.YieldInParameter,node),this.next();let delegating=false,argument=null;if(!this.hasPrecedingLineBreak())switch(delegating=this.eat(55),this.state.type){case 13:case 140:case 8:case 11:case 3:case 9:case 14:case 12:if(!delegating)break;default:argument=this.parseMaybeAssign();}return node.delegate=delegating,node.argument=argument,this.finishNode(node,"YieldExpression")}parseImportCall(node){if(this.next(),node.source=this.parseMaybeAssignAllowIn(),node.options=null,this.eat(12)&&!this.match(11)&&(node.options=this.parseMaybeAssignAllowIn(),this.eat(12)&&!this.match(11))){do{this.parseMaybeAssignAllowIn();}while(this.eat(12)&&!this.match(11));this.raise(Errors.ImportCallArity,node);}return this.expect(11),this.finishNode(node,"ImportExpression")}checkPipelineAtInfixOperator(left,leftStartLoc){this.hasPlugin(["pipelineOperator",{proposal:"smart"}])&&"SequenceExpression"===left.type&&this.raise(Errors.PipelineHeadSequenceExpression,leftStartLoc);}parseSmartPipelineBodyInStyle(childExpr,startLoc){if(this.isSimpleReference(childExpr)){const bodyNode=this.startNodeAt(startLoc);return bodyNode.callee=childExpr,this.finishNode(bodyNode,"PipelineBareFunction")}{const bodyNode=this.startNodeAt(startLoc);return this.checkSmartPipeTopicBodyEarlyErrors(startLoc),bodyNode.expression=childExpr,this.finishNode(bodyNode,"PipelineTopicExpression")}}isSimpleReference(expression){switch(expression.type){case "MemberExpression":return !expression.computed&&this.isSimpleReference(expression.object);case "Identifier":return  true;default:return  false}}checkSmartPipeTopicBodyEarlyErrors(startLoc){if(this.match(19))throw this.raise(Errors.PipelineBodyNoArrow,this.state.startLoc);this.topicReferenceWasUsedInCurrentContext()||this.raise(Errors.PipelineTopicUnused,startLoc);}withTopicBindingContext(callback){const outerContextTopicState=this.state.topicContext;this.state.topicContext={maxNumOfResolvableTopics:1,maxTopicIndex:null};try{return callback()}finally{this.state.topicContext=outerContextTopicState;}}withSmartMixTopicForbiddingContext(callback){if(!this.hasPlugin(["pipelineOperator",{proposal:"smart"}]))return callback();{const outerContextTopicState=this.state.topicContext;this.state.topicContext={maxNumOfResolvableTopics:0,maxTopicIndex:null};try{return callback()}finally{this.state.topicContext=outerContextTopicState;}}}withSoloAwaitPermittingContext(callback){const outerContextSoloAwaitState=this.state.soloAwait;this.state.soloAwait=true;try{return callback()}finally{this.state.soloAwait=outerContextSoloAwaitState;}}allowInAnd(callback){const flags=this.prodParam.currentFlags();if(8&~flags){this.prodParam.enter(8|flags);try{return callback()}finally{this.prodParam.exit();}}return callback()}disallowInAnd(callback){const flags=this.prodParam.currentFlags();if(8&flags){this.prodParam.enter(-9&flags);try{return callback()}finally{this.prodParam.exit();}}return callback()}registerTopicReference(){this.state.topicContext.maxTopicIndex=0;}topicReferenceIsAllowedInCurrentContext(){return this.state.topicContext.maxNumOfResolvableTopics>=1}topicReferenceWasUsedInCurrentContext(){return null!=this.state.topicContext.maxTopicIndex&&this.state.topicContext.maxTopicIndex>=0}parseFSharpPipelineBody(prec){const startLoc=this.state.startLoc;this.state.potentialArrowAt=this.state.start;const oldInFSharpPipelineDirectBody=this.state.inFSharpPipelineDirectBody;this.state.inFSharpPipelineDirectBody=true;const ret=this.parseExprOp(this.parseMaybeUnaryOrPrivate(),startLoc,prec);return this.state.inFSharpPipelineDirectBody=oldInFSharpPipelineDirectBody,ret}parseModuleExpression(){this.expectPlugin("moduleBlocks");const node=this.startNode();this.next(),this.match(5)||this.unexpected(null,5);const program=this.startNodeAt(this.state.endLoc);this.next();const revertScopes=this.initializeScopes(true);this.enterInitialScopes();try{node.body=this.parseProgram(program,8,"module");}finally{revertScopes();}return this.finishNode(node,"ModuleExpression")}parsePropertyNamePrefixOperator(prop){}}const loopLabel={kind:1},switchLabel={kind:2},loneSurrogate=/[\uD800-\uDFFF]/u,keywordRelationalOperator=/in(?:stanceof)?/y;class StatementParser extends ExpressionParser{parseTopLevel(file,program){return file.program=this.parseProgram(program),file.comments=this.comments,this.options.tokens&&(file.tokens=function(tokens,input,startIndex){for(let i=0;i<tokens.length;i++){const token=tokens[i],{type}=token;if("number"==typeof type){if(139===type){const{loc,start,value,end}=token,hashEndPos=start+1,hashEndLoc=createPositionWithColumnOffset(loc.start,1);tokens.splice(i,1,new Token({type:getExportedToken(27),value:"#",start,end:hashEndPos,startLoc:loc.start,endLoc:hashEndLoc}),new Token({type:getExportedToken(132),value,start:hashEndPos,end,startLoc:hashEndLoc,endLoc:loc.end})),i++;continue}if(tokenIsTemplate(type)){const{loc,start,value,end}=token,backquoteEnd=start+1,backquoteEndLoc=createPositionWithColumnOffset(loc.start,1);let startToken,templateValue,templateElementEnd,templateElementEndLoc,endToken;startToken=96===input.charCodeAt(start-startIndex)?new Token({type:getExportedToken(22),value:"`",start,end:backquoteEnd,startLoc:loc.start,endLoc:backquoteEndLoc}):new Token({type:getExportedToken(8),value:"}",start,end:backquoteEnd,startLoc:loc.start,endLoc:backquoteEndLoc}),24===type?(templateElementEnd=end-1,templateElementEndLoc=createPositionWithColumnOffset(loc.end,-1),templateValue=null===value?null:value.slice(1,-1),endToken=new Token({type:getExportedToken(22),value:"`",start:templateElementEnd,end,startLoc:templateElementEndLoc,endLoc:loc.end})):(templateElementEnd=end-2,templateElementEndLoc=createPositionWithColumnOffset(loc.end,-2),templateValue=null===value?null:value.slice(1,-2),endToken=new Token({type:getExportedToken(23),value:"${",start:templateElementEnd,end,startLoc:templateElementEndLoc,endLoc:loc.end})),tokens.splice(i,1,startToken,new Token({type:getExportedToken(20),value:templateValue,start:backquoteEnd,end:templateElementEnd,startLoc:backquoteEndLoc,endLoc:templateElementEndLoc}),endToken),i+=2;continue}token.type=getExportedToken(type);}}return tokens}(this.tokens,this.input,this.startIndex)),this.finishNode(file,"File")}parseProgram(program,end=140,sourceType=this.options.sourceType){if(program.sourceType=sourceType,program.interpreter=this.parseInterpreterDirective(),this.parseBlockBody(program,true,true,end),this.inModule){if(!this.options.allowUndeclaredExports&&this.scope.undefinedExports.size>0)for(const[localName,at]of Array.from(this.scope.undefinedExports))this.raise(Errors.ModuleExportUndefined,at,{localName});this.addExtra(program,"topLevelAwait",this.state.hasTopLevelAwait);}let finishedProgram;return finishedProgram=140===end?this.finishNode(program,"Program"):this.finishNodeAt(program,"Program",createPositionWithColumnOffset(this.state.startLoc,-1)),finishedProgram}stmtToDirective(stmt){const directive=stmt;directive.type="Directive",directive.value=directive.expression,delete directive.expression;const directiveLiteral=directive.value,expressionValue=directiveLiteral.value,raw=this.input.slice(this.offsetToSourcePos(directiveLiteral.start),this.offsetToSourcePos(directiveLiteral.end)),val=directiveLiteral.value=raw.slice(1,-1);return this.addExtra(directiveLiteral,"raw",raw),this.addExtra(directiveLiteral,"rawValue",val),this.addExtra(directiveLiteral,"expressionValue",expressionValue),directiveLiteral.type="DirectiveLiteral",directive}parseInterpreterDirective(){if(!this.match(28))return null;const node=this.startNode();return node.value=this.state.value,this.next(),this.finishNode(node,"InterpreterDirective")}isLet(){return !!this.isContextual(100)&&this.hasFollowingBindingAtom()}chStartsBindingIdentifier(ch,pos){if(isIdentifierStart(ch)){if(keywordRelationalOperator.lastIndex=pos,keywordRelationalOperator.test(this.input)){const endCh=this.codePointAtPos(keywordRelationalOperator.lastIndex);if(!isIdentifierChar(endCh)&&92!==endCh)return  false}return  true}return 92===ch}chStartsBindingPattern(ch){return 91===ch||123===ch}hasFollowingBindingAtom(){const next=this.nextTokenStart(),nextCh=this.codePointAtPos(next);return this.chStartsBindingPattern(nextCh)||this.chStartsBindingIdentifier(nextCh,next)}hasInLineFollowingBindingIdentifierOrBrace(){const next=this.nextTokenInLineStart(),nextCh=this.codePointAtPos(next);return 123===nextCh||this.chStartsBindingIdentifier(nextCh,next)}startsUsingForOf(){const{type,containsEsc}=this.lookahead();return !(102===type&&!containsEsc)&&(tokenIsIdentifier(type)&&!this.hasFollowingLineBreak()?(this.expectPlugin("explicitResourceManagement"),true):void 0)}startsAwaitUsing(){let next=this.nextTokenInLineStart();if(this.isUnparsedContextual(next,"using")){next=this.nextTokenInLineStartSince(next+5);const nextCh=this.codePointAtPos(next);if(this.chStartsBindingIdentifier(nextCh,next))return this.expectPlugin("explicitResourceManagement"),true}return  false}parseModuleItem(){return this.parseStatementLike(15)}parseStatementListItem(){return this.parseStatementLike(6|(!this.options.annexB||this.state.strict?0:8))}parseStatementOrSloppyAnnexBFunctionDeclaration(allowLabeledFunction=false){let flags=0;return this.options.annexB&&!this.state.strict&&(flags|=4,allowLabeledFunction&&(flags|=8)),this.parseStatementLike(flags)}parseStatement(){return this.parseStatementLike(0)}parseStatementLike(flags){let decorators=null;return this.match(26)&&(decorators=this.parseDecorators(true)),this.parseStatementContent(flags,decorators)}parseStatementContent(flags,decorators){const startType=this.state.type,node=this.startNode(),allowDeclaration=!!(2&flags),allowFunctionDeclaration=!!(4&flags),topLevel=1&flags;switch(startType){case 60:return this.parseBreakContinueStatement(node,true);case 63:return this.parseBreakContinueStatement(node,false);case 64:return this.parseDebuggerStatement(node);case 90:return this.parseDoWhileStatement(node);case 91:return this.parseForStatement(node);case 68:if(46===this.lookaheadCharCode())break;return allowFunctionDeclaration||this.raise(this.state.strict?Errors.StrictFunction:this.options.annexB?Errors.SloppyFunctionAnnexB:Errors.SloppyFunction,this.state.startLoc),this.parseFunctionStatement(node,false,!allowDeclaration&&allowFunctionDeclaration);case 80:return allowDeclaration||this.unexpected(),this.parseClass(this.maybeTakeDecorators(decorators,node),true);case 69:return this.parseIfStatement(node);case 70:return this.parseReturnStatement(node);case 71:return this.parseSwitchStatement(node);case 72:return this.parseThrowStatement(node);case 73:return this.parseTryStatement(node);case 96:if(!this.state.containsEsc&&this.startsAwaitUsing())return this.recordAwaitIfAllowed()?allowDeclaration||this.raise(Errors.UnexpectedLexicalDeclaration,node):this.raise(Errors.AwaitUsingNotInAsyncContext,node),this.next(),this.parseVarStatement(node,"await using");break;case 107:if(this.state.containsEsc||!this.hasInLineFollowingBindingIdentifierOrBrace())break;return this.expectPlugin("explicitResourceManagement"),!this.scope.inModule&&this.scope.inTopLevel?this.raise(Errors.UnexpectedUsingDeclaration,this.state.startLoc):allowDeclaration||this.raise(Errors.UnexpectedLexicalDeclaration,this.state.startLoc),this.parseVarStatement(node,"using");case 100:{if(this.state.containsEsc)break;const next=this.nextTokenStart(),nextCh=this.codePointAtPos(next);if(91!==nextCh){if(!allowDeclaration&&this.hasFollowingLineBreak())break;if(!this.chStartsBindingIdentifier(nextCh,next)&&123!==nextCh)break}}case 75:allowDeclaration||this.raise(Errors.UnexpectedLexicalDeclaration,this.state.startLoc);case 74:{const kind=this.state.value;return this.parseVarStatement(node,kind)}case 92:return this.parseWhileStatement(node);case 76:return this.parseWithStatement(node);case 5:return this.parseBlock();case 13:return this.parseEmptyStatement(node);case 83:{const nextTokenCharCode=this.lookaheadCharCode();if(40===nextTokenCharCode||46===nextTokenCharCode)break}case 82:{let result;return this.options.allowImportExportEverywhere||topLevel||this.raise(Errors.UnexpectedImportExport,this.state.startLoc),this.next(),83===startType?(result=this.parseImport(node),"ImportDeclaration"!==result.type||result.importKind&&"value"!==result.importKind||(this.sawUnambiguousESM=true)):(result=this.parseExport(node,decorators),("ExportNamedDeclaration"!==result.type||result.exportKind&&"value"!==result.exportKind)&&("ExportAllDeclaration"!==result.type||result.exportKind&&"value"!==result.exportKind)&&"ExportDefaultDeclaration"!==result.type||(this.sawUnambiguousESM=true)),this.assertModuleNodeAllowed(result),result}default:if(this.isAsyncFunction())return allowDeclaration||this.raise(Errors.AsyncFunctionInSingleStatementContext,this.state.startLoc),this.next(),this.parseFunctionStatement(node,true,!allowDeclaration&&allowFunctionDeclaration)}const maybeName=this.state.value,expr=this.parseExpression();return tokenIsIdentifier(startType)&&"Identifier"===expr.type&&this.eat(14)?this.parseLabeledStatement(node,maybeName,expr,flags):this.parseExpressionStatement(node,expr,decorators)}assertModuleNodeAllowed(node){this.options.allowImportExportEverywhere||this.inModule||this.raise(Errors.ImportOutsideModule,node);}decoratorsEnabledBeforeExport(){return !!this.hasPlugin("decorators-legacy")||this.hasPlugin("decorators")&&false!==this.getPluginOption("decorators","decoratorsBeforeExport")}maybeTakeDecorators(maybeDecorators,classNode,exportNode){return maybeDecorators&&(classNode.decorators&&classNode.decorators.length>0?("boolean"!=typeof this.getPluginOption("decorators","decoratorsBeforeExport")&&this.raise(Errors.DecoratorsBeforeAfterExport,classNode.decorators[0]),classNode.decorators.unshift(...maybeDecorators)):classNode.decorators=maybeDecorators,this.resetStartLocationFromNode(classNode,maybeDecorators[0]),exportNode&&this.resetStartLocationFromNode(exportNode,classNode)),classNode}canHaveLeadingDecorator(){return this.match(80)}parseDecorators(allowExport){const decorators=[];do{decorators.push(this.parseDecorator());}while(this.match(26));if(this.match(82))allowExport||this.unexpected(),this.decoratorsEnabledBeforeExport()||this.raise(Errors.DecoratorExportClass,this.state.startLoc);else if(!this.canHaveLeadingDecorator())throw this.raise(Errors.UnexpectedLeadingDecorator,this.state.startLoc);return decorators}parseDecorator(){this.expectOnePlugin(["decorators","decorators-legacy"]);const node=this.startNode();if(this.next(),this.hasPlugin("decorators")){const startLoc=this.state.startLoc;let expr;if(this.match(10)){const startLoc=this.state.startLoc;this.next(),expr=this.parseExpression(),this.expect(11),expr=this.wrapParenthesis(startLoc,expr);const paramsStartLoc=this.state.startLoc;node.expression=this.parseMaybeDecoratorArguments(expr),false===this.getPluginOption("decorators","allowCallParenthesized")&&node.expression!==expr&&this.raise(Errors.DecoratorArgumentsOutsideParentheses,paramsStartLoc);}else {for(expr=this.parseIdentifier(false);this.eat(16);){const node=this.startNodeAt(startLoc);node.object=expr,this.match(139)?(this.classScope.usePrivateName(this.state.value,this.state.startLoc),node.property=this.parsePrivateName()):node.property=this.parseIdentifier(true),node.computed=false,expr=this.finishNode(node,"MemberExpression");}node.expression=this.parseMaybeDecoratorArguments(expr);}}else node.expression=this.parseExprSubscripts();return this.finishNode(node,"Decorator")}parseMaybeDecoratorArguments(expr){if(this.eat(10)){const node=this.startNodeAtNode(expr);return node.callee=expr,node.arguments=this.parseCallExpressionArguments(11),this.toReferencedList(node.arguments),this.finishNode(node,"CallExpression")}return expr}parseBreakContinueStatement(node,isBreak){return this.next(),this.isLineTerminator()?node.label=null:(node.label=this.parseIdentifier(),this.semicolon()),this.verifyBreakContinue(node,isBreak),this.finishNode(node,isBreak?"BreakStatement":"ContinueStatement")}verifyBreakContinue(node,isBreak){let i;for(i=0;i<this.state.labels.length;++i){const lab=this.state.labels[i];if(null==node.label||lab.name===node.label.name){if(null!=lab.kind&&(isBreak||1===lab.kind))break;if(node.label&&isBreak)break}}if(i===this.state.labels.length){const type=isBreak?"BreakStatement":"ContinueStatement";this.raise(Errors.IllegalBreakContinue,node,{type});}}parseDebuggerStatement(node){return this.next(),this.semicolon(),this.finishNode(node,"DebuggerStatement")}parseHeaderExpression(){this.expect(10);const val=this.parseExpression();return this.expect(11),val}parseDoWhileStatement(node){return this.next(),this.state.labels.push(loopLabel),node.body=this.withSmartMixTopicForbiddingContext((()=>this.parseStatement())),this.state.labels.pop(),this.expect(92),node.test=this.parseHeaderExpression(),this.eat(13),this.finishNode(node,"DoWhileStatement")}parseForStatement(node){this.next(),this.state.labels.push(loopLabel);let awaitAt=null;if(this.isContextual(96)&&this.recordAwaitIfAllowed()&&(awaitAt=this.state.startLoc,this.next()),this.scope.enter(0),this.expect(10),this.match(13))return null!==awaitAt&&this.unexpected(awaitAt),this.parseFor(node,null);const startsWithLet=this.isContextual(100);{const startsWithAwaitUsing=this.isContextual(96)&&this.startsAwaitUsing(),starsWithUsingDeclaration=startsWithAwaitUsing||this.isContextual(107)&&this.startsUsingForOf(),isLetOrUsing=startsWithLet&&this.hasFollowingBindingAtom()||starsWithUsingDeclaration;if(this.match(74)||this.match(75)||isLetOrUsing){const initNode=this.startNode();let kind;startsWithAwaitUsing?(kind="await using",this.recordAwaitIfAllowed()||this.raise(Errors.AwaitUsingNotInAsyncContext,this.state.startLoc),this.next()):kind=this.state.value,this.next(),this.parseVar(initNode,true,kind);const init=this.finishNode(initNode,"VariableDeclaration"),isForIn=this.match(58);return isForIn&&starsWithUsingDeclaration&&this.raise(Errors.ForInUsing,init),(isForIn||this.isContextual(102))&&1===init.declarations.length?this.parseForIn(node,init,awaitAt):(null!==awaitAt&&this.unexpected(awaitAt),this.parseFor(node,init))}}const startsWithAsync=this.isContextual(95),refExpressionErrors=new ExpressionErrors,init=this.parseExpression(true,refExpressionErrors),isForOf=this.isContextual(102);if(isForOf&&(startsWithLet&&this.raise(Errors.ForOfLet,init),null===awaitAt&&startsWithAsync&&"Identifier"===init.type&&this.raise(Errors.ForOfAsync,init)),isForOf||this.match(58)){this.checkDestructuringPrivate(refExpressionErrors),this.toAssignable(init,true);const type=isForOf?"ForOfStatement":"ForInStatement";return this.checkLVal(init,{type}),this.parseForIn(node,init,awaitAt)}return this.checkExpressionErrors(refExpressionErrors,true),null!==awaitAt&&this.unexpected(awaitAt),this.parseFor(node,init)}parseFunctionStatement(node,isAsync,isHangingDeclaration){return this.next(),this.parseFunction(node,1|(isHangingDeclaration?2:0)|(isAsync?8:0))}parseIfStatement(node){return this.next(),node.test=this.parseHeaderExpression(),node.consequent=this.parseStatementOrSloppyAnnexBFunctionDeclaration(),node.alternate=this.eat(66)?this.parseStatementOrSloppyAnnexBFunctionDeclaration():null,this.finishNode(node,"IfStatement")}parseReturnStatement(node){return this.prodParam.hasReturn||this.options.allowReturnOutsideFunction||this.raise(Errors.IllegalReturn,this.state.startLoc),this.next(),this.isLineTerminator()?node.argument=null:(node.argument=this.parseExpression(),this.semicolon()),this.finishNode(node,"ReturnStatement")}parseSwitchStatement(node){this.next(),node.discriminant=this.parseHeaderExpression();const cases=node.cases=[];let cur;this.expect(5),this.state.labels.push(switchLabel),this.scope.enter(0);for(let sawDefault;!this.match(8);)if(this.match(61)||this.match(65)){const isCase=this.match(61);cur&&this.finishNode(cur,"SwitchCase"),cases.push(cur=this.startNode()),cur.consequent=[],this.next(),isCase?cur.test=this.parseExpression():(sawDefault&&this.raise(Errors.MultipleDefaultsInSwitch,this.state.lastTokStartLoc),sawDefault=true,cur.test=null),this.expect(14);}else cur?cur.consequent.push(this.parseStatementListItem()):this.unexpected();return this.scope.exit(),cur&&this.finishNode(cur,"SwitchCase"),this.next(),this.state.labels.pop(),this.finishNode(node,"SwitchStatement")}parseThrowStatement(node){return this.next(),this.hasPrecedingLineBreak()&&this.raise(Errors.NewlineAfterThrow,this.state.lastTokEndLoc),node.argument=this.parseExpression(),this.semicolon(),this.finishNode(node,"ThrowStatement")}parseCatchClauseParam(){const param=this.parseBindingAtom();return this.scope.enter(this.options.annexB&&"Identifier"===param.type?8:0),this.checkLVal(param,{type:"CatchClause"},9),param}parseTryStatement(node){if(this.next(),node.block=this.parseBlock(),node.handler=null,this.match(62)){const clause=this.startNode();this.next(),this.match(10)?(this.expect(10),clause.param=this.parseCatchClauseParam(),this.expect(11)):(clause.param=null,this.scope.enter(0)),clause.body=this.withSmartMixTopicForbiddingContext((()=>this.parseBlock(false,false))),this.scope.exit(),node.handler=this.finishNode(clause,"CatchClause");}return node.finalizer=this.eat(67)?this.parseBlock():null,node.handler||node.finalizer||this.raise(Errors.NoCatchOrFinally,node),this.finishNode(node,"TryStatement")}parseVarStatement(node,kind,allowMissingInitializer=false){return this.next(),this.parseVar(node,false,kind,allowMissingInitializer),this.semicolon(),this.finishNode(node,"VariableDeclaration")}parseWhileStatement(node){return this.next(),node.test=this.parseHeaderExpression(),this.state.labels.push(loopLabel),node.body=this.withSmartMixTopicForbiddingContext((()=>this.parseStatement())),this.state.labels.pop(),this.finishNode(node,"WhileStatement")}parseWithStatement(node){return this.state.strict&&this.raise(Errors.StrictWith,this.state.startLoc),this.next(),node.object=this.parseHeaderExpression(),node.body=this.withSmartMixTopicForbiddingContext((()=>this.parseStatement())),this.finishNode(node,"WithStatement")}parseEmptyStatement(node){return this.next(),this.finishNode(node,"EmptyStatement")}parseLabeledStatement(node,maybeName,expr,flags){for(const label of this.state.labels)label.name===maybeName&&this.raise(Errors.LabelRedeclaration,expr,{labelName:maybeName});const kind=(token=this.state.type)>=90&&token<=92?1:this.match(71)?2:null;var token;for(let i=this.state.labels.length-1;i>=0;i--){const label=this.state.labels[i];if(label.statementStart!==node.start)break;label.statementStart=this.sourceToOffsetPos(this.state.start),label.kind=kind;}return this.state.labels.push({name:maybeName,kind,statementStart:this.sourceToOffsetPos(this.state.start)}),node.body=8&flags?this.parseStatementOrSloppyAnnexBFunctionDeclaration(true):this.parseStatement(),this.state.labels.pop(),node.label=expr,this.finishNode(node,"LabeledStatement")}parseExpressionStatement(node,expr,decorators){return node.expression=expr,this.semicolon(),this.finishNode(node,"ExpressionStatement")}parseBlock(allowDirectives=false,createNewLexicalScope=true,afterBlockParse){const node=this.startNode();return allowDirectives&&this.state.strictErrors.clear(),this.expect(5),createNewLexicalScope&&this.scope.enter(0),this.parseBlockBody(node,allowDirectives,false,8,afterBlockParse),createNewLexicalScope&&this.scope.exit(),this.finishNode(node,"BlockStatement")}isValidDirective(stmt){return "ExpressionStatement"===stmt.type&&"StringLiteral"===stmt.expression.type&&!stmt.expression.extra.parenthesized}parseBlockBody(node,allowDirectives,topLevel,end,afterBlockParse){const body=node.body=[],directives=node.directives=[];this.parseBlockOrModuleBlockBody(body,allowDirectives?directives:void 0,topLevel,end,afterBlockParse);}parseBlockOrModuleBlockBody(body,directives,topLevel,end,afterBlockParse){const oldStrict=this.state.strict;let hasStrictModeDirective=false,parsedNonDirective=false;for(;!this.match(end);){const stmt=topLevel?this.parseModuleItem():this.parseStatementListItem();if(directives&&!parsedNonDirective){if(this.isValidDirective(stmt)){const directive=this.stmtToDirective(stmt);directives.push(directive),hasStrictModeDirective||"use strict"!==directive.value.value||(hasStrictModeDirective=true,this.setStrict(true));continue}parsedNonDirective=true,this.state.strictErrors.clear();}body.push(stmt);}null==afterBlockParse||afterBlockParse.call(this,hasStrictModeDirective),oldStrict||this.setStrict(false),this.next();}parseFor(node,init){return node.init=init,this.semicolon(false),node.test=this.match(13)?null:this.parseExpression(),this.semicolon(false),node.update=this.match(11)?null:this.parseExpression(),this.expect(11),node.body=this.withSmartMixTopicForbiddingContext((()=>this.parseStatement())),this.scope.exit(),this.state.labels.pop(),this.finishNode(node,"ForStatement")}parseForIn(node,init,awaitAt){const isForIn=this.match(58);return this.next(),isForIn?null!==awaitAt&&this.unexpected(awaitAt):node.await=null!==awaitAt,"VariableDeclaration"!==init.type||null==init.declarations[0].init||isForIn&&this.options.annexB&&!this.state.strict&&"var"===init.kind&&"Identifier"===init.declarations[0].id.type||this.raise(Errors.ForInOfLoopInitializer,init,{type:isForIn?"ForInStatement":"ForOfStatement"}),"AssignmentPattern"===init.type&&this.raise(Errors.InvalidLhs,init,{ancestor:{type:"ForStatement"}}),node.left=init,node.right=isForIn?this.parseExpression():this.parseMaybeAssignAllowIn(),this.expect(11),node.body=this.withSmartMixTopicForbiddingContext((()=>this.parseStatement())),this.scope.exit(),this.state.labels.pop(),this.finishNode(node,isForIn?"ForInStatement":"ForOfStatement")}parseVar(node,isFor,kind,allowMissingInitializer=false){const declarations=node.declarations=[];for(node.kind=kind;;){const decl=this.startNode();if(this.parseVarId(decl,kind),decl.init=this.eat(29)?isFor?this.parseMaybeAssignDisallowIn():this.parseMaybeAssignAllowIn():null,null!==decl.init||allowMissingInitializer||("Identifier"===decl.id.type||isFor&&(this.match(58)||this.isContextual(102))?"const"!==kind&&"using"!==kind&&"await using"!==kind||this.match(58)||this.isContextual(102)||this.raise(Errors.DeclarationMissingInitializer,this.state.lastTokEndLoc,{kind}):this.raise(Errors.DeclarationMissingInitializer,this.state.lastTokEndLoc,{kind:"destructuring"})),declarations.push(this.finishNode(decl,"VariableDeclarator")),!this.eat(12))break}return node}parseVarId(decl,kind){const id=this.parseBindingAtom();"using"!==kind&&"await using"!==kind||"ArrayPattern"!==id.type&&"ObjectPattern"!==id.type||this.raise(Errors.UsingDeclarationHasBindingPattern,id.loc.start),this.checkLVal(id,{type:"VariableDeclarator"},"var"===kind?5:8201),decl.id=id;}parseAsyncFunctionExpression(node){return this.parseFunction(node,8)}parseFunction(node,flags=0){const hangingDeclaration=2&flags,isDeclaration=!!(1&flags),requireId=isDeclaration&&!(4&flags),isAsync=!!(8&flags);this.initFunction(node,isAsync),this.match(55)&&(hangingDeclaration&&this.raise(Errors.GeneratorInSingleStatementContext,this.state.startLoc),this.next(),node.generator=true),isDeclaration&&(node.id=this.parseFunctionId(requireId));const oldMaybeInArrowParameters=this.state.maybeInArrowParameters;return this.state.maybeInArrowParameters=false,this.scope.enter(2),this.prodParam.enter(functionFlags(isAsync,node.generator)),isDeclaration||(node.id=this.parseFunctionId()),this.parseFunctionParams(node,false),this.withSmartMixTopicForbiddingContext((()=>{this.parseFunctionBodyAndFinish(node,isDeclaration?"FunctionDeclaration":"FunctionExpression");})),this.prodParam.exit(),this.scope.exit(),isDeclaration&&!hangingDeclaration&&this.registerFunctionStatementId(node),this.state.maybeInArrowParameters=oldMaybeInArrowParameters,node}parseFunctionId(requireId){return requireId||tokenIsIdentifier(this.state.type)?this.parseIdentifier():null}parseFunctionParams(node,isConstructor){this.expect(10),this.expressionScope.enter(new ExpressionScope(3)),node.params=this.parseBindingList(11,41,2|(isConstructor?4:0)),this.expressionScope.exit();}registerFunctionStatementId(node){node.id&&this.scope.declareName(node.id.name,!this.options.annexB||this.state.strict||node.generator||node.async?this.scope.treatFunctionsAsVar?5:8201:17,node.id.loc.start);}parseClass(node,isStatement,optionalId){this.next();const oldStrict=this.state.strict;return this.state.strict=true,this.parseClassId(node,isStatement,optionalId),this.parseClassSuper(node),node.body=this.parseClassBody(!!node.superClass,oldStrict),this.finishNode(node,isStatement?"ClassDeclaration":"ClassExpression")}isClassProperty(){return this.match(29)||this.match(13)||this.match(8)}isClassMethod(){return this.match(10)}nameIsConstructor(key){return "Identifier"===key.type&&"constructor"===key.name||"StringLiteral"===key.type&&"constructor"===key.value}isNonstaticConstructor(method){return !method.computed&&!method.static&&this.nameIsConstructor(method.key)}parseClassBody(hadSuperClass,oldStrict){this.classScope.enter();const state={hadConstructor:false,hadSuperClass};let decorators=[];const classBody=this.startNode();if(classBody.body=[],this.expect(5),this.withSmartMixTopicForbiddingContext((()=>{for(;!this.match(8);){if(this.eat(13)){if(decorators.length>0)throw this.raise(Errors.DecoratorSemicolon,this.state.lastTokEndLoc);continue}if(this.match(26)){decorators.push(this.parseDecorator());continue}const member=this.startNode();decorators.length&&(member.decorators=decorators,this.resetStartLocationFromNode(member,decorators[0]),decorators=[]),this.parseClassMember(classBody,member,state),"constructor"===member.kind&&member.decorators&&member.decorators.length>0&&this.raise(Errors.DecoratorConstructor,member);}})),this.state.strict=oldStrict,this.next(),decorators.length)throw this.raise(Errors.TrailingDecorator,this.state.startLoc);return this.classScope.exit(),this.finishNode(classBody,"ClassBody")}parseClassMemberFromModifier(classBody,member){const key=this.parseIdentifier(true);if(this.isClassMethod()){const method=member;return method.kind="method",method.computed=false,method.key=key,method.static=false,this.pushClassMethod(classBody,method,false,false,false,false),true}if(this.isClassProperty()){const prop=member;return prop.computed=false,prop.key=key,prop.static=false,classBody.body.push(this.parseClassProperty(prop)),true}return this.resetPreviousNodeTrailingComments(key),false}parseClassMember(classBody,member,state){const isStatic=this.isContextual(106);if(isStatic){if(this.parseClassMemberFromModifier(classBody,member))return;if(this.eat(5))return void this.parseClassStaticBlock(classBody,member)}this.parseClassMemberWithIsStatic(classBody,member,state,isStatic);}parseClassMemberWithIsStatic(classBody,member,state,isStatic){const publicMethod=member,privateMethod=member,publicProp=member,privateProp=member,accessorProp=member,method=publicMethod,publicMember=publicMethod;if(member.static=isStatic,this.parsePropertyNamePrefixOperator(member),this.eat(55)){method.kind="method";const isPrivateName=this.match(139);return this.parseClassElementName(method),isPrivateName?void this.pushClassPrivateMethod(classBody,privateMethod,true,false):(this.isNonstaticConstructor(publicMethod)&&this.raise(Errors.ConstructorIsGenerator,publicMethod.key),void this.pushClassMethod(classBody,publicMethod,true,false,false,false))}const isContextual=!this.state.containsEsc&&tokenIsIdentifier(this.state.type),key=this.parseClassElementName(member),maybeContextualKw=isContextual?key.name:null,isPrivate=this.isPrivateName(key),maybeQuestionTokenStartLoc=this.state.startLoc;if(this.parsePostMemberNameModifiers(publicMember),this.isClassMethod()){if(method.kind="method",isPrivate)return void this.pushClassPrivateMethod(classBody,privateMethod,false,false);const isConstructor=this.isNonstaticConstructor(publicMethod);let allowsDirectSuper=false;isConstructor&&(publicMethod.kind="constructor",state.hadConstructor&&!this.hasPlugin("typescript")&&this.raise(Errors.DuplicateConstructor,key),isConstructor&&this.hasPlugin("typescript")&&member.override&&this.raise(Errors.OverrideOnConstructor,key),state.hadConstructor=true,allowsDirectSuper=state.hadSuperClass),this.pushClassMethod(classBody,publicMethod,false,false,isConstructor,allowsDirectSuper);}else if(this.isClassProperty())isPrivate?this.pushClassPrivateProperty(classBody,privateProp):this.pushClassProperty(classBody,publicProp);else if("async"!==maybeContextualKw||this.isLineTerminator())if("get"!==maybeContextualKw&&"set"!==maybeContextualKw||this.match(55)&&this.isLineTerminator())if("accessor"!==maybeContextualKw||this.isLineTerminator())this.isLineTerminator()?isPrivate?this.pushClassPrivateProperty(classBody,privateProp):this.pushClassProperty(classBody,publicProp):this.unexpected();else {this.expectPlugin("decoratorAutoAccessors"),this.resetPreviousNodeTrailingComments(key);const isPrivate=this.match(139);this.parseClassElementName(publicProp),this.pushClassAccessorProperty(classBody,accessorProp,isPrivate);}else {this.resetPreviousNodeTrailingComments(key),method.kind=maybeContextualKw;const isPrivate=this.match(139);this.parseClassElementName(publicMethod),isPrivate?this.pushClassPrivateMethod(classBody,privateMethod,false,false):(this.isNonstaticConstructor(publicMethod)&&this.raise(Errors.ConstructorIsAccessor,publicMethod.key),this.pushClassMethod(classBody,publicMethod,false,false,false,false)),this.checkGetterSetterParams(publicMethod);}else {this.resetPreviousNodeTrailingComments(key);const isGenerator=this.eat(55);publicMember.optional&&this.unexpected(maybeQuestionTokenStartLoc),method.kind="method";const isPrivate=this.match(139);this.parseClassElementName(method),this.parsePostMemberNameModifiers(publicMember),isPrivate?this.pushClassPrivateMethod(classBody,privateMethod,isGenerator,true):(this.isNonstaticConstructor(publicMethod)&&this.raise(Errors.ConstructorIsAsync,publicMethod.key),this.pushClassMethod(classBody,publicMethod,isGenerator,true,false,false));}}parseClassElementName(member){const{type,value}=this.state;if(132!==type&&134!==type||!member.static||"prototype"!==value||this.raise(Errors.StaticPrototype,this.state.startLoc),139===type){"constructor"===value&&this.raise(Errors.ConstructorClassPrivateField,this.state.startLoc);const key=this.parsePrivateName();return member.key=key,key}return this.parsePropertyName(member),member.key}parseClassStaticBlock(classBody,member){var _member$decorators;this.scope.enter(208);const oldLabels=this.state.labels;this.state.labels=[],this.prodParam.enter(0);const body=member.body=[];this.parseBlockOrModuleBlockBody(body,void 0,false,8),this.prodParam.exit(),this.scope.exit(),this.state.labels=oldLabels,classBody.body.push(this.finishNode(member,"StaticBlock")),null!=(_member$decorators=member.decorators)&&_member$decorators.length&&this.raise(Errors.DecoratorStaticBlock,member);}pushClassProperty(classBody,prop){!prop.computed&&this.nameIsConstructor(prop.key)&&this.raise(Errors.ConstructorClassField,prop.key),classBody.body.push(this.parseClassProperty(prop));}pushClassPrivateProperty(classBody,prop){const node=this.parseClassPrivateProperty(prop);classBody.body.push(node),this.classScope.declarePrivateName(this.getPrivateNameSV(node.key),0,node.key.loc.start);}pushClassAccessorProperty(classBody,prop,isPrivate){isPrivate||prop.computed||!this.nameIsConstructor(prop.key)||this.raise(Errors.ConstructorClassField,prop.key);const node=this.parseClassAccessorProperty(prop);classBody.body.push(node),isPrivate&&this.classScope.declarePrivateName(this.getPrivateNameSV(node.key),0,node.key.loc.start);}pushClassMethod(classBody,method,isGenerator,isAsync,isConstructor,allowsDirectSuper){classBody.body.push(this.parseMethod(method,isGenerator,isAsync,isConstructor,allowsDirectSuper,"ClassMethod",true));}pushClassPrivateMethod(classBody,method,isGenerator,isAsync){const node=this.parseMethod(method,isGenerator,isAsync,false,false,"ClassPrivateMethod",true);classBody.body.push(node);const kind="get"===node.kind?node.static?6:2:"set"===node.kind?node.static?5:1:0;this.declareClassPrivateMethodInScope(node,kind);}declareClassPrivateMethodInScope(node,kind){this.classScope.declarePrivateName(this.getPrivateNameSV(node.key),kind,node.key.loc.start);}parsePostMemberNameModifiers(methodOrProp){}parseClassPrivateProperty(node){return this.parseInitializer(node),this.semicolon(),this.finishNode(node,"ClassPrivateProperty")}parseClassProperty(node){return this.parseInitializer(node),this.semicolon(),this.finishNode(node,"ClassProperty")}parseClassAccessorProperty(node){return this.parseInitializer(node),this.semicolon(),this.finishNode(node,"ClassAccessorProperty")}parseInitializer(node){this.scope.enter(80),this.expressionScope.enter(newExpressionScope()),this.prodParam.enter(0),node.value=this.eat(29)?this.parseMaybeAssignAllowIn():null,this.expressionScope.exit(),this.prodParam.exit(),this.scope.exit();}parseClassId(node,isStatement,optionalId,bindingType=8331){if(tokenIsIdentifier(this.state.type))node.id=this.parseIdentifier(),isStatement&&this.declareNameFromIdentifier(node.id,bindingType);else {if(!optionalId&&isStatement)throw this.raise(Errors.MissingClassName,this.state.startLoc);node.id=null;}}parseClassSuper(node){node.superClass=this.eat(81)?this.parseExprSubscripts():null;}parseExport(node,decorators){const maybeDefaultIdentifier=this.parseMaybeImportPhase(node,true),hasDefault=this.maybeParseExportDefaultSpecifier(node,maybeDefaultIdentifier),parseAfterDefault=!hasDefault||this.eat(12),hasStar=parseAfterDefault&&this.eatExportStar(node),hasNamespace=hasStar&&this.maybeParseExportNamespaceSpecifier(node),parseAfterNamespace=parseAfterDefault&&(!hasNamespace||this.eat(12)),isFromRequired=hasDefault||hasStar;if(hasStar&&!hasNamespace){if(hasDefault&&this.unexpected(),decorators)throw this.raise(Errors.UnsupportedDecoratorExport,node);return this.parseExportFrom(node,true),this.finishNode(node,"ExportAllDeclaration")}const hasSpecifiers=this.maybeParseExportNamedSpecifiers(node);let hasDeclaration;if(hasDefault&&parseAfterDefault&&!hasStar&&!hasSpecifiers&&this.unexpected(null,5),hasNamespace&&parseAfterNamespace&&this.unexpected(null,98),isFromRequired||hasSpecifiers){if(hasDeclaration=false,decorators)throw this.raise(Errors.UnsupportedDecoratorExport,node);this.parseExportFrom(node,isFromRequired);}else hasDeclaration=this.maybeParseExportDeclaration(node);if(isFromRequired||hasSpecifiers||hasDeclaration){var _node2$declaration;const node2=node;if(this.checkExport(node2,true,false,!!node2.source),"ClassDeclaration"===(null==(_node2$declaration=node2.declaration)?void 0:_node2$declaration.type))this.maybeTakeDecorators(decorators,node2.declaration,node2);else if(decorators)throw this.raise(Errors.UnsupportedDecoratorExport,node);return this.finishNode(node2,"ExportNamedDeclaration")}if(this.eat(65)){const node2=node,decl=this.parseExportDefaultExpression();if(node2.declaration=decl,"ClassDeclaration"===decl.type)this.maybeTakeDecorators(decorators,decl,node2);else if(decorators)throw this.raise(Errors.UnsupportedDecoratorExport,node);return this.checkExport(node2,true,true),this.finishNode(node2,"ExportDefaultDeclaration")}this.unexpected(null,5);}eatExportStar(node){return this.eat(55)}maybeParseExportDefaultSpecifier(node,maybeDefaultIdentifier){if(maybeDefaultIdentifier||this.isExportDefaultSpecifier()){this.expectPlugin("exportDefaultFrom",null==maybeDefaultIdentifier?void 0:maybeDefaultIdentifier.loc.start);const id=maybeDefaultIdentifier||this.parseIdentifier(true),specifier=this.startNodeAtNode(id);return specifier.exported=id,node.specifiers=[this.finishNode(specifier,"ExportDefaultSpecifier")],true}return  false}maybeParseExportNamespaceSpecifier(node){if(this.isContextual(93)){var _ref;null!=(_ref=node).specifiers||(_ref.specifiers=[]);const specifier=this.startNodeAt(this.state.lastTokStartLoc);return this.next(),specifier.exported=this.parseModuleExportName(),node.specifiers.push(this.finishNode(specifier,"ExportNamespaceSpecifier")),true}return  false}maybeParseExportNamedSpecifiers(node){if(this.match(5)){const node2=node;node2.specifiers||(node2.specifiers=[]);const isTypeExport="type"===node2.exportKind;return node2.specifiers.push(...this.parseExportSpecifiers(isTypeExport)),node2.source=null,node2.declaration=null,this.hasPlugin("importAssertions")&&(node2.assertions=[]),true}return  false}maybeParseExportDeclaration(node){return !!this.shouldParseExportDeclaration()&&(node.specifiers=[],node.source=null,this.hasPlugin("importAssertions")&&(node.assertions=[]),node.declaration=this.parseExportDeclaration(node),true)}isAsyncFunction(){if(!this.isContextual(95))return  false;const next=this.nextTokenInLineStart();return this.isUnparsedContextual(next,"function")}parseExportDefaultExpression(){const expr=this.startNode();if(this.match(68))return this.next(),this.parseFunction(expr,5);if(this.isAsyncFunction())return this.next(),this.next(),this.parseFunction(expr,13);if(this.match(80))return this.parseClass(expr,true,true);if(this.match(26))return this.hasPlugin("decorators")&&true===this.getPluginOption("decorators","decoratorsBeforeExport")&&this.raise(Errors.DecoratorBeforeExport,this.state.startLoc),this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false),this.startNode()),true,true);if(this.match(75)||this.match(74)||this.isLet())throw this.raise(Errors.UnsupportedDefaultExport,this.state.startLoc);const res=this.parseMaybeAssignAllowIn();return this.semicolon(),res}parseExportDeclaration(node){if(this.match(80)){return this.parseClass(this.startNode(),true,false)}return this.parseStatementListItem()}isExportDefaultSpecifier(){const{type}=this.state;if(tokenIsIdentifier(type)){if(95===type&&!this.state.containsEsc||100===type)return  false;if((130===type||129===type)&&!this.state.containsEsc){const{type:nextType}=this.lookahead();if(tokenIsIdentifier(nextType)&&98!==nextType||5===nextType)return this.expectOnePlugin(["flow","typescript"]),false}}else if(!this.match(65))return  false;const next=this.nextTokenStart(),hasFrom=this.isUnparsedContextual(next,"from");if(44===this.input.charCodeAt(next)||tokenIsIdentifier(this.state.type)&&hasFrom)return  true;if(this.match(65)&&hasFrom){const nextAfterFrom=this.input.charCodeAt(this.nextTokenStartSince(next+4));return 34===nextAfterFrom||39===nextAfterFrom}return  false}parseExportFrom(node,expect){this.eatContextual(98)?(node.source=this.parseImportSource(),this.checkExport(node),this.maybeParseImportAttributes(node),this.checkJSONModuleImport(node)):expect&&this.unexpected(),this.semicolon();}shouldParseExportDeclaration(){const{type}=this.state;return 26===type&&(this.expectOnePlugin(["decorators","decorators-legacy"]),this.hasPlugin("decorators"))?(true===this.getPluginOption("decorators","decoratorsBeforeExport")&&this.raise(Errors.DecoratorBeforeExport,this.state.startLoc),true):this.isContextual(107)||this.isContextual(96)&&this.startsAwaitUsing()?(this.raise(Errors.UsingDeclarationExport,this.state.startLoc),true):74===type||75===type||68===type||80===type||this.isLet()||this.isAsyncFunction()}checkExport(node,checkNames,isDefault,isFrom){var _node$specifiers;if(checkNames)if(isDefault){if(this.checkDuplicateExports(node,"default"),this.hasPlugin("exportDefaultFrom")){var _declaration$extra;const declaration=node.declaration;"Identifier"!==declaration.type||"from"!==declaration.name||declaration.end-declaration.start!=4||null!=(_declaration$extra=declaration.extra)&&_declaration$extra.parenthesized||this.raise(Errors.ExportDefaultFromAsIdentifier,declaration);}}else if(null!=(_node$specifiers=node.specifiers)&&_node$specifiers.length)for(const specifier of node.specifiers){const{exported}=specifier,exportName="Identifier"===exported.type?exported.name:exported.value;if(this.checkDuplicateExports(specifier,exportName),!isFrom&&specifier.local){const{local}=specifier;"Identifier"!==local.type?this.raise(Errors.ExportBindingIsString,specifier,{localName:local.value,exportName}):(this.checkReservedWord(local.name,local.loc.start,true,false),this.scope.checkLocalExport(local));}}else if(node.declaration){const decl=node.declaration;if("FunctionDeclaration"===decl.type||"ClassDeclaration"===decl.type){const{id}=decl;if(!id)throw new Error("Assertion failure");this.checkDuplicateExports(node,id.name);}else if("VariableDeclaration"===decl.type)for(const declaration of decl.declarations)this.checkDeclaration(declaration.id);}}checkDeclaration(node){if("Identifier"===node.type)this.checkDuplicateExports(node,node.name);else if("ObjectPattern"===node.type)for(const prop of node.properties)this.checkDeclaration(prop);else if("ArrayPattern"===node.type)for(const elem of node.elements)elem&&this.checkDeclaration(elem);else "ObjectProperty"===node.type?this.checkDeclaration(node.value):"RestElement"===node.type?this.checkDeclaration(node.argument):"AssignmentPattern"===node.type&&this.checkDeclaration(node.left);}checkDuplicateExports(node,exportName){this.exportedIdentifiers.has(exportName)&&("default"===exportName?this.raise(Errors.DuplicateDefaultExport,node):this.raise(Errors.DuplicateExport,node,{exportName})),this.exportedIdentifiers.add(exportName);}parseExportSpecifiers(isInTypeExport){const nodes=[];let first=true;for(this.expect(5);!this.eat(8);){if(first)first=false;else if(this.expect(12),this.eat(8))break;const isMaybeTypeOnly=this.isContextual(130),isString=this.match(134),node=this.startNode();node.local=this.parseModuleExportName(),nodes.push(this.parseExportSpecifier(node,isString,isInTypeExport,isMaybeTypeOnly));}return nodes}parseExportSpecifier(node,isString,isInTypeExport,isMaybeTypeOnly){return this.eatContextual(93)?node.exported=this.parseModuleExportName():isString?node.exported=cloneStringLiteral(node.local):node.exported||(node.exported=cloneIdentifier(node.local)),this.finishNode(node,"ExportSpecifier")}parseModuleExportName(){if(this.match(134)){const result=this.parseStringLiteral(this.state.value),surrogate=loneSurrogate.exec(result.value);return surrogate&&this.raise(Errors.ModuleExportNameHasLoneSurrogate,result,{surrogateCharCode:surrogate[0].charCodeAt(0)}),result}return this.parseIdentifier(true)}isJSONModuleImport(node){return null!=node.assertions&&node.assertions.some((({key,value})=>"json"===value.value&&("Identifier"===key.type?"type"===key.name:"type"===key.value)))}checkImportReflection(node){const{specifiers}=node,singleBindingType=1===specifiers.length?specifiers[0].type:null;if("source"===node.phase)"ImportDefaultSpecifier"!==singleBindingType&&this.raise(Errors.SourcePhaseImportRequiresDefault,specifiers[0].loc.start);else if("defer"===node.phase)"ImportNamespaceSpecifier"!==singleBindingType&&this.raise(Errors.DeferImportRequiresNamespace,specifiers[0].loc.start);else if(node.module){var _node$assertions;"ImportDefaultSpecifier"!==singleBindingType&&this.raise(Errors.ImportReflectionNotBinding,specifiers[0].loc.start),(null==(_node$assertions=node.assertions)?void 0:_node$assertions.length)>0&&this.raise(Errors.ImportReflectionHasAssertion,specifiers[0].loc.start);}}checkJSONModuleImport(node){if(this.isJSONModuleImport(node)&&"ExportAllDeclaration"!==node.type){const{specifiers}=node;if(null!=specifiers){const nonDefaultNamedSpecifier=specifiers.find((specifier=>{let imported;if("ExportSpecifier"===specifier.type?imported=specifier.local:"ImportSpecifier"===specifier.type&&(imported=specifier.imported),void 0!==imported)return "Identifier"===imported.type?"default"!==imported.name:"default"!==imported.value}));void 0!==nonDefaultNamedSpecifier&&this.raise(Errors.ImportJSONBindingNotDefault,nonDefaultNamedSpecifier.loc.start);}}}isPotentialImportPhase(isExport){return !isExport&&(this.isContextual(105)||this.isContextual(97)||this.isContextual(127))}applyImportPhase(node,isExport,phase,loc){isExport||("module"===phase?(this.expectPlugin("importReflection",loc),node.module=true):this.hasPlugin("importReflection")&&(node.module=false),"source"===phase?(this.expectPlugin("sourcePhaseImports",loc),node.phase="source"):"defer"===phase?(this.expectPlugin("deferredImportEvaluation",loc),node.phase="defer"):this.hasPlugin("sourcePhaseImports")&&(node.phase=null));}parseMaybeImportPhase(node,isExport){if(!this.isPotentialImportPhase(isExport))return this.applyImportPhase(node,isExport,null),null;const phaseIdentifier=this.parseIdentifier(true),{type}=this.state;return (tokenIsKeywordOrIdentifier(type)?98!==type||102===this.lookaheadCharCode():12!==type)?(this.resetPreviousIdentifierLeadingComments(phaseIdentifier),this.applyImportPhase(node,isExport,phaseIdentifier.name,phaseIdentifier.loc.start),null):(this.applyImportPhase(node,isExport,null),phaseIdentifier)}isPrecedingIdImportPhase(phase){const{type}=this.state;return tokenIsIdentifier(type)?98!==type||102===this.lookaheadCharCode():12!==type}parseImport(node){return this.match(134)?this.parseImportSourceAndAttributes(node):this.parseImportSpecifiersAndAfter(node,this.parseMaybeImportPhase(node,false))}parseImportSpecifiersAndAfter(node,maybeDefaultIdentifier){node.specifiers=[];const parseNext=!this.maybeParseDefaultImportSpecifier(node,maybeDefaultIdentifier)||this.eat(12),hasStar=parseNext&&this.maybeParseStarImportSpecifier(node);return parseNext&&!hasStar&&this.parseNamedImportSpecifiers(node),this.expectContextual(98),this.parseImportSourceAndAttributes(node)}parseImportSourceAndAttributes(node){return null!=node.specifiers||(node.specifiers=[]),node.source=this.parseImportSource(),this.maybeParseImportAttributes(node),this.checkImportReflection(node),this.checkJSONModuleImport(node),this.semicolon(),this.finishNode(node,"ImportDeclaration")}parseImportSource(){return this.match(134)||this.unexpected(),this.parseExprAtom()}parseImportSpecifierLocal(node,specifier,type){specifier.local=this.parseIdentifier(),node.specifiers.push(this.finishImportSpecifier(specifier,type));}finishImportSpecifier(specifier,type,bindingType=8201){return this.checkLVal(specifier.local,{type},bindingType),this.finishNode(specifier,type)}parseImportAttributes(){this.expect(5);const attrs=[],attrNames=new Set;do{if(this.match(8))break;const node=this.startNode(),keyName=this.state.value;if(attrNames.has(keyName)&&this.raise(Errors.ModuleAttributesWithDuplicateKeys,this.state.startLoc,{key:keyName}),attrNames.add(keyName),this.match(134)?node.key=this.parseStringLiteral(keyName):node.key=this.parseIdentifier(true),this.expect(14),!this.match(134))throw this.raise(Errors.ModuleAttributeInvalidValue,this.state.startLoc);node.value=this.parseStringLiteral(this.state.value),attrs.push(this.finishNode(node,"ImportAttribute"));}while(this.eat(12));return this.expect(8),attrs}parseModuleAttributes(){const attrs=[],attributes=new Set;do{const node=this.startNode();if(node.key=this.parseIdentifier(true),"type"!==node.key.name&&this.raise(Errors.ModuleAttributeDifferentFromType,node.key),attributes.has(node.key.name)&&this.raise(Errors.ModuleAttributesWithDuplicateKeys,node.key,{key:node.key.name}),attributes.add(node.key.name),this.expect(14),!this.match(134))throw this.raise(Errors.ModuleAttributeInvalidValue,this.state.startLoc);node.value=this.parseStringLiteral(this.state.value),attrs.push(this.finishNode(node,"ImportAttribute"));}while(this.eat(12));return attrs}maybeParseImportAttributes(node){let attributes;var useWith=false;if(this.match(76)){if(this.hasPrecedingLineBreak()&&40===this.lookaheadCharCode())return;this.next(),attributes=this.hasPlugin("moduleAttributes")?this.parseModuleAttributes():this.parseImportAttributes(),useWith=true;}else this.isContextual(94)&&!this.hasPrecedingLineBreak()?(this.hasPlugin("deprecatedImportAssert")||this.hasPlugin("importAssertions")||this.raise(Errors.ImportAttributesUseAssert,this.state.startLoc),this.hasPlugin("importAssertions")||this.addExtra(node,"deprecatedAssertSyntax",true),this.next(),attributes=this.parseImportAttributes()):attributes=[];!useWith&&this.hasPlugin("importAssertions")?node.assertions=attributes:node.attributes=attributes;}maybeParseDefaultImportSpecifier(node,maybeDefaultIdentifier){if(maybeDefaultIdentifier){const specifier=this.startNodeAtNode(maybeDefaultIdentifier);return specifier.local=maybeDefaultIdentifier,node.specifiers.push(this.finishImportSpecifier(specifier,"ImportDefaultSpecifier")),true}return !!tokenIsKeywordOrIdentifier(this.state.type)&&(this.parseImportSpecifierLocal(node,this.startNode(),"ImportDefaultSpecifier"),true)}maybeParseStarImportSpecifier(node){if(this.match(55)){const specifier=this.startNode();return this.next(),this.expectContextual(93),this.parseImportSpecifierLocal(node,specifier,"ImportNamespaceSpecifier"),true}return  false}parseNamedImportSpecifiers(node){let first=true;for(this.expect(5);!this.eat(8);){if(first)first=false;else {if(this.eat(14))throw this.raise(Errors.DestructureNamedImport,this.state.startLoc);if(this.expect(12),this.eat(8))break}const specifier=this.startNode(),importedIsString=this.match(134),isMaybeTypeOnly=this.isContextual(130);specifier.imported=this.parseModuleExportName();const importSpecifier=this.parseImportSpecifier(specifier,importedIsString,"type"===node.importKind||"typeof"===node.importKind,isMaybeTypeOnly,void 0);node.specifiers.push(importSpecifier);}}parseImportSpecifier(specifier,importedIsString,isInTypeOnlyImport,isMaybeTypeOnly,bindingType){if(this.eatContextual(93))specifier.local=this.parseIdentifier();else {const{imported}=specifier;if(importedIsString)throw this.raise(Errors.ImportBindingIsString,specifier,{importName:imported.value});this.checkReservedWord(imported.name,specifier.loc.start,true,true),specifier.local||(specifier.local=cloneIdentifier(imported));}return this.finishImportSpecifier(specifier,"ImportSpecifier",bindingType)}isThisParam(param){return "Identifier"===param.type&&"this"===param.name}}class Parser extends StatementParser{constructor(options,input,pluginsMap){super(options=function(opts){const options={sourceType:"script",sourceFilename:void 0,startIndex:0,startColumn:0,startLine:1,allowAwaitOutsideFunction:false,allowReturnOutsideFunction:false,allowNewTargetOutsideFunction:false,allowImportExportEverywhere:false,allowSuperOutsideMethod:false,allowUndeclaredExports:false,plugins:[],strictMode:null,ranges:false,tokens:false,createImportExpressions:false,createParenthesizedExpressions:false,errorRecovery:false,attachComment:true,annexB:true};if(null==opts)return options;if(null!=opts.annexB&&false!==opts.annexB)throw new Error("The `annexB` option can only be set to `false`.");for(const key of Object.keys(options))null!=opts[key]&&(options[key]=opts[key]);if(1===options.startLine)null==opts.startIndex&&options.startColumn>0?options.startIndex=options.startColumn:null==opts.startColumn&&options.startIndex>0&&(options.startColumn=options.startIndex);else if((null==opts.startColumn||null==opts.startIndex)&&null!=opts.startIndex)throw new Error("With a `startLine > 1` you must also specify `startIndex` and `startColumn`.");return options}(options),input),this.options=options,this.initializeScopes(),this.plugins=pluginsMap,this.filename=options.sourceFilename,this.startIndex=options.startIndex;}getScopeHandler(){return ScopeHandler}parse(){this.enterInitialScopes();const file=this.startNode(),program=this.startNode();return this.nextToken(),file.errors=null,this.parseTopLevel(file,program),file.errors=this.state.errors,file.comments.length=this.state.commentsLen,file}}const tokTypes=function(internalTokenTypes){const tokenTypes={};for(const typeName of Object.keys(internalTokenTypes))tokenTypes[typeName]=getExportedToken(internalTokenTypes[typeName]);return tokenTypes}(tt);function getParser(options,input){let cls=Parser;const pluginsMap=new Map;if(null!=options&&options.plugins){for(const plugin of options.plugins){let name,opts;"string"==typeof plugin?name=plugin:[name,opts]=plugin,pluginsMap.has(name)||pluginsMap.set(name,opts||{});}!function(pluginsMap){if(pluginsMap.has("decorators")){if(pluginsMap.has("decorators-legacy"))throw new Error("Cannot use the decorators and decorators-legacy plugin together");const decoratorsBeforeExport=pluginsMap.get("decorators").decoratorsBeforeExport;if(null!=decoratorsBeforeExport&&"boolean"!=typeof decoratorsBeforeExport)throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");const allowCallParenthesized=pluginsMap.get("decorators").allowCallParenthesized;if(null!=allowCallParenthesized&&"boolean"!=typeof allowCallParenthesized)throw new Error("'allowCallParenthesized' must be a boolean.")}if(pluginsMap.has("flow")&&pluginsMap.has("typescript"))throw new Error("Cannot combine flow and typescript plugins.");if(pluginsMap.has("placeholders")&&pluginsMap.has("v8intrinsic"))throw new Error("Cannot combine placeholders and v8intrinsic plugins.");if(pluginsMap.has("pipelineOperator")){var _pluginsMap$get;const proposal=pluginsMap.get("pipelineOperator").proposal;if(!PIPELINE_PROPOSALS.includes(proposal)){const proposalList=PIPELINE_PROPOSALS.map((p=>`"${p}"`)).join(", ");throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${proposalList}.`)}const tupleSyntaxIsHash="hash"===(null==(_pluginsMap$get=pluginsMap.get("recordAndTuple"))?void 0:_pluginsMap$get.syntaxType);if("hack"===proposal){if(pluginsMap.has("placeholders"))throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");if(pluginsMap.has("v8intrinsic"))throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");const topicToken=pluginsMap.get("pipelineOperator").topicToken;if(!TOPIC_TOKENS.includes(topicToken)){const tokenList=TOPIC_TOKENS.map((t=>`"${t}"`)).join(", ");throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${tokenList}.`)}if("#"===topicToken&&tupleSyntaxIsHash)throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "hack", topicToken: "#" }]\` and \`${JSON.stringify(["recordAndTuple",pluginsMap.get("recordAndTuple")])}\`.`)}else if("smart"===proposal&&tupleSyntaxIsHash)throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "smart" }]\` and \`${JSON.stringify(["recordAndTuple",pluginsMap.get("recordAndTuple")])}\`.`)}if(pluginsMap.has("moduleAttributes")){if(pluginsMap.has("deprecatedImportAssert")||pluginsMap.has("importAssertions"))throw new Error("Cannot combine importAssertions, deprecatedImportAssert and moduleAttributes plugins.");if("may-2020"!==pluginsMap.get("moduleAttributes").version)throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.")}if(pluginsMap.has("importAssertions")&&pluginsMap.has("deprecatedImportAssert"))throw new Error("Cannot combine importAssertions and deprecatedImportAssert plugins.");if(!pluginsMap.has("deprecatedImportAssert")&&pluginsMap.has("importAttributes")&&pluginsMap.get("importAttributes").deprecatedAssertSyntax&&pluginsMap.set("deprecatedImportAssert",{}),pluginsMap.has("recordAndTuple")){const syntaxType=pluginsMap.get("recordAndTuple").syntaxType;if(null!=syntaxType){const RECORD_AND_TUPLE_SYNTAX_TYPES=["hash","bar"];if(!RECORD_AND_TUPLE_SYNTAX_TYPES.includes(syntaxType))throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: "+RECORD_AND_TUPLE_SYNTAX_TYPES.map((p=>`'${p}'`)).join(", "))}}if(pluginsMap.has("asyncDoExpressions")&&!pluginsMap.has("doExpressions")){const error=new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");throw error.missingPlugins="doExpressions",error}if(pluginsMap.has("optionalChainingAssign")&&"2023-07"!==pluginsMap.get("optionalChainingAssign").version)throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is '2023-07'.")}(pluginsMap),cls=function(pluginsMap){const pluginList=[];for(const name of mixinPluginNames)pluginsMap.has(name)&&pluginList.push(name);const key=pluginList.join("|");let cls=parserClassCache.get(key);if(!cls){cls=Parser;for(const plugin of pluginList)cls=mixinPlugins[plugin](cls);parserClassCache.set(key,cls);}return cls}(pluginsMap);}return new cls(options,input,pluginsMap)}const parserClassCache=new Map;exports.parse=function(input,options){var _options;if("unambiguous"!==(null==(_options=options)?void 0:_options.sourceType))return getParser(options,input).parse();options=Object.assign({},options);try{options.sourceType="module";const parser=getParser(options,input),ast=parser.parse();if(parser.sawUnambiguousESM)return ast;if(parser.ambiguousScriptDifferentAst)try{return options.sourceType="script",getParser(options,input).parse()}catch(_unused){}else ast.program.sourceType="script";return ast}catch(moduleError){try{return options.sourceType="script",getParser(options,input).parse()}catch(_unused2){}throw moduleError}},exports.parseExpression=function(input,options){const parser=getParser(options,input);return parser.options.strictMode&&(parser.state.strict=true),parser.getExpression()},exports.tokTypes=tokTypes;},"./node_modules/.pnpm/@babel+plugin-proposal-decorators@7.25.9_@babel+core@7.26.0/node_modules/@babel/plugin-proposal-decorators/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{exports.A=void 0;var _helperPluginUtils=__webpack_require__("./node_modules/.pnpm/@babel+helper-plugin-utils@7.25.9/node_modules/@babel/helper-plugin-utils/lib/index.js"),_pluginSyntaxDecorators=__webpack_require__("./node_modules/.pnpm/@babel+plugin-syntax-decorators@7.25.9_@babel+core@7.26.0/node_modules/@babel/plugin-syntax-decorators/lib/index.js"),_helperCreateClassFeaturesPlugin=__webpack_require__("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.25.9_@babel+core@7.26.0/node_modules/@babel/helper-create-class-features-plugin/lib/index.js"),_transformerLegacy=__webpack_require__("./node_modules/.pnpm/@babel+plugin-proposal-decorators@7.25.9_@babel+core@7.26.0/node_modules/@babel/plugin-proposal-decorators/lib/transformer-legacy.js");exports.A=(0, _helperPluginUtils.declare)(((api,options)=>{api.assertVersion(7);var{legacy}=options;const{version}=options;if(legacy||"legacy"===version)return {name:"proposal-decorators",inherits:_pluginSyntaxDecorators.default,visitor:_transformerLegacy.default};if(version&&"2018-09"!==version&&"2021-12"!==version&&"2022-03"!==version&&"2023-01"!==version&&"2023-05"!==version&&"2023-11"!==version)throw new Error("The '.version' option must be one of 'legacy', '2023-11', '2023-05', '2023-01', '2022-03', or '2021-12'.");return api.assertVersion("^7.0.2"),(0, _helperCreateClassFeaturesPlugin.createClassFeaturePlugin)({name:"proposal-decorators",api,feature:_helperCreateClassFeaturesPlugin.FEATURES.decorators,inherits:_pluginSyntaxDecorators.default,decoratorVersion:version})}));},"./node_modules/.pnpm/@babel+plugin-proposal-decorators@7.25.9_@babel+core@7.26.0/node_modules/@babel/plugin-proposal-decorators/lib/transformer-legacy.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=void 0;var _core=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/index.js");const buildClassDecorator=_core.template.statement("\n  DECORATOR(CLASS_REF = INNER) || CLASS_REF;\n"),buildClassPrototype=(0, _core.template)("\n  CLASS_REF.prototype;\n"),buildGetDescriptor=(0, _core.template)("\n    Object.getOwnPropertyDescriptor(TARGET, PROPERTY);\n"),buildGetObjectInitializer=(0, _core.template)("\n    (TEMP = Object.getOwnPropertyDescriptor(TARGET, PROPERTY), (TEMP = TEMP ? TEMP.value : undefined), {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        initializer: function(){\n            return TEMP;\n        }\n    })\n"),WARNING_CALLS=new WeakSet;function applyEnsureOrdering(path){const identDecorators=(path.isClass()?[path,...path.get("body.body")]:path.get("properties")).reduce(((acc,prop)=>acc.concat(prop.node.decorators||[])),[]).filter((decorator=>!_core.types.isIdentifier(decorator.expression)));if(0!==identDecorators.length)return _core.types.sequenceExpression(identDecorators.map((decorator=>{const expression=decorator.expression,id=decorator.expression=path.scope.generateDeclaredUidIdentifier("dec");return _core.types.assignmentExpression("=",id,expression)})).concat([path.node]))}function hasClassDecorators(classNode){var _classNode$decorators;return !(null==(_classNode$decorators=classNode.decorators)||!_classNode$decorators.length)}function hasMethodDecorators(body){return body.some((node=>{var _node$decorators;return null==(_node$decorators=node.decorators)?void 0:_node$decorators.length}))}function applyTargetDecorators(path,state,decoratedProps){const name=path.scope.generateDeclaredUidIdentifier(path.isClass()?"class":"obj"),exprs=decoratedProps.reduce((function(acc,node){let decorators=[];if(null!=node.decorators&&(decorators=node.decorators,node.decorators=null),0===decorators.length)return acc;if(node.computed)throw path.buildCodeFrameError("Computed method/property decorators are not yet supported.");const property=_core.types.isLiteral(node.key)?node.key:_core.types.stringLiteral(node.key.name),target=path.isClass()&&!node.static?buildClassPrototype({CLASS_REF:name}).expression:name;if(_core.types.isClassProperty(node,{static:false})){const descriptor=path.scope.generateDeclaredUidIdentifier("descriptor"),initializer=node.value?_core.types.functionExpression(null,[],_core.types.blockStatement([_core.types.returnStatement(node.value)])):_core.types.nullLiteral();node.value=_core.types.callExpression(state.addHelper("initializerWarningHelper"),[descriptor,_core.types.thisExpression()]),WARNING_CALLS.add(node.value),acc.push(_core.types.assignmentExpression("=",_core.types.cloneNode(descriptor),_core.types.callExpression(state.addHelper("applyDecoratedDescriptor"),[_core.types.cloneNode(target),_core.types.cloneNode(property),_core.types.arrayExpression(decorators.map((dec=>_core.types.cloneNode(dec.expression)))),_core.types.objectExpression([_core.types.objectProperty(_core.types.identifier("configurable"),_core.types.booleanLiteral(true)),_core.types.objectProperty(_core.types.identifier("enumerable"),_core.types.booleanLiteral(true)),_core.types.objectProperty(_core.types.identifier("writable"),_core.types.booleanLiteral(true)),_core.types.objectProperty(_core.types.identifier("initializer"),initializer)])])));}else acc.push(_core.types.callExpression(state.addHelper("applyDecoratedDescriptor"),[_core.types.cloneNode(target),_core.types.cloneNode(property),_core.types.arrayExpression(decorators.map((dec=>_core.types.cloneNode(dec.expression)))),_core.types.isObjectProperty(node)||_core.types.isClassProperty(node,{static:true})?buildGetObjectInitializer({TEMP:path.scope.generateDeclaredUidIdentifier("init"),TARGET:_core.types.cloneNode(target),PROPERTY:_core.types.cloneNode(property)}).expression:buildGetDescriptor({TARGET:_core.types.cloneNode(target),PROPERTY:_core.types.cloneNode(property)}).expression,_core.types.cloneNode(target)]));return acc}),[]);return _core.types.sequenceExpression([_core.types.assignmentExpression("=",_core.types.cloneNode(name),path.node),_core.types.sequenceExpression(exprs),_core.types.cloneNode(name)])}function decoratedClassToExpression({node,scope}){if(!hasClassDecorators(node)&&!hasMethodDecorators(node.body.body))return;const ref=node.id?_core.types.cloneNode(node.id):scope.generateUidIdentifier("class");return _core.types.variableDeclaration("let",[_core.types.variableDeclarator(ref,_core.types.toExpression(node))])}const visitor={ExportDefaultDeclaration(path){const decl=path.get("declaration");if(!decl.isClassDeclaration())return;const replacement=decoratedClassToExpression(decl);if(replacement){const[varDeclPath]=path.replaceWithMultiple([replacement,_core.types.exportNamedDeclaration(null,[_core.types.exportSpecifier(_core.types.cloneNode(replacement.declarations[0].id),_core.types.identifier("default"))])]);decl.node.id||path.scope.registerDeclaration(varDeclPath);}},ClassDeclaration(path){const replacement=decoratedClassToExpression(path);if(replacement){const[newPath]=path.replaceWith(replacement),decl=newPath.get("declarations.0"),id=decl.node.id,binding=path.scope.getOwnBinding(id.name);binding.identifier=id,binding.path=decl;}},ClassExpression(path,state){const decoratedClass=applyEnsureOrdering(path)||function(classPath){if(!hasClassDecorators(classPath.node))return;const decorators=classPath.node.decorators||[];classPath.node.decorators=null;const name=classPath.scope.generateDeclaredUidIdentifier("class");return decorators.map((dec=>dec.expression)).reverse().reduce((function(acc,decorator){return buildClassDecorator({CLASS_REF:_core.types.cloneNode(name),DECORATOR:_core.types.cloneNode(decorator),INNER:acc}).expression}),classPath.node)}(path)||function(path,state){if(hasMethodDecorators(path.node.body.body))return applyTargetDecorators(path,state,path.node.body.body)}(path,state);decoratedClass&&path.replaceWith(decoratedClass);},ObjectExpression(path,state){const decoratedObject=applyEnsureOrdering(path)||function(path,state){if(hasMethodDecorators(path.node.properties))return applyTargetDecorators(path,state,path.node.properties.filter((prop=>"SpreadElement"!==prop.type)))}(path,state);decoratedObject&&path.replaceWith(decoratedObject);},AssignmentExpression(path,state){WARNING_CALLS.has(path.node.right)&&path.replaceWith(_core.types.callExpression(state.addHelper("initializerDefineProperty"),[_core.types.cloneNode(path.get("left.object").node),_core.types.stringLiteral(path.get("left.property").node.name||path.get("left.property").node.value),_core.types.cloneNode(path.get("right.arguments")[0].node),_core.types.cloneNode(path.get("right.arguments")[1].node)]));},CallExpression(path,state){3===path.node.arguments.length&&WARNING_CALLS.has(path.node.arguments[2])&&path.node.callee.name===state.addHelper("defineProperty").name&&path.replaceWith(_core.types.callExpression(state.addHelper("initializerDefineProperty"),[_core.types.cloneNode(path.get("arguments")[0].node),_core.types.cloneNode(path.get("arguments")[1].node),_core.types.cloneNode(path.get("arguments.2.arguments")[0].node),_core.types.cloneNode(path.get("arguments.2.arguments")[1].node)]));}};exports.default=visitor;},"./node_modules/.pnpm/@babel+plugin-syntax-decorators@7.25.9_@babel+core@7.26.0/node_modules/@babel/plugin-syntax-decorators/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=void 0;var _helperPluginUtils=__webpack_require__("./node_modules/.pnpm/@babel+helper-plugin-utils@7.25.9/node_modules/@babel/helper-plugin-utils/lib/index.js");exports.default=(0, _helperPluginUtils.declare)(((api,options)=>{api.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");let{version}=options;{const{legacy}=options;if(void 0!==legacy){if("boolean"!=typeof legacy)throw new Error(".legacy must be a boolean.");if(void 0!==version)throw new Error("You can either use the .legacy or the .version option, not both.")}if(void 0===version)version=legacy?"legacy":"2018-09";else if("2023-11"!==version&&"2023-05"!==version&&"2023-01"!==version&&"2022-03"!==version&&"2021-12"!==version&&"2018-09"!==version&&"legacy"!==version)throw new Error("Unsupported decorators version: "+version);var{decoratorsBeforeExport}=options;if(void 0===decoratorsBeforeExport){if("2021-12"===version||"2022-03"===version)decoratorsBeforeExport=false;else if("2018-09"===version)throw new Error("The decorators plugin, when .version is '2018-09' or not specified, requires a 'decoratorsBeforeExport' option, whose value must be a boolean.")}else {if("legacy"===version||"2022-03"===version||"2023-01"===version)throw new Error(`'decoratorsBeforeExport' can't be used with ${version} decorators.`);if("boolean"!=typeof decoratorsBeforeExport)throw new Error("'decoratorsBeforeExport' must be a boolean.")}}return {name:"syntax-decorators",manipulateOptions({generatorOpts},parserOpts){"legacy"===version?parserOpts.plugins.push("decorators-legacy"):"2023-01"===version||"2023-05"===version||"2023-11"===version?parserOpts.plugins.push(["decorators",{allowCallParenthesized:false}],"decoratorAutoAccessors"):"2022-03"===version?parserOpts.plugins.push(["decorators",{decoratorsBeforeExport:false,allowCallParenthesized:false}],"decoratorAutoAccessors"):"2021-12"===version?(parserOpts.plugins.push(["decorators",{decoratorsBeforeExport}],"decoratorAutoAccessors"),generatorOpts.decoratorsBeforeExport=decoratorsBeforeExport):"2018-09"===version&&(parserOpts.plugins.push(["decorators",{decoratorsBeforeExport}]),generatorOpts.decoratorsBeforeExport=decoratorsBeforeExport);}}}));},"./node_modules/.pnpm/@babel+plugin-syntax-import-assertions@7.26.0_@babel+core@7.26.0/node_modules/@babel/plugin-syntax-import-assertions/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{exports.A=void 0;var _helperPluginUtils=__webpack_require__("./node_modules/.pnpm/@babel+helper-plugin-utils@7.25.9/node_modules/@babel/helper-plugin-utils/lib/index.js");exports.A=(0, _helperPluginUtils.declare)((api=>{api.assertVersion(7);const isPlugin=(plugin,name)=>"plugin"===name||Array.isArray(plugin)&&"plugin"===plugin[0],options=plugin=>Array.isArray(plugin)&&plugin.length>1?plugin[1]:{};return {name:"syntax-import-assertions",manipulateOptions(opts,{plugins}){for(let i=0;i<plugins.length;i++){const plugin=plugins[i];if(isPlugin(plugin,"deprecatedImportAssert"))return;if(isPlugin(plugin,"importAttributes"))return void plugins.splice(i,1,"deprecatedImportAssert",["importAttributes",Object.assign({},options(plugin),{deprecatedAssertSyntax:true})])}plugins.push("importAssertions");}}}));},"./node_modules/.pnpm/@babel+plugin-syntax-jsx@7.25.9_@babel+core@7.26.0/node_modules/@babel/plugin-syntax-jsx/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=void 0;var _helperPluginUtils=__webpack_require__("./node_modules/.pnpm/@babel+helper-plugin-utils@7.25.9/node_modules/@babel/helper-plugin-utils/lib/index.js");exports.default=(0, _helperPluginUtils.declare)((api=>(api.assertVersion(7),{name:"syntax-jsx",manipulateOptions(opts,parserOpts){parserOpts.plugins.some((p=>"typescript"===(Array.isArray(p)?p[0]:p)))||parserOpts.plugins.push("jsx");}})));},"./node_modules/.pnpm/@babel+plugin-syntax-typescript@7.25.9_@babel+core@7.26.0/node_modules/@babel/plugin-syntax-typescript/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=void 0;var _helperPluginUtils=__webpack_require__("./node_modules/.pnpm/@babel+helper-plugin-utils@7.25.9/node_modules/@babel/helper-plugin-utils/lib/index.js"),removePlugin=function(plugins,name){const indices=[];plugins.forEach(((plugin,i)=>{(Array.isArray(plugin)?plugin[0]:plugin)===name&&indices.unshift(i);}));for(const i of indices)plugins.splice(i,1);};exports.default=(0, _helperPluginUtils.declare)(((api,opts)=>{api.assertVersion(7);const{disallowAmbiguousJSXLike,dts}=opts;var{isTSX}=opts;return {name:"syntax-typescript",manipulateOptions(opts,parserOpts){{const{plugins}=parserOpts;removePlugin(plugins,"flow"),removePlugin(plugins,"jsx"),plugins.push("objectRestSpread","classProperties"),isTSX&&plugins.push("jsx");}parserOpts.plugins.push(["typescript",{disallowAmbiguousJSXLike,dts}]);}}}));},"./node_modules/.pnpm/@babel+plugin-transform-export-namespace-from@7.25.9_@babel+core@7.26.0/node_modules/@babel/plugin-transform-export-namespace-from/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{exports.A=void 0;var _helperPluginUtils=__webpack_require__("./node_modules/.pnpm/@babel+helper-plugin-utils@7.25.9/node_modules/@babel/helper-plugin-utils/lib/index.js"),_core=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/index.js");exports.A=(0, _helperPluginUtils.declare)((api=>(api.assertVersion(7),{name:"transform-export-namespace-from",manipulateOptions:(_,parser)=>parser.plugins.push("exportNamespaceFrom"),visitor:{ExportNamedDeclaration(path){var _exported$name;const{node,scope}=path,{specifiers}=node,index=_core.types.isExportDefaultSpecifier(specifiers[0])?1:0;if(!_core.types.isExportNamespaceSpecifier(specifiers[index]))return;const nodes=[];1===index&&nodes.push(_core.types.exportNamedDeclaration(null,[specifiers.shift()],node.source));const specifier=specifiers.shift(),{exported}=specifier,uid=scope.generateUidIdentifier(null!=(_exported$name=exported.name)?_exported$name:exported.value);nodes.push(_core.types.importDeclaration([_core.types.importNamespaceSpecifier(uid)],_core.types.cloneNode(node.source)),_core.types.exportNamedDeclaration(null,[_core.types.exportSpecifier(_core.types.cloneNode(uid),exported)])),node.specifiers.length>=1&&nodes.push(node);const[importDeclaration]=path.replaceWithMultiple(nodes);path.scope.registerDeclaration(importDeclaration);}}})));},"./node_modules/.pnpm/@babel+plugin-transform-modules-commonjs@7.26.3_@babel+core@7.26.0/node_modules/@babel/plugin-transform-modules-commonjs/lib/dynamic-import.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.transformDynamicImport=function(path,noInterop,file){const buildRequire=noInterop?requireNoInterop:requireInterop;path.replaceWith((0, _helperModuleTransforms.buildDynamicImport)(path.node,true,false,(specifier=>buildRequire(specifier,file))));};var _core=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/index.js"),_helperModuleTransforms=__webpack_require__("./node_modules/.pnpm/@babel+helper-module-transforms@7.26.0_@babel+core@7.26.0/node_modules/@babel/helper-module-transforms/lib/index.js");const requireNoInterop=source=>_core.template.expression.ast`require(${source})`,requireInterop=(source,file)=>_core.types.callExpression(file.addHelper("interopRequireWildcard"),[requireNoInterop(source)]);},"./node_modules/.pnpm/@babel+plugin-transform-modules-commonjs@7.26.3_@babel+core@7.26.0/node_modules/@babel/plugin-transform-modules-commonjs/lib/hooks.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.defineCommonJSHook=function(file,hook){let hooks=file.get(commonJSHooksKey);hooks||file.set(commonJSHooksKey,hooks=[]);hooks.push(hook);},exports.makeInvokers=function(file){const hooks=file.get(commonJSHooksKey);return {getWrapperPayload:(...args)=>findMap(hooks,(hook=>null==hook.getWrapperPayload?void 0:hook.getWrapperPayload(...args))),wrapReference:(...args)=>findMap(hooks,(hook=>null==hook.wrapReference?void 0:hook.wrapReference(...args))),buildRequireWrapper:(...args)=>findMap(hooks,(hook=>null==hook.buildRequireWrapper?void 0:hook.buildRequireWrapper(...args)))}};const commonJSHooksKey="@babel/plugin-transform-modules-commonjs/customWrapperPlugin";function findMap(arr,cb){if(arr)for(const el of arr){const res=cb(el);if(null!=res)return res}}},"./node_modules/.pnpm/@babel+plugin-transform-modules-commonjs@7.26.3_@babel+core@7.26.0/node_modules/@babel/plugin-transform-modules-commonjs/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=void 0,Object.defineProperty(exports,"defineCommonJSHook",{enumerable:true,get:function(){return _hooks.defineCommonJSHook}});var _helperPluginUtils=__webpack_require__("./node_modules/.pnpm/@babel+helper-plugin-utils@7.25.9/node_modules/@babel/helper-plugin-utils/lib/index.js"),_helperModuleTransforms=__webpack_require__("./node_modules/.pnpm/@babel+helper-module-transforms@7.26.0_@babel+core@7.26.0/node_modules/@babel/helper-module-transforms/lib/index.js"),_core=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/index.js"),_dynamicImport=__webpack_require__("./node_modules/.pnpm/@babel+plugin-transform-modules-commonjs@7.26.3_@babel+core@7.26.0/node_modules/@babel/plugin-transform-modules-commonjs/lib/dynamic-import.js"),_lazy=__webpack_require__("./node_modules/.pnpm/@babel+plugin-transform-modules-commonjs@7.26.3_@babel+core@7.26.0/node_modules/@babel/plugin-transform-modules-commonjs/lib/lazy.js"),_hooks=__webpack_require__("./node_modules/.pnpm/@babel+plugin-transform-modules-commonjs@7.26.3_@babel+core@7.26.0/node_modules/@babel/plugin-transform-modules-commonjs/lib/hooks.js");exports.default=(0, _helperPluginUtils.declare)(((api,options)=>{var _api$assumption,_api$assumption2,_api$assumption3;api.assertVersion(7);const{strictNamespace=false,mjsStrictNamespace=strictNamespace,allowTopLevelThis,strict,strictMode,noInterop,importInterop,lazy=false,allowCommonJSExports=true,loose=false}=options,constantReexports=null!=(_api$assumption=api.assumption("constantReexports"))?_api$assumption:loose,enumerableModuleMeta=null!=(_api$assumption2=api.assumption("enumerableModuleMeta"))?_api$assumption2:loose,noIncompleteNsImportDetection=null!=(_api$assumption3=api.assumption("noIncompleteNsImportDetection"))&&_api$assumption3;if(!("boolean"==typeof lazy||"function"==typeof lazy||Array.isArray(lazy)&&lazy.every((item=>"string"==typeof item))))throw new Error(".lazy must be a boolean, array of strings, or a function");if("boolean"!=typeof strictNamespace)throw new Error(".strictNamespace must be a boolean, or undefined");if("boolean"!=typeof mjsStrictNamespace)throw new Error(".mjsStrictNamespace must be a boolean, or undefined");const getAssertion=localName=>_core.template.expression.ast`
    (function(){
      throw new Error(
        "The CommonJS '" + "${localName}" + "' variable is not available in ES6 modules." +
        "Consider setting setting sourceType:script or sourceType:unambiguous in your " +
        "Babel config for this file.");
    })()
  `,moduleExportsVisitor={ReferencedIdentifier(path){const localName=path.node.name;if("module"!==localName&&"exports"!==localName)return;const localBinding=path.scope.getBinding(localName);this.scope.getBinding(localName)!==localBinding||path.parentPath.isObjectProperty({value:path.node})&&path.parentPath.parentPath.isObjectPattern()||path.parentPath.isAssignmentExpression({left:path.node})||path.isAssignmentExpression({left:path.node})||path.replaceWith(getAssertion(localName));},UpdateExpression(path){const arg=path.get("argument");if(!arg.isIdentifier())return;const localName=arg.node.name;if("module"!==localName&&"exports"!==localName)return;const localBinding=path.scope.getBinding(localName);this.scope.getBinding(localName)===localBinding&&path.replaceWith(_core.types.assignmentExpression(path.node.operator[0]+"=",arg.node,getAssertion(localName)));},AssignmentExpression(path){const left=path.get("left");if(left.isIdentifier()){const localName=left.node.name;if("module"!==localName&&"exports"!==localName)return;const localBinding=path.scope.getBinding(localName);if(this.scope.getBinding(localName)!==localBinding)return;const right=path.get("right");right.replaceWith(_core.types.sequenceExpression([right.node,getAssertion(localName)]));}else if(left.isPattern()){const ids=left.getOuterBindingIdentifiers(),localName=Object.keys(ids).find((localName=>("module"===localName||"exports"===localName)&&this.scope.getBinding(localName)===path.scope.getBinding(localName)));if(localName){const right=path.get("right");right.replaceWith(_core.types.sequenceExpression([right.node,getAssertion(localName)]));}}}};return {name:"transform-modules-commonjs",pre(){this.file.set("@babel/plugin-transform-modules-*","commonjs"),lazy&&(0, _hooks.defineCommonJSHook)(this.file,(0, _lazy.lazyImportsHook)(lazy));},visitor:{["CallExpression"+(api.types.importExpression?"|ImportExpression":"")](path){if(!this.file.has("@babel/plugin-proposal-dynamic-import"))return;if(path.isCallExpression()&&!_core.types.isImport(path.node.callee))return;let{scope}=path;do{scope.rename("require");}while(scope=scope.parent);(0, _dynamicImport.transformDynamicImport)(path,noInterop,this.file);},Program:{exit(path,state){if(!(0, _helperModuleTransforms.isModule)(path))return;path.scope.rename("exports"),path.scope.rename("module"),path.scope.rename("require"),path.scope.rename("__filename"),path.scope.rename("__dirname"),allowCommonJSExports||path.traverse(moduleExportsVisitor,{scope:path.scope});let moduleName=(0, _helperModuleTransforms.getModuleName)(this.file.opts,options);moduleName&&(moduleName=_core.types.stringLiteral(moduleName));const hooks=(0, _hooks.makeInvokers)(this.file),{meta,headers}=(0, _helperModuleTransforms.rewriteModuleStatementsAndPrepareHeader)(path,{exportName:"exports",constantReexports,enumerableModuleMeta,strict,strictMode,allowTopLevelThis,noInterop,importInterop,wrapReference:hooks.wrapReference,getWrapperPayload:hooks.getWrapperPayload,esNamespaceOnly:"string"==typeof state.filename&&/\.mjs$/.test(state.filename)?mjsStrictNamespace:strictNamespace,noIncompleteNsImportDetection,filename:this.file.opts.filename});for(const[source,metadata]of meta.source){const loadExpr=_core.types.callExpression(_core.types.identifier("require"),[_core.types.stringLiteral(source)]);let header;if((0, _helperModuleTransforms.isSideEffectImport)(metadata)){if(lazy&&"function"===metadata.wrap)throw new Error("Assertion failure");header=_core.types.expressionStatement(loadExpr);}else {const init=(0, _helperModuleTransforms.wrapInterop)(path,loadExpr,metadata.interop)||loadExpr;if(metadata.wrap){const res=hooks.buildRequireWrapper(metadata.name,init,metadata.wrap,metadata.referenced);if(false===res)continue;header=res;}null!=header||(header=_core.template.statement.ast`
                var ${metadata.name} = ${init};
              `);}header.loc=metadata.loc,headers.push(header),headers.push(...(0, _helperModuleTransforms.buildNamespaceInitStatements)(meta,metadata,constantReexports,hooks.wrapReference));}(0, _helperModuleTransforms.ensureStatementsHoisted)(headers),path.unshiftContainer("body",headers),path.get("body").forEach((path=>{headers.includes(path.node)&&path.isVariableDeclaration()&&path.scope.registerDeclaration(path);}));}}}}}));},"./node_modules/.pnpm/@babel+plugin-transform-modules-commonjs@7.26.3_@babel+core@7.26.0/node_modules/@babel/plugin-transform-modules-commonjs/lib/lazy.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.lazyImportsHook=void 0;var _core=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/index.js"),_helperModuleTransforms=__webpack_require__("./node_modules/.pnpm/@babel+helper-module-transforms@7.26.0_@babel+core@7.26.0/node_modules/@babel/helper-module-transforms/lib/index.js");exports.lazyImportsHook=lazy=>({name:"@babel/plugin-transform-modules-commonjs/lazy",version:"7.26.3",getWrapperPayload:(source,metadata)=>(0, _helperModuleTransforms.isSideEffectImport)(metadata)||metadata.reexportAll?null:true===lazy?source.includes(".")?null:"lazy/function":Array.isArray(lazy)?lazy.includes(source)?"lazy/function":null:"function"==typeof lazy?lazy(source)?"lazy/function":null:void 0,buildRequireWrapper(name,init,payload,referenced){if("lazy/function"===payload)return !!referenced&&_core.template.statement.ast`
        function ${name}() {
          const data = ${init};
          ${name} = function(){ return data; };
          return data;
        }
      `},wrapReference(ref,payload){if("lazy/function"===payload)return _core.types.callExpression(ref,[])}});},"./node_modules/.pnpm/@babel+plugin-transform-react-jsx@7.25.9_@babel+core@7.26.0/node_modules/@babel/plugin-transform-react-jsx/lib/create-plugin.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function({name,development}){return (0, _helperPluginUtils.declare)(((_,options)=>{const{pure:PURE_ANNOTATION,throwIfNamespace=true,filter,runtime:RUNTIME_DEFAULT=(development?"automatic":"classic"),importSource:IMPORT_SOURCE_DEFAULT=DEFAULT.importSource,pragma:PRAGMA_DEFAULT=DEFAULT.pragma,pragmaFrag:PRAGMA_FRAG_DEFAULT=DEFAULT.pragmaFrag}=options;var{useSpread=false,useBuiltIns=false}=options;if("classic"===RUNTIME_DEFAULT){if("boolean"!=typeof useSpread)throw new Error("transform-react-jsx currently only accepts a boolean option for useSpread (defaults to false)");if("boolean"!=typeof useBuiltIns)throw new Error("transform-react-jsx currently only accepts a boolean option for useBuiltIns (defaults to false)");if(useSpread&&useBuiltIns)throw new Error("transform-react-jsx currently only accepts useBuiltIns or useSpread but not both")}const injectMetaPropertiesVisitor={JSXOpeningElement(path,state){const attributes=[];((function(scope){do{const{path}=scope;if(path.isFunctionParent()&&!path.isArrowFunctionExpression())return !path.isMethod()||("constructor"!==path.node.kind||!isDerivedClass(path.parentPath.parentPath));if(path.isTSModuleBlock())return  false}while(scope=scope.parent);return  true}))(path.scope)&&attributes.push(_core.types.jsxAttribute(_core.types.jsxIdentifier("__self"),_core.types.jsxExpressionContainer(_core.types.thisExpression()))),attributes.push(_core.types.jsxAttribute(_core.types.jsxIdentifier("__source"),_core.types.jsxExpressionContainer(function(path,state){const location=path.node.loc;if(!location)return path.scope.buildUndefinedNode();if(!state.fileNameIdentifier){const{filename=""}=state,fileNameIdentifier=path.scope.generateUidIdentifier("_jsxFileName");path.scope.getProgramParent().push({id:fileNameIdentifier,init:_core.types.stringLiteral(filename)}),state.fileNameIdentifier=fileNameIdentifier;}return function(fileNameIdentifier,lineNumber,column0Based){const fileLineLiteral=null!=lineNumber?_core.types.numericLiteral(lineNumber):_core.types.nullLiteral(),fileColumnLiteral=null!=column0Based?_core.types.numericLiteral(column0Based+1):_core.types.nullLiteral();return _core.template.expression.ast`{
    fileName: ${fileNameIdentifier},
    lineNumber: ${fileLineLiteral},
    columnNumber: ${fileColumnLiteral},
  }`}(_core.types.cloneNode(state.fileNameIdentifier),location.start.line,location.start.column)}(path,state)))),path.pushContainer("attributes",attributes);}};return {name,inherits:_pluginSyntaxJsx.default,visitor:{JSXNamespacedName(path){if(throwIfNamespace)throw path.buildCodeFrameError("Namespace tags are not supported by default. React's JSX doesn't support namespace tags. You can set `throwIfNamespace: false` to bypass this warning.")},JSXSpreadChild(path){throw path.buildCodeFrameError("Spread children are not supported in React.")},Program:{enter(path,state){const{file}=state;let runtime=RUNTIME_DEFAULT,source=IMPORT_SOURCE_DEFAULT,pragma=PRAGMA_DEFAULT,pragmaFrag=PRAGMA_FRAG_DEFAULT,sourceSet=!!options.importSource,pragmaSet=!!options.pragma,pragmaFragSet=!!options.pragmaFrag;if(file.ast.comments)for(const comment of file.ast.comments){const sourceMatches=JSX_SOURCE_ANNOTATION_REGEX.exec(comment.value);sourceMatches&&(source=sourceMatches[1],sourceSet=true);const runtimeMatches=JSX_RUNTIME_ANNOTATION_REGEX.exec(comment.value);runtimeMatches&&(runtime=runtimeMatches[1]);const jsxMatches=JSX_ANNOTATION_REGEX.exec(comment.value);jsxMatches&&(pragma=jsxMatches[1],pragmaSet=true);const jsxFragMatches=JSX_FRAG_ANNOTATION_REGEX.exec(comment.value);jsxFragMatches&&(pragmaFrag=jsxFragMatches[1],pragmaFragSet=true);}if(set(state,"runtime",runtime),"classic"===runtime){if(sourceSet)throw path.buildCodeFrameError("importSource cannot be set when runtime is classic.");const createElement=toMemberExpression(pragma),fragment=toMemberExpression(pragmaFrag);set(state,"id/createElement",(()=>_core.types.cloneNode(createElement))),set(state,"id/fragment",(()=>_core.types.cloneNode(fragment))),set(state,"defaultPure",pragma===DEFAULT.pragma);}else {if("automatic"!==runtime)throw path.buildCodeFrameError('Runtime must be either "classic" or "automatic".');{if(pragmaSet||pragmaFragSet)throw path.buildCodeFrameError("pragma and pragmaFrag cannot be set when runtime is automatic.");const define=(name,id)=>set(state,name,function(pass,path,importName,source){return ()=>{const actualSource=function(source,importName){switch(importName){case "Fragment":return `${source}/${development?"jsx-dev-runtime":"jsx-runtime"}`;case "jsxDEV":return `${source}/jsx-dev-runtime`;case "jsx":case "jsxs":return `${source}/jsx-runtime`;case "createElement":return source}}(source,importName);if((0, _helperModuleImports.isModule)(path)){let reference=get(pass,`imports/${importName}`);return reference?_core.types.cloneNode(reference):(reference=(0, _helperModuleImports.addNamed)(path,importName,actualSource,{importedInterop:"uncompiled",importPosition:"after"}),set(pass,`imports/${importName}`,reference),reference)}{let reference=get(pass,`requires/${actualSource}`);return reference?reference=_core.types.cloneNode(reference):(reference=(0, _helperModuleImports.addNamespace)(path,actualSource,{importedInterop:"uncompiled"}),set(pass,`requires/${actualSource}`,reference)),_core.types.memberExpression(reference,_core.types.identifier(importName))}}}(state,path,id,source));define("id/jsx",development?"jsxDEV":"jsx"),define("id/jsxs",development?"jsxDEV":"jsxs"),define("id/createElement","createElement"),define("id/fragment","Fragment"),set(state,"defaultPure",source===DEFAULT.importSource);}}development&&path.traverse(injectMetaPropertiesVisitor,state);}},JSXFragment:{exit(path,file){let callExpr;callExpr="classic"===get(file,"runtime")?function(path,file){if(filter&&!filter(path.node,file))return;return call(file,"createElement",[get(file,"id/fragment")(),_core.types.nullLiteral(),..._core.types.react.buildChildren(path.node)])}(path,file):function(path,file){const args=[get(file,"id/fragment")()],children=_core.types.react.buildChildren(path.node);args.push(_core.types.objectExpression(children.length>0?[buildChildrenProperty(children)]:[])),development&&args.push(path.scope.buildUndefinedNode(),_core.types.booleanLiteral(children.length>1));return call(file,children.length>1?"jsxs":"jsx",args)}(path,file),path.replaceWith(_core.types.inherits(callExpr,path.node));}},JSXElement:{exit(path,file){let callExpr;callExpr="classic"===get(file,"runtime")||function(path){const openingPath=path.get("openingElement"),attributes=openingPath.node.attributes;let seenPropsSpread=false;for(let i=0;i<attributes.length;i++){const attr=attributes[i];if(seenPropsSpread&&_core.types.isJSXAttribute(attr)&&"key"===attr.name.name)return  true;_core.types.isJSXSpreadAttribute(attr)&&(seenPropsSpread=true);}return  false}(path)?function(path,file){const openingPath=path.get("openingElement");return call(file,"createElement",[getTag(openingPath),buildCreateElementOpeningElementAttributes(file,path,openingPath.get("attributes")),..._core.types.react.buildChildren(path.node)])}(path,file):function(path,file){const openingPath=path.get("openingElement"),args=[getTag(openingPath)],attribsArray=[],extracted=Object.create(null);for(const attr of openingPath.get("attributes"))if(attr.isJSXAttribute()&&_core.types.isJSXIdentifier(attr.node.name)){const{name}=attr.node.name;switch(name){case "__source":case "__self":if(extracted[name])throw sourceSelfError(path,name);case "key":{const keyValue=convertAttributeValue(attr.node.value);if(null===keyValue)throw attr.buildCodeFrameError('Please provide an explicit key value. Using "key" as a shorthand for "key={true}" is not allowed.');extracted[name]=keyValue;break}default:attribsArray.push(attr);}}else attribsArray.push(attr);const children=_core.types.react.buildChildren(path.node);let attribs;attribs=attribsArray.length||children.length?function(attribs,children){const props=attribs.reduce(accumulateAttribute,[]);(null==children?void 0:children.length)>0&&props.push(buildChildrenProperty(children));return _core.types.objectExpression(props)}(attribsArray,children):_core.types.objectExpression([]);if(args.push(attribs),development){var _extracted$key;args.push(null!=(_extracted$key=extracted.key)?_extracted$key:path.scope.buildUndefinedNode(),_core.types.booleanLiteral(children.length>1)),extracted.__source?(args.push(extracted.__source),extracted.__self&&args.push(extracted.__self)):extracted.__self&&args.push(path.scope.buildUndefinedNode(),extracted.__self);}else void 0!==extracted.key&&args.push(extracted.key);return call(file,children.length>1?"jsxs":"jsx",args)}(path,file),path.replaceWith(_core.types.inherits(callExpr,path.node));}},JSXAttribute(path){_core.types.isJSXElement(path.node.value)&&(path.node.value=_core.types.jsxExpressionContainer(path.node.value));}}};function isDerivedClass(classPath){return null!==classPath.node.superClass}function call(pass,name,args){const node=_core.types.callExpression(get(pass,`id/${name}`)(),args);return (null!=PURE_ANNOTATION?PURE_ANNOTATION:get(pass,"defaultPure"))&&(0, _helperAnnotateAsPure.default)(node),node}function convertJSXIdentifier(node,parent){return _core.types.isJSXIdentifier(node)?"this"===node.name&&_core.types.isReferenced(node,parent)?_core.types.thisExpression():_core.types.isValidIdentifier(node.name,false)?(node.type="Identifier",node):_core.types.stringLiteral(node.name):_core.types.isJSXMemberExpression(node)?_core.types.memberExpression(convertJSXIdentifier(node.object,node),convertJSXIdentifier(node.property,node)):_core.types.isJSXNamespacedName(node)?_core.types.stringLiteral(`${node.namespace.name}:${node.name.name}`):node}function convertAttributeValue(node){return _core.types.isJSXExpressionContainer(node)?node.expression:node}function accumulateAttribute(array,attribute){if(_core.types.isJSXSpreadAttribute(attribute.node)){const arg=attribute.node.argument;return _core.types.isObjectExpression(arg)&&!arg.properties.some((value=>_core.types.isObjectProperty(value,{computed:false,shorthand:false})&&(_core.types.isIdentifier(value.key,{name:"__proto__"})||_core.types.isStringLiteral(value.key,{value:"__proto__"}))))?array.push(...arg.properties):array.push(_core.types.spreadElement(arg)),array}const value=convertAttributeValue("key"!==attribute.node.name.name?attribute.node.value||_core.types.booleanLiteral(true):attribute.node.value);if("key"===attribute.node.name.name&&null===value)throw attribute.buildCodeFrameError('Please provide an explicit key value. Using "key" as a shorthand for "key={true}" is not allowed.');var _value$extra;_core.types.isStringLiteral(value)&&!_core.types.isJSXExpressionContainer(attribute.node.value)&&(value.value=value.value.replace(/\n\s+/g," "),null==(_value$extra=value.extra)||delete _value$extra.raw);return _core.types.isJSXNamespacedName(attribute.node.name)?attribute.node.name=_core.types.stringLiteral(attribute.node.name.namespace.name+":"+attribute.node.name.name.name):_core.types.isValidIdentifier(attribute.node.name.name,false)?attribute.node.name.type="Identifier":attribute.node.name=_core.types.stringLiteral(attribute.node.name.name),array.push(_core.types.inherits(_core.types.objectProperty(attribute.node.name,value),attribute.node)),array}function buildChildrenProperty(children){let childrenNode;if(1===children.length)childrenNode=children[0];else {if(!(children.length>1))return;childrenNode=_core.types.arrayExpression(children);}return _core.types.objectProperty(_core.types.identifier("children"),childrenNode)}function getTag(openingPath){const tagExpr=convertJSXIdentifier(openingPath.node.name,openingPath.node);let tagName;return _core.types.isIdentifier(tagExpr)?tagName=tagExpr.name:_core.types.isStringLiteral(tagExpr)&&(tagName=tagExpr.value),_core.types.react.isCompatTag(tagName)?_core.types.stringLiteral(tagName):tagExpr}function buildCreateElementOpeningElementAttributes(file,path,attribs){const runtime=get(file,"runtime");if("automatic"!==runtime){const objs=[],props=attribs.reduce(accumulateAttribute,[]);if(useSpread)props.length&&objs.push(_core.types.objectExpression(props));else {let start=0;props.forEach(((prop,i)=>{_core.types.isSpreadElement(prop)&&(i>start&&objs.push(_core.types.objectExpression(props.slice(start,i))),objs.push(prop.argument),start=i+1);})),props.length>start&&objs.push(_core.types.objectExpression(props.slice(start)));}if(!objs.length)return _core.types.nullLiteral();if(!(1!==objs.length||_core.types.isSpreadElement(props[0])&&_core.types.isObjectExpression(props[0].argument)))return objs[0];_core.types.isObjectExpression(objs[0])||objs.unshift(_core.types.objectExpression([]));const helper=useBuiltIns?_core.types.memberExpression(_core.types.identifier("Object"),_core.types.identifier("assign")):file.addHelper("extends");return _core.types.callExpression(helper,objs)}const props=[],found=Object.create(null);for(const attr of attribs){const{node}=attr,name=_core.types.isJSXAttribute(node)&&_core.types.isJSXIdentifier(node.name)&&node.name.name;if("automatic"===runtime&&("__source"===name||"__self"===name)){if(found[name])throw sourceSelfError(path,name);found[name]=true;}accumulateAttribute(props,attr);}return 1===props.length&&_core.types.isSpreadElement(props[0])&&!_core.types.isObjectExpression(props[0].argument)?props[0].argument:props.length>0?_core.types.objectExpression(props):_core.types.nullLiteral()}}))};var _pluginSyntaxJsx=__webpack_require__("./node_modules/.pnpm/@babel+plugin-syntax-jsx@7.25.9_@babel+core@7.26.0/node_modules/@babel/plugin-syntax-jsx/lib/index.js"),_helperPluginUtils=__webpack_require__("./node_modules/.pnpm/@babel+helper-plugin-utils@7.25.9/node_modules/@babel/helper-plugin-utils/lib/index.js"),_core=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/index.js"),_helperModuleImports=__webpack_require__("./node_modules/.pnpm/@babel+helper-module-imports@7.25.9/node_modules/@babel/helper-module-imports/lib/index.js"),_helperAnnotateAsPure=__webpack_require__("./node_modules/.pnpm/@babel+helper-annotate-as-pure@7.25.9/node_modules/@babel/helper-annotate-as-pure/lib/index.js");const DEFAULT={importSource:"react",pragma:"React.createElement",pragmaFrag:"React.Fragment"},JSX_SOURCE_ANNOTATION_REGEX=/^\s*(?:\*\s*)?@jsxImportSource\s+(\S+)\s*$/m,JSX_RUNTIME_ANNOTATION_REGEX=/^\s*(?:\*\s*)?@jsxRuntime\s+(\S+)\s*$/m,JSX_ANNOTATION_REGEX=/^\s*(?:\*\s*)?@jsx\s+(\S+)\s*$/m,JSX_FRAG_ANNOTATION_REGEX=/^\s*(?:\*\s*)?@jsxFrag\s+(\S+)\s*$/m,get=(pass,name)=>pass.get(`@babel/plugin-react-jsx/${name}`),set=(pass,name,v)=>pass.set(`@babel/plugin-react-jsx/${name}`,v);function toMemberExpression(id){return id.split(".").map((name=>_core.types.identifier(name))).reduce(((object,property)=>_core.types.memberExpression(object,property)))}function sourceSelfError(path,name){const pluginName=`transform-react-jsx-${name.slice(2)}`;return path.buildCodeFrameError(`Duplicate ${name} prop found. You are most likely using the deprecated ${pluginName} Babel plugin. Both __source and __self are automatically set when using the automatic runtime. Please remove transform-react-jsx-source and transform-react-jsx-self from your Babel config.`)}},"./node_modules/.pnpm/@babel+plugin-transform-react-jsx@7.25.9_@babel+core@7.26.0/node_modules/@babel/plugin-transform-react-jsx/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{exports.A=void 0;var _createPlugin=__webpack_require__("./node_modules/.pnpm/@babel+plugin-transform-react-jsx@7.25.9_@babel+core@7.26.0/node_modules/@babel/plugin-transform-react-jsx/lib/create-plugin.js");exports.A=(0, _createPlugin.default)({name:"transform-react-jsx",development:false});},"./node_modules/.pnpm/@babel+plugin-transform-typescript@7.26.3_@babel+core@7.26.0/node_modules/@babel/plugin-transform-typescript/lib/const-enum.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(path,t){const{name}=path.node.id,parentIsExport=path.parentPath.isExportNamedDeclaration();let isExported=parentIsExport;!isExported&&t.isProgram(path.parent)&&(isExported=path.parent.body.some((stmt=>t.isExportNamedDeclaration(stmt)&&"type"!==stmt.exportKind&&!stmt.source&&stmt.specifiers.some((spec=>t.isExportSpecifier(spec)&&"type"!==spec.exportKind&&spec.local.name===name)))));const{enumValues:entries}=(0, _enum.translateEnumValues)(path,t);if(isExported){const obj=t.objectExpression(entries.map((([name,value])=>t.objectProperty(t.isValidIdentifier(name)?t.identifier(name):t.stringLiteral(name),value))));return void(path.scope.hasOwnBinding(name)?(parentIsExport?path.parentPath:path).replaceWith(t.expressionStatement(t.callExpression(t.memberExpression(t.identifier("Object"),t.identifier("assign")),[path.node.id,obj]))):(path.replaceWith(t.variableDeclaration("var",[t.variableDeclarator(path.node.id,obj)])),path.scope.registerDeclaration(path)))}const entriesMap=new Map(entries);path.scope.path.traverse({Scope(path){path.scope.hasOwnBinding(name)&&path.skip();},MemberExpression(path){if(!t.isIdentifier(path.node.object,{name}))return;let key;if(path.node.computed){if(!t.isStringLiteral(path.node.property))return;key=path.node.property.value;}else {if(!t.isIdentifier(path.node.property))return;key=path.node.property.name;}entriesMap.has(key)&&path.replaceWith(t.cloneNode(entriesMap.get(key)));}}),path.remove();};var _enum=__webpack_require__("./node_modules/.pnpm/@babel+plugin-transform-typescript@7.26.3_@babel+core@7.26.0/node_modules/@babel/plugin-transform-typescript/lib/enum.js");},"./node_modules/.pnpm/@babel+plugin-transform-typescript@7.26.3_@babel+core@7.26.0/node_modules/@babel/plugin-transform-typescript/lib/enum.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(path,t){const{node,parentPath}=path;if(node.declare)return void path.remove();const name=node.id.name,{fill,data,isPure}=function(path,t,id){const{enumValues:x,data,isPure}=translateEnumValues(path,t),assignments=x.map((([memberName,memberValue])=>buildEnumMember(isSyntacticallyString(memberValue),{ENUM:t.cloneNode(id),NAME:memberName,VALUE:memberValue})));return {fill:{ID:t.cloneNode(id),ASSIGNMENTS:assignments},data,isPure}}(path,t,node.id);switch(parentPath.type){case "BlockStatement":case "ExportNamedDeclaration":case "Program":{const isGlobal=t.isProgram(path.parent),isSeen=function seen(parentPath){if(parentPath.isExportDeclaration())return seen(parentPath.parentPath);return !!parentPath.getData(name)||(parentPath.setData(name,true),false)}(parentPath);let init=t.objectExpression([]);(isSeen||isGlobal)&&(init=t.logicalExpression("||",t.cloneNode(fill.ID),init));const enumIIFE=buildEnumWrapper(Object.assign({},fill,{INIT:init}));if(isPure&&(0, _helperAnnotateAsPure.default)(enumIIFE),isSeen){(parentPath.isExportDeclaration()?parentPath:path).replaceWith(t.expressionStatement(t.assignmentExpression("=",t.cloneNode(node.id),enumIIFE)));}else path.scope.registerDeclaration(path.replaceWith(t.variableDeclaration(isGlobal?"var":"let",[t.variableDeclarator(node.id,enumIIFE)]))[0]);ENUMS.set(path.scope.getBindingIdentifier(name),data);break}default:throw new Error(`Unexpected enum parent '${path.parent.type}`)}},exports.isSyntacticallyString=isSyntacticallyString,exports.translateEnumValues=translateEnumValues;var _core=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/index.js"),_assert=__webpack_require__("assert"),_helperAnnotateAsPure=__webpack_require__("./node_modules/.pnpm/@babel+helper-annotate-as-pure@7.25.9/node_modules/@babel/helper-annotate-as-pure/lib/index.js"),_helperSkipTransparentExpressionWrappers=__webpack_require__("./node_modules/.pnpm/@babel+helper-skip-transparent-expression-wrappers@7.25.9/node_modules/@babel/helper-skip-transparent-expression-wrappers/lib/index.js");const ENUMS=new WeakMap,buildEnumWrapper=_core.template.expression("\n    (function (ID) {\n      ASSIGNMENTS;\n      return ID;\n    })(INIT)\n  ");const buildStringAssignment=(0, _core.template)('\n  ENUM["NAME"] = VALUE;\n'),buildNumericAssignment=(0, _core.template)('\n  ENUM[ENUM["NAME"] = VALUE] = "NAME";\n'),buildEnumMember=(isString,options)=>(isString?buildStringAssignment:buildNumericAssignment)(options);function isSyntacticallyString(expr){switch((expr=(0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrapperNodes)(expr)).type){case "BinaryExpression":{const left=expr.left,right=expr.right;return "+"===expr.operator&&(isSyntacticallyString(left)||isSyntacticallyString(right))}case "TemplateLiteral":case "StringLiteral":return  true}return  false}function ReferencedIdentifier(expr,state){const{seen,path,t}=state,name=expr.node.name;seen.has(name)&&!expr.scope.hasOwnBinding(name)&&(expr.replaceWith(t.memberExpression(t.cloneNode(path.node.id),t.cloneNode(expr.node))),expr.skip());}const enumSelfReferenceVisitor={ReferencedIdentifier};function translateEnumValues(path,t){var _ENUMS$get;const bindingIdentifier=path.scope.getBindingIdentifier(path.node.id.name),seen=null!=(_ENUMS$get=ENUMS.get(bindingIdentifier))?_ENUMS$get:new Map;let lastName,constValue=-1,isPure=true;const enumValues=path.get("members").map((memberPath=>{const member=memberPath.node,name=t.isIdentifier(member.id)?member.id.name:member.id.value,initializerPath=memberPath.get("initializer");let value;if(member.initializer)constValue=computeConstantValue(initializerPath,seen),void 0!==constValue?(seen.set(name,constValue),_assert("number"==typeof constValue||"string"==typeof constValue),value=constValue===1/0||Number.isNaN(constValue)?t.identifier(String(constValue)):constValue===-1/0?t.unaryExpression("-",t.identifier("Infinity")):t.valueToNode(constValue)):(isPure&&(isPure=initializerPath.isPure()),initializerPath.isReferencedIdentifier()?ReferencedIdentifier(initializerPath,{t,seen,path}):initializerPath.traverse(enumSelfReferenceVisitor,{t,seen,path}),value=initializerPath.node,seen.set(name,void 0));else if("number"==typeof constValue)constValue+=1,value=t.numericLiteral(constValue),seen.set(name,constValue);else {if("string"==typeof constValue)throw path.buildCodeFrameError("Enum member must have initializer.");{const lastRef=t.memberExpression(t.cloneNode(path.node.id),t.stringLiteral(lastName),true);value=t.binaryExpression("+",t.numericLiteral(1),lastRef),seen.set(name,void 0);}}return lastName=name,[name,value]}));return {isPure,data:seen,enumValues}}function computeConstantValue(path,prevMembers,seen=new Set){return evaluate(path);function evaluate(path){const expr=path.node;switch(expr.type){case "MemberExpression":case "Identifier":return evaluateRef(path,prevMembers,seen);case "StringLiteral":case "NumericLiteral":return expr.value;case "UnaryExpression":return function(path){const value=evaluate(path.get("argument"));if(void 0===value)return;switch(path.node.operator){case "+":return value;case "-":return -value;case "~":return ~value;default:return}}(path);case "BinaryExpression":return function(path){const left=evaluate(path.get("left"));if(void 0===left)return;const right=evaluate(path.get("right"));if(void 0===right)return;switch(path.node.operator){case "|":return left|right;case "&":return left&right;case ">>":return left>>right;case ">>>":return left>>>right;case "<<":return left<<right;case "^":return left^right;case "*":return left*right;case "/":return left/right;case "+":return left+right;case "-":return left-right;case "%":return left%right;case "**":return Math.pow(left,right);default:return}}(path);case "ParenthesizedExpression":return evaluate(path.get("expression"));case "TemplateLiteral":{if(1===expr.quasis.length)return expr.quasis[0].value.cooked;const paths=path.get("expressions"),quasis=expr.quasis;let str="";for(let i=0;i<quasis.length;i++)if(str+=quasis[i].value.cooked,i+1<quasis.length){const value=evaluateRef(paths[i],prevMembers,seen);if(void 0===value)return;str+=value;}return str}default:return}}function evaluateRef(path,prevMembers,seen){if(path.isMemberExpression()){const expr=path.node,obj=expr.object,prop=expr.property;if(!_core.types.isIdentifier(obj)||(expr.computed?!_core.types.isStringLiteral(prop):!_core.types.isIdentifier(prop)))return;const bindingIdentifier=path.scope.getBindingIdentifier(obj.name),data=ENUMS.get(bindingIdentifier);if(!data)return;return data.get(prop.computed?prop.value:prop.name)}if(path.isIdentifier()){const name=path.node.name;if(["Infinity","NaN"].includes(name))return Number(name);let value=null==prevMembers?void 0:prevMembers.get(name);if(void 0!==value)return value;if(seen.has(path.node))return;return seen.add(path.node),value=computeConstantValue(path.resolve(),prevMembers,seen),null==prevMembers||prevMembers.set(name,value),value}}}},"./node_modules/.pnpm/@babel+plugin-transform-typescript@7.26.3_@babel+core@7.26.0/node_modules/@babel/plugin-transform-typescript/lib/global-types.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.GLOBAL_TYPES=void 0,exports.isGlobalType=function({scope},name){return !scope.hasBinding(name)&&(!!GLOBAL_TYPES.get(scope).has(name)||(console.warn(`The exported identifier "${name}" is not declared in Babel's scope tracker\nas a JavaScript value binding, and "@babel/plugin-transform-typescript"\nnever encountered it as a TypeScript type declaration.\nIt will be treated as a JavaScript value.\n\nThis problem is likely caused by another plugin injecting\n"${name}" without registering it in the scope tracker. If you are the author\n of that plugin, please use "scope.registerDeclaration(declarationPath)".`),false))},exports.registerGlobalType=function(programScope,name){GLOBAL_TYPES.get(programScope).add(name);};const GLOBAL_TYPES=exports.GLOBAL_TYPES=new WeakMap;},"./node_modules/.pnpm/@babel+plugin-transform-typescript@7.26.3_@babel+core@7.26.0/node_modules/@babel/plugin-transform-typescript/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=void 0;var _helperPluginUtils=__webpack_require__("./node_modules/.pnpm/@babel+helper-plugin-utils@7.25.9/node_modules/@babel/helper-plugin-utils/lib/index.js"),_pluginSyntaxTypescript=__webpack_require__("./node_modules/.pnpm/@babel+plugin-syntax-typescript@7.25.9_@babel+core@7.26.0/node_modules/@babel/plugin-syntax-typescript/lib/index.js"),_helperCreateClassFeaturesPlugin=__webpack_require__("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.25.9_@babel+core@7.26.0/node_modules/@babel/helper-create-class-features-plugin/lib/index.js"),_constEnum=__webpack_require__("./node_modules/.pnpm/@babel+plugin-transform-typescript@7.26.3_@babel+core@7.26.0/node_modules/@babel/plugin-transform-typescript/lib/const-enum.js"),_enum=__webpack_require__("./node_modules/.pnpm/@babel+plugin-transform-typescript@7.26.3_@babel+core@7.26.0/node_modules/@babel/plugin-transform-typescript/lib/enum.js"),_globalTypes=__webpack_require__("./node_modules/.pnpm/@babel+plugin-transform-typescript@7.26.3_@babel+core@7.26.0/node_modules/@babel/plugin-transform-typescript/lib/global-types.js"),_namespace=__webpack_require__("./node_modules/.pnpm/@babel+plugin-transform-typescript@7.26.3_@babel+core@7.26.0/node_modules/@babel/plugin-transform-typescript/lib/namespace.js");function isInType(path){switch(path.parent.type){case "TSTypeReference":case "TSExpressionWithTypeArguments":case "TSExpressionWithTypeArguments":case "TSTypeQuery":return  true;case "TSQualifiedName":return "TSImportEqualsDeclaration"!==path.parentPath.findParent((path=>"TSQualifiedName"!==path.type)).type;case "ExportSpecifier":return "type"===path.parent.exportKind||"type"===path.parentPath.parent.exportKind;default:return  false}}const NEEDS_EXPLICIT_ESM=new WeakMap,PARSED_PARAMS=new WeakSet;function safeRemove(path){const ids=path.getBindingIdentifiers();for(const name of Object.keys(ids)){const binding=path.scope.getBinding(name);binding&&binding.identifier===ids[name]&&binding.scope.removeBinding(name);}path.opts.noScope=true,path.remove(),path.opts.noScope=false;}function assertCjsTransformEnabled(path,pass,wrong,suggestion,extra=""){if("commonjs"!==pass.file.get("@babel/plugin-transform-modules-*"))throw path.buildCodeFrameError(`\`${wrong}\` is only supported when compiling modules to CommonJS.\nPlease consider using \`${suggestion}\`${extra}, or add @babel/plugin-transform-modules-commonjs to your Babel config.`)}exports.default=(0, _helperPluginUtils.declare)(((api,opts)=>{const{types:t,template}=api;api.assertVersion(7);const JSX_PRAGMA_REGEX=/\*?\s*@jsx((?:Frag)?)\s+(\S+)/,{allowNamespaces=true,jsxPragma="React.createElement",jsxPragmaFrag="React.Fragment",onlyRemoveTypeImports=false,optimizeConstEnums=false}=opts;var{allowDeclareFields=false}=opts;const classMemberVisitors={field(path){const{node}=path;if(!allowDeclareFields&&node.declare)throw path.buildCodeFrameError("The 'declare' modifier is only allowed when the 'allowDeclareFields' option of @babel/plugin-transform-typescript or @babel/preset-typescript is enabled.");if(node.declare){if(node.value)throw path.buildCodeFrameError("Fields with the 'declare' modifier cannot be initialized here, but only in the constructor");node.decorators||path.remove();}else if(node.definite){if(node.value)throw path.buildCodeFrameError("Definitely assigned fields cannot be initialized here, but only in the constructor");allowDeclareFields||node.decorators||t.isClassPrivateProperty(node)||path.remove();}else node.abstract?path.remove():allowDeclareFields||node.value||node.decorators||t.isClassPrivateProperty(node)||path.remove();node.accessibility&&(node.accessibility=null),node.abstract&&(node.abstract=null),node.readonly&&(node.readonly=null),node.optional&&(node.optional=null),node.typeAnnotation&&(node.typeAnnotation=null),node.definite&&(node.definite=null),node.declare&&(node.declare=null),node.override&&(node.override=null);},method({node}){node.accessibility&&(node.accessibility=null),node.abstract&&(node.abstract=null),node.optional&&(node.optional=null),node.override&&(node.override=null);},constructor(path,classPath){path.node.accessibility&&(path.node.accessibility=null);const assigns=[],{scope}=path;for(const paramPath of path.get("params")){const param=paramPath.node;if("TSParameterProperty"===param.type){const parameter=param.parameter;if(PARSED_PARAMS.has(parameter))continue;let id;if(PARSED_PARAMS.add(parameter),t.isIdentifier(parameter))id=parameter;else {if(!t.isAssignmentPattern(parameter)||!t.isIdentifier(parameter.left))throw paramPath.buildCodeFrameError("Parameter properties can not be destructuring patterns.");id=parameter.left;}assigns.push(template.statement.ast`
              this.${t.cloneNode(id)} = ${t.cloneNode(id)}
            `),paramPath.replaceWith(paramPath.get("parameter")),scope.registerBinding("param",paramPath);}}(0, _helperCreateClassFeaturesPlugin.injectInitialization)(classPath,path,assigns);}};return {name:"transform-typescript",inherits:_pluginSyntaxTypescript.default,visitor:{Pattern:visitPattern,Identifier:visitPattern,RestElement:visitPattern,Program:{enter(path,state){const{file}=state;let fileJsxPragma=null,fileJsxPragmaFrag=null;const programScope=path.scope;if(_globalTypes.GLOBAL_TYPES.has(programScope)||_globalTypes.GLOBAL_TYPES.set(programScope,new Set),file.ast.comments)for(const comment of file.ast.comments){const jsxMatches=JSX_PRAGMA_REGEX.exec(comment.value);jsxMatches&&(jsxMatches[1]?fileJsxPragmaFrag=jsxMatches[2]:fileJsxPragma=jsxMatches[2]);}let pragmaImportName=fileJsxPragma||jsxPragma;pragmaImportName&&([pragmaImportName]=pragmaImportName.split("."));let pragmaFragImportName=fileJsxPragmaFrag||jsxPragmaFrag;pragmaFragImportName&&([pragmaFragImportName]=pragmaFragImportName.split("."));for(let stmt of path.get("body"))if(stmt.isImportDeclaration()){if(NEEDS_EXPLICIT_ESM.has(state.file.ast.program)||NEEDS_EXPLICIT_ESM.set(state.file.ast.program,true),"type"===stmt.node.importKind){for(const specifier of stmt.node.specifiers)(0, _globalTypes.registerGlobalType)(programScope,specifier.local.name);stmt.remove();continue}const importsToRemove=new Set,specifiersLength=stmt.node.specifiers.length,isAllSpecifiersElided=()=>specifiersLength>0&&specifiersLength===importsToRemove.size;for(const specifier of stmt.node.specifiers)if("ImportSpecifier"===specifier.type&&"type"===specifier.importKind){(0, _globalTypes.registerGlobalType)(programScope,specifier.local.name);const binding=stmt.scope.getBinding(specifier.local.name);binding&&importsToRemove.add(binding.path);}if(onlyRemoveTypeImports)NEEDS_EXPLICIT_ESM.set(path.node,false);else {if(0===stmt.node.specifiers.length){NEEDS_EXPLICIT_ESM.set(path.node,false);continue}for(const specifier of stmt.node.specifiers){const binding=stmt.scope.getBinding(specifier.local.name);binding&&!importsToRemove.has(binding.path)&&(isImportTypeOnly({binding,programPath:path,pragmaImportName,pragmaFragImportName})?importsToRemove.add(binding.path):NEEDS_EXPLICIT_ESM.set(path.node,false));}}if(isAllSpecifiersElided()&&!onlyRemoveTypeImports)stmt.remove();else for(const importPath of importsToRemove)importPath.remove();}else if(stmt.isExportDeclaration()&&(stmt=stmt.get("declaration")),stmt.isVariableDeclaration({declare:true}))for(const name of Object.keys(stmt.getBindingIdentifiers()))(0, _globalTypes.registerGlobalType)(programScope,name);else (stmt.isTSTypeAliasDeclaration()||stmt.isTSDeclareFunction()&&stmt.get("id").isIdentifier()||stmt.isTSInterfaceDeclaration()||stmt.isClassDeclaration({declare:true})||stmt.isTSEnumDeclaration({declare:true})||stmt.isTSModuleDeclaration({declare:true})&&stmt.get("id").isIdentifier())&&(0, _globalTypes.registerGlobalType)(programScope,stmt.node.id.name);},exit(path){"module"===path.node.sourceType&&NEEDS_EXPLICIT_ESM.get(path.node)&&path.pushContainer("body",t.exportNamedDeclaration());}},ExportNamedDeclaration(path,state){if(NEEDS_EXPLICIT_ESM.has(state.file.ast.program)||NEEDS_EXPLICIT_ESM.set(state.file.ast.program,true),"type"!==path.node.exportKind)if(path.node.source&&path.node.specifiers.length>0&&path.node.specifiers.every((specifier=>"ExportSpecifier"===specifier.type&&"type"===specifier.exportKind)))path.remove();else if(!path.node.source&&path.node.specifiers.length>0&&path.node.specifiers.every((specifier=>t.isExportSpecifier(specifier)&&(0, _globalTypes.isGlobalType)(path,specifier.local.name))))path.remove();else {if(t.isTSModuleDeclaration(path.node.declaration)){const namespace=path.node.declaration;if(!t.isStringLiteral(namespace.id)){const id=(0, _namespace.getFirstIdentifier)(namespace.id);if(path.scope.hasOwnBinding(id.name))path.replaceWith(namespace);else {const[newExport]=path.replaceWithMultiple([t.exportNamedDeclaration(t.variableDeclaration("let",[t.variableDeclarator(t.cloneNode(id))])),namespace]);path.scope.registerDeclaration(newExport);}}}NEEDS_EXPLICIT_ESM.set(state.file.ast.program,false);}else path.remove();},ExportAllDeclaration(path){"type"===path.node.exportKind&&path.remove();},ExportSpecifier(path){(!path.parent.source&&(0, _globalTypes.isGlobalType)(path,path.node.local.name)||"type"===path.node.exportKind)&&path.remove();},ExportDefaultDeclaration(path,state){NEEDS_EXPLICIT_ESM.has(state.file.ast.program)||NEEDS_EXPLICIT_ESM.set(state.file.ast.program,true),t.isIdentifier(path.node.declaration)&&(0, _globalTypes.isGlobalType)(path,path.node.declaration.name)?path.remove():NEEDS_EXPLICIT_ESM.set(state.file.ast.program,false);},TSDeclareFunction(path){safeRemove(path);},TSDeclareMethod(path){safeRemove(path);},VariableDeclaration(path){path.node.declare&&safeRemove(path);},VariableDeclarator({node}){node.definite&&(node.definite=null);},TSIndexSignature(path){path.remove();},ClassDeclaration(path){const{node}=path;node.declare&&safeRemove(path);},Class(path){const{node}=path;node.typeParameters&&(node.typeParameters=null),node.superTypeParameters&&(node.superTypeParameters=null),node.implements&&(node.implements=null),node.abstract&&(node.abstract=null),path.get("body.body").forEach((child=>{child.isClassMethod()||child.isClassPrivateMethod()?"constructor"===child.node.kind?classMemberVisitors.constructor(child,path):classMemberVisitors.method(child):(child.isClassProperty()||child.isClassPrivateProperty()||child.isClassAccessorProperty())&&classMemberVisitors.field(child);}));},Function(path){const{node}=path;node.typeParameters&&(node.typeParameters=null),node.returnType&&(node.returnType=null);const params=node.params;params.length>0&&t.isIdentifier(params[0],{name:"this"})&&params.shift();},TSModuleDeclaration(path){(0, _namespace.default)(path,allowNamespaces);},TSInterfaceDeclaration(path){path.remove();},TSTypeAliasDeclaration(path){path.remove();},TSEnumDeclaration(path){optimizeConstEnums&&path.node.const?(0, _constEnum.default)(path,t):(0, _enum.default)(path,t);},TSImportEqualsDeclaration(path,pass){const{id,moduleReference,isExport}=path.node;let init,varKind;t.isTSExternalModuleReference(moduleReference)?(assertCjsTransformEnabled(path,pass,`import ${id.name} = require(...);`,`import ${id.name} from '...';`," alongside Typescript's --allowSyntheticDefaultImports option"),init=t.callExpression(t.identifier("require"),[moduleReference.expression]),varKind="const"):(init=entityNameToExpr(moduleReference),varKind="var");const newNode=t.variableDeclaration(varKind,[t.variableDeclarator(id,init)]);path.replaceWith(isExport?t.exportNamedDeclaration(newNode):newNode),path.scope.registerDeclaration(path);},TSExportAssignment(path,pass){assertCjsTransformEnabled(path,pass,"export = <value>;","export default <value>;"),path.replaceWith(template.statement.ast`module.exports = ${path.node.expression}`);},TSTypeAssertion(path){path.replaceWith(path.node.expression);},["TSAsExpression"+(t.tsSatisfiesExpression?"|TSSatisfiesExpression":"")](path){let{node}=path;do{node=node.expression;}while(t.isTSAsExpression(node)||null!=t.isTSSatisfiesExpression&&t.isTSSatisfiesExpression(node));path.replaceWith(node);},[api.types.tsInstantiationExpression?"TSNonNullExpression|TSInstantiationExpression":"TSNonNullExpression"](path){path.replaceWith(path.node.expression);},CallExpression(path){path.node.typeParameters=null;},OptionalCallExpression(path){path.node.typeParameters=null;},NewExpression(path){path.node.typeParameters=null;},JSXOpeningElement(path){path.node.typeParameters=null;},TaggedTemplateExpression(path){path.node.typeParameters=null;}}};function entityNameToExpr(node){return t.isTSQualifiedName(node)?t.memberExpression(entityNameToExpr(node.left),node.right):node}function visitPattern({node}){node.typeAnnotation&&(node.typeAnnotation=null),t.isIdentifier(node)&&node.optional&&(node.optional=null);}function isImportTypeOnly({binding,programPath,pragmaImportName,pragmaFragImportName}){for(const path of binding.referencePaths)if(!isInType(path))return  false;if(binding.identifier.name!==pragmaImportName&&binding.identifier.name!==pragmaFragImportName)return  true;let sourceFileHasJsx=false;return programPath.traverse({"JSXElement|JSXFragment"(path){sourceFileHasJsx=true,path.stop();}}),!sourceFileHasJsx}}));},"./node_modules/.pnpm/@babel+plugin-transform-typescript@7.26.3_@babel+core@7.26.0/node_modules/@babel/plugin-transform-typescript/lib/namespace.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(path,allowNamespaces){if(path.node.declare||"StringLiteral"===path.node.id.type)return void path.remove();if(!allowNamespaces)throw path.get("id").buildCodeFrameError("Namespace not marked type-only declare. Non-declarative namespaces are only supported experimentally in Babel. To enable and review caveats see: https://babeljs.io/docs/en/babel-plugin-transform-typescript");const name=getFirstIdentifier(path.node.id).name,value=handleNested(path,path.node);if(null===value){const program=path.findParent((p=>p.isProgram()));(0, _globalTypes.registerGlobalType)(program.scope,name),path.remove();}else path.scope.hasOwnBinding(name)?path.replaceWith(value):path.scope.registerDeclaration(path.replaceWithMultiple([getDeclaration(name),value])[0]);},exports.getFirstIdentifier=getFirstIdentifier;var _core=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/index.js"),_globalTypes=__webpack_require__("./node_modules/.pnpm/@babel+plugin-transform-typescript@7.26.3_@babel+core@7.26.0/node_modules/@babel/plugin-transform-typescript/lib/global-types.js");function getFirstIdentifier(node){return _core.types.isIdentifier(node)?node:getFirstIdentifier(node.left)}function getDeclaration(name){return _core.types.variableDeclaration("let",[_core.types.variableDeclarator(_core.types.identifier(name))])}function getMemberExpression(name,itemName){return _core.types.memberExpression(_core.types.identifier(name),_core.types.identifier(itemName))}function handleVariableDeclaration(node,name,hub){if("const"!==node.kind)throw hub.file.buildCodeFrameError(node,"Namespaces exporting non-const are not supported by Babel. Change to const or see: https://babeljs.io/docs/en/babel-plugin-transform-typescript");const{declarations}=node;if(declarations.every((declarator=>_core.types.isIdentifier(declarator.id)))){for(const declarator of declarations)declarator.init=_core.types.assignmentExpression("=",getMemberExpression(name,declarator.id.name),declarator.init);return [node]}const bindingIdentifiers=_core.types.getBindingIdentifiers(node),assignments=[];for(const idName in bindingIdentifiers)assignments.push(_core.types.assignmentExpression("=",getMemberExpression(name,idName),_core.types.cloneNode(bindingIdentifiers[idName])));return [node,_core.types.expressionStatement(_core.types.sequenceExpression(assignments))]}function buildNestedAmbientModuleError(path,node){return path.hub.buildError(node,"Ambient modules cannot be nested in other modules or namespaces.",Error)}function handleNested(path,node,parentExport){const names=new Set,realName=node.id,name=path.scope.generateUid(realName.name),body=node.body;let namespaceTopLevel;node.id;namespaceTopLevel=_core.types.isTSModuleBlock(body)?body.body:[_core.types.exportNamedDeclaration(body)];let isEmpty=true;for(let i=0;i<namespaceTopLevel.length;i++){const subNode=namespaceTopLevel[i];switch(subNode.type){case "TSModuleDeclaration":{if(!_core.types.isIdentifier(subNode.id))throw buildNestedAmbientModuleError(path,subNode);const transformed=handleNested(path,subNode);if(null!==transformed){isEmpty=false;const moduleName=subNode.id.name;names.has(moduleName)?namespaceTopLevel[i]=transformed:(names.add(moduleName),namespaceTopLevel.splice(i++,1,getDeclaration(moduleName),transformed));}continue}case "TSEnumDeclaration":case "FunctionDeclaration":case "ClassDeclaration":isEmpty=false,names.add(subNode.id.name);continue;case "VariableDeclaration":isEmpty=false;for(const name in _core.types.getBindingIdentifiers(subNode))names.add(name);continue;default:isEmpty&&(isEmpty=_core.types.isTypeScript(subNode));continue;case "ExportNamedDeclaration":}if(!("declare"in subNode.declaration)||!subNode.declaration.declare)switch(subNode.declaration.type){case "TSEnumDeclaration":case "FunctionDeclaration":case "ClassDeclaration":{isEmpty=false;const itemName=subNode.declaration.id.name;names.add(itemName),namespaceTopLevel.splice(i++,1,subNode.declaration,_core.types.expressionStatement(_core.types.assignmentExpression("=",getMemberExpression(name,itemName),_core.types.identifier(itemName))));break}case "VariableDeclaration":{isEmpty=false;const nodes=handleVariableDeclaration(subNode.declaration,name,path.hub);namespaceTopLevel.splice(i,nodes.length,...nodes),i+=nodes.length-1;break}case "TSModuleDeclaration":{if(!_core.types.isIdentifier(subNode.declaration.id))throw buildNestedAmbientModuleError(path,subNode.declaration);const transformed=handleNested(path,subNode.declaration,_core.types.identifier(name));if(null!==transformed){isEmpty=false;const moduleName=subNode.declaration.id.name;names.has(moduleName)?namespaceTopLevel[i]=transformed:(names.add(moduleName),namespaceTopLevel.splice(i++,1,getDeclaration(moduleName),transformed));}else namespaceTopLevel.splice(i,1),i--;}}}if(isEmpty)return null;let fallthroughValue=_core.types.objectExpression([]);if(parentExport){const memberExpr=_core.types.memberExpression(parentExport,realName);fallthroughValue=_core.template.expression.ast`
      ${_core.types.cloneNode(memberExpr)} ||
        (${_core.types.cloneNode(memberExpr)} = ${fallthroughValue})
    `;}return _core.template.statement.ast`
    (function (${_core.types.identifier(name)}) {
      ${namespaceTopLevel}
    })(${realName} || (${_core.types.cloneNode(realName)} = ${fallthroughValue}));
  `}},"./node_modules/.pnpm/@babel+preset-typescript@7.26.0_@babel+core@7.26.0/node_modules/@babel/preset-typescript/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true});var helperPluginUtils=__webpack_require__("./node_modules/.pnpm/@babel+helper-plugin-utils@7.25.9/node_modules/@babel/helper-plugin-utils/lib/index.js"),transformTypeScript=__webpack_require__("./node_modules/.pnpm/@babel+plugin-transform-typescript@7.26.3_@babel+core@7.26.0/node_modules/@babel/plugin-transform-typescript/lib/index.js");__webpack_require__("./node_modules/.pnpm/@babel+plugin-syntax-jsx@7.25.9_@babel+core@7.26.0/node_modules/@babel/plugin-syntax-jsx/lib/index.js");var transformModulesCommonJS=__webpack_require__("./node_modules/.pnpm/@babel+plugin-transform-modules-commonjs@7.26.3_@babel+core@7.26.0/node_modules/@babel/plugin-transform-modules-commonjs/lib/index.js"),helperValidatorOption=__webpack_require__("./node_modules/.pnpm/@babel+helper-validator-option@7.25.9/node_modules/@babel/helper-validator-option/lib/index.js");function _interopDefault(e){return e&&e.__esModule?e:{default:e}}var transformTypeScript__default=_interopDefault(transformTypeScript),transformModulesCommonJS__default=_interopDefault(transformModulesCommonJS);const v=new helperValidatorOption.OptionValidator("@babel/preset-typescript");var pluginRewriteTSImports=helperPluginUtils.declare((function({types:t,template}){function maybeReplace(source,path){source&&(t.isStringLiteral(source)?/[\\/]/.test(source.value)&&(source.value=source.value.replace(/(\.[mc]?)ts$/,"$1js").replace(/\.tsx$/,".js")):path.replaceWith(template.expression.ast`(${source} + "").replace(/([\\/].*\.[mc]?)tsx?$/, "$1js")`));}return {name:"preset-typescript/plugin-rewrite-ts-imports",visitor:{"ImportDeclaration|ExportAllDeclaration|ExportNamedDeclaration"(path){const node=path.node;"value"===(t.isImportDeclaration(node)?node.importKind:node.exportKind)&&maybeReplace(node.source,path.get("source"));},CallExpression(path){t.isImport(path.node.callee)&&maybeReplace(path.node.arguments[0],path.get("arguments.0"));},ImportExpression(path){maybeReplace(path.node.source,path.get("source"));}}}})),index=helperPluginUtils.declarePreset(((api,opts)=>{api.assertVersion(7);const{allExtensions,ignoreExtensions,allowNamespaces,disallowAmbiguousJSXLike,isTSX,jsxPragma,jsxPragmaFrag,onlyRemoveTypeImports,optimizeConstEnums,rewriteImportExtensions}=function(options={}){let{allowNamespaces=true,jsxPragma,onlyRemoveTypeImports}=options;const TopLevelOptions_ignoreExtensions="ignoreExtensions",TopLevelOptions_disallowAmbiguousJSXLike="disallowAmbiguousJSXLike",TopLevelOptions_jsxPragmaFrag="jsxPragmaFrag",TopLevelOptions_optimizeConstEnums="optimizeConstEnums",TopLevelOptions_rewriteImportExtensions="rewriteImportExtensions",TopLevelOptions_allExtensions="allExtensions",TopLevelOptions_isTSX="isTSX",jsxPragmaFrag=v.validateStringOption(TopLevelOptions_jsxPragmaFrag,options.jsxPragmaFrag,"React.Fragment");var allExtensions=v.validateBooleanOption(TopLevelOptions_allExtensions,options.allExtensions,false),isTSX=v.validateBooleanOption(TopLevelOptions_isTSX,options.isTSX,false);isTSX&&v.invariant(allExtensions,"isTSX:true requires allExtensions:true");const ignoreExtensions=v.validateBooleanOption(TopLevelOptions_ignoreExtensions,options.ignoreExtensions,false),disallowAmbiguousJSXLike=v.validateBooleanOption(TopLevelOptions_disallowAmbiguousJSXLike,options.disallowAmbiguousJSXLike,false);disallowAmbiguousJSXLike&&v.invariant(allExtensions,"disallowAmbiguousJSXLike:true requires allExtensions:true");const normalized={ignoreExtensions,allowNamespaces,disallowAmbiguousJSXLike,jsxPragma,jsxPragmaFrag,onlyRemoveTypeImports,optimizeConstEnums:v.validateBooleanOption(TopLevelOptions_optimizeConstEnums,options.optimizeConstEnums,false),rewriteImportExtensions:v.validateBooleanOption(TopLevelOptions_rewriteImportExtensions,options.rewriteImportExtensions,false)};return normalized.allExtensions=allExtensions,normalized.isTSX=isTSX,normalized}(opts),pluginOptions=disallowAmbiguousJSXLike=>({allowDeclareFields:opts.allowDeclareFields,allowNamespaces,disallowAmbiguousJSXLike,jsxPragma,jsxPragmaFrag,onlyRemoveTypeImports,optimizeConstEnums}),getPlugins=(isTSX,disallowAmbiguousJSXLike)=>[[transformTypeScript__default.default,Object.assign({isTSX},pluginOptions(disallowAmbiguousJSXLike))]];return {plugins:rewriteImportExtensions?[pluginRewriteTSImports]:[],overrides:allExtensions||ignoreExtensions?[{plugins:getPlugins(isTSX,disallowAmbiguousJSXLike)}]:[{test:/\.ts$/,plugins:getPlugins(false,false)},{test:/\.mts$/,sourceType:"module",plugins:getPlugins(false,true)},{test:/\.cts$/,sourceType:"unambiguous",plugins:[[transformModulesCommonJS__default.default,{allowTopLevelThis:true}],[transformTypeScript__default.default,pluginOptions(true)]]},{test:/\.tsx$/,plugins:getPlugins(true,false)}]}}));exports.default=index;},"./node_modules/.pnpm/@babel+template@7.25.9/node_modules/@babel/template/lib/builder.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function createTemplateBuilder(formatter,defaultOpts){const templateFnCache=new WeakMap,templateAstCache=new WeakMap,cachedOpts=defaultOpts||(0, _options.validate)(null);return Object.assign(((tpl,...args)=>{if("string"==typeof tpl){if(args.length>1)throw new Error("Unexpected extra params.");return extendedTrace((0,_string.default)(formatter,tpl,(0,_options.merge)(cachedOpts,(0,_options.validate)(args[0]))))}if(Array.isArray(tpl)){let builder=templateFnCache.get(tpl);return builder||(builder=(0, _literal.default)(formatter,tpl,cachedOpts),templateFnCache.set(tpl,builder)),extendedTrace(builder(args))}if("object"==typeof tpl&&tpl){if(args.length>0)throw new Error("Unexpected extra params.");return createTemplateBuilder(formatter,(0, _options.merge)(cachedOpts,(0, _options.validate)(tpl)))}throw new Error("Unexpected template param "+typeof tpl)}),{ast:(tpl,...args)=>{if("string"==typeof tpl){if(args.length>1)throw new Error("Unexpected extra params.");return (0, _string.default)(formatter,tpl,(0, _options.merge)((0, _options.merge)(cachedOpts,(0, _options.validate)(args[0])),NO_PLACEHOLDER))()}if(Array.isArray(tpl)){let builder=templateAstCache.get(tpl);return builder||(builder=(0, _literal.default)(formatter,tpl,(0, _options.merge)(cachedOpts,NO_PLACEHOLDER)),templateAstCache.set(tpl,builder)),builder(args)()}throw new Error("Unexpected template param "+typeof tpl)}})};var _options=__webpack_require__("./node_modules/.pnpm/@babel+template@7.25.9/node_modules/@babel/template/lib/options.js"),_string=__webpack_require__("./node_modules/.pnpm/@babel+template@7.25.9/node_modules/@babel/template/lib/string.js"),_literal=__webpack_require__("./node_modules/.pnpm/@babel+template@7.25.9/node_modules/@babel/template/lib/literal.js");const NO_PLACEHOLDER=(0, _options.validate)({placeholderPattern:false});function extendedTrace(fn){let rootStack="";try{throw new Error}catch(error){error.stack&&(rootStack=error.stack.split("\n").slice(3).join("\n"));}return arg=>{try{return fn(arg)}catch(err){throw err.stack+=`\n    =============\n${rootStack}`,err}}}},"./node_modules/.pnpm/@babel+template@7.25.9/node_modules/@babel/template/lib/formatters.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.statements=exports.statement=exports.smart=exports.program=exports.expression=void 0;var _t=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js");const{assertExpressionStatement}=_t;function makeStatementFormatter(fn){return {code:str=>`/* @babel/template */;\n${str}`,validate:()=>{},unwrap:ast=>fn(ast.program.body.slice(1))}}exports.smart=makeStatementFormatter((body=>body.length>1?body:body[0])),exports.statements=makeStatementFormatter((body=>body)),exports.statement=makeStatementFormatter((body=>{if(0===body.length)throw new Error("Found nothing to return.");if(body.length>1)throw new Error("Found multiple statements but wanted one");return body[0]}));const expression=exports.expression={code:str=>`(\n${str}\n)`,validate:ast=>{if(ast.program.body.length>1)throw new Error("Found multiple statements but wanted one");if(0===expression.unwrap(ast).start)throw new Error("Parse result included parens.")},unwrap:({program})=>{const[stmt]=program.body;return assertExpressionStatement(stmt),stmt.expression}};exports.program={code:str=>str,validate:()=>{},unwrap:ast=>ast.program};},"./node_modules/.pnpm/@babel+template@7.25.9/node_modules/@babel/template/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.statements=exports.statement=exports.smart=exports.program=exports.expression=exports.default=void 0;var formatters=__webpack_require__("./node_modules/.pnpm/@babel+template@7.25.9/node_modules/@babel/template/lib/formatters.js"),_builder=__webpack_require__("./node_modules/.pnpm/@babel+template@7.25.9/node_modules/@babel/template/lib/builder.js");const smart=exports.smart=(0, _builder.default)(formatters.smart),statement=exports.statement=(0, _builder.default)(formatters.statement),statements=exports.statements=(0, _builder.default)(formatters.statements),expression=exports.expression=(0, _builder.default)(formatters.expression),program=exports.program=(0, _builder.default)(formatters.program);exports.default=Object.assign(smart.bind(void 0),{smart,statement,statements,expression,program,ast:smart.ast});},"./node_modules/.pnpm/@babel+template@7.25.9/node_modules/@babel/template/lib/literal.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(formatter,tpl,opts){const{metadata,names}=function(formatter,tpl,opts){let prefix="BABEL_TPL$";const raw=tpl.join("");do{prefix="$$"+prefix;}while(raw.includes(prefix));const{names,code}=function(tpl,prefix){const names=[];let code=tpl[0];for(let i=1;i<tpl.length;i++){const value=`${prefix}${i-1}`;names.push(value),code+=value+tpl[i];}return {names,code}}(tpl,prefix),metadata=(0, _parse.default)(formatter,formatter.code(code),{parser:opts.parser,placeholderWhitelist:new Set(names.concat(opts.placeholderWhitelist?Array.from(opts.placeholderWhitelist):[])),placeholderPattern:opts.placeholderPattern,preserveComments:opts.preserveComments,syntacticPlaceholders:opts.syntacticPlaceholders});return {metadata,names}}(formatter,tpl,opts);return arg=>{const defaultReplacements={};return arg.forEach(((replacement,i)=>{defaultReplacements[names[i]]=replacement;})),arg=>{const replacements=(0, _options.normalizeReplacements)(arg);return replacements&&Object.keys(replacements).forEach((key=>{if(hasOwnProperty.call(defaultReplacements,key))throw new Error("Unexpected replacement overlap.")})),formatter.unwrap((0, _populate.default)(metadata,replacements?Object.assign(replacements,defaultReplacements):defaultReplacements))}}};var _options=__webpack_require__("./node_modules/.pnpm/@babel+template@7.25.9/node_modules/@babel/template/lib/options.js"),_parse=__webpack_require__("./node_modules/.pnpm/@babel+template@7.25.9/node_modules/@babel/template/lib/parse.js"),_populate=__webpack_require__("./node_modules/.pnpm/@babel+template@7.25.9/node_modules/@babel/template/lib/populate.js");},"./node_modules/.pnpm/@babel+template@7.25.9/node_modules/@babel/template/lib/options.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.merge=function(a,b){const{placeholderWhitelist=a.placeholderWhitelist,placeholderPattern=a.placeholderPattern,preserveComments=a.preserveComments,syntacticPlaceholders=a.syntacticPlaceholders}=b;return {parser:Object.assign({},a.parser,b.parser),placeholderWhitelist,placeholderPattern,preserveComments,syntacticPlaceholders}},exports.normalizeReplacements=function(replacements){if(Array.isArray(replacements))return replacements.reduce(((acc,replacement,i)=>(acc["$"+i]=replacement,acc)),{});if("object"==typeof replacements||null==replacements)return replacements||void 0;throw new Error("Template replacements must be an array, object, null, or undefined")},exports.validate=function(opts){if(null!=opts&&"object"!=typeof opts)throw new Error("Unknown template options.");const _ref=opts||{},{placeholderWhitelist,placeholderPattern,preserveComments,syntacticPlaceholders}=_ref,parser=function(r,e){if(null==r)return {};var t={};for(var n in r)if({}.hasOwnProperty.call(r,n)){if(e.includes(n))continue;t[n]=r[n];}return t}(_ref,_excluded);if(null!=placeholderWhitelist&&!(placeholderWhitelist instanceof Set))throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");if(null!=placeholderPattern&&!(placeholderPattern instanceof RegExp)&&false!==placeholderPattern)throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");if(null!=preserveComments&&"boolean"!=typeof preserveComments)throw new Error("'.preserveComments' must be a boolean, null, or undefined");if(null!=syntacticPlaceholders&&"boolean"!=typeof syntacticPlaceholders)throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");if(true===syntacticPlaceholders&&(null!=placeholderWhitelist||null!=placeholderPattern))throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");return {parser,placeholderWhitelist:placeholderWhitelist||void 0,placeholderPattern:null==placeholderPattern?void 0:placeholderPattern,preserveComments:null==preserveComments?void 0:preserveComments,syntacticPlaceholders:null==syntacticPlaceholders?void 0:syntacticPlaceholders}};const _excluded=["placeholderWhitelist","placeholderPattern","preserveComments","syntacticPlaceholders"];},"./node_modules/.pnpm/@babel+template@7.25.9/node_modules/@babel/template/lib/parse.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(formatter,code,opts){const{placeholderWhitelist,placeholderPattern,preserveComments,syntacticPlaceholders}=opts,ast=function(code,parserOpts,syntacticPlaceholders){const plugins=(parserOpts.plugins||[]).slice();false!==syntacticPlaceholders&&plugins.push("placeholders");parserOpts=Object.assign({allowReturnOutsideFunction:true,allowSuperOutsideMethod:true,sourceType:"module"},parserOpts,{plugins});try{return (0,_parser.parse)(code,parserOpts)}catch(err){const loc=err.loc;throw loc&&(err.message+="\n"+(0, _codeFrame.codeFrameColumns)(code,{start:loc}),err.code="BABEL_TEMPLATE_PARSE_ERROR"),err}}(code,opts.parser,syntacticPlaceholders);removePropertiesDeep(ast,{preserveComments}),formatter.validate(ast);const state={syntactic:{placeholders:[],placeholderNames:new Set},legacy:{placeholders:[],placeholderNames:new Set},placeholderWhitelist,placeholderPattern,syntacticPlaceholders};return traverse(ast,placeholderVisitorHandler,state),Object.assign({ast},state.syntactic.placeholders.length?state.syntactic:state.legacy)};var _t=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js"),_parser=__webpack_require__("./node_modules/.pnpm/@babel+parser@7.26.3/node_modules/@babel/parser/lib/index.js"),_codeFrame=__webpack_require__("./stubs/babel-codeframe.mjs");const{isCallExpression,isExpressionStatement,isFunction,isIdentifier,isJSXIdentifier,isNewExpression,isPlaceholder,isStatement,isStringLiteral,removePropertiesDeep,traverse}=_t,PATTERN=/^[_$A-Z0-9]+$/;function placeholderVisitorHandler(node,ancestors,state){var _state$placeholderWhi;let name,hasSyntacticPlaceholders=state.syntactic.placeholders.length>0;if(isPlaceholder(node)){if(false===state.syntacticPlaceholders)throw new Error("%%foo%%-style placeholders can't be used when '.syntacticPlaceholders' is false.");name=node.name.name,hasSyntacticPlaceholders=true;}else {if(hasSyntacticPlaceholders||state.syntacticPlaceholders)return;if(isIdentifier(node)||isJSXIdentifier(node))name=node.name;else {if(!isStringLiteral(node))return;name=node.value;}}if(hasSyntacticPlaceholders&&(null!=state.placeholderPattern||null!=state.placeholderWhitelist))throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");if(!(hasSyntacticPlaceholders||false!==state.placeholderPattern&&(state.placeholderPattern||PATTERN).test(name)||null!=(_state$placeholderWhi=state.placeholderWhitelist)&&_state$placeholderWhi.has(name)))return;ancestors=ancestors.slice();const{node:parent,key}=ancestors[ancestors.length-1];let type;isStringLiteral(node)||isPlaceholder(node,{expectedNode:"StringLiteral"})?type="string":isNewExpression(parent)&&"arguments"===key||isCallExpression(parent)&&"arguments"===key||isFunction(parent)&&"params"===key?type="param":isExpressionStatement(parent)&&!isPlaceholder(node)?(type="statement",ancestors=ancestors.slice(0,-1)):type=isStatement(node)&&isPlaceholder(node)?"statement":"other";const{placeholders,placeholderNames}=hasSyntacticPlaceholders?state.syntactic:state.legacy;placeholders.push({name,type,resolve:ast=>function(ast,ancestors){let parent=ast;for(let i=0;i<ancestors.length-1;i++){const{key,index}=ancestors[i];parent=void 0===index?parent[key]:parent[key][index];}const{key,index}=ancestors[ancestors.length-1];return {parent,key,index}}(ast,ancestors),isDuplicate:placeholderNames.has(name)}),placeholderNames.add(name);}},"./node_modules/.pnpm/@babel+template@7.25.9/node_modules/@babel/template/lib/populate.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(metadata,replacements){const ast=cloneNode(metadata.ast);replacements&&(metadata.placeholders.forEach((placeholder=>{if(!hasOwnProperty.call(replacements,placeholder.name)){const placeholderName=placeholder.name;throw new Error(`Error: No substitution given for "${placeholderName}". If this is not meant to be a\n            placeholder you may want to consider passing one of the following options to @babel/template:\n            - { placeholderPattern: false, placeholderWhitelist: new Set(['${placeholderName}'])}\n            - { placeholderPattern: /^${placeholderName}$/ }`)}})),Object.keys(replacements).forEach((key=>{if(!metadata.placeholderNames.has(key))throw new Error(`Unknown substitution "${key}" given`)})));return metadata.placeholders.slice().reverse().forEach((placeholder=>{try{!function(placeholder,ast,replacement){placeholder.isDuplicate&&(Array.isArray(replacement)?replacement=replacement.map((node=>cloneNode(node))):"object"==typeof replacement&&(replacement=cloneNode(replacement)));const{parent,key,index}=placeholder.resolve(ast);if("string"===placeholder.type){if("string"==typeof replacement&&(replacement=stringLiteral(replacement)),!replacement||!isStringLiteral(replacement))throw new Error("Expected string substitution")}else if("statement"===placeholder.type)void 0===index?replacement?Array.isArray(replacement)?replacement=blockStatement(replacement):"string"==typeof replacement?replacement=expressionStatement(identifier(replacement)):isStatement(replacement)||(replacement=expressionStatement(replacement)):replacement=emptyStatement():replacement&&!Array.isArray(replacement)&&("string"==typeof replacement&&(replacement=identifier(replacement)),isStatement(replacement)||(replacement=expressionStatement(replacement)));else if("param"===placeholder.type){if("string"==typeof replacement&&(replacement=identifier(replacement)),void 0===index)throw new Error("Assertion failure.")}else if("string"==typeof replacement&&(replacement=identifier(replacement)),Array.isArray(replacement))throw new Error("Cannot replace single expression with an array.");function set(parent,key,value){const node=parent[key];parent[key]=value,"Identifier"!==node.type&&"Placeholder"!==node.type||(node.typeAnnotation&&(value.typeAnnotation=node.typeAnnotation),node.optional&&(value.optional=node.optional),node.decorators&&(value.decorators=node.decorators));}if(void 0===index)validate(parent,key,replacement),set(parent,key,replacement);else {const items=parent[key].slice();"statement"===placeholder.type||"param"===placeholder.type?null==replacement?items.splice(index,1):Array.isArray(replacement)?items.splice(index,1,...replacement):set(items,index,replacement):set(items,index,replacement),validate(parent,key,items),parent[key]=items;}}(placeholder,ast,replacements&&replacements[placeholder.name]||null);}catch(e){throw e.message=`@babel/template placeholder "${placeholder.name}": ${e.message}`,e}})),ast};var _t=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js");const{blockStatement,cloneNode,emptyStatement,expressionStatement,identifier,isStatement,isStringLiteral,stringLiteral,validate}=_t;},"./node_modules/.pnpm/@babel+template@7.25.9/node_modules/@babel/template/lib/string.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(formatter,code,opts){let metadata;return code=formatter.code(code),arg=>{const replacements=(0, _options.normalizeReplacements)(arg);return metadata||(metadata=(0, _parse.default)(formatter,code,opts)),formatter.unwrap((0, _populate.default)(metadata,replacements))}};var _options=__webpack_require__("./node_modules/.pnpm/@babel+template@7.25.9/node_modules/@babel/template/lib/options.js"),_parse=__webpack_require__("./node_modules/.pnpm/@babel+template@7.25.9/node_modules/@babel/template/lib/parse.js"),_populate=__webpack_require__("./node_modules/.pnpm/@babel+template@7.25.9/node_modules/@babel/template/lib/populate.js");},"./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/cache.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.clear=function(){clearPath(),clearScope();},exports.clearPath=clearPath,exports.clearScope=clearScope,exports.getCachedPaths=function(hub,parent){var _pathsCache$get;return null==(_pathsCache$get=pathsCache.get(nullHub))?void 0:_pathsCache$get.get(parent)},exports.getOrCreateCachedPaths=function(hub,parent){let parents=pathsCache.get(nullHub);parents||pathsCache.set(nullHub,parents=new WeakMap);let paths=parents.get(parent);paths||parents.set(parent,paths=new Map);return paths},exports.scope=exports.path=void 0;let pathsCache=exports.path=new WeakMap,scope=exports.scope=new WeakMap;function clearPath(){exports.path=pathsCache=new WeakMap;}function clearScope(){exports.scope=scope=new WeakMap;}const nullHub=Object.freeze({});},"./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/context.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=void 0;var _index=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/index.js"),_t=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js"),_context=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/context.js");const{VISITOR_KEYS}=_t;exports.default=class{constructor(scope,opts,state,parentPath){this.queue=null,this.priorityQueue=null,this.parentPath=parentPath,this.scope=scope,this.state=state,this.opts=opts;}shouldVisit(node){const opts=this.opts;if(opts.enter||opts.exit)return  true;if(opts[node.type])return  true;const keys=VISITOR_KEYS[node.type];if(null==keys||!keys.length)return  false;for(const key of keys)if(node[key])return  true;return  false}create(node,container,key,listKey){return _index.default.get({parentPath:this.parentPath,parent:node,container,key,listKey})}maybeQueue(path,notPriority){this.queue&&(notPriority?this.queue.push(path):this.priorityQueue.push(path));}visitMultiple(container,parent,listKey){if(0===container.length)return  false;const queue=[];for(let key=0;key<container.length;key++){const node=container[key];node&&this.shouldVisit(node)&&queue.push(this.create(parent,container,key,listKey));}return this.visitQueue(queue)}visitSingle(node,key){return !!this.shouldVisit(node[key])&&this.visitQueue([this.create(node,node,key)])}visitQueue(queue){this.queue=queue,this.priorityQueue=[];const visited=new WeakSet;let stop=false,visitIndex=0;for(;visitIndex<queue.length;){const path=queue[visitIndex];if(visitIndex++,_context.resync.call(path),0!==path.contexts.length&&path.contexts[path.contexts.length-1]===this||_context.pushContext.call(path,this),null===path.key)continue;const{node}=path;if(!visited.has(node)){if(node&&visited.add(node),path.visit()){stop=true;break}if(this.priorityQueue.length&&(stop=this.visitQueue(this.priorityQueue),this.priorityQueue=[],this.queue=queue,stop))break}}for(let i=0;i<visitIndex;i++)_context.popContext.call(queue[i]);return this.queue=null,stop}visit(node,key){const nodes=node[key];return !!nodes&&(Array.isArray(nodes)?this.visitMultiple(nodes,node,key):this.visitSingle(node,key))}};},"./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/hub.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=void 0;exports.default=class{getCode(){}getScope(){}addHelper(){throw new Error("Helpers are not supported by the default hub.")}buildError(node,msg,Error=TypeError){return new Error(msg)}};},"./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),Object.defineProperty(exports,"Hub",{enumerable:true,get:function(){return _hub.default}}),Object.defineProperty(exports,"NodePath",{enumerable:true,get:function(){return _index.default}}),Object.defineProperty(exports,"Scope",{enumerable:true,get:function(){return _index2.default}}),exports.visitors=exports.default=void 0,__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/context.js");var visitors=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/visitors.js");exports.visitors=visitors;var _t=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js"),cache=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/cache.js"),_traverseNode=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/traverse-node.js"),_index=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/index.js"),_index2=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/scope/index.js"),_hub=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/hub.js");const{VISITOR_KEYS,removeProperties,traverseFast}=_t;function traverse(parent,opts={},scope,state,parentPath,visitSelf){if(parent){if(!opts.noScope&&!scope&&"Program"!==parent.type&&"File"!==parent.type)throw new Error(`You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a ${parent.type} node without passing scope and parentPath.`);if(!parentPath&&visitSelf)throw new Error("visitSelf can only be used when providing a NodePath.");VISITOR_KEYS[parent.type]&&(visitors.explode(opts),(0, _traverseNode.traverseNode)(parent,opts,scope,state,parentPath,null,visitSelf));}}exports.default=traverse;function hasDenylistedType(path,state){path.node.type===state.type&&(state.has=true,path.stop());}traverse.visitors=visitors,traverse.verify=visitors.verify,traverse.explode=visitors.explode,traverse.cheap=function(node,enter){traverseFast(node,enter);},traverse.node=function(node,opts,scope,state,path,skipKeys){(0, _traverseNode.traverseNode)(node,opts,scope,state,path,skipKeys);},traverse.clearNode=function(node,opts){removeProperties(node,opts);},traverse.removeProperties=function(tree,opts){return traverseFast(tree,traverse.clearNode,opts),tree},traverse.hasType=function(tree,type,denylistTypes){if(null!=denylistTypes&&denylistTypes.includes(tree.type))return  false;if(tree.type===type)return  true;const state={has:false,type};return traverse(tree,{noScope:true,denylist:denylistTypes,enter:hasDenylistedType},null,state),state.has},traverse.cache=cache;},"./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/ancestry.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.find=function(callback){let path=this;do{if(callback(path))return path}while(path=path.parentPath);return null},exports.findParent=function(callback){let path=this;for(;path=path.parentPath;)if(callback(path))return path;return null},exports.getAncestry=function(){let path=this;const paths=[];do{paths.push(path);}while(path=path.parentPath);return paths},exports.getDeepestCommonAncestorFrom=function(paths,filter){if(!paths.length)return this;if(1===paths.length)return paths[0];let lastCommonIndex,lastCommon,minDepth=1/0;const ancestries=paths.map((path=>{const ancestry=[];do{ancestry.unshift(path);}while((path=path.parentPath)&&path!==this);return ancestry.length<minDepth&&(minDepth=ancestry.length),ancestry})),first=ancestries[0];depthLoop:for(let i=0;i<minDepth;i++){const shouldMatch=first[i];for(const ancestry of ancestries)if(ancestry[i]!==shouldMatch)break depthLoop;lastCommonIndex=i,lastCommon=shouldMatch;}if(lastCommon)return filter?filter(lastCommon,lastCommonIndex,ancestries):lastCommon;throw new Error("Couldn't find intersection")},exports.getEarliestCommonAncestorFrom=function(paths){return this.getDeepestCommonAncestorFrom(paths,(function(deepest,i,ancestries){let earliest;const keys=VISITOR_KEYS[deepest.type];for(const ancestry of ancestries){const path=ancestry[i+1];if(!earliest){earliest=path;continue}if(path.listKey&&earliest.listKey===path.listKey&&path.key<earliest.key){earliest=path;continue}keys.indexOf(earliest.parentKey)>keys.indexOf(path.parentKey)&&(earliest=path);}return earliest}))},exports.getFunctionParent=function(){return this.findParent((p=>p.isFunction()))},exports.getStatementParent=function(){let path=this;do{if(!path.parentPath||Array.isArray(path.container)&&path.isStatement())break;path=path.parentPath;}while(path);if(path&&(path.isProgram()||path.isFile()))throw new Error("File/Program node, we can't possibly find a statement parent to this");return path},exports.inType=function(...candidateTypes){let path=this;for(;path;){for(const type of candidateTypes)if(path.node.type===type)return  true;path=path.parentPath;}return  false},exports.isAncestor=function(maybeDescendant){return maybeDescendant.isDescendant(this)},exports.isDescendant=function(maybeAncestor){return !!this.findParent((parent=>parent===maybeAncestor))};var _t=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js");const{VISITOR_KEYS}=_t;},"./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/comments.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.addComment=function(type,content,line){_addComment(this.node,type,content,line);},exports.addComments=function(type,comments){_addComments(this.node,type,comments);},exports.shareCommentsWithSiblings=function(){if("string"==typeof this.key)return;const node=this.node;if(!node)return;const trailing=node.trailingComments,leading=node.leadingComments;if(!trailing&&!leading)return;const prev=this.getSibling(this.key-1),next=this.getSibling(this.key+1),hasPrev=Boolean(prev.node),hasNext=Boolean(next.node);hasPrev&&(leading&&prev.addComments("trailing",removeIfExisting(leading,prev.node.trailingComments)),trailing&&!hasNext&&prev.addComments("trailing",trailing));hasNext&&(trailing&&next.addComments("leading",removeIfExisting(trailing,next.node.leadingComments)),leading&&!hasPrev&&next.addComments("leading",leading));};var _t=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js");const{addComment:_addComment,addComments:_addComments}=_t;function removeIfExisting(list,toRemove){if(null==toRemove||!toRemove.length)return list;const set=new Set(toRemove);return list.filter((el=>!set.has(el)))}},"./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/context.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports._call=_call,exports._getQueueContexts=function(){let path=this,contexts=this.contexts;for(;!contexts.length&&(path=path.parentPath,path);)contexts=path.contexts;return contexts},exports._resyncKey=_resyncKey,exports._resyncList=_resyncList,exports._resyncParent=_resyncParent,exports._resyncRemoved=function(){null!=this.key&&this.container&&this.container[this.key]===this.node||_removal._markRemoved.call(this);},exports.call=call,exports.isDenylisted=isDenylisted,exports.popContext=function(){this.contexts.pop(),this.contexts.length>0?this.setContext(this.contexts[this.contexts.length-1]):this.setContext(void 0);},exports.pushContext=function(context){this.contexts.push(context),this.setContext(context);},exports.requeue=function(pathToQueue=this){if(pathToQueue.removed)return;const contexts=this.contexts;for(const context of contexts)context.maybeQueue(pathToQueue);},exports.requeueComputedKeyAndDecorators=function(){const{context,node}=this;!t.isPrivate(node)&&node.computed&&context.maybeQueue(this.get("key"));if(node.decorators)for(const decorator of this.get("decorators"))context.maybeQueue(decorator);},exports.resync=function(){if(this.removed)return;_resyncParent.call(this),_resyncList.call(this),_resyncKey.call(this);},exports.setContext=function(context){null!=this.skipKeys&&(this.skipKeys={});this._traverseFlags=0,context&&(this.context=context,this.state=context.state,this.opts=context.opts);return setScope.call(this),this},exports.setKey=setKey,exports.setScope=setScope,exports.setup=function(parentPath,container,listKey,key){this.listKey=listKey,this.container=container,this.parentPath=parentPath||this.parentPath,setKey.call(this,key);},exports.skip=function(){this.shouldSkip=true;},exports.skipKey=function(key){null==this.skipKeys&&(this.skipKeys={});this.skipKeys[key]=true;},exports.stop=function(){this._traverseFlags|=_index.SHOULD_SKIP|_index.SHOULD_STOP;},exports.visit=function(){var _this$opts$shouldSkip,_this$opts;if(!this.node)return  false;if(this.isDenylisted())return  false;if(null!=(_this$opts$shouldSkip=(_this$opts=this.opts).shouldSkip)&&_this$opts$shouldSkip.call(_this$opts,this))return  false;const currentContext=this.context;if(this.shouldSkip||call.call(this,"enter"))return this.debug("Skip..."),this.shouldStop;return restoreContext(this,currentContext),this.debug("Recursing into..."),this.shouldStop=(0, _traverseNode.traverseNode)(this.node,this.opts,this.scope,this.state,this,this.skipKeys),restoreContext(this,currentContext),call.call(this,"exit"),this.shouldStop};var _traverseNode=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/traverse-node.js"),_index=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/index.js"),_removal=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/removal.js"),t=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js");function call(key){const opts=this.opts;return this.debug(key),!(!this.node||!_call.call(this,opts[key]))||!!this.node&&_call.call(this,null==(_opts$this$node$type=opts[this.node.type])?void 0:_opts$this$node$type[key]);var _opts$this$node$type;}function _call(fns){if(!fns)return  false;for(const fn of fns){if(!fn)continue;const node=this.node;if(!node)return  true;const ret=fn.call(this.state,this,this.state);if(ret&&"object"==typeof ret&&"function"==typeof ret.then)throw new Error("You appear to be using a plugin with an async traversal visitor, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");if(ret)throw new Error(`Unexpected return value from visitor method ${fn}`);if(this.node!==node)return  true;if(this._traverseFlags>0)return  true}return  false}function isDenylisted(){var _this$opts$denylist;const denylist=null!=(_this$opts$denylist=this.opts.denylist)?_this$opts$denylist:this.opts.blacklist;return null==denylist?void 0:denylist.includes(this.node.type)}function restoreContext(path,context){path.context!==context&&(path.context=context,path.state=context.state,path.opts=context.opts);}function setScope(){var _this$opts2,_this$scope;if(null!=(_this$opts2=this.opts)&&_this$opts2.noScope)return;let target,path=this.parentPath;for((("key"===this.key||"decorators"===this.listKey)&&path.isMethod()||"discriminant"===this.key&&path.isSwitchStatement())&&(path=path.parentPath);path&&!target;){var _path$opts;if(null!=(_path$opts=path.opts)&&_path$opts.noScope)return;target=path.scope,path=path.parentPath;}this.scope=this.getScope(target),null==(_this$scope=this.scope)||_this$scope.init();}function _resyncParent(){this.parentPath&&(this.parent=this.parentPath.node);}function _resyncKey(){if(this.container&&this.node!==this.container[this.key]){if(Array.isArray(this.container)){for(let i=0;i<this.container.length;i++)if(this.container[i]===this.node)return void setKey.call(this,i)}else for(const key of Object.keys(this.container))if(this.container[key]===this.node)return void setKey.call(this,key);this.key=null;}}function _resyncList(){if(!this.parent||!this.inList)return;const newContainer=this.parent[this.listKey];this.container!==newContainer&&(this.container=newContainer||null);}function setKey(key){var _this$node;this.key=key,this.node=this.container[this.key],this.type=null==(_this$node=this.node)?void 0:_this$node.type;}exports.isBlacklisted=isDenylisted;},"./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/conversion.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.arrowFunctionToExpression=function({allowInsertArrow=true,allowInsertArrowWithRest=allowInsertArrow,noNewArrows=!(_arguments$=>null==(_arguments$=arguments[0])?void 0:_arguments$.specCompliant)()}={}){if(!this.isArrowFunctionExpression())throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");let self=this;var _self$ensureFunctionN;noNewArrows||(self=null!=(_self$ensureFunctionN=self.ensureFunctionName(false))?_self$ensureFunctionN:self);const{thisBinding,fnPath:fn}=hoistFunctionEnvironment(self,noNewArrows,allowInsertArrow,allowInsertArrowWithRest);if(fn.ensureBlock(),function(path,type){path.node.type=type;}(fn,"FunctionExpression"),!noNewArrows){const checkBinding=thisBinding?null:fn.scope.generateUidIdentifier("arrowCheckId");return checkBinding&&fn.parentPath.scope.push({id:checkBinding,init:objectExpression([])}),fn.get("body").unshiftContainer("body",expressionStatement(callExpression(this.hub.addHelper("newArrowCheck"),[thisExpression(),identifier(checkBinding?checkBinding.name:thisBinding)]))),fn.replaceWith(callExpression(memberExpression(fn.node,identifier("bind")),[checkBinding?identifier(checkBinding.name):thisExpression()])),fn.get("callee.object")}return fn},exports.ensureBlock=function(){const body=this.get("body"),bodyNode=body.node;if(Array.isArray(body))throw new Error("Can't convert array path to a block statement");if(!bodyNode)throw new Error("Can't convert node without a body");if(body.isBlockStatement())return bodyNode;const statements=[];let key,listKey,stringPath="body";body.isStatement()?(listKey="body",key=0,statements.push(body.node)):(stringPath+=".body.0",this.isFunction()?(key="argument",statements.push(returnStatement(body.node))):(key="expression",statements.push(expressionStatement(body.node))));this.node.body=blockStatement(statements);const parentPath=this.get(stringPath);return _context.setup.call(body,parentPath,listKey?parentPath.node[listKey]:parentPath.node,listKey,key),this.node},exports.ensureFunctionName=function(supportUnicodeId){if(this.node.id)return this;const res=getFunctionName(this.node,this.parent);if(null==res)return this;let{name}=res;if(!supportUnicodeId&&/[\uD800-\uDFFF]/.test(name))return null;if(name.startsWith("get ")||name.startsWith("set "))return null;name=toBindingIdentifierName(name.replace(/[/ ]/g,"_"));const id=identifier(name);inherits(id,res.originalNode);const state={needsRename:false,name},{scope}=this,binding=scope.getOwnBinding(name);binding?"param"===binding.kind&&(state.needsRename=true):(scope.parent.hasBinding(name)||scope.hasGlobal(name))&&this.traverse(refersOuterBindingVisitor,state);if(!state.needsRename)return this.node.id=id,scope.getProgramParent().references[id.name]=true,this;if(scope.hasBinding(id.name)&&!scope.hasGlobal(id.name))return scope.rename(id.name),this.node.id=id,scope.getProgramParent().references[id.name]=true,this;if(!isFunction(this.node))return null;const key=scope.generateUidIdentifier(id.name),params=[];for(let i=0,len=function(node){const count=node.params.findIndex((param=>isAssignmentPattern(param)||isRestElement(param)));return  -1===count?node.params.length:count}(this.node);i<len;i++)params.push(scope.generateUidIdentifier("x"));const call=_template.default.expression.ast`
    (function (${key}) {
      function ${id}(${params}) {
        return ${cloneNode(key)}.apply(this, arguments);
      }

      ${cloneNode(id)}.toString = function () {
        return ${cloneNode(key)}.toString();
      }

      return ${cloneNode(id)};
    })(${toExpression(this.node)})
  `;return this.replaceWith(call)[0].get("arguments.0")},exports.splitExportDeclaration=function(){if(!this.isExportDeclaration()||this.isExportAllDeclaration())throw new Error("Only default and named export declarations can be split.");if(this.isExportNamedDeclaration()&&this.get("specifiers").length>0)throw new Error("It doesn't make sense to split exported specifiers.");const declaration=this.get("declaration");if(this.isExportDefaultDeclaration()){const standaloneDeclaration=declaration.isFunctionDeclaration()||declaration.isClassDeclaration(),exportExpr=declaration.isFunctionExpression()||declaration.isClassExpression(),scope=declaration.isScope()?declaration.scope.parent:declaration.scope;let id=declaration.node.id,needBindingRegistration=false;id?exportExpr&&scope.hasBinding(id.name)&&(needBindingRegistration=true,id=scope.generateUidIdentifier(id.name)):(needBindingRegistration=true,id=scope.generateUidIdentifier("default"),(standaloneDeclaration||exportExpr)&&(declaration.node.id=cloneNode(id)));const updatedDeclaration=standaloneDeclaration?declaration.node:variableDeclaration("var",[variableDeclarator(cloneNode(id),declaration.node)]),updatedExportDeclaration=exportNamedDeclaration(null,[exportSpecifier(cloneNode(id),identifier("default"))]);return this.insertAfter(updatedExportDeclaration),this.replaceWith(updatedDeclaration),needBindingRegistration&&scope.registerDeclaration(this),this}if(this.get("specifiers").length>0)throw new Error("It doesn't make sense to split exported specifiers.");const bindingIdentifiers=declaration.getOuterBindingIdentifiers(),specifiers=Object.keys(bindingIdentifiers).map((name=>exportSpecifier(identifier(name),identifier(name)))),aliasDeclar=exportNamedDeclaration(null,specifiers);return this.insertAfter(aliasDeclar),this.replaceWith(declaration.node),this},exports.toComputedKey=function(){let key;if(this.isMemberExpression())key=this.node.property;else {if(!this.isProperty()&&!this.isMethod())throw new ReferenceError("todo");key=this.node.key;}this.node.computed||isIdentifier(key)&&(key=stringLiteral(key.name));return key},exports.unwrapFunctionEnvironment=function(){if(!this.isArrowFunctionExpression()&&!this.isFunctionExpression()&&!this.isFunctionDeclaration())throw this.buildCodeFrameError("Can only unwrap the environment of a function.");hoistFunctionEnvironment(this);};var _t=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js"),_template=__webpack_require__("./node_modules/.pnpm/@babel+template@7.25.9/node_modules/@babel/template/lib/index.js"),_visitors=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/visitors.js"),_context=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/context.js");const{arrowFunctionExpression,assignmentExpression,binaryExpression,blockStatement,callExpression,conditionalExpression,expressionStatement,identifier,isIdentifier,jsxIdentifier,logicalExpression,LOGICAL_OPERATORS,memberExpression,metaProperty,numericLiteral,objectExpression,restElement,returnStatement,sequenceExpression,spreadElement,stringLiteral,super:_super,thisExpression,toExpression,unaryExpression,toBindingIdentifierName,isFunction,isAssignmentPattern,isRestElement,getFunctionName,cloneNode,variableDeclaration,variableDeclarator,exportNamedDeclaration,exportSpecifier,inherits}=_t;exports.arrowFunctionToShadowed=function(){this.isArrowFunctionExpression()&&this.arrowFunctionToExpression();};const getSuperCallsVisitor=(0, _visitors.environmentVisitor)({CallExpression(child,{allSuperCalls}){child.get("callee").isSuper()&&allSuperCalls.push(child);}});function hoistFunctionEnvironment(fnPath,noNewArrows=true,allowInsertArrow=true,allowInsertArrowWithRest=true){let arrowParent,thisEnvFn=fnPath.findParent((p=>p.isArrowFunctionExpression()?(null!=arrowParent||(arrowParent=p),false):p.isFunction()||p.isProgram()||p.isClassProperty({static:false})||p.isClassPrivateProperty({static:false})));const inConstructor=thisEnvFn.isClassMethod({kind:"constructor"});if(thisEnvFn.isClassProperty()||thisEnvFn.isClassPrivateProperty())if(arrowParent)thisEnvFn=arrowParent;else {if(!allowInsertArrow)throw fnPath.buildCodeFrameError("Unable to transform arrow inside class property");fnPath.replaceWith(callExpression(arrowFunctionExpression([],toExpression(fnPath.node)),[])),thisEnvFn=fnPath.get("callee"),fnPath=thisEnvFn.get("body");}const{thisPaths,argumentsPaths,newTargetPaths,superProps,superCalls}=function(fnPath){const thisPaths=[],argumentsPaths=[],newTargetPaths=[],superProps=[],superCalls=[];return fnPath.traverse(getScopeInformationVisitor,{thisPaths,argumentsPaths,newTargetPaths,superProps,superCalls}),{thisPaths,argumentsPaths,newTargetPaths,superProps,superCalls}}(fnPath);if(inConstructor&&superCalls.length>0){if(!allowInsertArrow)throw superCalls[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super()` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");if(!allowInsertArrowWithRest)throw superCalls[0].buildCodeFrameError("When using '@babel/plugin-transform-parameters', it's not possible to compile `super()` in an arrow function with default or rest parameters without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");const allSuperCalls=[];thisEnvFn.traverse(getSuperCallsVisitor,{allSuperCalls});const superBinding=function(thisEnvFn){return getBinding(thisEnvFn,"supercall",(()=>{const argsBinding=thisEnvFn.scope.generateUidIdentifier("args");return arrowFunctionExpression([restElement(argsBinding)],callExpression(_super(),[spreadElement(identifier(argsBinding.name))]))}))}(thisEnvFn);allSuperCalls.forEach((superCall=>{const callee=identifier(superBinding);callee.loc=superCall.node.callee.loc,superCall.get("callee").replaceWith(callee);}));}if(argumentsPaths.length>0){const argumentsBinding=getBinding(thisEnvFn,"arguments",(()=>{const args=()=>identifier("arguments");return thisEnvFn.scope.path.isProgram()?conditionalExpression(binaryExpression("===",unaryExpression("typeof",args()),stringLiteral("undefined")),thisEnvFn.scope.buildUndefinedNode(),args()):args()}));argumentsPaths.forEach((argumentsChild=>{const argsRef=identifier(argumentsBinding);argsRef.loc=argumentsChild.node.loc,argumentsChild.replaceWith(argsRef);}));}if(newTargetPaths.length>0){const newTargetBinding=getBinding(thisEnvFn,"newtarget",(()=>metaProperty(identifier("new"),identifier("target"))));newTargetPaths.forEach((targetChild=>{const targetRef=identifier(newTargetBinding);targetRef.loc=targetChild.node.loc,targetChild.replaceWith(targetRef);}));}if(superProps.length>0){if(!allowInsertArrow)throw superProps[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super.prop` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");superProps.reduce(((acc,superProp)=>acc.concat(function(superProp){if(superProp.parentPath.isAssignmentExpression()&&"="!==superProp.parentPath.node.operator){const assignmentPath=superProp.parentPath,op=assignmentPath.node.operator.slice(0,-1),value=assignmentPath.node.right,isLogicalAssignment=function(op){return LOGICAL_OPERATORS.includes(op)}(op);if(superProp.node.computed){const tmp=superProp.scope.generateDeclaredUidIdentifier("tmp"),object=superProp.node.object,property=superProp.node.property;assignmentPath.get("left").replaceWith(memberExpression(object,assignmentExpression("=",tmp,property),true)),assignmentPath.get("right").replaceWith(rightExpression(isLogicalAssignment?"=":op,memberExpression(object,identifier(tmp.name),true),value));}else {const object=superProp.node.object,property=superProp.node.property;assignmentPath.get("left").replaceWith(memberExpression(object,property)),assignmentPath.get("right").replaceWith(rightExpression(isLogicalAssignment?"=":op,memberExpression(object,identifier(property.name)),value));}return isLogicalAssignment?assignmentPath.replaceWith(logicalExpression(op,assignmentPath.node.left,assignmentPath.node.right)):assignmentPath.node.operator="=",[assignmentPath.get("left"),assignmentPath.get("right").get("left")]}if(superProp.parentPath.isUpdateExpression()){const updateExpr=superProp.parentPath,tmp=superProp.scope.generateDeclaredUidIdentifier("tmp"),computedKey=superProp.node.computed?superProp.scope.generateDeclaredUidIdentifier("prop"):null,parts=[assignmentExpression("=",tmp,memberExpression(superProp.node.object,computedKey?assignmentExpression("=",computedKey,superProp.node.property):superProp.node.property,superProp.node.computed)),assignmentExpression("=",memberExpression(superProp.node.object,computedKey?identifier(computedKey.name):superProp.node.property,superProp.node.computed),binaryExpression(superProp.parentPath.node.operator[0],identifier(tmp.name),numericLiteral(1)))];superProp.parentPath.node.prefix||parts.push(identifier(tmp.name)),updateExpr.replaceWith(sequenceExpression(parts));return [updateExpr.get("expressions.0.right"),updateExpr.get("expressions.1.left")]}return [superProp];function rightExpression(op,left,right){return "="===op?assignmentExpression("=",left,right):binaryExpression(op,left,right)}}(superProp))),[]).forEach((superProp=>{const key=superProp.node.computed?"":superProp.get("property").node.name,superParentPath=superProp.parentPath,isAssignment=superParentPath.isAssignmentExpression({left:superProp.node}),isCall=superParentPath.isCallExpression({callee:superProp.node}),isTaggedTemplate=superParentPath.isTaggedTemplateExpression({tag:superProp.node}),superBinding=function(thisEnvFn,isAssignment,propName){const op=isAssignment?"set":"get";return getBinding(thisEnvFn,`superprop_${op}:${propName||""}`,(()=>{const argsList=[];let fnBody;if(propName)fnBody=memberExpression(_super(),identifier(propName));else {const method=thisEnvFn.scope.generateUidIdentifier("prop");argsList.unshift(method),fnBody=memberExpression(_super(),identifier(method.name),true);}if(isAssignment){const valueIdent=thisEnvFn.scope.generateUidIdentifier("value");argsList.push(valueIdent),fnBody=assignmentExpression("=",fnBody,identifier(valueIdent.name));}return arrowFunctionExpression(argsList,fnBody)}))}(thisEnvFn,isAssignment,key),args=[];if(superProp.node.computed&&args.push(superProp.get("property").node),isAssignment){const value=superParentPath.node.right;args.push(value);}const call=callExpression(identifier(superBinding),args);isCall?(superParentPath.unshiftContainer("arguments",thisExpression()),superProp.replaceWith(memberExpression(call,identifier("call"))),thisPaths.push(superParentPath.get("arguments.0"))):isAssignment?superParentPath.replaceWith(call):isTaggedTemplate?(superProp.replaceWith(callExpression(memberExpression(call,identifier("bind"),false),[thisExpression()])),thisPaths.push(superProp.get("arguments.0"))):superProp.replaceWith(call);}));}let thisBinding;return (thisPaths.length>0||!noNewArrows)&&(thisBinding=function(thisEnvFn,inConstructor){return getBinding(thisEnvFn,"this",(thisBinding=>{if(!inConstructor||!hasSuperClass(thisEnvFn))return thisExpression();thisEnvFn.traverse(assignSuperThisVisitor,{supers:new WeakSet,thisBinding});}))}(thisEnvFn,inConstructor),(noNewArrows||inConstructor&&hasSuperClass(thisEnvFn))&&(thisPaths.forEach((thisChild=>{const thisRef=thisChild.isJSX()?jsxIdentifier(thisBinding):identifier(thisBinding);thisRef.loc=thisChild.node.loc,thisChild.replaceWith(thisRef);})),noNewArrows||(thisBinding=null))),{thisBinding,fnPath}}function hasSuperClass(thisEnvFn){return thisEnvFn.isClassMethod()&&!!thisEnvFn.parentPath.parentPath.node.superClass}const assignSuperThisVisitor=(0, _visitors.environmentVisitor)({CallExpression(child,{supers,thisBinding}){child.get("callee").isSuper()&&(supers.has(child.node)||(supers.add(child.node),child.replaceWithMultiple([child.node,assignmentExpression("=",identifier(thisBinding),identifier("this"))])));}});function getBinding(thisEnvFn,key,init){const cacheKey="binding:"+key;let data=thisEnvFn.getData(cacheKey);if(!data){const id=thisEnvFn.scope.generateUidIdentifier(key);data=id.name,thisEnvFn.setData(cacheKey,data),thisEnvFn.scope.push({id,init:init(data)});}return data}const getScopeInformationVisitor=(0, _visitors.environmentVisitor)({ThisExpression(child,{thisPaths}){thisPaths.push(child);},JSXIdentifier(child,{thisPaths}){"this"===child.node.name&&(child.parentPath.isJSXMemberExpression({object:child.node})||child.parentPath.isJSXOpeningElement({name:child.node}))&&thisPaths.push(child);},CallExpression(child,{superCalls}){child.get("callee").isSuper()&&superCalls.push(child);},MemberExpression(child,{superProps}){child.get("object").isSuper()&&superProps.push(child);},Identifier(child,{argumentsPaths}){if(!child.isReferencedIdentifier({name:"arguments"}))return;let curr=child.scope;do{if(curr.hasOwnBinding("arguments"))return void curr.rename("arguments");if(curr.path.isFunction()&&!curr.path.isArrowFunctionExpression())break}while(curr=curr.parent);argumentsPaths.push(child);},MetaProperty(child,{newTargetPaths}){child.get("meta").isIdentifier({name:"new"})&&child.get("property").isIdentifier({name:"target"})&&newTargetPaths.push(child);}});const refersOuterBindingVisitor={"ReferencedIdentifier|BindingIdentifier"(path,state){path.node.name===state.name&&(state.needsRename=true,path.stop());},Scope(path,state){path.scope.hasOwnBinding(state.name)&&path.skip();}};},"./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/evaluation.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.evaluate=function(){const state={confident:true,deoptPath:null,seen:new Map};let value=evaluateCached(this,state);state.confident||(value=void 0);return {confident:state.confident,deopt:state.deoptPath,value}},exports.evaluateTruthy=function(){const res=this.evaluate();if(res.confident)return !!res.value};const VALID_OBJECT_CALLEES=["Number","String","Math"],VALID_IDENTIFIER_CALLEES=["isFinite","isNaN","parseFloat","parseInt","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent",null,null],INVALID_METHODS=["random"];function isValidObjectCallee(val){return VALID_OBJECT_CALLEES.includes(val)}function deopt(path,state){state.confident&&(state.deoptPath=path,state.confident=false);}const Globals=new Map([["undefined",void 0],["Infinity",1/0],["NaN",NaN]]);function evaluateCached(path,state){const{node}=path,{seen}=state;if(seen.has(node)){const existing=seen.get(node);return existing.resolved?existing.value:void deopt(path,state)}{const item={resolved:false};seen.set(node,item);const val=function(path,state){if(!state.confident)return;if(path.isSequenceExpression()){const exprs=path.get("expressions");return evaluateCached(exprs[exprs.length-1],state)}if(path.isStringLiteral()||path.isNumericLiteral()||path.isBooleanLiteral())return path.node.value;if(path.isNullLiteral())return null;if(path.isTemplateLiteral())return evaluateQuasis(path,path.node.quasis,state);if(path.isTaggedTemplateExpression()&&path.get("tag").isMemberExpression()){const object=path.get("tag.object"),{node:{name}}=object,property=path.get("tag.property");if(object.isIdentifier()&&"String"===name&&!path.scope.getBinding(name)&&property.isIdentifier()&&"raw"===property.node.name)return evaluateQuasis(path,path.node.quasi.quasis,state,true)}if(path.isConditionalExpression()){const testResult=evaluateCached(path.get("test"),state);if(!state.confident)return;return evaluateCached(testResult?path.get("consequent"):path.get("alternate"),state)}if(path.isExpressionWrapper())return evaluateCached(path.get("expression"),state);if(path.isMemberExpression()&&!path.parentPath.isCallExpression({callee:path.node})){const property=path.get("property"),object=path.get("object");if(object.isLiteral()){const value=object.node.value,type=typeof value;let key=null;if(path.node.computed){if(key=evaluateCached(property,state),!state.confident)return}else property.isIdentifier()&&(key=property.node.name);if(!("number"!==type&&"string"!==type||null==key||"number"!=typeof key&&"string"!=typeof key))return value[key]}}if(path.isReferencedIdentifier()){const binding=path.scope.getBinding(path.node.name);if(binding){if(binding.constantViolations.length>0||path.node.start<binding.path.node.end)return void deopt(binding.path,state);if(binding.hasValue)return binding.value}const name=path.node.name;if(Globals.has(name))return binding?void deopt(binding.path,state):Globals.get(name);const resolved=path.resolve();return resolved===path?void deopt(path,state):evaluateCached(resolved,state)}if(path.isUnaryExpression({prefix:true})){if("void"===path.node.operator)return;const argument=path.get("argument");if("typeof"===path.node.operator&&(argument.isFunction()||argument.isClass()))return "function";const arg=evaluateCached(argument,state);if(!state.confident)return;switch(path.node.operator){case "!":return !arg;case "+":return +arg;case "-":return -arg;case "~":return ~arg;case "typeof":return typeof arg}}if(path.isArrayExpression()){const arr=[],elems=path.get("elements");for(const elem of elems){const elemValue=elem.evaluate();if(!elemValue.confident)return void deopt(elemValue.deopt,state);arr.push(elemValue.value);}return arr}if(path.isObjectExpression()){const obj={},props=path.get("properties");for(const prop of props){if(prop.isObjectMethod()||prop.isSpreadElement())return void deopt(prop,state);const keyPath=prop.get("key");let key;if(prop.node.computed){if(key=keyPath.evaluate(),!key.confident)return void deopt(key.deopt,state);key=key.value;}else key=keyPath.isIdentifier()?keyPath.node.name:keyPath.node.value;let value=prop.get("value").evaluate();if(!value.confident)return void deopt(value.deopt,state);value=value.value,obj[key]=value;}return obj}if(path.isLogicalExpression()){const wasConfident=state.confident,left=evaluateCached(path.get("left"),state),leftConfident=state.confident;state.confident=wasConfident;const right=evaluateCached(path.get("right"),state),rightConfident=state.confident;switch(path.node.operator){case "||":if(state.confident=leftConfident&&(!!left||rightConfident),!state.confident)return;return left||right;case "&&":if(state.confident=leftConfident&&(!left||rightConfident),!state.confident)return;return left&&right;case "??":if(state.confident=leftConfident&&(null!=left||rightConfident),!state.confident)return;return null!=left?left:right}}if(path.isBinaryExpression()){const left=evaluateCached(path.get("left"),state);if(!state.confident)return;const right=evaluateCached(path.get("right"),state);if(!state.confident)return;switch(path.node.operator){case "-":return left-right;case "+":return left+right;case "/":return left/right;case "*":return left*right;case "%":return left%right;case "**":return Math.pow(left,right);case "<":return left<right;case ">":return left>right;case "<=":return left<=right;case ">=":return left>=right;case "==":return left==right;case "!=":return left!=right;case "===":return left===right;case "!==":return left!==right;case "|":return left|right;case "&":return left&right;case "^":return left^right;case "<<":return left<<right;case ">>":return left>>right;case ">>>":return left>>>right}}if(path.isCallExpression()){const callee=path.get("callee");let context,func;if(callee.isIdentifier()&&!path.scope.getBinding(callee.node.name)&&(isValidObjectCallee(callee.node.name)||function(val){return VALID_IDENTIFIER_CALLEES.includes(val)}(callee.node.name))&&(func=commonjsGlobal[callee.node.name]),callee.isMemberExpression()){const object=callee.get("object"),property=callee.get("property");if(object.isIdentifier()&&property.isIdentifier()&&isValidObjectCallee(object.node.name)&&!function(val){return INVALID_METHODS.includes(val)}(property.node.name)){context=commonjsGlobal[object.node.name];const key=property.node.name;hasOwnProperty.call(context,key)&&(func=context[key]);}if(object.isLiteral()&&property.isIdentifier()){const type=typeof object.node.value;"string"!==type&&"number"!==type||(context=object.node.value,func=context[property.node.name]);}}if(func){const args=path.get("arguments").map((arg=>evaluateCached(arg,state)));if(!state.confident)return;return func.apply(context,args)}}deopt(path,state);}(path,state);return state.confident&&(item.resolved=true,item.value=val),val}}function evaluateQuasis(path,quasis,state,raw=false){let str="",i=0;const exprs=path.isTemplateLiteral()?path.get("expressions"):path.get("quasi.expressions");for(const elem of quasis){if(!state.confident)break;str+=raw?elem.value.raw:elem.value.cooked;const expr=exprs[i++];expr&&(str+=String(evaluateCached(expr,state)));}if(state.confident)return str}},"./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/family.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports._getKey=_getKey,exports._getPattern=_getPattern,exports.get=function(key,context=true){ true===context&&(context=this.context);const parts=key.split(".");return 1===parts.length?_getKey.call(this,key,context):_getPattern.call(this,parts,context)},exports.getAllNextSiblings=function(){let _key=this.key,sibling=this.getSibling(++_key);const siblings=[];for(;sibling.node;)siblings.push(sibling),sibling=this.getSibling(++_key);return siblings},exports.getAllPrevSiblings=function(){let _key=this.key,sibling=this.getSibling(--_key);const siblings=[];for(;sibling.node;)siblings.push(sibling),sibling=this.getSibling(--_key);return siblings},exports.getAssignmentIdentifiers=function(){return _getAssignmentIdentifiers(this.node)},exports.getBindingIdentifierPaths=function(duplicates=false,outerOnly=false){const search=[this],ids=Object.create(null);for(;search.length;){const id=search.shift();if(!id)continue;if(!id.node)continue;const keys=_getBindingIdentifiers.keys[id.node.type];if(id.isIdentifier())if(duplicates){(ids[id.node.name]=ids[id.node.name]||[]).push(id);}else ids[id.node.name]=id;else if(id.isExportDeclaration()){const declaration=id.get("declaration");declaration.isDeclaration()&&search.push(declaration);}else {if(outerOnly){if(id.isFunctionDeclaration()){search.push(id.get("id"));continue}if(id.isFunctionExpression())continue}if(keys)for(let i=0;i<keys.length;i++){const key=keys[i],child=id.get(key);Array.isArray(child)?search.push(...child):child.node&&search.push(child);}}}return ids},exports.getBindingIdentifiers=function(duplicates){return _getBindingIdentifiers(this.node,duplicates)},exports.getCompletionRecords=function(){return _getCompletionRecords(this,{canHaveBreak:false,shouldPopulateBreak:false,inCaseClause:false}).map((r=>r.path))},exports.getNextSibling=function(){return this.getSibling(this.key+1)},exports.getOpposite=function(){if("left"===this.key)return this.getSibling("right");if("right"===this.key)return this.getSibling("left");return null},exports.getOuterBindingIdentifierPaths=function(duplicates=false){return this.getBindingIdentifierPaths(duplicates,true)},exports.getOuterBindingIdentifiers=function(duplicates){return _getOuterBindingIdentifiers(this.node,duplicates)},exports.getPrevSibling=function(){return this.getSibling(this.key-1)},exports.getSibling=function(key){return _index.default.get({parentPath:this.parentPath,parent:this.parent,container:this.container,listKey:this.listKey,key}).setContext(this.context)};var _index=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/index.js"),_t=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js");const{getAssignmentIdentifiers:_getAssignmentIdentifiers,getBindingIdentifiers:_getBindingIdentifiers,getOuterBindingIdentifiers:_getOuterBindingIdentifiers,numericLiteral,unaryExpression}=_t,NORMAL_COMPLETION=0,BREAK_COMPLETION=1;function addCompletionRecords(path,records,context){return path&&records.push(..._getCompletionRecords(path,context)),records}function normalCompletionToBreak(completions){completions.forEach((c=>{c.type=BREAK_COMPLETION;}));}function replaceBreakStatementInBreakCompletion(completions,reachable){completions.forEach((c=>{c.path.isBreakStatement({label:null})&&(reachable?c.path.replaceWith(unaryExpression("void",numericLiteral(0))):c.path.remove());}));}function getStatementListCompletion(paths,context){const completions=[];if(context.canHaveBreak){let lastNormalCompletions=[];for(let i=0;i<paths.length;i++){const path=paths[i],newContext=Object.assign({},context,{inCaseClause:false});path.isBlockStatement()&&(context.inCaseClause||context.shouldPopulateBreak)?newContext.shouldPopulateBreak=true:newContext.shouldPopulateBreak=false;const statementCompletions=_getCompletionRecords(path,newContext);if(statementCompletions.length>0&&statementCompletions.every((c=>c.type===BREAK_COMPLETION))){lastNormalCompletions.length>0&&statementCompletions.every((c=>c.path.isBreakStatement({label:null})))?(normalCompletionToBreak(lastNormalCompletions),completions.push(...lastNormalCompletions),lastNormalCompletions.some((c=>c.path.isDeclaration()))&&(completions.push(...statementCompletions),replaceBreakStatementInBreakCompletion(statementCompletions,true)),replaceBreakStatementInBreakCompletion(statementCompletions,false)):(completions.push(...statementCompletions),context.shouldPopulateBreak||replaceBreakStatementInBreakCompletion(statementCompletions,true));break}if(i===paths.length-1)completions.push(...statementCompletions);else {lastNormalCompletions=[];for(let i=0;i<statementCompletions.length;i++){const c=statementCompletions[i];c.type===BREAK_COMPLETION&&completions.push(c),c.type===NORMAL_COMPLETION&&lastNormalCompletions.push(c);}}}}else if(paths.length)for(let i=paths.length-1;i>=0;i--){const pathCompletions=_getCompletionRecords(paths[i],context);if(pathCompletions.length>1||1===pathCompletions.length&&!pathCompletions[0].path.isVariableDeclaration()){completions.push(...pathCompletions);break}}return completions}function _getCompletionRecords(path,context){let records=[];if(path.isIfStatement())records=addCompletionRecords(path.get("consequent"),records,context),records=addCompletionRecords(path.get("alternate"),records,context);else {if(path.isDoExpression()||path.isFor()||path.isWhile()||path.isLabeledStatement())return addCompletionRecords(path.get("body"),records,context);if(path.isProgram()||path.isBlockStatement())return getStatementListCompletion(path.get("body"),context);if(path.isFunction())return _getCompletionRecords(path.get("body"),context);if(path.isTryStatement())records=addCompletionRecords(path.get("block"),records,context),records=addCompletionRecords(path.get("handler"),records,context);else {if(path.isCatchClause())return addCompletionRecords(path.get("body"),records,context);if(path.isSwitchStatement())return function(cases,records,context){let lastNormalCompletions=[];for(let i=0;i<cases.length;i++){const caseCompletions=_getCompletionRecords(cases[i],context),normalCompletions=[],breakCompletions=[];for(const c of caseCompletions)c.type===NORMAL_COMPLETION&&normalCompletions.push(c),c.type===BREAK_COMPLETION&&breakCompletions.push(c);normalCompletions.length&&(lastNormalCompletions=normalCompletions),records.push(...breakCompletions);}return records.push(...lastNormalCompletions),records}(path.get("cases"),records,context);if(path.isSwitchCase())return getStatementListCompletion(path.get("consequent"),{canHaveBreak:true,shouldPopulateBreak:false,inCaseClause:true});path.isBreakStatement()?records.push(function(path){return {type:BREAK_COMPLETION,path}}(path)):records.push(function(path){return {type:NORMAL_COMPLETION,path}}(path));}}return records}function _getKey(key,context){const node=this.node,container=node[key];return Array.isArray(container)?container.map(((_,i)=>_index.default.get({listKey:key,parentPath:this,parent:node,container,key:i}).setContext(context))):_index.default.get({parentPath:this,parent:node,container:node,key}).setContext(context)}function _getPattern(parts,context){let path=this;for(const part of parts)path="."===part?path.parentPath:Array.isArray(path)?path[part]:path.get(part,context);return path}},"./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=exports.SHOULD_STOP=exports.SHOULD_SKIP=exports.REMOVED=void 0;var virtualTypes=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/lib/virtual-types.js"),_debug=__webpack_require__("./node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/index.js"),_index=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/index.js"),_index2=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/scope/index.js"),_t=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js"),t=_t,cache=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/cache.js"),_generator=__webpack_require__("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/index.js"),NodePath_ancestry=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/ancestry.js"),NodePath_inference=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/inference/index.js"),NodePath_replacement=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/replacement.js"),NodePath_evaluation=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/evaluation.js"),NodePath_conversion=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/conversion.js"),NodePath_introspection=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/introspection.js"),_context=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/context.js"),NodePath_context=_context,NodePath_removal=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/removal.js"),NodePath_modification=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/modification.js"),NodePath_family=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/family.js"),NodePath_comments=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/comments.js"),NodePath_virtual_types_validator=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/lib/virtual-types-validator.js");const{validate}=_t,debug=_debug("babel"),NodePath_Final=(exports.REMOVED=1,exports.SHOULD_STOP=2,exports.SHOULD_SKIP=4,exports.default=class NodePath{constructor(hub,parent){this.contexts=[],this.state=null,this.opts=null,this._traverseFlags=0,this.skipKeys=null,this.parentPath=null,this.container=null,this.listKey=null,this.key=null,this.node=null,this.type=null,this.parent=parent,this.hub=hub,this.data=null,this.context=null,this.scope=null;}get removed(){return (1&this._traverseFlags)>0}set removed(v){v?this._traverseFlags|=1:this._traverseFlags&=-2;}get shouldStop(){return (2&this._traverseFlags)>0}set shouldStop(v){v?this._traverseFlags|=2:this._traverseFlags&=-3;}get shouldSkip(){return (4&this._traverseFlags)>0}set shouldSkip(v){v?this._traverseFlags|=4:this._traverseFlags&=-5;}static get({hub,parentPath,parent,container,listKey,key}){if(!hub&&parentPath&&(hub=parentPath.hub),!parent)throw new Error("To get a node path the parent needs to exist");const targetNode=container[key],paths=cache.getOrCreateCachedPaths(hub,parent);let path=paths.get(targetNode);return path||(path=new NodePath(hub,parent),targetNode&&paths.set(targetNode,path)),_context.setup.call(path,parentPath,container,listKey,key),path}getScope(scope){return this.isScope()?new _index2.default(this):scope}setData(key,val){return null==this.data&&(this.data=Object.create(null)),this.data[key]=val}getData(key,def){null==this.data&&(this.data=Object.create(null));let val=this.data[key];return void 0===val&&void 0!==def&&(val=this.data[key]=def),val}hasNode(){return null!=this.node}buildCodeFrameError(msg,Error=SyntaxError){return this.hub.buildError(this.node,msg,Error)}traverse(visitor,state){(0, _index.default)(this.node,visitor,this.scope,state,this);}set(key,node){validate(this.node,key,node),this.node[key]=node;}getPathLocation(){const parts=[];let path=this;do{let key=path.key;path.inList&&(key=`${path.listKey}[${key}]`),parts.unshift(key);}while(path=path.parentPath);return parts.join(".")}debug(message){debug.enabled&&debug(`${this.getPathLocation()} ${this.type}: ${message}`);}toString(){return (0, _generator.default)(this.node).code}get inList(){return !!this.listKey}set inList(inList){inList||(this.listKey=null);}get parentKey(){return this.listKey||this.key}}),methods={findParent:NodePath_ancestry.findParent,find:NodePath_ancestry.find,getFunctionParent:NodePath_ancestry.getFunctionParent,getStatementParent:NodePath_ancestry.getStatementParent,getEarliestCommonAncestorFrom:NodePath_ancestry.getEarliestCommonAncestorFrom,getDeepestCommonAncestorFrom:NodePath_ancestry.getDeepestCommonAncestorFrom,getAncestry:NodePath_ancestry.getAncestry,isAncestor:NodePath_ancestry.isAncestor,isDescendant:NodePath_ancestry.isDescendant,inType:NodePath_ancestry.inType,getTypeAnnotation:NodePath_inference.getTypeAnnotation,isBaseType:NodePath_inference.isBaseType,couldBeBaseType:NodePath_inference.couldBeBaseType,baseTypeStrictlyMatches:NodePath_inference.baseTypeStrictlyMatches,isGenericType:NodePath_inference.isGenericType,replaceWithMultiple:NodePath_replacement.replaceWithMultiple,replaceWithSourceString:NodePath_replacement.replaceWithSourceString,replaceWith:NodePath_replacement.replaceWith,replaceExpressionWithStatements:NodePath_replacement.replaceExpressionWithStatements,replaceInline:NodePath_replacement.replaceInline,evaluateTruthy:NodePath_evaluation.evaluateTruthy,evaluate:NodePath_evaluation.evaluate,toComputedKey:NodePath_conversion.toComputedKey,ensureBlock:NodePath_conversion.ensureBlock,unwrapFunctionEnvironment:NodePath_conversion.unwrapFunctionEnvironment,arrowFunctionToExpression:NodePath_conversion.arrowFunctionToExpression,splitExportDeclaration:NodePath_conversion.splitExportDeclaration,ensureFunctionName:NodePath_conversion.ensureFunctionName,matchesPattern:NodePath_introspection.matchesPattern,isStatic:NodePath_introspection.isStatic,isNodeType:NodePath_introspection.isNodeType,canHaveVariableDeclarationOrExpression:NodePath_introspection.canHaveVariableDeclarationOrExpression,canSwapBetweenExpressionAndStatement:NodePath_introspection.canSwapBetweenExpressionAndStatement,isCompletionRecord:NodePath_introspection.isCompletionRecord,isStatementOrBlock:NodePath_introspection.isStatementOrBlock,referencesImport:NodePath_introspection.referencesImport,getSource:NodePath_introspection.getSource,willIMaybeExecuteBefore:NodePath_introspection.willIMaybeExecuteBefore,_guessExecutionStatusRelativeTo:NodePath_introspection._guessExecutionStatusRelativeTo,resolve:NodePath_introspection.resolve,isConstantExpression:NodePath_introspection.isConstantExpression,isInStrictMode:NodePath_introspection.isInStrictMode,isDenylisted:NodePath_context.isDenylisted,visit:NodePath_context.visit,skip:NodePath_context.skip,skipKey:NodePath_context.skipKey,stop:NodePath_context.stop,setContext:NodePath_context.setContext,requeue:NodePath_context.requeue,requeueComputedKeyAndDecorators:NodePath_context.requeueComputedKeyAndDecorators,remove:NodePath_removal.remove,insertBefore:NodePath_modification.insertBefore,insertAfter:NodePath_modification.insertAfter,unshiftContainer:NodePath_modification.unshiftContainer,pushContainer:NodePath_modification.pushContainer,getOpposite:NodePath_family.getOpposite,getCompletionRecords:NodePath_family.getCompletionRecords,getSibling:NodePath_family.getSibling,getPrevSibling:NodePath_family.getPrevSibling,getNextSibling:NodePath_family.getNextSibling,getAllNextSiblings:NodePath_family.getAllNextSiblings,getAllPrevSiblings:NodePath_family.getAllPrevSiblings,get:NodePath_family.get,getAssignmentIdentifiers:NodePath_family.getAssignmentIdentifiers,getBindingIdentifiers:NodePath_family.getBindingIdentifiers,getOuterBindingIdentifiers:NodePath_family.getOuterBindingIdentifiers,getBindingIdentifierPaths:NodePath_family.getBindingIdentifierPaths,getOuterBindingIdentifierPaths:NodePath_family.getOuterBindingIdentifierPaths,shareCommentsWithSiblings:NodePath_comments.shareCommentsWithSiblings,addComment:NodePath_comments.addComment,addComments:NodePath_comments.addComments};Object.assign(NodePath_Final.prototype,methods),NodePath_Final.prototype.arrowFunctionToShadowed=NodePath_conversion[String("arrowFunctionToShadowed")],Object.assign(NodePath_Final.prototype,{has:NodePath_introspection[String("has")],is:NodePath_introspection[String("is")],isnt:NodePath_introspection[String("isnt")],equals:NodePath_introspection[String("equals")],hoist:NodePath_modification[String("hoist")],updateSiblingKeys:NodePath_modification.updateSiblingKeys,call:NodePath_context.call,isBlacklisted:NodePath_context[String("isBlacklisted")],setScope:NodePath_context.setScope,resync:NodePath_context.resync,popContext:NodePath_context.popContext,pushContext:NodePath_context.pushContext,setup:NodePath_context.setup,setKey:NodePath_context.setKey}),NodePath_Final.prototype._guessExecutionStatusRelativeToDifferentFunctions=NodePath_introspection._guessExecutionStatusRelativeTo,NodePath_Final.prototype._guessExecutionStatusRelativeToDifferentFunctions=NodePath_introspection._guessExecutionStatusRelativeTo,Object.assign(NodePath_Final.prototype,{_getTypeAnnotation:NodePath_inference._getTypeAnnotation,_replaceWith:NodePath_replacement._replaceWith,_resolve:NodePath_introspection._resolve,_call:NodePath_context._call,_resyncParent:NodePath_context._resyncParent,_resyncKey:NodePath_context._resyncKey,_resyncList:NodePath_context._resyncList,_resyncRemoved:NodePath_context._resyncRemoved,_getQueueContexts:NodePath_context._getQueueContexts,_removeFromScope:NodePath_removal._removeFromScope,_callRemovalHooks:NodePath_removal._callRemovalHooks,_remove:NodePath_removal._remove,_markRemoved:NodePath_removal._markRemoved,_assertUnremoved:NodePath_removal._assertUnremoved,_containerInsert:NodePath_modification._containerInsert,_containerInsertBefore:NodePath_modification._containerInsertBefore,_containerInsertAfter:NodePath_modification._containerInsertAfter,_verifyNodeList:NodePath_modification._verifyNodeList,_getKey:NodePath_family._getKey,_getPattern:NodePath_family._getPattern});for(const type of t.TYPES){const typeKey=`is${type}`,fn=t[typeKey];NodePath_Final.prototype[typeKey]=function(opts){return fn(this.node,opts)},NodePath_Final.prototype[`assert${type}`]=function(opts){if(!fn(this.node,opts))throw new TypeError(`Expected node path of type ${type}`)};}Object.assign(NodePath_Final.prototype,NodePath_virtual_types_validator);for(const type of Object.keys(virtualTypes))"_"!==type[0]&&(t.TYPES.includes(type)||t.TYPES.push(type));},"./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/inference/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports._getTypeAnnotation=_getTypeAnnotation,exports.baseTypeStrictlyMatches=function(rightArg){const left=this.getTypeAnnotation(),right=rightArg.getTypeAnnotation();if(!isAnyTypeAnnotation(left)&&isFlowBaseAnnotation(left))return right.type===left.type;return  false},exports.couldBeBaseType=function(name){const type=this.getTypeAnnotation();if(isAnyTypeAnnotation(type))return  true;if(isUnionTypeAnnotation(type)){for(const type2 of type.types)if(isAnyTypeAnnotation(type2)||_isBaseType(name,type2,true))return  true;return  false}return _isBaseType(name,type,true)},exports.getTypeAnnotation=function(){let type=this.getData("typeAnnotation");if(null!=type)return type;type=_getTypeAnnotation.call(this)||anyTypeAnnotation(),(isTypeAnnotation(type)||isTSTypeAnnotation(type))&&(type=type.typeAnnotation);return this.setData("typeAnnotation",type),type},exports.isBaseType=function(baseName,soft){return _isBaseType(baseName,this.getTypeAnnotation(),soft)},exports.isGenericType=function(genericName){const type=this.getTypeAnnotation();if("Array"===genericName&&(isTSArrayType(type)||isArrayTypeAnnotation(type)||isTupleTypeAnnotation(type)))return  true;return isGenericTypeAnnotation(type)&&isIdentifier(type.id,{name:genericName})||isTSTypeReference(type)&&isIdentifier(type.typeName,{name:genericName})};var inferers=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/inference/inferers.js"),_t=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js");const{anyTypeAnnotation,isAnyTypeAnnotation,isArrayTypeAnnotation,isBooleanTypeAnnotation,isEmptyTypeAnnotation,isFlowBaseAnnotation,isGenericTypeAnnotation,isIdentifier,isMixedTypeAnnotation,isNumberTypeAnnotation,isStringTypeAnnotation,isTSArrayType,isTSTypeAnnotation,isTSTypeReference,isTupleTypeAnnotation,isTypeAnnotation,isUnionTypeAnnotation,isVoidTypeAnnotation,stringTypeAnnotation,voidTypeAnnotation}=_t;const typeAnnotationInferringNodes=new WeakSet;function _getTypeAnnotation(){const node=this.node;if(node){if(node.typeAnnotation)return node.typeAnnotation;if(!typeAnnotationInferringNodes.has(node)){typeAnnotationInferringNodes.add(node);try{var _inferer;let inferer=inferers[node.type];if(inferer)return inferer.call(this,node);if(inferer=inferers[this.parentPath.type],null!=(_inferer=inferer)&&_inferer.validParent)return this.parentPath.getTypeAnnotation()}finally{typeAnnotationInferringNodes.delete(node);}}}else if("init"===this.key&&this.parentPath.isVariableDeclarator()){const declar=this.parentPath.parentPath,declarParent=declar.parentPath;return "left"===declar.key&&declarParent.isForInStatement()?stringTypeAnnotation():"left"===declar.key&&declarParent.isForOfStatement()?anyTypeAnnotation():voidTypeAnnotation()}}function _isBaseType(baseName,type,soft){if("string"===baseName)return isStringTypeAnnotation(type);if("number"===baseName)return isNumberTypeAnnotation(type);if("boolean"===baseName)return isBooleanTypeAnnotation(type);if("any"===baseName)return isAnyTypeAnnotation(type);if("mixed"===baseName)return isMixedTypeAnnotation(type);if("empty"===baseName)return isEmptyTypeAnnotation(type);if("void"===baseName)return isVoidTypeAnnotation(type);if(soft)return  false;throw new Error(`Unknown base type ${baseName}`)}},"./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/inference/inferer-reference.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(node){if(!this.isReferenced())return;const binding=this.scope.getBinding(node.name);if(binding)return binding.identifier.typeAnnotation?binding.identifier.typeAnnotation:function(binding,path,name){const types=[],functionConstantViolations=[];let constantViolations=getConstantViolationsBefore(binding,path,functionConstantViolations);const testType=getConditionalAnnotation(binding,path,name);if(testType){const testConstantViolations=getConstantViolationsBefore(binding,testType.ifStatement);constantViolations=constantViolations.filter((path=>!testConstantViolations.includes(path))),types.push(testType.typeAnnotation);}if(constantViolations.length){constantViolations.push(...functionConstantViolations);for(const violation of constantViolations)types.push(violation.getTypeAnnotation());}if(!types.length)return;return (0, _util.createUnionType)(types)}(binding,this,node.name);if("undefined"===node.name)return voidTypeAnnotation();if("NaN"===node.name||"Infinity"===node.name)return numberTypeAnnotation();node.name;};var _t=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js"),_util=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/inference/util.js");const{BOOLEAN_NUMBER_BINARY_OPERATORS,createTypeAnnotationBasedOnTypeof,numberTypeAnnotation,voidTypeAnnotation}=_t;function getConstantViolationsBefore(binding,path,functions){const violations=binding.constantViolations.slice();return violations.unshift(binding.path),violations.filter((violation=>{const status=(violation=violation.resolve())._guessExecutionStatusRelativeTo(path);return functions&&"unknown"===status&&functions.push(violation),"before"===status}))}function inferAnnotationFromBinaryExpression(name,path){const operator=path.node.operator,right=path.get("right").resolve(),left=path.get("left").resolve();let target,typeofPath,typePath;if(left.isIdentifier({name})?target=right:right.isIdentifier({name})&&(target=left),target)return "==="===operator?target.getTypeAnnotation():BOOLEAN_NUMBER_BINARY_OPERATORS.includes(operator)?numberTypeAnnotation():void 0;if("==="!==operator&&"=="!==operator)return;if(left.isUnaryExpression({operator:"typeof"})?(typeofPath=left,typePath=right):right.isUnaryExpression({operator:"typeof"})&&(typeofPath=right,typePath=left),!typeofPath)return;if(!typeofPath.get("argument").isIdentifier({name}))return;if(typePath=typePath.resolve(),!typePath.isLiteral())return;const typeValue=typePath.node.value;return "string"==typeof typeValue?createTypeAnnotationBasedOnTypeof(typeValue):void 0}function getConditionalAnnotation(binding,path,name){const ifStatement=function(binding,path,name){let parentPath;for(;parentPath=path.parentPath;){if(parentPath.isIfStatement()||parentPath.isConditionalExpression()){if("test"===path.key)return;return parentPath}if(parentPath.isFunction()&&parentPath.parentPath.scope.getBinding(name)!==binding)return;path=parentPath;}}(binding,path,name);if(!ifStatement)return;const paths=[ifStatement.get("test")],types=[];for(let i=0;i<paths.length;i++){const path=paths[i];if(path.isLogicalExpression())"&&"===path.node.operator&&(paths.push(path.get("left")),paths.push(path.get("right")));else if(path.isBinaryExpression()){const type=inferAnnotationFromBinaryExpression(name,path);type&&types.push(type);}}return types.length?{typeAnnotation:(0, _util.createUnionType)(types),ifStatement}:getConditionalAnnotation(binding,ifStatement,name)}},"./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/inference/inferers.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.ArrayExpression=ArrayExpression,exports.AssignmentExpression=function(){return this.get("right").getTypeAnnotation()},exports.BinaryExpression=function(node){const operator=node.operator;if(NUMBER_BINARY_OPERATORS.includes(operator))return numberTypeAnnotation();if(BOOLEAN_BINARY_OPERATORS.includes(operator))return booleanTypeAnnotation();if("+"===operator){const right=this.get("right"),left=this.get("left");return left.isBaseType("number")&&right.isBaseType("number")?numberTypeAnnotation():left.isBaseType("string")||right.isBaseType("string")?stringTypeAnnotation():unionTypeAnnotation([stringTypeAnnotation(),numberTypeAnnotation()])}},exports.BooleanLiteral=function(){return booleanTypeAnnotation()},exports.CallExpression=function(){const{callee}=this.node;if(isObjectKeys(callee))return arrayTypeAnnotation(stringTypeAnnotation());if(isArrayFrom(callee)||isObjectValues(callee)||isIdentifier(callee,{name:"Array"}))return arrayTypeAnnotation(anyTypeAnnotation());if(isObjectEntries(callee))return arrayTypeAnnotation(tupleTypeAnnotation([stringTypeAnnotation(),anyTypeAnnotation()]));return resolveCall(this.get("callee"))},exports.ConditionalExpression=function(){const argumentTypes=[this.get("consequent").getTypeAnnotation(),this.get("alternate").getTypeAnnotation()];return (0, _util.createUnionType)(argumentTypes)},exports.ClassDeclaration=exports.ClassExpression=exports.FunctionDeclaration=exports.ArrowFunctionExpression=exports.FunctionExpression=function(){return genericTypeAnnotation(identifier("Function"))},Object.defineProperty(exports,"Identifier",{enumerable:true,get:function(){return _infererReference.default}}),exports.LogicalExpression=function(){const argumentTypes=[this.get("left").getTypeAnnotation(),this.get("right").getTypeAnnotation()];return (0, _util.createUnionType)(argumentTypes)},exports.NewExpression=function(node){if("Identifier"===node.callee.type)return genericTypeAnnotation(node.callee)},exports.NullLiteral=function(){return nullLiteralTypeAnnotation()},exports.NumericLiteral=function(){return numberTypeAnnotation()},exports.ObjectExpression=function(){return genericTypeAnnotation(identifier("Object"))},exports.ParenthesizedExpression=function(){return this.get("expression").getTypeAnnotation()},exports.RegExpLiteral=function(){return genericTypeAnnotation(identifier("RegExp"))},exports.RestElement=RestElement,exports.SequenceExpression=function(){return this.get("expressions").pop().getTypeAnnotation()},exports.StringLiteral=function(){return stringTypeAnnotation()},exports.TSAsExpression=TSAsExpression,exports.TSNonNullExpression=function(){return this.get("expression").getTypeAnnotation()},exports.TaggedTemplateExpression=function(){return resolveCall(this.get("tag"))},exports.TemplateLiteral=function(){return stringTypeAnnotation()},exports.TypeCastExpression=TypeCastExpression,exports.UnaryExpression=function(node){const operator=node.operator;if("void"===operator)return voidTypeAnnotation();if(NUMBER_UNARY_OPERATORS.includes(operator))return numberTypeAnnotation();if(STRING_UNARY_OPERATORS.includes(operator))return stringTypeAnnotation();if(BOOLEAN_UNARY_OPERATORS.includes(operator))return booleanTypeAnnotation()},exports.UpdateExpression=function(node){const operator=node.operator;if("++"===operator||"--"===operator)return numberTypeAnnotation()},exports.VariableDeclarator=function(){if(!this.get("id").isIdentifier())return;return this.get("init").getTypeAnnotation()};var _t=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js"),_infererReference=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/inference/inferer-reference.js"),_util=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/inference/util.js");const{BOOLEAN_BINARY_OPERATORS,BOOLEAN_UNARY_OPERATORS,NUMBER_BINARY_OPERATORS,NUMBER_UNARY_OPERATORS,STRING_UNARY_OPERATORS,anyTypeAnnotation,arrayTypeAnnotation,booleanTypeAnnotation,buildMatchMemberExpression,genericTypeAnnotation,identifier,nullLiteralTypeAnnotation,numberTypeAnnotation,stringTypeAnnotation,tupleTypeAnnotation,unionTypeAnnotation,voidTypeAnnotation,isIdentifier}=_t;function TypeCastExpression(node){return node.typeAnnotation}function TSAsExpression(node){return node.typeAnnotation}function ArrayExpression(){return genericTypeAnnotation(identifier("Array"))}function RestElement(){return ArrayExpression()}TypeCastExpression.validParent=true,TSAsExpression.validParent=true,RestElement.validParent=true;const isArrayFrom=buildMatchMemberExpression("Array.from"),isObjectKeys=buildMatchMemberExpression("Object.keys"),isObjectValues=buildMatchMemberExpression("Object.values"),isObjectEntries=buildMatchMemberExpression("Object.entries");function resolveCall(callee){if((callee=callee.resolve()).isFunction()){const{node}=callee;if(node.async)return node.generator?genericTypeAnnotation(identifier("AsyncIterator")):genericTypeAnnotation(identifier("Promise"));if(node.generator)return genericTypeAnnotation(identifier("Iterator"));if(callee.node.returnType)return callee.node.returnType}}},"./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/inference/util.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.createUnionType=function(types){if(types.every((v=>isFlowType(v))))return createFlowUnionType?createFlowUnionType(types):createUnionTypeAnnotation(types);if(types.every((v=>isTSType(v)))&&createTSUnionType)return createTSUnionType(types)};var _t=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js");const{createFlowUnionType,createTSUnionType,createUnionTypeAnnotation,isFlowType,isTSType}=_t;},"./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/introspection.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports._guessExecutionStatusRelativeTo=function(target){return _guessExecutionStatusRelativeToCached(this,target,new Map)},exports._resolve=_resolve,exports.canHaveVariableDeclarationOrExpression=function(){return ("init"===this.key||"left"===this.key)&&this.parentPath.isFor()},exports.canSwapBetweenExpressionAndStatement=function(replacement){if("body"!==this.key||!this.parentPath.isArrowFunctionExpression())return  false;if(this.isExpression())return isBlockStatement(replacement);if(this.isBlockStatement())return isExpression(replacement);return  false},exports.getSource=function(){const node=this.node;if(node.end){const code=this.hub.getCode();if(code)return code.slice(node.start,node.end)}return ""},exports.isCompletionRecord=function(allowInsideFunction){let path=this,first=true;do{const{type,container}=path;if(!first&&(path.isFunction()||"StaticBlock"===type))return !!allowInsideFunction;if(first=false,Array.isArray(container)&&path.key!==container.length-1)return  false}while((path=path.parentPath)&&!path.isProgram()&&!path.isDoExpression());return  true},exports.isConstantExpression=function(){if(this.isIdentifier()){const binding=this.scope.getBinding(this.node.name);return !!binding&&binding.constant}if(this.isLiteral())return !this.isRegExpLiteral()&&(!this.isTemplateLiteral()||this.get("expressions").every((expression=>expression.isConstantExpression())));if(this.isUnaryExpression())return "void"===this.node.operator&&this.get("argument").isConstantExpression();if(this.isBinaryExpression()){const{operator}=this.node;return "in"!==operator&&"instanceof"!==operator&&this.get("left").isConstantExpression()&&this.get("right").isConstantExpression()}if(this.isMemberExpression())return !this.node.computed&&this.get("object").isIdentifier({name:"Symbol"})&&!this.scope.hasBinding("Symbol",{noGlobals:true});if(this.isCallExpression())return 1===this.node.arguments.length&&this.get("callee").matchesPattern("Symbol.for")&&!this.scope.hasBinding("Symbol",{noGlobals:true})&&this.get("arguments")[0].isStringLiteral();return  false},exports.isInStrictMode=function(){const start=this.isProgram()?this:this.parentPath;return !!start.find((path=>{if(path.isProgram({sourceType:"module"}))return  true;if(path.isClass())return  true;if(path.isArrowFunctionExpression()&&!path.get("body").isBlockStatement())return  false;let body;if(path.isFunction())body=path.node.body;else {if(!path.isProgram())return  false;body=path.node;}for(const directive of body.directives)if("use strict"===directive.value.value)return  true}))},exports.isNodeType=function(type){return isType(this.type,type)},exports.isStatementOrBlock=function(){return !this.parentPath.isLabeledStatement()&&!isBlockStatement(this.container)&&STATEMENT_OR_BLOCK_KEYS.includes(this.key)},exports.isStatic=function(){return this.scope.isStatic(this.node)},exports.matchesPattern=function(pattern,allowPartial){return _matchesPattern(this.node,pattern,allowPartial)},exports.referencesImport=function(moduleSource,importName){if(!this.isReferencedIdentifier()){if(this.isJSXMemberExpression()&&this.node.property.name===importName||(this.isMemberExpression()||this.isOptionalMemberExpression())&&(this.node.computed?isStringLiteral(this.node.property,{value:importName}):this.node.property.name===importName)){const object=this.get("object");return object.isReferencedIdentifier()&&object.referencesImport(moduleSource,"*")}return  false}const binding=this.scope.getBinding(this.node.name);if(!binding||"module"!==binding.kind)return  false;const path=binding.path,parent=path.parentPath;if(!parent.isImportDeclaration())return  false;if(parent.node.source.value!==moduleSource)return  false;if(!importName)return  true;if(path.isImportDefaultSpecifier()&&"default"===importName)return  true;if(path.isImportNamespaceSpecifier()&&"*"===importName)return  true;if(path.isImportSpecifier()&&isIdentifier(path.node.imported,{name:importName}))return  true;return  false},exports.resolve=function(dangerous,resolved){return _resolve.call(this,dangerous,resolved)||this},exports.willIMaybeExecuteBefore=function(target){return "after"!==this._guessExecutionStatusRelativeTo(target)};var _t=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js");const{STATEMENT_OR_BLOCK_KEYS,VISITOR_KEYS,isBlockStatement,isExpression,isIdentifier,isLiteral,isStringLiteral,isType,matchesPattern:_matchesPattern}=_t;function getOuterFunction(path){return path.isProgram()?path:(path.parentPath.scope.getFunctionParent()||path.parentPath.scope.getProgramParent()).path}function isExecutionUncertain(type,key){switch(type){case "LogicalExpression":case "AssignmentPattern":return "right"===key;case "ConditionalExpression":case "IfStatement":return "consequent"===key||"alternate"===key;case "WhileStatement":case "DoWhileStatement":case "ForInStatement":case "ForOfStatement":return "body"===key;case "ForStatement":return "body"===key||"update"===key;case "SwitchStatement":return "cases"===key;case "TryStatement":return "handler"===key;case "OptionalMemberExpression":return "property"===key;case "OptionalCallExpression":return "arguments"===key;default:return  false}}function isExecutionUncertainInList(paths,maxIndex){for(let i=0;i<maxIndex;i++){const path=paths[i];if(isExecutionUncertain(path.parent.type,path.parentKey))return  true}return  false}exports.has=function(key){var _this$node;const val=null==(_this$node=this.node)?void 0:_this$node[key];return val&&Array.isArray(val)?!!val.length:!!val},exports.is=exports.has,exports.isnt=function(key){return !this.has(key)},exports.equals=function(key,value){return this.node[key]===value};const SYMBOL_CHECKING=Symbol();function _guessExecutionStatusRelativeToCached(base,target,cache){const funcParent={this:getOuterFunction(base),target:getOuterFunction(target)};if(funcParent.target.node!==funcParent.this.node)return function(base,target,cache){let cached,nodeMap=cache.get(base.node);if(nodeMap){if(cached=nodeMap.get(target.node))return cached===SYMBOL_CHECKING?"unknown":cached}else cache.set(base.node,nodeMap=new Map);nodeMap.set(target.node,SYMBOL_CHECKING);const result=function(base,target,cache){if(!target.isFunctionDeclaration())return "before"===_guessExecutionStatusRelativeToCached(base,target,cache)?"before":"unknown";if(target.parentPath.isExportDeclaration())return "unknown";const binding=target.scope.getBinding(target.node.id.name);if(!binding.references)return "before";const referencePaths=binding.referencePaths;let allStatus;for(const path of referencePaths){if(!!path.find((path=>path.node===target.node)))continue;if("callee"!==path.key||!path.parentPath.isCallExpression())return "unknown";const status=_guessExecutionStatusRelativeToCached(base,path,cache);if(allStatus&&allStatus!==status)return "unknown";allStatus=status;}return allStatus}(base,target,cache);return nodeMap.set(target.node,result),result}(base,funcParent.target,cache);const paths={target:target.getAncestry(),this:base.getAncestry()};if(paths.target.includes(base))return "after";if(paths.this.includes(target))return "before";let commonPath;const commonIndex={target:0,this:0};for(;!commonPath&&commonIndex.this<paths.this.length;){const path=paths.this[commonIndex.this];commonIndex.target=paths.target.indexOf(path),commonIndex.target>=0?commonPath=path:commonIndex.this++;}if(!commonPath)throw new Error("Internal Babel error - The two compared nodes don't appear to belong to the same program.");if(isExecutionUncertainInList(paths.this,commonIndex.this-1)||isExecutionUncertainInList(paths.target,commonIndex.target-1))return "unknown";const divergence={this:paths.this[commonIndex.this-1],target:paths.target[commonIndex.target-1]};if(divergence.target.listKey&&divergence.this.listKey&&divergence.target.container===divergence.this.container)return divergence.target.key>divergence.this.key?"before":"after";const keys=VISITOR_KEYS[commonPath.type],keyPosition_this=keys.indexOf(divergence.this.parentKey);return keys.indexOf(divergence.target.parentKey)>keyPosition_this?"before":"after"}function _resolve(dangerous,resolved){var _resolved;if(null==(_resolved=resolved)||!_resolved.includes(this))if((resolved=resolved||[]).push(this),this.isVariableDeclarator()){if(this.get("id").isIdentifier())return this.get("init").resolve(dangerous,resolved)}else if(this.isReferencedIdentifier()){const binding=this.scope.getBinding(this.node.name);if(!binding)return;if(!binding.constant)return;if("module"===binding.kind)return;if(binding.path!==this){const ret=binding.path.resolve(dangerous,resolved);if(this.find((parent=>parent.node===ret.node)))return;return ret}}else {if(this.isTypeCastExpression())return this.get("expression").resolve(dangerous,resolved);if(dangerous&&this.isMemberExpression()){const targetKey=this.toComputedKey();if(!isLiteral(targetKey))return;const targetName=targetKey.value,target=this.get("object").resolve(dangerous,resolved);if(target.isObjectExpression()){const props=target.get("properties");for(const prop of props){if(!prop.isProperty())continue;const key=prop.get("key");let match=prop.isnt("computed")&&key.isIdentifier({name:targetName});if(match=match||key.isLiteral({value:targetName}),match)return prop.get("value").resolve(dangerous,resolved)}}else if(target.isArrayExpression()&&!isNaN(+targetName)){const elem=target.get("elements")[targetName];if(elem)return elem.resolve(dangerous,resolved)}}}}},"./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/lib/hoister.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=void 0;var _t=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js"),_t2=_t;const{react}=_t,{cloneNode,jsxExpressionContainer,variableDeclaration,variableDeclarator}=_t2,referenceVisitor={ReferencedIdentifier(path,state){if(path.isJSXIdentifier()&&react.isCompatTag(path.node.name)&&!path.parentPath.isJSXMemberExpression())return;if("this"===path.node.name){let scope=path.scope;do{if(scope.path.isFunction()&&!scope.path.isArrowFunctionExpression())break}while(scope=scope.parent);scope&&state.breakOnScopePaths.push(scope.path);}const binding=path.scope.getBinding(path.node.name);if(binding){for(const violation of binding.constantViolations)if(violation.scope!==binding.path.scope)return state.mutableBinding=true,void path.stop();binding===state.scope.getBinding(path.node.name)&&(state.bindings[path.node.name]=binding);}}};exports.default=class{constructor(path,scope){this.breakOnScopePaths=void 0,this.bindings=void 0,this.mutableBinding=void 0,this.scopes=void 0,this.scope=void 0,this.path=void 0,this.attachAfter=void 0,this.breakOnScopePaths=[],this.bindings={},this.mutableBinding=false,this.scopes=[],this.scope=scope,this.path=path,this.attachAfter=false;}isCompatibleScope(scope){for(const key of Object.keys(this.bindings)){const binding=this.bindings[key];if(!scope.bindingIdentifierEquals(key,binding.identifier))return  false}return  true}getCompatibleScopes(){let scope=this.path.scope;do{if(!this.isCompatibleScope(scope))break;if(this.scopes.push(scope),this.breakOnScopePaths.includes(scope.path))break}while(scope=scope.parent)}getAttachmentPath(){let path=this._getAttachmentPath();if(!path)return;let targetScope=path.scope;if(targetScope.path===path&&(targetScope=path.scope.parent),targetScope.path.isProgram()||targetScope.path.isFunction())for(const name of Object.keys(this.bindings)){if(!targetScope.hasOwnBinding(name))continue;const binding=this.bindings[name];if("param"===binding.kind||"params"===binding.path.parentKey)continue;if(this.getAttachmentParentForPath(binding.path).key>=path.key){this.attachAfter=true,path=binding.path;for(const violationPath of binding.constantViolations)this.getAttachmentParentForPath(violationPath).key>path.key&&(path=violationPath);}}return path}_getAttachmentPath(){const scope=this.scopes.pop();if(scope)if(scope.path.isFunction()){if(!this.hasOwnParamBindings(scope))return this.getNextScopeAttachmentParent();{if(this.scope===scope)return;const bodies=scope.path.get("body").get("body");for(let i=0;i<bodies.length;i++)if(!bodies[i].node._blockHoist)return bodies[i]}}else if(scope.path.isProgram())return this.getNextScopeAttachmentParent()}getNextScopeAttachmentParent(){const scope=this.scopes.pop();if(scope)return this.getAttachmentParentForPath(scope.path)}getAttachmentParentForPath(path){do{if(!path.parentPath||Array.isArray(path.container)&&path.isStatement())return path}while(path=path.parentPath)}hasOwnParamBindings(scope){for(const name of Object.keys(this.bindings)){if(!scope.hasOwnBinding(name))continue;const binding=this.bindings[name];if("param"===binding.kind&&binding.constant)return  true}return  false}run(){if(this.path.traverse(referenceVisitor,this),this.mutableBinding)return;this.getCompatibleScopes();const attachTo=this.getAttachmentPath();if(!attachTo)return;if(attachTo.getFunctionParent()===this.path.getFunctionParent())return;let uid=attachTo.scope.generateUidIdentifier("ref");const declarator=variableDeclarator(uid,this.path.node),insertFn=this.attachAfter?"insertAfter":"insertBefore",[attached]=attachTo[insertFn]([attachTo.isVariableDeclarator()?declarator:variableDeclaration("var",[declarator])]),parent=this.path.parentPath;return parent.isJSXElement()&&this.path.container===parent.node.children&&(uid=jsxExpressionContainer(uid)),this.path.replaceWith(cloneNode(uid)),attachTo.isVariableDeclarator()?attached.get("init"):attached.get("declarations.0.init")}};},"./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/lib/removal-hooks.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.hooks=void 0;exports.hooks=[function(self,parent){if("test"===self.key&&(parent.isWhile()||parent.isSwitchCase())||"declaration"===self.key&&parent.isExportDeclaration()||"body"===self.key&&parent.isLabeledStatement()||"declarations"===self.listKey&&parent.isVariableDeclaration()&&1===parent.node.declarations.length||"expression"===self.key&&parent.isExpressionStatement())return parent.remove(),true},function(self,parent){if(parent.isSequenceExpression()&&1===parent.node.expressions.length)return parent.replaceWith(parent.node.expressions[0]),true},function(self,parent){if(parent.isBinary())return "left"===self.key?parent.replaceWith(parent.node.right):parent.replaceWith(parent.node.left),true},function(self,parent){if(parent.isIfStatement()&&"consequent"===self.key||"body"===self.key&&(parent.isLoop()||parent.isArrowFunctionExpression()))return self.replaceWith({type:"BlockStatement",body:[]}),true}];},"./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/lib/virtual-types-validator.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.isBindingIdentifier=function(){const{node,parent}=this,grandparent=this.parentPath.parent;return isIdentifier(node)&&isBinding(node,parent,grandparent)},exports.isBlockScoped=function(){return nodeIsBlockScoped(this.node)},exports.isExpression=function(){return this.isIdentifier()?this.isReferencedIdentifier():nodeIsExpression(this.node)},exports.isFlow=function(){const{node}=this;return !!nodeIsFlow(node)||(isImportDeclaration(node)?"type"===node.importKind||"typeof"===node.importKind:isExportDeclaration(node)?"type"===node.exportKind:!!isImportSpecifier(node)&&("type"===node.importKind||"typeof"===node.importKind))},exports.isForAwaitStatement=function(){return isForOfStatement(this.node,{await:true})},exports.isGenerated=function(){return !this.isUser()},exports.isPure=function(constantsOnly){return this.scope.isPure(this.node,constantsOnly)},exports.isReferenced=function(){return nodeIsReferenced(this.node,this.parent)},exports.isReferencedIdentifier=function(opts){const{node,parent}=this;if(!isIdentifier(node,opts)&&!isJSXMemberExpression(parent,opts)){if(!isJSXIdentifier(node,opts))return  false;if(isCompatTag(node.name))return  false}return nodeIsReferenced(node,parent,this.parentPath.parent)},exports.isReferencedMemberExpression=function(){const{node,parent}=this;return isMemberExpression(node)&&nodeIsReferenced(node,parent)},exports.isRestProperty=function(){var _this$parentPath;return nodeIsRestElement(this.node)&&(null==(_this$parentPath=this.parentPath)?void 0:_this$parentPath.isObjectPattern())},exports.isScope=function(){return nodeIsScope(this.node,this.parent)},exports.isSpreadProperty=function(){var _this$parentPath2;return nodeIsRestElement(this.node)&&(null==(_this$parentPath2=this.parentPath)?void 0:_this$parentPath2.isObjectExpression())},exports.isStatement=function(){const{node,parent}=this;if(nodeIsStatement(node)){if(isVariableDeclaration(node)){if(isForXStatement(parent,{left:node}))return  false;if(isForStatement(parent,{init:node}))return  false}return  true}return  false},exports.isUser=function(){return this.node&&!!this.node.loc},exports.isVar=function(){return nodeIsVar(this.node)};var _t=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js");const{isBinding,isBlockScoped:nodeIsBlockScoped,isExportDeclaration,isExpression:nodeIsExpression,isFlow:nodeIsFlow,isForStatement,isForXStatement,isIdentifier,isImportDeclaration,isImportSpecifier,isJSXIdentifier,isJSXMemberExpression,isMemberExpression,isRestElement:nodeIsRestElement,isReferenced:nodeIsReferenced,isScope:nodeIsScope,isStatement:nodeIsStatement,isVar:nodeIsVar,isVariableDeclaration,react,isForOfStatement}=_t,{isCompatTag}=react;exports.isExistentialTypeParam=function(){throw new Error("`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.")},exports.isNumericLiteralTypeAnnotation=function(){throw new Error("`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.")};},"./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/lib/virtual-types.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.Var=exports.User=exports.Statement=exports.SpreadProperty=exports.Scope=exports.RestProperty=exports.ReferencedMemberExpression=exports.ReferencedIdentifier=exports.Referenced=exports.Pure=exports.NumericLiteralTypeAnnotation=exports.Generated=exports.ForAwaitStatement=exports.Flow=exports.Expression=exports.ExistentialTypeParam=exports.BlockScoped=exports.BindingIdentifier=void 0;exports.ReferencedIdentifier=["Identifier","JSXIdentifier"],exports.ReferencedMemberExpression=["MemberExpression"],exports.BindingIdentifier=["Identifier"],exports.Statement=["Statement"],exports.Expression=["Expression"],exports.Scope=["Scopable","Pattern"],exports.Referenced=null,exports.BlockScoped=null,exports.Var=["VariableDeclaration"],exports.User=null,exports.Generated=null,exports.Pure=null,exports.Flow=["Flow","ImportDeclaration","ExportDeclaration","ImportSpecifier"],exports.RestProperty=["RestElement"],exports.SpreadProperty=["RestElement"],exports.ExistentialTypeParam=["ExistsTypeAnnotation"],exports.NumericLiteralTypeAnnotation=["NumberLiteralTypeAnnotation"],exports.ForAwaitStatement=["ForOfStatement"];},"./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/modification.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports._containerInsert=_containerInsert,exports._containerInsertAfter=_containerInsertAfter,exports._containerInsertBefore=_containerInsertBefore,exports._verifyNodeList=_verifyNodeList,exports.insertAfter=function(nodes_){if(_removal._assertUnremoved.call(this),this.isSequenceExpression())return last(this.get("expressions")).insertAfter(nodes_);const nodes=_verifyNodeList.call(this,nodes_),{parentPath,parent}=this;if(parentPath.isExpressionStatement()||parentPath.isLabeledStatement()||isExportNamedDeclaration(parent)||parentPath.isExportDefaultDeclaration()&&this.isDeclaration())return parentPath.insertAfter(nodes.map((node=>isExpression(node)?expressionStatement(node):node)));if(this.isNodeType("Expression")&&!this.isJSXElement()&&!parentPath.isJSXElement()||parentPath.isForStatement()&&"init"===this.key){const self=this;if(self.node){const node=self.node;let{scope}=this;if(scope.path.isPattern())return assertExpression(node),self.replaceWith(callExpression(arrowFunctionExpression([],node),[])),self.get("callee.body").insertAfter(nodes),[self];if(isHiddenInSequenceExpression(self))nodes.unshift(node);else if(isCallExpression(node)&&isSuper(node.callee))nodes.unshift(node),nodes.push(thisExpression());else if(function(node,scope){if(!isAssignmentExpression(node)||!isIdentifier(node.left))return  false;const blockScope=scope.getBlockParent();return blockScope.hasOwnBinding(node.left.name)&&blockScope.getOwnBinding(node.left.name).constantViolations.length<=1}(node,scope))nodes.unshift(node),nodes.push(cloneNode(node.left));else if(scope.isPure(node,true))nodes.push(node);else {parentPath.isMethod({computed:true,key:node})&&(scope=scope.parent);const temp=scope.generateDeclaredUidIdentifier();nodes.unshift(expressionStatement(assignmentExpression("=",cloneNode(temp),node))),nodes.push(expressionStatement(cloneNode(temp)));}}return this.replaceExpressionWithStatements(nodes)}if(Array.isArray(this.container))return _containerInsertAfter.call(this,nodes);if(this.isStatementOrBlock()){const node=this.node,shouldInsertCurrentNode=node&&(!this.isExpressionStatement()||null!=node.expression);return this.replaceWith(blockStatement(shouldInsertCurrentNode?[node]:[])),this.pushContainer("body",nodes)}throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?")},exports.insertBefore=function(nodes_){_removal._assertUnremoved.call(this);const nodes=_verifyNodeList.call(this,nodes_),{parentPath,parent}=this;if(parentPath.isExpressionStatement()||parentPath.isLabeledStatement()||isExportNamedDeclaration(parent)||parentPath.isExportDefaultDeclaration()&&this.isDeclaration())return parentPath.insertBefore(nodes);if(this.isNodeType("Expression")&&!this.isJSXElement()||parentPath.isForStatement()&&"init"===this.key)return this.node&&nodes.push(this.node),this.replaceExpressionWithStatements(nodes);if(Array.isArray(this.container))return _containerInsertBefore.call(this,nodes);if(this.isStatementOrBlock()){const node=this.node,shouldInsertCurrentNode=node&&(!this.isExpressionStatement()||null!=node.expression);return this.replaceWith(blockStatement(shouldInsertCurrentNode?[node]:[])),this.unshiftContainer("body",nodes)}throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?")},exports.pushContainer=function(listKey,nodes){_removal._assertUnremoved.call(this);const verifiedNodes=_verifyNodeList.call(this,nodes),container=this.node[listKey];return _index.default.get({parentPath:this,parent:this.node,container,listKey,key:container.length}).setContext(this.context).replaceWithMultiple(verifiedNodes)},exports.unshiftContainer=function(listKey,nodes){_removal._assertUnremoved.call(this),nodes=_verifyNodeList.call(this,nodes);const path=_index.default.get({parentPath:this,parent:this.node,container:this.node[listKey],listKey,key:0}).setContext(this.context);return _containerInsertBefore.call(path,nodes)},exports.updateSiblingKeys=updateSiblingKeys;var _cache=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/cache.js"),_hoister=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/lib/hoister.js"),_index=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/index.js"),_context=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/context.js"),_removal=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/removal.js"),_t=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js");const{arrowFunctionExpression,assertExpression,assignmentExpression,blockStatement,callExpression,cloneNode,expressionStatement,isAssignmentExpression,isCallExpression,isExportNamedDeclaration,isExpression,isIdentifier,isSequenceExpression,isSuper,thisExpression}=_t;function _containerInsert(from,nodes){updateSiblingKeys.call(this,from,nodes.length);const paths=[];this.container.splice(from,0,...nodes);for(let i=0;i<nodes.length;i++){var _this$context;const to=from+i,path=this.getSibling(to);paths.push(path),null!=(_this$context=this.context)&&_this$context.queue&&_context.pushContext.call(path,this.context);}const contexts=_context._getQueueContexts.call(this);for(const path of paths){_context.setScope.call(path),path.debug("Inserted.");for(const context of contexts)context.maybeQueue(path,true);}return paths}function _containerInsertBefore(nodes){return _containerInsert.call(this,this.key,nodes)}function _containerInsertAfter(nodes){return _containerInsert.call(this,this.key+1,nodes)}const last=arr=>arr[arr.length-1];function isHiddenInSequenceExpression(path){return isSequenceExpression(path.parent)&&(last(path.parent.expressions)!==path.node||isHiddenInSequenceExpression(path.parentPath))}function updateSiblingKeys(fromIndex,incrementBy){if(!this.parent)return;const paths=(0, _cache.getCachedPaths)(this.hub,this.parent)||[];for(const[,path]of paths)"number"==typeof path.key&&path.container===this.container&&path.key>=fromIndex&&(path.key+=incrementBy);}function _verifyNodeList(nodes){if(!nodes)return [];Array.isArray(nodes)||(nodes=[nodes]);for(let i=0;i<nodes.length;i++){const node=nodes[i];let msg;if(node?"object"!=typeof node?msg="contains a non-object node":node.type?node instanceof _index.default&&(msg="has a NodePath when it expected a raw object"):msg="without a type":msg="has falsy node",msg){const type=Array.isArray(node)?"array":typeof node;throw new Error(`Node list ${msg} with the index of ${i} and type of ${type}`)}}return nodes}exports.hoist=function(scope=this.scope){return new _hoister.default(this,scope).run()};},"./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/removal.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports._assertUnremoved=_assertUnremoved,exports._callRemovalHooks=_callRemovalHooks,exports._markRemoved=_markRemoved,exports._remove=_remove,exports._removeFromScope=_removeFromScope,exports.remove=function(){var _this$opts;if(_assertUnremoved.call(this),_context.resync.call(this),_callRemovalHooks.call(this))return void _markRemoved.call(this);null!=(_this$opts=this.opts)&&_this$opts.noScope||_removeFromScope.call(this);this.shareCommentsWithSiblings(),_remove.call(this),_markRemoved.call(this);};var _removalHooks=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/lib/removal-hooks.js"),_cache=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/cache.js"),_replacement=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/replacement.js"),_index=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/index.js"),_t=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js"),_modification=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/modification.js"),_context=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/context.js");const{getBindingIdentifiers}=_t;function _removeFromScope(){const bindings=getBindingIdentifiers(this.node,false,false,true);Object.keys(bindings).forEach((name=>this.scope.removeBinding(name)));}function _callRemovalHooks(){if(this.parentPath)for(const fn of _removalHooks.hooks)if(fn(this,this.parentPath))return  true}function _remove(){Array.isArray(this.container)?(this.container.splice(this.key,1),_modification.updateSiblingKeys.call(this,this.key,-1)):_replacement._replaceWith.call(this,null);}function _markRemoved(){this._traverseFlags|=_index.SHOULD_SKIP|_index.REMOVED,this.parent&&(0, _cache.getCachedPaths)(this.hub,this.parent).delete(this.node),this.node=null;}function _assertUnremoved(){if(this.removed)throw this.buildCodeFrameError("NodePath has been removed so is read-only.")}},"./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/replacement.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports._replaceWith=_replaceWith,exports.replaceExpressionWithStatements=function(nodes){_context.resync.call(this);const declars=[],nodesAsSingleExpression=gatherSequenceExpressions(nodes,declars);if(nodesAsSingleExpression){for(const id of declars)this.scope.push({id});return this.replaceWith(nodesAsSingleExpression)[0].get("expressions")}const functionParent=this.getFunctionParent(),isParentAsync=null==functionParent?void 0:functionParent.node.async,isParentGenerator=null==functionParent?void 0:functionParent.node.generator,container=arrowFunctionExpression([],blockStatement(nodes));this.replaceWith(callExpression(container,[]));const callee=this.get("callee");callee.get("body").scope.hoistVariables((id=>this.scope.push({id})));const completionRecords=callee.getCompletionRecords();for(const path of completionRecords){if(!path.isExpressionStatement())continue;const loop=path.findParent((path=>path.isLoop()));if(loop){let uid=loop.getData("expressionReplacementReturnUid");uid?uid=identifier(uid.name):(uid=callee.scope.generateDeclaredUidIdentifier("ret"),callee.get("body").pushContainer("body",returnStatement(cloneNode(uid))),loop.setData("expressionReplacementReturnUid",uid)),path.get("expression").replaceWith(assignmentExpression("=",cloneNode(uid),path.node.expression));}else path.replaceWith(returnStatement(path.node.expression));}callee.arrowFunctionToExpression();const newCallee=callee,needToAwaitFunction=isParentAsync&&_index.default.hasType(this.get("callee.body").node,"AwaitExpression",FUNCTION_TYPES),needToYieldFunction=isParentGenerator&&_index.default.hasType(this.get("callee.body").node,"YieldExpression",FUNCTION_TYPES);needToAwaitFunction&&(newCallee.set("async",true),needToYieldFunction||this.replaceWith(awaitExpression(this.node)));needToYieldFunction&&(newCallee.set("generator",true),this.replaceWith(yieldExpression(this.node,true)));return newCallee.get("body.body")},exports.replaceInline=function(nodes){if(_context.resync.call(this),Array.isArray(nodes)){if(Array.isArray(this.container)){nodes=_modification._verifyNodeList.call(this,nodes);const paths=_modification._containerInsertAfter.call(this,nodes);return this.remove(),paths}return this.replaceWithMultiple(nodes)}return this.replaceWith(nodes)},exports.replaceWith=function(replacementPath){if(_context.resync.call(this),this.removed)throw new Error("You can't replace this node, we've already removed it");let replacement=replacementPath instanceof _index2.default?replacementPath.node:replacementPath;if(!replacement)throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");if(this.node===replacement)return [this];if(this.isProgram()&&!isProgram(replacement))throw new Error("You can only replace a Program root node with another Program node");if(Array.isArray(replacement))throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");if("string"==typeof replacement)throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");let nodePath="";this.isNodeType("Statement")&&isExpression(replacement)&&(this.canHaveVariableDeclarationOrExpression()||this.canSwapBetweenExpressionAndStatement(replacement)||this.parentPath.isExportDefaultDeclaration()||(replacement=expressionStatement(replacement),nodePath="expression"));if(this.isNodeType("Expression")&&isStatement(replacement)&&!this.canHaveVariableDeclarationOrExpression()&&!this.canSwapBetweenExpressionAndStatement(replacement))return this.replaceExpressionWithStatements([replacement]);const oldNode=this.node;oldNode&&(inheritsComments(replacement,oldNode),removeComments(oldNode));return _replaceWith.call(this,replacement),this.type=replacement.type,_context.setScope.call(this),this.requeue(),[nodePath?this.get(nodePath):this]},exports.replaceWithMultiple=function(nodes){var _getCachedPaths;_context.resync.call(this),nodes=_modification._verifyNodeList.call(this,nodes),inheritLeadingComments(nodes[0],this.node),inheritTrailingComments(nodes[nodes.length-1],this.node),null==(_getCachedPaths=(0, _cache.getCachedPaths)(this.hub,this.parent))||_getCachedPaths.delete(this.node),this.node=this.container[this.key]=null;const paths=this.insertAfter(nodes);this.node?this.requeue():this.remove();return paths},exports.replaceWithSourceString=function(replacement){let ast;_context.resync.call(this);try{replacement=`(${replacement})`,ast=(0,_parser.parse)(replacement);}catch(err){const loc=err.loc;throw loc&&(err.message+=" - make sure this is an expression.\n"+(0, _codeFrame.codeFrameColumns)(replacement,{start:{line:loc.line,column:loc.column+1}}),err.code="BABEL_REPLACE_SOURCE_ERROR"),err}const expressionAST=ast.program.body[0].expression;return _index.default.removeProperties(expressionAST),this.replaceWith(expressionAST)};var _codeFrame=__webpack_require__("./stubs/babel-codeframe.mjs"),_index=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/index.js"),_index2=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/index.js"),_cache=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/cache.js"),_modification=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/modification.js"),_parser=__webpack_require__("./node_modules/.pnpm/@babel+parser@7.26.3/node_modules/@babel/parser/lib/index.js"),_t=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js"),_context=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/context.js");const{FUNCTION_TYPES,arrowFunctionExpression,assignmentExpression,awaitExpression,blockStatement,buildUndefinedNode,callExpression,cloneNode,conditionalExpression,expressionStatement,getBindingIdentifiers,identifier,inheritLeadingComments,inheritTrailingComments,inheritsComments,isBlockStatement,isEmptyStatement,isExpression,isExpressionStatement,isIfStatement,isProgram,isStatement,isVariableDeclaration,removeComments,returnStatement,sequenceExpression,validate,yieldExpression}=_t;function _replaceWith(node){var _getCachedPaths2;if(!this.container)throw new ReferenceError("Container is falsy");this.inList?validate(this.parent,this.key,[node]):validate(this.parent,this.key,node),this.debug(`Replace with ${null==node?void 0:node.type}`),null==(_getCachedPaths2=(0, _cache.getCachedPaths)(this.hub,this.parent))||_getCachedPaths2.set(node,this).delete(this.node),this.node=this.container[this.key]=node;}function gatherSequenceExpressions(nodes,declars){const exprs=[];let ensureLastUndefined=true;for(const node of nodes)if(isEmptyStatement(node)||(ensureLastUndefined=false),isExpression(node))exprs.push(node);else if(isExpressionStatement(node))exprs.push(node.expression);else if(isVariableDeclaration(node)){if("var"!==node.kind)return;for(const declar of node.declarations){const bindings=getBindingIdentifiers(declar);for(const key of Object.keys(bindings))declars.push(cloneNode(bindings[key]));declar.init&&exprs.push(assignmentExpression("=",declar.id,declar.init));}ensureLastUndefined=true;}else if(isIfStatement(node)){const consequent=node.consequent?gatherSequenceExpressions([node.consequent],declars):buildUndefinedNode(),alternate=node.alternate?gatherSequenceExpressions([node.alternate],declars):buildUndefinedNode();if(!consequent||!alternate)return;exprs.push(conditionalExpression(node.test,consequent,alternate));}else if(isBlockStatement(node)){const body=gatherSequenceExpressions(node.body,declars);if(!body)return;exprs.push(body);}else {if(!isEmptyStatement(node))return;0===nodes.indexOf(node)&&(ensureLastUndefined=true);}return ensureLastUndefined&&exprs.push(buildUndefinedNode()),1===exprs.length?exprs[0]:sequenceExpression(exprs)}},"./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/scope/binding.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=void 0;exports.default=class{constructor({identifier,scope,path,kind}){this.identifier=void 0,this.scope=void 0,this.path=void 0,this.kind=void 0,this.constantViolations=[],this.constant=true,this.referencePaths=[],this.referenced=false,this.references=0,this.identifier=identifier,this.scope=scope,this.path=path,this.kind=kind,"var"!==kind&&"hoisted"!==kind||!function(path){for(let{parentPath,key}=path;parentPath;({parentPath,key}=parentPath)){if(parentPath.isFunctionParent())return  false;if(parentPath.isWhile()||parentPath.isForXStatement()||parentPath.isForStatement()&&"body"===key)return  true}return  false}(path)||this.reassign(path),this.clearValue();}deoptValue(){this.clearValue(),this.hasDeoptedValue=true;}setValue(value){this.hasDeoptedValue||(this.hasValue=true,this.value=value);}clearValue(){this.hasDeoptedValue=false,this.hasValue=false,this.value=null;}reassign(path){this.constant=false,this.constantViolations.includes(path)||this.constantViolations.push(path);}reference(path){this.referencePaths.includes(path)||(this.referenced=true,this.references++,this.referencePaths.push(path));}dereference(){this.references--,this.referenced=!!this.references;}};},"./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/scope/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=void 0;var _renamer=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/scope/lib/renamer.js"),_index=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/index.js"),_binding=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/scope/binding.js"),_globals=__webpack_require__("./node_modules/.pnpm/globals@11.12.0/node_modules/globals/index.js"),_t=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js"),t=_t,_cache=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/cache.js"),_visitors=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/visitors.js");const{NOT_LOCAL_BINDING,assignmentExpression,callExpression,cloneNode,getBindingIdentifiers,identifier,isArrayExpression,isBinary,isCallExpression,isClass,isClassBody,isClassDeclaration,isExportAllDeclaration,isExportDefaultDeclaration,isExportNamedDeclaration,isFunctionDeclaration,isIdentifier,isImportDeclaration,isLiteral,isMemberExpression,isMethod,isModuleSpecifier,isNullLiteral,isObjectExpression,isProperty,isPureish,isRegExpLiteral,isSuper,isTaggedTemplateExpression,isTemplateLiteral,isThisExpression,isUnaryExpression,isVariableDeclaration,expressionStatement,matchesPattern,memberExpression,numericLiteral,toIdentifier,variableDeclaration,variableDeclarator,isRecordExpression,isTupleExpression,isObjectProperty,isTopicReference,isMetaProperty,isPrivateName,isExportDeclaration,buildUndefinedNode,sequenceExpression}=_t;function gatherNodeParts(node,parts){switch(null==node?void 0:node.type){default:var _node$specifiers;if(isImportDeclaration(node)||isExportDeclaration(node))if((isExportAllDeclaration(node)||isExportNamedDeclaration(node)||isImportDeclaration(node))&&node.source)gatherNodeParts(node.source,parts);else if((isExportNamedDeclaration(node)||isImportDeclaration(node))&&null!=(_node$specifiers=node.specifiers)&&_node$specifiers.length)for(const e of node.specifiers)gatherNodeParts(e,parts);else (isExportDefaultDeclaration(node)||isExportNamedDeclaration(node))&&node.declaration&&gatherNodeParts(node.declaration,parts);else isModuleSpecifier(node)?gatherNodeParts(node.local,parts):!isLiteral(node)||isNullLiteral(node)||isRegExpLiteral(node)||isTemplateLiteral(node)||parts.push(node.value);break;case "MemberExpression":case "OptionalMemberExpression":case "JSXMemberExpression":gatherNodeParts(node.object,parts),gatherNodeParts(node.property,parts);break;case "Identifier":case "JSXIdentifier":parts.push(node.name);break;case "CallExpression":case "OptionalCallExpression":case "NewExpression":gatherNodeParts(node.callee,parts);break;case "ObjectExpression":case "ObjectPattern":for(const e of node.properties)gatherNodeParts(e,parts);break;case "SpreadElement":case "RestElement":case "UnaryExpression":case "UpdateExpression":gatherNodeParts(node.argument,parts);break;case "ObjectProperty":case "ObjectMethod":case "ClassProperty":case "ClassMethod":case "ClassPrivateProperty":case "ClassPrivateMethod":gatherNodeParts(node.key,parts);break;case "ThisExpression":parts.push("this");break;case "Super":parts.push("super");break;case "Import":parts.push("import");break;case "DoExpression":parts.push("do");break;case "YieldExpression":parts.push("yield"),gatherNodeParts(node.argument,parts);break;case "AwaitExpression":parts.push("await"),gatherNodeParts(node.argument,parts);break;case "AssignmentExpression":gatherNodeParts(node.left,parts);break;case "VariableDeclarator":case "FunctionExpression":case "FunctionDeclaration":case "ClassExpression":case "ClassDeclaration":case "PrivateName":gatherNodeParts(node.id,parts);break;case "ParenthesizedExpression":gatherNodeParts(node.expression,parts);break;case "MetaProperty":gatherNodeParts(node.meta,parts),gatherNodeParts(node.property,parts);break;case "JSXElement":gatherNodeParts(node.openingElement,parts);break;case "JSXOpeningElement":gatherNodeParts(node.name,parts);break;case "JSXFragment":gatherNodeParts(node.openingFragment,parts);break;case "JSXOpeningFragment":parts.push("Fragment");break;case "JSXNamespacedName":gatherNodeParts(node.namespace,parts),gatherNodeParts(node.name,parts);}}const collectorVisitor={ForStatement(path){const declar=path.get("init");if(declar.isVar()){const{scope}=path;(scope.getFunctionParent()||scope.getProgramParent()).registerBinding("var",declar);}},Declaration(path){if(path.isBlockScoped())return;if(path.isImportDeclaration())return;if(path.isExportDeclaration())return;(path.scope.getFunctionParent()||path.scope.getProgramParent()).registerDeclaration(path);},ImportDeclaration(path){path.scope.getBlockParent().registerDeclaration(path);},ReferencedIdentifier(path,state){state.references.push(path);},ForXStatement(path,state){const left=path.get("left");if(left.isPattern()||left.isIdentifier())state.constantViolations.push(path);else if(left.isVar()){const{scope}=path;(scope.getFunctionParent()||scope.getProgramParent()).registerBinding("var",left);}},ExportDeclaration:{exit(path){const{node,scope}=path;if(isExportAllDeclaration(node))return;const declar=node.declaration;if(isClassDeclaration(declar)||isFunctionDeclaration(declar)){const id=declar.id;if(!id)return;const binding=scope.getBinding(id.name);null==binding||binding.reference(path);}else if(isVariableDeclaration(declar))for(const decl of declar.declarations)for(const name of Object.keys(getBindingIdentifiers(decl))){const binding=scope.getBinding(name);null==binding||binding.reference(path);}}},LabeledStatement(path){path.scope.getBlockParent().registerDeclaration(path);},AssignmentExpression(path,state){state.assignments.push(path);},UpdateExpression(path,state){state.constantViolations.push(path);},UnaryExpression(path,state){"delete"===path.node.operator&&state.constantViolations.push(path);},BlockScoped(path){let scope=path.scope;scope.path===path&&(scope=scope.parent);if(scope.getBlockParent().registerDeclaration(path),path.isClassDeclaration()&&path.node.id){const name=path.node.id.name;path.scope.bindings[name]=path.scope.parent.getBinding(name);}},CatchClause(path){path.scope.registerBinding("let",path);},Function(path){const params=path.get("params");for(const param of params)path.scope.registerBinding("param",param);path.isFunctionExpression()&&path.node.id&&!path.node.id[NOT_LOCAL_BINDING]&&path.scope.registerBinding("local",path.get("id"),path);},ClassExpression(path){path.node.id&&!path.node.id[NOT_LOCAL_BINDING]&&path.scope.registerBinding("local",path.get("id"),path);},TSTypeAnnotation(path){path.skip();}};let uid=0;class Scope{constructor(path){this.uid=void 0,this.path=void 0,this.block=void 0,this.inited=void 0,this.labels=void 0,this.bindings=void 0,this.references=void 0,this.globals=void 0,this.uids=void 0,this.data=void 0,this.crawling=void 0;const{node}=path,cached=_cache.scope.get(node);if((null==cached?void 0:cached.path)===path)return cached;_cache.scope.set(node,this),this.uid=uid++,this.block=node,this.path=path,this.labels=new Map,this.inited=false;}get parent(){var _parent;let parent,path=this.path;do{var _path;const shouldSkip="key"===path.key||"decorators"===path.listKey;path=path.parentPath,shouldSkip&&path.isMethod()&&(path=path.parentPath),null!=(_path=path)&&_path.isScope()&&(parent=path);}while(path&&!parent);return null==(_parent=parent)?void 0:_parent.scope}generateDeclaredUidIdentifier(name){const id=this.generateUidIdentifier(name);return this.push({id}),cloneNode(id)}generateUidIdentifier(name){return identifier(this.generateUid(name))}generateUid(name="temp"){let uid;name=toIdentifier(name).replace(/^_+/,"").replace(/\d+$/g,"");let i=1;do{uid=`_${name}`,i>1&&(uid+=i),i++;}while(this.hasLabel(uid)||this.hasBinding(uid)||this.hasGlobal(uid)||this.hasReference(uid));const program=this.getProgramParent();return program.references[uid]=true,program.uids[uid]=true,uid}generateUidBasedOnNode(node,defaultName){const parts=[];gatherNodeParts(node,parts);let id=parts.join("$");return id=id.replace(/^_/,"")||defaultName||"ref",this.generateUid(id.slice(0,20))}generateUidIdentifierBasedOnNode(node,defaultName){return identifier(this.generateUidBasedOnNode(node,defaultName))}isStatic(node){if(isThisExpression(node)||isSuper(node)||isTopicReference(node))return  true;if(isIdentifier(node)){const binding=this.getBinding(node.name);return binding?binding.constant:this.hasBinding(node.name)}return  false}maybeGenerateMemoised(node,dontPush){if(this.isStatic(node))return null;{const id=this.generateUidIdentifierBasedOnNode(node);return dontPush?id:(this.push({id}),cloneNode(id))}}checkBlockScopedCollisions(local,kind,name,id){if("param"===kind)return;if("local"===local.kind)return;if("let"===kind||"let"===local.kind||"const"===local.kind||"module"===local.kind||"param"===local.kind&&"const"===kind)throw this.path.hub.buildError(id,`Duplicate declaration "${name}"`,TypeError)}rename(oldName,newName){const binding=this.getBinding(oldName);if(binding){newName||(newName=this.generateUidIdentifier(oldName).name);new _renamer.default(binding,oldName,newName).rename(arguments[2]);}}dump(){const sep="-".repeat(60);console.log(sep);let scope=this;do{console.log("#",scope.block.type);for(const name of Object.keys(scope.bindings)){const binding=scope.bindings[name];console.log(" -",name,{constant:binding.constant,references:binding.references,violations:binding.constantViolations.length,kind:binding.kind});}}while(scope=scope.parent);console.log(sep);}hasLabel(name){return !!this.getLabel(name)}getLabel(name){return this.labels.get(name)}registerLabel(path){this.labels.set(path.node.label.name,path);}registerDeclaration(path){if(path.isLabeledStatement())this.registerLabel(path);else if(path.isFunctionDeclaration())this.registerBinding("hoisted",path.get("id"),path);else if(path.isVariableDeclaration()){const declarations=path.get("declarations"),{kind}=path.node;for(const declar of declarations)this.registerBinding("using"===kind||"await using"===kind?"const":kind,declar);}else if(path.isClassDeclaration()){if(path.node.declare)return;this.registerBinding("let",path);}else if(path.isImportDeclaration()){const isTypeDeclaration="type"===path.node.importKind||"typeof"===path.node.importKind,specifiers=path.get("specifiers");for(const specifier of specifiers){const isTypeSpecifier=isTypeDeclaration||specifier.isImportSpecifier()&&("type"===specifier.node.importKind||"typeof"===specifier.node.importKind);this.registerBinding(isTypeSpecifier?"unknown":"module",specifier);}}else if(path.isExportDeclaration()){const declar=path.get("declaration");(declar.isClassDeclaration()||declar.isFunctionDeclaration()||declar.isVariableDeclaration())&&this.registerDeclaration(declar);}else this.registerBinding("unknown",path);}buildUndefinedNode(){return buildUndefinedNode()}registerConstantViolation(path){const ids=path.getAssignmentIdentifiers();for(const name of Object.keys(ids)){var _this$getBinding;null==(_this$getBinding=this.getBinding(name))||_this$getBinding.reassign(path);}}registerBinding(kind,path,bindingPath=path){if(!kind)throw new ReferenceError("no `kind`");if(path.isVariableDeclaration()){const declarators=path.get("declarations");for(const declar of declarators)this.registerBinding(kind,declar);return}const parent=this.getProgramParent(),ids=path.getOuterBindingIdentifiers(true);for(const name of Object.keys(ids)){parent.references[name]=true;for(const id of ids[name]){const local=this.getOwnBinding(name);if(local){if(local.identifier===id)continue;this.checkBlockScopedCollisions(local,kind,name,id);}local?local.reassign(bindingPath):this.bindings[name]=new _binding.default({identifier:id,scope:this,path:bindingPath,kind});}}}addGlobal(node){this.globals[node.name]=node;}hasUid(name){let scope=this;do{if(scope.uids[name])return  true}while(scope=scope.parent);return  false}hasGlobal(name){let scope=this;do{if(scope.globals[name])return  true}while(scope=scope.parent);return  false}hasReference(name){return !!this.getProgramParent().references[name]}isPure(node,constantsOnly){if(isIdentifier(node)){const binding=this.getBinding(node.name);return !!binding&&(!constantsOnly||binding.constant)}if(isThisExpression(node)||isMetaProperty(node)||isTopicReference(node)||isPrivateName(node))return  true;var _node$decorators,_node$decorators2,_node$decorators3;if(isClass(node))return !(node.superClass&&!this.isPure(node.superClass,constantsOnly))&&(!((null==(_node$decorators=node.decorators)?void 0:_node$decorators.length)>0)&&this.isPure(node.body,constantsOnly));if(isClassBody(node)){for(const method of node.body)if(!this.isPure(method,constantsOnly))return  false;return  true}if(isBinary(node))return this.isPure(node.left,constantsOnly)&&this.isPure(node.right,constantsOnly);if(isArrayExpression(node)||isTupleExpression(node)){for(const elem of node.elements)if(null!==elem&&!this.isPure(elem,constantsOnly))return  false;return  true}if(isObjectExpression(node)||isRecordExpression(node)){for(const prop of node.properties)if(!this.isPure(prop,constantsOnly))return  false;return  true}if(isMethod(node))return !(node.computed&&!this.isPure(node.key,constantsOnly))&&!((null==(_node$decorators2=node.decorators)?void 0:_node$decorators2.length)>0);if(isProperty(node))return !(node.computed&&!this.isPure(node.key,constantsOnly))&&(!((null==(_node$decorators3=node.decorators)?void 0:_node$decorators3.length)>0)&&!((isObjectProperty(node)||node.static)&&null!==node.value&&!this.isPure(node.value,constantsOnly)));if(isUnaryExpression(node))return this.isPure(node.argument,constantsOnly);if(isTemplateLiteral(node)){for(const expression of node.expressions)if(!this.isPure(expression,constantsOnly))return  false;return  true}return isTaggedTemplateExpression(node)?matchesPattern(node.tag,"String.raw")&&!this.hasBinding("String",{noGlobals:true})&&this.isPure(node.quasi,constantsOnly):isMemberExpression(node)?!node.computed&&isIdentifier(node.object)&&"Symbol"===node.object.name&&isIdentifier(node.property)&&"for"!==node.property.name&&!this.hasBinding("Symbol",{noGlobals:true}):isCallExpression(node)?matchesPattern(node.callee,"Symbol.for")&&!this.hasBinding("Symbol",{noGlobals:true})&&1===node.arguments.length&&t.isStringLiteral(node.arguments[0]):isPureish(node)}setData(key,val){return this.data[key]=val}getData(key){let scope=this;do{const data=scope.data[key];if(null!=data)return data}while(scope=scope.parent)}removeData(key){let scope=this;do{null!=scope.data[key]&&(scope.data[key]=null);}while(scope=scope.parent)}init(){this.inited||(this.inited=true,this.crawl());}crawl(){const path=this.path;this.references=Object.create(null),this.bindings=Object.create(null),this.globals=Object.create(null),this.uids=Object.create(null),this.data=Object.create(null);let scope=this;do{if(scope.crawling)return;if(scope.path.isProgram())break}while(scope=scope.parent);const programParent=scope,state={references:[],constantViolations:[],assignments:[]};if(this.crawling=true,"Program"!==path.type&&(0, _visitors.isExplodedVisitor)(collectorVisitor)){for(const visit of collectorVisitor.enter)visit.call(state,path,state);const typeVisitors=collectorVisitor[path.type];if(typeVisitors)for(const visit of typeVisitors.enter)visit.call(state,path,state);}path.traverse(collectorVisitor,state),this.crawling=false;for(const path of state.assignments){const ids=path.getAssignmentIdentifiers();for(const name of Object.keys(ids))path.scope.getBinding(name)||programParent.addGlobal(ids[name]);path.scope.registerConstantViolation(path);}for(const ref of state.references){const binding=ref.scope.getBinding(ref.node.name);binding?binding.reference(ref):programParent.addGlobal(ref.node);}for(const path of state.constantViolations)path.scope.registerConstantViolation(path);}push(opts){let path=this.path;path.isPattern()?path=this.getPatternParent().path:path.isBlockStatement()||path.isProgram()||(path=this.getBlockParent().path),path.isSwitchStatement()&&(path=(this.getFunctionParent()||this.getProgramParent()).path);const{init,unique,kind="var",id}=opts;if(!init&&!unique&&("var"===kind||"let"===kind)&&path.isFunction()&&!path.node.name&&isCallExpression(path.parent,{callee:path.node})&&path.parent.arguments.length<=path.node.params.length&&isIdentifier(id))return path.pushContainer("params",id),void path.scope.registerBinding("param",path.get("params")[path.node.params.length-1]);(path.isLoop()||path.isCatchClause()||path.isFunction())&&(path.ensureBlock(),path=path.get("body"));const blockHoist=null==opts._blockHoist?2:opts._blockHoist,dataKey=`declaration:${kind}:${blockHoist}`;let declarPath=!unique&&path.getData(dataKey);if(!declarPath){const declar=variableDeclaration(kind,[]);declar._blockHoist=blockHoist,[declarPath]=path.unshiftContainer("body",[declar]),unique||path.setData(dataKey,declarPath);}const declarator=variableDeclarator(id,init),len=declarPath.node.declarations.push(declarator);path.scope.registerBinding(kind,declarPath.get("declarations")[len-1]);}getProgramParent(){let scope=this;do{if(scope.path.isProgram())return scope}while(scope=scope.parent);throw new Error("Couldn't find a Program")}getFunctionParent(){let scope=this;do{if(scope.path.isFunctionParent())return scope}while(scope=scope.parent);return null}getBlockParent(){let scope=this;do{if(scope.path.isBlockParent())return scope}while(scope=scope.parent);throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...")}getPatternParent(){let scope=this;do{if(!scope.path.isPattern())return scope.getBlockParent()}while(scope=scope.parent.parent);throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...")}getAllBindings(){const ids=Object.create(null);let scope=this;do{for(const key of Object.keys(scope.bindings))key in ids==false&&(ids[key]=scope.bindings[key]);scope=scope.parent;}while(scope);return ids}bindingIdentifierEquals(name,node){return this.getBindingIdentifier(name)===node}getBinding(name){let previousPath,scope=this;do{const binding=scope.getOwnBinding(name);var _previousPath;if(binding){if(null==(_previousPath=previousPath)||!_previousPath.isPattern()||"param"===binding.kind||"local"===binding.kind)return binding}else if(!binding&&"arguments"===name&&scope.path.isFunction()&&!scope.path.isArrowFunctionExpression())break;previousPath=scope.path;}while(scope=scope.parent)}getOwnBinding(name){return this.bindings[name]}getBindingIdentifier(name){var _this$getBinding2;return null==(_this$getBinding2=this.getBinding(name))?void 0:_this$getBinding2.identifier}getOwnBindingIdentifier(name){const binding=this.bindings[name];return null==binding?void 0:binding.identifier}hasOwnBinding(name){return !!this.getOwnBinding(name)}hasBinding(name,opts){if(!name)return  false;let noGlobals,noUids,scope=this;do{if(scope.hasOwnBinding(name))return  true}while(scope=scope.parent);return "object"==typeof opts?(noGlobals=opts.noGlobals,noUids=opts.noUids):"boolean"==typeof opts&&(noGlobals=opts),!(noUids||!this.hasUid(name))||(!(noGlobals||!Scope.globals.includes(name))||!(noGlobals||!Scope.contextVariables.includes(name)))}parentHasBinding(name,opts){var _this$parent;return null==(_this$parent=this.parent)?void 0:_this$parent.hasBinding(name,opts)}moveBindingTo(name,scope){const info=this.getBinding(name);info&&(info.scope.removeOwnBinding(name),info.scope=scope,scope.bindings[name]=info);}removeOwnBinding(name){delete this.bindings[name];}removeBinding(name){var _this$getBinding3;null==(_this$getBinding3=this.getBinding(name))||_this$getBinding3.scope.removeOwnBinding(name);let scope=this;do{scope.uids[name]&&(scope.uids[name]=false);}while(scope=scope.parent)}hoistVariables(emit=id=>this.push({id})){this.crawl();const seen=new Set;for(const name of Object.keys(this.bindings)){const binding=this.bindings[name];if(!binding)continue;const{path}=binding;if(!path.isVariableDeclarator())continue;const{parent,parentPath}=path;if("var"!==parent.kind||seen.has(parent))continue;let firstId;seen.add(path.parent);const init=[];for(const decl of parent.declarations){null!=firstId||(firstId=decl.id),decl.init&&init.push(assignmentExpression("=",decl.id,decl.init));const ids=Object.keys(getBindingIdentifiers(decl,false,true,true));for(const name of ids)emit(identifier(name),null!=decl.init);}if(parentPath.parentPath.isFor({left:parent}))parentPath.replaceWith(firstId);else if(0===init.length)parentPath.remove();else {const expr=1===init.length?init[0]:sequenceExpression(init);parentPath.parentPath.isForStatement({init:parent})?parentPath.replaceWith(expr):parentPath.replaceWith(expressionStatement(expr));}}}}exports.default=Scope,Scope.globals=Object.keys(_globals.builtin),Scope.contextVariables=["arguments","undefined","Infinity","NaN"],Scope.prototype._renameFromMap=function(map,oldName,newName,value){map[oldName]&&(map[newName]=value,map[oldName]=null);},Scope.prototype.traverse=function(node,opts,state){(0, _index.default)(node,opts,this,state,this.path);},Scope.prototype._generateUid=function(name,i){let id=name;return i>1&&(id+=i),`_${id}`},Scope.prototype.toArray=function(node,i,arrayLikeIsIterable){if(isIdentifier(node)){const binding=this.getBinding(node.name);if(null!=binding&&binding.constant&&binding.path.isGenericType("Array"))return node}if(isArrayExpression(node))return node;if(isIdentifier(node,{name:"arguments"}))return callExpression(memberExpression(memberExpression(memberExpression(identifier("Array"),identifier("prototype")),identifier("slice")),identifier("call")),[node]);let helperName;const args=[node];return  true===i?helperName="toConsumableArray":"number"==typeof i?(args.push(numericLiteral(i)),helperName="slicedToArray"):helperName="toArray",arrayLikeIsIterable&&(args.unshift(this.path.hub.addHelper(helperName)),helperName="maybeArrayLike"),callExpression(this.path.hub.addHelper(helperName),args)},Scope.prototype.getAllBindingsOfKind=function(...kinds){const ids=Object.create(null);for(const kind of kinds){let scope=this;do{for(const name of Object.keys(scope.bindings)){const binding=scope.bindings[name];binding.kind===kind&&(ids[name]=binding);}scope=scope.parent;}while(scope)}return ids},Object.defineProperties(Scope.prototype,{parentBlock:{configurable:true,enumerable:true,get(){return this.path.parent}},hub:{configurable:true,enumerable:true,get(){return this.path.hub}}});},"./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/scope/lib/renamer.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=void 0;var t=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js"),_t=t,_traverseNode=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/traverse-node.js"),_visitors=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/visitors.js"),_context=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/context.js");const{getAssignmentIdentifiers}=_t,renameVisitor={ReferencedIdentifier({node},state){node.name===state.oldName&&(node.name=state.newName);},Scope(path,state){path.scope.bindingIdentifierEquals(state.oldName,state.binding.identifier)||(path.skip(),path.isMethod()&&(path.requeueComputedKeyAndDecorators?path.requeueComputedKeyAndDecorators():_context.requeueComputedKeyAndDecorators.call(path)));},ObjectProperty({node,scope},state){const{name}=node.key;var _node$extra;!node.shorthand||name!==state.oldName&&name!==state.newName||scope.getBindingIdentifier(name)!==state.binding.identifier||(node.shorthand=false,null!=(_node$extra=node.extra)&&_node$extra.shorthand&&(node.extra.shorthand=false));},"AssignmentExpression|Declaration|VariableDeclarator"(path,state){if(path.isVariableDeclaration())return;const ids=path.isAssignmentExpression()?getAssignmentIdentifiers(path.node):path.getOuterBindingIdentifiers();for(const name in ids)name===state.oldName&&(ids[name].name=state.newName);}};exports.default=class{constructor(binding,oldName,newName){this.newName=newName,this.oldName=oldName,this.binding=binding;}maybeConvertFromExportDeclaration(parentDeclar){const maybeExportDeclar=parentDeclar.parentPath;if(maybeExportDeclar.isExportDeclaration()){if(maybeExportDeclar.isExportDefaultDeclaration()){const{declaration}=maybeExportDeclar.node;if(t.isDeclaration(declaration)&&!declaration.id)return}maybeExportDeclar.isExportAllDeclaration()||maybeExportDeclar.splitExportDeclaration();}}maybeConvertFromClassFunctionDeclaration(path){return path}maybeConvertFromClassFunctionExpression(path){return path}rename(){const{binding,oldName,newName}=this,{scope,path}=binding,parentDeclar=path.find((path=>path.isDeclaration()||path.isFunctionExpression()||path.isClassExpression()));if(parentDeclar){parentDeclar.getOuterBindingIdentifiers()[oldName]===binding.identifier&&this.maybeConvertFromExportDeclaration(parentDeclar);}const blockToTraverse=arguments[0]||scope.block,skipKeys={discriminant:true};t.isMethod(blockToTraverse)&&(blockToTraverse.computed&&(skipKeys.key=true),t.isObjectMethod(blockToTraverse)||(skipKeys.decorators=true)),(0, _traverseNode.traverseNode)(blockToTraverse,(0, _visitors.explode)(renameVisitor),scope,this,scope.path,skipKeys),arguments[0]||(scope.removeOwnBinding(oldName),scope.bindings[newName]=binding,this.binding.identifier.name=newName),parentDeclar&&(this.maybeConvertFromClassFunctionDeclaration(path),this.maybeConvertFromClassFunctionExpression(path));}};},"./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/traverse-node.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.traverseNode=function(node,opts,scope,state,path,skipKeys,visitSelf){const keys=VISITOR_KEYS[node.type];if(!keys)return  false;const context=new _context.default(scope,opts,state,path);if(visitSelf)return (null==skipKeys||!skipKeys[path.parentKey])&&context.visitQueue([path]);for(const key of keys)if((null==skipKeys||!skipKeys[key])&&context.visit(node,key))return  true;return  false};var _context=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/context.js"),_t=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js");const{VISITOR_KEYS}=_t;},"./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/visitors.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.environmentVisitor=function(visitor){return merge([_environmentVisitor,visitor])},exports.explode=explode$1,exports.isExplodedVisitor=isExplodedVisitor,exports.merge=merge,exports.verify=verify$1;var virtualTypes=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/lib/virtual-types.js"),virtualTypesValidators=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/lib/virtual-types-validator.js"),_t=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js"),_context=__webpack_require__("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/context.js");const{DEPRECATED_KEYS,DEPRECATED_ALIASES,FLIPPED_ALIAS_KEYS,TYPES,__internal__deprecationWarning:deprecationWarning}=_t;function isExplodedVisitor(visitor){return null==visitor?void 0:visitor._exploded}function explode$1(visitor){if(isExplodedVisitor(visitor))return visitor;visitor._exploded=true;for(const nodeType of Object.keys(visitor)){if(shouldIgnoreKey(nodeType))continue;const parts=nodeType.split("|");if(1===parts.length)continue;const fns=visitor[nodeType];delete visitor[nodeType];for(const part of parts)visitor[part]=fns;}verify$1(visitor),delete visitor.__esModule,function(obj){for(const key of Object.keys(obj)){if(shouldIgnoreKey(key))continue;const fns=obj[key];"function"==typeof fns&&(obj[key]={enter:fns});}}(visitor),ensureCallbackArrays(visitor);for(const nodeType of Object.keys(visitor)){if(shouldIgnoreKey(nodeType))continue;if(!(nodeType in virtualTypes))continue;const fns=visitor[nodeType];for(const type of Object.keys(fns))fns[type]=wrapCheck(nodeType,fns[type]);delete visitor[nodeType];const types=virtualTypes[nodeType];if(null!==types)for(const type of types)visitor[type]?mergePair(visitor[type],fns):visitor[type]=fns;else mergePair(visitor,fns);}for(const nodeType of Object.keys(visitor)){if(shouldIgnoreKey(nodeType))continue;let aliases=FLIPPED_ALIAS_KEYS[nodeType];if(nodeType in DEPRECATED_KEYS){const deprecatedKey=DEPRECATED_KEYS[nodeType];deprecationWarning(nodeType,deprecatedKey,"Visitor "),aliases=[deprecatedKey];}else if(nodeType in DEPRECATED_ALIASES){const deprecatedAlias=DEPRECATED_ALIASES[nodeType];deprecationWarning(nodeType,deprecatedAlias,"Visitor "),aliases=FLIPPED_ALIAS_KEYS[deprecatedAlias];}if(!aliases)continue;const fns=visitor[nodeType];delete visitor[nodeType];for(const alias of aliases){const existing=visitor[alias];existing?mergePair(existing,fns):visitor[alias]=Object.assign({},fns);}}for(const nodeType of Object.keys(visitor))shouldIgnoreKey(nodeType)||ensureCallbackArrays(visitor[nodeType]);return visitor}function verify$1(visitor){if(!visitor._verified){if("function"==typeof visitor)throw new Error("You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Function }`?");for(const nodeType of Object.keys(visitor)){if("enter"!==nodeType&&"exit"!==nodeType||validateVisitorMethods(nodeType,visitor[nodeType]),shouldIgnoreKey(nodeType))continue;if(!TYPES.includes(nodeType))throw new Error(`You gave us a visitor for the node type ${nodeType} but it's not a valid type in @babel/traverse 7.26.4`);const visitors=visitor[nodeType];if("object"==typeof visitors)for(const visitorKey of Object.keys(visitors)){if("enter"!==visitorKey&&"exit"!==visitorKey)throw new Error(`You passed \`traverse()\` a visitor object with the property ${nodeType} that has the invalid property ${visitorKey}`);validateVisitorMethods(`${nodeType}.${visitorKey}`,visitors[visitorKey]);}}visitor._verified=true;}}function validateVisitorMethods(path,val){const fns=[].concat(val);for(const fn of fns)if("function"!=typeof fn)throw new TypeError(`Non-function found defined in ${path} with type ${typeof fn}`)}function merge(visitors,states=[],wrapper){const mergedVisitor={_verified:true,_exploded:true};Object.defineProperty(mergedVisitor,"_exploded",{enumerable:false}),Object.defineProperty(mergedVisitor,"_verified",{enumerable:false});for(let i=0;i<visitors.length;i++){const visitor=explode$1(visitors[i]),state=states[i];let topVisitor=visitor;(state||wrapper)&&(topVisitor=wrapWithStateOrWrapper(topVisitor,state,wrapper)),mergePair(mergedVisitor,topVisitor);for(const key of Object.keys(visitor)){if(shouldIgnoreKey(key))continue;let typeVisitor=visitor[key];(state||wrapper)&&(typeVisitor=wrapWithStateOrWrapper(typeVisitor,state,wrapper));mergePair(mergedVisitor[key]||(mergedVisitor[key]={}),typeVisitor);}}return mergedVisitor}function wrapWithStateOrWrapper(oldVisitor,state,wrapper){const newVisitor={};for(const phase of ["enter","exit"]){let fns=oldVisitor[phase];Array.isArray(fns)&&(fns=fns.map((function(fn){let newFn=fn;return state&&(newFn=function(path){fn.call(state,path,state);}),wrapper&&(newFn=wrapper(null==state?void 0:state.key,phase,newFn)),newFn!==fn&&(newFn.toString=()=>fn.toString()),newFn})),newVisitor[phase]=fns);}return newVisitor}function ensureCallbackArrays(obj){obj.enter&&!Array.isArray(obj.enter)&&(obj.enter=[obj.enter]),obj.exit&&!Array.isArray(obj.exit)&&(obj.exit=[obj.exit]);}function wrapCheck(nodeType,fn){const validator=virtualTypesValidators[`is${nodeType}`],newFn=function(path){if(validator.call(path))return fn.apply(this,arguments)};return newFn.toString=()=>fn.toString(),newFn}function shouldIgnoreKey(key){return "_"===key[0]||("enter"===key||"exit"===key||"shouldSkip"===key||("denylist"===key||"noScope"===key||"skipKeys"===key||"blacklist"===key))}function mergePair(dest,src){for(const phase of ["enter","exit"])src[phase]&&(dest[phase]=[].concat(dest[phase]||[],src[phase]));}const _environmentVisitor={FunctionParent(path){path.isArrowFunctionExpression()||(path.skip(),path.isMethod()&&(path.requeueComputedKeyAndDecorators?path.requeueComputedKeyAndDecorators():_context.requeueComputedKeyAndDecorators.call(path)));},Property(path){path.isObjectProperty()||(path.skip(),path.requeueComputedKeyAndDecorators?path.requeueComputedKeyAndDecorators():_context.requeueComputedKeyAndDecorators.call(path));}};},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/asserts/assertNode.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(node){if(!(0, _isNode.default)(node)){var _node$type;const type=null!=(_node$type=null==node?void 0:node.type)?_node$type:JSON.stringify(node);throw new TypeError(`Not a valid node of type "${type}"`)}};var _isNode=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isNode.js");},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/asserts/generated/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.assertAccessor=function(node,opts){assert("Accessor",node,opts);},exports.assertAnyTypeAnnotation=function(node,opts){assert("AnyTypeAnnotation",node,opts);},exports.assertArgumentPlaceholder=function(node,opts){assert("ArgumentPlaceholder",node,opts);},exports.assertArrayExpression=function(node,opts){assert("ArrayExpression",node,opts);},exports.assertArrayPattern=function(node,opts){assert("ArrayPattern",node,opts);},exports.assertArrayTypeAnnotation=function(node,opts){assert("ArrayTypeAnnotation",node,opts);},exports.assertArrowFunctionExpression=function(node,opts){assert("ArrowFunctionExpression",node,opts);},exports.assertAssignmentExpression=function(node,opts){assert("AssignmentExpression",node,opts);},exports.assertAssignmentPattern=function(node,opts){assert("AssignmentPattern",node,opts);},exports.assertAwaitExpression=function(node,opts){assert("AwaitExpression",node,opts);},exports.assertBigIntLiteral=function(node,opts){assert("BigIntLiteral",node,opts);},exports.assertBinary=function(node,opts){assert("Binary",node,opts);},exports.assertBinaryExpression=function(node,opts){assert("BinaryExpression",node,opts);},exports.assertBindExpression=function(node,opts){assert("BindExpression",node,opts);},exports.assertBlock=function(node,opts){assert("Block",node,opts);},exports.assertBlockParent=function(node,opts){assert("BlockParent",node,opts);},exports.assertBlockStatement=function(node,opts){assert("BlockStatement",node,opts);},exports.assertBooleanLiteral=function(node,opts){assert("BooleanLiteral",node,opts);},exports.assertBooleanLiteralTypeAnnotation=function(node,opts){assert("BooleanLiteralTypeAnnotation",node,opts);},exports.assertBooleanTypeAnnotation=function(node,opts){assert("BooleanTypeAnnotation",node,opts);},exports.assertBreakStatement=function(node,opts){assert("BreakStatement",node,opts);},exports.assertCallExpression=function(node,opts){assert("CallExpression",node,opts);},exports.assertCatchClause=function(node,opts){assert("CatchClause",node,opts);},exports.assertClass=function(node,opts){assert("Class",node,opts);},exports.assertClassAccessorProperty=function(node,opts){assert("ClassAccessorProperty",node,opts);},exports.assertClassBody=function(node,opts){assert("ClassBody",node,opts);},exports.assertClassDeclaration=function(node,opts){assert("ClassDeclaration",node,opts);},exports.assertClassExpression=function(node,opts){assert("ClassExpression",node,opts);},exports.assertClassImplements=function(node,opts){assert("ClassImplements",node,opts);},exports.assertClassMethod=function(node,opts){assert("ClassMethod",node,opts);},exports.assertClassPrivateMethod=function(node,opts){assert("ClassPrivateMethod",node,opts);},exports.assertClassPrivateProperty=function(node,opts){assert("ClassPrivateProperty",node,opts);},exports.assertClassProperty=function(node,opts){assert("ClassProperty",node,opts);},exports.assertCompletionStatement=function(node,opts){assert("CompletionStatement",node,opts);},exports.assertConditional=function(node,opts){assert("Conditional",node,opts);},exports.assertConditionalExpression=function(node,opts){assert("ConditionalExpression",node,opts);},exports.assertContinueStatement=function(node,opts){assert("ContinueStatement",node,opts);},exports.assertDebuggerStatement=function(node,opts){assert("DebuggerStatement",node,opts);},exports.assertDecimalLiteral=function(node,opts){assert("DecimalLiteral",node,opts);},exports.assertDeclaration=function(node,opts){assert("Declaration",node,opts);},exports.assertDeclareClass=function(node,opts){assert("DeclareClass",node,opts);},exports.assertDeclareExportAllDeclaration=function(node,opts){assert("DeclareExportAllDeclaration",node,opts);},exports.assertDeclareExportDeclaration=function(node,opts){assert("DeclareExportDeclaration",node,opts);},exports.assertDeclareFunction=function(node,opts){assert("DeclareFunction",node,opts);},exports.assertDeclareInterface=function(node,opts){assert("DeclareInterface",node,opts);},exports.assertDeclareModule=function(node,opts){assert("DeclareModule",node,opts);},exports.assertDeclareModuleExports=function(node,opts){assert("DeclareModuleExports",node,opts);},exports.assertDeclareOpaqueType=function(node,opts){assert("DeclareOpaqueType",node,opts);},exports.assertDeclareTypeAlias=function(node,opts){assert("DeclareTypeAlias",node,opts);},exports.assertDeclareVariable=function(node,opts){assert("DeclareVariable",node,opts);},exports.assertDeclaredPredicate=function(node,opts){assert("DeclaredPredicate",node,opts);},exports.assertDecorator=function(node,opts){assert("Decorator",node,opts);},exports.assertDirective=function(node,opts){assert("Directive",node,opts);},exports.assertDirectiveLiteral=function(node,opts){assert("DirectiveLiteral",node,opts);},exports.assertDoExpression=function(node,opts){assert("DoExpression",node,opts);},exports.assertDoWhileStatement=function(node,opts){assert("DoWhileStatement",node,opts);},exports.assertEmptyStatement=function(node,opts){assert("EmptyStatement",node,opts);},exports.assertEmptyTypeAnnotation=function(node,opts){assert("EmptyTypeAnnotation",node,opts);},exports.assertEnumBody=function(node,opts){assert("EnumBody",node,opts);},exports.assertEnumBooleanBody=function(node,opts){assert("EnumBooleanBody",node,opts);},exports.assertEnumBooleanMember=function(node,opts){assert("EnumBooleanMember",node,opts);},exports.assertEnumDeclaration=function(node,opts){assert("EnumDeclaration",node,opts);},exports.assertEnumDefaultedMember=function(node,opts){assert("EnumDefaultedMember",node,opts);},exports.assertEnumMember=function(node,opts){assert("EnumMember",node,opts);},exports.assertEnumNumberBody=function(node,opts){assert("EnumNumberBody",node,opts);},exports.assertEnumNumberMember=function(node,opts){assert("EnumNumberMember",node,opts);},exports.assertEnumStringBody=function(node,opts){assert("EnumStringBody",node,opts);},exports.assertEnumStringMember=function(node,opts){assert("EnumStringMember",node,opts);},exports.assertEnumSymbolBody=function(node,opts){assert("EnumSymbolBody",node,opts);},exports.assertExistsTypeAnnotation=function(node,opts){assert("ExistsTypeAnnotation",node,opts);},exports.assertExportAllDeclaration=function(node,opts){assert("ExportAllDeclaration",node,opts);},exports.assertExportDeclaration=function(node,opts){assert("ExportDeclaration",node,opts);},exports.assertExportDefaultDeclaration=function(node,opts){assert("ExportDefaultDeclaration",node,opts);},exports.assertExportDefaultSpecifier=function(node,opts){assert("ExportDefaultSpecifier",node,opts);},exports.assertExportNamedDeclaration=function(node,opts){assert("ExportNamedDeclaration",node,opts);},exports.assertExportNamespaceSpecifier=function(node,opts){assert("ExportNamespaceSpecifier",node,opts);},exports.assertExportSpecifier=function(node,opts){assert("ExportSpecifier",node,opts);},exports.assertExpression=function(node,opts){assert("Expression",node,opts);},exports.assertExpressionStatement=function(node,opts){assert("ExpressionStatement",node,opts);},exports.assertExpressionWrapper=function(node,opts){assert("ExpressionWrapper",node,opts);},exports.assertFile=function(node,opts){assert("File",node,opts);},exports.assertFlow=function(node,opts){assert("Flow",node,opts);},exports.assertFlowBaseAnnotation=function(node,opts){assert("FlowBaseAnnotation",node,opts);},exports.assertFlowDeclaration=function(node,opts){assert("FlowDeclaration",node,opts);},exports.assertFlowPredicate=function(node,opts){assert("FlowPredicate",node,opts);},exports.assertFlowType=function(node,opts){assert("FlowType",node,opts);},exports.assertFor=function(node,opts){assert("For",node,opts);},exports.assertForInStatement=function(node,opts){assert("ForInStatement",node,opts);},exports.assertForOfStatement=function(node,opts){assert("ForOfStatement",node,opts);},exports.assertForStatement=function(node,opts){assert("ForStatement",node,opts);},exports.assertForXStatement=function(node,opts){assert("ForXStatement",node,opts);},exports.assertFunction=function(node,opts){assert("Function",node,opts);},exports.assertFunctionDeclaration=function(node,opts){assert("FunctionDeclaration",node,opts);},exports.assertFunctionExpression=function(node,opts){assert("FunctionExpression",node,opts);},exports.assertFunctionParent=function(node,opts){assert("FunctionParent",node,opts);},exports.assertFunctionTypeAnnotation=function(node,opts){assert("FunctionTypeAnnotation",node,opts);},exports.assertFunctionTypeParam=function(node,opts){assert("FunctionTypeParam",node,opts);},exports.assertGenericTypeAnnotation=function(node,opts){assert("GenericTypeAnnotation",node,opts);},exports.assertIdentifier=function(node,opts){assert("Identifier",node,opts);},exports.assertIfStatement=function(node,opts){assert("IfStatement",node,opts);},exports.assertImmutable=function(node,opts){assert("Immutable",node,opts);},exports.assertImport=function(node,opts){assert("Import",node,opts);},exports.assertImportAttribute=function(node,opts){assert("ImportAttribute",node,opts);},exports.assertImportDeclaration=function(node,opts){assert("ImportDeclaration",node,opts);},exports.assertImportDefaultSpecifier=function(node,opts){assert("ImportDefaultSpecifier",node,opts);},exports.assertImportExpression=function(node,opts){assert("ImportExpression",node,opts);},exports.assertImportNamespaceSpecifier=function(node,opts){assert("ImportNamespaceSpecifier",node,opts);},exports.assertImportOrExportDeclaration=function(node,opts){assert("ImportOrExportDeclaration",node,opts);},exports.assertImportSpecifier=function(node,opts){assert("ImportSpecifier",node,opts);},exports.assertIndexedAccessType=function(node,opts){assert("IndexedAccessType",node,opts);},exports.assertInferredPredicate=function(node,opts){assert("InferredPredicate",node,opts);},exports.assertInterfaceDeclaration=function(node,opts){assert("InterfaceDeclaration",node,opts);},exports.assertInterfaceExtends=function(node,opts){assert("InterfaceExtends",node,opts);},exports.assertInterfaceTypeAnnotation=function(node,opts){assert("InterfaceTypeAnnotation",node,opts);},exports.assertInterpreterDirective=function(node,opts){assert("InterpreterDirective",node,opts);},exports.assertIntersectionTypeAnnotation=function(node,opts){assert("IntersectionTypeAnnotation",node,opts);},exports.assertJSX=function(node,opts){assert("JSX",node,opts);},exports.assertJSXAttribute=function(node,opts){assert("JSXAttribute",node,opts);},exports.assertJSXClosingElement=function(node,opts){assert("JSXClosingElement",node,opts);},exports.assertJSXClosingFragment=function(node,opts){assert("JSXClosingFragment",node,opts);},exports.assertJSXElement=function(node,opts){assert("JSXElement",node,opts);},exports.assertJSXEmptyExpression=function(node,opts){assert("JSXEmptyExpression",node,opts);},exports.assertJSXExpressionContainer=function(node,opts){assert("JSXExpressionContainer",node,opts);},exports.assertJSXFragment=function(node,opts){assert("JSXFragment",node,opts);},exports.assertJSXIdentifier=function(node,opts){assert("JSXIdentifier",node,opts);},exports.assertJSXMemberExpression=function(node,opts){assert("JSXMemberExpression",node,opts);},exports.assertJSXNamespacedName=function(node,opts){assert("JSXNamespacedName",node,opts);},exports.assertJSXOpeningElement=function(node,opts){assert("JSXOpeningElement",node,opts);},exports.assertJSXOpeningFragment=function(node,opts){assert("JSXOpeningFragment",node,opts);},exports.assertJSXSpreadAttribute=function(node,opts){assert("JSXSpreadAttribute",node,opts);},exports.assertJSXSpreadChild=function(node,opts){assert("JSXSpreadChild",node,opts);},exports.assertJSXText=function(node,opts){assert("JSXText",node,opts);},exports.assertLVal=function(node,opts){assert("LVal",node,opts);},exports.assertLabeledStatement=function(node,opts){assert("LabeledStatement",node,opts);},exports.assertLiteral=function(node,opts){assert("Literal",node,opts);},exports.assertLogicalExpression=function(node,opts){assert("LogicalExpression",node,opts);},exports.assertLoop=function(node,opts){assert("Loop",node,opts);},exports.assertMemberExpression=function(node,opts){assert("MemberExpression",node,opts);},exports.assertMetaProperty=function(node,opts){assert("MetaProperty",node,opts);},exports.assertMethod=function(node,opts){assert("Method",node,opts);},exports.assertMiscellaneous=function(node,opts){assert("Miscellaneous",node,opts);},exports.assertMixedTypeAnnotation=function(node,opts){assert("MixedTypeAnnotation",node,opts);},exports.assertModuleDeclaration=function(node,opts){(0, _deprecationWarning.default)("assertModuleDeclaration","assertImportOrExportDeclaration"),assert("ModuleDeclaration",node,opts);},exports.assertModuleExpression=function(node,opts){assert("ModuleExpression",node,opts);},exports.assertModuleSpecifier=function(node,opts){assert("ModuleSpecifier",node,opts);},exports.assertNewExpression=function(node,opts){assert("NewExpression",node,opts);},exports.assertNoop=function(node,opts){assert("Noop",node,opts);},exports.assertNullLiteral=function(node,opts){assert("NullLiteral",node,opts);},exports.assertNullLiteralTypeAnnotation=function(node,opts){assert("NullLiteralTypeAnnotation",node,opts);},exports.assertNullableTypeAnnotation=function(node,opts){assert("NullableTypeAnnotation",node,opts);},exports.assertNumberLiteral=function(node,opts){(0, _deprecationWarning.default)("assertNumberLiteral","assertNumericLiteral"),assert("NumberLiteral",node,opts);},exports.assertNumberLiteralTypeAnnotation=function(node,opts){assert("NumberLiteralTypeAnnotation",node,opts);},exports.assertNumberTypeAnnotation=function(node,opts){assert("NumberTypeAnnotation",node,opts);},exports.assertNumericLiteral=function(node,opts){assert("NumericLiteral",node,opts);},exports.assertObjectExpression=function(node,opts){assert("ObjectExpression",node,opts);},exports.assertObjectMember=function(node,opts){assert("ObjectMember",node,opts);},exports.assertObjectMethod=function(node,opts){assert("ObjectMethod",node,opts);},exports.assertObjectPattern=function(node,opts){assert("ObjectPattern",node,opts);},exports.assertObjectProperty=function(node,opts){assert("ObjectProperty",node,opts);},exports.assertObjectTypeAnnotation=function(node,opts){assert("ObjectTypeAnnotation",node,opts);},exports.assertObjectTypeCallProperty=function(node,opts){assert("ObjectTypeCallProperty",node,opts);},exports.assertObjectTypeIndexer=function(node,opts){assert("ObjectTypeIndexer",node,opts);},exports.assertObjectTypeInternalSlot=function(node,opts){assert("ObjectTypeInternalSlot",node,opts);},exports.assertObjectTypeProperty=function(node,opts){assert("ObjectTypeProperty",node,opts);},exports.assertObjectTypeSpreadProperty=function(node,opts){assert("ObjectTypeSpreadProperty",node,opts);},exports.assertOpaqueType=function(node,opts){assert("OpaqueType",node,opts);},exports.assertOptionalCallExpression=function(node,opts){assert("OptionalCallExpression",node,opts);},exports.assertOptionalIndexedAccessType=function(node,opts){assert("OptionalIndexedAccessType",node,opts);},exports.assertOptionalMemberExpression=function(node,opts){assert("OptionalMemberExpression",node,opts);},exports.assertParenthesizedExpression=function(node,opts){assert("ParenthesizedExpression",node,opts);},exports.assertPattern=function(node,opts){assert("Pattern",node,opts);},exports.assertPatternLike=function(node,opts){assert("PatternLike",node,opts);},exports.assertPipelineBareFunction=function(node,opts){assert("PipelineBareFunction",node,opts);},exports.assertPipelinePrimaryTopicReference=function(node,opts){assert("PipelinePrimaryTopicReference",node,opts);},exports.assertPipelineTopicExpression=function(node,opts){assert("PipelineTopicExpression",node,opts);},exports.assertPlaceholder=function(node,opts){assert("Placeholder",node,opts);},exports.assertPrivate=function(node,opts){assert("Private",node,opts);},exports.assertPrivateName=function(node,opts){assert("PrivateName",node,opts);},exports.assertProgram=function(node,opts){assert("Program",node,opts);},exports.assertProperty=function(node,opts){assert("Property",node,opts);},exports.assertPureish=function(node,opts){assert("Pureish",node,opts);},exports.assertQualifiedTypeIdentifier=function(node,opts){assert("QualifiedTypeIdentifier",node,opts);},exports.assertRecordExpression=function(node,opts){assert("RecordExpression",node,opts);},exports.assertRegExpLiteral=function(node,opts){assert("RegExpLiteral",node,opts);},exports.assertRegexLiteral=function(node,opts){(0, _deprecationWarning.default)("assertRegexLiteral","assertRegExpLiteral"),assert("RegexLiteral",node,opts);},exports.assertRestElement=function(node,opts){assert("RestElement",node,opts);},exports.assertRestProperty=function(node,opts){(0, _deprecationWarning.default)("assertRestProperty","assertRestElement"),assert("RestProperty",node,opts);},exports.assertReturnStatement=function(node,opts){assert("ReturnStatement",node,opts);},exports.assertScopable=function(node,opts){assert("Scopable",node,opts);},exports.assertSequenceExpression=function(node,opts){assert("SequenceExpression",node,opts);},exports.assertSpreadElement=function(node,opts){assert("SpreadElement",node,opts);},exports.assertSpreadProperty=function(node,opts){(0, _deprecationWarning.default)("assertSpreadProperty","assertSpreadElement"),assert("SpreadProperty",node,opts);},exports.assertStandardized=function(node,opts){assert("Standardized",node,opts);},exports.assertStatement=function(node,opts){assert("Statement",node,opts);},exports.assertStaticBlock=function(node,opts){assert("StaticBlock",node,opts);},exports.assertStringLiteral=function(node,opts){assert("StringLiteral",node,opts);},exports.assertStringLiteralTypeAnnotation=function(node,opts){assert("StringLiteralTypeAnnotation",node,opts);},exports.assertStringTypeAnnotation=function(node,opts){assert("StringTypeAnnotation",node,opts);},exports.assertSuper=function(node,opts){assert("Super",node,opts);},exports.assertSwitchCase=function(node,opts){assert("SwitchCase",node,opts);},exports.assertSwitchStatement=function(node,opts){assert("SwitchStatement",node,opts);},exports.assertSymbolTypeAnnotation=function(node,opts){assert("SymbolTypeAnnotation",node,opts);},exports.assertTSAnyKeyword=function(node,opts){assert("TSAnyKeyword",node,opts);},exports.assertTSArrayType=function(node,opts){assert("TSArrayType",node,opts);},exports.assertTSAsExpression=function(node,opts){assert("TSAsExpression",node,opts);},exports.assertTSBaseType=function(node,opts){assert("TSBaseType",node,opts);},exports.assertTSBigIntKeyword=function(node,opts){assert("TSBigIntKeyword",node,opts);},exports.assertTSBooleanKeyword=function(node,opts){assert("TSBooleanKeyword",node,opts);},exports.assertTSCallSignatureDeclaration=function(node,opts){assert("TSCallSignatureDeclaration",node,opts);},exports.assertTSConditionalType=function(node,opts){assert("TSConditionalType",node,opts);},exports.assertTSConstructSignatureDeclaration=function(node,opts){assert("TSConstructSignatureDeclaration",node,opts);},exports.assertTSConstructorType=function(node,opts){assert("TSConstructorType",node,opts);},exports.assertTSDeclareFunction=function(node,opts){assert("TSDeclareFunction",node,opts);},exports.assertTSDeclareMethod=function(node,opts){assert("TSDeclareMethod",node,opts);},exports.assertTSEntityName=function(node,opts){assert("TSEntityName",node,opts);},exports.assertTSEnumDeclaration=function(node,opts){assert("TSEnumDeclaration",node,opts);},exports.assertTSEnumMember=function(node,opts){assert("TSEnumMember",node,opts);},exports.assertTSExportAssignment=function(node,opts){assert("TSExportAssignment",node,opts);},exports.assertTSExpressionWithTypeArguments=function(node,opts){assert("TSExpressionWithTypeArguments",node,opts);},exports.assertTSExternalModuleReference=function(node,opts){assert("TSExternalModuleReference",node,opts);},exports.assertTSFunctionType=function(node,opts){assert("TSFunctionType",node,opts);},exports.assertTSImportEqualsDeclaration=function(node,opts){assert("TSImportEqualsDeclaration",node,opts);},exports.assertTSImportType=function(node,opts){assert("TSImportType",node,opts);},exports.assertTSIndexSignature=function(node,opts){assert("TSIndexSignature",node,opts);},exports.assertTSIndexedAccessType=function(node,opts){assert("TSIndexedAccessType",node,opts);},exports.assertTSInferType=function(node,opts){assert("TSInferType",node,opts);},exports.assertTSInstantiationExpression=function(node,opts){assert("TSInstantiationExpression",node,opts);},exports.assertTSInterfaceBody=function(node,opts){assert("TSInterfaceBody",node,opts);},exports.assertTSInterfaceDeclaration=function(node,opts){assert("TSInterfaceDeclaration",node,opts);},exports.assertTSIntersectionType=function(node,opts){assert("TSIntersectionType",node,opts);},exports.assertTSIntrinsicKeyword=function(node,opts){assert("TSIntrinsicKeyword",node,opts);},exports.assertTSLiteralType=function(node,opts){assert("TSLiteralType",node,opts);},exports.assertTSMappedType=function(node,opts){assert("TSMappedType",node,opts);},exports.assertTSMethodSignature=function(node,opts){assert("TSMethodSignature",node,opts);},exports.assertTSModuleBlock=function(node,opts){assert("TSModuleBlock",node,opts);},exports.assertTSModuleDeclaration=function(node,opts){assert("TSModuleDeclaration",node,opts);},exports.assertTSNamedTupleMember=function(node,opts){assert("TSNamedTupleMember",node,opts);},exports.assertTSNamespaceExportDeclaration=function(node,opts){assert("TSNamespaceExportDeclaration",node,opts);},exports.assertTSNeverKeyword=function(node,opts){assert("TSNeverKeyword",node,opts);},exports.assertTSNonNullExpression=function(node,opts){assert("TSNonNullExpression",node,opts);},exports.assertTSNullKeyword=function(node,opts){assert("TSNullKeyword",node,opts);},exports.assertTSNumberKeyword=function(node,opts){assert("TSNumberKeyword",node,opts);},exports.assertTSObjectKeyword=function(node,opts){assert("TSObjectKeyword",node,opts);},exports.assertTSOptionalType=function(node,opts){assert("TSOptionalType",node,opts);},exports.assertTSParameterProperty=function(node,opts){assert("TSParameterProperty",node,opts);},exports.assertTSParenthesizedType=function(node,opts){assert("TSParenthesizedType",node,opts);},exports.assertTSPropertySignature=function(node,opts){assert("TSPropertySignature",node,opts);},exports.assertTSQualifiedName=function(node,opts){assert("TSQualifiedName",node,opts);},exports.assertTSRestType=function(node,opts){assert("TSRestType",node,opts);},exports.assertTSSatisfiesExpression=function(node,opts){assert("TSSatisfiesExpression",node,opts);},exports.assertTSStringKeyword=function(node,opts){assert("TSStringKeyword",node,opts);},exports.assertTSSymbolKeyword=function(node,opts){assert("TSSymbolKeyword",node,opts);},exports.assertTSThisType=function(node,opts){assert("TSThisType",node,opts);},exports.assertTSTupleType=function(node,opts){assert("TSTupleType",node,opts);},exports.assertTSType=function(node,opts){assert("TSType",node,opts);},exports.assertTSTypeAliasDeclaration=function(node,opts){assert("TSTypeAliasDeclaration",node,opts);},exports.assertTSTypeAnnotation=function(node,opts){assert("TSTypeAnnotation",node,opts);},exports.assertTSTypeAssertion=function(node,opts){assert("TSTypeAssertion",node,opts);},exports.assertTSTypeElement=function(node,opts){assert("TSTypeElement",node,opts);},exports.assertTSTypeLiteral=function(node,opts){assert("TSTypeLiteral",node,opts);},exports.assertTSTypeOperator=function(node,opts){assert("TSTypeOperator",node,opts);},exports.assertTSTypeParameter=function(node,opts){assert("TSTypeParameter",node,opts);},exports.assertTSTypeParameterDeclaration=function(node,opts){assert("TSTypeParameterDeclaration",node,opts);},exports.assertTSTypeParameterInstantiation=function(node,opts){assert("TSTypeParameterInstantiation",node,opts);},exports.assertTSTypePredicate=function(node,opts){assert("TSTypePredicate",node,opts);},exports.assertTSTypeQuery=function(node,opts){assert("TSTypeQuery",node,opts);},exports.assertTSTypeReference=function(node,opts){assert("TSTypeReference",node,opts);},exports.assertTSUndefinedKeyword=function(node,opts){assert("TSUndefinedKeyword",node,opts);},exports.assertTSUnionType=function(node,opts){assert("TSUnionType",node,opts);},exports.assertTSUnknownKeyword=function(node,opts){assert("TSUnknownKeyword",node,opts);},exports.assertTSVoidKeyword=function(node,opts){assert("TSVoidKeyword",node,opts);},exports.assertTaggedTemplateExpression=function(node,opts){assert("TaggedTemplateExpression",node,opts);},exports.assertTemplateElement=function(node,opts){assert("TemplateElement",node,opts);},exports.assertTemplateLiteral=function(node,opts){assert("TemplateLiteral",node,opts);},exports.assertTerminatorless=function(node,opts){assert("Terminatorless",node,opts);},exports.assertThisExpression=function(node,opts){assert("ThisExpression",node,opts);},exports.assertThisTypeAnnotation=function(node,opts){assert("ThisTypeAnnotation",node,opts);},exports.assertThrowStatement=function(node,opts){assert("ThrowStatement",node,opts);},exports.assertTopicReference=function(node,opts){assert("TopicReference",node,opts);},exports.assertTryStatement=function(node,opts){assert("TryStatement",node,opts);},exports.assertTupleExpression=function(node,opts){assert("TupleExpression",node,opts);},exports.assertTupleTypeAnnotation=function(node,opts){assert("TupleTypeAnnotation",node,opts);},exports.assertTypeAlias=function(node,opts){assert("TypeAlias",node,opts);},exports.assertTypeAnnotation=function(node,opts){assert("TypeAnnotation",node,opts);},exports.assertTypeCastExpression=function(node,opts){assert("TypeCastExpression",node,opts);},exports.assertTypeParameter=function(node,opts){assert("TypeParameter",node,opts);},exports.assertTypeParameterDeclaration=function(node,opts){assert("TypeParameterDeclaration",node,opts);},exports.assertTypeParameterInstantiation=function(node,opts){assert("TypeParameterInstantiation",node,opts);},exports.assertTypeScript=function(node,opts){assert("TypeScript",node,opts);},exports.assertTypeofTypeAnnotation=function(node,opts){assert("TypeofTypeAnnotation",node,opts);},exports.assertUnaryExpression=function(node,opts){assert("UnaryExpression",node,opts);},exports.assertUnaryLike=function(node,opts){assert("UnaryLike",node,opts);},exports.assertUnionTypeAnnotation=function(node,opts){assert("UnionTypeAnnotation",node,opts);},exports.assertUpdateExpression=function(node,opts){assert("UpdateExpression",node,opts);},exports.assertUserWhitespacable=function(node,opts){assert("UserWhitespacable",node,opts);},exports.assertV8IntrinsicIdentifier=function(node,opts){assert("V8IntrinsicIdentifier",node,opts);},exports.assertVariableDeclaration=function(node,opts){assert("VariableDeclaration",node,opts);},exports.assertVariableDeclarator=function(node,opts){assert("VariableDeclarator",node,opts);},exports.assertVariance=function(node,opts){assert("Variance",node,opts);},exports.assertVoidTypeAnnotation=function(node,opts){assert("VoidTypeAnnotation",node,opts);},exports.assertWhile=function(node,opts){assert("While",node,opts);},exports.assertWhileStatement=function(node,opts){assert("WhileStatement",node,opts);},exports.assertWithStatement=function(node,opts){assert("WithStatement",node,opts);},exports.assertYieldExpression=function(node,opts){assert("YieldExpression",node,opts);};var _is=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/is.js"),_deprecationWarning=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/utils/deprecationWarning.js");function assert(type,node,opts){if(!(0, _is.default)(type,node,opts))throw new Error(`Expected type "${type}" with option ${JSON.stringify(opts)}, but instead got "${node.type}".`)}},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(types){const flattened=(0, _removeTypeDuplicates.default)(types);return 1===flattened.length?flattened[0]:(0, _index.unionTypeAnnotation)(flattened)};var _index=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/generated/index.js"),_removeTypeDuplicates=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js");},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=void 0;var _index=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/generated/index.js");exports.default=function(type){switch(type){case "string":return (0, _index.stringTypeAnnotation)();case "number":return (0, _index.numberTypeAnnotation)();case "undefined":return (0, _index.voidTypeAnnotation)();case "boolean":return (0, _index.booleanTypeAnnotation)();case "function":return (0, _index.genericTypeAnnotation)((0, _index.identifier)("Function"));case "object":return (0, _index.genericTypeAnnotation)((0, _index.identifier)("Object"));case "symbol":return (0, _index.genericTypeAnnotation)((0, _index.identifier)("Symbol"));case "bigint":return (0, _index.anyTypeAnnotation)()}throw new Error("Invalid typeof value: "+type)};},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/generated/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.anyTypeAnnotation=function(){return {type:"AnyTypeAnnotation"}},exports.argumentPlaceholder=function(){return {type:"ArgumentPlaceholder"}},exports.arrayExpression=function(elements=[]){const node={type:"ArrayExpression",elements},defs=NODE_FIELDS.ArrayExpression;return validate(defs.elements,node,"elements",elements,1),node},exports.arrayPattern=function(elements){const node={type:"ArrayPattern",elements},defs=NODE_FIELDS.ArrayPattern;return validate(defs.elements,node,"elements",elements,1),node},exports.arrayTypeAnnotation=function(elementType){const node={type:"ArrayTypeAnnotation",elementType},defs=NODE_FIELDS.ArrayTypeAnnotation;return validate(defs.elementType,node,"elementType",elementType,1),node},exports.arrowFunctionExpression=function(params,body,async=false){const node={type:"ArrowFunctionExpression",params,body,async,expression:null},defs=NODE_FIELDS.ArrowFunctionExpression;return validate(defs.params,node,"params",params,1),validate(defs.body,node,"body",body,1),validate(defs.async,node,"async",async),node},exports.assignmentExpression=function(operator,left,right){const node={type:"AssignmentExpression",operator,left,right},defs=NODE_FIELDS.AssignmentExpression;return validate(defs.operator,node,"operator",operator),validate(defs.left,node,"left",left,1),validate(defs.right,node,"right",right,1),node},exports.assignmentPattern=function(left,right){const node={type:"AssignmentPattern",left,right},defs=NODE_FIELDS.AssignmentPattern;return validate(defs.left,node,"left",left,1),validate(defs.right,node,"right",right,1),node},exports.awaitExpression=function(argument){const node={type:"AwaitExpression",argument},defs=NODE_FIELDS.AwaitExpression;return validate(defs.argument,node,"argument",argument,1),node},exports.bigIntLiteral=function(value){const node={type:"BigIntLiteral",value},defs=NODE_FIELDS.BigIntLiteral;return validate(defs.value,node,"value",value),node},exports.binaryExpression=function(operator,left,right){const node={type:"BinaryExpression",operator,left,right},defs=NODE_FIELDS.BinaryExpression;return validate(defs.operator,node,"operator",operator),validate(defs.left,node,"left",left,1),validate(defs.right,node,"right",right,1),node},exports.bindExpression=function(object,callee){const node={type:"BindExpression",object,callee},defs=NODE_FIELDS.BindExpression;return validate(defs.object,node,"object",object,1),validate(defs.callee,node,"callee",callee,1),node},exports.blockStatement=function(body,directives=[]){const node={type:"BlockStatement",body,directives},defs=NODE_FIELDS.BlockStatement;return validate(defs.body,node,"body",body,1),validate(defs.directives,node,"directives",directives,1),node},exports.booleanLiteral=function(value){const node={type:"BooleanLiteral",value},defs=NODE_FIELDS.BooleanLiteral;return validate(defs.value,node,"value",value),node},exports.booleanLiteralTypeAnnotation=function(value){const node={type:"BooleanLiteralTypeAnnotation",value},defs=NODE_FIELDS.BooleanLiteralTypeAnnotation;return validate(defs.value,node,"value",value),node},exports.booleanTypeAnnotation=function(){return {type:"BooleanTypeAnnotation"}},exports.breakStatement=function(label=null){const node={type:"BreakStatement",label},defs=NODE_FIELDS.BreakStatement;return validate(defs.label,node,"label",label,1),node},exports.callExpression=function(callee,_arguments){const node={type:"CallExpression",callee,arguments:_arguments},defs=NODE_FIELDS.CallExpression;return validate(defs.callee,node,"callee",callee,1),validate(defs.arguments,node,"arguments",_arguments,1),node},exports.catchClause=function(param=null,body){const node={type:"CatchClause",param,body},defs=NODE_FIELDS.CatchClause;return validate(defs.param,node,"param",param,1),validate(defs.body,node,"body",body,1),node},exports.classAccessorProperty=function(key,value=null,typeAnnotation=null,decorators=null,computed=false,_static=false){const node={type:"ClassAccessorProperty",key,value,typeAnnotation,decorators,computed,static:_static},defs=NODE_FIELDS.ClassAccessorProperty;return validate(defs.key,node,"key",key,1),validate(defs.value,node,"value",value,1),validate(defs.typeAnnotation,node,"typeAnnotation",typeAnnotation,1),validate(defs.decorators,node,"decorators",decorators,1),validate(defs.computed,node,"computed",computed),validate(defs.static,node,"static",_static),node},exports.classBody=function(body){const node={type:"ClassBody",body},defs=NODE_FIELDS.ClassBody;return validate(defs.body,node,"body",body,1),node},exports.classDeclaration=function(id=null,superClass=null,body,decorators=null){const node={type:"ClassDeclaration",id,superClass,body,decorators},defs=NODE_FIELDS.ClassDeclaration;return validate(defs.id,node,"id",id,1),validate(defs.superClass,node,"superClass",superClass,1),validate(defs.body,node,"body",body,1),validate(defs.decorators,node,"decorators",decorators,1),node},exports.classExpression=function(id=null,superClass=null,body,decorators=null){const node={type:"ClassExpression",id,superClass,body,decorators},defs=NODE_FIELDS.ClassExpression;return validate(defs.id,node,"id",id,1),validate(defs.superClass,node,"superClass",superClass,1),validate(defs.body,node,"body",body,1),validate(defs.decorators,node,"decorators",decorators,1),node},exports.classImplements=function(id,typeParameters=null){const node={type:"ClassImplements",id,typeParameters},defs=NODE_FIELDS.ClassImplements;return validate(defs.id,node,"id",id,1),validate(defs.typeParameters,node,"typeParameters",typeParameters,1),node},exports.classMethod=function(kind="method",key,params,body,computed=false,_static=false,generator=false,async=false){const node={type:"ClassMethod",kind,key,params,body,computed,static:_static,generator,async},defs=NODE_FIELDS.ClassMethod;return validate(defs.kind,node,"kind",kind),validate(defs.key,node,"key",key,1),validate(defs.params,node,"params",params,1),validate(defs.body,node,"body",body,1),validate(defs.computed,node,"computed",computed),validate(defs.static,node,"static",_static),validate(defs.generator,node,"generator",generator),validate(defs.async,node,"async",async),node},exports.classPrivateMethod=function(kind="method",key,params,body,_static=false){const node={type:"ClassPrivateMethod",kind,key,params,body,static:_static},defs=NODE_FIELDS.ClassPrivateMethod;return validate(defs.kind,node,"kind",kind),validate(defs.key,node,"key",key,1),validate(defs.params,node,"params",params,1),validate(defs.body,node,"body",body,1),validate(defs.static,node,"static",_static),node},exports.classPrivateProperty=function(key,value=null,decorators=null,_static=false){const node={type:"ClassPrivateProperty",key,value,decorators,static:_static},defs=NODE_FIELDS.ClassPrivateProperty;return validate(defs.key,node,"key",key,1),validate(defs.value,node,"value",value,1),validate(defs.decorators,node,"decorators",decorators,1),validate(defs.static,node,"static",_static),node},exports.classProperty=function(key,value=null,typeAnnotation=null,decorators=null,computed=false,_static=false){const node={type:"ClassProperty",key,value,typeAnnotation,decorators,computed,static:_static},defs=NODE_FIELDS.ClassProperty;return validate(defs.key,node,"key",key,1),validate(defs.value,node,"value",value,1),validate(defs.typeAnnotation,node,"typeAnnotation",typeAnnotation,1),validate(defs.decorators,node,"decorators",decorators,1),validate(defs.computed,node,"computed",computed),validate(defs.static,node,"static",_static),node},exports.conditionalExpression=function(test,consequent,alternate){const node={type:"ConditionalExpression",test,consequent,alternate},defs=NODE_FIELDS.ConditionalExpression;return validate(defs.test,node,"test",test,1),validate(defs.consequent,node,"consequent",consequent,1),validate(defs.alternate,node,"alternate",alternate,1),node},exports.continueStatement=function(label=null){const node={type:"ContinueStatement",label},defs=NODE_FIELDS.ContinueStatement;return validate(defs.label,node,"label",label,1),node},exports.debuggerStatement=function(){return {type:"DebuggerStatement"}},exports.decimalLiteral=function(value){const node={type:"DecimalLiteral",value},defs=NODE_FIELDS.DecimalLiteral;return validate(defs.value,node,"value",value),node},exports.declareClass=function(id,typeParameters=null,_extends=null,body){const node={type:"DeclareClass",id,typeParameters,extends:_extends,body},defs=NODE_FIELDS.DeclareClass;return validate(defs.id,node,"id",id,1),validate(defs.typeParameters,node,"typeParameters",typeParameters,1),validate(defs.extends,node,"extends",_extends,1),validate(defs.body,node,"body",body,1),node},exports.declareExportAllDeclaration=function(source,attributes=null){const node={type:"DeclareExportAllDeclaration",source,attributes},defs=NODE_FIELDS.DeclareExportAllDeclaration;return validate(defs.source,node,"source",source,1),validate(defs.attributes,node,"attributes",attributes,1),node},exports.declareExportDeclaration=function(declaration=null,specifiers=null,source=null,attributes=null){const node={type:"DeclareExportDeclaration",declaration,specifiers,source,attributes},defs=NODE_FIELDS.DeclareExportDeclaration;return validate(defs.declaration,node,"declaration",declaration,1),validate(defs.specifiers,node,"specifiers",specifiers,1),validate(defs.source,node,"source",source,1),validate(defs.attributes,node,"attributes",attributes,1),node},exports.declareFunction=function(id){const node={type:"DeclareFunction",id},defs=NODE_FIELDS.DeclareFunction;return validate(defs.id,node,"id",id,1),node},exports.declareInterface=function(id,typeParameters=null,_extends=null,body){const node={type:"DeclareInterface",id,typeParameters,extends:_extends,body},defs=NODE_FIELDS.DeclareInterface;return validate(defs.id,node,"id",id,1),validate(defs.typeParameters,node,"typeParameters",typeParameters,1),validate(defs.extends,node,"extends",_extends,1),validate(defs.body,node,"body",body,1),node},exports.declareModule=function(id,body,kind=null){const node={type:"DeclareModule",id,body,kind},defs=NODE_FIELDS.DeclareModule;return validate(defs.id,node,"id",id,1),validate(defs.body,node,"body",body,1),validate(defs.kind,node,"kind",kind),node},exports.declareModuleExports=function(typeAnnotation){const node={type:"DeclareModuleExports",typeAnnotation},defs=NODE_FIELDS.DeclareModuleExports;return validate(defs.typeAnnotation,node,"typeAnnotation",typeAnnotation,1),node},exports.declareOpaqueType=function(id,typeParameters=null,supertype=null){const node={type:"DeclareOpaqueType",id,typeParameters,supertype},defs=NODE_FIELDS.DeclareOpaqueType;return validate(defs.id,node,"id",id,1),validate(defs.typeParameters,node,"typeParameters",typeParameters,1),validate(defs.supertype,node,"supertype",supertype,1),node},exports.declareTypeAlias=function(id,typeParameters=null,right){const node={type:"DeclareTypeAlias",id,typeParameters,right},defs=NODE_FIELDS.DeclareTypeAlias;return validate(defs.id,node,"id",id,1),validate(defs.typeParameters,node,"typeParameters",typeParameters,1),validate(defs.right,node,"right",right,1),node},exports.declareVariable=function(id){const node={type:"DeclareVariable",id},defs=NODE_FIELDS.DeclareVariable;return validate(defs.id,node,"id",id,1),node},exports.declaredPredicate=function(value){const node={type:"DeclaredPredicate",value},defs=NODE_FIELDS.DeclaredPredicate;return validate(defs.value,node,"value",value,1),node},exports.decorator=function(expression){const node={type:"Decorator",expression},defs=NODE_FIELDS.Decorator;return validate(defs.expression,node,"expression",expression,1),node},exports.directive=function(value){const node={type:"Directive",value},defs=NODE_FIELDS.Directive;return validate(defs.value,node,"value",value,1),node},exports.directiveLiteral=function(value){const node={type:"DirectiveLiteral",value},defs=NODE_FIELDS.DirectiveLiteral;return validate(defs.value,node,"value",value),node},exports.doExpression=function(body,async=false){const node={type:"DoExpression",body,async},defs=NODE_FIELDS.DoExpression;return validate(defs.body,node,"body",body,1),validate(defs.async,node,"async",async),node},exports.doWhileStatement=function(test,body){const node={type:"DoWhileStatement",test,body},defs=NODE_FIELDS.DoWhileStatement;return validate(defs.test,node,"test",test,1),validate(defs.body,node,"body",body,1),node},exports.emptyStatement=function(){return {type:"EmptyStatement"}},exports.emptyTypeAnnotation=function(){return {type:"EmptyTypeAnnotation"}},exports.enumBooleanBody=function(members){const node={type:"EnumBooleanBody",members,explicitType:null,hasUnknownMembers:null},defs=NODE_FIELDS.EnumBooleanBody;return validate(defs.members,node,"members",members,1),node},exports.enumBooleanMember=function(id){const node={type:"EnumBooleanMember",id,init:null},defs=NODE_FIELDS.EnumBooleanMember;return validate(defs.id,node,"id",id,1),node},exports.enumDeclaration=function(id,body){const node={type:"EnumDeclaration",id,body},defs=NODE_FIELDS.EnumDeclaration;return validate(defs.id,node,"id",id,1),validate(defs.body,node,"body",body,1),node},exports.enumDefaultedMember=function(id){const node={type:"EnumDefaultedMember",id},defs=NODE_FIELDS.EnumDefaultedMember;return validate(defs.id,node,"id",id,1),node},exports.enumNumberBody=function(members){const node={type:"EnumNumberBody",members,explicitType:null,hasUnknownMembers:null},defs=NODE_FIELDS.EnumNumberBody;return validate(defs.members,node,"members",members,1),node},exports.enumNumberMember=function(id,init){const node={type:"EnumNumberMember",id,init},defs=NODE_FIELDS.EnumNumberMember;return validate(defs.id,node,"id",id,1),validate(defs.init,node,"init",init,1),node},exports.enumStringBody=function(members){const node={type:"EnumStringBody",members,explicitType:null,hasUnknownMembers:null},defs=NODE_FIELDS.EnumStringBody;return validate(defs.members,node,"members",members,1),node},exports.enumStringMember=function(id,init){const node={type:"EnumStringMember",id,init},defs=NODE_FIELDS.EnumStringMember;return validate(defs.id,node,"id",id,1),validate(defs.init,node,"init",init,1),node},exports.enumSymbolBody=function(members){const node={type:"EnumSymbolBody",members,hasUnknownMembers:null},defs=NODE_FIELDS.EnumSymbolBody;return validate(defs.members,node,"members",members,1),node},exports.existsTypeAnnotation=function(){return {type:"ExistsTypeAnnotation"}},exports.exportAllDeclaration=function(source){const node={type:"ExportAllDeclaration",source},defs=NODE_FIELDS.ExportAllDeclaration;return validate(defs.source,node,"source",source,1),node},exports.exportDefaultDeclaration=function(declaration){const node={type:"ExportDefaultDeclaration",declaration},defs=NODE_FIELDS.ExportDefaultDeclaration;return validate(defs.declaration,node,"declaration",declaration,1),node},exports.exportDefaultSpecifier=function(exported){const node={type:"ExportDefaultSpecifier",exported},defs=NODE_FIELDS.ExportDefaultSpecifier;return validate(defs.exported,node,"exported",exported,1),node},exports.exportNamedDeclaration=function(declaration=null,specifiers=[],source=null){const node={type:"ExportNamedDeclaration",declaration,specifiers,source},defs=NODE_FIELDS.ExportNamedDeclaration;return validate(defs.declaration,node,"declaration",declaration,1),validate(defs.specifiers,node,"specifiers",specifiers,1),validate(defs.source,node,"source",source,1),node},exports.exportNamespaceSpecifier=function(exported){const node={type:"ExportNamespaceSpecifier",exported},defs=NODE_FIELDS.ExportNamespaceSpecifier;return validate(defs.exported,node,"exported",exported,1),node},exports.exportSpecifier=function(local,exported){const node={type:"ExportSpecifier",local,exported},defs=NODE_FIELDS.ExportSpecifier;return validate(defs.local,node,"local",local,1),validate(defs.exported,node,"exported",exported,1),node},exports.expressionStatement=function(expression){const node={type:"ExpressionStatement",expression},defs=NODE_FIELDS.ExpressionStatement;return validate(defs.expression,node,"expression",expression,1),node},exports.file=function(program,comments=null,tokens=null){const node={type:"File",program,comments,tokens},defs=NODE_FIELDS.File;return validate(defs.program,node,"program",program,1),validate(defs.comments,node,"comments",comments,1),validate(defs.tokens,node,"tokens",tokens),node},exports.forInStatement=function(left,right,body){const node={type:"ForInStatement",left,right,body},defs=NODE_FIELDS.ForInStatement;return validate(defs.left,node,"left",left,1),validate(defs.right,node,"right",right,1),validate(defs.body,node,"body",body,1),node},exports.forOfStatement=function(left,right,body,_await=false){const node={type:"ForOfStatement",left,right,body,await:_await},defs=NODE_FIELDS.ForOfStatement;return validate(defs.left,node,"left",left,1),validate(defs.right,node,"right",right,1),validate(defs.body,node,"body",body,1),validate(defs.await,node,"await",_await),node},exports.forStatement=function(init=null,test=null,update=null,body){const node={type:"ForStatement",init,test,update,body},defs=NODE_FIELDS.ForStatement;return validate(defs.init,node,"init",init,1),validate(defs.test,node,"test",test,1),validate(defs.update,node,"update",update,1),validate(defs.body,node,"body",body,1),node},exports.functionDeclaration=function(id=null,params,body,generator=false,async=false){const node={type:"FunctionDeclaration",id,params,body,generator,async},defs=NODE_FIELDS.FunctionDeclaration;return validate(defs.id,node,"id",id,1),validate(defs.params,node,"params",params,1),validate(defs.body,node,"body",body,1),validate(defs.generator,node,"generator",generator),validate(defs.async,node,"async",async),node},exports.functionExpression=function(id=null,params,body,generator=false,async=false){const node={type:"FunctionExpression",id,params,body,generator,async},defs=NODE_FIELDS.FunctionExpression;return validate(defs.id,node,"id",id,1),validate(defs.params,node,"params",params,1),validate(defs.body,node,"body",body,1),validate(defs.generator,node,"generator",generator),validate(defs.async,node,"async",async),node},exports.functionTypeAnnotation=function(typeParameters=null,params,rest=null,returnType){const node={type:"FunctionTypeAnnotation",typeParameters,params,rest,returnType},defs=NODE_FIELDS.FunctionTypeAnnotation;return validate(defs.typeParameters,node,"typeParameters",typeParameters,1),validate(defs.params,node,"params",params,1),validate(defs.rest,node,"rest",rest,1),validate(defs.returnType,node,"returnType",returnType,1),node},exports.functionTypeParam=function(name=null,typeAnnotation){const node={type:"FunctionTypeParam",name,typeAnnotation},defs=NODE_FIELDS.FunctionTypeParam;return validate(defs.name,node,"name",name,1),validate(defs.typeAnnotation,node,"typeAnnotation",typeAnnotation,1),node},exports.genericTypeAnnotation=function(id,typeParameters=null){const node={type:"GenericTypeAnnotation",id,typeParameters},defs=NODE_FIELDS.GenericTypeAnnotation;return validate(defs.id,node,"id",id,1),validate(defs.typeParameters,node,"typeParameters",typeParameters,1),node},exports.identifier=function(name){const node={type:"Identifier",name},defs=NODE_FIELDS.Identifier;return validate(defs.name,node,"name",name),node},exports.ifStatement=function(test,consequent,alternate=null){const node={type:"IfStatement",test,consequent,alternate},defs=NODE_FIELDS.IfStatement;return validate(defs.test,node,"test",test,1),validate(defs.consequent,node,"consequent",consequent,1),validate(defs.alternate,node,"alternate",alternate,1),node},exports.import=function(){return {type:"Import"}},exports.importAttribute=function(key,value){const node={type:"ImportAttribute",key,value},defs=NODE_FIELDS.ImportAttribute;return validate(defs.key,node,"key",key,1),validate(defs.value,node,"value",value,1),node},exports.importDeclaration=function(specifiers,source){const node={type:"ImportDeclaration",specifiers,source},defs=NODE_FIELDS.ImportDeclaration;return validate(defs.specifiers,node,"specifiers",specifiers,1),validate(defs.source,node,"source",source,1),node},exports.importDefaultSpecifier=function(local){const node={type:"ImportDefaultSpecifier",local},defs=NODE_FIELDS.ImportDefaultSpecifier;return validate(defs.local,node,"local",local,1),node},exports.importExpression=function(source,options=null){const node={type:"ImportExpression",source,options},defs=NODE_FIELDS.ImportExpression;return validate(defs.source,node,"source",source,1),validate(defs.options,node,"options",options,1),node},exports.importNamespaceSpecifier=function(local){const node={type:"ImportNamespaceSpecifier",local},defs=NODE_FIELDS.ImportNamespaceSpecifier;return validate(defs.local,node,"local",local,1),node},exports.importSpecifier=function(local,imported){const node={type:"ImportSpecifier",local,imported},defs=NODE_FIELDS.ImportSpecifier;return validate(defs.local,node,"local",local,1),validate(defs.imported,node,"imported",imported,1),node},exports.indexedAccessType=function(objectType,indexType){const node={type:"IndexedAccessType",objectType,indexType},defs=NODE_FIELDS.IndexedAccessType;return validate(defs.objectType,node,"objectType",objectType,1),validate(defs.indexType,node,"indexType",indexType,1),node},exports.inferredPredicate=function(){return {type:"InferredPredicate"}},exports.interfaceDeclaration=function(id,typeParameters=null,_extends=null,body){const node={type:"InterfaceDeclaration",id,typeParameters,extends:_extends,body},defs=NODE_FIELDS.InterfaceDeclaration;return validate(defs.id,node,"id",id,1),validate(defs.typeParameters,node,"typeParameters",typeParameters,1),validate(defs.extends,node,"extends",_extends,1),validate(defs.body,node,"body",body,1),node},exports.interfaceExtends=function(id,typeParameters=null){const node={type:"InterfaceExtends",id,typeParameters},defs=NODE_FIELDS.InterfaceExtends;return validate(defs.id,node,"id",id,1),validate(defs.typeParameters,node,"typeParameters",typeParameters,1),node},exports.interfaceTypeAnnotation=function(_extends=null,body){const node={type:"InterfaceTypeAnnotation",extends:_extends,body},defs=NODE_FIELDS.InterfaceTypeAnnotation;return validate(defs.extends,node,"extends",_extends,1),validate(defs.body,node,"body",body,1),node},exports.interpreterDirective=function(value){const node={type:"InterpreterDirective",value},defs=NODE_FIELDS.InterpreterDirective;return validate(defs.value,node,"value",value),node},exports.intersectionTypeAnnotation=function(types){const node={type:"IntersectionTypeAnnotation",types},defs=NODE_FIELDS.IntersectionTypeAnnotation;return validate(defs.types,node,"types",types,1),node},exports.jSXAttribute=exports.jsxAttribute=function(name,value=null){const node={type:"JSXAttribute",name,value},defs=NODE_FIELDS.JSXAttribute;return validate(defs.name,node,"name",name,1),validate(defs.value,node,"value",value,1),node},exports.jSXClosingElement=exports.jsxClosingElement=function(name){const node={type:"JSXClosingElement",name},defs=NODE_FIELDS.JSXClosingElement;return validate(defs.name,node,"name",name,1),node},exports.jSXClosingFragment=exports.jsxClosingFragment=function(){return {type:"JSXClosingFragment"}},exports.jSXElement=exports.jsxElement=function(openingElement,closingElement=null,children,selfClosing=null){const node={type:"JSXElement",openingElement,closingElement,children,selfClosing},defs=NODE_FIELDS.JSXElement;return validate(defs.openingElement,node,"openingElement",openingElement,1),validate(defs.closingElement,node,"closingElement",closingElement,1),validate(defs.children,node,"children",children,1),validate(defs.selfClosing,node,"selfClosing",selfClosing),node},exports.jSXEmptyExpression=exports.jsxEmptyExpression=function(){return {type:"JSXEmptyExpression"}},exports.jSXExpressionContainer=exports.jsxExpressionContainer=function(expression){const node={type:"JSXExpressionContainer",expression},defs=NODE_FIELDS.JSXExpressionContainer;return validate(defs.expression,node,"expression",expression,1),node},exports.jSXFragment=exports.jsxFragment=function(openingFragment,closingFragment,children){const node={type:"JSXFragment",openingFragment,closingFragment,children},defs=NODE_FIELDS.JSXFragment;return validate(defs.openingFragment,node,"openingFragment",openingFragment,1),validate(defs.closingFragment,node,"closingFragment",closingFragment,1),validate(defs.children,node,"children",children,1),node},exports.jSXIdentifier=exports.jsxIdentifier=function(name){const node={type:"JSXIdentifier",name},defs=NODE_FIELDS.JSXIdentifier;return validate(defs.name,node,"name",name),node},exports.jSXMemberExpression=exports.jsxMemberExpression=function(object,property){const node={type:"JSXMemberExpression",object,property},defs=NODE_FIELDS.JSXMemberExpression;return validate(defs.object,node,"object",object,1),validate(defs.property,node,"property",property,1),node},exports.jSXNamespacedName=exports.jsxNamespacedName=function(namespace,name){const node={type:"JSXNamespacedName",namespace,name},defs=NODE_FIELDS.JSXNamespacedName;return validate(defs.namespace,node,"namespace",namespace,1),validate(defs.name,node,"name",name,1),node},exports.jSXOpeningElement=exports.jsxOpeningElement=function(name,attributes,selfClosing=false){const node={type:"JSXOpeningElement",name,attributes,selfClosing},defs=NODE_FIELDS.JSXOpeningElement;return validate(defs.name,node,"name",name,1),validate(defs.attributes,node,"attributes",attributes,1),validate(defs.selfClosing,node,"selfClosing",selfClosing),node},exports.jSXOpeningFragment=exports.jsxOpeningFragment=function(){return {type:"JSXOpeningFragment"}},exports.jSXSpreadAttribute=exports.jsxSpreadAttribute=function(argument){const node={type:"JSXSpreadAttribute",argument},defs=NODE_FIELDS.JSXSpreadAttribute;return validate(defs.argument,node,"argument",argument,1),node},exports.jSXSpreadChild=exports.jsxSpreadChild=function(expression){const node={type:"JSXSpreadChild",expression},defs=NODE_FIELDS.JSXSpreadChild;return validate(defs.expression,node,"expression",expression,1),node},exports.jSXText=exports.jsxText=function(value){const node={type:"JSXText",value},defs=NODE_FIELDS.JSXText;return validate(defs.value,node,"value",value),node},exports.labeledStatement=function(label,body){const node={type:"LabeledStatement",label,body},defs=NODE_FIELDS.LabeledStatement;return validate(defs.label,node,"label",label,1),validate(defs.body,node,"body",body,1),node},exports.logicalExpression=function(operator,left,right){const node={type:"LogicalExpression",operator,left,right},defs=NODE_FIELDS.LogicalExpression;return validate(defs.operator,node,"operator",operator),validate(defs.left,node,"left",left,1),validate(defs.right,node,"right",right,1),node},exports.memberExpression=function(object,property,computed=false,optional=null){const node={type:"MemberExpression",object,property,computed,optional},defs=NODE_FIELDS.MemberExpression;return validate(defs.object,node,"object",object,1),validate(defs.property,node,"property",property,1),validate(defs.computed,node,"computed",computed),validate(defs.optional,node,"optional",optional),node},exports.metaProperty=function(meta,property){const node={type:"MetaProperty",meta,property},defs=NODE_FIELDS.MetaProperty;return validate(defs.meta,node,"meta",meta,1),validate(defs.property,node,"property",property,1),node},exports.mixedTypeAnnotation=function(){return {type:"MixedTypeAnnotation"}},exports.moduleExpression=function(body){const node={type:"ModuleExpression",body},defs=NODE_FIELDS.ModuleExpression;return validate(defs.body,node,"body",body,1),node},exports.newExpression=function(callee,_arguments){const node={type:"NewExpression",callee,arguments:_arguments},defs=NODE_FIELDS.NewExpression;return validate(defs.callee,node,"callee",callee,1),validate(defs.arguments,node,"arguments",_arguments,1),node},exports.noop=function(){return {type:"Noop"}},exports.nullLiteral=function(){return {type:"NullLiteral"}},exports.nullLiteralTypeAnnotation=function(){return {type:"NullLiteralTypeAnnotation"}},exports.nullableTypeAnnotation=function(typeAnnotation){const node={type:"NullableTypeAnnotation",typeAnnotation},defs=NODE_FIELDS.NullableTypeAnnotation;return validate(defs.typeAnnotation,node,"typeAnnotation",typeAnnotation,1),node},exports.numberLiteral=function(value){return (0, _deprecationWarning.default)("NumberLiteral","NumericLiteral","The node type "),numericLiteral(value)},exports.numberLiteralTypeAnnotation=function(value){const node={type:"NumberLiteralTypeAnnotation",value},defs=NODE_FIELDS.NumberLiteralTypeAnnotation;return validate(defs.value,node,"value",value),node},exports.numberTypeAnnotation=function(){return {type:"NumberTypeAnnotation"}},exports.numericLiteral=numericLiteral,exports.objectExpression=function(properties){const node={type:"ObjectExpression",properties},defs=NODE_FIELDS.ObjectExpression;return validate(defs.properties,node,"properties",properties,1),node},exports.objectMethod=function(kind="method",key,params,body,computed=false,generator=false,async=false){const node={type:"ObjectMethod",kind,key,params,body,computed,generator,async},defs=NODE_FIELDS.ObjectMethod;return validate(defs.kind,node,"kind",kind),validate(defs.key,node,"key",key,1),validate(defs.params,node,"params",params,1),validate(defs.body,node,"body",body,1),validate(defs.computed,node,"computed",computed),validate(defs.generator,node,"generator",generator),validate(defs.async,node,"async",async),node},exports.objectPattern=function(properties){const node={type:"ObjectPattern",properties},defs=NODE_FIELDS.ObjectPattern;return validate(defs.properties,node,"properties",properties,1),node},exports.objectProperty=function(key,value,computed=false,shorthand=false,decorators=null){const node={type:"ObjectProperty",key,value,computed,shorthand,decorators},defs=NODE_FIELDS.ObjectProperty;return validate(defs.key,node,"key",key,1),validate(defs.value,node,"value",value,1),validate(defs.computed,node,"computed",computed),validate(defs.shorthand,node,"shorthand",shorthand),validate(defs.decorators,node,"decorators",decorators,1),node},exports.objectTypeAnnotation=function(properties,indexers=[],callProperties=[],internalSlots=[],exact=false){const node={type:"ObjectTypeAnnotation",properties,indexers,callProperties,internalSlots,exact},defs=NODE_FIELDS.ObjectTypeAnnotation;return validate(defs.properties,node,"properties",properties,1),validate(defs.indexers,node,"indexers",indexers,1),validate(defs.callProperties,node,"callProperties",callProperties,1),validate(defs.internalSlots,node,"internalSlots",internalSlots,1),validate(defs.exact,node,"exact",exact),node},exports.objectTypeCallProperty=function(value){const node={type:"ObjectTypeCallProperty",value,static:null},defs=NODE_FIELDS.ObjectTypeCallProperty;return validate(defs.value,node,"value",value,1),node},exports.objectTypeIndexer=function(id=null,key,value,variance=null){const node={type:"ObjectTypeIndexer",id,key,value,variance,static:null},defs=NODE_FIELDS.ObjectTypeIndexer;return validate(defs.id,node,"id",id,1),validate(defs.key,node,"key",key,1),validate(defs.value,node,"value",value,1),validate(defs.variance,node,"variance",variance,1),node},exports.objectTypeInternalSlot=function(id,value,optional,_static,method){const node={type:"ObjectTypeInternalSlot",id,value,optional,static:_static,method},defs=NODE_FIELDS.ObjectTypeInternalSlot;return validate(defs.id,node,"id",id,1),validate(defs.value,node,"value",value,1),validate(defs.optional,node,"optional",optional),validate(defs.static,node,"static",_static),validate(defs.method,node,"method",method),node},exports.objectTypeProperty=function(key,value,variance=null){const node={type:"ObjectTypeProperty",key,value,variance,kind:null,method:null,optional:null,proto:null,static:null},defs=NODE_FIELDS.ObjectTypeProperty;return validate(defs.key,node,"key",key,1),validate(defs.value,node,"value",value,1),validate(defs.variance,node,"variance",variance,1),node},exports.objectTypeSpreadProperty=function(argument){const node={type:"ObjectTypeSpreadProperty",argument},defs=NODE_FIELDS.ObjectTypeSpreadProperty;return validate(defs.argument,node,"argument",argument,1),node},exports.opaqueType=function(id,typeParameters=null,supertype=null,impltype){const node={type:"OpaqueType",id,typeParameters,supertype,impltype},defs=NODE_FIELDS.OpaqueType;return validate(defs.id,node,"id",id,1),validate(defs.typeParameters,node,"typeParameters",typeParameters,1),validate(defs.supertype,node,"supertype",supertype,1),validate(defs.impltype,node,"impltype",impltype,1),node},exports.optionalCallExpression=function(callee,_arguments,optional){const node={type:"OptionalCallExpression",callee,arguments:_arguments,optional},defs=NODE_FIELDS.OptionalCallExpression;return validate(defs.callee,node,"callee",callee,1),validate(defs.arguments,node,"arguments",_arguments,1),validate(defs.optional,node,"optional",optional),node},exports.optionalIndexedAccessType=function(objectType,indexType){const node={type:"OptionalIndexedAccessType",objectType,indexType,optional:null},defs=NODE_FIELDS.OptionalIndexedAccessType;return validate(defs.objectType,node,"objectType",objectType,1),validate(defs.indexType,node,"indexType",indexType,1),node},exports.optionalMemberExpression=function(object,property,computed=false,optional){const node={type:"OptionalMemberExpression",object,property,computed,optional},defs=NODE_FIELDS.OptionalMemberExpression;return validate(defs.object,node,"object",object,1),validate(defs.property,node,"property",property,1),validate(defs.computed,node,"computed",computed),validate(defs.optional,node,"optional",optional),node},exports.parenthesizedExpression=function(expression){const node={type:"ParenthesizedExpression",expression},defs=NODE_FIELDS.ParenthesizedExpression;return validate(defs.expression,node,"expression",expression,1),node},exports.pipelineBareFunction=function(callee){const node={type:"PipelineBareFunction",callee},defs=NODE_FIELDS.PipelineBareFunction;return validate(defs.callee,node,"callee",callee,1),node},exports.pipelinePrimaryTopicReference=function(){return {type:"PipelinePrimaryTopicReference"}},exports.pipelineTopicExpression=function(expression){const node={type:"PipelineTopicExpression",expression},defs=NODE_FIELDS.PipelineTopicExpression;return validate(defs.expression,node,"expression",expression,1),node},exports.placeholder=function(expectedNode,name){const node={type:"Placeholder",expectedNode,name},defs=NODE_FIELDS.Placeholder;return validate(defs.expectedNode,node,"expectedNode",expectedNode),validate(defs.name,node,"name",name,1),node},exports.privateName=function(id){const node={type:"PrivateName",id},defs=NODE_FIELDS.PrivateName;return validate(defs.id,node,"id",id,1),node},exports.program=function(body,directives=[],sourceType="script",interpreter=null){const node={type:"Program",body,directives,sourceType,interpreter},defs=NODE_FIELDS.Program;return validate(defs.body,node,"body",body,1),validate(defs.directives,node,"directives",directives,1),validate(defs.sourceType,node,"sourceType",sourceType),validate(defs.interpreter,node,"interpreter",interpreter,1),node},exports.qualifiedTypeIdentifier=function(id,qualification){const node={type:"QualifiedTypeIdentifier",id,qualification},defs=NODE_FIELDS.QualifiedTypeIdentifier;return validate(defs.id,node,"id",id,1),validate(defs.qualification,node,"qualification",qualification,1),node},exports.recordExpression=function(properties){const node={type:"RecordExpression",properties},defs=NODE_FIELDS.RecordExpression;return validate(defs.properties,node,"properties",properties,1),node},exports.regExpLiteral=regExpLiteral,exports.regexLiteral=function(pattern,flags=""){return (0, _deprecationWarning.default)("RegexLiteral","RegExpLiteral","The node type "),regExpLiteral(pattern,flags)},exports.restElement=restElement,exports.restProperty=function(argument){return (0, _deprecationWarning.default)("RestProperty","RestElement","The node type "),restElement(argument)},exports.returnStatement=function(argument=null){const node={type:"ReturnStatement",argument},defs=NODE_FIELDS.ReturnStatement;return validate(defs.argument,node,"argument",argument,1),node},exports.sequenceExpression=function(expressions){const node={type:"SequenceExpression",expressions},defs=NODE_FIELDS.SequenceExpression;return validate(defs.expressions,node,"expressions",expressions,1),node},exports.spreadElement=spreadElement,exports.spreadProperty=function(argument){return (0, _deprecationWarning.default)("SpreadProperty","SpreadElement","The node type "),spreadElement(argument)},exports.staticBlock=function(body){const node={type:"StaticBlock",body},defs=NODE_FIELDS.StaticBlock;return validate(defs.body,node,"body",body,1),node},exports.stringLiteral=function(value){const node={type:"StringLiteral",value},defs=NODE_FIELDS.StringLiteral;return validate(defs.value,node,"value",value),node},exports.stringLiteralTypeAnnotation=function(value){const node={type:"StringLiteralTypeAnnotation",value},defs=NODE_FIELDS.StringLiteralTypeAnnotation;return validate(defs.value,node,"value",value),node},exports.stringTypeAnnotation=function(){return {type:"StringTypeAnnotation"}},exports.super=function(){return {type:"Super"}},exports.switchCase=function(test=null,consequent){const node={type:"SwitchCase",test,consequent},defs=NODE_FIELDS.SwitchCase;return validate(defs.test,node,"test",test,1),validate(defs.consequent,node,"consequent",consequent,1),node},exports.switchStatement=function(discriminant,cases){const node={type:"SwitchStatement",discriminant,cases},defs=NODE_FIELDS.SwitchStatement;return validate(defs.discriminant,node,"discriminant",discriminant,1),validate(defs.cases,node,"cases",cases,1),node},exports.symbolTypeAnnotation=function(){return {type:"SymbolTypeAnnotation"}},exports.taggedTemplateExpression=function(tag,quasi){const node={type:"TaggedTemplateExpression",tag,quasi},defs=NODE_FIELDS.TaggedTemplateExpression;return validate(defs.tag,node,"tag",tag,1),validate(defs.quasi,node,"quasi",quasi,1),node},exports.templateElement=function(value,tail=false){const node={type:"TemplateElement",value,tail},defs=NODE_FIELDS.TemplateElement;return validate(defs.value,node,"value",value),validate(defs.tail,node,"tail",tail),node},exports.templateLiteral=function(quasis,expressions){const node={type:"TemplateLiteral",quasis,expressions},defs=NODE_FIELDS.TemplateLiteral;return validate(defs.quasis,node,"quasis",quasis,1),validate(defs.expressions,node,"expressions",expressions,1),node},exports.thisExpression=function(){return {type:"ThisExpression"}},exports.thisTypeAnnotation=function(){return {type:"ThisTypeAnnotation"}},exports.throwStatement=function(argument){const node={type:"ThrowStatement",argument},defs=NODE_FIELDS.ThrowStatement;return validate(defs.argument,node,"argument",argument,1),node},exports.topicReference=function(){return {type:"TopicReference"}},exports.tryStatement=function(block,handler=null,finalizer=null){const node={type:"TryStatement",block,handler,finalizer},defs=NODE_FIELDS.TryStatement;return validate(defs.block,node,"block",block,1),validate(defs.handler,node,"handler",handler,1),validate(defs.finalizer,node,"finalizer",finalizer,1),node},exports.tSAnyKeyword=exports.tsAnyKeyword=function(){return {type:"TSAnyKeyword"}},exports.tSArrayType=exports.tsArrayType=function(elementType){const node={type:"TSArrayType",elementType},defs=NODE_FIELDS.TSArrayType;return validate(defs.elementType,node,"elementType",elementType,1),node},exports.tSAsExpression=exports.tsAsExpression=function(expression,typeAnnotation){const node={type:"TSAsExpression",expression,typeAnnotation},defs=NODE_FIELDS.TSAsExpression;return validate(defs.expression,node,"expression",expression,1),validate(defs.typeAnnotation,node,"typeAnnotation",typeAnnotation,1),node},exports.tSBigIntKeyword=exports.tsBigIntKeyword=function(){return {type:"TSBigIntKeyword"}},exports.tSBooleanKeyword=exports.tsBooleanKeyword=function(){return {type:"TSBooleanKeyword"}},exports.tSCallSignatureDeclaration=exports.tsCallSignatureDeclaration=function(typeParameters=null,parameters,typeAnnotation=null){const node={type:"TSCallSignatureDeclaration",typeParameters,parameters,typeAnnotation},defs=NODE_FIELDS.TSCallSignatureDeclaration;return validate(defs.typeParameters,node,"typeParameters",typeParameters,1),validate(defs.parameters,node,"parameters",parameters,1),validate(defs.typeAnnotation,node,"typeAnnotation",typeAnnotation,1),node},exports.tSConditionalType=exports.tsConditionalType=function(checkType,extendsType,trueType,falseType){const node={type:"TSConditionalType",checkType,extendsType,trueType,falseType},defs=NODE_FIELDS.TSConditionalType;return validate(defs.checkType,node,"checkType",checkType,1),validate(defs.extendsType,node,"extendsType",extendsType,1),validate(defs.trueType,node,"trueType",trueType,1),validate(defs.falseType,node,"falseType",falseType,1),node},exports.tSConstructSignatureDeclaration=exports.tsConstructSignatureDeclaration=function(typeParameters=null,parameters,typeAnnotation=null){const node={type:"TSConstructSignatureDeclaration",typeParameters,parameters,typeAnnotation},defs=NODE_FIELDS.TSConstructSignatureDeclaration;return validate(defs.typeParameters,node,"typeParameters",typeParameters,1),validate(defs.parameters,node,"parameters",parameters,1),validate(defs.typeAnnotation,node,"typeAnnotation",typeAnnotation,1),node},exports.tSConstructorType=exports.tsConstructorType=function(typeParameters=null,parameters,typeAnnotation=null){const node={type:"TSConstructorType",typeParameters,parameters,typeAnnotation},defs=NODE_FIELDS.TSConstructorType;return validate(defs.typeParameters,node,"typeParameters",typeParameters,1),validate(defs.parameters,node,"parameters",parameters,1),validate(defs.typeAnnotation,node,"typeAnnotation",typeAnnotation,1),node},exports.tSDeclareFunction=exports.tsDeclareFunction=function(id=null,typeParameters=null,params,returnType=null){const node={type:"TSDeclareFunction",id,typeParameters,params,returnType},defs=NODE_FIELDS.TSDeclareFunction;return validate(defs.id,node,"id",id,1),validate(defs.typeParameters,node,"typeParameters",typeParameters,1),validate(defs.params,node,"params",params,1),validate(defs.returnType,node,"returnType",returnType,1),node},exports.tSDeclareMethod=exports.tsDeclareMethod=function(decorators=null,key,typeParameters=null,params,returnType=null){const node={type:"TSDeclareMethod",decorators,key,typeParameters,params,returnType},defs=NODE_FIELDS.TSDeclareMethod;return validate(defs.decorators,node,"decorators",decorators,1),validate(defs.key,node,"key",key,1),validate(defs.typeParameters,node,"typeParameters",typeParameters,1),validate(defs.params,node,"params",params,1),validate(defs.returnType,node,"returnType",returnType,1),node},exports.tSEnumDeclaration=exports.tsEnumDeclaration=function(id,members){const node={type:"TSEnumDeclaration",id,members},defs=NODE_FIELDS.TSEnumDeclaration;return validate(defs.id,node,"id",id,1),validate(defs.members,node,"members",members,1),node},exports.tSEnumMember=exports.tsEnumMember=function(id,initializer=null){const node={type:"TSEnumMember",id,initializer},defs=NODE_FIELDS.TSEnumMember;return validate(defs.id,node,"id",id,1),validate(defs.initializer,node,"initializer",initializer,1),node},exports.tSExportAssignment=exports.tsExportAssignment=function(expression){const node={type:"TSExportAssignment",expression},defs=NODE_FIELDS.TSExportAssignment;return validate(defs.expression,node,"expression",expression,1),node},exports.tSExpressionWithTypeArguments=exports.tsExpressionWithTypeArguments=function(expression,typeParameters=null){const node={type:"TSExpressionWithTypeArguments",expression,typeParameters},defs=NODE_FIELDS.TSExpressionWithTypeArguments;return validate(defs.expression,node,"expression",expression,1),validate(defs.typeParameters,node,"typeParameters",typeParameters,1),node},exports.tSExternalModuleReference=exports.tsExternalModuleReference=function(expression){const node={type:"TSExternalModuleReference",expression},defs=NODE_FIELDS.TSExternalModuleReference;return validate(defs.expression,node,"expression",expression,1),node},exports.tSFunctionType=exports.tsFunctionType=function(typeParameters=null,parameters,typeAnnotation=null){const node={type:"TSFunctionType",typeParameters,parameters,typeAnnotation},defs=NODE_FIELDS.TSFunctionType;return validate(defs.typeParameters,node,"typeParameters",typeParameters,1),validate(defs.parameters,node,"parameters",parameters,1),validate(defs.typeAnnotation,node,"typeAnnotation",typeAnnotation,1),node},exports.tSImportEqualsDeclaration=exports.tsImportEqualsDeclaration=function(id,moduleReference){const node={type:"TSImportEqualsDeclaration",id,moduleReference,isExport:null},defs=NODE_FIELDS.TSImportEqualsDeclaration;return validate(defs.id,node,"id",id,1),validate(defs.moduleReference,node,"moduleReference",moduleReference,1),node},exports.tSImportType=exports.tsImportType=function(argument,qualifier=null,typeParameters=null){const node={type:"TSImportType",argument,qualifier,typeParameters},defs=NODE_FIELDS.TSImportType;return validate(defs.argument,node,"argument",argument,1),validate(defs.qualifier,node,"qualifier",qualifier,1),validate(defs.typeParameters,node,"typeParameters",typeParameters,1),node},exports.tSIndexSignature=exports.tsIndexSignature=function(parameters,typeAnnotation=null){const node={type:"TSIndexSignature",parameters,typeAnnotation},defs=NODE_FIELDS.TSIndexSignature;return validate(defs.parameters,node,"parameters",parameters,1),validate(defs.typeAnnotation,node,"typeAnnotation",typeAnnotation,1),node},exports.tSIndexedAccessType=exports.tsIndexedAccessType=function(objectType,indexType){const node={type:"TSIndexedAccessType",objectType,indexType},defs=NODE_FIELDS.TSIndexedAccessType;return validate(defs.objectType,node,"objectType",objectType,1),validate(defs.indexType,node,"indexType",indexType,1),node},exports.tSInferType=exports.tsInferType=function(typeParameter){const node={type:"TSInferType",typeParameter},defs=NODE_FIELDS.TSInferType;return validate(defs.typeParameter,node,"typeParameter",typeParameter,1),node},exports.tSInstantiationExpression=exports.tsInstantiationExpression=function(expression,typeParameters=null){const node={type:"TSInstantiationExpression",expression,typeParameters},defs=NODE_FIELDS.TSInstantiationExpression;return validate(defs.expression,node,"expression",expression,1),validate(defs.typeParameters,node,"typeParameters",typeParameters,1),node},exports.tSInterfaceBody=exports.tsInterfaceBody=function(body){const node={type:"TSInterfaceBody",body},defs=NODE_FIELDS.TSInterfaceBody;return validate(defs.body,node,"body",body,1),node},exports.tSInterfaceDeclaration=exports.tsInterfaceDeclaration=function(id,typeParameters=null,_extends=null,body){const node={type:"TSInterfaceDeclaration",id,typeParameters,extends:_extends,body},defs=NODE_FIELDS.TSInterfaceDeclaration;return validate(defs.id,node,"id",id,1),validate(defs.typeParameters,node,"typeParameters",typeParameters,1),validate(defs.extends,node,"extends",_extends,1),validate(defs.body,node,"body",body,1),node},exports.tSIntersectionType=exports.tsIntersectionType=function(types){const node={type:"TSIntersectionType",types},defs=NODE_FIELDS.TSIntersectionType;return validate(defs.types,node,"types",types,1),node},exports.tSIntrinsicKeyword=exports.tsIntrinsicKeyword=function(){return {type:"TSIntrinsicKeyword"}},exports.tSLiteralType=exports.tsLiteralType=function(literal){const node={type:"TSLiteralType",literal},defs=NODE_FIELDS.TSLiteralType;return validate(defs.literal,node,"literal",literal,1),node},exports.tSMappedType=exports.tsMappedType=function(typeParameter,typeAnnotation=null,nameType=null){const node={type:"TSMappedType",typeParameter,typeAnnotation,nameType},defs=NODE_FIELDS.TSMappedType;return validate(defs.typeParameter,node,"typeParameter",typeParameter,1),validate(defs.typeAnnotation,node,"typeAnnotation",typeAnnotation,1),validate(defs.nameType,node,"nameType",nameType,1),node},exports.tSMethodSignature=exports.tsMethodSignature=function(key,typeParameters=null,parameters,typeAnnotation=null){const node={type:"TSMethodSignature",key,typeParameters,parameters,typeAnnotation,kind:null},defs=NODE_FIELDS.TSMethodSignature;return validate(defs.key,node,"key",key,1),validate(defs.typeParameters,node,"typeParameters",typeParameters,1),validate(defs.parameters,node,"parameters",parameters,1),validate(defs.typeAnnotation,node,"typeAnnotation",typeAnnotation,1),node},exports.tSModuleBlock=exports.tsModuleBlock=function(body){const node={type:"TSModuleBlock",body},defs=NODE_FIELDS.TSModuleBlock;return validate(defs.body,node,"body",body,1),node},exports.tSModuleDeclaration=exports.tsModuleDeclaration=function(id,body){const node={type:"TSModuleDeclaration",id,body,kind:null},defs=NODE_FIELDS.TSModuleDeclaration;return validate(defs.id,node,"id",id,1),validate(defs.body,node,"body",body,1),node},exports.tSNamedTupleMember=exports.tsNamedTupleMember=function(label,elementType,optional=false){const node={type:"TSNamedTupleMember",label,elementType,optional},defs=NODE_FIELDS.TSNamedTupleMember;return validate(defs.label,node,"label",label,1),validate(defs.elementType,node,"elementType",elementType,1),validate(defs.optional,node,"optional",optional),node},exports.tSNamespaceExportDeclaration=exports.tsNamespaceExportDeclaration=function(id){const node={type:"TSNamespaceExportDeclaration",id},defs=NODE_FIELDS.TSNamespaceExportDeclaration;return validate(defs.id,node,"id",id,1),node},exports.tSNeverKeyword=exports.tsNeverKeyword=function(){return {type:"TSNeverKeyword"}},exports.tSNonNullExpression=exports.tsNonNullExpression=function(expression){const node={type:"TSNonNullExpression",expression},defs=NODE_FIELDS.TSNonNullExpression;return validate(defs.expression,node,"expression",expression,1),node},exports.tSNullKeyword=exports.tsNullKeyword=function(){return {type:"TSNullKeyword"}},exports.tSNumberKeyword=exports.tsNumberKeyword=function(){return {type:"TSNumberKeyword"}},exports.tSObjectKeyword=exports.tsObjectKeyword=function(){return {type:"TSObjectKeyword"}},exports.tSOptionalType=exports.tsOptionalType=function(typeAnnotation){const node={type:"TSOptionalType",typeAnnotation},defs=NODE_FIELDS.TSOptionalType;return validate(defs.typeAnnotation,node,"typeAnnotation",typeAnnotation,1),node},exports.tSParameterProperty=exports.tsParameterProperty=function(parameter){const node={type:"TSParameterProperty",parameter},defs=NODE_FIELDS.TSParameterProperty;return validate(defs.parameter,node,"parameter",parameter,1),node},exports.tSParenthesizedType=exports.tsParenthesizedType=function(typeAnnotation){const node={type:"TSParenthesizedType",typeAnnotation},defs=NODE_FIELDS.TSParenthesizedType;return validate(defs.typeAnnotation,node,"typeAnnotation",typeAnnotation,1),node},exports.tSPropertySignature=exports.tsPropertySignature=function(key,typeAnnotation=null){const node={type:"TSPropertySignature",key,typeAnnotation,kind:null},defs=NODE_FIELDS.TSPropertySignature;return validate(defs.key,node,"key",key,1),validate(defs.typeAnnotation,node,"typeAnnotation",typeAnnotation,1),node},exports.tSQualifiedName=exports.tsQualifiedName=function(left,right){const node={type:"TSQualifiedName",left,right},defs=NODE_FIELDS.TSQualifiedName;return validate(defs.left,node,"left",left,1),validate(defs.right,node,"right",right,1),node},exports.tSRestType=exports.tsRestType=function(typeAnnotation){const node={type:"TSRestType",typeAnnotation},defs=NODE_FIELDS.TSRestType;return validate(defs.typeAnnotation,node,"typeAnnotation",typeAnnotation,1),node},exports.tSSatisfiesExpression=exports.tsSatisfiesExpression=function(expression,typeAnnotation){const node={type:"TSSatisfiesExpression",expression,typeAnnotation},defs=NODE_FIELDS.TSSatisfiesExpression;return validate(defs.expression,node,"expression",expression,1),validate(defs.typeAnnotation,node,"typeAnnotation",typeAnnotation,1),node},exports.tSStringKeyword=exports.tsStringKeyword=function(){return {type:"TSStringKeyword"}},exports.tSSymbolKeyword=exports.tsSymbolKeyword=function(){return {type:"TSSymbolKeyword"}},exports.tSThisType=exports.tsThisType=function(){return {type:"TSThisType"}},exports.tSTupleType=exports.tsTupleType=function(elementTypes){const node={type:"TSTupleType",elementTypes},defs=NODE_FIELDS.TSTupleType;return validate(defs.elementTypes,node,"elementTypes",elementTypes,1),node},exports.tSTypeAliasDeclaration=exports.tsTypeAliasDeclaration=function(id,typeParameters=null,typeAnnotation){const node={type:"TSTypeAliasDeclaration",id,typeParameters,typeAnnotation},defs=NODE_FIELDS.TSTypeAliasDeclaration;return validate(defs.id,node,"id",id,1),validate(defs.typeParameters,node,"typeParameters",typeParameters,1),validate(defs.typeAnnotation,node,"typeAnnotation",typeAnnotation,1),node},exports.tSTypeAnnotation=exports.tsTypeAnnotation=function(typeAnnotation){const node={type:"TSTypeAnnotation",typeAnnotation},defs=NODE_FIELDS.TSTypeAnnotation;return validate(defs.typeAnnotation,node,"typeAnnotation",typeAnnotation,1),node},exports.tSTypeAssertion=exports.tsTypeAssertion=function(typeAnnotation,expression){const node={type:"TSTypeAssertion",typeAnnotation,expression},defs=NODE_FIELDS.TSTypeAssertion;return validate(defs.typeAnnotation,node,"typeAnnotation",typeAnnotation,1),validate(defs.expression,node,"expression",expression,1),node},exports.tSTypeLiteral=exports.tsTypeLiteral=function(members){const node={type:"TSTypeLiteral",members},defs=NODE_FIELDS.TSTypeLiteral;return validate(defs.members,node,"members",members,1),node},exports.tSTypeOperator=exports.tsTypeOperator=function(typeAnnotation){const node={type:"TSTypeOperator",typeAnnotation,operator:null},defs=NODE_FIELDS.TSTypeOperator;return validate(defs.typeAnnotation,node,"typeAnnotation",typeAnnotation,1),node},exports.tSTypeParameter=exports.tsTypeParameter=function(constraint=null,_default=null,name){const node={type:"TSTypeParameter",constraint,default:_default,name},defs=NODE_FIELDS.TSTypeParameter;return validate(defs.constraint,node,"constraint",constraint,1),validate(defs.default,node,"default",_default,1),validate(defs.name,node,"name",name),node},exports.tSTypeParameterDeclaration=exports.tsTypeParameterDeclaration=function(params){const node={type:"TSTypeParameterDeclaration",params},defs=NODE_FIELDS.TSTypeParameterDeclaration;return validate(defs.params,node,"params",params,1),node},exports.tSTypeParameterInstantiation=exports.tsTypeParameterInstantiation=function(params){const node={type:"TSTypeParameterInstantiation",params},defs=NODE_FIELDS.TSTypeParameterInstantiation;return validate(defs.params,node,"params",params,1),node},exports.tSTypePredicate=exports.tsTypePredicate=function(parameterName,typeAnnotation=null,asserts=null){const node={type:"TSTypePredicate",parameterName,typeAnnotation,asserts},defs=NODE_FIELDS.TSTypePredicate;return validate(defs.parameterName,node,"parameterName",parameterName,1),validate(defs.typeAnnotation,node,"typeAnnotation",typeAnnotation,1),validate(defs.asserts,node,"asserts",asserts),node},exports.tSTypeQuery=exports.tsTypeQuery=function(exprName,typeParameters=null){const node={type:"TSTypeQuery",exprName,typeParameters},defs=NODE_FIELDS.TSTypeQuery;return validate(defs.exprName,node,"exprName",exprName,1),validate(defs.typeParameters,node,"typeParameters",typeParameters,1),node},exports.tSTypeReference=exports.tsTypeReference=function(typeName,typeParameters=null){const node={type:"TSTypeReference",typeName,typeParameters},defs=NODE_FIELDS.TSTypeReference;return validate(defs.typeName,node,"typeName",typeName,1),validate(defs.typeParameters,node,"typeParameters",typeParameters,1),node},exports.tSUndefinedKeyword=exports.tsUndefinedKeyword=function(){return {type:"TSUndefinedKeyword"}},exports.tSUnionType=exports.tsUnionType=function(types){const node={type:"TSUnionType",types},defs=NODE_FIELDS.TSUnionType;return validate(defs.types,node,"types",types,1),node},exports.tSUnknownKeyword=exports.tsUnknownKeyword=function(){return {type:"TSUnknownKeyword"}},exports.tSVoidKeyword=exports.tsVoidKeyword=function(){return {type:"TSVoidKeyword"}},exports.tupleExpression=function(elements=[]){const node={type:"TupleExpression",elements},defs=NODE_FIELDS.TupleExpression;return validate(defs.elements,node,"elements",elements,1),node},exports.tupleTypeAnnotation=function(types){const node={type:"TupleTypeAnnotation",types},defs=NODE_FIELDS.TupleTypeAnnotation;return validate(defs.types,node,"types",types,1),node},exports.typeAlias=function(id,typeParameters=null,right){const node={type:"TypeAlias",id,typeParameters,right},defs=NODE_FIELDS.TypeAlias;return validate(defs.id,node,"id",id,1),validate(defs.typeParameters,node,"typeParameters",typeParameters,1),validate(defs.right,node,"right",right,1),node},exports.typeAnnotation=function(typeAnnotation){const node={type:"TypeAnnotation",typeAnnotation},defs=NODE_FIELDS.TypeAnnotation;return validate(defs.typeAnnotation,node,"typeAnnotation",typeAnnotation,1),node},exports.typeCastExpression=function(expression,typeAnnotation){const node={type:"TypeCastExpression",expression,typeAnnotation},defs=NODE_FIELDS.TypeCastExpression;return validate(defs.expression,node,"expression",expression,1),validate(defs.typeAnnotation,node,"typeAnnotation",typeAnnotation,1),node},exports.typeParameter=function(bound=null,_default=null,variance=null){const node={type:"TypeParameter",bound,default:_default,variance,name:null},defs=NODE_FIELDS.TypeParameter;return validate(defs.bound,node,"bound",bound,1),validate(defs.default,node,"default",_default,1),validate(defs.variance,node,"variance",variance,1),node},exports.typeParameterDeclaration=function(params){const node={type:"TypeParameterDeclaration",params},defs=NODE_FIELDS.TypeParameterDeclaration;return validate(defs.params,node,"params",params,1),node},exports.typeParameterInstantiation=function(params){const node={type:"TypeParameterInstantiation",params},defs=NODE_FIELDS.TypeParameterInstantiation;return validate(defs.params,node,"params",params,1),node},exports.typeofTypeAnnotation=function(argument){const node={type:"TypeofTypeAnnotation",argument},defs=NODE_FIELDS.TypeofTypeAnnotation;return validate(defs.argument,node,"argument",argument,1),node},exports.unaryExpression=function(operator,argument,prefix=true){const node={type:"UnaryExpression",operator,argument,prefix},defs=NODE_FIELDS.UnaryExpression;return validate(defs.operator,node,"operator",operator),validate(defs.argument,node,"argument",argument,1),validate(defs.prefix,node,"prefix",prefix),node},exports.unionTypeAnnotation=function(types){const node={type:"UnionTypeAnnotation",types},defs=NODE_FIELDS.UnionTypeAnnotation;return validate(defs.types,node,"types",types,1),node},exports.updateExpression=function(operator,argument,prefix=false){const node={type:"UpdateExpression",operator,argument,prefix},defs=NODE_FIELDS.UpdateExpression;return validate(defs.operator,node,"operator",operator),validate(defs.argument,node,"argument",argument,1),validate(defs.prefix,node,"prefix",prefix),node},exports.v8IntrinsicIdentifier=function(name){const node={type:"V8IntrinsicIdentifier",name},defs=NODE_FIELDS.V8IntrinsicIdentifier;return validate(defs.name,node,"name",name),node},exports.variableDeclaration=function(kind,declarations){const node={type:"VariableDeclaration",kind,declarations},defs=NODE_FIELDS.VariableDeclaration;return validate(defs.kind,node,"kind",kind),validate(defs.declarations,node,"declarations",declarations,1),node},exports.variableDeclarator=function(id,init=null){const node={type:"VariableDeclarator",id,init},defs=NODE_FIELDS.VariableDeclarator;return validate(defs.id,node,"id",id,1),validate(defs.init,node,"init",init,1),node},exports.variance=function(kind){const node={type:"Variance",kind},defs=NODE_FIELDS.Variance;return validate(defs.kind,node,"kind",kind),node},exports.voidTypeAnnotation=function(){return {type:"VoidTypeAnnotation"}},exports.whileStatement=function(test,body){const node={type:"WhileStatement",test,body},defs=NODE_FIELDS.WhileStatement;return validate(defs.test,node,"test",test,1),validate(defs.body,node,"body",body,1),node},exports.withStatement=function(object,body){const node={type:"WithStatement",object,body},defs=NODE_FIELDS.WithStatement;return validate(defs.object,node,"object",object,1),validate(defs.body,node,"body",body,1),node},exports.yieldExpression=function(argument=null,delegate=false){const node={type:"YieldExpression",argument,delegate},defs=NODE_FIELDS.YieldExpression;return validate(defs.argument,node,"argument",argument,1),validate(defs.delegate,node,"delegate",delegate),node};var _validate=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/validate.js"),_deprecationWarning=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/utils/deprecationWarning.js"),utils=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/utils.js");const{validateInternal:validate}=_validate,{NODE_FIELDS}=utils;function numericLiteral(value){const node={type:"NumericLiteral",value},defs=NODE_FIELDS.NumericLiteral;return validate(defs.value,node,"value",value),node}function regExpLiteral(pattern,flags=""){const node={type:"RegExpLiteral",pattern,flags},defs=NODE_FIELDS.RegExpLiteral;return validate(defs.pattern,node,"pattern",pattern),validate(defs.flags,node,"flags",flags),node}function restElement(argument){const node={type:"RestElement",argument},defs=NODE_FIELDS.RestElement;return validate(defs.argument,node,"argument",argument,1),node}function spreadElement(argument){const node={type:"SpreadElement",argument},defs=NODE_FIELDS.SpreadElement;return validate(defs.argument,node,"argument",argument,1),node}},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/generated/uppercase.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),Object.defineProperty(exports,"AnyTypeAnnotation",{enumerable:true,get:function(){return _index.anyTypeAnnotation}}),Object.defineProperty(exports,"ArgumentPlaceholder",{enumerable:true,get:function(){return _index.argumentPlaceholder}}),Object.defineProperty(exports,"ArrayExpression",{enumerable:true,get:function(){return _index.arrayExpression}}),Object.defineProperty(exports,"ArrayPattern",{enumerable:true,get:function(){return _index.arrayPattern}}),Object.defineProperty(exports,"ArrayTypeAnnotation",{enumerable:true,get:function(){return _index.arrayTypeAnnotation}}),Object.defineProperty(exports,"ArrowFunctionExpression",{enumerable:true,get:function(){return _index.arrowFunctionExpression}}),Object.defineProperty(exports,"AssignmentExpression",{enumerable:true,get:function(){return _index.assignmentExpression}}),Object.defineProperty(exports,"AssignmentPattern",{enumerable:true,get:function(){return _index.assignmentPattern}}),Object.defineProperty(exports,"AwaitExpression",{enumerable:true,get:function(){return _index.awaitExpression}}),Object.defineProperty(exports,"BigIntLiteral",{enumerable:true,get:function(){return _index.bigIntLiteral}}),Object.defineProperty(exports,"BinaryExpression",{enumerable:true,get:function(){return _index.binaryExpression}}),Object.defineProperty(exports,"BindExpression",{enumerable:true,get:function(){return _index.bindExpression}}),Object.defineProperty(exports,"BlockStatement",{enumerable:true,get:function(){return _index.blockStatement}}),Object.defineProperty(exports,"BooleanLiteral",{enumerable:true,get:function(){return _index.booleanLiteral}}),Object.defineProperty(exports,"BooleanLiteralTypeAnnotation",{enumerable:true,get:function(){return _index.booleanLiteralTypeAnnotation}}),Object.defineProperty(exports,"BooleanTypeAnnotation",{enumerable:true,get:function(){return _index.booleanTypeAnnotation}}),Object.defineProperty(exports,"BreakStatement",{enumerable:true,get:function(){return _index.breakStatement}}),Object.defineProperty(exports,"CallExpression",{enumerable:true,get:function(){return _index.callExpression}}),Object.defineProperty(exports,"CatchClause",{enumerable:true,get:function(){return _index.catchClause}}),Object.defineProperty(exports,"ClassAccessorProperty",{enumerable:true,get:function(){return _index.classAccessorProperty}}),Object.defineProperty(exports,"ClassBody",{enumerable:true,get:function(){return _index.classBody}}),Object.defineProperty(exports,"ClassDeclaration",{enumerable:true,get:function(){return _index.classDeclaration}}),Object.defineProperty(exports,"ClassExpression",{enumerable:true,get:function(){return _index.classExpression}}),Object.defineProperty(exports,"ClassImplements",{enumerable:true,get:function(){return _index.classImplements}}),Object.defineProperty(exports,"ClassMethod",{enumerable:true,get:function(){return _index.classMethod}}),Object.defineProperty(exports,"ClassPrivateMethod",{enumerable:true,get:function(){return _index.classPrivateMethod}}),Object.defineProperty(exports,"ClassPrivateProperty",{enumerable:true,get:function(){return _index.classPrivateProperty}}),Object.defineProperty(exports,"ClassProperty",{enumerable:true,get:function(){return _index.classProperty}}),Object.defineProperty(exports,"ConditionalExpression",{enumerable:true,get:function(){return _index.conditionalExpression}}),Object.defineProperty(exports,"ContinueStatement",{enumerable:true,get:function(){return _index.continueStatement}}),Object.defineProperty(exports,"DebuggerStatement",{enumerable:true,get:function(){return _index.debuggerStatement}}),Object.defineProperty(exports,"DecimalLiteral",{enumerable:true,get:function(){return _index.decimalLiteral}}),Object.defineProperty(exports,"DeclareClass",{enumerable:true,get:function(){return _index.declareClass}}),Object.defineProperty(exports,"DeclareExportAllDeclaration",{enumerable:true,get:function(){return _index.declareExportAllDeclaration}}),Object.defineProperty(exports,"DeclareExportDeclaration",{enumerable:true,get:function(){return _index.declareExportDeclaration}}),Object.defineProperty(exports,"DeclareFunction",{enumerable:true,get:function(){return _index.declareFunction}}),Object.defineProperty(exports,"DeclareInterface",{enumerable:true,get:function(){return _index.declareInterface}}),Object.defineProperty(exports,"DeclareModule",{enumerable:true,get:function(){return _index.declareModule}}),Object.defineProperty(exports,"DeclareModuleExports",{enumerable:true,get:function(){return _index.declareModuleExports}}),Object.defineProperty(exports,"DeclareOpaqueType",{enumerable:true,get:function(){return _index.declareOpaqueType}}),Object.defineProperty(exports,"DeclareTypeAlias",{enumerable:true,get:function(){return _index.declareTypeAlias}}),Object.defineProperty(exports,"DeclareVariable",{enumerable:true,get:function(){return _index.declareVariable}}),Object.defineProperty(exports,"DeclaredPredicate",{enumerable:true,get:function(){return _index.declaredPredicate}}),Object.defineProperty(exports,"Decorator",{enumerable:true,get:function(){return _index.decorator}}),Object.defineProperty(exports,"Directive",{enumerable:true,get:function(){return _index.directive}}),Object.defineProperty(exports,"DirectiveLiteral",{enumerable:true,get:function(){return _index.directiveLiteral}}),Object.defineProperty(exports,"DoExpression",{enumerable:true,get:function(){return _index.doExpression}}),Object.defineProperty(exports,"DoWhileStatement",{enumerable:true,get:function(){return _index.doWhileStatement}}),Object.defineProperty(exports,"EmptyStatement",{enumerable:true,get:function(){return _index.emptyStatement}}),Object.defineProperty(exports,"EmptyTypeAnnotation",{enumerable:true,get:function(){return _index.emptyTypeAnnotation}}),Object.defineProperty(exports,"EnumBooleanBody",{enumerable:true,get:function(){return _index.enumBooleanBody}}),Object.defineProperty(exports,"EnumBooleanMember",{enumerable:true,get:function(){return _index.enumBooleanMember}}),Object.defineProperty(exports,"EnumDeclaration",{enumerable:true,get:function(){return _index.enumDeclaration}}),Object.defineProperty(exports,"EnumDefaultedMember",{enumerable:true,get:function(){return _index.enumDefaultedMember}}),Object.defineProperty(exports,"EnumNumberBody",{enumerable:true,get:function(){return _index.enumNumberBody}}),Object.defineProperty(exports,"EnumNumberMember",{enumerable:true,get:function(){return _index.enumNumberMember}}),Object.defineProperty(exports,"EnumStringBody",{enumerable:true,get:function(){return _index.enumStringBody}}),Object.defineProperty(exports,"EnumStringMember",{enumerable:true,get:function(){return _index.enumStringMember}}),Object.defineProperty(exports,"EnumSymbolBody",{enumerable:true,get:function(){return _index.enumSymbolBody}}),Object.defineProperty(exports,"ExistsTypeAnnotation",{enumerable:true,get:function(){return _index.existsTypeAnnotation}}),Object.defineProperty(exports,"ExportAllDeclaration",{enumerable:true,get:function(){return _index.exportAllDeclaration}}),Object.defineProperty(exports,"ExportDefaultDeclaration",{enumerable:true,get:function(){return _index.exportDefaultDeclaration}}),Object.defineProperty(exports,"ExportDefaultSpecifier",{enumerable:true,get:function(){return _index.exportDefaultSpecifier}}),Object.defineProperty(exports,"ExportNamedDeclaration",{enumerable:true,get:function(){return _index.exportNamedDeclaration}}),Object.defineProperty(exports,"ExportNamespaceSpecifier",{enumerable:true,get:function(){return _index.exportNamespaceSpecifier}}),Object.defineProperty(exports,"ExportSpecifier",{enumerable:true,get:function(){return _index.exportSpecifier}}),Object.defineProperty(exports,"ExpressionStatement",{enumerable:true,get:function(){return _index.expressionStatement}}),Object.defineProperty(exports,"File",{enumerable:true,get:function(){return _index.file}}),Object.defineProperty(exports,"ForInStatement",{enumerable:true,get:function(){return _index.forInStatement}}),Object.defineProperty(exports,"ForOfStatement",{enumerable:true,get:function(){return _index.forOfStatement}}),Object.defineProperty(exports,"ForStatement",{enumerable:true,get:function(){return _index.forStatement}}),Object.defineProperty(exports,"FunctionDeclaration",{enumerable:true,get:function(){return _index.functionDeclaration}}),Object.defineProperty(exports,"FunctionExpression",{enumerable:true,get:function(){return _index.functionExpression}}),Object.defineProperty(exports,"FunctionTypeAnnotation",{enumerable:true,get:function(){return _index.functionTypeAnnotation}}),Object.defineProperty(exports,"FunctionTypeParam",{enumerable:true,get:function(){return _index.functionTypeParam}}),Object.defineProperty(exports,"GenericTypeAnnotation",{enumerable:true,get:function(){return _index.genericTypeAnnotation}}),Object.defineProperty(exports,"Identifier",{enumerable:true,get:function(){return _index.identifier}}),Object.defineProperty(exports,"IfStatement",{enumerable:true,get:function(){return _index.ifStatement}}),Object.defineProperty(exports,"Import",{enumerable:true,get:function(){return _index.import}}),Object.defineProperty(exports,"ImportAttribute",{enumerable:true,get:function(){return _index.importAttribute}}),Object.defineProperty(exports,"ImportDeclaration",{enumerable:true,get:function(){return _index.importDeclaration}}),Object.defineProperty(exports,"ImportDefaultSpecifier",{enumerable:true,get:function(){return _index.importDefaultSpecifier}}),Object.defineProperty(exports,"ImportExpression",{enumerable:true,get:function(){return _index.importExpression}}),Object.defineProperty(exports,"ImportNamespaceSpecifier",{enumerable:true,get:function(){return _index.importNamespaceSpecifier}}),Object.defineProperty(exports,"ImportSpecifier",{enumerable:true,get:function(){return _index.importSpecifier}}),Object.defineProperty(exports,"IndexedAccessType",{enumerable:true,get:function(){return _index.indexedAccessType}}),Object.defineProperty(exports,"InferredPredicate",{enumerable:true,get:function(){return _index.inferredPredicate}}),Object.defineProperty(exports,"InterfaceDeclaration",{enumerable:true,get:function(){return _index.interfaceDeclaration}}),Object.defineProperty(exports,"InterfaceExtends",{enumerable:true,get:function(){return _index.interfaceExtends}}),Object.defineProperty(exports,"InterfaceTypeAnnotation",{enumerable:true,get:function(){return _index.interfaceTypeAnnotation}}),Object.defineProperty(exports,"InterpreterDirective",{enumerable:true,get:function(){return _index.interpreterDirective}}),Object.defineProperty(exports,"IntersectionTypeAnnotation",{enumerable:true,get:function(){return _index.intersectionTypeAnnotation}}),Object.defineProperty(exports,"JSXAttribute",{enumerable:true,get:function(){return _index.jsxAttribute}}),Object.defineProperty(exports,"JSXClosingElement",{enumerable:true,get:function(){return _index.jsxClosingElement}}),Object.defineProperty(exports,"JSXClosingFragment",{enumerable:true,get:function(){return _index.jsxClosingFragment}}),Object.defineProperty(exports,"JSXElement",{enumerable:true,get:function(){return _index.jsxElement}}),Object.defineProperty(exports,"JSXEmptyExpression",{enumerable:true,get:function(){return _index.jsxEmptyExpression}}),Object.defineProperty(exports,"JSXExpressionContainer",{enumerable:true,get:function(){return _index.jsxExpressionContainer}}),Object.defineProperty(exports,"JSXFragment",{enumerable:true,get:function(){return _index.jsxFragment}}),Object.defineProperty(exports,"JSXIdentifier",{enumerable:true,get:function(){return _index.jsxIdentifier}}),Object.defineProperty(exports,"JSXMemberExpression",{enumerable:true,get:function(){return _index.jsxMemberExpression}}),Object.defineProperty(exports,"JSXNamespacedName",{enumerable:true,get:function(){return _index.jsxNamespacedName}}),Object.defineProperty(exports,"JSXOpeningElement",{enumerable:true,get:function(){return _index.jsxOpeningElement}}),Object.defineProperty(exports,"JSXOpeningFragment",{enumerable:true,get:function(){return _index.jsxOpeningFragment}}),Object.defineProperty(exports,"JSXSpreadAttribute",{enumerable:true,get:function(){return _index.jsxSpreadAttribute}}),Object.defineProperty(exports,"JSXSpreadChild",{enumerable:true,get:function(){return _index.jsxSpreadChild}}),Object.defineProperty(exports,"JSXText",{enumerable:true,get:function(){return _index.jsxText}}),Object.defineProperty(exports,"LabeledStatement",{enumerable:true,get:function(){return _index.labeledStatement}}),Object.defineProperty(exports,"LogicalExpression",{enumerable:true,get:function(){return _index.logicalExpression}}),Object.defineProperty(exports,"MemberExpression",{enumerable:true,get:function(){return _index.memberExpression}}),Object.defineProperty(exports,"MetaProperty",{enumerable:true,get:function(){return _index.metaProperty}}),Object.defineProperty(exports,"MixedTypeAnnotation",{enumerable:true,get:function(){return _index.mixedTypeAnnotation}}),Object.defineProperty(exports,"ModuleExpression",{enumerable:true,get:function(){return _index.moduleExpression}}),Object.defineProperty(exports,"NewExpression",{enumerable:true,get:function(){return _index.newExpression}}),Object.defineProperty(exports,"Noop",{enumerable:true,get:function(){return _index.noop}}),Object.defineProperty(exports,"NullLiteral",{enumerable:true,get:function(){return _index.nullLiteral}}),Object.defineProperty(exports,"NullLiteralTypeAnnotation",{enumerable:true,get:function(){return _index.nullLiteralTypeAnnotation}}),Object.defineProperty(exports,"NullableTypeAnnotation",{enumerable:true,get:function(){return _index.nullableTypeAnnotation}}),Object.defineProperty(exports,"NumberLiteral",{enumerable:true,get:function(){return _index.numberLiteral}}),Object.defineProperty(exports,"NumberLiteralTypeAnnotation",{enumerable:true,get:function(){return _index.numberLiteralTypeAnnotation}}),Object.defineProperty(exports,"NumberTypeAnnotation",{enumerable:true,get:function(){return _index.numberTypeAnnotation}}),Object.defineProperty(exports,"NumericLiteral",{enumerable:true,get:function(){return _index.numericLiteral}}),Object.defineProperty(exports,"ObjectExpression",{enumerable:true,get:function(){return _index.objectExpression}}),Object.defineProperty(exports,"ObjectMethod",{enumerable:true,get:function(){return _index.objectMethod}}),Object.defineProperty(exports,"ObjectPattern",{enumerable:true,get:function(){return _index.objectPattern}}),Object.defineProperty(exports,"ObjectProperty",{enumerable:true,get:function(){return _index.objectProperty}}),Object.defineProperty(exports,"ObjectTypeAnnotation",{enumerable:true,get:function(){return _index.objectTypeAnnotation}}),Object.defineProperty(exports,"ObjectTypeCallProperty",{enumerable:true,get:function(){return _index.objectTypeCallProperty}}),Object.defineProperty(exports,"ObjectTypeIndexer",{enumerable:true,get:function(){return _index.objectTypeIndexer}}),Object.defineProperty(exports,"ObjectTypeInternalSlot",{enumerable:true,get:function(){return _index.objectTypeInternalSlot}}),Object.defineProperty(exports,"ObjectTypeProperty",{enumerable:true,get:function(){return _index.objectTypeProperty}}),Object.defineProperty(exports,"ObjectTypeSpreadProperty",{enumerable:true,get:function(){return _index.objectTypeSpreadProperty}}),Object.defineProperty(exports,"OpaqueType",{enumerable:true,get:function(){return _index.opaqueType}}),Object.defineProperty(exports,"OptionalCallExpression",{enumerable:true,get:function(){return _index.optionalCallExpression}}),Object.defineProperty(exports,"OptionalIndexedAccessType",{enumerable:true,get:function(){return _index.optionalIndexedAccessType}}),Object.defineProperty(exports,"OptionalMemberExpression",{enumerable:true,get:function(){return _index.optionalMemberExpression}}),Object.defineProperty(exports,"ParenthesizedExpression",{enumerable:true,get:function(){return _index.parenthesizedExpression}}),Object.defineProperty(exports,"PipelineBareFunction",{enumerable:true,get:function(){return _index.pipelineBareFunction}}),Object.defineProperty(exports,"PipelinePrimaryTopicReference",{enumerable:true,get:function(){return _index.pipelinePrimaryTopicReference}}),Object.defineProperty(exports,"PipelineTopicExpression",{enumerable:true,get:function(){return _index.pipelineTopicExpression}}),Object.defineProperty(exports,"Placeholder",{enumerable:true,get:function(){return _index.placeholder}}),Object.defineProperty(exports,"PrivateName",{enumerable:true,get:function(){return _index.privateName}}),Object.defineProperty(exports,"Program",{enumerable:true,get:function(){return _index.program}}),Object.defineProperty(exports,"QualifiedTypeIdentifier",{enumerable:true,get:function(){return _index.qualifiedTypeIdentifier}}),Object.defineProperty(exports,"RecordExpression",{enumerable:true,get:function(){return _index.recordExpression}}),Object.defineProperty(exports,"RegExpLiteral",{enumerable:true,get:function(){return _index.regExpLiteral}}),Object.defineProperty(exports,"RegexLiteral",{enumerable:true,get:function(){return _index.regexLiteral}}),Object.defineProperty(exports,"RestElement",{enumerable:true,get:function(){return _index.restElement}}),Object.defineProperty(exports,"RestProperty",{enumerable:true,get:function(){return _index.restProperty}}),Object.defineProperty(exports,"ReturnStatement",{enumerable:true,get:function(){return _index.returnStatement}}),Object.defineProperty(exports,"SequenceExpression",{enumerable:true,get:function(){return _index.sequenceExpression}}),Object.defineProperty(exports,"SpreadElement",{enumerable:true,get:function(){return _index.spreadElement}}),Object.defineProperty(exports,"SpreadProperty",{enumerable:true,get:function(){return _index.spreadProperty}}),Object.defineProperty(exports,"StaticBlock",{enumerable:true,get:function(){return _index.staticBlock}}),Object.defineProperty(exports,"StringLiteral",{enumerable:true,get:function(){return _index.stringLiteral}}),Object.defineProperty(exports,"StringLiteralTypeAnnotation",{enumerable:true,get:function(){return _index.stringLiteralTypeAnnotation}}),Object.defineProperty(exports,"StringTypeAnnotation",{enumerable:true,get:function(){return _index.stringTypeAnnotation}}),Object.defineProperty(exports,"Super",{enumerable:true,get:function(){return _index.super}}),Object.defineProperty(exports,"SwitchCase",{enumerable:true,get:function(){return _index.switchCase}}),Object.defineProperty(exports,"SwitchStatement",{enumerable:true,get:function(){return _index.switchStatement}}),Object.defineProperty(exports,"SymbolTypeAnnotation",{enumerable:true,get:function(){return _index.symbolTypeAnnotation}}),Object.defineProperty(exports,"TSAnyKeyword",{enumerable:true,get:function(){return _index.tsAnyKeyword}}),Object.defineProperty(exports,"TSArrayType",{enumerable:true,get:function(){return _index.tsArrayType}}),Object.defineProperty(exports,"TSAsExpression",{enumerable:true,get:function(){return _index.tsAsExpression}}),Object.defineProperty(exports,"TSBigIntKeyword",{enumerable:true,get:function(){return _index.tsBigIntKeyword}}),Object.defineProperty(exports,"TSBooleanKeyword",{enumerable:true,get:function(){return _index.tsBooleanKeyword}}),Object.defineProperty(exports,"TSCallSignatureDeclaration",{enumerable:true,get:function(){return _index.tsCallSignatureDeclaration}}),Object.defineProperty(exports,"TSConditionalType",{enumerable:true,get:function(){return _index.tsConditionalType}}),Object.defineProperty(exports,"TSConstructSignatureDeclaration",{enumerable:true,get:function(){return _index.tsConstructSignatureDeclaration}}),Object.defineProperty(exports,"TSConstructorType",{enumerable:true,get:function(){return _index.tsConstructorType}}),Object.defineProperty(exports,"TSDeclareFunction",{enumerable:true,get:function(){return _index.tsDeclareFunction}}),Object.defineProperty(exports,"TSDeclareMethod",{enumerable:true,get:function(){return _index.tsDeclareMethod}}),Object.defineProperty(exports,"TSEnumDeclaration",{enumerable:true,get:function(){return _index.tsEnumDeclaration}}),Object.defineProperty(exports,"TSEnumMember",{enumerable:true,get:function(){return _index.tsEnumMember}}),Object.defineProperty(exports,"TSExportAssignment",{enumerable:true,get:function(){return _index.tsExportAssignment}}),Object.defineProperty(exports,"TSExpressionWithTypeArguments",{enumerable:true,get:function(){return _index.tsExpressionWithTypeArguments}}),Object.defineProperty(exports,"TSExternalModuleReference",{enumerable:true,get:function(){return _index.tsExternalModuleReference}}),Object.defineProperty(exports,"TSFunctionType",{enumerable:true,get:function(){return _index.tsFunctionType}}),Object.defineProperty(exports,"TSImportEqualsDeclaration",{enumerable:true,get:function(){return _index.tsImportEqualsDeclaration}}),Object.defineProperty(exports,"TSImportType",{enumerable:true,get:function(){return _index.tsImportType}}),Object.defineProperty(exports,"TSIndexSignature",{enumerable:true,get:function(){return _index.tsIndexSignature}}),Object.defineProperty(exports,"TSIndexedAccessType",{enumerable:true,get:function(){return _index.tsIndexedAccessType}}),Object.defineProperty(exports,"TSInferType",{enumerable:true,get:function(){return _index.tsInferType}}),Object.defineProperty(exports,"TSInstantiationExpression",{enumerable:true,get:function(){return _index.tsInstantiationExpression}}),Object.defineProperty(exports,"TSInterfaceBody",{enumerable:true,get:function(){return _index.tsInterfaceBody}}),Object.defineProperty(exports,"TSInterfaceDeclaration",{enumerable:true,get:function(){return _index.tsInterfaceDeclaration}}),Object.defineProperty(exports,"TSIntersectionType",{enumerable:true,get:function(){return _index.tsIntersectionType}}),Object.defineProperty(exports,"TSIntrinsicKeyword",{enumerable:true,get:function(){return _index.tsIntrinsicKeyword}}),Object.defineProperty(exports,"TSLiteralType",{enumerable:true,get:function(){return _index.tsLiteralType}}),Object.defineProperty(exports,"TSMappedType",{enumerable:true,get:function(){return _index.tsMappedType}}),Object.defineProperty(exports,"TSMethodSignature",{enumerable:true,get:function(){return _index.tsMethodSignature}}),Object.defineProperty(exports,"TSModuleBlock",{enumerable:true,get:function(){return _index.tsModuleBlock}}),Object.defineProperty(exports,"TSModuleDeclaration",{enumerable:true,get:function(){return _index.tsModuleDeclaration}}),Object.defineProperty(exports,"TSNamedTupleMember",{enumerable:true,get:function(){return _index.tsNamedTupleMember}}),Object.defineProperty(exports,"TSNamespaceExportDeclaration",{enumerable:true,get:function(){return _index.tsNamespaceExportDeclaration}}),Object.defineProperty(exports,"TSNeverKeyword",{enumerable:true,get:function(){return _index.tsNeverKeyword}}),Object.defineProperty(exports,"TSNonNullExpression",{enumerable:true,get:function(){return _index.tsNonNullExpression}}),Object.defineProperty(exports,"TSNullKeyword",{enumerable:true,get:function(){return _index.tsNullKeyword}}),Object.defineProperty(exports,"TSNumberKeyword",{enumerable:true,get:function(){return _index.tsNumberKeyword}}),Object.defineProperty(exports,"TSObjectKeyword",{enumerable:true,get:function(){return _index.tsObjectKeyword}}),Object.defineProperty(exports,"TSOptionalType",{enumerable:true,get:function(){return _index.tsOptionalType}}),Object.defineProperty(exports,"TSParameterProperty",{enumerable:true,get:function(){return _index.tsParameterProperty}}),Object.defineProperty(exports,"TSParenthesizedType",{enumerable:true,get:function(){return _index.tsParenthesizedType}}),Object.defineProperty(exports,"TSPropertySignature",{enumerable:true,get:function(){return _index.tsPropertySignature}}),Object.defineProperty(exports,"TSQualifiedName",{enumerable:true,get:function(){return _index.tsQualifiedName}}),Object.defineProperty(exports,"TSRestType",{enumerable:true,get:function(){return _index.tsRestType}}),Object.defineProperty(exports,"TSSatisfiesExpression",{enumerable:true,get:function(){return _index.tsSatisfiesExpression}}),Object.defineProperty(exports,"TSStringKeyword",{enumerable:true,get:function(){return _index.tsStringKeyword}}),Object.defineProperty(exports,"TSSymbolKeyword",{enumerable:true,get:function(){return _index.tsSymbolKeyword}}),Object.defineProperty(exports,"TSThisType",{enumerable:true,get:function(){return _index.tsThisType}}),Object.defineProperty(exports,"TSTupleType",{enumerable:true,get:function(){return _index.tsTupleType}}),Object.defineProperty(exports,"TSTypeAliasDeclaration",{enumerable:true,get:function(){return _index.tsTypeAliasDeclaration}}),Object.defineProperty(exports,"TSTypeAnnotation",{enumerable:true,get:function(){return _index.tsTypeAnnotation}}),Object.defineProperty(exports,"TSTypeAssertion",{enumerable:true,get:function(){return _index.tsTypeAssertion}}),Object.defineProperty(exports,"TSTypeLiteral",{enumerable:true,get:function(){return _index.tsTypeLiteral}}),Object.defineProperty(exports,"TSTypeOperator",{enumerable:true,get:function(){return _index.tsTypeOperator}}),Object.defineProperty(exports,"TSTypeParameter",{enumerable:true,get:function(){return _index.tsTypeParameter}}),Object.defineProperty(exports,"TSTypeParameterDeclaration",{enumerable:true,get:function(){return _index.tsTypeParameterDeclaration}}),Object.defineProperty(exports,"TSTypeParameterInstantiation",{enumerable:true,get:function(){return _index.tsTypeParameterInstantiation}}),Object.defineProperty(exports,"TSTypePredicate",{enumerable:true,get:function(){return _index.tsTypePredicate}}),Object.defineProperty(exports,"TSTypeQuery",{enumerable:true,get:function(){return _index.tsTypeQuery}}),Object.defineProperty(exports,"TSTypeReference",{enumerable:true,get:function(){return _index.tsTypeReference}}),Object.defineProperty(exports,"TSUndefinedKeyword",{enumerable:true,get:function(){return _index.tsUndefinedKeyword}}),Object.defineProperty(exports,"TSUnionType",{enumerable:true,get:function(){return _index.tsUnionType}}),Object.defineProperty(exports,"TSUnknownKeyword",{enumerable:true,get:function(){return _index.tsUnknownKeyword}}),Object.defineProperty(exports,"TSVoidKeyword",{enumerable:true,get:function(){return _index.tsVoidKeyword}}),Object.defineProperty(exports,"TaggedTemplateExpression",{enumerable:true,get:function(){return _index.taggedTemplateExpression}}),Object.defineProperty(exports,"TemplateElement",{enumerable:true,get:function(){return _index.templateElement}}),Object.defineProperty(exports,"TemplateLiteral",{enumerable:true,get:function(){return _index.templateLiteral}}),Object.defineProperty(exports,"ThisExpression",{enumerable:true,get:function(){return _index.thisExpression}}),Object.defineProperty(exports,"ThisTypeAnnotation",{enumerable:true,get:function(){return _index.thisTypeAnnotation}}),Object.defineProperty(exports,"ThrowStatement",{enumerable:true,get:function(){return _index.throwStatement}}),Object.defineProperty(exports,"TopicReference",{enumerable:true,get:function(){return _index.topicReference}}),Object.defineProperty(exports,"TryStatement",{enumerable:true,get:function(){return _index.tryStatement}}),Object.defineProperty(exports,"TupleExpression",{enumerable:true,get:function(){return _index.tupleExpression}}),Object.defineProperty(exports,"TupleTypeAnnotation",{enumerable:true,get:function(){return _index.tupleTypeAnnotation}}),Object.defineProperty(exports,"TypeAlias",{enumerable:true,get:function(){return _index.typeAlias}}),Object.defineProperty(exports,"TypeAnnotation",{enumerable:true,get:function(){return _index.typeAnnotation}}),Object.defineProperty(exports,"TypeCastExpression",{enumerable:true,get:function(){return _index.typeCastExpression}}),Object.defineProperty(exports,"TypeParameter",{enumerable:true,get:function(){return _index.typeParameter}}),Object.defineProperty(exports,"TypeParameterDeclaration",{enumerable:true,get:function(){return _index.typeParameterDeclaration}}),Object.defineProperty(exports,"TypeParameterInstantiation",{enumerable:true,get:function(){return _index.typeParameterInstantiation}}),Object.defineProperty(exports,"TypeofTypeAnnotation",{enumerable:true,get:function(){return _index.typeofTypeAnnotation}}),Object.defineProperty(exports,"UnaryExpression",{enumerable:true,get:function(){return _index.unaryExpression}}),Object.defineProperty(exports,"UnionTypeAnnotation",{enumerable:true,get:function(){return _index.unionTypeAnnotation}}),Object.defineProperty(exports,"UpdateExpression",{enumerable:true,get:function(){return _index.updateExpression}}),Object.defineProperty(exports,"V8IntrinsicIdentifier",{enumerable:true,get:function(){return _index.v8IntrinsicIdentifier}}),Object.defineProperty(exports,"VariableDeclaration",{enumerable:true,get:function(){return _index.variableDeclaration}}),Object.defineProperty(exports,"VariableDeclarator",{enumerable:true,get:function(){return _index.variableDeclarator}}),Object.defineProperty(exports,"Variance",{enumerable:true,get:function(){return _index.variance}}),Object.defineProperty(exports,"VoidTypeAnnotation",{enumerable:true,get:function(){return _index.voidTypeAnnotation}}),Object.defineProperty(exports,"WhileStatement",{enumerable:true,get:function(){return _index.whileStatement}}),Object.defineProperty(exports,"WithStatement",{enumerable:true,get:function(){return _index.withStatement}}),Object.defineProperty(exports,"YieldExpression",{enumerable:true,get:function(){return _index.yieldExpression}});var _index=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/generated/index.js");},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/productions.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.buildUndefinedNode=function(){return (0, _index.unaryExpression)("void",(0, _index.numericLiteral)(0),true)};var _index=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/generated/index.js");},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/react/buildChildren.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(node){const elements=[];for(let i=0;i<node.children.length;i++){let child=node.children[i];(0, _index.isJSXText)(child)?(0, _cleanJSXElementLiteralChild.default)(child,elements):((0, _index.isJSXExpressionContainer)(child)&&(child=child.expression),(0, _index.isJSXEmptyExpression)(child)||elements.push(child));}return elements};var _index=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/generated/index.js"),_cleanJSXElementLiteralChild=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js");},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(typeAnnotations){const types=typeAnnotations.map((type=>(0, _index2.isTSTypeAnnotation)(type)?type.typeAnnotation:type)),flattened=(0, _removeTypeDuplicates.default)(types);return 1===flattened.length?flattened[0]:(0, _index.tsUnionType)(flattened)};var _index=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/generated/index.js"),_removeTypeDuplicates=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js"),_index2=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/generated/index.js");},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/clone/clone.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(node){return (0, _cloneNode.default)(node,false)};var _cloneNode=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/clone/cloneNode.js");},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/clone/cloneDeep.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(node){return (0, _cloneNode.default)(node)};var _cloneNode=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/clone/cloneNode.js");},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(node){return (0, _cloneNode.default)(node,true,true)};var _cloneNode=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/clone/cloneNode.js");},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/clone/cloneNode.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(node,deep=true,withoutLoc=false){return cloneNodeInternal(node,deep,withoutLoc,new Map)};var _index=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/index.js"),_index2=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/generated/index.js");const{hasOwn}={hasOwn:Function.call.bind(Object.prototype.hasOwnProperty)};function cloneIfNode(obj,deep,withoutLoc,commentsCache){return obj&&"string"==typeof obj.type?cloneNodeInternal(obj,deep,withoutLoc,commentsCache):obj}function cloneIfNodeOrArray(obj,deep,withoutLoc,commentsCache){return Array.isArray(obj)?obj.map((node=>cloneIfNode(node,deep,withoutLoc,commentsCache))):cloneIfNode(obj,deep,withoutLoc,commentsCache)}function cloneNodeInternal(node,deep=true,withoutLoc=false,commentsCache){if(!node)return node;const{type}=node,newNode={type:node.type};if((0, _index2.isIdentifier)(node))newNode.name=node.name,hasOwn(node,"optional")&&"boolean"==typeof node.optional&&(newNode.optional=node.optional),hasOwn(node,"typeAnnotation")&&(newNode.typeAnnotation=deep?cloneIfNodeOrArray(node.typeAnnotation,true,withoutLoc,commentsCache):node.typeAnnotation),hasOwn(node,"decorators")&&(newNode.decorators=deep?cloneIfNodeOrArray(node.decorators,true,withoutLoc,commentsCache):node.decorators);else {if(!hasOwn(_index.NODE_FIELDS,type))throw new Error(`Unknown node type: "${type}"`);for(const field of Object.keys(_index.NODE_FIELDS[type]))hasOwn(node,field)&&(newNode[field]=deep?(0, _index2.isFile)(node)&&"comments"===field?maybeCloneComments(node.comments,deep,withoutLoc,commentsCache):cloneIfNodeOrArray(node[field],true,withoutLoc,commentsCache):node[field]);}return hasOwn(node,"loc")&&(newNode.loc=withoutLoc?null:node.loc),hasOwn(node,"leadingComments")&&(newNode.leadingComments=maybeCloneComments(node.leadingComments,deep,withoutLoc,commentsCache)),hasOwn(node,"innerComments")&&(newNode.innerComments=maybeCloneComments(node.innerComments,deep,withoutLoc,commentsCache)),hasOwn(node,"trailingComments")&&(newNode.trailingComments=maybeCloneComments(node.trailingComments,deep,withoutLoc,commentsCache)),hasOwn(node,"extra")&&(newNode.extra=Object.assign({},node.extra)),newNode}function maybeCloneComments(comments,deep,withoutLoc,commentsCache){return comments&&deep?comments.map((comment=>{const cache=commentsCache.get(comment);if(cache)return cache;const{type,value,loc}=comment,ret={type,value,loc};return withoutLoc&&(ret.loc=null),commentsCache.set(comment,ret),ret})):comments}},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/clone/cloneWithoutLoc.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(node){return (0, _cloneNode.default)(node,false,true)};var _cloneNode=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/clone/cloneNode.js");},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/comments/addComment.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(node,type,content,line){return (0, _addComments.default)(node,type,[{type:line?"CommentLine":"CommentBlock",value:content}])};var _addComments=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/comments/addComments.js");},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/comments/addComments.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(node,type,comments){if(!comments||!node)return node;const key=`${type}Comments`;node[key]?"leading"===type?node[key]=comments.concat(node[key]):node[key].push(...comments):node[key]=comments;return node};},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/comments/inheritInnerComments.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(child,parent){(0, _inherit.default)("innerComments",child,parent);};var _inherit=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/utils/inherit.js");},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/comments/inheritLeadingComments.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(child,parent){(0, _inherit.default)("leadingComments",child,parent);};var _inherit=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/utils/inherit.js");},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/comments/inheritTrailingComments.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(child,parent){(0, _inherit.default)("trailingComments",child,parent);};var _inherit=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/utils/inherit.js");},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/comments/inheritsComments.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(child,parent){return (0, _inheritTrailingComments.default)(child,parent),(0, _inheritLeadingComments.default)(child,parent),(0, _inheritInnerComments.default)(child,parent),child};var _inheritTrailingComments=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/comments/inheritTrailingComments.js"),_inheritLeadingComments=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/comments/inheritLeadingComments.js"),_inheritInnerComments=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/comments/inheritInnerComments.js");},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/comments/removeComments.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(node){return _index.COMMENT_KEYS.forEach((key=>{node[key]=null;})),node};var _index=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/constants/index.js");},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/constants/generated/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.WHILE_TYPES=exports.USERWHITESPACABLE_TYPES=exports.UNARYLIKE_TYPES=exports.TYPESCRIPT_TYPES=exports.TSTYPE_TYPES=exports.TSTYPEELEMENT_TYPES=exports.TSENTITYNAME_TYPES=exports.TSBASETYPE_TYPES=exports.TERMINATORLESS_TYPES=exports.STATEMENT_TYPES=exports.STANDARDIZED_TYPES=exports.SCOPABLE_TYPES=exports.PUREISH_TYPES=exports.PROPERTY_TYPES=exports.PRIVATE_TYPES=exports.PATTERN_TYPES=exports.PATTERNLIKE_TYPES=exports.OBJECTMEMBER_TYPES=exports.MODULESPECIFIER_TYPES=exports.MODULEDECLARATION_TYPES=exports.MISCELLANEOUS_TYPES=exports.METHOD_TYPES=exports.LVAL_TYPES=exports.LOOP_TYPES=exports.LITERAL_TYPES=exports.JSX_TYPES=exports.IMPORTOREXPORTDECLARATION_TYPES=exports.IMMUTABLE_TYPES=exports.FUNCTION_TYPES=exports.FUNCTIONPARENT_TYPES=exports.FOR_TYPES=exports.FORXSTATEMENT_TYPES=exports.FLOW_TYPES=exports.FLOWTYPE_TYPES=exports.FLOWPREDICATE_TYPES=exports.FLOWDECLARATION_TYPES=exports.FLOWBASEANNOTATION_TYPES=exports.EXPRESSION_TYPES=exports.EXPRESSIONWRAPPER_TYPES=exports.EXPORTDECLARATION_TYPES=exports.ENUMMEMBER_TYPES=exports.ENUMBODY_TYPES=exports.DECLARATION_TYPES=exports.CONDITIONAL_TYPES=exports.COMPLETIONSTATEMENT_TYPES=exports.CLASS_TYPES=exports.BLOCK_TYPES=exports.BLOCKPARENT_TYPES=exports.BINARY_TYPES=exports.ACCESSOR_TYPES=void 0;var _index=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/index.js");exports.STANDARDIZED_TYPES=_index.FLIPPED_ALIAS_KEYS.Standardized,exports.EXPRESSION_TYPES=_index.FLIPPED_ALIAS_KEYS.Expression,exports.BINARY_TYPES=_index.FLIPPED_ALIAS_KEYS.Binary,exports.SCOPABLE_TYPES=_index.FLIPPED_ALIAS_KEYS.Scopable,exports.BLOCKPARENT_TYPES=_index.FLIPPED_ALIAS_KEYS.BlockParent,exports.BLOCK_TYPES=_index.FLIPPED_ALIAS_KEYS.Block,exports.STATEMENT_TYPES=_index.FLIPPED_ALIAS_KEYS.Statement,exports.TERMINATORLESS_TYPES=_index.FLIPPED_ALIAS_KEYS.Terminatorless,exports.COMPLETIONSTATEMENT_TYPES=_index.FLIPPED_ALIAS_KEYS.CompletionStatement,exports.CONDITIONAL_TYPES=_index.FLIPPED_ALIAS_KEYS.Conditional,exports.LOOP_TYPES=_index.FLIPPED_ALIAS_KEYS.Loop,exports.WHILE_TYPES=_index.FLIPPED_ALIAS_KEYS.While,exports.EXPRESSIONWRAPPER_TYPES=_index.FLIPPED_ALIAS_KEYS.ExpressionWrapper,exports.FOR_TYPES=_index.FLIPPED_ALIAS_KEYS.For,exports.FORXSTATEMENT_TYPES=_index.FLIPPED_ALIAS_KEYS.ForXStatement,exports.FUNCTION_TYPES=_index.FLIPPED_ALIAS_KEYS.Function,exports.FUNCTIONPARENT_TYPES=_index.FLIPPED_ALIAS_KEYS.FunctionParent,exports.PUREISH_TYPES=_index.FLIPPED_ALIAS_KEYS.Pureish,exports.DECLARATION_TYPES=_index.FLIPPED_ALIAS_KEYS.Declaration,exports.PATTERNLIKE_TYPES=_index.FLIPPED_ALIAS_KEYS.PatternLike,exports.LVAL_TYPES=_index.FLIPPED_ALIAS_KEYS.LVal,exports.TSENTITYNAME_TYPES=_index.FLIPPED_ALIAS_KEYS.TSEntityName,exports.LITERAL_TYPES=_index.FLIPPED_ALIAS_KEYS.Literal,exports.IMMUTABLE_TYPES=_index.FLIPPED_ALIAS_KEYS.Immutable,exports.USERWHITESPACABLE_TYPES=_index.FLIPPED_ALIAS_KEYS.UserWhitespacable,exports.METHOD_TYPES=_index.FLIPPED_ALIAS_KEYS.Method,exports.OBJECTMEMBER_TYPES=_index.FLIPPED_ALIAS_KEYS.ObjectMember,exports.PROPERTY_TYPES=_index.FLIPPED_ALIAS_KEYS.Property,exports.UNARYLIKE_TYPES=_index.FLIPPED_ALIAS_KEYS.UnaryLike,exports.PATTERN_TYPES=_index.FLIPPED_ALIAS_KEYS.Pattern,exports.CLASS_TYPES=_index.FLIPPED_ALIAS_KEYS.Class;const IMPORTOREXPORTDECLARATION_TYPES=exports.IMPORTOREXPORTDECLARATION_TYPES=_index.FLIPPED_ALIAS_KEYS.ImportOrExportDeclaration;exports.EXPORTDECLARATION_TYPES=_index.FLIPPED_ALIAS_KEYS.ExportDeclaration,exports.MODULESPECIFIER_TYPES=_index.FLIPPED_ALIAS_KEYS.ModuleSpecifier,exports.ACCESSOR_TYPES=_index.FLIPPED_ALIAS_KEYS.Accessor,exports.PRIVATE_TYPES=_index.FLIPPED_ALIAS_KEYS.Private,exports.FLOW_TYPES=_index.FLIPPED_ALIAS_KEYS.Flow,exports.FLOWTYPE_TYPES=_index.FLIPPED_ALIAS_KEYS.FlowType,exports.FLOWBASEANNOTATION_TYPES=_index.FLIPPED_ALIAS_KEYS.FlowBaseAnnotation,exports.FLOWDECLARATION_TYPES=_index.FLIPPED_ALIAS_KEYS.FlowDeclaration,exports.FLOWPREDICATE_TYPES=_index.FLIPPED_ALIAS_KEYS.FlowPredicate,exports.ENUMBODY_TYPES=_index.FLIPPED_ALIAS_KEYS.EnumBody,exports.ENUMMEMBER_TYPES=_index.FLIPPED_ALIAS_KEYS.EnumMember,exports.JSX_TYPES=_index.FLIPPED_ALIAS_KEYS.JSX,exports.MISCELLANEOUS_TYPES=_index.FLIPPED_ALIAS_KEYS.Miscellaneous,exports.TYPESCRIPT_TYPES=_index.FLIPPED_ALIAS_KEYS.TypeScript,exports.TSTYPEELEMENT_TYPES=_index.FLIPPED_ALIAS_KEYS.TSTypeElement,exports.TSTYPE_TYPES=_index.FLIPPED_ALIAS_KEYS.TSType,exports.TSBASETYPE_TYPES=_index.FLIPPED_ALIAS_KEYS.TSBaseType,exports.MODULEDECLARATION_TYPES=IMPORTOREXPORTDECLARATION_TYPES;},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/constants/index.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.UPDATE_OPERATORS=exports.UNARY_OPERATORS=exports.STRING_UNARY_OPERATORS=exports.STATEMENT_OR_BLOCK_KEYS=exports.NUMBER_UNARY_OPERATORS=exports.NUMBER_BINARY_OPERATORS=exports.NOT_LOCAL_BINDING=exports.LOGICAL_OPERATORS=exports.INHERIT_KEYS=exports.FOR_INIT_KEYS=exports.FLATTENABLE_KEYS=exports.EQUALITY_BINARY_OPERATORS=exports.COMPARISON_BINARY_OPERATORS=exports.COMMENT_KEYS=exports.BOOLEAN_UNARY_OPERATORS=exports.BOOLEAN_NUMBER_BINARY_OPERATORS=exports.BOOLEAN_BINARY_OPERATORS=exports.BLOCK_SCOPED_SYMBOL=exports.BINARY_OPERATORS=exports.ASSIGNMENT_OPERATORS=void 0;exports.STATEMENT_OR_BLOCK_KEYS=["consequent","body","alternate"],exports.FLATTENABLE_KEYS=["body","expressions"],exports.FOR_INIT_KEYS=["left","init"],exports.COMMENT_KEYS=["leadingComments","trailingComments","innerComments"];const LOGICAL_OPERATORS=exports.LOGICAL_OPERATORS=["||","&&","??"],BOOLEAN_NUMBER_BINARY_OPERATORS=(exports.UPDATE_OPERATORS=["++","--"],exports.BOOLEAN_NUMBER_BINARY_OPERATORS=[">","<",">=","<="]),EQUALITY_BINARY_OPERATORS=exports.EQUALITY_BINARY_OPERATORS=["==","===","!=","!=="],COMPARISON_BINARY_OPERATORS=exports.COMPARISON_BINARY_OPERATORS=[...EQUALITY_BINARY_OPERATORS,"in","instanceof"],BOOLEAN_BINARY_OPERATORS=exports.BOOLEAN_BINARY_OPERATORS=[...COMPARISON_BINARY_OPERATORS,...BOOLEAN_NUMBER_BINARY_OPERATORS],NUMBER_BINARY_OPERATORS=exports.NUMBER_BINARY_OPERATORS=["-","/","%","*","**","&","|",">>",">>>","<<","^"],BOOLEAN_UNARY_OPERATORS=(exports.BINARY_OPERATORS=["+",...NUMBER_BINARY_OPERATORS,...BOOLEAN_BINARY_OPERATORS,"|>"],exports.ASSIGNMENT_OPERATORS=["=","+=",...NUMBER_BINARY_OPERATORS.map((op=>op+"=")),...LOGICAL_OPERATORS.map((op=>op+"="))],exports.BOOLEAN_UNARY_OPERATORS=["delete","!"]),NUMBER_UNARY_OPERATORS=exports.NUMBER_UNARY_OPERATORS=["+","-","~"],STRING_UNARY_OPERATORS=exports.STRING_UNARY_OPERATORS=["typeof"];exports.UNARY_OPERATORS=["void","throw",...BOOLEAN_UNARY_OPERATORS,...NUMBER_UNARY_OPERATORS,...STRING_UNARY_OPERATORS],exports.INHERIT_KEYS={optional:["typeAnnotation","typeParameters","returnType"],force:["start","loc","end"]},exports.BLOCK_SCOPED_SYMBOL=Symbol.for("var used to be block scoped"),exports.NOT_LOCAL_BINDING=Symbol.for("should not be considered a local binding");},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/converters/ensureBlock.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(node,key="body"){const result=(0, _toBlock.default)(node[key],node);return node[key]=result,result};var _toBlock=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/converters/toBlock.js");},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function gatherSequenceExpressions(nodes,declars){const exprs=[];let ensureLastUndefined=true;for(const node of nodes)if((0, _index.isEmptyStatement)(node)||(ensureLastUndefined=false),(0, _index.isExpression)(node))exprs.push(node);else if((0, _index.isExpressionStatement)(node))exprs.push(node.expression);else if((0, _index.isVariableDeclaration)(node)){if("var"!==node.kind)return;for(const declar of node.declarations){const bindings=(0, _getBindingIdentifiers.default)(declar);for(const key of Object.keys(bindings))declars.push({kind:node.kind,id:(0, _cloneNode.default)(bindings[key])});declar.init&&exprs.push((0, _index2.assignmentExpression)("=",declar.id,declar.init));}ensureLastUndefined=true;}else if((0, _index.isIfStatement)(node)){const consequent=node.consequent?gatherSequenceExpressions([node.consequent],declars):(0, _productions.buildUndefinedNode)(),alternate=node.alternate?gatherSequenceExpressions([node.alternate],declars):(0, _productions.buildUndefinedNode)();if(!consequent||!alternate)return;exprs.push((0, _index2.conditionalExpression)(node.test,consequent,alternate));}else if((0, _index.isBlockStatement)(node)){const body=gatherSequenceExpressions(node.body,declars);if(!body)return;exprs.push(body);}else {if(!(0, _index.isEmptyStatement)(node))return;0===nodes.indexOf(node)&&(ensureLastUndefined=true);}ensureLastUndefined&&exprs.push((0, _productions.buildUndefinedNode)());return 1===exprs.length?exprs[0]:(0, _index2.sequenceExpression)(exprs)};var _getBindingIdentifiers=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js"),_index=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/generated/index.js"),_index2=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/generated/index.js"),_productions=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/productions.js"),_cloneNode=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/clone/cloneNode.js");},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/converters/toBindingIdentifierName.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(name){"eval"!==(name=(0, _toIdentifier.default)(name))&&"arguments"!==name||(name="_"+name);return name};var _toIdentifier=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/converters/toIdentifier.js");},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/converters/toBlock.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(node,parent){if((0, _index.isBlockStatement)(node))return node;let blockNodes=[];(0, _index.isEmptyStatement)(node)?blockNodes=[]:((0, _index.isStatement)(node)||(node=(0, _index.isFunction)(parent)?(0, _index2.returnStatement)(node):(0, _index2.expressionStatement)(node)),blockNodes=[node]);return (0, _index2.blockStatement)(blockNodes)};var _index=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/generated/index.js"),_index2=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/generated/index.js");},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/converters/toComputedKey.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(node,key=node.key||node.property){!node.computed&&(0, _index.isIdentifier)(key)&&(key=(0, _index2.stringLiteral)(key.name));return key};var _index=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/generated/index.js"),_index2=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/generated/index.js");},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/converters/toExpression.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=void 0;var _index=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/generated/index.js");exports.default=function(node){(0, _index.isExpressionStatement)(node)&&(node=node.expression);if((0, _index.isExpression)(node))return node;(0, _index.isClass)(node)?node.type="ClassExpression":(0, _index.isFunction)(node)&&(node.type="FunctionExpression");if(!(0, _index.isExpression)(node))throw new Error(`cannot turn ${node.type} to an expression`);return node};},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/converters/toIdentifier.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(input){input+="";let name="";for(const c of input)name+=(0, _helperValidatorIdentifier.isIdentifierChar)(c.codePointAt(0))?c:"-";name=name.replace(/^[-0-9]+/,""),name=name.replace(/[-\s]+(.)?/g,(function(match,c){return c?c.toUpperCase():""})),(0, _isValidIdentifier.default)(name)||(name=`_${name}`);return name||"_"};var _isValidIdentifier=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isValidIdentifier.js"),_helperValidatorIdentifier=__webpack_require__("./node_modules/.pnpm/@babel+helper-validator-identifier@7.25.9/node_modules/@babel/helper-validator-identifier/lib/index.js");},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/converters/toKeyAlias.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=toKeyAlias;var _index=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/generated/index.js"),_cloneNode=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/clone/cloneNode.js"),_removePropertiesDeep=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/modifications/removePropertiesDeep.js");function toKeyAlias(node,key=node.key){let alias;return "method"===node.kind?toKeyAlias.increment()+"":(alias=(0, _index.isIdentifier)(key)?key.name:(0, _index.isStringLiteral)(key)?JSON.stringify(key.value):JSON.stringify((0, _removePropertiesDeep.default)((0, _cloneNode.default)(key))),node.computed&&(alias=`[${alias}]`),node.static&&(alias=`static:${alias}`),alias)}toKeyAlias.uid=0,toKeyAlias.increment=function(){return toKeyAlias.uid>=Number.MAX_SAFE_INTEGER?toKeyAlias.uid=0:toKeyAlias.uid++};},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/converters/toSequenceExpression.js":(__unused_webpack_module,exports,__webpack_require__)=>{exports.default=function(nodes,scope){if(null==nodes||!nodes.length)return;const declars=[],result=(0, _gatherSequenceExpressions.default)(nodes,declars);if(!result)return;for(const declar of declars)scope.push(declar);return result};var _gatherSequenceExpressions=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js");},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/converters/toStatement.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=void 0;var _index=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/generated/index.js"),_index2=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/generated/index.js");exports.default=function(node,ignore){if((0, _index.isStatement)(node))return node;let newType,mustHaveId=false;if((0, _index.isClass)(node))mustHaveId=true,newType="ClassDeclaration";else if((0, _index.isFunction)(node))mustHaveId=true,newType="FunctionDeclaration";else if((0, _index.isAssignmentExpression)(node))return (0, _index2.expressionStatement)(node);mustHaveId&&!node.id&&(newType=false);if(!newType){if(ignore)return  false;throw new Error(`cannot turn ${node.type} to a statement`)}return node.type=newType,node};},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/converters/valueToNode.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=void 0;var _isValidIdentifier=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isValidIdentifier.js"),_index=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/generated/index.js");exports.default=function valueToNode(value){if(void 0===value)return (0, _index.identifier)("undefined");if(true===value||false===value)return (0, _index.booleanLiteral)(value);if(null===value)return (0, _index.nullLiteral)();if("string"==typeof value)return (0, _index.stringLiteral)(value);if("number"==typeof value){let result;if(Number.isFinite(value))result=(0, _index.numericLiteral)(Math.abs(value));else {let numerator;numerator=Number.isNaN(value)?(0, _index.numericLiteral)(0):(0, _index.numericLiteral)(1),result=(0, _index.binaryExpression)("/",numerator,(0, _index.numericLiteral)(0));}return (value<0||Object.is(value,-0))&&(result=(0, _index.unaryExpression)("-",result)),result}if(function(value){return "[object RegExp]"===objectToString(value)}(value)){const pattern=value.source,flags=/\/([a-z]*)$/.exec(value.toString())[1];return (0, _index.regExpLiteral)(pattern,flags)}if(Array.isArray(value))return (0, _index.arrayExpression)(value.map(valueToNode));if(function(value){if("object"!=typeof value||null===value||"[object Object]"!==Object.prototype.toString.call(value))return  false;const proto=Object.getPrototypeOf(value);return null===proto||null===Object.getPrototypeOf(proto)}(value)){const props=[];for(const key of Object.keys(value)){let nodeKey;nodeKey=(0, _isValidIdentifier.default)(key)?(0, _index.identifier)(key):(0, _index.stringLiteral)(key),props.push((0, _index.objectProperty)(nodeKey,valueToNode(value[key])));}return (0, _index.objectExpression)(props)}throw new Error("don't know how to turn this value into a node")};const objectToString=Function.call.bind(Object.prototype.toString);},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/core.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.patternLikeCommon=exports.importAttributes=exports.functionTypeAnnotationCommon=exports.functionDeclarationCommon=exports.functionCommon=exports.classMethodOrPropertyCommon=exports.classMethodOrDeclareMethodCommon=void 0;var _is=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/is.js"),_isValidIdentifier=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isValidIdentifier.js"),_helperValidatorIdentifier=__webpack_require__("./node_modules/.pnpm/@babel+helper-validator-identifier@7.25.9/node_modules/@babel/helper-validator-identifier/lib/index.js"),_helperStringParser=__webpack_require__("./node_modules/.pnpm/@babel+helper-string-parser@7.25.9/node_modules/@babel/helper-string-parser/lib/index.js"),_index=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/constants/index.js"),_utils=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/utils.js");const defineType=(0, _utils.defineAliasedType)("Standardized");defineType("ArrayExpression",{fields:{elements:{validate:(0, _utils.arrayOf)((0, _utils.assertNodeOrValueType)("null","Expression","SpreadElement")),default:process.env.BABEL_TYPES_8_BREAKING?void 0:[]}},visitor:["elements"],aliases:["Expression"]}),defineType("AssignmentExpression",{fields:{operator:{validate:process.env.BABEL_TYPES_8_BREAKING?Object.assign(function(){const identifier=(0, _utils.assertOneOf)(..._index.ASSIGNMENT_OPERATORS),pattern=(0, _utils.assertOneOf)("=");return function(node,key,val){((0, _is.default)("Pattern",node.left)?pattern:identifier)(node,key,val);}}(),{type:"string"}):(0, _utils.assertValueType)("string")},left:{validate:process.env.BABEL_TYPES_8_BREAKING?(0, _utils.assertNodeType)("Identifier","MemberExpression","OptionalMemberExpression","ArrayPattern","ObjectPattern","TSAsExpression","TSSatisfiesExpression","TSTypeAssertion","TSNonNullExpression"):(0, _utils.assertNodeType)("LVal","OptionalMemberExpression")},right:{validate:(0, _utils.assertNodeType)("Expression")}},builder:["operator","left","right"],visitor:["left","right"],aliases:["Expression"]}),defineType("BinaryExpression",{builder:["operator","left","right"],fields:{operator:{validate:(0, _utils.assertOneOf)(..._index.BINARY_OPERATORS)},left:{validate:function(){const expression=(0, _utils.assertNodeType)("Expression"),inOp=(0, _utils.assertNodeType)("Expression","PrivateName");return Object.assign((function(node,key,val){("in"===node.operator?inOp:expression)(node,key,val);}),{oneOfNodeTypes:["Expression","PrivateName"]})}()},right:{validate:(0, _utils.assertNodeType)("Expression")}},visitor:["left","right"],aliases:["Binary","Expression"]}),defineType("InterpreterDirective",{builder:["value"],fields:{value:{validate:(0, _utils.assertValueType)("string")}}}),defineType("Directive",{visitor:["value"],fields:{value:{validate:(0, _utils.assertNodeType)("DirectiveLiteral")}}}),defineType("DirectiveLiteral",{builder:["value"],fields:{value:{validate:(0, _utils.assertValueType)("string")}}}),defineType("BlockStatement",{builder:["body","directives"],visitor:["directives","body"],fields:{directives:{validate:(0, _utils.arrayOfType)("Directive"),default:[]},body:(0, _utils.validateArrayOfType)("Statement")},aliases:["Scopable","BlockParent","Block","Statement"]}),defineType("BreakStatement",{visitor:["label"],fields:{label:{validate:(0, _utils.assertNodeType)("Identifier"),optional:true}},aliases:["Statement","Terminatorless","CompletionStatement"]}),defineType("CallExpression",{visitor:["callee","arguments","typeParameters","typeArguments"],builder:["callee","arguments"],aliases:["Expression"],fields:Object.assign({callee:{validate:(0, _utils.assertNodeType)("Expression","Super","V8IntrinsicIdentifier")},arguments:(0, _utils.validateArrayOfType)("Expression","SpreadElement","ArgumentPlaceholder")},process.env.BABEL_TYPES_8_BREAKING?{}:{optional:{validate:(0, _utils.assertValueType)("boolean"),optional:true}},{typeArguments:{validate:(0, _utils.assertNodeType)("TypeParameterInstantiation"),optional:true},typeParameters:{validate:(0, _utils.assertNodeType)("TSTypeParameterInstantiation"),optional:true}})}),defineType("CatchClause",{visitor:["param","body"],fields:{param:{validate:(0, _utils.assertNodeType)("Identifier","ArrayPattern","ObjectPattern"),optional:true},body:{validate:(0, _utils.assertNodeType)("BlockStatement")}},aliases:["Scopable","BlockParent"]}),defineType("ConditionalExpression",{visitor:["test","consequent","alternate"],fields:{test:{validate:(0, _utils.assertNodeType)("Expression")},consequent:{validate:(0, _utils.assertNodeType)("Expression")},alternate:{validate:(0, _utils.assertNodeType)("Expression")}},aliases:["Expression","Conditional"]}),defineType("ContinueStatement",{visitor:["label"],fields:{label:{validate:(0, _utils.assertNodeType)("Identifier"),optional:true}},aliases:["Statement","Terminatorless","CompletionStatement"]}),defineType("DebuggerStatement",{aliases:["Statement"]}),defineType("DoWhileStatement",{builder:["test","body"],visitor:["body","test"],fields:{test:{validate:(0, _utils.assertNodeType)("Expression")},body:{validate:(0, _utils.assertNodeType)("Statement")}},aliases:["Statement","BlockParent","Loop","While","Scopable"]}),defineType("EmptyStatement",{aliases:["Statement"]}),defineType("ExpressionStatement",{visitor:["expression"],fields:{expression:{validate:(0, _utils.assertNodeType)("Expression")}},aliases:["Statement","ExpressionWrapper"]}),defineType("File",{builder:["program","comments","tokens"],visitor:["program"],fields:{program:{validate:(0, _utils.assertNodeType)("Program")},comments:{validate:process.env.BABEL_TYPES_8_BREAKING?(0, _utils.assertEach)((0, _utils.assertNodeType)("CommentBlock","CommentLine")):Object.assign((()=>{}),{each:{oneOfNodeTypes:["CommentBlock","CommentLine"]}}),optional:true},tokens:{validate:(0, _utils.assertEach)(Object.assign((()=>{}),{type:"any"})),optional:true}}}),defineType("ForInStatement",{visitor:["left","right","body"],aliases:["Scopable","Statement","For","BlockParent","Loop","ForXStatement"],fields:{left:{validate:process.env.BABEL_TYPES_8_BREAKING?(0, _utils.assertNodeType)("VariableDeclaration","Identifier","MemberExpression","ArrayPattern","ObjectPattern","TSAsExpression","TSSatisfiesExpression","TSTypeAssertion","TSNonNullExpression"):(0, _utils.assertNodeType)("VariableDeclaration","LVal")},right:{validate:(0, _utils.assertNodeType)("Expression")},body:{validate:(0, _utils.assertNodeType)("Statement")}}}),defineType("ForStatement",{visitor:["init","test","update","body"],aliases:["Scopable","Statement","For","BlockParent","Loop"],fields:{init:{validate:(0, _utils.assertNodeType)("VariableDeclaration","Expression"),optional:true},test:{validate:(0, _utils.assertNodeType)("Expression"),optional:true},update:{validate:(0, _utils.assertNodeType)("Expression"),optional:true},body:{validate:(0, _utils.assertNodeType)("Statement")}}});const functionCommon=()=>({params:(0, _utils.validateArrayOfType)("Identifier","Pattern","RestElement"),generator:{default:false},async:{default:false}});exports.functionCommon=functionCommon;const functionTypeAnnotationCommon=()=>({returnType:{validate:(0, _utils.assertNodeType)("TypeAnnotation","TSTypeAnnotation","Noop"),optional:true},typeParameters:{validate:(0, _utils.assertNodeType)("TypeParameterDeclaration","TSTypeParameterDeclaration","Noop"),optional:true}});exports.functionTypeAnnotationCommon=functionTypeAnnotationCommon;const functionDeclarationCommon=()=>Object.assign({},functionCommon(),{declare:{validate:(0, _utils.assertValueType)("boolean"),optional:true},id:{validate:(0, _utils.assertNodeType)("Identifier"),optional:true}});exports.functionDeclarationCommon=functionDeclarationCommon,defineType("FunctionDeclaration",{builder:["id","params","body","generator","async"],visitor:["id","typeParameters","params","returnType","body"],fields:Object.assign({},functionDeclarationCommon(),functionTypeAnnotationCommon(),{body:{validate:(0, _utils.assertNodeType)("BlockStatement")},predicate:{validate:(0, _utils.assertNodeType)("DeclaredPredicate","InferredPredicate"),optional:true}}),aliases:["Scopable","Function","BlockParent","FunctionParent","Statement","Pureish","Declaration"],validate:process.env.BABEL_TYPES_8_BREAKING?function(){const identifier=(0, _utils.assertNodeType)("Identifier");return function(parent,key,node){(0, _is.default)("ExportDefaultDeclaration",parent)||identifier(node,"id",node.id);}}():void 0}),defineType("FunctionExpression",{inherits:"FunctionDeclaration",aliases:["Scopable","Function","BlockParent","FunctionParent","Expression","Pureish"],fields:Object.assign({},functionCommon(),functionTypeAnnotationCommon(),{id:{validate:(0, _utils.assertNodeType)("Identifier"),optional:true},body:{validate:(0, _utils.assertNodeType)("BlockStatement")},predicate:{validate:(0, _utils.assertNodeType)("DeclaredPredicate","InferredPredicate"),optional:true}})});const patternLikeCommon=()=>({typeAnnotation:{validate:(0, _utils.assertNodeType)("TypeAnnotation","TSTypeAnnotation","Noop"),optional:true},optional:{validate:(0, _utils.assertValueType)("boolean"),optional:true},decorators:{validate:(0, _utils.arrayOfType)("Decorator"),optional:true}});exports.patternLikeCommon=patternLikeCommon,defineType("Identifier",{builder:["name"],visitor:["typeAnnotation","decorators"],aliases:["Expression","PatternLike","LVal","TSEntityName"],fields:Object.assign({},patternLikeCommon(),{name:{validate:process.env.BABEL_TYPES_8_BREAKING?(0, _utils.chain)((0, _utils.assertValueType)("string"),Object.assign((function(node,key,val){if(!(0, _isValidIdentifier.default)(val,false))throw new TypeError(`"${val}" is not a valid identifier name`)}),{type:"string"})):(0, _utils.assertValueType)("string")}}),validate:process.env.BABEL_TYPES_8_BREAKING?function(parent,key,node){const match=/\.(\w+)$/.exec(key);if(!match)return;const[,parentKey]=match,nonComp={computed:false};if("property"===parentKey){if((0, _is.default)("MemberExpression",parent,nonComp))return;if((0, _is.default)("OptionalMemberExpression",parent,nonComp))return}else if("key"===parentKey){if((0, _is.default)("Property",parent,nonComp))return;if((0, _is.default)("Method",parent,nonComp))return}else if("exported"===parentKey){if((0, _is.default)("ExportSpecifier",parent))return}else if("imported"===parentKey){if((0, _is.default)("ImportSpecifier",parent,{imported:node}))return}else if("meta"===parentKey&&(0, _is.default)("MetaProperty",parent,{meta:node}))return;if(((0, _helperValidatorIdentifier.isKeyword)(node.name)||(0, _helperValidatorIdentifier.isReservedWord)(node.name,false))&&"this"!==node.name)throw new TypeError(`"${node.name}" is not a valid identifier`)}:void 0}),defineType("IfStatement",{visitor:["test","consequent","alternate"],aliases:["Statement","Conditional"],fields:{test:{validate:(0, _utils.assertNodeType)("Expression")},consequent:{validate:(0, _utils.assertNodeType)("Statement")},alternate:{optional:true,validate:(0, _utils.assertNodeType)("Statement")}}}),defineType("LabeledStatement",{visitor:["label","body"],aliases:["Statement"],fields:{label:{validate:(0, _utils.assertNodeType)("Identifier")},body:{validate:(0, _utils.assertNodeType)("Statement")}}}),defineType("StringLiteral",{builder:["value"],fields:{value:{validate:(0, _utils.assertValueType)("string")}},aliases:["Expression","Pureish","Literal","Immutable"]}),defineType("NumericLiteral",{builder:["value"],deprecatedAlias:"NumberLiteral",fields:{value:{validate:(0, _utils.chain)((0, _utils.assertValueType)("number"),Object.assign((function(node,key,val){}),{type:"number"}))}},aliases:["Expression","Pureish","Literal","Immutable"]}),defineType("NullLiteral",{aliases:["Expression","Pureish","Literal","Immutable"]}),defineType("BooleanLiteral",{builder:["value"],fields:{value:{validate:(0, _utils.assertValueType)("boolean")}},aliases:["Expression","Pureish","Literal","Immutable"]}),defineType("RegExpLiteral",{builder:["pattern","flags"],deprecatedAlias:"RegexLiteral",aliases:["Expression","Pureish","Literal"],fields:{pattern:{validate:(0, _utils.assertValueType)("string")},flags:{validate:process.env.BABEL_TYPES_8_BREAKING?(0, _utils.chain)((0, _utils.assertValueType)("string"),Object.assign((function(node,key,val){const invalid=/[^gimsuy]/.exec(val);if(invalid)throw new TypeError(`"${invalid[0]}" is not a valid RegExp flag`)}),{type:"string"})):(0, _utils.assertValueType)("string"),default:""}}}),defineType("LogicalExpression",{builder:["operator","left","right"],visitor:["left","right"],aliases:["Binary","Expression"],fields:{operator:{validate:(0, _utils.assertOneOf)(..._index.LOGICAL_OPERATORS)},left:{validate:(0, _utils.assertNodeType)("Expression")},right:{validate:(0, _utils.assertNodeType)("Expression")}}}),defineType("MemberExpression",{builder:["object","property","computed",...process.env.BABEL_TYPES_8_BREAKING?[]:["optional"]],visitor:["object","property"],aliases:["Expression","LVal"],fields:Object.assign({object:{validate:(0, _utils.assertNodeType)("Expression","Super")},property:{validate:function(){const normal=(0, _utils.assertNodeType)("Identifier","PrivateName"),computed=(0, _utils.assertNodeType)("Expression"),validator=function(node,key,val){(node.computed?computed:normal)(node,key,val);};return validator.oneOfNodeTypes=["Expression","Identifier","PrivateName"],validator}()},computed:{default:false}},process.env.BABEL_TYPES_8_BREAKING?{}:{optional:{validate:(0, _utils.assertValueType)("boolean"),optional:true}})}),defineType("NewExpression",{inherits:"CallExpression"}),defineType("Program",{visitor:["directives","body"],builder:["body","directives","sourceType","interpreter"],fields:{sourceType:{validate:(0, _utils.assertOneOf)("script","module"),default:"script"},interpreter:{validate:(0, _utils.assertNodeType)("InterpreterDirective"),default:null,optional:true},directives:{validate:(0, _utils.arrayOfType)("Directive"),default:[]},body:(0, _utils.validateArrayOfType)("Statement")},aliases:["Scopable","BlockParent","Block"]}),defineType("ObjectExpression",{visitor:["properties"],aliases:["Expression"],fields:{properties:(0, _utils.validateArrayOfType)("ObjectMethod","ObjectProperty","SpreadElement")}}),defineType("ObjectMethod",{builder:["kind","key","params","body","computed","generator","async"],visitor:["decorators","key","typeParameters","params","returnType","body"],fields:Object.assign({},functionCommon(),functionTypeAnnotationCommon(),{kind:Object.assign({validate:(0, _utils.assertOneOf)("method","get","set")},process.env.BABEL_TYPES_8_BREAKING?{}:{default:"method"}),computed:{default:false},key:{validate:function(){const normal=(0, _utils.assertNodeType)("Identifier","StringLiteral","NumericLiteral","BigIntLiteral"),computed=(0, _utils.assertNodeType)("Expression"),validator=function(node,key,val){(node.computed?computed:normal)(node,key,val);};return validator.oneOfNodeTypes=["Expression","Identifier","StringLiteral","NumericLiteral","BigIntLiteral"],validator}()},decorators:{validate:(0, _utils.arrayOfType)("Decorator"),optional:true},body:{validate:(0, _utils.assertNodeType)("BlockStatement")}}),aliases:["UserWhitespacable","Function","Scopable","BlockParent","FunctionParent","Method","ObjectMember"]}),defineType("ObjectProperty",{builder:["key","value","computed","shorthand",...process.env.BABEL_TYPES_8_BREAKING?[]:["decorators"]],fields:{computed:{default:false},key:{validate:function(){const normal=(0, _utils.assertNodeType)("Identifier","StringLiteral","NumericLiteral","BigIntLiteral","DecimalLiteral","PrivateName"),computed=(0, _utils.assertNodeType)("Expression");return Object.assign((function(node,key,val){(node.computed?computed:normal)(node,key,val);}),{oneOfNodeTypes:["Expression","Identifier","StringLiteral","NumericLiteral","BigIntLiteral","DecimalLiteral","PrivateName"]})}()},value:{validate:(0, _utils.assertNodeType)("Expression","PatternLike")},shorthand:{validate:process.env.BABEL_TYPES_8_BREAKING?(0, _utils.chain)((0, _utils.assertValueType)("boolean"),Object.assign((function(node,key,shorthand){if(shorthand){if(node.computed)throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");if(!(0, _is.default)("Identifier",node.key))throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier")}}),{type:"boolean"})):(0, _utils.assertValueType)("boolean"),default:false},decorators:{validate:(0, _utils.arrayOfType)("Decorator"),optional:true}},visitor:["key","value","decorators"],aliases:["UserWhitespacable","Property","ObjectMember"],validate:process.env.BABEL_TYPES_8_BREAKING?function(){const pattern=(0, _utils.assertNodeType)("Identifier","Pattern","TSAsExpression","TSSatisfiesExpression","TSNonNullExpression","TSTypeAssertion"),expression=(0, _utils.assertNodeType)("Expression");return function(parent,key,node){((0, _is.default)("ObjectPattern",parent)?pattern:expression)(node,"value",node.value);}}():void 0}),defineType("RestElement",{visitor:["argument","typeAnnotation"],builder:["argument"],aliases:["LVal","PatternLike"],deprecatedAlias:"RestProperty",fields:Object.assign({},patternLikeCommon(),{argument:{validate:process.env.BABEL_TYPES_8_BREAKING?(0, _utils.assertNodeType)("Identifier","ArrayPattern","ObjectPattern","MemberExpression","TSAsExpression","TSSatisfiesExpression","TSTypeAssertion","TSNonNullExpression"):(0, _utils.assertNodeType)("LVal")}}),validate:process.env.BABEL_TYPES_8_BREAKING?function(parent,key){const match=/(\w+)\[(\d+)\]/.exec(key);if(!match)throw new Error("Internal Babel error: malformed key.");const[,listKey,index]=match;if(parent[listKey].length>+index+1)throw new TypeError(`RestElement must be last element of ${listKey}`)}:void 0}),defineType("ReturnStatement",{visitor:["argument"],aliases:["Statement","Terminatorless","CompletionStatement"],fields:{argument:{validate:(0, _utils.assertNodeType)("Expression"),optional:true}}}),defineType("SequenceExpression",{visitor:["expressions"],fields:{expressions:(0, _utils.validateArrayOfType)("Expression")},aliases:["Expression"]}),defineType("ParenthesizedExpression",{visitor:["expression"],aliases:["Expression","ExpressionWrapper"],fields:{expression:{validate:(0, _utils.assertNodeType)("Expression")}}}),defineType("SwitchCase",{visitor:["test","consequent"],fields:{test:{validate:(0, _utils.assertNodeType)("Expression"),optional:true},consequent:(0, _utils.validateArrayOfType)("Statement")}}),defineType("SwitchStatement",{visitor:["discriminant","cases"],aliases:["Statement","BlockParent","Scopable"],fields:{discriminant:{validate:(0, _utils.assertNodeType)("Expression")},cases:(0, _utils.validateArrayOfType)("SwitchCase")}}),defineType("ThisExpression",{aliases:["Expression"]}),defineType("ThrowStatement",{visitor:["argument"],aliases:["Statement","Terminatorless","CompletionStatement"],fields:{argument:{validate:(0, _utils.assertNodeType)("Expression")}}}),defineType("TryStatement",{visitor:["block","handler","finalizer"],aliases:["Statement"],fields:{block:{validate:process.env.BABEL_TYPES_8_BREAKING?(0, _utils.chain)((0, _utils.assertNodeType)("BlockStatement"),Object.assign((function(node){if(!node.handler&&!node.finalizer)throw new TypeError("TryStatement expects either a handler or finalizer, or both")}),{oneOfNodeTypes:["BlockStatement"]})):(0, _utils.assertNodeType)("BlockStatement")},handler:{optional:true,validate:(0, _utils.assertNodeType)("CatchClause")},finalizer:{optional:true,validate:(0, _utils.assertNodeType)("BlockStatement")}}}),defineType("UnaryExpression",{builder:["operator","argument","prefix"],fields:{prefix:{default:true},argument:{validate:(0, _utils.assertNodeType)("Expression")},operator:{validate:(0, _utils.assertOneOf)(..._index.UNARY_OPERATORS)}},visitor:["argument"],aliases:["UnaryLike","Expression"]}),defineType("UpdateExpression",{builder:["operator","argument","prefix"],fields:{prefix:{default:false},argument:{validate:process.env.BABEL_TYPES_8_BREAKING?(0, _utils.assertNodeType)("Identifier","MemberExpression"):(0, _utils.assertNodeType)("Expression")},operator:{validate:(0, _utils.assertOneOf)(..._index.UPDATE_OPERATORS)}},visitor:["argument"],aliases:["Expression"]}),defineType("VariableDeclaration",{builder:["kind","declarations"],visitor:["declarations"],aliases:["Statement","Declaration"],fields:{declare:{validate:(0, _utils.assertValueType)("boolean"),optional:true},kind:{validate:(0, _utils.assertOneOf)("var","let","const","using","await using")},declarations:(0, _utils.validateArrayOfType)("VariableDeclarator")},validate:process.env.BABEL_TYPES_8_BREAKING?(()=>{const withoutInit=(0, _utils.assertNodeType)("Identifier");return function(parent,key,node){if((0, _is.default)("ForXStatement",parent,{left:node})){if(1!==node.declarations.length)throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`)}else node.declarations.forEach((decl=>{decl.init||withoutInit(decl,"id",decl.id);}));}})():void 0}),defineType("VariableDeclarator",{visitor:["id","init"],fields:{id:{validate:process.env.BABEL_TYPES_8_BREAKING?(0, _utils.assertNodeType)("Identifier","ArrayPattern","ObjectPattern"):(0, _utils.assertNodeType)("LVal")},definite:{optional:true,validate:(0, _utils.assertValueType)("boolean")},init:{optional:true,validate:(0, _utils.assertNodeType)("Expression")}}}),defineType("WhileStatement",{visitor:["test","body"],aliases:["Statement","BlockParent","Loop","While","Scopable"],fields:{test:{validate:(0, _utils.assertNodeType)("Expression")},body:{validate:(0, _utils.assertNodeType)("Statement")}}}),defineType("WithStatement",{visitor:["object","body"],aliases:["Statement"],fields:{object:{validate:(0, _utils.assertNodeType)("Expression")},body:{validate:(0, _utils.assertNodeType)("Statement")}}}),defineType("AssignmentPattern",{visitor:["left","right","decorators"],builder:["left","right"],aliases:["Pattern","PatternLike","LVal"],fields:Object.assign({},patternLikeCommon(),{left:{validate:(0, _utils.assertNodeType)("Identifier","ObjectPattern","ArrayPattern","MemberExpression","TSAsExpression","TSSatisfiesExpression","TSTypeAssertion","TSNonNullExpression")},right:{validate:(0, _utils.assertNodeType)("Expression")},decorators:{validate:(0, _utils.arrayOfType)("Decorator"),optional:true}})}),defineType("ArrayPattern",{visitor:["elements","typeAnnotation"],builder:["elements"],aliases:["Pattern","PatternLike","LVal"],fields:Object.assign({},patternLikeCommon(),{elements:{validate:(0, _utils.chain)((0, _utils.assertValueType)("array"),(0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null","PatternLike","LVal")))}})}),defineType("ArrowFunctionExpression",{builder:["params","body","async"],visitor:["typeParameters","params","returnType","body"],aliases:["Scopable","Function","BlockParent","FunctionParent","Expression","Pureish"],fields:Object.assign({},functionCommon(),functionTypeAnnotationCommon(),{expression:{validate:(0, _utils.assertValueType)("boolean")},body:{validate:(0, _utils.assertNodeType)("BlockStatement","Expression")},predicate:{validate:(0, _utils.assertNodeType)("DeclaredPredicate","InferredPredicate"),optional:true}})}),defineType("ClassBody",{visitor:["body"],fields:{body:(0, _utils.validateArrayOfType)("ClassMethod","ClassPrivateMethod","ClassProperty","ClassPrivateProperty","ClassAccessorProperty","TSDeclareMethod","TSIndexSignature","StaticBlock")}}),defineType("ClassExpression",{builder:["id","superClass","body","decorators"],visitor:["decorators","id","typeParameters","superClass","superTypeParameters","mixins","implements","body"],aliases:["Scopable","Class","Expression"],fields:{id:{validate:(0, _utils.assertNodeType)("Identifier"),optional:true},typeParameters:{validate:(0, _utils.assertNodeType)("TypeParameterDeclaration","TSTypeParameterDeclaration","Noop"),optional:true},body:{validate:(0, _utils.assertNodeType)("ClassBody")},superClass:{optional:true,validate:(0, _utils.assertNodeType)("Expression")},superTypeParameters:{validate:(0, _utils.assertNodeType)("TypeParameterInstantiation","TSTypeParameterInstantiation"),optional:true},implements:{validate:(0, _utils.arrayOfType)("TSExpressionWithTypeArguments","ClassImplements"),optional:true},decorators:{validate:(0, _utils.arrayOfType)("Decorator"),optional:true},mixins:{validate:(0, _utils.assertNodeType)("InterfaceExtends"),optional:true}}}),defineType("ClassDeclaration",{inherits:"ClassExpression",aliases:["Scopable","Class","Statement","Declaration"],fields:{id:{validate:(0, _utils.assertNodeType)("Identifier"),optional:true},typeParameters:{validate:(0, _utils.assertNodeType)("TypeParameterDeclaration","TSTypeParameterDeclaration","Noop"),optional:true},body:{validate:(0, _utils.assertNodeType)("ClassBody")},superClass:{optional:true,validate:(0, _utils.assertNodeType)("Expression")},superTypeParameters:{validate:(0, _utils.assertNodeType)("TypeParameterInstantiation","TSTypeParameterInstantiation"),optional:true},implements:{validate:(0, _utils.arrayOfType)("TSExpressionWithTypeArguments","ClassImplements"),optional:true},decorators:{validate:(0, _utils.arrayOfType)("Decorator"),optional:true},mixins:{validate:(0, _utils.assertNodeType)("InterfaceExtends"),optional:true},declare:{validate:(0, _utils.assertValueType)("boolean"),optional:true},abstract:{validate:(0, _utils.assertValueType)("boolean"),optional:true}},validate:process.env.BABEL_TYPES_8_BREAKING?function(){const identifier=(0, _utils.assertNodeType)("Identifier");return function(parent,key,node){(0, _is.default)("ExportDefaultDeclaration",parent)||identifier(node,"id",node.id);}}():void 0});const importAttributes=exports.importAttributes={attributes:{optional:true,validate:(0, _utils.arrayOfType)("ImportAttribute")},assertions:{deprecated:true,optional:true,validate:(0, _utils.arrayOfType)("ImportAttribute")}};defineType("ExportAllDeclaration",{builder:["source"],visitor:["source","attributes","assertions"],aliases:["Statement","Declaration","ImportOrExportDeclaration","ExportDeclaration"],fields:Object.assign({source:{validate:(0, _utils.assertNodeType)("StringLiteral")},exportKind:(0, _utils.validateOptional)((0, _utils.assertOneOf)("type","value"))},importAttributes)}),defineType("ExportDefaultDeclaration",{visitor:["declaration"],aliases:["Statement","Declaration","ImportOrExportDeclaration","ExportDeclaration"],fields:{declaration:(0, _utils.validateType)("TSDeclareFunction","FunctionDeclaration","ClassDeclaration","Expression"),exportKind:(0, _utils.validateOptional)((0, _utils.assertOneOf)("value"))}}),defineType("ExportNamedDeclaration",{builder:["declaration","specifiers","source"],visitor:process.env?["declaration","specifiers","source","attributes"]:["declaration","specifiers","source","attributes","assertions"],aliases:["Statement","Declaration","ImportOrExportDeclaration","ExportDeclaration"],fields:Object.assign({declaration:{optional:true,validate:process.env.BABEL_TYPES_8_BREAKING?(0, _utils.chain)((0, _utils.assertNodeType)("Declaration"),Object.assign((function(node,key,val){if(val&&node.specifiers.length)throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");if(val&&node.source)throw new TypeError("Cannot export a declaration from a source")}),{oneOfNodeTypes:["Declaration"]})):(0, _utils.assertNodeType)("Declaration")}},importAttributes,{specifiers:{default:[],validate:(0, _utils.arrayOf)(function(){const sourced=(0, _utils.assertNodeType)("ExportSpecifier","ExportDefaultSpecifier","ExportNamespaceSpecifier"),sourceless=(0, _utils.assertNodeType)("ExportSpecifier");return process.env.BABEL_TYPES_8_BREAKING?Object.assign((function(node,key,val){(node.source?sourced:sourceless)(node,key,val);}),{oneOfNodeTypes:["ExportSpecifier","ExportDefaultSpecifier","ExportNamespaceSpecifier"]}):sourced}())},source:{validate:(0, _utils.assertNodeType)("StringLiteral"),optional:true},exportKind:(0, _utils.validateOptional)((0, _utils.assertOneOf)("type","value"))})}),defineType("ExportSpecifier",{visitor:["local","exported"],aliases:["ModuleSpecifier"],fields:{local:{validate:(0, _utils.assertNodeType)("Identifier")},exported:{validate:(0, _utils.assertNodeType)("Identifier","StringLiteral")},exportKind:{validate:(0, _utils.assertOneOf)("type","value"),optional:true}}}),defineType("ForOfStatement",{visitor:["left","right","body"],builder:["left","right","body","await"],aliases:["Scopable","Statement","For","BlockParent","Loop","ForXStatement"],fields:{left:{validate:function(){if(!process.env.BABEL_TYPES_8_BREAKING)return (0, _utils.assertNodeType)("VariableDeclaration","LVal");const declaration=(0, _utils.assertNodeType)("VariableDeclaration"),lval=(0, _utils.assertNodeType)("Identifier","MemberExpression","ArrayPattern","ObjectPattern","TSAsExpression","TSSatisfiesExpression","TSTypeAssertion","TSNonNullExpression");return Object.assign((function(node,key,val){(0, _is.default)("VariableDeclaration",val)?declaration(node,key,val):lval(node,key,val);}),{oneOfNodeTypes:["VariableDeclaration","Identifier","MemberExpression","ArrayPattern","ObjectPattern","TSAsExpression","TSSatisfiesExpression","TSTypeAssertion","TSNonNullExpression"]})}()},right:{validate:(0, _utils.assertNodeType)("Expression")},body:{validate:(0, _utils.assertNodeType)("Statement")},await:{default:false}}}),defineType("ImportDeclaration",{builder:["specifiers","source"],visitor:["specifiers","source","attributes","assertions"],aliases:["Statement","Declaration","ImportOrExportDeclaration"],fields:Object.assign({},importAttributes,{module:{optional:true,validate:(0, _utils.assertValueType)("boolean")},phase:{default:null,validate:(0, _utils.assertOneOf)("source","defer")},specifiers:(0, _utils.validateArrayOfType)("ImportSpecifier","ImportDefaultSpecifier","ImportNamespaceSpecifier"),source:{validate:(0, _utils.assertNodeType)("StringLiteral")},importKind:{validate:(0, _utils.assertOneOf)("type","typeof","value"),optional:true}})}),defineType("ImportDefaultSpecifier",{visitor:["local"],aliases:["ModuleSpecifier"],fields:{local:{validate:(0, _utils.assertNodeType)("Identifier")}}}),defineType("ImportNamespaceSpecifier",{visitor:["local"],aliases:["ModuleSpecifier"],fields:{local:{validate:(0, _utils.assertNodeType)("Identifier")}}}),defineType("ImportSpecifier",{visitor:["imported","local"],builder:["local","imported"],aliases:["ModuleSpecifier"],fields:{local:{validate:(0, _utils.assertNodeType)("Identifier")},imported:{validate:(0, _utils.assertNodeType)("Identifier","StringLiteral")},importKind:{validate:(0, _utils.assertOneOf)("type","typeof","value"),optional:true}}}),defineType("ImportExpression",{visitor:["source","options"],aliases:["Expression"],fields:{phase:{default:null,validate:(0, _utils.assertOneOf)("source","defer")},source:{validate:(0, _utils.assertNodeType)("Expression")},options:{validate:(0, _utils.assertNodeType)("Expression"),optional:true}}}),defineType("MetaProperty",{visitor:["meta","property"],aliases:["Expression"],fields:{meta:{validate:process.env.BABEL_TYPES_8_BREAKING?(0, _utils.chain)((0, _utils.assertNodeType)("Identifier"),Object.assign((function(node,key,val){let property;switch(val.name){case "function":property="sent";break;case "new":property="target";break;case "import":property="meta";}if(!(0, _is.default)("Identifier",node.property,{name:property}))throw new TypeError("Unrecognised MetaProperty")}),{oneOfNodeTypes:["Identifier"]})):(0, _utils.assertNodeType)("Identifier")},property:{validate:(0, _utils.assertNodeType)("Identifier")}}});const classMethodOrPropertyCommon=()=>({abstract:{validate:(0, _utils.assertValueType)("boolean"),optional:true},accessibility:{validate:(0, _utils.assertOneOf)("public","private","protected"),optional:true},static:{default:false},override:{default:false},computed:{default:false},optional:{validate:(0, _utils.assertValueType)("boolean"),optional:true},key:{validate:(0, _utils.chain)(function(){const normal=(0, _utils.assertNodeType)("Identifier","StringLiteral","NumericLiteral","BigIntLiteral"),computed=(0, _utils.assertNodeType)("Expression");return function(node,key,val){(node.computed?computed:normal)(node,key,val);}}(),(0, _utils.assertNodeType)("Identifier","StringLiteral","NumericLiteral","BigIntLiteral","Expression"))}});exports.classMethodOrPropertyCommon=classMethodOrPropertyCommon;const classMethodOrDeclareMethodCommon=()=>Object.assign({},functionCommon(),classMethodOrPropertyCommon(),{params:(0, _utils.validateArrayOfType)("Identifier","Pattern","RestElement","TSParameterProperty"),kind:{validate:(0, _utils.assertOneOf)("get","set","method","constructor"),default:"method"},access:{validate:(0, _utils.chain)((0, _utils.assertValueType)("string"),(0, _utils.assertOneOf)("public","private","protected")),optional:true},decorators:{validate:(0, _utils.arrayOfType)("Decorator"),optional:true}});exports.classMethodOrDeclareMethodCommon=classMethodOrDeclareMethodCommon,defineType("ClassMethod",{aliases:["Function","Scopable","BlockParent","FunctionParent","Method"],builder:["kind","key","params","body","computed","static","generator","async"],visitor:["decorators","key","typeParameters","params","returnType","body"],fields:Object.assign({},classMethodOrDeclareMethodCommon(),functionTypeAnnotationCommon(),{body:{validate:(0, _utils.assertNodeType)("BlockStatement")}})}),defineType("ObjectPattern",{visitor:["properties","typeAnnotation","decorators"],builder:["properties"],aliases:["Pattern","PatternLike","LVal"],fields:Object.assign({},patternLikeCommon(),{properties:(0, _utils.validateArrayOfType)("RestElement","ObjectProperty")})}),defineType("SpreadElement",{visitor:["argument"],aliases:["UnaryLike"],deprecatedAlias:"SpreadProperty",fields:{argument:{validate:(0, _utils.assertNodeType)("Expression")}}}),defineType("Super",{aliases:["Expression"]}),defineType("TaggedTemplateExpression",{visitor:["tag","typeParameters","quasi"],builder:["tag","quasi"],aliases:["Expression"],fields:{tag:{validate:(0, _utils.assertNodeType)("Expression")},quasi:{validate:(0, _utils.assertNodeType)("TemplateLiteral")},typeParameters:{validate:(0, _utils.assertNodeType)("TypeParameterInstantiation","TSTypeParameterInstantiation"),optional:true}}}),defineType("TemplateElement",{builder:["value","tail"],fields:{value:{validate:(0, _utils.chain)((0, _utils.assertShape)({raw:{validate:(0, _utils.assertValueType)("string")},cooked:{validate:(0, _utils.assertValueType)("string"),optional:true}}),(function(node){const raw=node.value.raw;let unterminatedCalled=false;const error=()=>{throw new Error("Internal @babel/types error.")},{str,firstInvalidLoc}=(0, _helperStringParser.readStringContents)("template",raw,0,0,0,{unterminated(){unterminatedCalled=true;},strictNumericEscape:error,invalidEscapeSequence:error,numericSeparatorInEscapeSequence:error,unexpectedNumericSeparator:error,invalidDigit:error,invalidCodePoint:error});if(!unterminatedCalled)throw new Error("Invalid raw");node.value.cooked=firstInvalidLoc?null:str;}))},tail:{default:false}}}),defineType("TemplateLiteral",{visitor:["quasis","expressions"],aliases:["Expression","Literal"],fields:{quasis:(0, _utils.validateArrayOfType)("TemplateElement"),expressions:{validate:(0, _utils.chain)((0, _utils.assertValueType)("array"),(0, _utils.assertEach)((0, _utils.assertNodeType)("Expression","TSType")),(function(node,key,val){if(node.quasis.length!==val.length+1)throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of expressions.\nExpected ${val.length+1} quasis but got ${node.quasis.length}`)}))}}}),defineType("YieldExpression",{builder:["argument","delegate"],visitor:["argument"],aliases:["Expression","Terminatorless"],fields:{delegate:{validate:process.env.BABEL_TYPES_8_BREAKING?(0, _utils.chain)((0, _utils.assertValueType)("boolean"),Object.assign((function(node,key,val){if(val&&!node.argument)throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument")}),{type:"boolean"})):(0, _utils.assertValueType)("boolean"),default:false},argument:{optional:true,validate:(0, _utils.assertNodeType)("Expression")}}}),defineType("AwaitExpression",{builder:["argument"],visitor:["argument"],aliases:["Expression","Terminatorless"],fields:{argument:{validate:(0, _utils.assertNodeType)("Expression")}}}),defineType("Import",{aliases:["Expression"]}),defineType("BigIntLiteral",{builder:["value"],fields:{value:{validate:(0, _utils.assertValueType)("string")}},aliases:["Expression","Pureish","Literal","Immutable"]}),defineType("ExportNamespaceSpecifier",{visitor:["exported"],aliases:["ModuleSpecifier"],fields:{exported:{validate:(0, _utils.assertNodeType)("Identifier")}}}),defineType("OptionalMemberExpression",{builder:["object","property","computed","optional"],visitor:["object","property"],aliases:["Expression"],fields:{object:{validate:(0, _utils.assertNodeType)("Expression")},property:{validate:function(){const normal=(0, _utils.assertNodeType)("Identifier"),computed=(0, _utils.assertNodeType)("Expression");return Object.assign((function(node,key,val){(node.computed?computed:normal)(node,key,val);}),{oneOfNodeTypes:["Expression","Identifier"]})}()},computed:{default:false},optional:{validate:process.env.BABEL_TYPES_8_BREAKING?(0, _utils.chain)((0, _utils.assertValueType)("boolean"),(0, _utils.assertOptionalChainStart)()):(0, _utils.assertValueType)("boolean")}}}),defineType("OptionalCallExpression",{visitor:["callee","arguments","typeParameters","typeArguments"],builder:["callee","arguments","optional"],aliases:["Expression"],fields:{callee:{validate:(0, _utils.assertNodeType)("Expression")},arguments:(0, _utils.validateArrayOfType)("Expression","SpreadElement","ArgumentPlaceholder"),optional:{validate:process.env.BABEL_TYPES_8_BREAKING?(0, _utils.chain)((0, _utils.assertValueType)("boolean"),(0, _utils.assertOptionalChainStart)()):(0, _utils.assertValueType)("boolean")},typeArguments:{validate:(0, _utils.assertNodeType)("TypeParameterInstantiation"),optional:true},typeParameters:{validate:(0, _utils.assertNodeType)("TSTypeParameterInstantiation"),optional:true}}}),defineType("ClassProperty",{visitor:["decorators","key","typeAnnotation","value"],builder:["key","value","typeAnnotation","decorators","computed","static"],aliases:["Property"],fields:Object.assign({},classMethodOrPropertyCommon(),{value:{validate:(0, _utils.assertNodeType)("Expression"),optional:true},definite:{validate:(0, _utils.assertValueType)("boolean"),optional:true},typeAnnotation:{validate:(0, _utils.assertNodeType)("TypeAnnotation","TSTypeAnnotation","Noop"),optional:true},decorators:{validate:(0, _utils.arrayOfType)("Decorator"),optional:true},readonly:{validate:(0, _utils.assertValueType)("boolean"),optional:true},declare:{validate:(0, _utils.assertValueType)("boolean"),optional:true},variance:{validate:(0, _utils.assertNodeType)("Variance"),optional:true}})}),defineType("ClassAccessorProperty",{visitor:["decorators","key","typeAnnotation","value"],builder:["key","value","typeAnnotation","decorators","computed","static"],aliases:["Property","Accessor"],fields:Object.assign({},classMethodOrPropertyCommon(),{key:{validate:(0, _utils.chain)(function(){const normal=(0, _utils.assertNodeType)("Identifier","StringLiteral","NumericLiteral","BigIntLiteral","PrivateName"),computed=(0, _utils.assertNodeType)("Expression");return function(node,key,val){(node.computed?computed:normal)(node,key,val);}}(),(0, _utils.assertNodeType)("Identifier","StringLiteral","NumericLiteral","BigIntLiteral","Expression","PrivateName"))},value:{validate:(0, _utils.assertNodeType)("Expression"),optional:true},definite:{validate:(0, _utils.assertValueType)("boolean"),optional:true},typeAnnotation:{validate:(0, _utils.assertNodeType)("TypeAnnotation","TSTypeAnnotation","Noop"),optional:true},decorators:{validate:(0, _utils.arrayOfType)("Decorator"),optional:true},readonly:{validate:(0, _utils.assertValueType)("boolean"),optional:true},declare:{validate:(0, _utils.assertValueType)("boolean"),optional:true},variance:{validate:(0, _utils.assertNodeType)("Variance"),optional:true}})}),defineType("ClassPrivateProperty",{visitor:["decorators","key","typeAnnotation","value"],builder:["key","value","decorators","static"],aliases:["Property","Private"],fields:{key:{validate:(0, _utils.assertNodeType)("PrivateName")},value:{validate:(0, _utils.assertNodeType)("Expression"),optional:true},typeAnnotation:{validate:(0, _utils.assertNodeType)("TypeAnnotation","TSTypeAnnotation","Noop"),optional:true},decorators:{validate:(0, _utils.arrayOfType)("Decorator"),optional:true},static:{validate:(0, _utils.assertValueType)("boolean"),default:false},readonly:{validate:(0, _utils.assertValueType)("boolean"),optional:true},definite:{validate:(0, _utils.assertValueType)("boolean"),optional:true},variance:{validate:(0, _utils.assertNodeType)("Variance"),optional:true}}}),defineType("ClassPrivateMethod",{builder:["kind","key","params","body","static"],visitor:["decorators","key","typeParameters","params","returnType","body"],aliases:["Function","Scopable","BlockParent","FunctionParent","Method","Private"],fields:Object.assign({},classMethodOrDeclareMethodCommon(),functionTypeAnnotationCommon(),{kind:{validate:(0, _utils.assertOneOf)("get","set","method"),default:"method"},key:{validate:(0, _utils.assertNodeType)("PrivateName")},body:{validate:(0, _utils.assertNodeType)("BlockStatement")}})}),defineType("PrivateName",{visitor:["id"],aliases:["Private"],fields:{id:{validate:(0, _utils.assertNodeType)("Identifier")}}}),defineType("StaticBlock",{visitor:["body"],fields:{body:(0, _utils.validateArrayOfType)("Statement")},aliases:["Scopable","BlockParent","FunctionParent"]});},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/deprecated-aliases.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.DEPRECATED_ALIASES=void 0;exports.DEPRECATED_ALIASES={ModuleDeclaration:"ImportOrExportDeclaration"};},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/experimental.js":(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{var _utils=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/utils.js");(0, _utils.default)("ArgumentPlaceholder",{}),(0, _utils.default)("BindExpression",{visitor:["object","callee"],aliases:["Expression"],fields:process.env.BABEL_TYPES_8_BREAKING?{object:{validate:(0, _utils.assertNodeType)("Expression")},callee:{validate:(0, _utils.assertNodeType)("Expression")}}:{object:{validate:Object.assign((()=>{}),{oneOfNodeTypes:["Expression"]})},callee:{validate:Object.assign((()=>{}),{oneOfNodeTypes:["Expression"]})}}}),(0, _utils.default)("ImportAttribute",{visitor:["key","value"],fields:{key:{validate:(0, _utils.assertNodeType)("Identifier","StringLiteral")},value:{validate:(0, _utils.assertNodeType)("StringLiteral")}}}),(0, _utils.default)("Decorator",{visitor:["expression"],fields:{expression:{validate:(0, _utils.assertNodeType)("Expression")}}}),(0, _utils.default)("DoExpression",{visitor:["body"],builder:["body","async"],aliases:["Expression"],fields:{body:{validate:(0, _utils.assertNodeType)("BlockStatement")},async:{validate:(0, _utils.assertValueType)("boolean"),default:false}}}),(0, _utils.default)("ExportDefaultSpecifier",{visitor:["exported"],aliases:["ModuleSpecifier"],fields:{exported:{validate:(0, _utils.assertNodeType)("Identifier")}}}),(0, _utils.default)("RecordExpression",{visitor:["properties"],aliases:["Expression"],fields:{properties:(0, _utils.validateArrayOfType)("ObjectProperty","SpreadElement")}}),(0, _utils.default)("TupleExpression",{fields:{elements:{validate:(0, _utils.arrayOfType)("Expression","SpreadElement"),default:[]}},visitor:["elements"],aliases:["Expression"]}),(0, _utils.default)("DecimalLiteral",{builder:["value"],fields:{value:{validate:(0, _utils.assertValueType)("string")}},aliases:["Expression","Pureish","Literal","Immutable"]}),(0, _utils.default)("ModuleExpression",{visitor:["body"],fields:{body:{validate:(0, _utils.assertNodeType)("Program")}},aliases:["Expression"]}),(0, _utils.default)("TopicReference",{aliases:["Expression"]}),(0, _utils.default)("PipelineTopicExpression",{builder:["expression"],visitor:["expression"],fields:{expression:{validate:(0, _utils.assertNodeType)("Expression")}},aliases:["Expression"]}),(0, _utils.default)("PipelineBareFunction",{builder:["callee"],visitor:["callee"],fields:{callee:{validate:(0, _utils.assertNodeType)("Expression")}},aliases:["Expression"]}),(0, _utils.default)("PipelinePrimaryTopicReference",{aliases:["Expression"]});},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/flow.js":(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{var _core=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/core.js"),_utils=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/utils.js");const defineType=(0, _utils.defineAliasedType)("Flow"),defineInterfaceishType=name=>{const isDeclareClass="DeclareClass"===name;defineType(name,{builder:["id","typeParameters","extends","body"],visitor:["id","typeParameters","extends",...isDeclareClass?["mixins","implements"]:[],"body"],aliases:["FlowDeclaration","Statement","Declaration"],fields:Object.assign({id:(0, _utils.validateType)("Identifier"),typeParameters:(0, _utils.validateOptionalType)("TypeParameterDeclaration"),extends:(0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends"))},isDeclareClass?{mixins:(0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),implements:(0, _utils.validateOptional)((0, _utils.arrayOfType)("ClassImplements"))}:{},{body:(0, _utils.validateType)("ObjectTypeAnnotation")})});};defineType("AnyTypeAnnotation",{aliases:["FlowType","FlowBaseAnnotation"]}),defineType("ArrayTypeAnnotation",{visitor:["elementType"],aliases:["FlowType"],fields:{elementType:(0, _utils.validateType)("FlowType")}}),defineType("BooleanTypeAnnotation",{aliases:["FlowType","FlowBaseAnnotation"]}),defineType("BooleanLiteralTypeAnnotation",{builder:["value"],aliases:["FlowType"],fields:{value:(0, _utils.validate)((0, _utils.assertValueType)("boolean"))}}),defineType("NullLiteralTypeAnnotation",{aliases:["FlowType","FlowBaseAnnotation"]}),defineType("ClassImplements",{visitor:["id","typeParameters"],fields:{id:(0, _utils.validateType)("Identifier"),typeParameters:(0, _utils.validateOptionalType)("TypeParameterInstantiation")}}),defineInterfaceishType("DeclareClass"),defineType("DeclareFunction",{visitor:["id"],aliases:["FlowDeclaration","Statement","Declaration"],fields:{id:(0, _utils.validateType)("Identifier"),predicate:(0, _utils.validateOptionalType)("DeclaredPredicate")}}),defineInterfaceishType("DeclareInterface"),defineType("DeclareModule",{builder:["id","body","kind"],visitor:["id","body"],aliases:["FlowDeclaration","Statement","Declaration"],fields:{id:(0, _utils.validateType)("Identifier","StringLiteral"),body:(0, _utils.validateType)("BlockStatement"),kind:(0, _utils.validateOptional)((0, _utils.assertOneOf)("CommonJS","ES"))}}),defineType("DeclareModuleExports",{visitor:["typeAnnotation"],aliases:["FlowDeclaration","Statement","Declaration"],fields:{typeAnnotation:(0, _utils.validateType)("TypeAnnotation")}}),defineType("DeclareTypeAlias",{visitor:["id","typeParameters","right"],aliases:["FlowDeclaration","Statement","Declaration"],fields:{id:(0, _utils.validateType)("Identifier"),typeParameters:(0, _utils.validateOptionalType)("TypeParameterDeclaration"),right:(0, _utils.validateType)("FlowType")}}),defineType("DeclareOpaqueType",{visitor:["id","typeParameters","supertype"],aliases:["FlowDeclaration","Statement","Declaration"],fields:{id:(0, _utils.validateType)("Identifier"),typeParameters:(0, _utils.validateOptionalType)("TypeParameterDeclaration"),supertype:(0, _utils.validateOptionalType)("FlowType"),impltype:(0, _utils.validateOptionalType)("FlowType")}}),defineType("DeclareVariable",{visitor:["id"],aliases:["FlowDeclaration","Statement","Declaration"],fields:{id:(0, _utils.validateType)("Identifier")}}),defineType("DeclareExportDeclaration",{visitor:["declaration","specifiers","source","attributes"],aliases:["FlowDeclaration","Statement","Declaration"],fields:Object.assign({declaration:(0, _utils.validateOptionalType)("Flow"),specifiers:(0, _utils.validateOptional)((0, _utils.arrayOfType)("ExportSpecifier","ExportNamespaceSpecifier")),source:(0, _utils.validateOptionalType)("StringLiteral"),default:(0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))},_core.importAttributes)}),defineType("DeclareExportAllDeclaration",{visitor:["source","attributes"],aliases:["FlowDeclaration","Statement","Declaration"],fields:Object.assign({source:(0, _utils.validateType)("StringLiteral"),exportKind:(0, _utils.validateOptional)((0, _utils.assertOneOf)("type","value"))},_core.importAttributes)}),defineType("DeclaredPredicate",{visitor:["value"],aliases:["FlowPredicate"],fields:{value:(0, _utils.validateType)("Flow")}}),defineType("ExistsTypeAnnotation",{aliases:["FlowType"]}),defineType("FunctionTypeAnnotation",{visitor:["typeParameters","params","rest","returnType"],aliases:["FlowType"],fields:{typeParameters:(0, _utils.validateOptionalType)("TypeParameterDeclaration"),params:(0, _utils.validateArrayOfType)("FunctionTypeParam"),rest:(0, _utils.validateOptionalType)("FunctionTypeParam"),this:(0, _utils.validateOptionalType)("FunctionTypeParam"),returnType:(0, _utils.validateType)("FlowType")}}),defineType("FunctionTypeParam",{visitor:["name","typeAnnotation"],fields:{name:(0, _utils.validateOptionalType)("Identifier"),typeAnnotation:(0, _utils.validateType)("FlowType"),optional:(0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))}}),defineType("GenericTypeAnnotation",{visitor:["id","typeParameters"],aliases:["FlowType"],fields:{id:(0, _utils.validateType)("Identifier","QualifiedTypeIdentifier"),typeParameters:(0, _utils.validateOptionalType)("TypeParameterInstantiation")}}),defineType("InferredPredicate",{aliases:["FlowPredicate"]}),defineType("InterfaceExtends",{visitor:["id","typeParameters"],fields:{id:(0, _utils.validateType)("Identifier","QualifiedTypeIdentifier"),typeParameters:(0, _utils.validateOptionalType)("TypeParameterInstantiation")}}),defineInterfaceishType("InterfaceDeclaration"),defineType("InterfaceTypeAnnotation",{visitor:["extends","body"],aliases:["FlowType"],fields:{extends:(0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),body:(0, _utils.validateType)("ObjectTypeAnnotation")}}),defineType("IntersectionTypeAnnotation",{visitor:["types"],aliases:["FlowType"],fields:{types:(0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))}}),defineType("MixedTypeAnnotation",{aliases:["FlowType","FlowBaseAnnotation"]}),defineType("EmptyTypeAnnotation",{aliases:["FlowType","FlowBaseAnnotation"]}),defineType("NullableTypeAnnotation",{visitor:["typeAnnotation"],aliases:["FlowType"],fields:{typeAnnotation:(0, _utils.validateType)("FlowType")}}),defineType("NumberLiteralTypeAnnotation",{builder:["value"],aliases:["FlowType"],fields:{value:(0, _utils.validate)((0, _utils.assertValueType)("number"))}}),defineType("NumberTypeAnnotation",{aliases:["FlowType","FlowBaseAnnotation"]}),defineType("ObjectTypeAnnotation",{visitor:["properties","indexers","callProperties","internalSlots"],aliases:["FlowType"],builder:["properties","indexers","callProperties","internalSlots","exact"],fields:{properties:(0, _utils.validate)((0, _utils.arrayOfType)("ObjectTypeProperty","ObjectTypeSpreadProperty")),indexers:{validate:(0, _utils.arrayOfType)("ObjectTypeIndexer"),optional:true,default:[]},callProperties:{validate:(0, _utils.arrayOfType)("ObjectTypeCallProperty"),optional:true,default:[]},internalSlots:{validate:(0, _utils.arrayOfType)("ObjectTypeInternalSlot"),optional:true,default:[]},exact:{validate:(0, _utils.assertValueType)("boolean"),default:false},inexact:(0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))}}),defineType("ObjectTypeInternalSlot",{visitor:["id","value"],builder:["id","value","optional","static","method"],aliases:["UserWhitespacable"],fields:{id:(0, _utils.validateType)("Identifier"),value:(0, _utils.validateType)("FlowType"),optional:(0, _utils.validate)((0, _utils.assertValueType)("boolean")),static:(0, _utils.validate)((0, _utils.assertValueType)("boolean")),method:(0, _utils.validate)((0, _utils.assertValueType)("boolean"))}}),defineType("ObjectTypeCallProperty",{visitor:["value"],aliases:["UserWhitespacable"],fields:{value:(0, _utils.validateType)("FlowType"),static:(0, _utils.validate)((0, _utils.assertValueType)("boolean"))}}),defineType("ObjectTypeIndexer",{visitor:["variance","id","key","value"],builder:["id","key","value","variance"],aliases:["UserWhitespacable"],fields:{id:(0, _utils.validateOptionalType)("Identifier"),key:(0, _utils.validateType)("FlowType"),value:(0, _utils.validateType)("FlowType"),static:(0, _utils.validate)((0, _utils.assertValueType)("boolean")),variance:(0, _utils.validateOptionalType)("Variance")}}),defineType("ObjectTypeProperty",{visitor:["key","value","variance"],aliases:["UserWhitespacable"],fields:{key:(0, _utils.validateType)("Identifier","StringLiteral"),value:(0, _utils.validateType)("FlowType"),kind:(0, _utils.validate)((0, _utils.assertOneOf)("init","get","set")),static:(0, _utils.validate)((0, _utils.assertValueType)("boolean")),proto:(0, _utils.validate)((0, _utils.assertValueType)("boolean")),optional:(0, _utils.validate)((0, _utils.assertValueType)("boolean")),variance:(0, _utils.validateOptionalType)("Variance"),method:(0, _utils.validate)((0, _utils.assertValueType)("boolean"))}}),defineType("ObjectTypeSpreadProperty",{visitor:["argument"],aliases:["UserWhitespacable"],fields:{argument:(0, _utils.validateType)("FlowType")}}),defineType("OpaqueType",{visitor:["id","typeParameters","supertype","impltype"],aliases:["FlowDeclaration","Statement","Declaration"],fields:{id:(0, _utils.validateType)("Identifier"),typeParameters:(0, _utils.validateOptionalType)("TypeParameterDeclaration"),supertype:(0, _utils.validateOptionalType)("FlowType"),impltype:(0, _utils.validateType)("FlowType")}}),defineType("QualifiedTypeIdentifier",{visitor:["qualification","id"],builder:["id","qualification"],fields:{id:(0, _utils.validateType)("Identifier"),qualification:(0, _utils.validateType)("Identifier","QualifiedTypeIdentifier")}}),defineType("StringLiteralTypeAnnotation",{builder:["value"],aliases:["FlowType"],fields:{value:(0, _utils.validate)((0, _utils.assertValueType)("string"))}}),defineType("StringTypeAnnotation",{aliases:["FlowType","FlowBaseAnnotation"]}),defineType("SymbolTypeAnnotation",{aliases:["FlowType","FlowBaseAnnotation"]}),defineType("ThisTypeAnnotation",{aliases:["FlowType","FlowBaseAnnotation"]}),defineType("TupleTypeAnnotation",{visitor:["types"],aliases:["FlowType"],fields:{types:(0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))}}),defineType("TypeofTypeAnnotation",{visitor:["argument"],aliases:["FlowType"],fields:{argument:(0, _utils.validateType)("FlowType")}}),defineType("TypeAlias",{visitor:["id","typeParameters","right"],aliases:["FlowDeclaration","Statement","Declaration"],fields:{id:(0, _utils.validateType)("Identifier"),typeParameters:(0, _utils.validateOptionalType)("TypeParameterDeclaration"),right:(0, _utils.validateType)("FlowType")}}),defineType("TypeAnnotation",{visitor:["typeAnnotation"],fields:{typeAnnotation:(0, _utils.validateType)("FlowType")}}),defineType("TypeCastExpression",{visitor:["expression","typeAnnotation"],aliases:["ExpressionWrapper","Expression"],fields:{expression:(0, _utils.validateType)("Expression"),typeAnnotation:(0, _utils.validateType)("TypeAnnotation")}}),defineType("TypeParameter",{visitor:["bound","default","variance"],fields:{name:(0, _utils.validate)((0, _utils.assertValueType)("string")),bound:(0, _utils.validateOptionalType)("TypeAnnotation"),default:(0, _utils.validateOptionalType)("FlowType"),variance:(0, _utils.validateOptionalType)("Variance")}}),defineType("TypeParameterDeclaration",{visitor:["params"],fields:{params:(0, _utils.validate)((0, _utils.arrayOfType)("TypeParameter"))}}),defineType("TypeParameterInstantiation",{visitor:["params"],fields:{params:(0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))}}),defineType("UnionTypeAnnotation",{visitor:["types"],aliases:["FlowType"],fields:{types:(0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))}}),defineType("Variance",{builder:["kind"],fields:{kind:(0, _utils.validate)((0, _utils.assertOneOf)("minus","plus"))}}),defineType("VoidTypeAnnotation",{aliases:["FlowType","FlowBaseAnnotation"]}),defineType("EnumDeclaration",{aliases:["Statement","Declaration"],visitor:["id","body"],fields:{id:(0, _utils.validateType)("Identifier"),body:(0, _utils.validateType)("EnumBooleanBody","EnumNumberBody","EnumStringBody","EnumSymbolBody")}}),defineType("EnumBooleanBody",{aliases:["EnumBody"],visitor:["members"],fields:{explicitType:(0, _utils.validate)((0, _utils.assertValueType)("boolean")),members:(0, _utils.validateArrayOfType)("EnumBooleanMember"),hasUnknownMembers:(0, _utils.validate)((0, _utils.assertValueType)("boolean"))}}),defineType("EnumNumberBody",{aliases:["EnumBody"],visitor:["members"],fields:{explicitType:(0, _utils.validate)((0, _utils.assertValueType)("boolean")),members:(0, _utils.validateArrayOfType)("EnumNumberMember"),hasUnknownMembers:(0, _utils.validate)((0, _utils.assertValueType)("boolean"))}}),defineType("EnumStringBody",{aliases:["EnumBody"],visitor:["members"],fields:{explicitType:(0, _utils.validate)((0, _utils.assertValueType)("boolean")),members:(0, _utils.validateArrayOfType)("EnumStringMember","EnumDefaultedMember"),hasUnknownMembers:(0, _utils.validate)((0, _utils.assertValueType)("boolean"))}}),defineType("EnumSymbolBody",{aliases:["EnumBody"],visitor:["members"],fields:{members:(0, _utils.validateArrayOfType)("EnumDefaultedMember"),hasUnknownMembers:(0, _utils.validate)((0, _utils.assertValueType)("boolean"))}}),defineType("EnumBooleanMember",{aliases:["EnumMember"],visitor:["id"],fields:{id:(0, _utils.validateType)("Identifier"),init:(0, _utils.validateType)("BooleanLiteral")}}),defineType("EnumNumberMember",{aliases:["EnumMember"],visitor:["id","init"],fields:{id:(0, _utils.validateType)("Identifier"),init:(0, _utils.validateType)("NumericLiteral")}}),defineType("EnumStringMember",{aliases:["EnumMember"],visitor:["id","init"],fields:{id:(0, _utils.validateType)("Identifier"),init:(0, _utils.validateType)("StringLiteral")}}),defineType("EnumDefaultedMember",{aliases:["EnumMember"],visitor:["id"],fields:{id:(0, _utils.validateType)("Identifier")}}),defineType("IndexedAccessType",{visitor:["objectType","indexType"],aliases:["FlowType"],fields:{objectType:(0, _utils.validateType)("FlowType"),indexType:(0, _utils.validateType)("FlowType")}}),defineType("OptionalIndexedAccessType",{visitor:["objectType","indexType"],aliases:["FlowType"],fields:{objectType:(0, _utils.validateType)("FlowType"),indexType:(0, _utils.validateType)("FlowType"),optional:(0, _utils.validate)((0, _utils.assertValueType)("boolean"))}});},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),Object.defineProperty(exports,"ALIAS_KEYS",{enumerable:true,get:function(){return _utils.ALIAS_KEYS}}),Object.defineProperty(exports,"BUILDER_KEYS",{enumerable:true,get:function(){return _utils.BUILDER_KEYS}}),Object.defineProperty(exports,"DEPRECATED_ALIASES",{enumerable:true,get:function(){return _deprecatedAliases.DEPRECATED_ALIASES}}),Object.defineProperty(exports,"DEPRECATED_KEYS",{enumerable:true,get:function(){return _utils.DEPRECATED_KEYS}}),Object.defineProperty(exports,"FLIPPED_ALIAS_KEYS",{enumerable:true,get:function(){return _utils.FLIPPED_ALIAS_KEYS}}),Object.defineProperty(exports,"NODE_FIELDS",{enumerable:true,get:function(){return _utils.NODE_FIELDS}}),Object.defineProperty(exports,"NODE_PARENT_VALIDATIONS",{enumerable:true,get:function(){return _utils.NODE_PARENT_VALIDATIONS}}),Object.defineProperty(exports,"PLACEHOLDERS",{enumerable:true,get:function(){return _placeholders.PLACEHOLDERS}}),Object.defineProperty(exports,"PLACEHOLDERS_ALIAS",{enumerable:true,get:function(){return _placeholders.PLACEHOLDERS_ALIAS}}),Object.defineProperty(exports,"PLACEHOLDERS_FLIPPED_ALIAS",{enumerable:true,get:function(){return _placeholders.PLACEHOLDERS_FLIPPED_ALIAS}}),exports.TYPES=void 0,Object.defineProperty(exports,"VISITOR_KEYS",{enumerable:true,get:function(){return _utils.VISITOR_KEYS}}),__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/core.js"),__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/flow.js"),__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/jsx.js"),__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/misc.js"),__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/experimental.js"),__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/typescript.js");var _utils=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/utils.js"),_placeholders=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/placeholders.js"),_deprecatedAliases=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/deprecated-aliases.js");Object.keys(_deprecatedAliases.DEPRECATED_ALIASES).forEach((deprecatedAlias=>{_utils.FLIPPED_ALIAS_KEYS[deprecatedAlias]=_utils.FLIPPED_ALIAS_KEYS[_deprecatedAliases.DEPRECATED_ALIASES[deprecatedAlias]];}));exports.TYPES=[].concat(Object.keys(_utils.VISITOR_KEYS),Object.keys(_utils.FLIPPED_ALIAS_KEYS),Object.keys(_utils.DEPRECATED_KEYS));},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/jsx.js":(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{var _utils=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/utils.js");const defineType=(0, _utils.defineAliasedType)("JSX");defineType("JSXAttribute",{visitor:["name","value"],aliases:["Immutable"],fields:{name:{validate:(0, _utils.assertNodeType)("JSXIdentifier","JSXNamespacedName")},value:{optional:true,validate:(0, _utils.assertNodeType)("JSXElement","JSXFragment","StringLiteral","JSXExpressionContainer")}}}),defineType("JSXClosingElement",{visitor:["name"],aliases:["Immutable"],fields:{name:{validate:(0, _utils.assertNodeType)("JSXIdentifier","JSXMemberExpression","JSXNamespacedName")}}}),defineType("JSXElement",{builder:["openingElement","closingElement","children","selfClosing"],visitor:["openingElement","children","closingElement"],aliases:["Immutable","Expression"],fields:Object.assign({openingElement:{validate:(0, _utils.assertNodeType)("JSXOpeningElement")},closingElement:{optional:true,validate:(0, _utils.assertNodeType)("JSXClosingElement")},children:(0, _utils.validateArrayOfType)("JSXText","JSXExpressionContainer","JSXSpreadChild","JSXElement","JSXFragment")},{selfClosing:{validate:(0, _utils.assertValueType)("boolean"),optional:true}})}),defineType("JSXEmptyExpression",{}),defineType("JSXExpressionContainer",{visitor:["expression"],aliases:["Immutable"],fields:{expression:{validate:(0, _utils.assertNodeType)("Expression","JSXEmptyExpression")}}}),defineType("JSXSpreadChild",{visitor:["expression"],aliases:["Immutable"],fields:{expression:{validate:(0, _utils.assertNodeType)("Expression")}}}),defineType("JSXIdentifier",{builder:["name"],fields:{name:{validate:(0, _utils.assertValueType)("string")}}}),defineType("JSXMemberExpression",{visitor:["object","property"],fields:{object:{validate:(0, _utils.assertNodeType)("JSXMemberExpression","JSXIdentifier")},property:{validate:(0, _utils.assertNodeType)("JSXIdentifier")}}}),defineType("JSXNamespacedName",{visitor:["namespace","name"],fields:{namespace:{validate:(0, _utils.assertNodeType)("JSXIdentifier")},name:{validate:(0, _utils.assertNodeType)("JSXIdentifier")}}}),defineType("JSXOpeningElement",{builder:["name","attributes","selfClosing"],visitor:["name","attributes"],aliases:["Immutable"],fields:{name:{validate:(0, _utils.assertNodeType)("JSXIdentifier","JSXMemberExpression","JSXNamespacedName")},selfClosing:{default:false},attributes:(0, _utils.validateArrayOfType)("JSXAttribute","JSXSpreadAttribute"),typeParameters:{validate:(0, _utils.assertNodeType)("TypeParameterInstantiation","TSTypeParameterInstantiation"),optional:true}}}),defineType("JSXSpreadAttribute",{visitor:["argument"],fields:{argument:{validate:(0, _utils.assertNodeType)("Expression")}}}),defineType("JSXText",{aliases:["Immutable"],builder:["value"],fields:{value:{validate:(0, _utils.assertValueType)("string")}}}),defineType("JSXFragment",{builder:["openingFragment","closingFragment","children"],visitor:["openingFragment","children","closingFragment"],aliases:["Immutable","Expression"],fields:{openingFragment:{validate:(0, _utils.assertNodeType)("JSXOpeningFragment")},closingFragment:{validate:(0, _utils.assertNodeType)("JSXClosingFragment")},children:(0, _utils.validateArrayOfType)("JSXText","JSXExpressionContainer","JSXSpreadChild","JSXElement","JSXFragment")}}),defineType("JSXOpeningFragment",{aliases:["Immutable"]}),defineType("JSXClosingFragment",{aliases:["Immutable"]});},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/misc.js":(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{var _utils=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/utils.js"),_placeholders=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/placeholders.js"),_core=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/core.js");const defineType=(0, _utils.defineAliasedType)("Miscellaneous");defineType("Noop",{visitor:[]}),defineType("Placeholder",{visitor:[],builder:["expectedNode","name"],fields:Object.assign({name:{validate:(0, _utils.assertNodeType)("Identifier")},expectedNode:{validate:(0, _utils.assertOneOf)(..._placeholders.PLACEHOLDERS)}},(0, _core.patternLikeCommon)())}),defineType("V8IntrinsicIdentifier",{builder:["name"],fields:{name:{validate:(0, _utils.assertValueType)("string")}}});},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/placeholders.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.PLACEHOLDERS_FLIPPED_ALIAS=exports.PLACEHOLDERS_ALIAS=exports.PLACEHOLDERS=void 0;var _utils=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/utils.js");const PLACEHOLDERS=exports.PLACEHOLDERS=["Identifier","StringLiteral","Expression","Statement","Declaration","BlockStatement","ClassBody","Pattern"],PLACEHOLDERS_ALIAS=exports.PLACEHOLDERS_ALIAS={Declaration:["Statement"],Pattern:["PatternLike","LVal"]};for(const type of PLACEHOLDERS){const alias=_utils.ALIAS_KEYS[type];null!=alias&&alias.length&&(PLACEHOLDERS_ALIAS[type]=alias);}const PLACEHOLDERS_FLIPPED_ALIAS=exports.PLACEHOLDERS_FLIPPED_ALIAS={};Object.keys(PLACEHOLDERS_ALIAS).forEach((type=>{PLACEHOLDERS_ALIAS[type].forEach((alias=>{hasOwnProperty.call(PLACEHOLDERS_FLIPPED_ALIAS,alias)||(PLACEHOLDERS_FLIPPED_ALIAS[alias]=[]),PLACEHOLDERS_FLIPPED_ALIAS[alias].push(type);}));}));},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/typescript.js":(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{var _utils=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/utils.js"),_core=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/core.js"),_is=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/is.js");const defineType=(0, _utils.defineAliasedType)("TypeScript"),bool=(0, _utils.assertValueType)("boolean"),tSFunctionTypeAnnotationCommon=()=>({returnType:{validate:(0, _utils.assertNodeType)("TSTypeAnnotation","Noop"),optional:true},typeParameters:{validate:(0, _utils.assertNodeType)("TSTypeParameterDeclaration","Noop"),optional:true}});defineType("TSParameterProperty",{aliases:["LVal"],visitor:["parameter"],fields:{accessibility:{validate:(0, _utils.assertOneOf)("public","private","protected"),optional:true},readonly:{validate:(0, _utils.assertValueType)("boolean"),optional:true},parameter:{validate:(0, _utils.assertNodeType)("Identifier","AssignmentPattern")},override:{validate:(0, _utils.assertValueType)("boolean"),optional:true},decorators:{validate:(0, _utils.arrayOfType)("Decorator"),optional:true}}}),defineType("TSDeclareFunction",{aliases:["Statement","Declaration"],visitor:["id","typeParameters","params","returnType"],fields:Object.assign({},(0, _core.functionDeclarationCommon)(),tSFunctionTypeAnnotationCommon())}),defineType("TSDeclareMethod",{visitor:["decorators","key","typeParameters","params","returnType"],fields:Object.assign({},(0, _core.classMethodOrDeclareMethodCommon)(),tSFunctionTypeAnnotationCommon())}),defineType("TSQualifiedName",{aliases:["TSEntityName"],visitor:["left","right"],fields:{left:(0, _utils.validateType)("TSEntityName"),right:(0, _utils.validateType)("Identifier")}});const signatureDeclarationCommon=()=>({typeParameters:(0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),parameters:(0, _utils.validateArrayOfType)("ArrayPattern","Identifier","ObjectPattern","RestElement"),typeAnnotation:(0, _utils.validateOptionalType)("TSTypeAnnotation")}),callConstructSignatureDeclaration={aliases:["TSTypeElement"],visitor:["typeParameters","parameters","typeAnnotation"],fields:signatureDeclarationCommon()};defineType("TSCallSignatureDeclaration",callConstructSignatureDeclaration),defineType("TSConstructSignatureDeclaration",callConstructSignatureDeclaration);const namedTypeElementCommon=()=>({key:(0, _utils.validateType)("Expression"),computed:{default:false},optional:(0, _utils.validateOptional)(bool)});defineType("TSPropertySignature",{aliases:["TSTypeElement"],visitor:["key","typeAnnotation"],fields:Object.assign({},namedTypeElementCommon(),{readonly:(0, _utils.validateOptional)(bool),typeAnnotation:(0, _utils.validateOptionalType)("TSTypeAnnotation"),kind:{validate:(0, _utils.assertOneOf)("get","set")}})}),defineType("TSMethodSignature",{aliases:["TSTypeElement"],visitor:["key","typeParameters","parameters","typeAnnotation"],fields:Object.assign({},signatureDeclarationCommon(),namedTypeElementCommon(),{kind:{validate:(0, _utils.assertOneOf)("method","get","set")}})}),defineType("TSIndexSignature",{aliases:["TSTypeElement"],visitor:["parameters","typeAnnotation"],fields:{readonly:(0, _utils.validateOptional)(bool),static:(0, _utils.validateOptional)(bool),parameters:(0, _utils.validateArrayOfType)("Identifier"),typeAnnotation:(0, _utils.validateOptionalType)("TSTypeAnnotation")}});const tsKeywordTypes=["TSAnyKeyword","TSBooleanKeyword","TSBigIntKeyword","TSIntrinsicKeyword","TSNeverKeyword","TSNullKeyword","TSNumberKeyword","TSObjectKeyword","TSStringKeyword","TSSymbolKeyword","TSUndefinedKeyword","TSUnknownKeyword","TSVoidKeyword"];for(const type of tsKeywordTypes)defineType(type,{aliases:["TSType","TSBaseType"],visitor:[],fields:{}});defineType("TSThisType",{aliases:["TSType","TSBaseType"],visitor:[],fields:{}});const fnOrCtrBase={aliases:["TSType"],visitor:["typeParameters","parameters","typeAnnotation"]};defineType("TSFunctionType",Object.assign({},fnOrCtrBase,{fields:signatureDeclarationCommon()})),defineType("TSConstructorType",Object.assign({},fnOrCtrBase,{fields:Object.assign({},signatureDeclarationCommon(),{abstract:(0, _utils.validateOptional)(bool)})})),defineType("TSTypeReference",{aliases:["TSType"],visitor:["typeName","typeParameters"],fields:{typeName:(0, _utils.validateType)("TSEntityName"),typeParameters:(0, _utils.validateOptionalType)("TSTypeParameterInstantiation")}}),defineType("TSTypePredicate",{aliases:["TSType"],visitor:["parameterName","typeAnnotation"],builder:["parameterName","typeAnnotation","asserts"],fields:{parameterName:(0, _utils.validateType)("Identifier","TSThisType"),typeAnnotation:(0, _utils.validateOptionalType)("TSTypeAnnotation"),asserts:(0, _utils.validateOptional)(bool)}}),defineType("TSTypeQuery",{aliases:["TSType"],visitor:["exprName","typeParameters"],fields:{exprName:(0, _utils.validateType)("TSEntityName","TSImportType"),typeParameters:(0, _utils.validateOptionalType)("TSTypeParameterInstantiation")}}),defineType("TSTypeLiteral",{aliases:["TSType"],visitor:["members"],fields:{members:(0, _utils.validateArrayOfType)("TSTypeElement")}}),defineType("TSArrayType",{aliases:["TSType"],visitor:["elementType"],fields:{elementType:(0, _utils.validateType)("TSType")}}),defineType("TSTupleType",{aliases:["TSType"],visitor:["elementTypes"],fields:{elementTypes:(0, _utils.validateArrayOfType)("TSType","TSNamedTupleMember")}}),defineType("TSOptionalType",{aliases:["TSType"],visitor:["typeAnnotation"],fields:{typeAnnotation:(0, _utils.validateType)("TSType")}}),defineType("TSRestType",{aliases:["TSType"],visitor:["typeAnnotation"],fields:{typeAnnotation:(0, _utils.validateType)("TSType")}}),defineType("TSNamedTupleMember",{visitor:["label","elementType"],builder:["label","elementType","optional"],fields:{label:(0, _utils.validateType)("Identifier"),optional:{validate:bool,default:false},elementType:(0, _utils.validateType)("TSType")}});const unionOrIntersection={aliases:["TSType"],visitor:["types"],fields:{types:(0, _utils.validateArrayOfType)("TSType")}};defineType("TSUnionType",unionOrIntersection),defineType("TSIntersectionType",unionOrIntersection),defineType("TSConditionalType",{aliases:["TSType"],visitor:["checkType","extendsType","trueType","falseType"],fields:{checkType:(0, _utils.validateType)("TSType"),extendsType:(0, _utils.validateType)("TSType"),trueType:(0, _utils.validateType)("TSType"),falseType:(0, _utils.validateType)("TSType")}}),defineType("TSInferType",{aliases:["TSType"],visitor:["typeParameter"],fields:{typeParameter:(0, _utils.validateType)("TSTypeParameter")}}),defineType("TSParenthesizedType",{aliases:["TSType"],visitor:["typeAnnotation"],fields:{typeAnnotation:(0, _utils.validateType)("TSType")}}),defineType("TSTypeOperator",{aliases:["TSType"],visitor:["typeAnnotation"],fields:{operator:(0, _utils.validate)((0, _utils.assertValueType)("string")),typeAnnotation:(0, _utils.validateType)("TSType")}}),defineType("TSIndexedAccessType",{aliases:["TSType"],visitor:["objectType","indexType"],fields:{objectType:(0, _utils.validateType)("TSType"),indexType:(0, _utils.validateType)("TSType")}}),defineType("TSMappedType",{aliases:["TSType"],visitor:["typeParameter","nameType","typeAnnotation"],builder:["typeParameter","typeAnnotation","nameType"],fields:Object.assign({},{typeParameter:(0, _utils.validateType)("TSTypeParameter")},{readonly:(0, _utils.validateOptional)((0, _utils.assertOneOf)(true,false,"+","-")),optional:(0, _utils.validateOptional)((0, _utils.assertOneOf)(true,false,"+","-")),typeAnnotation:(0, _utils.validateOptionalType)("TSType"),nameType:(0, _utils.validateOptionalType)("TSType")})}),defineType("TSLiteralType",{aliases:["TSType","TSBaseType"],visitor:["literal"],fields:{literal:{validate:function(){const unaryExpression=(0, _utils.assertNodeType)("NumericLiteral","BigIntLiteral"),unaryOperator=(0, _utils.assertOneOf)("-"),literal=(0, _utils.assertNodeType)("NumericLiteral","StringLiteral","BooleanLiteral","BigIntLiteral","TemplateLiteral");function validator(parent,key,node){(0, _is.default)("UnaryExpression",node)?(unaryOperator(node,"operator",node.operator),unaryExpression(node,"argument",node.argument)):literal(parent,key,node);}return validator.oneOfNodeTypes=["NumericLiteral","StringLiteral","BooleanLiteral","BigIntLiteral","TemplateLiteral","UnaryExpression"],validator}()}}});defineType("TSExpressionWithTypeArguments",{aliases:["TSType"],visitor:["expression","typeParameters"],fields:{expression:(0, _utils.validateType)("TSEntityName"),typeParameters:(0, _utils.validateOptionalType)("TSTypeParameterInstantiation")}}),defineType("TSInterfaceDeclaration",{aliases:["Statement","Declaration"],visitor:["id","typeParameters","extends","body"],fields:{declare:(0, _utils.validateOptional)(bool),id:(0, _utils.validateType)("Identifier"),typeParameters:(0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),extends:(0, _utils.validateOptional)((0, _utils.arrayOfType)("TSExpressionWithTypeArguments")),body:(0, _utils.validateType)("TSInterfaceBody")}}),defineType("TSInterfaceBody",{visitor:["body"],fields:{body:(0, _utils.validateArrayOfType)("TSTypeElement")}}),defineType("TSTypeAliasDeclaration",{aliases:["Statement","Declaration"],visitor:["id","typeParameters","typeAnnotation"],fields:{declare:(0, _utils.validateOptional)(bool),id:(0, _utils.validateType)("Identifier"),typeParameters:(0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),typeAnnotation:(0, _utils.validateType)("TSType")}}),defineType("TSInstantiationExpression",{aliases:["Expression"],visitor:["expression","typeParameters"],fields:{expression:(0, _utils.validateType)("Expression"),typeParameters:(0, _utils.validateOptionalType)("TSTypeParameterInstantiation")}});const TSTypeExpression={aliases:["Expression","LVal","PatternLike"],visitor:["expression","typeAnnotation"],fields:{expression:(0, _utils.validateType)("Expression"),typeAnnotation:(0, _utils.validateType)("TSType")}};defineType("TSAsExpression",TSTypeExpression),defineType("TSSatisfiesExpression",TSTypeExpression),defineType("TSTypeAssertion",{aliases:["Expression","LVal","PatternLike"],visitor:["typeAnnotation","expression"],fields:{typeAnnotation:(0, _utils.validateType)("TSType"),expression:(0, _utils.validateType)("Expression")}}),defineType("TSEnumDeclaration",{aliases:["Statement","Declaration"],visitor:["id","members"],fields:{declare:(0, _utils.validateOptional)(bool),const:(0, _utils.validateOptional)(bool),id:(0, _utils.validateType)("Identifier"),members:(0, _utils.validateArrayOfType)("TSEnumMember"),initializer:(0, _utils.validateOptionalType)("Expression")}}),defineType("TSEnumMember",{visitor:["id","initializer"],fields:{id:(0, _utils.validateType)("Identifier","StringLiteral"),initializer:(0, _utils.validateOptionalType)("Expression")}}),defineType("TSModuleDeclaration",{aliases:["Statement","Declaration"],visitor:["id","body"],fields:Object.assign({kind:{validate:(0, _utils.assertOneOf)("global","module","namespace")},declare:(0, _utils.validateOptional)(bool)},{global:(0, _utils.validateOptional)(bool)},{id:(0, _utils.validateType)("Identifier","StringLiteral"),body:(0, _utils.validateType)("TSModuleBlock","TSModuleDeclaration")})}),defineType("TSModuleBlock",{aliases:["Scopable","Block","BlockParent","FunctionParent"],visitor:["body"],fields:{body:(0, _utils.validateArrayOfType)("Statement")}}),defineType("TSImportType",{aliases:["TSType"],visitor:["argument","qualifier","typeParameters"],fields:{argument:(0, _utils.validateType)("StringLiteral"),qualifier:(0, _utils.validateOptionalType)("TSEntityName"),typeParameters:(0, _utils.validateOptionalType)("TSTypeParameterInstantiation"),options:{validate:(0, _utils.assertNodeType)("Expression"),optional:true}}}),defineType("TSImportEqualsDeclaration",{aliases:["Statement"],visitor:["id","moduleReference"],fields:{isExport:(0, _utils.validate)(bool),id:(0, _utils.validateType)("Identifier"),moduleReference:(0, _utils.validateType)("TSEntityName","TSExternalModuleReference"),importKind:{validate:(0, _utils.assertOneOf)("type","value"),optional:true}}}),defineType("TSExternalModuleReference",{visitor:["expression"],fields:{expression:(0, _utils.validateType)("StringLiteral")}}),defineType("TSNonNullExpression",{aliases:["Expression","LVal","PatternLike"],visitor:["expression"],fields:{expression:(0, _utils.validateType)("Expression")}}),defineType("TSExportAssignment",{aliases:["Statement"],visitor:["expression"],fields:{expression:(0, _utils.validateType)("Expression")}}),defineType("TSNamespaceExportDeclaration",{aliases:["Statement"],visitor:["id"],fields:{id:(0, _utils.validateType)("Identifier")}}),defineType("TSTypeAnnotation",{visitor:["typeAnnotation"],fields:{typeAnnotation:{validate:(0, _utils.assertNodeType)("TSType")}}}),defineType("TSTypeParameterInstantiation",{visitor:["params"],fields:{params:(0, _utils.validateArrayOfType)("TSType")}}),defineType("TSTypeParameterDeclaration",{visitor:["params"],fields:{params:(0, _utils.validateArrayOfType)("TSTypeParameter")}}),defineType("TSTypeParameter",{builder:["constraint","default","name"],visitor:["constraint","default"],fields:{name:{validate:(0, _utils.assertValueType)("string")},in:{validate:(0, _utils.assertValueType)("boolean"),optional:true},out:{validate:(0, _utils.assertValueType)("boolean"),optional:true},const:{validate:(0, _utils.assertValueType)("boolean"),optional:true},constraint:{validate:(0, _utils.assertNodeType)("TSType"),optional:true},default:{validate:(0, _utils.assertNodeType)("TSType"),optional:true}}});},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/utils.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.VISITOR_KEYS=exports.NODE_PARENT_VALIDATIONS=exports.NODE_FIELDS=exports.FLIPPED_ALIAS_KEYS=exports.DEPRECATED_KEYS=exports.BUILDER_KEYS=exports.ALIAS_KEYS=void 0,exports.arrayOf=arrayOf,exports.arrayOfType=arrayOfType,exports.assertEach=assertEach,exports.assertNodeOrValueType=function(...types){function validate(node,key,val){for(const type of types)if(getType(val)===type||(0, _is.default)(type,val))return void(0, _validate.validateChild)(node,key,val);throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(null==val?void 0:val.type)}`)}return validate.oneOfNodeOrValueTypes=types,validate},exports.assertNodeType=assertNodeType,exports.assertOneOf=function(...values){function validate(node,key,val){if(!values.includes(val))throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`)}return validate.oneOf=values,validate},exports.assertOptionalChainStart=function(){return function(node){var _current;let current=node;for(;node;){const{type}=current;if("OptionalCallExpression"!==type){if("OptionalMemberExpression"!==type)break;if(current.optional)return;current=current.object;}else {if(current.optional)return;current=current.callee;}}throw new TypeError(`Non-optional ${node.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${null==(_current=current)?void 0:_current.type}`)}},exports.assertShape=function(shape){function validate(node,key,val){const errors=[];for(const property of Object.keys(shape))try{(0,_validate.validateField)(node,property,val[property],shape[property]);}catch(error){if(error instanceof TypeError){errors.push(error.message);continue}throw error}if(errors.length)throw new TypeError(`Property ${key} of ${node.type} expected to have the following:\n${errors.join("\n")}`)}return validate.shapeOf=shape,validate},exports.assertValueType=assertValueType,exports.chain=chain,exports.default=defineType,exports.defineAliasedType=function(...aliases){return (type,opts={})=>{let defined=opts.aliases;var _store$opts$inherits$;defined||(opts.inherits&&(defined=null==(_store$opts$inherits$=store[opts.inherits].aliases)?void 0:_store$opts$inherits$.slice()),null!=defined||(defined=[]),opts.aliases=defined);const additional=aliases.filter((a=>!defined.includes(a)));defined.unshift(...additional),defineType(type,opts);}},exports.validate=validate,exports.validateArrayOfType=function(...typeNames){return validate(arrayOfType(...typeNames))},exports.validateOptional=function(validate){return {validate,optional:true}},exports.validateOptionalType=function(...typeNames){return {validate:assertNodeType(...typeNames),optional:true}},exports.validateType=function(...typeNames){return validate(assertNodeType(...typeNames))};var _is=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/is.js"),_validate=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/validate.js");const VISITOR_KEYS=exports.VISITOR_KEYS={},ALIAS_KEYS=exports.ALIAS_KEYS={},FLIPPED_ALIAS_KEYS=exports.FLIPPED_ALIAS_KEYS={},NODE_FIELDS=exports.NODE_FIELDS={},BUILDER_KEYS=exports.BUILDER_KEYS={},DEPRECATED_KEYS=exports.DEPRECATED_KEYS={},NODE_PARENT_VALIDATIONS=exports.NODE_PARENT_VALIDATIONS={};function getType(val){return Array.isArray(val)?"array":null===val?"null":typeof val}function validate(validate){return {validate}}function arrayOf(elementType){return chain(assertValueType("array"),assertEach(elementType))}function arrayOfType(...typeNames){return arrayOf(assertNodeType(...typeNames))}function assertEach(callback){const childValidator=process.env.BABEL_TYPES_8_BREAKING?_validate.validateChild:()=>{};function validator(node,key,val){if(Array.isArray(val))for(let i=0;i<val.length;i++){const subkey=`${key}[${i}]`,v=val[i];callback(node,subkey,v),childValidator(node,subkey,v);}}return validator.each=callback,validator}function assertNodeType(...types){function validate(node,key,val){for(const type of types)if((0, _is.default)(type,val))return void(0, _validate.validateChild)(node,key,val);throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(null==val?void 0:val.type)}`)}return validate.oneOfNodeTypes=types,validate}function assertValueType(type){function validate(node,key,val){if(!(getType(val)===type))throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`)}return validate.type=type,validate}function chain(...fns){function validate(...args){for(const fn of fns)fn(...args);}if(validate.chainOf=fns,fns.length>=2&&"type"in fns[0]&&"array"===fns[0].type&&!("each"in fns[1]))throw new Error('An assertValueType("array") validator can only be followed by an assertEach(...) validator.');return validate}const validTypeOpts=new Set(["aliases","builder","deprecatedAlias","fields","inherits","visitor","validate"]),validFieldKeys=new Set(["default","optional","deprecated","validate"]),store={};function defineType(type,opts={}){const inherits=opts.inherits&&store[opts.inherits]||{};let fields=opts.fields;if(!fields&&(fields={},inherits.fields)){const keys=Object.getOwnPropertyNames(inherits.fields);for(const key of keys){const field=inherits.fields[key],def=field.default;if(Array.isArray(def)?def.length>0:def&&"object"==typeof def)throw new Error("field defaults can only be primitives or empty arrays currently");fields[key]={default:Array.isArray(def)?[]:def,optional:field.optional,deprecated:field.deprecated,validate:field.validate};}}const visitor=opts.visitor||inherits.visitor||[],aliases=opts.aliases||inherits.aliases||[],builder=opts.builder||inherits.builder||opts.visitor||[];for(const k of Object.keys(opts))if(!validTypeOpts.has(k))throw new Error(`Unknown type option "${k}" on ${type}`);opts.deprecatedAlias&&(DEPRECATED_KEYS[opts.deprecatedAlias]=type);for(const key of visitor.concat(builder))fields[key]=fields[key]||{};for(const key of Object.keys(fields)){const field=fields[key];void 0===field.default||builder.includes(key)||(field.optional=true),void 0===field.default?field.default=null:field.validate||null==field.default||(field.validate=assertValueType(getType(field.default)));for(const k of Object.keys(field))if(!validFieldKeys.has(k))throw new Error(`Unknown field key "${k}" on ${type}.${key}`)}VISITOR_KEYS[type]=opts.visitor=visitor,BUILDER_KEYS[type]=opts.builder=builder,NODE_FIELDS[type]=opts.fields=fields,ALIAS_KEYS[type]=opts.aliases=aliases,aliases.forEach((alias=>{FLIPPED_ALIAS_KEYS[alias]=FLIPPED_ALIAS_KEYS[alias]||[],FLIPPED_ALIAS_KEYS[alias].push(type);})),opts.validate&&(NODE_PARENT_VALIDATIONS[type]=opts.validate),store[type]=opts;}},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true});var _exportNames={react:true,assertNode:true,createTypeAnnotationBasedOnTypeof:true,createUnionTypeAnnotation:true,createFlowUnionType:true,createTSUnionType:true,cloneNode:true,clone:true,cloneDeep:true,cloneDeepWithoutLoc:true,cloneWithoutLoc:true,addComment:true,addComments:true,inheritInnerComments:true,inheritLeadingComments:true,inheritsComments:true,inheritTrailingComments:true,removeComments:true,ensureBlock:true,toBindingIdentifierName:true,toBlock:true,toComputedKey:true,toExpression:true,toIdentifier:true,toKeyAlias:true,toStatement:true,valueToNode:true,appendToMemberExpression:true,inherits:true,prependToMemberExpression:true,removeProperties:true,removePropertiesDeep:true,removeTypeDuplicates:true,getAssignmentIdentifiers:true,getBindingIdentifiers:true,getOuterBindingIdentifiers:true,getFunctionName:true,traverse:true,traverseFast:true,shallowEqual:true,is:true,isBinding:true,isBlockScoped:true,isImmutable:true,isLet:true,isNode:true,isNodesEquivalent:true,isPlaceholderType:true,isReferenced:true,isScope:true,isSpecifierDefault:true,isType:true,isValidES3Identifier:true,isValidIdentifier:true,isVar:true,matchesPattern:true,validate:true,buildMatchMemberExpression:true,__internal__deprecationWarning:true};Object.defineProperty(exports,"__internal__deprecationWarning",{enumerable:true,get:function(){return _deprecationWarning.default}}),Object.defineProperty(exports,"addComment",{enumerable:true,get:function(){return _addComment.default}}),Object.defineProperty(exports,"addComments",{enumerable:true,get:function(){return _addComments.default}}),Object.defineProperty(exports,"appendToMemberExpression",{enumerable:true,get:function(){return _appendToMemberExpression.default}}),Object.defineProperty(exports,"assertNode",{enumerable:true,get:function(){return _assertNode.default}}),Object.defineProperty(exports,"buildMatchMemberExpression",{enumerable:true,get:function(){return _buildMatchMemberExpression.default}}),Object.defineProperty(exports,"clone",{enumerable:true,get:function(){return _clone.default}}),Object.defineProperty(exports,"cloneDeep",{enumerable:true,get:function(){return _cloneDeep.default}}),Object.defineProperty(exports,"cloneDeepWithoutLoc",{enumerable:true,get:function(){return _cloneDeepWithoutLoc.default}}),Object.defineProperty(exports,"cloneNode",{enumerable:true,get:function(){return _cloneNode.default}}),Object.defineProperty(exports,"cloneWithoutLoc",{enumerable:true,get:function(){return _cloneWithoutLoc.default}}),Object.defineProperty(exports,"createFlowUnionType",{enumerable:true,get:function(){return _createFlowUnionType.default}}),Object.defineProperty(exports,"createTSUnionType",{enumerable:true,get:function(){return _createTSUnionType.default}}),Object.defineProperty(exports,"createTypeAnnotationBasedOnTypeof",{enumerable:true,get:function(){return _createTypeAnnotationBasedOnTypeof.default}}),Object.defineProperty(exports,"createUnionTypeAnnotation",{enumerable:true,get:function(){return _createFlowUnionType.default}}),Object.defineProperty(exports,"ensureBlock",{enumerable:true,get:function(){return _ensureBlock.default}}),Object.defineProperty(exports,"getAssignmentIdentifiers",{enumerable:true,get:function(){return _getAssignmentIdentifiers.default}}),Object.defineProperty(exports,"getBindingIdentifiers",{enumerable:true,get:function(){return _getBindingIdentifiers.default}}),Object.defineProperty(exports,"getFunctionName",{enumerable:true,get:function(){return _getFunctionName.default}}),Object.defineProperty(exports,"getOuterBindingIdentifiers",{enumerable:true,get:function(){return _getOuterBindingIdentifiers.default}}),Object.defineProperty(exports,"inheritInnerComments",{enumerable:true,get:function(){return _inheritInnerComments.default}}),Object.defineProperty(exports,"inheritLeadingComments",{enumerable:true,get:function(){return _inheritLeadingComments.default}}),Object.defineProperty(exports,"inheritTrailingComments",{enumerable:true,get:function(){return _inheritTrailingComments.default}}),Object.defineProperty(exports,"inherits",{enumerable:true,get:function(){return _inherits.default}}),Object.defineProperty(exports,"inheritsComments",{enumerable:true,get:function(){return _inheritsComments.default}}),Object.defineProperty(exports,"is",{enumerable:true,get:function(){return _is.default}}),Object.defineProperty(exports,"isBinding",{enumerable:true,get:function(){return _isBinding.default}}),Object.defineProperty(exports,"isBlockScoped",{enumerable:true,get:function(){return _isBlockScoped.default}}),Object.defineProperty(exports,"isImmutable",{enumerable:true,get:function(){return _isImmutable.default}}),Object.defineProperty(exports,"isLet",{enumerable:true,get:function(){return _isLet.default}}),Object.defineProperty(exports,"isNode",{enumerable:true,get:function(){return _isNode.default}}),Object.defineProperty(exports,"isNodesEquivalent",{enumerable:true,get:function(){return _isNodesEquivalent.default}}),Object.defineProperty(exports,"isPlaceholderType",{enumerable:true,get:function(){return _isPlaceholderType.default}}),Object.defineProperty(exports,"isReferenced",{enumerable:true,get:function(){return _isReferenced.default}}),Object.defineProperty(exports,"isScope",{enumerable:true,get:function(){return _isScope.default}}),Object.defineProperty(exports,"isSpecifierDefault",{enumerable:true,get:function(){return _isSpecifierDefault.default}}),Object.defineProperty(exports,"isType",{enumerable:true,get:function(){return _isType.default}}),Object.defineProperty(exports,"isValidES3Identifier",{enumerable:true,get:function(){return _isValidES3Identifier.default}}),Object.defineProperty(exports,"isValidIdentifier",{enumerable:true,get:function(){return _isValidIdentifier.default}}),Object.defineProperty(exports,"isVar",{enumerable:true,get:function(){return _isVar.default}}),Object.defineProperty(exports,"matchesPattern",{enumerable:true,get:function(){return _matchesPattern.default}}),Object.defineProperty(exports,"prependToMemberExpression",{enumerable:true,get:function(){return _prependToMemberExpression.default}}),exports.react=void 0,Object.defineProperty(exports,"removeComments",{enumerable:true,get:function(){return _removeComments.default}}),Object.defineProperty(exports,"removeProperties",{enumerable:true,get:function(){return _removeProperties.default}}),Object.defineProperty(exports,"removePropertiesDeep",{enumerable:true,get:function(){return _removePropertiesDeep.default}}),Object.defineProperty(exports,"removeTypeDuplicates",{enumerable:true,get:function(){return _removeTypeDuplicates.default}}),Object.defineProperty(exports,"shallowEqual",{enumerable:true,get:function(){return _shallowEqual.default}}),Object.defineProperty(exports,"toBindingIdentifierName",{enumerable:true,get:function(){return _toBindingIdentifierName.default}}),Object.defineProperty(exports,"toBlock",{enumerable:true,get:function(){return _toBlock.default}}),Object.defineProperty(exports,"toComputedKey",{enumerable:true,get:function(){return _toComputedKey.default}}),Object.defineProperty(exports,"toExpression",{enumerable:true,get:function(){return _toExpression.default}}),Object.defineProperty(exports,"toIdentifier",{enumerable:true,get:function(){return _toIdentifier.default}}),Object.defineProperty(exports,"toKeyAlias",{enumerable:true,get:function(){return _toKeyAlias.default}}),Object.defineProperty(exports,"toStatement",{enumerable:true,get:function(){return _toStatement.default}}),Object.defineProperty(exports,"traverse",{enumerable:true,get:function(){return _traverse.default}}),Object.defineProperty(exports,"traverseFast",{enumerable:true,get:function(){return _traverseFast.default}}),Object.defineProperty(exports,"validate",{enumerable:true,get:function(){return _validate.default}}),Object.defineProperty(exports,"valueToNode",{enumerable:true,get:function(){return _valueToNode.default}});var _isReactComponent=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/react/isReactComponent.js"),_isCompatTag=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/react/isCompatTag.js"),_buildChildren=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/react/buildChildren.js"),_assertNode=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/asserts/assertNode.js"),_index=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/asserts/generated/index.js");Object.keys(_index).forEach((function(key){"default"!==key&&"__esModule"!==key&&(Object.prototype.hasOwnProperty.call(_exportNames,key)||key in exports&&exports[key]===_index[key]||Object.defineProperty(exports,key,{enumerable:true,get:function(){return _index[key]}}));}));var _createTypeAnnotationBasedOnTypeof=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js"),_createFlowUnionType=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js"),_createTSUnionType=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js"),_index2=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/generated/index.js");Object.keys(_index2).forEach((function(key){"default"!==key&&"__esModule"!==key&&(Object.prototype.hasOwnProperty.call(_exportNames,key)||key in exports&&exports[key]===_index2[key]||Object.defineProperty(exports,key,{enumerable:true,get:function(){return _index2[key]}}));}));var _uppercase=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/generated/uppercase.js");Object.keys(_uppercase).forEach((function(key){"default"!==key&&"__esModule"!==key&&(Object.prototype.hasOwnProperty.call(_exportNames,key)||key in exports&&exports[key]===_uppercase[key]||Object.defineProperty(exports,key,{enumerable:true,get:function(){return _uppercase[key]}}));}));var _productions=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/productions.js");Object.keys(_productions).forEach((function(key){"default"!==key&&"__esModule"!==key&&(Object.prototype.hasOwnProperty.call(_exportNames,key)||key in exports&&exports[key]===_productions[key]||Object.defineProperty(exports,key,{enumerable:true,get:function(){return _productions[key]}}));}));var _cloneNode=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/clone/cloneNode.js"),_clone=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/clone/clone.js"),_cloneDeep=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/clone/cloneDeep.js"),_cloneDeepWithoutLoc=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js"),_cloneWithoutLoc=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/clone/cloneWithoutLoc.js"),_addComment=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/comments/addComment.js"),_addComments=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/comments/addComments.js"),_inheritInnerComments=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/comments/inheritInnerComments.js"),_inheritLeadingComments=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/comments/inheritLeadingComments.js"),_inheritsComments=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/comments/inheritsComments.js"),_inheritTrailingComments=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/comments/inheritTrailingComments.js"),_removeComments=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/comments/removeComments.js"),_index3=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/constants/generated/index.js");Object.keys(_index3).forEach((function(key){"default"!==key&&"__esModule"!==key&&(Object.prototype.hasOwnProperty.call(_exportNames,key)||key in exports&&exports[key]===_index3[key]||Object.defineProperty(exports,key,{enumerable:true,get:function(){return _index3[key]}}));}));var _index4=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/constants/index.js");Object.keys(_index4).forEach((function(key){"default"!==key&&"__esModule"!==key&&(Object.prototype.hasOwnProperty.call(_exportNames,key)||key in exports&&exports[key]===_index4[key]||Object.defineProperty(exports,key,{enumerable:true,get:function(){return _index4[key]}}));}));var _ensureBlock=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/converters/ensureBlock.js"),_toBindingIdentifierName=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/converters/toBindingIdentifierName.js"),_toBlock=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/converters/toBlock.js"),_toComputedKey=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/converters/toComputedKey.js"),_toExpression=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/converters/toExpression.js"),_toIdentifier=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/converters/toIdentifier.js"),_toKeyAlias=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/converters/toKeyAlias.js"),_toStatement=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/converters/toStatement.js"),_valueToNode=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/converters/valueToNode.js"),_index5=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/index.js");Object.keys(_index5).forEach((function(key){"default"!==key&&"__esModule"!==key&&(Object.prototype.hasOwnProperty.call(_exportNames,key)||key in exports&&exports[key]===_index5[key]||Object.defineProperty(exports,key,{enumerable:true,get:function(){return _index5[key]}}));}));var _appendToMemberExpression=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/modifications/appendToMemberExpression.js"),_inherits=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/modifications/inherits.js"),_prependToMemberExpression=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/modifications/prependToMemberExpression.js"),_removeProperties=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/modifications/removeProperties.js"),_removePropertiesDeep=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/modifications/removePropertiesDeep.js"),_removeTypeDuplicates=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js"),_getAssignmentIdentifiers=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/retrievers/getAssignmentIdentifiers.js"),_getBindingIdentifiers=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js"),_getOuterBindingIdentifiers=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js"),_getFunctionName=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/retrievers/getFunctionName.js"),_traverse=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/traverse/traverse.js");Object.keys(_traverse).forEach((function(key){"default"!==key&&"__esModule"!==key&&(Object.prototype.hasOwnProperty.call(_exportNames,key)||key in exports&&exports[key]===_traverse[key]||Object.defineProperty(exports,key,{enumerable:true,get:function(){return _traverse[key]}}));}));var _traverseFast=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/traverse/traverseFast.js"),_shallowEqual=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/utils/shallowEqual.js"),_is=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/is.js"),_isBinding=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isBinding.js"),_isBlockScoped=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isBlockScoped.js"),_isImmutable=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isImmutable.js"),_isLet=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isLet.js"),_isNode=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isNode.js"),_isNodesEquivalent=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isNodesEquivalent.js"),_isPlaceholderType=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isPlaceholderType.js"),_isReferenced=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isReferenced.js"),_isScope=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isScope.js"),_isSpecifierDefault=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isSpecifierDefault.js"),_isType=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isType.js"),_isValidES3Identifier=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isValidES3Identifier.js"),_isValidIdentifier=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isValidIdentifier.js"),_isVar=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isVar.js"),_matchesPattern=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/matchesPattern.js"),_validate=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/validate.js"),_buildMatchMemberExpression=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js"),_index6=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/generated/index.js");Object.keys(_index6).forEach((function(key){"default"!==key&&"__esModule"!==key&&(Object.prototype.hasOwnProperty.call(_exportNames,key)||key in exports&&exports[key]===_index6[key]||Object.defineProperty(exports,key,{enumerable:true,get:function(){return _index6[key]}}));}));var _deprecationWarning=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/utils/deprecationWarning.js");exports.react={isReactComponent:_isReactComponent.default,isCompatTag:_isCompatTag.default,buildChildren:_buildChildren.default};exports.toSequenceExpression=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/converters/toSequenceExpression.js").default,process.env.BABEL_TYPES_8_BREAKING&&console.warn("BABEL_TYPES_8_BREAKING is not supported anymore. Use the latest Babel 8.0.0 pre-release instead!");},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/modifications/appendToMemberExpression.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(member,append,computed=false){return member.object=(0, _index.memberExpression)(member.object,member.property,member.computed),member.property=append,member.computed=!!computed,member};var _index=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/generated/index.js");},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function removeTypeDuplicates(nodesIn){const nodes=Array.from(nodesIn),generics=new Map,bases=new Map,typeGroups=new Set,types=[];for(let i=0;i<nodes.length;i++){const node=nodes[i];if(node&&!types.includes(node)){if((0, _index.isAnyTypeAnnotation)(node))return [node];if((0, _index.isFlowBaseAnnotation)(node))bases.set(node.type,node);else if((0, _index.isUnionTypeAnnotation)(node))typeGroups.has(node.types)||(nodes.push(...node.types),typeGroups.add(node.types));else if((0, _index.isGenericTypeAnnotation)(node)){const name=getQualifiedName(node.id);if(generics.has(name)){let existing=generics.get(name);existing.typeParameters?node.typeParameters&&(existing.typeParameters.params.push(...node.typeParameters.params),existing.typeParameters.params=removeTypeDuplicates(existing.typeParameters.params)):existing=node.typeParameters;}else generics.set(name,node);}else types.push(node);}}for(const[,baseType]of bases)types.push(baseType);for(const[,genericName]of generics)types.push(genericName);return types};var _index=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/generated/index.js");function getQualifiedName(node){return (0, _index.isIdentifier)(node)?node.name:`${node.id.name}.${getQualifiedName(node.qualification)}`}},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/modifications/inherits.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(child,parent){if(!child||!parent)return child;for(const key of _index.INHERIT_KEYS.optional)null==child[key]&&(child[key]=parent[key]);for(const key of Object.keys(parent))"_"===key[0]&&"__clone"!==key&&(child[key]=parent[key]);for(const key of _index.INHERIT_KEYS.force)child[key]=parent[key];return (0, _inheritsComments.default)(child,parent),child};var _index=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/constants/index.js"),_inheritsComments=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/comments/inheritsComments.js");},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/modifications/prependToMemberExpression.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(member,prepend){if((0, _index2.isSuper)(member.object))throw new Error("Cannot prepend node to super property access (`super.foo`).");return member.object=(0, _index.memberExpression)(prepend,member.object),member};var _index=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/generated/index.js"),_index2=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js");},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/modifications/removeProperties.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(node,opts={}){const map=opts.preserveComments?CLEAR_KEYS:CLEAR_KEYS_PLUS_COMMENTS;for(const key of map)null!=node[key]&&(node[key]=void 0);for(const key of Object.keys(node))"_"===key[0]&&null!=node[key]&&(node[key]=void 0);const symbols=Object.getOwnPropertySymbols(node);for(const sym of symbols)node[sym]=null;};var _index=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/constants/index.js");const CLEAR_KEYS=["tokens","start","end","loc","raw","rawValue"],CLEAR_KEYS_PLUS_COMMENTS=[..._index.COMMENT_KEYS,"comments",...CLEAR_KEYS];},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/modifications/removePropertiesDeep.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(tree,opts){return (0, _traverseFast.default)(tree,_removeProperties.default,opts),tree};var _traverseFast=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/traverse/traverseFast.js"),_removeProperties=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/modifications/removeProperties.js");},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function removeTypeDuplicates(nodesIn){const nodes=Array.from(nodesIn),generics=new Map,bases=new Map,typeGroups=new Set,types=[];for(let i=0;i<nodes.length;i++){const node=nodes[i];if(node&&!types.includes(node)){if((0, _index.isTSAnyKeyword)(node))return [node];if((0, _index.isTSBaseType)(node))bases.set(node.type,node);else if((0, _index.isTSUnionType)(node))typeGroups.has(node.types)||(nodes.push(...node.types),typeGroups.add(node.types));else if((0, _index.isTSTypeReference)(node)&&node.typeParameters){const name=getQualifiedName(node.typeName);if(generics.has(name)){let existing=generics.get(name);existing.typeParameters?node.typeParameters&&(existing.typeParameters.params.push(...node.typeParameters.params),existing.typeParameters.params=removeTypeDuplicates(existing.typeParameters.params)):existing=node.typeParameters;}else generics.set(name,node);}else types.push(node);}}for(const[,baseType]of bases)types.push(baseType);for(const[,genericName]of generics)types.push(genericName);return types};var _index=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/generated/index.js");function getQualifiedName(node){return (0, _index.isIdentifier)(node)?node.name:`${node.right.name}.${getQualifiedName(node.left)}`}},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/retrievers/getAssignmentIdentifiers.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(node){const search=[].concat(node),ids=Object.create(null);for(;search.length;){const id=search.pop();if(id)switch(id.type){case "ArrayPattern":search.push(...id.elements);break;case "AssignmentExpression":case "AssignmentPattern":case "ForInStatement":case "ForOfStatement":search.push(id.left);break;case "ObjectPattern":search.push(...id.properties);break;case "ObjectProperty":search.push(id.value);break;case "RestElement":case "UpdateExpression":search.push(id.argument);break;case "UnaryExpression":"delete"===id.operator&&search.push(id.argument);break;case "Identifier":ids[id.name]=id;}}return ids};},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=getBindingIdentifiers;var _index=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/generated/index.js");function getBindingIdentifiers(node,duplicates,outerOnly,newBindingsOnly){const search=[].concat(node),ids=Object.create(null);for(;search.length;){const id=search.shift();if(!id)continue;if(newBindingsOnly&&((0, _index.isAssignmentExpression)(id)||(0, _index.isUnaryExpression)(id)||(0, _index.isUpdateExpression)(id)))continue;if((0, _index.isIdentifier)(id)){if(duplicates){(ids[id.name]=ids[id.name]||[]).push(id);}else ids[id.name]=id;continue}if((0, _index.isExportDeclaration)(id)&&!(0, _index.isExportAllDeclaration)(id)){(0, _index.isDeclaration)(id.declaration)&&search.push(id.declaration);continue}if(outerOnly){if((0, _index.isFunctionDeclaration)(id)){search.push(id.id);continue}if((0, _index.isFunctionExpression)(id))continue}const keys=getBindingIdentifiers.keys[id.type];if(keys)for(let i=0;i<keys.length;i++){const nodes=id[keys[i]];nodes&&(Array.isArray(nodes)?search.push(...nodes):search.push(nodes));}}return ids}getBindingIdentifiers.keys={DeclareClass:["id"],DeclareFunction:["id"],DeclareModule:["id"],DeclareVariable:["id"],DeclareInterface:["id"],DeclareTypeAlias:["id"],DeclareOpaqueType:["id"],InterfaceDeclaration:["id"],TypeAlias:["id"],OpaqueType:["id"],CatchClause:["param"],LabeledStatement:["label"],UnaryExpression:["argument"],AssignmentExpression:["left"],ImportSpecifier:["local"],ImportNamespaceSpecifier:["local"],ImportDefaultSpecifier:["local"],ImportDeclaration:["specifiers"],ExportSpecifier:["exported"],ExportNamespaceSpecifier:["exported"],ExportDefaultSpecifier:["exported"],FunctionDeclaration:["id","params"],FunctionExpression:["id","params"],ArrowFunctionExpression:["params"],ObjectMethod:["params"],ClassMethod:["params"],ClassPrivateMethod:["params"],ForInStatement:["left"],ForOfStatement:["left"],ClassDeclaration:["id"],ClassExpression:["id"],RestElement:["argument"],UpdateExpression:["argument"],ObjectProperty:["value"],AssignmentPattern:["left"],ArrayPattern:["elements"],ObjectPattern:["properties"],VariableDeclaration:["declarations"],VariableDeclarator:["id"]};},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/retrievers/getFunctionName.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(node,parent){if("id"in node&&node.id)return {name:node.id.name,originalNode:node.id};let id,prefix="";(0, _index.isObjectProperty)(parent,{value:node})?id=getObjectMemberKey(parent):(0, _index.isObjectMethod)(node)||(0, _index.isClassMethod)(node)?(id=getObjectMemberKey(node),"get"===node.kind?prefix="get ":"set"===node.kind&&(prefix="set ")):(0, _index.isVariableDeclarator)(parent,{init:node})?id=parent.id:(0, _index.isAssignmentExpression)(parent,{operator:"=",right:node})&&(id=parent.left);if(!id)return null;const name=(0, _index.isLiteral)(id)?function(id){if((0, _index.isNullLiteral)(id))return "null";if((0, _index.isRegExpLiteral)(id))return `/${id.pattern}/${id.flags}`;if((0, _index.isTemplateLiteral)(id))return id.quasis.map((quasi=>quasi.value.raw)).join("");if(void 0!==id.value)return String(id.value);return null}(id):(0, _index.isIdentifier)(id)?id.name:(0, _index.isPrivateName)(id)?id.id.name:null;return null==name?null:{name:prefix+name,originalNode:id}};var _index=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/generated/index.js");function getObjectMemberKey(node){if(!node.computed||(0, _index.isLiteral)(node.key))return node.key}},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=void 0;var _getBindingIdentifiers=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js");exports.default=function(node,duplicates){return (0, _getBindingIdentifiers.default)(node,duplicates,true)};},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/traverse/traverse.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(node,handlers,state){"function"==typeof handlers&&(handlers={enter:handlers});const{enter,exit}=handlers;traverseSimpleImpl(node,enter,exit,state,[]);};var _index=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/index.js");function traverseSimpleImpl(node,enter,exit,state,ancestors){const keys=_index.VISITOR_KEYS[node.type];if(keys){enter&&enter(node,ancestors,state);for(const key of keys){const subNode=node[key];if(Array.isArray(subNode))for(let i=0;i<subNode.length;i++){const child=subNode[i];child&&(ancestors.push({node,key,index:i}),traverseSimpleImpl(child,enter,exit,state,ancestors),ancestors.pop());}else subNode&&(ancestors.push({node,key}),traverseSimpleImpl(subNode,enter,exit,state,ancestors),ancestors.pop());}exit&&exit(node,ancestors,state);}}},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/traverse/traverseFast.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function traverseFast(node,enter,opts){if(!node)return;const keys=_index.VISITOR_KEYS[node.type];if(!keys)return;enter(node,opts=opts||{});for(const key of keys){const subNode=node[key];if(Array.isArray(subNode))for(const node of subNode)traverseFast(node,enter,opts);else traverseFast(subNode,enter,opts);}};var _index=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/index.js");},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/utils/deprecationWarning.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(oldName,newName,prefix=""){if(warnings.has(oldName))return;warnings.add(oldName);const{internal,trace}=function(skip,length){const{stackTraceLimit,prepareStackTrace}=Error;let stackTrace;if(Error.stackTraceLimit=1+skip+length,Error.prepareStackTrace=function(err,stack){stackTrace=stack;},(new Error).stack,Error.stackTraceLimit=stackTraceLimit,Error.prepareStackTrace=prepareStackTrace,!stackTrace)return {internal:false,trace:""};const shortStackTrace=stackTrace.slice(1+skip,1+skip+length);return {internal:/[\\/]@babel[\\/]/.test(shortStackTrace[1].getFileName()),trace:shortStackTrace.map((frame=>`    at ${frame}`)).join("\n")}}(1,2);if(internal)return;console.warn(`${prefix}\`${oldName}\` has been deprecated, please migrate to \`${newName}\`\n${trace}`);};const warnings=new Set;},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/utils/inherit.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(key,child,parent){child&&parent&&(child[key]=Array.from(new Set([].concat(child[key],parent[key]).filter(Boolean))));};},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(child,args){const lines=child.value.split(/\r\n|\n|\r/);let lastNonEmptyLine=0;for(let i=0;i<lines.length;i++)/[^ \t]/.exec(lines[i])&&(lastNonEmptyLine=i);let str="";for(let i=0;i<lines.length;i++){const line=lines[i],isFirstLine=0===i,isLastLine=i===lines.length-1,isLastNonEmptyLine=i===lastNonEmptyLine;let trimmedLine=line.replace(/\t/g," ");isFirstLine||(trimmedLine=trimmedLine.replace(/^ +/,"")),isLastLine||(trimmedLine=trimmedLine.replace(/ +$/,"")),trimmedLine&&(isLastNonEmptyLine||(trimmedLine+=" "),str+=trimmedLine);}str&&args.push((0, _index2.inherits)((0, _index.stringLiteral)(str),child));};var _index=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/generated/index.js"),_index2=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js");},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/utils/shallowEqual.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(actual,expected){const keys=Object.keys(expected);for(const key of keys)if(actual[key]!==expected[key])return  false;return  true};},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(match,allowPartial){const parts=match.split(".");return member=>(0, _matchesPattern.default)(member,parts,allowPartial)};var _matchesPattern=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/matchesPattern.js");},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/generated/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.isAccessor=function(node,opts){if(!node)return  false;if("ClassAccessorProperty"!==node.type)return  false;return null==opts||(0, _shallowEqual.default)(node,opts)},exports.isAnyTypeAnnotation=function(node,opts){return !!node&&("AnyTypeAnnotation"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isArgumentPlaceholder=function(node,opts){return !!node&&("ArgumentPlaceholder"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isArrayExpression=function(node,opts){return !!node&&("ArrayExpression"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isArrayPattern=function(node,opts){return !!node&&("ArrayPattern"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isArrayTypeAnnotation=function(node,opts){return !!node&&("ArrayTypeAnnotation"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isArrowFunctionExpression=function(node,opts){return !!node&&("ArrowFunctionExpression"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isAssignmentExpression=function(node,opts){return !!node&&("AssignmentExpression"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isAssignmentPattern=function(node,opts){return !!node&&("AssignmentPattern"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isAwaitExpression=function(node,opts){return !!node&&("AwaitExpression"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isBigIntLiteral=function(node,opts){return !!node&&("BigIntLiteral"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isBinary=function(node,opts){if(!node)return  false;switch(node.type){case "BinaryExpression":case "LogicalExpression":break;default:return  false}return null==opts||(0, _shallowEqual.default)(node,opts)},exports.isBinaryExpression=function(node,opts){return !!node&&("BinaryExpression"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isBindExpression=function(node,opts){return !!node&&("BindExpression"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isBlock=function(node,opts){if(!node)return  false;switch(node.type){case "BlockStatement":case "Program":case "TSModuleBlock":break;case "Placeholder":if("BlockStatement"===node.expectedNode)break;default:return  false}return null==opts||(0, _shallowEqual.default)(node,opts)},exports.isBlockParent=function(node,opts){if(!node)return  false;switch(node.type){case "BlockStatement":case "CatchClause":case "DoWhileStatement":case "ForInStatement":case "ForStatement":case "FunctionDeclaration":case "FunctionExpression":case "Program":case "ObjectMethod":case "SwitchStatement":case "WhileStatement":case "ArrowFunctionExpression":case "ForOfStatement":case "ClassMethod":case "ClassPrivateMethod":case "StaticBlock":case "TSModuleBlock":break;case "Placeholder":if("BlockStatement"===node.expectedNode)break;default:return  false}return null==opts||(0, _shallowEqual.default)(node,opts)},exports.isBlockStatement=function(node,opts){return !!node&&("BlockStatement"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isBooleanLiteral=function(node,opts){return !!node&&("BooleanLiteral"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isBooleanLiteralTypeAnnotation=function(node,opts){return !!node&&("BooleanLiteralTypeAnnotation"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isBooleanTypeAnnotation=function(node,opts){return !!node&&("BooleanTypeAnnotation"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isBreakStatement=function(node,opts){return !!node&&("BreakStatement"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isCallExpression=function(node,opts){return !!node&&("CallExpression"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isCatchClause=function(node,opts){return !!node&&("CatchClause"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isClass=function(node,opts){if(!node)return  false;switch(node.type){case "ClassExpression":case "ClassDeclaration":break;default:return  false}return null==opts||(0, _shallowEqual.default)(node,opts)},exports.isClassAccessorProperty=function(node,opts){return !!node&&("ClassAccessorProperty"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isClassBody=function(node,opts){return !!node&&("ClassBody"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isClassDeclaration=function(node,opts){return !!node&&("ClassDeclaration"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isClassExpression=function(node,opts){return !!node&&("ClassExpression"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isClassImplements=function(node,opts){return !!node&&("ClassImplements"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isClassMethod=function(node,opts){return !!node&&("ClassMethod"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isClassPrivateMethod=function(node,opts){return !!node&&("ClassPrivateMethod"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isClassPrivateProperty=function(node,opts){return !!node&&("ClassPrivateProperty"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isClassProperty=function(node,opts){return !!node&&("ClassProperty"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isCompletionStatement=function(node,opts){if(!node)return  false;switch(node.type){case "BreakStatement":case "ContinueStatement":case "ReturnStatement":case "ThrowStatement":break;default:return  false}return null==opts||(0, _shallowEqual.default)(node,opts)},exports.isConditional=function(node,opts){if(!node)return  false;switch(node.type){case "ConditionalExpression":case "IfStatement":break;default:return  false}return null==opts||(0, _shallowEqual.default)(node,opts)},exports.isConditionalExpression=function(node,opts){return !!node&&("ConditionalExpression"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isContinueStatement=function(node,opts){return !!node&&("ContinueStatement"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isDebuggerStatement=function(node,opts){return !!node&&("DebuggerStatement"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isDecimalLiteral=function(node,opts){return !!node&&("DecimalLiteral"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isDeclaration=function(node,opts){if(!node)return  false;switch(node.type){case "FunctionDeclaration":case "VariableDeclaration":case "ClassDeclaration":case "ExportAllDeclaration":case "ExportDefaultDeclaration":case "ExportNamedDeclaration":case "ImportDeclaration":case "DeclareClass":case "DeclareFunction":case "DeclareInterface":case "DeclareModule":case "DeclareModuleExports":case "DeclareTypeAlias":case "DeclareOpaqueType":case "DeclareVariable":case "DeclareExportDeclaration":case "DeclareExportAllDeclaration":case "InterfaceDeclaration":case "OpaqueType":case "TypeAlias":case "EnumDeclaration":case "TSDeclareFunction":case "TSInterfaceDeclaration":case "TSTypeAliasDeclaration":case "TSEnumDeclaration":case "TSModuleDeclaration":break;case "Placeholder":if("Declaration"===node.expectedNode)break;default:return  false}return null==opts||(0, _shallowEqual.default)(node,opts)},exports.isDeclareClass=function(node,opts){return !!node&&("DeclareClass"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isDeclareExportAllDeclaration=function(node,opts){return !!node&&("DeclareExportAllDeclaration"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isDeclareExportDeclaration=function(node,opts){return !!node&&("DeclareExportDeclaration"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isDeclareFunction=function(node,opts){return !!node&&("DeclareFunction"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isDeclareInterface=function(node,opts){return !!node&&("DeclareInterface"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isDeclareModule=function(node,opts){return !!node&&("DeclareModule"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isDeclareModuleExports=function(node,opts){return !!node&&("DeclareModuleExports"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isDeclareOpaqueType=function(node,opts){return !!node&&("DeclareOpaqueType"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isDeclareTypeAlias=function(node,opts){return !!node&&("DeclareTypeAlias"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isDeclareVariable=function(node,opts){return !!node&&("DeclareVariable"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isDeclaredPredicate=function(node,opts){return !!node&&("DeclaredPredicate"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isDecorator=function(node,opts){return !!node&&("Decorator"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isDirective=function(node,opts){return !!node&&("Directive"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isDirectiveLiteral=function(node,opts){return !!node&&("DirectiveLiteral"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isDoExpression=function(node,opts){return !!node&&("DoExpression"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isDoWhileStatement=function(node,opts){return !!node&&("DoWhileStatement"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isEmptyStatement=function(node,opts){return !!node&&("EmptyStatement"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isEmptyTypeAnnotation=function(node,opts){return !!node&&("EmptyTypeAnnotation"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isEnumBody=function(node,opts){if(!node)return  false;switch(node.type){case "EnumBooleanBody":case "EnumNumberBody":case "EnumStringBody":case "EnumSymbolBody":break;default:return  false}return null==opts||(0, _shallowEqual.default)(node,opts)},exports.isEnumBooleanBody=function(node,opts){return !!node&&("EnumBooleanBody"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isEnumBooleanMember=function(node,opts){return !!node&&("EnumBooleanMember"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isEnumDeclaration=function(node,opts){return !!node&&("EnumDeclaration"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isEnumDefaultedMember=function(node,opts){return !!node&&("EnumDefaultedMember"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isEnumMember=function(node,opts){if(!node)return  false;switch(node.type){case "EnumBooleanMember":case "EnumNumberMember":case "EnumStringMember":case "EnumDefaultedMember":break;default:return  false}return null==opts||(0, _shallowEqual.default)(node,opts)},exports.isEnumNumberBody=function(node,opts){return !!node&&("EnumNumberBody"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isEnumNumberMember=function(node,opts){return !!node&&("EnumNumberMember"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isEnumStringBody=function(node,opts){return !!node&&("EnumStringBody"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isEnumStringMember=function(node,opts){return !!node&&("EnumStringMember"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isEnumSymbolBody=function(node,opts){return !!node&&("EnumSymbolBody"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isExistsTypeAnnotation=function(node,opts){return !!node&&("ExistsTypeAnnotation"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isExportAllDeclaration=function(node,opts){return !!node&&("ExportAllDeclaration"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isExportDeclaration=function(node,opts){if(!node)return  false;switch(node.type){case "ExportAllDeclaration":case "ExportDefaultDeclaration":case "ExportNamedDeclaration":break;default:return  false}return null==opts||(0, _shallowEqual.default)(node,opts)},exports.isExportDefaultDeclaration=function(node,opts){return !!node&&("ExportDefaultDeclaration"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isExportDefaultSpecifier=function(node,opts){return !!node&&("ExportDefaultSpecifier"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isExportNamedDeclaration=function(node,opts){return !!node&&("ExportNamedDeclaration"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isExportNamespaceSpecifier=function(node,opts){return !!node&&("ExportNamespaceSpecifier"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isExportSpecifier=function(node,opts){return !!node&&("ExportSpecifier"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isExpression=function(node,opts){if(!node)return  false;switch(node.type){case "ArrayExpression":case "AssignmentExpression":case "BinaryExpression":case "CallExpression":case "ConditionalExpression":case "FunctionExpression":case "Identifier":case "StringLiteral":case "NumericLiteral":case "NullLiteral":case "BooleanLiteral":case "RegExpLiteral":case "LogicalExpression":case "MemberExpression":case "NewExpression":case "ObjectExpression":case "SequenceExpression":case "ParenthesizedExpression":case "ThisExpression":case "UnaryExpression":case "UpdateExpression":case "ArrowFunctionExpression":case "ClassExpression":case "ImportExpression":case "MetaProperty":case "Super":case "TaggedTemplateExpression":case "TemplateLiteral":case "YieldExpression":case "AwaitExpression":case "Import":case "BigIntLiteral":case "OptionalMemberExpression":case "OptionalCallExpression":case "TypeCastExpression":case "JSXElement":case "JSXFragment":case "BindExpression":case "DoExpression":case "RecordExpression":case "TupleExpression":case "DecimalLiteral":case "ModuleExpression":case "TopicReference":case "PipelineTopicExpression":case "PipelineBareFunction":case "PipelinePrimaryTopicReference":case "TSInstantiationExpression":case "TSAsExpression":case "TSSatisfiesExpression":case "TSTypeAssertion":case "TSNonNullExpression":break;case "Placeholder":switch(node.expectedNode){case "Expression":case "Identifier":case "StringLiteral":break;default:return  false}break;default:return  false}return null==opts||(0, _shallowEqual.default)(node,opts)},exports.isExpressionStatement=function(node,opts){return !!node&&("ExpressionStatement"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isExpressionWrapper=function(node,opts){if(!node)return  false;switch(node.type){case "ExpressionStatement":case "ParenthesizedExpression":case "TypeCastExpression":break;default:return  false}return null==opts||(0, _shallowEqual.default)(node,opts)},exports.isFile=function(node,opts){return !!node&&("File"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isFlow=function(node,opts){if(!node)return  false;switch(node.type){case "AnyTypeAnnotation":case "ArrayTypeAnnotation":case "BooleanTypeAnnotation":case "BooleanLiteralTypeAnnotation":case "NullLiteralTypeAnnotation":case "ClassImplements":case "DeclareClass":case "DeclareFunction":case "DeclareInterface":case "DeclareModule":case "DeclareModuleExports":case "DeclareTypeAlias":case "DeclareOpaqueType":case "DeclareVariable":case "DeclareExportDeclaration":case "DeclareExportAllDeclaration":case "DeclaredPredicate":case "ExistsTypeAnnotation":case "FunctionTypeAnnotation":case "FunctionTypeParam":case "GenericTypeAnnotation":case "InferredPredicate":case "InterfaceExtends":case "InterfaceDeclaration":case "InterfaceTypeAnnotation":case "IntersectionTypeAnnotation":case "MixedTypeAnnotation":case "EmptyTypeAnnotation":case "NullableTypeAnnotation":case "NumberLiteralTypeAnnotation":case "NumberTypeAnnotation":case "ObjectTypeAnnotation":case "ObjectTypeInternalSlot":case "ObjectTypeCallProperty":case "ObjectTypeIndexer":case "ObjectTypeProperty":case "ObjectTypeSpreadProperty":case "OpaqueType":case "QualifiedTypeIdentifier":case "StringLiteralTypeAnnotation":case "StringTypeAnnotation":case "SymbolTypeAnnotation":case "ThisTypeAnnotation":case "TupleTypeAnnotation":case "TypeofTypeAnnotation":case "TypeAlias":case "TypeAnnotation":case "TypeCastExpression":case "TypeParameter":case "TypeParameterDeclaration":case "TypeParameterInstantiation":case "UnionTypeAnnotation":case "Variance":case "VoidTypeAnnotation":case "EnumDeclaration":case "EnumBooleanBody":case "EnumNumberBody":case "EnumStringBody":case "EnumSymbolBody":case "EnumBooleanMember":case "EnumNumberMember":case "EnumStringMember":case "EnumDefaultedMember":case "IndexedAccessType":case "OptionalIndexedAccessType":break;default:return  false}return null==opts||(0, _shallowEqual.default)(node,opts)},exports.isFlowBaseAnnotation=function(node,opts){if(!node)return  false;switch(node.type){case "AnyTypeAnnotation":case "BooleanTypeAnnotation":case "NullLiteralTypeAnnotation":case "MixedTypeAnnotation":case "EmptyTypeAnnotation":case "NumberTypeAnnotation":case "StringTypeAnnotation":case "SymbolTypeAnnotation":case "ThisTypeAnnotation":case "VoidTypeAnnotation":break;default:return  false}return null==opts||(0, _shallowEqual.default)(node,opts)},exports.isFlowDeclaration=function(node,opts){if(!node)return  false;switch(node.type){case "DeclareClass":case "DeclareFunction":case "DeclareInterface":case "DeclareModule":case "DeclareModuleExports":case "DeclareTypeAlias":case "DeclareOpaqueType":case "DeclareVariable":case "DeclareExportDeclaration":case "DeclareExportAllDeclaration":case "InterfaceDeclaration":case "OpaqueType":case "TypeAlias":break;default:return  false}return null==opts||(0, _shallowEqual.default)(node,opts)},exports.isFlowPredicate=function(node,opts){if(!node)return  false;switch(node.type){case "DeclaredPredicate":case "InferredPredicate":break;default:return  false}return null==opts||(0, _shallowEqual.default)(node,opts)},exports.isFlowType=function(node,opts){if(!node)return  false;switch(node.type){case "AnyTypeAnnotation":case "ArrayTypeAnnotation":case "BooleanTypeAnnotation":case "BooleanLiteralTypeAnnotation":case "NullLiteralTypeAnnotation":case "ExistsTypeAnnotation":case "FunctionTypeAnnotation":case "GenericTypeAnnotation":case "InterfaceTypeAnnotation":case "IntersectionTypeAnnotation":case "MixedTypeAnnotation":case "EmptyTypeAnnotation":case "NullableTypeAnnotation":case "NumberLiteralTypeAnnotation":case "NumberTypeAnnotation":case "ObjectTypeAnnotation":case "StringLiteralTypeAnnotation":case "StringTypeAnnotation":case "SymbolTypeAnnotation":case "ThisTypeAnnotation":case "TupleTypeAnnotation":case "TypeofTypeAnnotation":case "UnionTypeAnnotation":case "VoidTypeAnnotation":case "IndexedAccessType":case "OptionalIndexedAccessType":break;default:return  false}return null==opts||(0, _shallowEqual.default)(node,opts)},exports.isFor=function(node,opts){if(!node)return  false;switch(node.type){case "ForInStatement":case "ForStatement":case "ForOfStatement":break;default:return  false}return null==opts||(0, _shallowEqual.default)(node,opts)},exports.isForInStatement=function(node,opts){return !!node&&("ForInStatement"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isForOfStatement=function(node,opts){return !!node&&("ForOfStatement"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isForStatement=function(node,opts){return !!node&&("ForStatement"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isForXStatement=function(node,opts){if(!node)return  false;switch(node.type){case "ForInStatement":case "ForOfStatement":break;default:return  false}return null==opts||(0, _shallowEqual.default)(node,opts)},exports.isFunction=function(node,opts){if(!node)return  false;switch(node.type){case "FunctionDeclaration":case "FunctionExpression":case "ObjectMethod":case "ArrowFunctionExpression":case "ClassMethod":case "ClassPrivateMethod":break;default:return  false}return null==opts||(0, _shallowEqual.default)(node,opts)},exports.isFunctionDeclaration=function(node,opts){return !!node&&("FunctionDeclaration"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isFunctionExpression=function(node,opts){return !!node&&("FunctionExpression"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isFunctionParent=function(node,opts){if(!node)return  false;switch(node.type){case "FunctionDeclaration":case "FunctionExpression":case "ObjectMethod":case "ArrowFunctionExpression":case "ClassMethod":case "ClassPrivateMethod":case "StaticBlock":case "TSModuleBlock":break;default:return  false}return null==opts||(0, _shallowEqual.default)(node,opts)},exports.isFunctionTypeAnnotation=function(node,opts){return !!node&&("FunctionTypeAnnotation"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isFunctionTypeParam=function(node,opts){return !!node&&("FunctionTypeParam"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isGenericTypeAnnotation=function(node,opts){return !!node&&("GenericTypeAnnotation"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isIdentifier=function(node,opts){return !!node&&("Identifier"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isIfStatement=function(node,opts){return !!node&&("IfStatement"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isImmutable=function(node,opts){if(!node)return  false;switch(node.type){case "StringLiteral":case "NumericLiteral":case "NullLiteral":case "BooleanLiteral":case "BigIntLiteral":case "JSXAttribute":case "JSXClosingElement":case "JSXElement":case "JSXExpressionContainer":case "JSXSpreadChild":case "JSXOpeningElement":case "JSXText":case "JSXFragment":case "JSXOpeningFragment":case "JSXClosingFragment":case "DecimalLiteral":break;case "Placeholder":if("StringLiteral"===node.expectedNode)break;default:return  false}return null==opts||(0, _shallowEqual.default)(node,opts)},exports.isImport=function(node,opts){return !!node&&("Import"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isImportAttribute=function(node,opts){return !!node&&("ImportAttribute"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isImportDeclaration=function(node,opts){return !!node&&("ImportDeclaration"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isImportDefaultSpecifier=function(node,opts){return !!node&&("ImportDefaultSpecifier"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isImportExpression=function(node,opts){return !!node&&("ImportExpression"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isImportNamespaceSpecifier=function(node,opts){return !!node&&("ImportNamespaceSpecifier"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isImportOrExportDeclaration=isImportOrExportDeclaration,exports.isImportSpecifier=function(node,opts){return !!node&&("ImportSpecifier"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isIndexedAccessType=function(node,opts){return !!node&&("IndexedAccessType"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isInferredPredicate=function(node,opts){return !!node&&("InferredPredicate"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isInterfaceDeclaration=function(node,opts){return !!node&&("InterfaceDeclaration"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isInterfaceExtends=function(node,opts){return !!node&&("InterfaceExtends"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isInterfaceTypeAnnotation=function(node,opts){return !!node&&("InterfaceTypeAnnotation"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isInterpreterDirective=function(node,opts){return !!node&&("InterpreterDirective"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isIntersectionTypeAnnotation=function(node,opts){return !!node&&("IntersectionTypeAnnotation"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isJSX=function(node,opts){if(!node)return  false;switch(node.type){case "JSXAttribute":case "JSXClosingElement":case "JSXElement":case "JSXEmptyExpression":case "JSXExpressionContainer":case "JSXSpreadChild":case "JSXIdentifier":case "JSXMemberExpression":case "JSXNamespacedName":case "JSXOpeningElement":case "JSXSpreadAttribute":case "JSXText":case "JSXFragment":case "JSXOpeningFragment":case "JSXClosingFragment":break;default:return  false}return null==opts||(0, _shallowEqual.default)(node,opts)},exports.isJSXAttribute=function(node,opts){return !!node&&("JSXAttribute"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isJSXClosingElement=function(node,opts){return !!node&&("JSXClosingElement"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isJSXClosingFragment=function(node,opts){return !!node&&("JSXClosingFragment"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isJSXElement=function(node,opts){return !!node&&("JSXElement"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isJSXEmptyExpression=function(node,opts){return !!node&&("JSXEmptyExpression"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isJSXExpressionContainer=function(node,opts){return !!node&&("JSXExpressionContainer"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isJSXFragment=function(node,opts){return !!node&&("JSXFragment"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isJSXIdentifier=function(node,opts){return !!node&&("JSXIdentifier"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isJSXMemberExpression=function(node,opts){return !!node&&("JSXMemberExpression"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isJSXNamespacedName=function(node,opts){return !!node&&("JSXNamespacedName"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isJSXOpeningElement=function(node,opts){return !!node&&("JSXOpeningElement"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isJSXOpeningFragment=function(node,opts){return !!node&&("JSXOpeningFragment"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isJSXSpreadAttribute=function(node,opts){return !!node&&("JSXSpreadAttribute"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isJSXSpreadChild=function(node,opts){return !!node&&("JSXSpreadChild"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isJSXText=function(node,opts){return !!node&&("JSXText"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isLVal=function(node,opts){if(!node)return  false;switch(node.type){case "Identifier":case "MemberExpression":case "RestElement":case "AssignmentPattern":case "ArrayPattern":case "ObjectPattern":case "TSParameterProperty":case "TSAsExpression":case "TSSatisfiesExpression":case "TSTypeAssertion":case "TSNonNullExpression":break;case "Placeholder":switch(node.expectedNode){case "Pattern":case "Identifier":break;default:return  false}break;default:return  false}return null==opts||(0, _shallowEqual.default)(node,opts)},exports.isLabeledStatement=function(node,opts){return !!node&&("LabeledStatement"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isLiteral=function(node,opts){if(!node)return  false;switch(node.type){case "StringLiteral":case "NumericLiteral":case "NullLiteral":case "BooleanLiteral":case "RegExpLiteral":case "TemplateLiteral":case "BigIntLiteral":case "DecimalLiteral":break;case "Placeholder":if("StringLiteral"===node.expectedNode)break;default:return  false}return null==opts||(0, _shallowEqual.default)(node,opts)},exports.isLogicalExpression=function(node,opts){return !!node&&("LogicalExpression"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isLoop=function(node,opts){if(!node)return  false;switch(node.type){case "DoWhileStatement":case "ForInStatement":case "ForStatement":case "WhileStatement":case "ForOfStatement":break;default:return  false}return null==opts||(0, _shallowEqual.default)(node,opts)},exports.isMemberExpression=function(node,opts){return !!node&&("MemberExpression"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isMetaProperty=function(node,opts){return !!node&&("MetaProperty"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isMethod=function(node,opts){if(!node)return  false;switch(node.type){case "ObjectMethod":case "ClassMethod":case "ClassPrivateMethod":break;default:return  false}return null==opts||(0, _shallowEqual.default)(node,opts)},exports.isMiscellaneous=function(node,opts){if(!node)return  false;switch(node.type){case "Noop":case "Placeholder":case "V8IntrinsicIdentifier":break;default:return  false}return null==opts||(0, _shallowEqual.default)(node,opts)},exports.isMixedTypeAnnotation=function(node,opts){return !!node&&("MixedTypeAnnotation"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isModuleDeclaration=function(node,opts){return (0, _deprecationWarning.default)("isModuleDeclaration","isImportOrExportDeclaration"),isImportOrExportDeclaration(node,opts)},exports.isModuleExpression=function(node,opts){return !!node&&("ModuleExpression"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isModuleSpecifier=function(node,opts){if(!node)return  false;switch(node.type){case "ExportSpecifier":case "ImportDefaultSpecifier":case "ImportNamespaceSpecifier":case "ImportSpecifier":case "ExportNamespaceSpecifier":case "ExportDefaultSpecifier":break;default:return  false}return null==opts||(0, _shallowEqual.default)(node,opts)},exports.isNewExpression=function(node,opts){return !!node&&("NewExpression"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isNoop=function(node,opts){return !!node&&("Noop"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isNullLiteral=function(node,opts){return !!node&&("NullLiteral"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isNullLiteralTypeAnnotation=function(node,opts){return !!node&&("NullLiteralTypeAnnotation"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isNullableTypeAnnotation=function(node,opts){return !!node&&("NullableTypeAnnotation"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isNumberLiteral=function(node,opts){return (0, _deprecationWarning.default)("isNumberLiteral","isNumericLiteral"),!!node&&("NumberLiteral"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isNumberLiteralTypeAnnotation=function(node,opts){return !!node&&("NumberLiteralTypeAnnotation"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isNumberTypeAnnotation=function(node,opts){return !!node&&("NumberTypeAnnotation"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isNumericLiteral=function(node,opts){return !!node&&("NumericLiteral"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isObjectExpression=function(node,opts){return !!node&&("ObjectExpression"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isObjectMember=function(node,opts){if(!node)return  false;switch(node.type){case "ObjectMethod":case "ObjectProperty":break;default:return  false}return null==opts||(0, _shallowEqual.default)(node,opts)},exports.isObjectMethod=function(node,opts){return !!node&&("ObjectMethod"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isObjectPattern=function(node,opts){return !!node&&("ObjectPattern"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isObjectProperty=function(node,opts){return !!node&&("ObjectProperty"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isObjectTypeAnnotation=function(node,opts){return !!node&&("ObjectTypeAnnotation"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isObjectTypeCallProperty=function(node,opts){return !!node&&("ObjectTypeCallProperty"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isObjectTypeIndexer=function(node,opts){return !!node&&("ObjectTypeIndexer"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isObjectTypeInternalSlot=function(node,opts){return !!node&&("ObjectTypeInternalSlot"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isObjectTypeProperty=function(node,opts){return !!node&&("ObjectTypeProperty"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isObjectTypeSpreadProperty=function(node,opts){return !!node&&("ObjectTypeSpreadProperty"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isOpaqueType=function(node,opts){return !!node&&("OpaqueType"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isOptionalCallExpression=function(node,opts){return !!node&&("OptionalCallExpression"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isOptionalIndexedAccessType=function(node,opts){return !!node&&("OptionalIndexedAccessType"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isOptionalMemberExpression=function(node,opts){return !!node&&("OptionalMemberExpression"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isParenthesizedExpression=function(node,opts){return !!node&&("ParenthesizedExpression"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isPattern=function(node,opts){if(!node)return  false;switch(node.type){case "AssignmentPattern":case "ArrayPattern":case "ObjectPattern":break;case "Placeholder":if("Pattern"===node.expectedNode)break;default:return  false}return null==opts||(0, _shallowEqual.default)(node,opts)},exports.isPatternLike=function(node,opts){if(!node)return  false;switch(node.type){case "Identifier":case "RestElement":case "AssignmentPattern":case "ArrayPattern":case "ObjectPattern":case "TSAsExpression":case "TSSatisfiesExpression":case "TSTypeAssertion":case "TSNonNullExpression":break;case "Placeholder":switch(node.expectedNode){case "Pattern":case "Identifier":break;default:return  false}break;default:return  false}return null==opts||(0, _shallowEqual.default)(node,opts)},exports.isPipelineBareFunction=function(node,opts){return !!node&&("PipelineBareFunction"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isPipelinePrimaryTopicReference=function(node,opts){return !!node&&("PipelinePrimaryTopicReference"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isPipelineTopicExpression=function(node,opts){return !!node&&("PipelineTopicExpression"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isPlaceholder=function(node,opts){return !!node&&("Placeholder"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isPrivate=function(node,opts){if(!node)return  false;switch(node.type){case "ClassPrivateProperty":case "ClassPrivateMethod":case "PrivateName":break;default:return  false}return null==opts||(0, _shallowEqual.default)(node,opts)},exports.isPrivateName=function(node,opts){return !!node&&("PrivateName"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isProgram=function(node,opts){return !!node&&("Program"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isProperty=function(node,opts){if(!node)return  false;switch(node.type){case "ObjectProperty":case "ClassProperty":case "ClassAccessorProperty":case "ClassPrivateProperty":break;default:return  false}return null==opts||(0, _shallowEqual.default)(node,opts)},exports.isPureish=function(node,opts){if(!node)return  false;switch(node.type){case "FunctionDeclaration":case "FunctionExpression":case "StringLiteral":case "NumericLiteral":case "NullLiteral":case "BooleanLiteral":case "RegExpLiteral":case "ArrowFunctionExpression":case "BigIntLiteral":case "DecimalLiteral":break;case "Placeholder":if("StringLiteral"===node.expectedNode)break;default:return  false}return null==opts||(0, _shallowEqual.default)(node,opts)},exports.isQualifiedTypeIdentifier=function(node,opts){return !!node&&("QualifiedTypeIdentifier"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isRecordExpression=function(node,opts){return !!node&&("RecordExpression"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isRegExpLiteral=function(node,opts){return !!node&&("RegExpLiteral"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isRegexLiteral=function(node,opts){return (0, _deprecationWarning.default)("isRegexLiteral","isRegExpLiteral"),!!node&&("RegexLiteral"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isRestElement=function(node,opts){return !!node&&("RestElement"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isRestProperty=function(node,opts){return (0, _deprecationWarning.default)("isRestProperty","isRestElement"),!!node&&("RestProperty"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isReturnStatement=function(node,opts){return !!node&&("ReturnStatement"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isScopable=function(node,opts){if(!node)return  false;switch(node.type){case "BlockStatement":case "CatchClause":case "DoWhileStatement":case "ForInStatement":case "ForStatement":case "FunctionDeclaration":case "FunctionExpression":case "Program":case "ObjectMethod":case "SwitchStatement":case "WhileStatement":case "ArrowFunctionExpression":case "ClassExpression":case "ClassDeclaration":case "ForOfStatement":case "ClassMethod":case "ClassPrivateMethod":case "StaticBlock":case "TSModuleBlock":break;case "Placeholder":if("BlockStatement"===node.expectedNode)break;default:return  false}return null==opts||(0, _shallowEqual.default)(node,opts)},exports.isSequenceExpression=function(node,opts){return !!node&&("SequenceExpression"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isSpreadElement=function(node,opts){return !!node&&("SpreadElement"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isSpreadProperty=function(node,opts){return (0, _deprecationWarning.default)("isSpreadProperty","isSpreadElement"),!!node&&("SpreadProperty"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isStandardized=function(node,opts){if(!node)return  false;switch(node.type){case "ArrayExpression":case "AssignmentExpression":case "BinaryExpression":case "InterpreterDirective":case "Directive":case "DirectiveLiteral":case "BlockStatement":case "BreakStatement":case "CallExpression":case "CatchClause":case "ConditionalExpression":case "ContinueStatement":case "DebuggerStatement":case "DoWhileStatement":case "EmptyStatement":case "ExpressionStatement":case "File":case "ForInStatement":case "ForStatement":case "FunctionDeclaration":case "FunctionExpression":case "Identifier":case "IfStatement":case "LabeledStatement":case "StringLiteral":case "NumericLiteral":case "NullLiteral":case "BooleanLiteral":case "RegExpLiteral":case "LogicalExpression":case "MemberExpression":case "NewExpression":case "Program":case "ObjectExpression":case "ObjectMethod":case "ObjectProperty":case "RestElement":case "ReturnStatement":case "SequenceExpression":case "ParenthesizedExpression":case "SwitchCase":case "SwitchStatement":case "ThisExpression":case "ThrowStatement":case "TryStatement":case "UnaryExpression":case "UpdateExpression":case "VariableDeclaration":case "VariableDeclarator":case "WhileStatement":case "WithStatement":case "AssignmentPattern":case "ArrayPattern":case "ArrowFunctionExpression":case "ClassBody":case "ClassExpression":case "ClassDeclaration":case "ExportAllDeclaration":case "ExportDefaultDeclaration":case "ExportNamedDeclaration":case "ExportSpecifier":case "ForOfStatement":case "ImportDeclaration":case "ImportDefaultSpecifier":case "ImportNamespaceSpecifier":case "ImportSpecifier":case "ImportExpression":case "MetaProperty":case "ClassMethod":case "ObjectPattern":case "SpreadElement":case "Super":case "TaggedTemplateExpression":case "TemplateElement":case "TemplateLiteral":case "YieldExpression":case "AwaitExpression":case "Import":case "BigIntLiteral":case "ExportNamespaceSpecifier":case "OptionalMemberExpression":case "OptionalCallExpression":case "ClassProperty":case "ClassAccessorProperty":case "ClassPrivateProperty":case "ClassPrivateMethod":case "PrivateName":case "StaticBlock":break;case "Placeholder":switch(node.expectedNode){case "Identifier":case "StringLiteral":case "BlockStatement":case "ClassBody":break;default:return  false}break;default:return  false}return null==opts||(0, _shallowEqual.default)(node,opts)},exports.isStatement=function(node,opts){if(!node)return  false;switch(node.type){case "BlockStatement":case "BreakStatement":case "ContinueStatement":case "DebuggerStatement":case "DoWhileStatement":case "EmptyStatement":case "ExpressionStatement":case "ForInStatement":case "ForStatement":case "FunctionDeclaration":case "IfStatement":case "LabeledStatement":case "ReturnStatement":case "SwitchStatement":case "ThrowStatement":case "TryStatement":case "VariableDeclaration":case "WhileStatement":case "WithStatement":case "ClassDeclaration":case "ExportAllDeclaration":case "ExportDefaultDeclaration":case "ExportNamedDeclaration":case "ForOfStatement":case "ImportDeclaration":case "DeclareClass":case "DeclareFunction":case "DeclareInterface":case "DeclareModule":case "DeclareModuleExports":case "DeclareTypeAlias":case "DeclareOpaqueType":case "DeclareVariable":case "DeclareExportDeclaration":case "DeclareExportAllDeclaration":case "InterfaceDeclaration":case "OpaqueType":case "TypeAlias":case "EnumDeclaration":case "TSDeclareFunction":case "TSInterfaceDeclaration":case "TSTypeAliasDeclaration":case "TSEnumDeclaration":case "TSModuleDeclaration":case "TSImportEqualsDeclaration":case "TSExportAssignment":case "TSNamespaceExportDeclaration":break;case "Placeholder":switch(node.expectedNode){case "Statement":case "Declaration":case "BlockStatement":break;default:return  false}break;default:return  false}return null==opts||(0, _shallowEqual.default)(node,opts)},exports.isStaticBlock=function(node,opts){return !!node&&("StaticBlock"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isStringLiteral=function(node,opts){return !!node&&("StringLiteral"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isStringLiteralTypeAnnotation=function(node,opts){return !!node&&("StringLiteralTypeAnnotation"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isStringTypeAnnotation=function(node,opts){return !!node&&("StringTypeAnnotation"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isSuper=function(node,opts){return !!node&&("Super"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isSwitchCase=function(node,opts){return !!node&&("SwitchCase"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isSwitchStatement=function(node,opts){return !!node&&("SwitchStatement"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isSymbolTypeAnnotation=function(node,opts){return !!node&&("SymbolTypeAnnotation"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSAnyKeyword=function(node,opts){return !!node&&("TSAnyKeyword"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSArrayType=function(node,opts){return !!node&&("TSArrayType"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSAsExpression=function(node,opts){return !!node&&("TSAsExpression"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSBaseType=function(node,opts){if(!node)return  false;switch(node.type){case "TSAnyKeyword":case "TSBooleanKeyword":case "TSBigIntKeyword":case "TSIntrinsicKeyword":case "TSNeverKeyword":case "TSNullKeyword":case "TSNumberKeyword":case "TSObjectKeyword":case "TSStringKeyword":case "TSSymbolKeyword":case "TSUndefinedKeyword":case "TSUnknownKeyword":case "TSVoidKeyword":case "TSThisType":case "TSLiteralType":break;default:return  false}return null==opts||(0, _shallowEqual.default)(node,opts)},exports.isTSBigIntKeyword=function(node,opts){return !!node&&("TSBigIntKeyword"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSBooleanKeyword=function(node,opts){return !!node&&("TSBooleanKeyword"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSCallSignatureDeclaration=function(node,opts){return !!node&&("TSCallSignatureDeclaration"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSConditionalType=function(node,opts){return !!node&&("TSConditionalType"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSConstructSignatureDeclaration=function(node,opts){return !!node&&("TSConstructSignatureDeclaration"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSConstructorType=function(node,opts){return !!node&&("TSConstructorType"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSDeclareFunction=function(node,opts){return !!node&&("TSDeclareFunction"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSDeclareMethod=function(node,opts){return !!node&&("TSDeclareMethod"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSEntityName=function(node,opts){if(!node)return  false;switch(node.type){case "Identifier":case "TSQualifiedName":break;case "Placeholder":if("Identifier"===node.expectedNode)break;default:return  false}return null==opts||(0, _shallowEqual.default)(node,opts)},exports.isTSEnumDeclaration=function(node,opts){return !!node&&("TSEnumDeclaration"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSEnumMember=function(node,opts){return !!node&&("TSEnumMember"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSExportAssignment=function(node,opts){return !!node&&("TSExportAssignment"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSExpressionWithTypeArguments=function(node,opts){return !!node&&("TSExpressionWithTypeArguments"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSExternalModuleReference=function(node,opts){return !!node&&("TSExternalModuleReference"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSFunctionType=function(node,opts){return !!node&&("TSFunctionType"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSImportEqualsDeclaration=function(node,opts){return !!node&&("TSImportEqualsDeclaration"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSImportType=function(node,opts){return !!node&&("TSImportType"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSIndexSignature=function(node,opts){return !!node&&("TSIndexSignature"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSIndexedAccessType=function(node,opts){return !!node&&("TSIndexedAccessType"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSInferType=function(node,opts){return !!node&&("TSInferType"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSInstantiationExpression=function(node,opts){return !!node&&("TSInstantiationExpression"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSInterfaceBody=function(node,opts){return !!node&&("TSInterfaceBody"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSInterfaceDeclaration=function(node,opts){return !!node&&("TSInterfaceDeclaration"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSIntersectionType=function(node,opts){return !!node&&("TSIntersectionType"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSIntrinsicKeyword=function(node,opts){return !!node&&("TSIntrinsicKeyword"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSLiteralType=function(node,opts){return !!node&&("TSLiteralType"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSMappedType=function(node,opts){return !!node&&("TSMappedType"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSMethodSignature=function(node,opts){return !!node&&("TSMethodSignature"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSModuleBlock=function(node,opts){return !!node&&("TSModuleBlock"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSModuleDeclaration=function(node,opts){return !!node&&("TSModuleDeclaration"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSNamedTupleMember=function(node,opts){return !!node&&("TSNamedTupleMember"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSNamespaceExportDeclaration=function(node,opts){return !!node&&("TSNamespaceExportDeclaration"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSNeverKeyword=function(node,opts){return !!node&&("TSNeverKeyword"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSNonNullExpression=function(node,opts){return !!node&&("TSNonNullExpression"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSNullKeyword=function(node,opts){return !!node&&("TSNullKeyword"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSNumberKeyword=function(node,opts){return !!node&&("TSNumberKeyword"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSObjectKeyword=function(node,opts){return !!node&&("TSObjectKeyword"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSOptionalType=function(node,opts){return !!node&&("TSOptionalType"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSParameterProperty=function(node,opts){return !!node&&("TSParameterProperty"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSParenthesizedType=function(node,opts){return !!node&&("TSParenthesizedType"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSPropertySignature=function(node,opts){return !!node&&("TSPropertySignature"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSQualifiedName=function(node,opts){return !!node&&("TSQualifiedName"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSRestType=function(node,opts){return !!node&&("TSRestType"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSSatisfiesExpression=function(node,opts){return !!node&&("TSSatisfiesExpression"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSStringKeyword=function(node,opts){return !!node&&("TSStringKeyword"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSSymbolKeyword=function(node,opts){return !!node&&("TSSymbolKeyword"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSThisType=function(node,opts){return !!node&&("TSThisType"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSTupleType=function(node,opts){return !!node&&("TSTupleType"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSType=function(node,opts){if(!node)return  false;switch(node.type){case "TSAnyKeyword":case "TSBooleanKeyword":case "TSBigIntKeyword":case "TSIntrinsicKeyword":case "TSNeverKeyword":case "TSNullKeyword":case "TSNumberKeyword":case "TSObjectKeyword":case "TSStringKeyword":case "TSSymbolKeyword":case "TSUndefinedKeyword":case "TSUnknownKeyword":case "TSVoidKeyword":case "TSThisType":case "TSFunctionType":case "TSConstructorType":case "TSTypeReference":case "TSTypePredicate":case "TSTypeQuery":case "TSTypeLiteral":case "TSArrayType":case "TSTupleType":case "TSOptionalType":case "TSRestType":case "TSUnionType":case "TSIntersectionType":case "TSConditionalType":case "TSInferType":case "TSParenthesizedType":case "TSTypeOperator":case "TSIndexedAccessType":case "TSMappedType":case "TSLiteralType":case "TSExpressionWithTypeArguments":case "TSImportType":break;default:return  false}return null==opts||(0, _shallowEqual.default)(node,opts)},exports.isTSTypeAliasDeclaration=function(node,opts){return !!node&&("TSTypeAliasDeclaration"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSTypeAnnotation=function(node,opts){return !!node&&("TSTypeAnnotation"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSTypeAssertion=function(node,opts){return !!node&&("TSTypeAssertion"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSTypeElement=function(node,opts){if(!node)return  false;switch(node.type){case "TSCallSignatureDeclaration":case "TSConstructSignatureDeclaration":case "TSPropertySignature":case "TSMethodSignature":case "TSIndexSignature":break;default:return  false}return null==opts||(0, _shallowEqual.default)(node,opts)},exports.isTSTypeLiteral=function(node,opts){return !!node&&("TSTypeLiteral"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSTypeOperator=function(node,opts){return !!node&&("TSTypeOperator"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSTypeParameter=function(node,opts){return !!node&&("TSTypeParameter"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSTypeParameterDeclaration=function(node,opts){return !!node&&("TSTypeParameterDeclaration"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSTypeParameterInstantiation=function(node,opts){return !!node&&("TSTypeParameterInstantiation"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSTypePredicate=function(node,opts){return !!node&&("TSTypePredicate"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSTypeQuery=function(node,opts){return !!node&&("TSTypeQuery"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSTypeReference=function(node,opts){return !!node&&("TSTypeReference"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSUndefinedKeyword=function(node,opts){return !!node&&("TSUndefinedKeyword"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSUnionType=function(node,opts){return !!node&&("TSUnionType"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSUnknownKeyword=function(node,opts){return !!node&&("TSUnknownKeyword"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTSVoidKeyword=function(node,opts){return !!node&&("TSVoidKeyword"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTaggedTemplateExpression=function(node,opts){return !!node&&("TaggedTemplateExpression"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTemplateElement=function(node,opts){return !!node&&("TemplateElement"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTemplateLiteral=function(node,opts){return !!node&&("TemplateLiteral"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTerminatorless=function(node,opts){if(!node)return  false;switch(node.type){case "BreakStatement":case "ContinueStatement":case "ReturnStatement":case "ThrowStatement":case "YieldExpression":case "AwaitExpression":break;default:return  false}return null==opts||(0, _shallowEqual.default)(node,opts)},exports.isThisExpression=function(node,opts){return !!node&&("ThisExpression"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isThisTypeAnnotation=function(node,opts){return !!node&&("ThisTypeAnnotation"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isThrowStatement=function(node,opts){return !!node&&("ThrowStatement"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTopicReference=function(node,opts){return !!node&&("TopicReference"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTryStatement=function(node,opts){return !!node&&("TryStatement"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTupleExpression=function(node,opts){return !!node&&("TupleExpression"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTupleTypeAnnotation=function(node,opts){return !!node&&("TupleTypeAnnotation"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTypeAlias=function(node,opts){return !!node&&("TypeAlias"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTypeAnnotation=function(node,opts){return !!node&&("TypeAnnotation"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTypeCastExpression=function(node,opts){return !!node&&("TypeCastExpression"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTypeParameter=function(node,opts){return !!node&&("TypeParameter"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTypeParameterDeclaration=function(node,opts){return !!node&&("TypeParameterDeclaration"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTypeParameterInstantiation=function(node,opts){return !!node&&("TypeParameterInstantiation"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isTypeScript=function(node,opts){if(!node)return  false;switch(node.type){case "TSParameterProperty":case "TSDeclareFunction":case "TSDeclareMethod":case "TSQualifiedName":case "TSCallSignatureDeclaration":case "TSConstructSignatureDeclaration":case "TSPropertySignature":case "TSMethodSignature":case "TSIndexSignature":case "TSAnyKeyword":case "TSBooleanKeyword":case "TSBigIntKeyword":case "TSIntrinsicKeyword":case "TSNeverKeyword":case "TSNullKeyword":case "TSNumberKeyword":case "TSObjectKeyword":case "TSStringKeyword":case "TSSymbolKeyword":case "TSUndefinedKeyword":case "TSUnknownKeyword":case "TSVoidKeyword":case "TSThisType":case "TSFunctionType":case "TSConstructorType":case "TSTypeReference":case "TSTypePredicate":case "TSTypeQuery":case "TSTypeLiteral":case "TSArrayType":case "TSTupleType":case "TSOptionalType":case "TSRestType":case "TSNamedTupleMember":case "TSUnionType":case "TSIntersectionType":case "TSConditionalType":case "TSInferType":case "TSParenthesizedType":case "TSTypeOperator":case "TSIndexedAccessType":case "TSMappedType":case "TSLiteralType":case "TSExpressionWithTypeArguments":case "TSInterfaceDeclaration":case "TSInterfaceBody":case "TSTypeAliasDeclaration":case "TSInstantiationExpression":case "TSAsExpression":case "TSSatisfiesExpression":case "TSTypeAssertion":case "TSEnumDeclaration":case "TSEnumMember":case "TSModuleDeclaration":case "TSModuleBlock":case "TSImportType":case "TSImportEqualsDeclaration":case "TSExternalModuleReference":case "TSNonNullExpression":case "TSExportAssignment":case "TSNamespaceExportDeclaration":case "TSTypeAnnotation":case "TSTypeParameterInstantiation":case "TSTypeParameterDeclaration":case "TSTypeParameter":break;default:return  false}return null==opts||(0, _shallowEqual.default)(node,opts)},exports.isTypeofTypeAnnotation=function(node,opts){return !!node&&("TypeofTypeAnnotation"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isUnaryExpression=function(node,opts){return !!node&&("UnaryExpression"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isUnaryLike=function(node,opts){if(!node)return  false;switch(node.type){case "UnaryExpression":case "SpreadElement":break;default:return  false}return null==opts||(0, _shallowEqual.default)(node,opts)},exports.isUnionTypeAnnotation=function(node,opts){return !!node&&("UnionTypeAnnotation"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isUpdateExpression=function(node,opts){return !!node&&("UpdateExpression"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isUserWhitespacable=function(node,opts){if(!node)return  false;switch(node.type){case "ObjectMethod":case "ObjectProperty":case "ObjectTypeInternalSlot":case "ObjectTypeCallProperty":case "ObjectTypeIndexer":case "ObjectTypeProperty":case "ObjectTypeSpreadProperty":break;default:return  false}return null==opts||(0, _shallowEqual.default)(node,opts)},exports.isV8IntrinsicIdentifier=function(node,opts){return !!node&&("V8IntrinsicIdentifier"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isVariableDeclaration=function(node,opts){return !!node&&("VariableDeclaration"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isVariableDeclarator=function(node,opts){return !!node&&("VariableDeclarator"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isVariance=function(node,opts){return !!node&&("Variance"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isVoidTypeAnnotation=function(node,opts){return !!node&&("VoidTypeAnnotation"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isWhile=function(node,opts){if(!node)return  false;switch(node.type){case "DoWhileStatement":case "WhileStatement":break;default:return  false}return null==opts||(0, _shallowEqual.default)(node,opts)},exports.isWhileStatement=function(node,opts){return !!node&&("WhileStatement"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isWithStatement=function(node,opts){return !!node&&("WithStatement"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))},exports.isYieldExpression=function(node,opts){return !!node&&("YieldExpression"===node.type&&(null==opts||(0, _shallowEqual.default)(node,opts)))};var _shallowEqual=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/utils/shallowEqual.js"),_deprecationWarning=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/utils/deprecationWarning.js");function isImportOrExportDeclaration(node,opts){if(!node)return  false;switch(node.type){case "ExportAllDeclaration":case "ExportDefaultDeclaration":case "ExportNamedDeclaration":case "ImportDeclaration":break;default:return  false}return null==opts||(0, _shallowEqual.default)(node,opts)}},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/is.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(type,node,opts){if(!node)return  false;if(!(0, _isType.default)(node.type,type))return !opts&&"Placeholder"===node.type&&type in _index.FLIPPED_ALIAS_KEYS&&(0, _isPlaceholderType.default)(node.expectedNode,type);return void 0===opts||(0, _shallowEqual.default)(node,opts)};var _shallowEqual=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/utils/shallowEqual.js"),_isType=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isType.js"),_isPlaceholderType=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isPlaceholderType.js"),_index=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/index.js");},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isBinding.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(node,parent,grandparent){if(grandparent&&"Identifier"===node.type&&"ObjectProperty"===parent.type&&"ObjectExpression"===grandparent.type)return  false;const keys=_getBindingIdentifiers.default.keys[parent.type];if(keys)for(let i=0;i<keys.length;i++){const val=parent[keys[i]];if(Array.isArray(val)){if(val.includes(node))return  true}else if(val===node)return  true}return  false};var _getBindingIdentifiers=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js");},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isBlockScoped.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(node){return (0, _index.isFunctionDeclaration)(node)||(0, _index.isClassDeclaration)(node)||(0, _isLet.default)(node)};var _index=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/generated/index.js"),_isLet=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isLet.js");},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isImmutable.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(node){if((0, _isType.default)(node.type,"Immutable"))return  true;if((0, _index.isIdentifier)(node))return "undefined"===node.name;return  false};var _isType=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isType.js"),_index=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/generated/index.js");},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isLet.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(node){return (0, _index.isVariableDeclaration)(node)&&("var"!==node.kind||node[_index2.BLOCK_SCOPED_SYMBOL])};var _index=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/generated/index.js"),_index2=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/constants/index.js");},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isNode.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(node){return !(!node||!_index.VISITOR_KEYS[node.type])};var _index=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/index.js");},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isNodesEquivalent.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function isNodesEquivalent(a,b){if("object"!=typeof a||"object"!=typeof b||null==a||null==b)return a===b;if(a.type!==b.type)return  false;const fields=Object.keys(_index.NODE_FIELDS[a.type]||a.type),visitorKeys=_index.VISITOR_KEYS[a.type];for(const field of fields){const val_a=a[field],val_b=b[field];if(typeof val_a!=typeof val_b)return  false;if(null!=val_a||null!=val_b){if(null==val_a||null==val_b)return  false;if(Array.isArray(val_a)){if(!Array.isArray(val_b))return  false;if(val_a.length!==val_b.length)return  false;for(let i=0;i<val_a.length;i++)if(!isNodesEquivalent(val_a[i],val_b[i]))return  false}else if("object"!=typeof val_a||null!=visitorKeys&&visitorKeys.includes(field)){if(!isNodesEquivalent(val_a,val_b))return  false}else for(const key of Object.keys(val_a))if(val_a[key]!==val_b[key])return  false}}return  true};var _index=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/index.js");},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isPlaceholderType.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(placeholderType,targetType){if(placeholderType===targetType)return  true;const aliases=_index.PLACEHOLDERS_ALIAS[placeholderType];if(aliases)for(const alias of aliases)if(targetType===alias)return  true;return  false};var _index=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/index.js");},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isReferenced.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(node,parent,grandparent){switch(parent.type){case "MemberExpression":case "OptionalMemberExpression":return parent.property===node?!!parent.computed:parent.object===node;case "JSXMemberExpression":return parent.object===node;case "VariableDeclarator":return parent.init===node;case "ArrowFunctionExpression":return parent.body===node;case "PrivateName":case "LabeledStatement":case "CatchClause":case "RestElement":case "BreakStatement":case "ContinueStatement":case "FunctionDeclaration":case "FunctionExpression":case "ExportNamespaceSpecifier":case "ExportDefaultSpecifier":case "ImportDefaultSpecifier":case "ImportNamespaceSpecifier":case "ImportSpecifier":case "ImportAttribute":case "JSXAttribute":case "ObjectPattern":case "ArrayPattern":case "MetaProperty":return  false;case "ClassMethod":case "ClassPrivateMethod":case "ObjectMethod":return parent.key===node&&!!parent.computed;case "ObjectProperty":return parent.key===node?!!parent.computed:!grandparent||"ObjectPattern"!==grandparent.type;case "ClassProperty":case "ClassAccessorProperty":case "TSPropertySignature":return parent.key!==node||!!parent.computed;case "ClassPrivateProperty":case "ObjectTypeProperty":return parent.key!==node;case "ClassDeclaration":case "ClassExpression":return parent.superClass===node;case "AssignmentExpression":case "AssignmentPattern":return parent.right===node;case "ExportSpecifier":return (null==grandparent||!grandparent.source)&&parent.local===node;case "TSEnumMember":return parent.id!==node}return  true};},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isScope.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(node,parent){if((0, _index.isBlockStatement)(node)&&((0, _index.isFunction)(parent)||(0, _index.isCatchClause)(parent)))return  false;if((0, _index.isPattern)(node)&&((0, _index.isFunction)(parent)||(0, _index.isCatchClause)(parent)))return  true;return (0, _index.isScopable)(node)};var _index=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/generated/index.js");},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isSpecifierDefault.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(specifier){return (0, _index.isImportDefaultSpecifier)(specifier)||(0, _index.isIdentifier)(specifier.imported||specifier.exported,{name:"default"})};var _index=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/generated/index.js");},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isType.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(nodeType,targetType){if(nodeType===targetType)return  true;if(null==nodeType)return  false;if(_index.ALIAS_KEYS[targetType])return  false;const aliases=_index.FLIPPED_ALIAS_KEYS[targetType];if(aliases){if(aliases[0]===nodeType)return  true;for(const alias of aliases)if(nodeType===alias)return  true}return  false};var _index=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/index.js");},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isValidES3Identifier.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(name){return (0, _isValidIdentifier.default)(name)&&!RESERVED_WORDS_ES3_ONLY.has(name)};var _isValidIdentifier=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isValidIdentifier.js");const RESERVED_WORDS_ES3_ONLY=new Set(["abstract","boolean","byte","char","double","enum","final","float","goto","implements","int","interface","long","native","package","private","protected","public","short","static","synchronized","throws","transient","volatile"]);},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isValidIdentifier.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(name,reserved=true){if("string"!=typeof name)return  false;if(reserved&&((0, _helperValidatorIdentifier.isKeyword)(name)||(0, _helperValidatorIdentifier.isStrictReservedWord)(name,true)))return  false;return (0, _helperValidatorIdentifier.isIdentifierName)(name)};var _helperValidatorIdentifier=__webpack_require__("./node_modules/.pnpm/@babel+helper-validator-identifier@7.25.9/node_modules/@babel/helper-validator-identifier/lib/index.js");},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isVar.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(node){return (0, _index.isVariableDeclaration)(node,{kind:"var"})&&!node[_index2.BLOCK_SCOPED_SYMBOL]};var _index=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/generated/index.js"),_index2=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/constants/index.js");},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/matchesPattern.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(member,match,allowPartial){if(!(0, _index.isMemberExpression)(member))return  false;const parts=Array.isArray(match)?match:match.split("."),nodes=[];let node;for(node=member;(0, _index.isMemberExpression)(node);node=node.object)nodes.push(node.property);if(nodes.push(node),nodes.length<parts.length)return  false;if(!allowPartial&&nodes.length>parts.length)return  false;for(let i=0,j=nodes.length-1;i<parts.length;i++,j--){const node=nodes[j];let value;if((0, _index.isIdentifier)(node))value=node.name;else if((0, _index.isStringLiteral)(node))value=node.value;else {if(!(0, _index.isThisExpression)(node))return  false;value="this";}if(parts[i]!==value)return  false}return  true};var _index=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/generated/index.js");},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/react/isCompatTag.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(tagName){return !!tagName&&/^[a-z]/.test(tagName)};},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/react/isReactComponent.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=void 0;const isReactComponent=(0, __webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js").default)("React.Component");exports.default=isReactComponent;},"./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/validate.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:true}),exports.default=function(node,key,val){if(!node)return;const fields=_index.NODE_FIELDS[node.type];if(!fields)return;const field=fields[key];validateField(node,key,val,field),validateChild(node,key,val);},exports.validateChild=validateChild,exports.validateField=validateField,exports.validateInternal=function(field,node,key,val,maybeNode){if(null==field||!field.validate)return;if(field.optional&&null==val)return;if(field.validate(node,key,val),maybeNode){var _NODE_PARENT_VALIDATI;const type=val.type;if(null==type)return;null==(_NODE_PARENT_VALIDATI=_index.NODE_PARENT_VALIDATIONS[type])||_NODE_PARENT_VALIDATI.call(_index.NODE_PARENT_VALIDATIONS,node,key,val);}};var _index=__webpack_require__("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/index.js");function validateField(node,key,val,field){null!=field&&field.validate&&(field.optional&&null==val||field.validate(node,key,val));}function validateChild(node,key,val){var _NODE_PARENT_VALIDATI2;const type=null==val?void 0:val.type;null!=type&&(null==(_NODE_PARENT_VALIDATI2=_index.NODE_PARENT_VALIDATIONS[type])||_NODE_PARENT_VALIDATI2.call(_index.NODE_PARENT_VALIDATIONS,node,key,val));}},"./node_modules/.pnpm/json5@2.2.3/node_modules/json5/dist/index.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{default:()=>__WEBPACK_DEFAULT_EXPORT__});var unicode={Space_Separator:/[\u1680\u2000-\u200A\u202F\u205F\u3000]/,ID_Start:/[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/,ID_Continue:/[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/},util={isSpaceSeparator:c=>"string"==typeof c&&unicode.Space_Separator.test(c),isIdStartChar:c=>"string"==typeof c&&(c>="a"&&c<="z"||c>="A"&&c<="Z"||"$"===c||"_"===c||unicode.ID_Start.test(c)),isIdContinueChar:c=>"string"==typeof c&&(c>="a"&&c<="z"||c>="A"&&c<="Z"||c>="0"&&c<="9"||"$"===c||"_"===c||""===c||""===c||unicode.ID_Continue.test(c)),isDigit:c=>"string"==typeof c&&/[0-9]/.test(c),isHexDigit:c=>"string"==typeof c&&/[0-9A-Fa-f]/.test(c)};let source,parseState,stack,pos,line,column,token,key,root;function internalize(holder,name,reviver){const value=holder[name];if(null!=value&&"object"==typeof value)if(Array.isArray(value))for(let i=0;i<value.length;i++){const key=String(i),replacement=internalize(value,key,reviver);void 0===replacement?delete value[key]:Object.defineProperty(value,key,{value:replacement,writable:true,enumerable:true,configurable:true});}else for(const key in value){const replacement=internalize(value,key,reviver);void 0===replacement?delete value[key]:Object.defineProperty(value,key,{value:replacement,writable:true,enumerable:true,configurable:true});}return reviver.call(holder,name,value)}let lexState,buffer,doubleQuote,sign,c;function lex(){for(lexState="default",buffer="",doubleQuote=false,sign=1;;){c=peek();const token=lexStates[lexState]();if(token)return token}}function peek(){if(source[pos])return String.fromCodePoint(source.codePointAt(pos))}function read(){const c=peek();return "\n"===c?(line++,column=0):c?column+=c.length:column++,c&&(pos+=c.length),c}const lexStates={default(){switch(c){case "\t":case "\v":case "\f":case " ":case "":case "\ufeff":case "\n":case "\r":case "\u2028":case "\u2029":return void read();case "/":return read(),void(lexState="comment");case void 0:return read(),newToken("eof")}if(!util.isSpaceSeparator(c))return lexStates[parseState]();read();},comment(){switch(c){case "*":return read(),void(lexState="multiLineComment");case "/":return read(),void(lexState="singleLineComment")}throw invalidChar(read())},multiLineComment(){switch(c){case "*":return read(),void(lexState="multiLineCommentAsterisk");case void 0:throw invalidChar(read())}read();},multiLineCommentAsterisk(){switch(c){case "*":return void read();case "/":return read(),void(lexState="default");case void 0:throw invalidChar(read())}read(),lexState="multiLineComment";},singleLineComment(){switch(c){case "\n":case "\r":case "\u2028":case "\u2029":return read(),void(lexState="default");case void 0:return read(),newToken("eof")}read();},value(){switch(c){case "{":case "[":return newToken("punctuator",read());case "n":return read(),literal("ull"),newToken("null",null);case "t":return read(),literal("rue"),newToken("boolean",true);case "f":return read(),literal("alse"),newToken("boolean",false);case "-":case "+":return "-"===read()&&(sign=-1),void(lexState="sign");case ".":return buffer=read(),void(lexState="decimalPointLeading");case "0":return buffer=read(),void(lexState="zero");case "1":case "2":case "3":case "4":case "5":case "6":case "7":case "8":case "9":return buffer=read(),void(lexState="decimalInteger");case "I":return read(),literal("nfinity"),newToken("numeric",1/0);case "N":return read(),literal("aN"),newToken("numeric",NaN);case '"':case "'":return doubleQuote='"'===read(),buffer="",void(lexState="string")}throw invalidChar(read())},identifierNameStartEscape(){if("u"!==c)throw invalidChar(read());read();const u=unicodeEscape();switch(u){case "$":case "_":break;default:if(!util.isIdStartChar(u))throw invalidIdentifier()}buffer+=u,lexState="identifierName";},identifierName(){switch(c){case "$":case "_":case "":case "":return void(buffer+=read());case "\\":return read(),void(lexState="identifierNameEscape")}if(!util.isIdContinueChar(c))return newToken("identifier",buffer);buffer+=read();},identifierNameEscape(){if("u"!==c)throw invalidChar(read());read();const u=unicodeEscape();switch(u){case "$":case "_":case "":case "":break;default:if(!util.isIdContinueChar(u))throw invalidIdentifier()}buffer+=u,lexState="identifierName";},sign(){switch(c){case ".":return buffer=read(),void(lexState="decimalPointLeading");case "0":return buffer=read(),void(lexState="zero");case "1":case "2":case "3":case "4":case "5":case "6":case "7":case "8":case "9":return buffer=read(),void(lexState="decimalInteger");case "I":return read(),literal("nfinity"),newToken("numeric",sign*(1/0));case "N":return read(),literal("aN"),newToken("numeric",NaN)}throw invalidChar(read())},zero(){switch(c){case ".":return buffer+=read(),void(lexState="decimalPoint");case "e":case "E":return buffer+=read(),void(lexState="decimalExponent");case "x":case "X":return buffer+=read(),void(lexState="hexadecimal")}return newToken("numeric",0*sign)},decimalInteger(){switch(c){case ".":return buffer+=read(),void(lexState="decimalPoint");case "e":case "E":return buffer+=read(),void(lexState="decimalExponent")}if(!util.isDigit(c))return newToken("numeric",sign*Number(buffer));buffer+=read();},decimalPointLeading(){if(util.isDigit(c))return buffer+=read(),void(lexState="decimalFraction");throw invalidChar(read())},decimalPoint(){switch(c){case "e":case "E":return buffer+=read(),void(lexState="decimalExponent")}return util.isDigit(c)?(buffer+=read(),void(lexState="decimalFraction")):newToken("numeric",sign*Number(buffer))},decimalFraction(){switch(c){case "e":case "E":return buffer+=read(),void(lexState="decimalExponent")}if(!util.isDigit(c))return newToken("numeric",sign*Number(buffer));buffer+=read();},decimalExponent(){switch(c){case "+":case "-":return buffer+=read(),void(lexState="decimalExponentSign")}if(util.isDigit(c))return buffer+=read(),void(lexState="decimalExponentInteger");throw invalidChar(read())},decimalExponentSign(){if(util.isDigit(c))return buffer+=read(),void(lexState="decimalExponentInteger");throw invalidChar(read())},decimalExponentInteger(){if(!util.isDigit(c))return newToken("numeric",sign*Number(buffer));buffer+=read();},hexadecimal(){if(util.isHexDigit(c))return buffer+=read(),void(lexState="hexadecimalInteger");throw invalidChar(read())},hexadecimalInteger(){if(!util.isHexDigit(c))return newToken("numeric",sign*Number(buffer));buffer+=read();},string(){switch(c){case "\\":return read(),void(buffer+=function(){switch(peek()){case "b":return read(),"\b";case "f":return read(),"\f";case "n":return read(),"\n";case "r":return read(),"\r";case "t":return read(),"\t";case "v":return read(),"\v";case "0":if(read(),util.isDigit(peek()))throw invalidChar(read());return "\0";case "x":return read(),function(){let buffer="",c=peek();if(!util.isHexDigit(c))throw invalidChar(read());if(buffer+=read(),c=peek(),!util.isHexDigit(c))throw invalidChar(read());return buffer+=read(),String.fromCodePoint(parseInt(buffer,16))}();case "u":return read(),unicodeEscape();case "\n":case "\u2028":case "\u2029":return read(),"";case "\r":return read(),"\n"===peek()&&read(),"";case "1":case "2":case "3":case "4":case "5":case "6":case "7":case "8":case "9":case void 0:throw invalidChar(read())}return read()}());case '"':return doubleQuote?(read(),newToken("string",buffer)):void(buffer+=read());case "'":return doubleQuote?void(buffer+=read()):(read(),newToken("string",buffer));case "\n":case "\r":throw invalidChar(read());case "\u2028":case "\u2029":!function(c){console.warn(`JSON5: '${formatChar(c)}' in strings is not valid ECMAScript; consider escaping`);}(c);break;case void 0:throw invalidChar(read())}buffer+=read();},start(){switch(c){case "{":case "[":return newToken("punctuator",read())}lexState="value";},beforePropertyName(){switch(c){case "$":case "_":return buffer=read(),void(lexState="identifierName");case "\\":return read(),void(lexState="identifierNameStartEscape");case "}":return newToken("punctuator",read());case '"':case "'":return doubleQuote='"'===read(),void(lexState="string")}if(util.isIdStartChar(c))return buffer+=read(),void(lexState="identifierName");throw invalidChar(read())},afterPropertyName(){if(":"===c)return newToken("punctuator",read());throw invalidChar(read())},beforePropertyValue(){lexState="value";},afterPropertyValue(){switch(c){case ",":case "}":return newToken("punctuator",read())}throw invalidChar(read())},beforeArrayValue(){if("]"===c)return newToken("punctuator",read());lexState="value";},afterArrayValue(){switch(c){case ",":case "]":return newToken("punctuator",read())}throw invalidChar(read())},end(){throw invalidChar(read())}};function newToken(type,value){return {type,value,line,column}}function literal(s){for(const c of s){if(peek()!==c)throw invalidChar(read());read();}}function unicodeEscape(){let buffer="",count=4;for(;count-- >0;){const c=peek();if(!util.isHexDigit(c))throw invalidChar(read());buffer+=read();}return String.fromCodePoint(parseInt(buffer,16))}const parseStates={start(){if("eof"===token.type)throw invalidEOF();push();},beforePropertyName(){switch(token.type){case "identifier":case "string":return key=token.value,void(parseState="afterPropertyName");case "punctuator":return void pop();case "eof":throw invalidEOF()}},afterPropertyName(){if("eof"===token.type)throw invalidEOF();parseState="beforePropertyValue";},beforePropertyValue(){if("eof"===token.type)throw invalidEOF();push();},beforeArrayValue(){if("eof"===token.type)throw invalidEOF();"punctuator"!==token.type||"]"!==token.value?push():pop();},afterPropertyValue(){if("eof"===token.type)throw invalidEOF();switch(token.value){case ",":return void(parseState="beforePropertyName");case "}":pop();}},afterArrayValue(){if("eof"===token.type)throw invalidEOF();switch(token.value){case ",":return void(parseState="beforeArrayValue");case "]":pop();}},end(){}};function push(){let value;switch(token.type){case "punctuator":switch(token.value){case "{":value={};break;case "[":value=[];}break;case "null":case "boolean":case "numeric":case "string":value=token.value;}if(void 0===root)root=value;else {const parent=stack[stack.length-1];Array.isArray(parent)?parent.push(value):Object.defineProperty(parent,key,{value,writable:true,enumerable:true,configurable:true});}if(null!==value&&"object"==typeof value)stack.push(value),parseState=Array.isArray(value)?"beforeArrayValue":"beforePropertyName";else {const current=stack[stack.length-1];parseState=null==current?"end":Array.isArray(current)?"afterArrayValue":"afterPropertyValue";}}function pop(){stack.pop();const current=stack[stack.length-1];parseState=null==current?"end":Array.isArray(current)?"afterArrayValue":"afterPropertyValue";}function invalidChar(c){return syntaxError(void 0===c?`JSON5: invalid end of input at ${line}:${column}`:`JSON5: invalid character '${formatChar(c)}' at ${line}:${column}`)}function invalidEOF(){return syntaxError(`JSON5: invalid end of input at ${line}:${column}`)}function invalidIdentifier(){return column-=5,syntaxError(`JSON5: invalid identifier character at ${line}:${column}`)}function formatChar(c){const replacements={"'":"\\'",'"':'\\"',"\\":"\\\\","\b":"\\b","\f":"\\f","\n":"\\n","\r":"\\r","\t":"\\t","\v":"\\v","\0":"\\0","\u2028":"\\u2028","\u2029":"\\u2029"};if(replacements[c])return replacements[c];if(c<" "){const hexString=c.charCodeAt(0).toString(16);return "\\x"+("00"+hexString).substring(hexString.length)}return c}function syntaxError(message){const err=new SyntaxError(message);return err.lineNumber=line,err.columnNumber=column,err}const JSON5={parse:function(text,reviver){source=String(text),parseState="start",stack=[],pos=0,line=1,column=0,token=void 0,key=void 0,root=void 0;do{token=lex(),parseStates[parseState]();}while("eof"!==token.type);return "function"==typeof reviver?internalize({"":root},"",reviver):root},stringify:function(value,replacer,space){const stack=[];let propertyList,replacerFunc,quote,indent="",gap="";if(null==replacer||"object"!=typeof replacer||Array.isArray(replacer)||(space=replacer.space,quote=replacer.quote,replacer=replacer.replacer),"function"==typeof replacer)replacerFunc=replacer;else if(Array.isArray(replacer)){propertyList=[];for(const v of replacer){let item;"string"==typeof v?item=v:("number"==typeof v||v instanceof String||v instanceof Number)&&(item=String(v)),void 0!==item&&propertyList.indexOf(item)<0&&propertyList.push(item);}}return space instanceof Number?space=Number(space):space instanceof String&&(space=String(space)),"number"==typeof space?space>0&&(space=Math.min(10,Math.floor(space)),gap="          ".substr(0,space)):"string"==typeof space&&(gap=space.substr(0,10)),serializeProperty("",{"":value});function serializeProperty(key,holder){let value=holder[key];switch(null!=value&&("function"==typeof value.toJSON5?value=value.toJSON5(key):"function"==typeof value.toJSON&&(value=value.toJSON(key))),replacerFunc&&(value=replacerFunc.call(holder,key,value)),value instanceof Number?value=Number(value):value instanceof String?value=String(value):value instanceof Boolean&&(value=value.valueOf()),value){case null:return "null";case  true:return "true";case  false:return "false"}return "string"==typeof value?quoteString(value):"number"==typeof value?String(value):"object"==typeof value?Array.isArray(value)?function(value){if(stack.indexOf(value)>=0)throw TypeError("Converting circular structure to JSON5");stack.push(value);let stepback=indent;indent+=gap;let final,partial=[];for(let i=0;i<value.length;i++){const propertyString=serializeProperty(String(i),value);partial.push(void 0!==propertyString?propertyString:"null");}if(0===partial.length)final="[]";else if(""===gap){final="["+partial.join(",")+"]";}else {let separator=",\n"+indent,properties=partial.join(separator);final="[\n"+indent+properties+",\n"+stepback+"]";}return stack.pop(),indent=stepback,final}(value):function(value){if(stack.indexOf(value)>=0)throw TypeError("Converting circular structure to JSON5");stack.push(value);let stepback=indent;indent+=gap;let final,keys=propertyList||Object.keys(value),partial=[];for(const key of keys){const propertyString=serializeProperty(key,value);if(void 0!==propertyString){let member=serializeKey(key)+":";""!==gap&&(member+=" "),member+=propertyString,partial.push(member);}}if(0===partial.length)final="{}";else {let properties;if(""===gap)properties=partial.join(","),final="{"+properties+"}";else {let separator=",\n"+indent;properties=partial.join(separator),final="{\n"+indent+properties+",\n"+stepback+"}";}}return stack.pop(),indent=stepback,final}(value):void 0}function quoteString(value){const quotes={"'":.1,'"':.2},replacements={"'":"\\'",'"':'\\"',"\\":"\\\\","\b":"\\b","\f":"\\f","\n":"\\n","\r":"\\r","\t":"\\t","\v":"\\v","\0":"\\0","\u2028":"\\u2028","\u2029":"\\u2029"};let product="";for(let i=0;i<value.length;i++){const c=value[i];switch(c){case "'":case '"':quotes[c]++,product+=c;continue;case "\0":if(util.isDigit(value[i+1])){product+="\\x00";continue}}if(replacements[c])product+=replacements[c];else if(c<" "){let hexString=c.charCodeAt(0).toString(16);product+="\\x"+("00"+hexString).substring(hexString.length);}else product+=c;}const quoteChar=quote||Object.keys(quotes).reduce(((a,b)=>quotes[a]<quotes[b]?a:b));return product=product.replace(new RegExp(quoteChar,"g"),replacements[quoteChar]),quoteChar+product+quoteChar}function serializeKey(key){if(0===key.length)return quoteString(key);const firstChar=String.fromCodePoint(key.codePointAt(0));if(!util.isIdStartChar(firstChar))return quoteString(key);for(let i=firstChar.length;i<key.length;i++)if(!util.isIdContinueChar(String.fromCodePoint(key.codePointAt(i))))return quoteString(key);return key}}};const __WEBPACK_DEFAULT_EXPORT__=JSON5;},"./stubs/babel-codeframe.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{function codeFrameColumns(){return ""}__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{codeFrameColumns:()=>codeFrameColumns});},"./stubs/helper-compilation-targets.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{function getTargets(){return {}}__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{default:()=>getTargets});},"./node_modules/.pnpm/@babel+preset-typescript@7.26.0_@babel+core@7.26.0/node_modules/@babel/preset-typescript/package.json":module=>{module.exports=JSON.parse('{"name":"@babel/preset-typescript","version":"7.26.0","description":"Babel preset for TypeScript.","repository":{"type":"git","url":"https://github.com/babel/babel.git","directory":"packages/babel-preset-typescript"},"license":"MIT","publishConfig":{"access":"public"},"main":"./lib/index.js","keywords":["babel-preset","typescript"],"dependencies":{"@babel/helper-plugin-utils":"^7.25.9","@babel/helper-validator-option":"^7.25.9","@babel/plugin-syntax-jsx":"^7.25.9","@babel/plugin-transform-modules-commonjs":"^7.25.9","@babel/plugin-transform-typescript":"^7.25.9"},"peerDependencies":{"@babel/core":"^7.0.0-0"},"devDependencies":{"@babel/core":"^7.26.0","@babel/helper-plugin-test-runner":"^7.25.9"},"homepage":"https://babel.dev/docs/en/next/babel-preset-typescript","bugs":"https://github.com/babel/babel/issues?utf8=%E2%9C%93&q=is%3Aissue+label%3A%22area%3A%20typescript%22+is%3Aopen","engines":{"node":">=6.9.0"},"author":"The Babel Team (https://babel.dev/team)","type":"commonjs"}');},"./node_modules/.pnpm/globals@11.12.0/node_modules/globals/globals.json":module=>{module.exports=JSON.parse('{"builtin":{"Array":false,"ArrayBuffer":false,"Atomics":false,"BigInt":false,"BigInt64Array":false,"BigUint64Array":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"globalThis":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"SharedArrayBuffer":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"es5":{"Array":false,"Boolean":false,"constructor":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"propertyIsEnumerable":false,"RangeError":false,"ReferenceError":false,"RegExp":false,"String":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false},"es2015":{"Array":false,"ArrayBuffer":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"es2017":{"Array":false,"ArrayBuffer":false,"Atomics":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"SharedArrayBuffer":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"browser":{"AbortController":false,"AbortSignal":false,"addEventListener":false,"alert":false,"AnalyserNode":false,"Animation":false,"AnimationEffectReadOnly":false,"AnimationEffectTiming":false,"AnimationEffectTimingReadOnly":false,"AnimationEvent":false,"AnimationPlaybackEvent":false,"AnimationTimeline":false,"applicationCache":false,"ApplicationCache":false,"ApplicationCacheErrorEvent":false,"atob":false,"Attr":false,"Audio":false,"AudioBuffer":false,"AudioBufferSourceNode":false,"AudioContext":false,"AudioDestinationNode":false,"AudioListener":false,"AudioNode":false,"AudioParam":false,"AudioProcessingEvent":false,"AudioScheduledSourceNode":false,"AudioWorkletGlobalScope ":false,"AudioWorkletNode":false,"AudioWorkletProcessor":false,"BarProp":false,"BaseAudioContext":false,"BatteryManager":false,"BeforeUnloadEvent":false,"BiquadFilterNode":false,"Blob":false,"BlobEvent":false,"blur":false,"BroadcastChannel":false,"btoa":false,"BudgetService":false,"ByteLengthQueuingStrategy":false,"Cache":false,"caches":false,"CacheStorage":false,"cancelAnimationFrame":false,"cancelIdleCallback":false,"CanvasCaptureMediaStreamTrack":false,"CanvasGradient":false,"CanvasPattern":false,"CanvasRenderingContext2D":false,"ChannelMergerNode":false,"ChannelSplitterNode":false,"CharacterData":false,"clearInterval":false,"clearTimeout":false,"clientInformation":false,"ClipboardEvent":false,"close":false,"closed":false,"CloseEvent":false,"Comment":false,"CompositionEvent":false,"confirm":false,"console":false,"ConstantSourceNode":false,"ConvolverNode":false,"CountQueuingStrategy":false,"createImageBitmap":false,"Credential":false,"CredentialsContainer":false,"crypto":false,"Crypto":false,"CryptoKey":false,"CSS":false,"CSSConditionRule":false,"CSSFontFaceRule":false,"CSSGroupingRule":false,"CSSImportRule":false,"CSSKeyframeRule":false,"CSSKeyframesRule":false,"CSSMediaRule":false,"CSSNamespaceRule":false,"CSSPageRule":false,"CSSRule":false,"CSSRuleList":false,"CSSStyleDeclaration":false,"CSSStyleRule":false,"CSSStyleSheet":false,"CSSSupportsRule":false,"CustomElementRegistry":false,"customElements":false,"CustomEvent":false,"DataTransfer":false,"DataTransferItem":false,"DataTransferItemList":false,"defaultstatus":false,"defaultStatus":false,"DelayNode":false,"DeviceMotionEvent":false,"DeviceOrientationEvent":false,"devicePixelRatio":false,"dispatchEvent":false,"document":false,"Document":false,"DocumentFragment":false,"DocumentType":false,"DOMError":false,"DOMException":false,"DOMImplementation":false,"DOMMatrix":false,"DOMMatrixReadOnly":false,"DOMParser":false,"DOMPoint":false,"DOMPointReadOnly":false,"DOMQuad":false,"DOMRect":false,"DOMRectReadOnly":false,"DOMStringList":false,"DOMStringMap":false,"DOMTokenList":false,"DragEvent":false,"DynamicsCompressorNode":false,"Element":false,"ErrorEvent":false,"event":false,"Event":false,"EventSource":false,"EventTarget":false,"external":false,"fetch":false,"File":false,"FileList":false,"FileReader":false,"find":false,"focus":false,"FocusEvent":false,"FontFace":false,"FontFaceSetLoadEvent":false,"FormData":false,"frameElement":false,"frames":false,"GainNode":false,"Gamepad":false,"GamepadButton":false,"GamepadEvent":false,"getComputedStyle":false,"getSelection":false,"HashChangeEvent":false,"Headers":false,"history":false,"History":false,"HTMLAllCollection":false,"HTMLAnchorElement":false,"HTMLAreaElement":false,"HTMLAudioElement":false,"HTMLBaseElement":false,"HTMLBodyElement":false,"HTMLBRElement":false,"HTMLButtonElement":false,"HTMLCanvasElement":false,"HTMLCollection":false,"HTMLContentElement":false,"HTMLDataElement":false,"HTMLDataListElement":false,"HTMLDetailsElement":false,"HTMLDialogElement":false,"HTMLDirectoryElement":false,"HTMLDivElement":false,"HTMLDListElement":false,"HTMLDocument":false,"HTMLElement":false,"HTMLEmbedElement":false,"HTMLFieldSetElement":false,"HTMLFontElement":false,"HTMLFormControlsCollection":false,"HTMLFormElement":false,"HTMLFrameElement":false,"HTMLFrameSetElement":false,"HTMLHeadElement":false,"HTMLHeadingElement":false,"HTMLHRElement":false,"HTMLHtmlElement":false,"HTMLIFrameElement":false,"HTMLImageElement":false,"HTMLInputElement":false,"HTMLLabelElement":false,"HTMLLegendElement":false,"HTMLLIElement":false,"HTMLLinkElement":false,"HTMLMapElement":false,"HTMLMarqueeElement":false,"HTMLMediaElement":false,"HTMLMenuElement":false,"HTMLMetaElement":false,"HTMLMeterElement":false,"HTMLModElement":false,"HTMLObjectElement":false,"HTMLOListElement":false,"HTMLOptGroupElement":false,"HTMLOptionElement":false,"HTMLOptionsCollection":false,"HTMLOutputElement":false,"HTMLParagraphElement":false,"HTMLParamElement":false,"HTMLPictureElement":false,"HTMLPreElement":false,"HTMLProgressElement":false,"HTMLQuoteElement":false,"HTMLScriptElement":false,"HTMLSelectElement":false,"HTMLShadowElement":false,"HTMLSlotElement":false,"HTMLSourceElement":false,"HTMLSpanElement":false,"HTMLStyleElement":false,"HTMLTableCaptionElement":false,"HTMLTableCellElement":false,"HTMLTableColElement":false,"HTMLTableElement":false,"HTMLTableRowElement":false,"HTMLTableSectionElement":false,"HTMLTemplateElement":false,"HTMLTextAreaElement":false,"HTMLTimeElement":false,"HTMLTitleElement":false,"HTMLTrackElement":false,"HTMLUListElement":false,"HTMLUnknownElement":false,"HTMLVideoElement":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"IdleDeadline":false,"IIRFilterNode":false,"Image":false,"ImageBitmap":false,"ImageBitmapRenderingContext":false,"ImageCapture":false,"ImageData":false,"indexedDB":false,"innerHeight":false,"innerWidth":false,"InputEvent":false,"IntersectionObserver":false,"IntersectionObserverEntry":false,"Intl":false,"isSecureContext":false,"KeyboardEvent":false,"KeyframeEffect":false,"KeyframeEffectReadOnly":false,"length":false,"localStorage":false,"location":true,"Location":false,"locationbar":false,"matchMedia":false,"MediaDeviceInfo":false,"MediaDevices":false,"MediaElementAudioSourceNode":false,"MediaEncryptedEvent":false,"MediaError":false,"MediaKeyMessageEvent":false,"MediaKeySession":false,"MediaKeyStatusMap":false,"MediaKeySystemAccess":false,"MediaList":false,"MediaQueryList":false,"MediaQueryListEvent":false,"MediaRecorder":false,"MediaSettingsRange":false,"MediaSource":false,"MediaStream":false,"MediaStreamAudioDestinationNode":false,"MediaStreamAudioSourceNode":false,"MediaStreamEvent":false,"MediaStreamTrack":false,"MediaStreamTrackEvent":false,"menubar":false,"MessageChannel":false,"MessageEvent":false,"MessagePort":false,"MIDIAccess":false,"MIDIConnectionEvent":false,"MIDIInput":false,"MIDIInputMap":false,"MIDIMessageEvent":false,"MIDIOutput":false,"MIDIOutputMap":false,"MIDIPort":false,"MimeType":false,"MimeTypeArray":false,"MouseEvent":false,"moveBy":false,"moveTo":false,"MutationEvent":false,"MutationObserver":false,"MutationRecord":false,"name":false,"NamedNodeMap":false,"NavigationPreloadManager":false,"navigator":false,"Navigator":false,"NetworkInformation":false,"Node":false,"NodeFilter":false,"NodeIterator":false,"NodeList":false,"Notification":false,"OfflineAudioCompletionEvent":false,"OfflineAudioContext":false,"offscreenBuffering":false,"OffscreenCanvas":true,"onabort":true,"onafterprint":true,"onanimationend":true,"onanimationiteration":true,"onanimationstart":true,"onappinstalled":true,"onauxclick":true,"onbeforeinstallprompt":true,"onbeforeprint":true,"onbeforeunload":true,"onblur":true,"oncancel":true,"oncanplay":true,"oncanplaythrough":true,"onchange":true,"onclick":true,"onclose":true,"oncontextmenu":true,"oncuechange":true,"ondblclick":true,"ondevicemotion":true,"ondeviceorientation":true,"ondeviceorientationabsolute":true,"ondrag":true,"ondragend":true,"ondragenter":true,"ondragleave":true,"ondragover":true,"ondragstart":true,"ondrop":true,"ondurationchange":true,"onemptied":true,"onended":true,"onerror":true,"onfocus":true,"ongotpointercapture":true,"onhashchange":true,"oninput":true,"oninvalid":true,"onkeydown":true,"onkeypress":true,"onkeyup":true,"onlanguagechange":true,"onload":true,"onloadeddata":true,"onloadedmetadata":true,"onloadstart":true,"onlostpointercapture":true,"onmessage":true,"onmessageerror":true,"onmousedown":true,"onmouseenter":true,"onmouseleave":true,"onmousemove":true,"onmouseout":true,"onmouseover":true,"onmouseup":true,"onmousewheel":true,"onoffline":true,"ononline":true,"onpagehide":true,"onpageshow":true,"onpause":true,"onplay":true,"onplaying":true,"onpointercancel":true,"onpointerdown":true,"onpointerenter":true,"onpointerleave":true,"onpointermove":true,"onpointerout":true,"onpointerover":true,"onpointerup":true,"onpopstate":true,"onprogress":true,"onratechange":true,"onrejectionhandled":true,"onreset":true,"onresize":true,"onscroll":true,"onsearch":true,"onseeked":true,"onseeking":true,"onselect":true,"onstalled":true,"onstorage":true,"onsubmit":true,"onsuspend":true,"ontimeupdate":true,"ontoggle":true,"ontransitionend":true,"onunhandledrejection":true,"onunload":true,"onvolumechange":true,"onwaiting":true,"onwheel":true,"open":false,"openDatabase":false,"opener":false,"Option":false,"origin":false,"OscillatorNode":false,"outerHeight":false,"outerWidth":false,"PageTransitionEvent":false,"pageXOffset":false,"pageYOffset":false,"PannerNode":false,"parent":false,"Path2D":false,"PaymentAddress":false,"PaymentRequest":false,"PaymentRequestUpdateEvent":false,"PaymentResponse":false,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceLongTaskTiming":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceNavigationTiming":false,"PerformanceObserver":false,"PerformanceObserverEntryList":false,"PerformancePaintTiming":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"PeriodicWave":false,"Permissions":false,"PermissionStatus":false,"personalbar":false,"PhotoCapabilities":false,"Plugin":false,"PluginArray":false,"PointerEvent":false,"PopStateEvent":false,"postMessage":false,"Presentation":false,"PresentationAvailability":false,"PresentationConnection":false,"PresentationConnectionAvailableEvent":false,"PresentationConnectionCloseEvent":false,"PresentationConnectionList":false,"PresentationReceiver":false,"PresentationRequest":false,"print":false,"ProcessingInstruction":false,"ProgressEvent":false,"PromiseRejectionEvent":false,"prompt":false,"PushManager":false,"PushSubscription":false,"PushSubscriptionOptions":false,"queueMicrotask":false,"RadioNodeList":false,"Range":false,"ReadableStream":false,"registerProcessor":false,"RemotePlayback":false,"removeEventListener":false,"Request":false,"requestAnimationFrame":false,"requestIdleCallback":false,"resizeBy":false,"ResizeObserver":false,"ResizeObserverEntry":false,"resizeTo":false,"Response":false,"RTCCertificate":false,"RTCDataChannel":false,"RTCDataChannelEvent":false,"RTCDtlsTransport":false,"RTCIceCandidate":false,"RTCIceGatherer":false,"RTCIceTransport":false,"RTCPeerConnection":false,"RTCPeerConnectionIceEvent":false,"RTCRtpContributingSource":false,"RTCRtpReceiver":false,"RTCRtpSender":false,"RTCSctpTransport":false,"RTCSessionDescription":false,"RTCStatsReport":false,"RTCTrackEvent":false,"screen":false,"Screen":false,"screenLeft":false,"ScreenOrientation":false,"screenTop":false,"screenX":false,"screenY":false,"ScriptProcessorNode":false,"scroll":false,"scrollbars":false,"scrollBy":false,"scrollTo":false,"scrollX":false,"scrollY":false,"SecurityPolicyViolationEvent":false,"Selection":false,"self":false,"ServiceWorker":false,"ServiceWorkerContainer":false,"ServiceWorkerRegistration":false,"sessionStorage":false,"setInterval":false,"setTimeout":false,"ShadowRoot":false,"SharedWorker":false,"SourceBuffer":false,"SourceBufferList":false,"speechSynthesis":false,"SpeechSynthesisEvent":false,"SpeechSynthesisUtterance":false,"StaticRange":false,"status":false,"statusbar":false,"StereoPannerNode":false,"stop":false,"Storage":false,"StorageEvent":false,"StorageManager":false,"styleMedia":false,"StyleSheet":false,"StyleSheetList":false,"SubtleCrypto":false,"SVGAElement":false,"SVGAngle":false,"SVGAnimatedAngle":false,"SVGAnimatedBoolean":false,"SVGAnimatedEnumeration":false,"SVGAnimatedInteger":false,"SVGAnimatedLength":false,"SVGAnimatedLengthList":false,"SVGAnimatedNumber":false,"SVGAnimatedNumberList":false,"SVGAnimatedPreserveAspectRatio":false,"SVGAnimatedRect":false,"SVGAnimatedString":false,"SVGAnimatedTransformList":false,"SVGAnimateElement":false,"SVGAnimateMotionElement":false,"SVGAnimateTransformElement":false,"SVGAnimationElement":false,"SVGCircleElement":false,"SVGClipPathElement":false,"SVGComponentTransferFunctionElement":false,"SVGDefsElement":false,"SVGDescElement":false,"SVGDiscardElement":false,"SVGElement":false,"SVGEllipseElement":false,"SVGFEBlendElement":false,"SVGFEColorMatrixElement":false,"SVGFEComponentTransferElement":false,"SVGFECompositeElement":false,"SVGFEConvolveMatrixElement":false,"SVGFEDiffuseLightingElement":false,"SVGFEDisplacementMapElement":false,"SVGFEDistantLightElement":false,"SVGFEDropShadowElement":false,"SVGFEFloodElement":false,"SVGFEFuncAElement":false,"SVGFEFuncBElement":false,"SVGFEFuncGElement":false,"SVGFEFuncRElement":false,"SVGFEGaussianBlurElement":false,"SVGFEImageElement":false,"SVGFEMergeElement":false,"SVGFEMergeNodeElement":false,"SVGFEMorphologyElement":false,"SVGFEOffsetElement":false,"SVGFEPointLightElement":false,"SVGFESpecularLightingElement":false,"SVGFESpotLightElement":false,"SVGFETileElement":false,"SVGFETurbulenceElement":false,"SVGFilterElement":false,"SVGForeignObjectElement":false,"SVGGElement":false,"SVGGeometryElement":false,"SVGGradientElement":false,"SVGGraphicsElement":false,"SVGImageElement":false,"SVGLength":false,"SVGLengthList":false,"SVGLinearGradientElement":false,"SVGLineElement":false,"SVGMarkerElement":false,"SVGMaskElement":false,"SVGMatrix":false,"SVGMetadataElement":false,"SVGMPathElement":false,"SVGNumber":false,"SVGNumberList":false,"SVGPathElement":false,"SVGPatternElement":false,"SVGPoint":false,"SVGPointList":false,"SVGPolygonElement":false,"SVGPolylineElement":false,"SVGPreserveAspectRatio":false,"SVGRadialGradientElement":false,"SVGRect":false,"SVGRectElement":false,"SVGScriptElement":false,"SVGSetElement":false,"SVGStopElement":false,"SVGStringList":false,"SVGStyleElement":false,"SVGSVGElement":false,"SVGSwitchElement":false,"SVGSymbolElement":false,"SVGTextContentElement":false,"SVGTextElement":false,"SVGTextPathElement":false,"SVGTextPositioningElement":false,"SVGTitleElement":false,"SVGTransform":false,"SVGTransformList":false,"SVGTSpanElement":false,"SVGUnitTypes":false,"SVGUseElement":false,"SVGViewElement":false,"TaskAttributionTiming":false,"Text":false,"TextDecoder":false,"TextEncoder":false,"TextEvent":false,"TextMetrics":false,"TextTrack":false,"TextTrackCue":false,"TextTrackCueList":false,"TextTrackList":false,"TimeRanges":false,"toolbar":false,"top":false,"Touch":false,"TouchEvent":false,"TouchList":false,"TrackEvent":false,"TransitionEvent":false,"TreeWalker":false,"UIEvent":false,"URL":false,"URLSearchParams":false,"ValidityState":false,"visualViewport":false,"VisualViewport":false,"VTTCue":false,"WaveShaperNode":false,"WebAssembly":false,"WebGL2RenderingContext":false,"WebGLActiveInfo":false,"WebGLBuffer":false,"WebGLContextEvent":false,"WebGLFramebuffer":false,"WebGLProgram":false,"WebGLQuery":false,"WebGLRenderbuffer":false,"WebGLRenderingContext":false,"WebGLSampler":false,"WebGLShader":false,"WebGLShaderPrecisionFormat":false,"WebGLSync":false,"WebGLTexture":false,"WebGLTransformFeedback":false,"WebGLUniformLocation":false,"WebGLVertexArrayObject":false,"WebSocket":false,"WheelEvent":false,"window":false,"Window":false,"Worker":false,"WritableStream":false,"XMLDocument":false,"XMLHttpRequest":false,"XMLHttpRequestEventTarget":false,"XMLHttpRequestUpload":false,"XMLSerializer":false,"XPathEvaluator":false,"XPathExpression":false,"XPathResult":false,"XSLTProcessor":false},"worker":{"addEventListener":false,"applicationCache":false,"atob":false,"Blob":false,"BroadcastChannel":false,"btoa":false,"Cache":false,"caches":false,"clearInterval":false,"clearTimeout":false,"close":true,"console":false,"fetch":false,"FileReaderSync":false,"FormData":false,"Headers":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"ImageData":false,"importScripts":true,"indexedDB":false,"location":false,"MessageChannel":false,"MessagePort":false,"name":false,"navigator":false,"Notification":false,"onclose":true,"onconnect":true,"onerror":true,"onlanguagechange":true,"onmessage":true,"onoffline":true,"ononline":true,"onrejectionhandled":true,"onunhandledrejection":true,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"postMessage":true,"Promise":false,"queueMicrotask":false,"removeEventListener":false,"Request":false,"Response":false,"self":true,"ServiceWorkerRegistration":false,"setInterval":false,"setTimeout":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false,"WebSocket":false,"Worker":false,"WorkerGlobalScope":false,"XMLHttpRequest":false},"node":{"__dirname":false,"__filename":false,"Buffer":false,"clearImmediate":false,"clearInterval":false,"clearTimeout":false,"console":false,"exports":true,"global":false,"Intl":false,"module":false,"process":false,"queueMicrotask":false,"require":false,"setImmediate":false,"setInterval":false,"setTimeout":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false},"commonjs":{"exports":true,"global":false,"module":false,"require":false},"amd":{"define":false,"require":false},"mocha":{"after":false,"afterEach":false,"before":false,"beforeEach":false,"context":false,"describe":false,"it":false,"mocha":false,"run":false,"setup":false,"specify":false,"suite":false,"suiteSetup":false,"suiteTeardown":false,"teardown":false,"test":false,"xcontext":false,"xdescribe":false,"xit":false,"xspecify":false},"jasmine":{"afterAll":false,"afterEach":false,"beforeAll":false,"beforeEach":false,"describe":false,"expect":false,"fail":false,"fdescribe":false,"fit":false,"it":false,"jasmine":false,"pending":false,"runs":false,"spyOn":false,"spyOnProperty":false,"waits":false,"waitsFor":false,"xdescribe":false,"xit":false},"jest":{"afterAll":false,"afterEach":false,"beforeAll":false,"beforeEach":false,"describe":false,"expect":false,"fdescribe":false,"fit":false,"it":false,"jest":false,"pit":false,"require":false,"test":false,"xdescribe":false,"xit":false,"xtest":false},"qunit":{"asyncTest":false,"deepEqual":false,"equal":false,"expect":false,"module":false,"notDeepEqual":false,"notEqual":false,"notOk":false,"notPropEqual":false,"notStrictEqual":false,"ok":false,"propEqual":false,"QUnit":false,"raises":false,"start":false,"stop":false,"strictEqual":false,"test":false,"throws":false},"phantomjs":{"console":true,"exports":true,"phantom":true,"require":true,"WebPage":true},"couch":{"emit":false,"exports":false,"getRow":false,"log":false,"module":false,"provides":false,"require":false,"respond":false,"send":false,"start":false,"sum":false},"rhino":{"defineClass":false,"deserialize":false,"gc":false,"help":false,"importClass":false,"importPackage":false,"java":false,"load":false,"loadClass":false,"Packages":false,"print":false,"quit":false,"readFile":false,"readUrl":false,"runCommand":false,"seal":false,"serialize":false,"spawn":false,"sync":false,"toint32":false,"version":false},"nashorn":{"__DIR__":false,"__FILE__":false,"__LINE__":false,"com":false,"edu":false,"exit":false,"java":false,"Java":false,"javafx":false,"JavaImporter":false,"javax":false,"JSAdapter":false,"load":false,"loadWithNewGlobal":false,"org":false,"Packages":false,"print":false,"quit":false},"wsh":{"ActiveXObject":true,"Enumerator":true,"GetObject":true,"ScriptEngine":true,"ScriptEngineBuildVersion":true,"ScriptEngineMajorVersion":true,"ScriptEngineMinorVersion":true,"VBArray":true,"WScript":true,"WSH":true,"XDomainRequest":true},"jquery":{"$":false,"jQuery":false},"yui":{"YAHOO":false,"YAHOO_config":false,"YUI":false,"YUI_config":false},"shelljs":{"cat":false,"cd":false,"chmod":false,"config":false,"cp":false,"dirs":false,"echo":false,"env":false,"error":false,"exec":false,"exit":false,"find":false,"grep":false,"ln":false,"ls":false,"mkdir":false,"mv":false,"popd":false,"pushd":false,"pwd":false,"rm":false,"sed":false,"set":false,"target":false,"tempdir":false,"test":false,"touch":false,"which":false},"prototypejs":{"$":false,"$$":false,"$A":false,"$break":false,"$continue":false,"$F":false,"$H":false,"$R":false,"$w":false,"Abstract":false,"Ajax":false,"Autocompleter":false,"Builder":false,"Class":false,"Control":false,"Draggable":false,"Draggables":false,"Droppables":false,"Effect":false,"Element":false,"Enumerable":false,"Event":false,"Field":false,"Form":false,"Hash":false,"Insertion":false,"ObjectRange":false,"PeriodicalExecuter":false,"Position":false,"Prototype":false,"Scriptaculous":false,"Selector":false,"Sortable":false,"SortableObserver":false,"Sound":false,"Template":false,"Toggle":false,"Try":false},"meteor":{"_":false,"$":false,"Accounts":false,"AccountsClient":false,"AccountsCommon":false,"AccountsServer":false,"App":false,"Assets":false,"Blaze":false,"check":false,"Cordova":false,"DDP":false,"DDPRateLimiter":false,"DDPServer":false,"Deps":false,"EJSON":false,"Email":false,"HTTP":false,"Log":false,"Match":false,"Meteor":false,"Mongo":false,"MongoInternals":false,"Npm":false,"Package":false,"Plugin":false,"process":false,"Random":false,"ReactiveDict":false,"ReactiveVar":false,"Router":false,"ServiceConfiguration":false,"Session":false,"share":false,"Spacebars":false,"Template":false,"Tinytest":false,"Tracker":false,"UI":false,"Utils":false,"WebApp":false,"WebAppInternals":false},"mongo":{"_isWindows":false,"_rand":false,"BulkWriteResult":false,"cat":false,"cd":false,"connect":false,"db":false,"getHostName":false,"getMemInfo":false,"hostname":false,"ISODate":false,"listFiles":false,"load":false,"ls":false,"md5sumFile":false,"mkdir":false,"Mongo":false,"NumberInt":false,"NumberLong":false,"ObjectId":false,"PlanCache":false,"print":false,"printjson":false,"pwd":false,"quit":false,"removeFile":false,"rs":false,"sh":false,"UUID":false,"version":false,"WriteResult":false},"applescript":{"$":false,"Application":false,"Automation":false,"console":false,"delay":false,"Library":false,"ObjC":false,"ObjectSpecifier":false,"Path":false,"Progress":false,"Ref":false},"serviceworker":{"addEventListener":false,"applicationCache":false,"atob":false,"Blob":false,"BroadcastChannel":false,"btoa":false,"Cache":false,"caches":false,"CacheStorage":false,"clearInterval":false,"clearTimeout":false,"Client":false,"clients":false,"Clients":false,"close":true,"console":false,"ExtendableEvent":false,"ExtendableMessageEvent":false,"fetch":false,"FetchEvent":false,"FileReaderSync":false,"FormData":false,"Headers":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"ImageData":false,"importScripts":false,"indexedDB":false,"location":false,"MessageChannel":false,"MessagePort":false,"name":false,"navigator":false,"Notification":false,"onclose":true,"onconnect":true,"onerror":true,"onfetch":true,"oninstall":true,"onlanguagechange":true,"onmessage":true,"onmessageerror":true,"onnotificationclick":true,"onnotificationclose":true,"onoffline":true,"ononline":true,"onpush":true,"onpushsubscriptionchange":true,"onrejectionhandled":true,"onsync":true,"onunhandledrejection":true,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"postMessage":true,"Promise":false,"queueMicrotask":false,"registration":false,"removeEventListener":false,"Request":false,"Response":false,"self":false,"ServiceWorker":false,"ServiceWorkerContainer":false,"ServiceWorkerGlobalScope":false,"ServiceWorkerMessageEvent":false,"ServiceWorkerRegistration":false,"setInterval":false,"setTimeout":false,"skipWaiting":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false,"WebSocket":false,"WindowClient":false,"Worker":false,"WorkerGlobalScope":false,"XMLHttpRequest":false},"atomtest":{"advanceClock":false,"fakeClearInterval":false,"fakeClearTimeout":false,"fakeSetInterval":false,"fakeSetTimeout":false,"resetTimeouts":false,"waitsForPromise":false},"embertest":{"andThen":false,"click":false,"currentPath":false,"currentRouteName":false,"currentURL":false,"fillIn":false,"find":false,"findAll":false,"findWithAssert":false,"keyEvent":false,"pauseTest":false,"resumeTest":false,"triggerEvent":false,"visit":false,"wait":false},"protractor":{"$":false,"$$":false,"browser":false,"by":false,"By":false,"DartObject":false,"element":false,"protractor":false},"shared-node-browser":{"clearInterval":false,"clearTimeout":false,"console":false,"setInterval":false,"setTimeout":false,"URL":false,"URLSearchParams":false},"webextensions":{"browser":false,"chrome":false,"opr":false},"greasemonkey":{"cloneInto":false,"createObjectIn":false,"exportFunction":false,"GM":false,"GM_addStyle":false,"GM_deleteValue":false,"GM_getResourceText":false,"GM_getResourceURL":false,"GM_getValue":false,"GM_info":false,"GM_listValues":false,"GM_log":false,"GM_openInTab":false,"GM_registerMenuCommand":false,"GM_setClipboard":false,"GM_setValue":false,"GM_xmlhttpRequest":false,"unsafeWindow":false},"devtools":{"$":false,"$_":false,"$$":false,"$0":false,"$1":false,"$2":false,"$3":false,"$4":false,"$x":false,"chrome":false,"clear":false,"copy":false,"debug":false,"dir":false,"dirxml":false,"getEventListeners":false,"inspect":false,"keys":false,"monitor":false,"monitorEvents":false,"profile":false,"profileEnd":false,"queryObjects":false,"table":false,"undebug":false,"unmonitor":false,"unmonitorEvents":false,"values":false}}');}},__webpack_module_cache__={};function __webpack_require__(moduleId){var cachedModule=__webpack_module_cache__[moduleId];if(void 0!==cachedModule)return cachedModule.exports;var module=__webpack_module_cache__[moduleId]={exports:{}};return __webpack_modules__[moduleId].call(module.exports,module,module.exports,__webpack_require__),module.exports}__webpack_require__.n=module=>{var getter=module&&module.__esModule?()=>module.default:()=>module;return __webpack_require__.d(getter,{a:getter}),getter},__webpack_require__.d=(exports,definition)=>{for(var key in definition)__webpack_require__.o(definition,key)&&!__webpack_require__.o(exports,key)&&Object.defineProperty(exports,key,{enumerable:true,get:definition[key]});},__webpack_require__.o=(obj,prop)=>Object.prototype.hasOwnProperty.call(obj,prop),__webpack_require__.r=exports=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(exports,"__esModule",{value:true});};var __webpack_exports__={};(()=>{__webpack_require__.d(__webpack_exports__,{default:()=>transform});var lib=__webpack_require__("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/index.js"),plugin_proposal_decorators_lib=__webpack_require__("./node_modules/.pnpm/@babel+plugin-proposal-decorators@7.25.9_@babel+core@7.26.0/node_modules/@babel/plugin-proposal-decorators/lib/index.js"),plugin_syntax_class_properties_lib=__webpack_require__("./node_modules/.pnpm/@babel+plugin-syntax-class-properties@7.12.13_@babel+core@7.26.0/node_modules/@babel/plugin-syntax-class-properties/lib/index.js"),plugin_syntax_import_assertions_lib=__webpack_require__("./node_modules/.pnpm/@babel+plugin-syntax-import-assertions@7.26.0_@babel+core@7.26.0/node_modules/@babel/plugin-syntax-import-assertions/lib/index.js"),plugin_syntax_jsx_lib=__webpack_require__("./node_modules/.pnpm/@babel+plugin-syntax-jsx@7.25.9_@babel+core@7.26.0/node_modules/@babel/plugin-syntax-jsx/lib/index.js"),plugin_transform_export_namespace_from_lib=__webpack_require__("./node_modules/.pnpm/@babel+plugin-transform-export-namespace-from@7.25.9_@babel+core@7.26.0/node_modules/@babel/plugin-transform-export-namespace-from/lib/index.js"),plugin_transform_react_jsx_lib=__webpack_require__("./node_modules/.pnpm/@babel+plugin-transform-react-jsx@7.25.9_@babel+core@7.26.0/node_modules/@babel/plugin-transform-react-jsx/lib/index.js"),plugin_transform_typescript_lib=__webpack_require__("./node_modules/.pnpm/@babel+plugin-transform-typescript@7.26.3_@babel+core@7.26.0/node_modules/@babel/plugin-transform-typescript/lib/index.js"),babel_plugin_parameter_decorator_lib=__webpack_require__("./node_modules/.pnpm/babel-plugin-parameter-decorator@1.0.16/node_modules/babel-plugin-parameter-decorator/lib/index.js"),babel_plugin_parameter_decorator_lib_default=__webpack_require__.n(babel_plugin_parameter_decorator_lib),helper_plugin_utils_lib=__webpack_require__("./node_modules/.pnpm/@babel+helper-plugin-utils@7.25.9/node_modules/@babel/helper-plugin-utils/lib/index.js");function createParamDecorator(paramIndex,decoratorExpression,isConstructor=false){return lib.types.decorator(lib.types.functionExpression(null,[lib.types.identifier("target"),lib.types.identifier("key")],lib.types.blockStatement([lib.types.returnStatement(lib.types.callExpression(decoratorExpression,[lib.types.identifier("target"),lib.types.identifier(isConstructor?"undefined":"key"),lib.types.numericLiteral(paramIndex)]))])))}function parameterVisitor(classPath,path){if("ClassMethod"!==path.type)return;if("ClassMethod"!==path.node.type)return;if("Identifier"!==path.node.key.type)return;const methodPath=path,params=methodPath.get("params")||[];for(const param of params){if(null==("Identifier"===param.node.type||"ObjectPattern"===param.node.type?param.node:"TSParameterProperty"===param.node.type&&"Identifier"===param.node.parameter.type?param.node.parameter:null))continue;let resultantDecorator;for(const decorator of param.node.decorators||[])"constructor"===methodPath.node.kind?(resultantDecorator=createParamDecorator(param.key,decorator.expression,true),classPath.node.decorators||(classPath.node.decorators=[]),classPath.node.decorators.push(resultantDecorator)):(resultantDecorator=createParamDecorator(param.key,decorator.expression,false),methodPath.node.decorators||(methodPath.node.decorators=[]),methodPath.node.decorators.push(resultantDecorator));resultantDecorator&&(param.node.decorators=null);}}function createVoidZero(){return lib.types.unaryExpression("void",lib.types.numericLiteral(0))}function getTypedNode(param){return null==param?null:"ClassProperty"===param.type||"Identifier"===param.type||"ObjectPattern"===param.type?param:"AssignmentPattern"===param.type&&"Identifier"===param.left.type?param.left:"TSParameterProperty"===param.type?getTypedNode(param.parameter):null}function serializeType(classPath,param){const node=getTypedNode(param);if(null==node)return createVoidZero();if(!node.typeAnnotation||"TSTypeAnnotation"!==node.typeAnnotation.type)return createVoidZero();const annotation=node.typeAnnotation.typeAnnotation;return serializeTypeNode(classPath.node.id?classPath.node.id.name:"",annotation)}function serializeTypeReferenceNode(className,node){const reference=serializeReference(node.typeName);return isClassType(className,reference)?lib.types.identifier("Object"):lib.types.conditionalExpression(lib.types.binaryExpression("===",lib.types.unaryExpression("typeof",reference),lib.types.stringLiteral("undefined")),lib.types.identifier("Object"),lib.types.cloneDeep(reference))}function isClassType(className,node){switch(node.type){case "Identifier":return node.name===className;case "MemberExpression":return isClassType(className,node.object);default:throw new Error(`The property expression at ${node.start} is not valid as a Type to be used in Reflect.metadata`)}}function serializeReference(typeName){return "Identifier"===typeName.type?lib.types.identifier(typeName.name):lib.types.memberExpression(serializeReference(typeName.left),typeName.right)}function serializeTypeNode(className,node){if(void 0===node)return lib.types.identifier("Object");switch(node.type){case "TSVoidKeyword":case "TSUndefinedKeyword":case "TSNullKeyword":case "TSNeverKeyword":return createVoidZero();case "TSParenthesizedType":return serializeTypeNode(className,node.typeAnnotation);case "TSFunctionType":case "TSConstructorType":return lib.types.identifier("Function");case "TSArrayType":case "TSTupleType":return lib.types.identifier("Array");case "TSTypePredicate":case "TSBooleanKeyword":return lib.types.identifier("Boolean");case "TSStringKeyword":return lib.types.identifier("String");case "TSObjectKeyword":return lib.types.identifier("Object");case "TSLiteralType":switch(node.literal.type){case "StringLiteral":return lib.types.identifier("String");case "NumericLiteral":return lib.types.identifier("Number");case "BooleanLiteral":return lib.types.identifier("Boolean");default:throw new Error("Bad type for decorator"+node.literal)}case "TSNumberKeyword":case "TSBigIntKeyword":return lib.types.identifier("Number");case "TSSymbolKeyword":return lib.types.identifier("Symbol");case "TSTypeReference":return serializeTypeReferenceNode(className,node);case "TSIntersectionType":case "TSUnionType":return serializeTypeList(className,node.types);case "TSConditionalType":return serializeTypeList(className,[node.trueType,node.falseType]);case "TSTypeQuery":case "TSTypeOperator":case "TSIndexedAccessType":case "TSMappedType":case "TSTypeLiteral":case "TSAnyKeyword":case "TSUnknownKeyword":case "TSThisType":break;default:throw new Error("Bad type for decorator")}return lib.types.identifier("Object")}function serializeTypeList(className,types){let serializedUnion;for(let typeNode of types){for(;"TSParenthesizedType"===typeNode.type;)typeNode=typeNode.typeAnnotation;if("TSNeverKeyword"===typeNode.type)continue;if("TSNullKeyword"===typeNode.type||"TSUndefinedKeyword"===typeNode.type)continue;const serializedIndividual=serializeTypeNode(className,typeNode);if(lib.types.isIdentifier(serializedIndividual)&&"Object"===serializedIndividual.name)return serializedIndividual;if(serializedUnion){if(!lib.types.isIdentifier(serializedUnion)||!lib.types.isIdentifier(serializedIndividual)||serializedUnion.name!==serializedIndividual.name)return lib.types.identifier("Object")}else serializedUnion=serializedIndividual;}return serializedUnion||createVoidZero()}function createMetadataDesignDecorator(design,typeArg){return lib.types.decorator(lib.types.logicalExpression("||",lib.types.optionalCallExpression(lib.types.memberExpression(lib.types.identifier("Reflect"),lib.types.identifier("metadata")),[lib.types.stringLiteral(design),typeArg],true),lib.types.arrowFunctionExpression([lib.types.identifier("t")],lib.types.identifier("t"))))}function metadataVisitor(classPath,path){const field=path.node,classNode=classPath.node;switch(field.type){case "ClassMethod":{const decorators="constructor"===field.kind?classNode.decorators:field.decorators;if(!decorators||0===decorators.length)return;decorators.push(createMetadataDesignDecorator("design:type",lib.types.identifier("Function"))),decorators.push(createMetadataDesignDecorator("design:paramtypes",lib.types.arrayExpression(field.params.map((param=>serializeType(classPath,param))))));break}case "ClassProperty":if(!field.decorators||0===field.decorators.length)return;if(!field.typeAnnotation||"TSTypeAnnotation"!==field.typeAnnotation.type)return;field.decorators.push(createMetadataDesignDecorator("design:type",serializeType(classPath,field)));}}const babel_plugin_transform_typescript_metadata=(0, helper_plugin_utils_lib.declare)((api=>(api.assertVersion(7),{visitor:{Program(programPath){programPath.traverse({ClassDeclaration(path){for(const field of path.get("body").get("body"))"ClassMethod"!==field.type&&"ClassProperty"!==field.type||(parameterVisitor(path,field),metadataVisitor(path,field));path.parentPath.scope.crawl();}});}}})));function importMetaEnvPlugin({template,types}){return {name:"@import-meta-env/babel",visitor:{Identifier(path){if(!types.isIdentifier(path))return;if(!types.isMemberExpression(path.parentPath)&&!types.isOptionalMemberExpression(path.parentPath))return;if(!types.isMemberExpression(path.parentPath.node))return;const parentNode=path.parentPath.node;if(!types.isMetaProperty(parentNode.object))return;const parentNodeObjMeta=parentNode.object;"import"===parentNodeObjMeta.meta.name&&"meta"===parentNodeObjMeta.property.name&&"env"===parentNode.property.name&&path.parentPath.replaceWith(template.expression.ast("process.env"));}}}}function importMetaResolvePlugin(_ctx){return {name:"import-meta-resolve",visitor:{Program(path){const metas=[];if(path.traverse({MemberExpression(memberExpPath){const{node}=memberExpPath;"MetaProperty"===node.object.type&&"import"===node.object.meta.name&&"meta"===node.object.property.name&&"Identifier"===node.property.type&&"resolve"===node.property.name&&metas.push(memberExpPath);}}),0!==metas.length)for(const meta of metas)meta.replaceWith({type:"ExpressionStatement",expression:{type:"Identifier",name:"jitiESMResolve"}});}}}}var template_lib=__webpack_require__("./node_modules/.pnpm/@babel+template@7.25.9/node_modules/@babel/template/lib/index.js");const _DRIVE_LETTER_START_RE=/^[A-Za-z]:\//;function normalizeWindowsPath(input=""){return input?input.replace(/\\/g,"/").replace(_DRIVE_LETTER_START_RE,(r=>r.toUpperCase())):input}const _IS_ABSOLUTE_RE=/^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Za-z]:[/\\]/,_DRIVE_LETTER_RE=/^[A-Za-z]:$/;const pathe_ff20891b_isAbsolute=function(p){return _IS_ABSOLUTE_RE.test(p)},pathe_ff20891b_dirname=function(p){const segments=normalizeWindowsPath(p).replace(/\/$/,"").split("/").slice(0,-1);return 1===segments.length&&_DRIVE_LETTER_RE.test(segments[0])&&(segments[0]+="/"),segments.join("/")||(pathe_ff20891b_isAbsolute(p)?"/":".")};var astralIdentifierCodes=[509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,7,9,32,4,318,1,80,3,71,10,50,3,123,2,54,14,32,10,3,1,11,3,46,10,8,0,46,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,2,11,83,11,7,0,3,0,158,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,68,8,2,0,3,0,2,3,2,4,2,0,15,1,83,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,7,19,58,14,5,9,243,14,166,9,71,5,2,1,3,3,2,0,2,1,13,9,120,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,343,9,54,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,10,1,2,0,49,6,4,4,14,10,5350,0,7,14,11465,27,2343,9,87,9,39,4,60,6,26,9,535,9,470,0,2,54,8,3,82,0,12,1,19628,1,4178,9,519,45,3,22,543,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,101,0,161,6,10,9,357,0,62,13,499,13,245,1,2,9,726,6,110,6,6,9,4759,9,787719,239],astralIdentifierStartCodes=[0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,13,10,2,14,2,6,2,1,2,10,2,14,2,6,2,1,4,51,13,310,10,21,11,7,25,5,2,41,2,8,70,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,39,27,10,22,251,41,7,1,17,2,60,28,11,0,9,21,43,17,47,20,28,22,13,52,58,1,3,0,14,44,33,24,27,35,30,0,3,0,9,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,20,1,64,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,31,9,2,0,3,0,2,37,2,0,26,0,2,0,45,52,19,3,21,2,31,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,38,6,186,43,117,63,32,7,3,0,3,7,2,1,2,23,16,0,2,0,95,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,19,72,200,32,32,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,16,0,2,12,2,33,125,0,80,921,103,110,18,195,2637,96,16,1071,18,5,26,3994,6,582,6842,29,1763,568,8,30,18,78,18,29,19,47,17,3,32,20,6,18,433,44,212,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,1237,42,9,8936,3,2,6,2,1,2,290,16,0,30,2,3,0,15,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,1845,30,7,5,262,61,147,44,11,6,17,0,322,29,19,43,485,27,229,29,3,0,496,6,2,3,2,1,2,14,2,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42719,33,4153,7,221,3,5761,15,7472,16,621,2467,541,1507,4938,6,4191],nonASCIIidentifierStartChars="------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------",reservedWords={3:"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",5:"class enum extends super const export import",6:"enum",strict:"implements interface let package private protected public static yield",strictBind:"eval arguments"},ecma5AndLessKeywords="break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this",keywords$1={5:ecma5AndLessKeywords,"5module":ecma5AndLessKeywords+" export import",6:ecma5AndLessKeywords+" const class extends export import super"},keywordRelationalOperator=/^in(stanceof)?$/,nonASCIIidentifierStart=new RegExp("["+nonASCIIidentifierStartChars+"]"),nonASCIIidentifier=new RegExp("["+nonASCIIidentifierStartChars+"-----------------------------------------------------------------------------------------------------------------------------------------------------]");function isInAstralSet(code,set){for(var pos=65536,i=0;i<set.length;i+=2){if((pos+=set[i])>code)return  false;if((pos+=set[i+1])>=code)return  true}return  false}function isIdentifierStart(code,astral){return code<65?36===code:code<91||(code<97?95===code:code<123||(code<=65535?code>=170&&nonASCIIidentifierStart.test(String.fromCharCode(code)):false!==astral&&isInAstralSet(code,astralIdentifierStartCodes)))}function isIdentifierChar(code,astral){return code<48?36===code:code<58||!(code<65)&&(code<91||(code<97?95===code:code<123||(code<=65535?code>=170&&nonASCIIidentifier.test(String.fromCharCode(code)):false!==astral&&(isInAstralSet(code,astralIdentifierStartCodes)||isInAstralSet(code,astralIdentifierCodes)))))}var TokenType=function(label,conf){ void 0===conf&&(conf={}),this.label=label,this.keyword=conf.keyword,this.beforeExpr=!!conf.beforeExpr,this.startsExpr=!!conf.startsExpr,this.isLoop=!!conf.isLoop,this.isAssign=!!conf.isAssign,this.prefix=!!conf.prefix,this.postfix=!!conf.postfix,this.binop=conf.binop||null,this.updateContext=null;};function binop(name,prec){return new TokenType(name,{beforeExpr:true,binop:prec})}var beforeExpr={beforeExpr:true},startsExpr={startsExpr:true},keywords={};function kw(name,options){return void 0===options&&(options={}),options.keyword=name,keywords[name]=new TokenType(name,options)}var types$1={num:new TokenType("num",startsExpr),regexp:new TokenType("regexp",startsExpr),string:new TokenType("string",startsExpr),name:new TokenType("name",startsExpr),privateId:new TokenType("privateId",startsExpr),eof:new TokenType("eof"),bracketL:new TokenType("[",{beforeExpr:true,startsExpr:true}),bracketR:new TokenType("]"),braceL:new TokenType("{",{beforeExpr:true,startsExpr:true}),braceR:new TokenType("}"),parenL:new TokenType("(",{beforeExpr:true,startsExpr:true}),parenR:new TokenType(")"),comma:new TokenType(",",beforeExpr),semi:new TokenType(";",beforeExpr),colon:new TokenType(":",beforeExpr),dot:new TokenType("."),question:new TokenType("?",beforeExpr),questionDot:new TokenType("?."),arrow:new TokenType("=>",beforeExpr),template:new TokenType("template"),invalidTemplate:new TokenType("invalidTemplate"),ellipsis:new TokenType("...",beforeExpr),backQuote:new TokenType("`",startsExpr),dollarBraceL:new TokenType("${",{beforeExpr:true,startsExpr:true}),eq:new TokenType("=",{beforeExpr:true,isAssign:true}),assign:new TokenType("_=",{beforeExpr:true,isAssign:true}),incDec:new TokenType("++/--",{prefix:true,postfix:true,startsExpr:true}),prefix:new TokenType("!/~",{beforeExpr:true,prefix:true,startsExpr:true}),logicalOR:binop("||",1),logicalAND:binop("&&",2),bitwiseOR:binop("|",3),bitwiseXOR:binop("^",4),bitwiseAND:binop("&",5),equality:binop("==/!=/===/!==",6),relational:binop("</>/<=/>=",7),bitShift:binop("<</>>/>>>",8),plusMin:new TokenType("+/-",{beforeExpr:true,binop:9,prefix:true,startsExpr:true}),modulo:binop("%",10),star:binop("*",10),slash:binop("/",10),starstar:new TokenType("**",{beforeExpr:true}),coalesce:binop("??",1),_break:kw("break"),_case:kw("case",beforeExpr),_catch:kw("catch"),_continue:kw("continue"),_debugger:kw("debugger"),_default:kw("default",beforeExpr),_do:kw("do",{isLoop:true,beforeExpr:true}),_else:kw("else",beforeExpr),_finally:kw("finally"),_for:kw("for",{isLoop:true}),_function:kw("function",startsExpr),_if:kw("if"),_return:kw("return",beforeExpr),_switch:kw("switch"),_throw:kw("throw",beforeExpr),_try:kw("try"),_var:kw("var"),_const:kw("const"),_while:kw("while",{isLoop:true}),_with:kw("with"),_new:kw("new",{beforeExpr:true,startsExpr:true}),_this:kw("this",startsExpr),_super:kw("super",startsExpr),_class:kw("class",startsExpr),_extends:kw("extends",beforeExpr),_export:kw("export"),_import:kw("import",startsExpr),_null:kw("null",startsExpr),_true:kw("true",startsExpr),_false:kw("false",startsExpr),_in:kw("in",{beforeExpr:true,binop:7}),_instanceof:kw("instanceof",{beforeExpr:true,binop:7}),_typeof:kw("typeof",{beforeExpr:true,prefix:true,startsExpr:true}),_void:kw("void",{beforeExpr:true,prefix:true,startsExpr:true}),_delete:kw("delete",{beforeExpr:true,prefix:true,startsExpr:true})},lineBreak=/\r\n?|\n|\u2028|\u2029/,lineBreakG=new RegExp(lineBreak.source,"g");function isNewLine(code){return 10===code||13===code||8232===code||8233===code}function nextLineBreak(code,from,end){ void 0===end&&(end=code.length);for(var i=from;i<end;i++){var next=code.charCodeAt(i);if(isNewLine(next))return i<end-1&&13===next&&10===code.charCodeAt(i+1)?i+2:i+1}return  -1}var nonASCIIwhitespace=/[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/,skipWhiteSpace=/(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g,ref=Object.prototype,acorn_hasOwnProperty=ref.hasOwnProperty,acorn_toString=ref.toString,hasOwn=Object.hasOwn||function(obj,propName){return acorn_hasOwnProperty.call(obj,propName)},isArray=Array.isArray||function(obj){return "[object Array]"===acorn_toString.call(obj)},regexpCache=Object.create(null);function wordsRegexp(words){return regexpCache[words]||(regexpCache[words]=new RegExp("^(?:"+words.replace(/ /g,"|")+")$"))}function codePointToString(code){return code<=65535?String.fromCharCode(code):(code-=65536,String.fromCharCode(55296+(code>>10),56320+(1023&code)))}var loneSurrogate=/(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/,Position=function(line,col){this.line=line,this.column=col;};Position.prototype.offset=function(n){return new Position(this.line,this.column+n)};var SourceLocation=function(p,start,end){this.start=start,this.end=end,null!==p.sourceFile&&(this.source=p.sourceFile);};function getLineInfo(input,offset){for(var line=1,cur=0;;){var nextBreak=nextLineBreak(input,cur,offset);if(nextBreak<0)return new Position(line,offset-cur);++line,cur=nextBreak;}}var defaultOptions={ecmaVersion:null,sourceType:"script",onInsertedSemicolon:null,onTrailingComma:null,allowReserved:null,allowReturnOutsideFunction:false,allowImportExportEverywhere:false,allowAwaitOutsideFunction:null,allowSuperOutsideMethod:null,allowHashBang:false,checkPrivateFields:true,locations:false,onToken:null,onComment:null,ranges:false,program:null,sourceFile:null,directSourceFile:null,preserveParens:false},warnedAboutEcmaVersion=false;function getOptions(opts){var options={};for(var opt in defaultOptions)options[opt]=opts&&hasOwn(opts,opt)?opts[opt]:defaultOptions[opt];if("latest"===options.ecmaVersion?options.ecmaVersion=1e8:null==options.ecmaVersion?(!warnedAboutEcmaVersion&&"object"==typeof console&&console.warn&&(warnedAboutEcmaVersion=true,console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.")),options.ecmaVersion=11):options.ecmaVersion>=2015&&(options.ecmaVersion-=2009),null==options.allowReserved&&(options.allowReserved=options.ecmaVersion<5),opts&&null!=opts.allowHashBang||(options.allowHashBang=options.ecmaVersion>=14),isArray(options.onToken)){var tokens=options.onToken;options.onToken=function(token){return tokens.push(token)};}return isArray(options.onComment)&&(options.onComment=function(options,array){return function(block,text,start,end,startLoc,endLoc){var comment={type:block?"Block":"Line",value:text,start,end};options.locations&&(comment.loc=new SourceLocation(this,startLoc,endLoc)),options.ranges&&(comment.range=[start,end]),array.push(comment);}}(options,options.onComment)),options}function functionFlags(async,generator){return 2|(async?4:0)|(generator?8:0)}var Parser=function(options,input,startPos){this.options=options=getOptions(options),this.sourceFile=options.sourceFile,this.keywords=wordsRegexp(keywords$1[options.ecmaVersion>=6?6:"module"===options.sourceType?"5module":5]);var reserved="";true!==options.allowReserved&&(reserved=reservedWords[options.ecmaVersion>=6?6:5===options.ecmaVersion?5:3],"module"===options.sourceType&&(reserved+=" await")),this.reservedWords=wordsRegexp(reserved);var reservedStrict=(reserved?reserved+" ":"")+reservedWords.strict;this.reservedWordsStrict=wordsRegexp(reservedStrict),this.reservedWordsStrictBind=wordsRegexp(reservedStrict+" "+reservedWords.strictBind),this.input=String(input),this.containsEsc=false,startPos?(this.pos=startPos,this.lineStart=this.input.lastIndexOf("\n",startPos-1)+1,this.curLine=this.input.slice(0,this.lineStart).split(lineBreak).length):(this.pos=this.lineStart=0,this.curLine=1),this.type=types$1.eof,this.value=null,this.start=this.end=this.pos,this.startLoc=this.endLoc=this.curPosition(),this.lastTokEndLoc=this.lastTokStartLoc=null,this.lastTokStart=this.lastTokEnd=this.pos,this.context=this.initialContext(),this.exprAllowed=true,this.inModule="module"===options.sourceType,this.strict=this.inModule||this.strictDirective(this.pos),this.potentialArrowAt=-1,this.potentialArrowInForAwait=false,this.yieldPos=this.awaitPos=this.awaitIdentPos=0,this.labels=[],this.undefinedExports=Object.create(null),0===this.pos&&options.allowHashBang&&"#!"===this.input.slice(0,2)&&this.skipLineComment(2),this.scopeStack=[],this.enterScope(1),this.regexpState=null,this.privateNameStack=[];},prototypeAccessors={inFunction:{configurable:true},inGenerator:{configurable:true},inAsync:{configurable:true},canAwait:{configurable:true},allowSuper:{configurable:true},allowDirectSuper:{configurable:true},treatFunctionsAsVar:{configurable:true},allowNewDotTarget:{configurable:true},inClassStaticBlock:{configurable:true}};Parser.prototype.parse=function(){var node=this.options.program||this.startNode();return this.nextToken(),this.parseTopLevel(node)},prototypeAccessors.inFunction.get=function(){return (2&this.currentVarScope().flags)>0},prototypeAccessors.inGenerator.get=function(){return (8&this.currentVarScope().flags)>0&&!this.currentVarScope().inClassFieldInit},prototypeAccessors.inAsync.get=function(){return (4&this.currentVarScope().flags)>0&&!this.currentVarScope().inClassFieldInit},prototypeAccessors.canAwait.get=function(){for(var i=this.scopeStack.length-1;i>=0;i--){var scope=this.scopeStack[i];if(scope.inClassFieldInit||256&scope.flags)return  false;if(2&scope.flags)return (4&scope.flags)>0}return this.inModule&&this.options.ecmaVersion>=13||this.options.allowAwaitOutsideFunction},prototypeAccessors.allowSuper.get=function(){var ref=this.currentThisScope(),flags=ref.flags,inClassFieldInit=ref.inClassFieldInit;return (64&flags)>0||inClassFieldInit||this.options.allowSuperOutsideMethod},prototypeAccessors.allowDirectSuper.get=function(){return (128&this.currentThisScope().flags)>0},prototypeAccessors.treatFunctionsAsVar.get=function(){return this.treatFunctionsAsVarInScope(this.currentScope())},prototypeAccessors.allowNewDotTarget.get=function(){var ref=this.currentThisScope(),flags=ref.flags,inClassFieldInit=ref.inClassFieldInit;return (258&flags)>0||inClassFieldInit},prototypeAccessors.inClassStaticBlock.get=function(){return (256&this.currentVarScope().flags)>0},Parser.extend=function(){for(var plugins=[],len=arguments.length;len--;)plugins[len]=arguments[len];for(var cls=this,i=0;i<plugins.length;i++)cls=plugins[i](cls);return cls},Parser.parse=function(input,options){return new this(options,input).parse()},Parser.parseExpressionAt=function(input,pos,options){var parser=new this(options,input,pos);return parser.nextToken(),parser.parseExpression()},Parser.tokenizer=function(input,options){return new this(options,input)},Object.defineProperties(Parser.prototype,prototypeAccessors);var pp$9=Parser.prototype,literal=/^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;pp$9.strictDirective=function(start){if(this.options.ecmaVersion<5)return  false;for(;;){skipWhiteSpace.lastIndex=start,start+=skipWhiteSpace.exec(this.input)[0].length;var match=literal.exec(this.input.slice(start));if(!match)return  false;if("use strict"===(match[1]||match[2])){skipWhiteSpace.lastIndex=start+match[0].length;var spaceAfter=skipWhiteSpace.exec(this.input),end=spaceAfter.index+spaceAfter[0].length,next=this.input.charAt(end);return ";"===next||"}"===next||lineBreak.test(spaceAfter[0])&&!(/[(`.[+\-/*%<>=,?^&]/.test(next)||"!"===next&&"="===this.input.charAt(end+1))}start+=match[0].length,skipWhiteSpace.lastIndex=start,start+=skipWhiteSpace.exec(this.input)[0].length,";"===this.input[start]&&start++;}},pp$9.eat=function(type){return this.type===type&&(this.next(),true)},pp$9.isContextual=function(name){return this.type===types$1.name&&this.value===name&&!this.containsEsc},pp$9.eatContextual=function(name){return !!this.isContextual(name)&&(this.next(),true)},pp$9.expectContextual=function(name){this.eatContextual(name)||this.unexpected();},pp$9.canInsertSemicolon=function(){return this.type===types$1.eof||this.type===types$1.braceR||lineBreak.test(this.input.slice(this.lastTokEnd,this.start))},pp$9.insertSemicolon=function(){if(this.canInsertSemicolon())return this.options.onInsertedSemicolon&&this.options.onInsertedSemicolon(this.lastTokEnd,this.lastTokEndLoc),true},pp$9.semicolon=function(){this.eat(types$1.semi)||this.insertSemicolon()||this.unexpected();},pp$9.afterTrailingComma=function(tokType,notNext){if(this.type===tokType)return this.options.onTrailingComma&&this.options.onTrailingComma(this.lastTokStart,this.lastTokStartLoc),notNext||this.next(),true},pp$9.expect=function(type){this.eat(type)||this.unexpected();},pp$9.unexpected=function(pos){this.raise(null!=pos?pos:this.start,"Unexpected token");};var DestructuringErrors=function(){this.shorthandAssign=this.trailingComma=this.parenthesizedAssign=this.parenthesizedBind=this.doubleProto=-1;};pp$9.checkPatternErrors=function(refDestructuringErrors,isAssign){if(refDestructuringErrors){refDestructuringErrors.trailingComma>-1&&this.raiseRecoverable(refDestructuringErrors.trailingComma,"Comma is not permitted after the rest element");var parens=isAssign?refDestructuringErrors.parenthesizedAssign:refDestructuringErrors.parenthesizedBind;parens>-1&&this.raiseRecoverable(parens,isAssign?"Assigning to rvalue":"Parenthesized pattern");}},pp$9.checkExpressionErrors=function(refDestructuringErrors,andThrow){if(!refDestructuringErrors)return  false;var shorthandAssign=refDestructuringErrors.shorthandAssign,doubleProto=refDestructuringErrors.doubleProto;if(!andThrow)return shorthandAssign>=0||doubleProto>=0;shorthandAssign>=0&&this.raise(shorthandAssign,"Shorthand property assignments are valid only in destructuring patterns"),doubleProto>=0&&this.raiseRecoverable(doubleProto,"Redefinition of __proto__ property");},pp$9.checkYieldAwaitInDefaultParams=function(){this.yieldPos&&(!this.awaitPos||this.yieldPos<this.awaitPos)&&this.raise(this.yieldPos,"Yield expression cannot be a default value"),this.awaitPos&&this.raise(this.awaitPos,"Await expression cannot be a default value");},pp$9.isSimpleAssignTarget=function(expr){return "ParenthesizedExpression"===expr.type?this.isSimpleAssignTarget(expr.expression):"Identifier"===expr.type||"MemberExpression"===expr.type};var pp$8=Parser.prototype;pp$8.parseTopLevel=function(node){var exports=Object.create(null);for(node.body||(node.body=[]);this.type!==types$1.eof;){var stmt=this.parseStatement(null,true,exports);node.body.push(stmt);}if(this.inModule)for(var i=0,list=Object.keys(this.undefinedExports);i<list.length;i+=1){var name=list[i];this.raiseRecoverable(this.undefinedExports[name].start,"Export '"+name+"' is not defined");}return this.adaptDirectivePrologue(node.body),this.next(),node.sourceType=this.options.sourceType,this.finishNode(node,"Program")};var loopLabel={kind:"loop"},switchLabel={kind:"switch"};pp$8.isLet=function(context){if(this.options.ecmaVersion<6||!this.isContextual("let"))return  false;skipWhiteSpace.lastIndex=this.pos;var skip=skipWhiteSpace.exec(this.input),next=this.pos+skip[0].length,nextCh=this.input.charCodeAt(next);if(91===nextCh||92===nextCh)return  true;if(context)return  false;if(123===nextCh||nextCh>55295&&nextCh<56320)return  true;if(isIdentifierStart(nextCh,true)){for(var pos=next+1;isIdentifierChar(nextCh=this.input.charCodeAt(pos),true);)++pos;if(92===nextCh||nextCh>55295&&nextCh<56320)return  true;var ident=this.input.slice(next,pos);if(!keywordRelationalOperator.test(ident))return  true}return  false},pp$8.isAsyncFunction=function(){if(this.options.ecmaVersion<8||!this.isContextual("async"))return  false;skipWhiteSpace.lastIndex=this.pos;var after,skip=skipWhiteSpace.exec(this.input),next=this.pos+skip[0].length;return !(lineBreak.test(this.input.slice(this.pos,next))||"function"!==this.input.slice(next,next+8)||next+8!==this.input.length&&(isIdentifierChar(after=this.input.charCodeAt(next+8))||after>55295&&after<56320))},pp$8.parseStatement=function(context,topLevel,exports){var kind,starttype=this.type,node=this.startNode();switch(this.isLet(context)&&(starttype=types$1._var,kind="let"),starttype){case types$1._break:case types$1._continue:return this.parseBreakContinueStatement(node,starttype.keyword);case types$1._debugger:return this.parseDebuggerStatement(node);case types$1._do:return this.parseDoStatement(node);case types$1._for:return this.parseForStatement(node);case types$1._function:return context&&(this.strict||"if"!==context&&"label"!==context)&&this.options.ecmaVersion>=6&&this.unexpected(),this.parseFunctionStatement(node,false,!context);case types$1._class:return context&&this.unexpected(),this.parseClass(node,true);case types$1._if:return this.parseIfStatement(node);case types$1._return:return this.parseReturnStatement(node);case types$1._switch:return this.parseSwitchStatement(node);case types$1._throw:return this.parseThrowStatement(node);case types$1._try:return this.parseTryStatement(node);case types$1._const:case types$1._var:return kind=kind||this.value,context&&"var"!==kind&&this.unexpected(),this.parseVarStatement(node,kind);case types$1._while:return this.parseWhileStatement(node);case types$1._with:return this.parseWithStatement(node);case types$1.braceL:return this.parseBlock(true,node);case types$1.semi:return this.parseEmptyStatement(node);case types$1._export:case types$1._import:if(this.options.ecmaVersion>10&&starttype===types$1._import){skipWhiteSpace.lastIndex=this.pos;var skip=skipWhiteSpace.exec(this.input),next=this.pos+skip[0].length,nextCh=this.input.charCodeAt(next);if(40===nextCh||46===nextCh)return this.parseExpressionStatement(node,this.parseExpression())}return this.options.allowImportExportEverywhere||(topLevel||this.raise(this.start,"'import' and 'export' may only appear at the top level"),this.inModule||this.raise(this.start,"'import' and 'export' may appear only with 'sourceType: module'")),starttype===types$1._import?this.parseImport(node):this.parseExport(node,exports);default:if(this.isAsyncFunction())return context&&this.unexpected(),this.next(),this.parseFunctionStatement(node,true,!context);var maybeName=this.value,expr=this.parseExpression();return starttype===types$1.name&&"Identifier"===expr.type&&this.eat(types$1.colon)?this.parseLabeledStatement(node,maybeName,expr,context):this.parseExpressionStatement(node,expr)}},pp$8.parseBreakContinueStatement=function(node,keyword){var isBreak="break"===keyword;this.next(),this.eat(types$1.semi)||this.insertSemicolon()?node.label=null:this.type!==types$1.name?this.unexpected():(node.label=this.parseIdent(),this.semicolon());for(var i=0;i<this.labels.length;++i){var lab=this.labels[i];if(null==node.label||lab.name===node.label.name){if(null!=lab.kind&&(isBreak||"loop"===lab.kind))break;if(node.label&&isBreak)break}}return i===this.labels.length&&this.raise(node.start,"Unsyntactic "+keyword),this.finishNode(node,isBreak?"BreakStatement":"ContinueStatement")},pp$8.parseDebuggerStatement=function(node){return this.next(),this.semicolon(),this.finishNode(node,"DebuggerStatement")},pp$8.parseDoStatement=function(node){return this.next(),this.labels.push(loopLabel),node.body=this.parseStatement("do"),this.labels.pop(),this.expect(types$1._while),node.test=this.parseParenExpression(),this.options.ecmaVersion>=6?this.eat(types$1.semi):this.semicolon(),this.finishNode(node,"DoWhileStatement")},pp$8.parseForStatement=function(node){this.next();var awaitAt=this.options.ecmaVersion>=9&&this.canAwait&&this.eatContextual("await")?this.lastTokStart:-1;if(this.labels.push(loopLabel),this.enterScope(0),this.expect(types$1.parenL),this.type===types$1.semi)return awaitAt>-1&&this.unexpected(awaitAt),this.parseFor(node,null);var isLet=this.isLet();if(this.type===types$1._var||this.type===types$1._const||isLet){var init$1=this.startNode(),kind=isLet?"let":this.value;return this.next(),this.parseVar(init$1,true,kind),this.finishNode(init$1,"VariableDeclaration"),(this.type===types$1._in||this.options.ecmaVersion>=6&&this.isContextual("of"))&&1===init$1.declarations.length?(this.options.ecmaVersion>=9&&(this.type===types$1._in?awaitAt>-1&&this.unexpected(awaitAt):node.await=awaitAt>-1),this.parseForIn(node,init$1)):(awaitAt>-1&&this.unexpected(awaitAt),this.parseFor(node,init$1))}var startsWithLet=this.isContextual("let"),isForOf=false,containsEsc=this.containsEsc,refDestructuringErrors=new DestructuringErrors,initPos=this.start,init=awaitAt>-1?this.parseExprSubscripts(refDestructuringErrors,"await"):this.parseExpression(true,refDestructuringErrors);return this.type===types$1._in||(isForOf=this.options.ecmaVersion>=6&&this.isContextual("of"))?(awaitAt>-1?(this.type===types$1._in&&this.unexpected(awaitAt),node.await=true):isForOf&&this.options.ecmaVersion>=8&&(init.start!==initPos||containsEsc||"Identifier"!==init.type||"async"!==init.name?this.options.ecmaVersion>=9&&(node.await=false):this.unexpected()),startsWithLet&&isForOf&&this.raise(init.start,"The left-hand side of a for-of loop may not start with 'let'."),this.toAssignable(init,false,refDestructuringErrors),this.checkLValPattern(init),this.parseForIn(node,init)):(this.checkExpressionErrors(refDestructuringErrors,true),awaitAt>-1&&this.unexpected(awaitAt),this.parseFor(node,init))},pp$8.parseFunctionStatement=function(node,isAsync,declarationPosition){return this.next(),this.parseFunction(node,FUNC_STATEMENT|(declarationPosition?0:FUNC_HANGING_STATEMENT),false,isAsync)},pp$8.parseIfStatement=function(node){return this.next(),node.test=this.parseParenExpression(),node.consequent=this.parseStatement("if"),node.alternate=this.eat(types$1._else)?this.parseStatement("if"):null,this.finishNode(node,"IfStatement")},pp$8.parseReturnStatement=function(node){return this.inFunction||this.options.allowReturnOutsideFunction||this.raise(this.start,"'return' outside of function"),this.next(),this.eat(types$1.semi)||this.insertSemicolon()?node.argument=null:(node.argument=this.parseExpression(),this.semicolon()),this.finishNode(node,"ReturnStatement")},pp$8.parseSwitchStatement=function(node){var cur;this.next(),node.discriminant=this.parseParenExpression(),node.cases=[],this.expect(types$1.braceL),this.labels.push(switchLabel),this.enterScope(0);for(var sawDefault=false;this.type!==types$1.braceR;)if(this.type===types$1._case||this.type===types$1._default){var isCase=this.type===types$1._case;cur&&this.finishNode(cur,"SwitchCase"),node.cases.push(cur=this.startNode()),cur.consequent=[],this.next(),isCase?cur.test=this.parseExpression():(sawDefault&&this.raiseRecoverable(this.lastTokStart,"Multiple default clauses"),sawDefault=true,cur.test=null),this.expect(types$1.colon);}else cur||this.unexpected(),cur.consequent.push(this.parseStatement(null));return this.exitScope(),cur&&this.finishNode(cur,"SwitchCase"),this.next(),this.labels.pop(),this.finishNode(node,"SwitchStatement")},pp$8.parseThrowStatement=function(node){return this.next(),lineBreak.test(this.input.slice(this.lastTokEnd,this.start))&&this.raise(this.lastTokEnd,"Illegal newline after throw"),node.argument=this.parseExpression(),this.semicolon(),this.finishNode(node,"ThrowStatement")};var empty$1=[];pp$8.parseCatchClauseParam=function(){var param=this.parseBindingAtom(),simple="Identifier"===param.type;return this.enterScope(simple?32:0),this.checkLValPattern(param,simple?4:2),this.expect(types$1.parenR),param},pp$8.parseTryStatement=function(node){if(this.next(),node.block=this.parseBlock(),node.handler=null,this.type===types$1._catch){var clause=this.startNode();this.next(),this.eat(types$1.parenL)?clause.param=this.parseCatchClauseParam():(this.options.ecmaVersion<10&&this.unexpected(),clause.param=null,this.enterScope(0)),clause.body=this.parseBlock(false),this.exitScope(),node.handler=this.finishNode(clause,"CatchClause");}return node.finalizer=this.eat(types$1._finally)?this.parseBlock():null,node.handler||node.finalizer||this.raise(node.start,"Missing catch or finally clause"),this.finishNode(node,"TryStatement")},pp$8.parseVarStatement=function(node,kind,allowMissingInitializer){return this.next(),this.parseVar(node,false,kind,allowMissingInitializer),this.semicolon(),this.finishNode(node,"VariableDeclaration")},pp$8.parseWhileStatement=function(node){return this.next(),node.test=this.parseParenExpression(),this.labels.push(loopLabel),node.body=this.parseStatement("while"),this.labels.pop(),this.finishNode(node,"WhileStatement")},pp$8.parseWithStatement=function(node){return this.strict&&this.raise(this.start,"'with' in strict mode"),this.next(),node.object=this.parseParenExpression(),node.body=this.parseStatement("with"),this.finishNode(node,"WithStatement")},pp$8.parseEmptyStatement=function(node){return this.next(),this.finishNode(node,"EmptyStatement")},pp$8.parseLabeledStatement=function(node,maybeName,expr,context){for(var i$1=0,list=this.labels;i$1<list.length;i$1+=1){list[i$1].name===maybeName&&this.raise(expr.start,"Label '"+maybeName+"' is already declared");}for(var kind=this.type.isLoop?"loop":this.type===types$1._switch?"switch":null,i=this.labels.length-1;i>=0;i--){var label$1=this.labels[i];if(label$1.statementStart!==node.start)break;label$1.statementStart=this.start,label$1.kind=kind;}return this.labels.push({name:maybeName,kind,statementStart:this.start}),node.body=this.parseStatement(context?-1===context.indexOf("label")?context+"label":context:"label"),this.labels.pop(),node.label=expr,this.finishNode(node,"LabeledStatement")},pp$8.parseExpressionStatement=function(node,expr){return node.expression=expr,this.semicolon(),this.finishNode(node,"ExpressionStatement")},pp$8.parseBlock=function(createNewLexicalScope,node,exitStrict){for(void 0===createNewLexicalScope&&(createNewLexicalScope=true),void 0===node&&(node=this.startNode()),node.body=[],this.expect(types$1.braceL),createNewLexicalScope&&this.enterScope(0);this.type!==types$1.braceR;){var stmt=this.parseStatement(null);node.body.push(stmt);}return exitStrict&&(this.strict=false),this.next(),createNewLexicalScope&&this.exitScope(),this.finishNode(node,"BlockStatement")},pp$8.parseFor=function(node,init){return node.init=init,this.expect(types$1.semi),node.test=this.type===types$1.semi?null:this.parseExpression(),this.expect(types$1.semi),node.update=this.type===types$1.parenR?null:this.parseExpression(),this.expect(types$1.parenR),node.body=this.parseStatement("for"),this.exitScope(),this.labels.pop(),this.finishNode(node,"ForStatement")},pp$8.parseForIn=function(node,init){var isForIn=this.type===types$1._in;return this.next(),"VariableDeclaration"===init.type&&null!=init.declarations[0].init&&(!isForIn||this.options.ecmaVersion<8||this.strict||"var"!==init.kind||"Identifier"!==init.declarations[0].id.type)&&this.raise(init.start,(isForIn?"for-in":"for-of")+" loop variable declaration may not have an initializer"),node.left=init,node.right=isForIn?this.parseExpression():this.parseMaybeAssign(),this.expect(types$1.parenR),node.body=this.parseStatement("for"),this.exitScope(),this.labels.pop(),this.finishNode(node,isForIn?"ForInStatement":"ForOfStatement")},pp$8.parseVar=function(node,isFor,kind,allowMissingInitializer){for(node.declarations=[],node.kind=kind;;){var decl=this.startNode();if(this.parseVarId(decl,kind),this.eat(types$1.eq)?decl.init=this.parseMaybeAssign(isFor):allowMissingInitializer||"const"!==kind||this.type===types$1._in||this.options.ecmaVersion>=6&&this.isContextual("of")?allowMissingInitializer||"Identifier"===decl.id.type||isFor&&(this.type===types$1._in||this.isContextual("of"))?decl.init=null:this.raise(this.lastTokEnd,"Complex binding patterns require an initialization value"):this.unexpected(),node.declarations.push(this.finishNode(decl,"VariableDeclarator")),!this.eat(types$1.comma))break}return node},pp$8.parseVarId=function(decl,kind){decl.id=this.parseBindingAtom(),this.checkLValPattern(decl.id,"var"===kind?1:2,false);};var FUNC_STATEMENT=1,FUNC_HANGING_STATEMENT=2;function isPrivateNameConflicted(privateNameMap,element){var name=element.key.name,curr=privateNameMap[name],next="true";return "MethodDefinition"!==element.type||"get"!==element.kind&&"set"!==element.kind||(next=(element.static?"s":"i")+element.kind),"iget"===curr&&"iset"===next||"iset"===curr&&"iget"===next||"sget"===curr&&"sset"===next||"sset"===curr&&"sget"===next?(privateNameMap[name]="true",false):!!curr||(privateNameMap[name]=next,false)}function checkKeyName(node,name){var computed=node.computed,key=node.key;return !computed&&("Identifier"===key.type&&key.name===name||"Literal"===key.type&&key.value===name)}pp$8.parseFunction=function(node,statement,allowExpressionBody,isAsync,forInit){this.initFunction(node),(this.options.ecmaVersion>=9||this.options.ecmaVersion>=6&&!isAsync)&&(this.type===types$1.star&&statement&FUNC_HANGING_STATEMENT&&this.unexpected(),node.generator=this.eat(types$1.star)),this.options.ecmaVersion>=8&&(node.async=!!isAsync),statement&FUNC_STATEMENT&&(node.id=4&statement&&this.type!==types$1.name?null:this.parseIdent(),!node.id||statement&FUNC_HANGING_STATEMENT||this.checkLValSimple(node.id,this.strict||node.generator||node.async?this.treatFunctionsAsVar?1:2:3));var oldYieldPos=this.yieldPos,oldAwaitPos=this.awaitPos,oldAwaitIdentPos=this.awaitIdentPos;return this.yieldPos=0,this.awaitPos=0,this.awaitIdentPos=0,this.enterScope(functionFlags(node.async,node.generator)),statement&FUNC_STATEMENT||(node.id=this.type===types$1.name?this.parseIdent():null),this.parseFunctionParams(node),this.parseFunctionBody(node,allowExpressionBody,false,forInit),this.yieldPos=oldYieldPos,this.awaitPos=oldAwaitPos,this.awaitIdentPos=oldAwaitIdentPos,this.finishNode(node,statement&FUNC_STATEMENT?"FunctionDeclaration":"FunctionExpression")},pp$8.parseFunctionParams=function(node){this.expect(types$1.parenL),node.params=this.parseBindingList(types$1.parenR,false,this.options.ecmaVersion>=8),this.checkYieldAwaitInDefaultParams();},pp$8.parseClass=function(node,isStatement){this.next();var oldStrict=this.strict;this.strict=true,this.parseClassId(node,isStatement),this.parseClassSuper(node);var privateNameMap=this.enterClassBody(),classBody=this.startNode(),hadConstructor=false;for(classBody.body=[],this.expect(types$1.braceL);this.type!==types$1.braceR;){var element=this.parseClassElement(null!==node.superClass);element&&(classBody.body.push(element),"MethodDefinition"===element.type&&"constructor"===element.kind?(hadConstructor&&this.raiseRecoverable(element.start,"Duplicate constructor in the same class"),hadConstructor=true):element.key&&"PrivateIdentifier"===element.key.type&&isPrivateNameConflicted(privateNameMap,element)&&this.raiseRecoverable(element.key.start,"Identifier '#"+element.key.name+"' has already been declared"));}return this.strict=oldStrict,this.next(),node.body=this.finishNode(classBody,"ClassBody"),this.exitClassBody(),this.finishNode(node,isStatement?"ClassDeclaration":"ClassExpression")},pp$8.parseClassElement=function(constructorAllowsSuper){if(this.eat(types$1.semi))return null;var ecmaVersion=this.options.ecmaVersion,node=this.startNode(),keyName="",isGenerator=false,isAsync=false,kind="method",isStatic=false;if(this.eatContextual("static")){if(ecmaVersion>=13&&this.eat(types$1.braceL))return this.parseClassStaticBlock(node),node;this.isClassElementNameStart()||this.type===types$1.star?isStatic=true:keyName="static";}if(node.static=isStatic,!keyName&&ecmaVersion>=8&&this.eatContextual("async")&&(!this.isClassElementNameStart()&&this.type!==types$1.star||this.canInsertSemicolon()?keyName="async":isAsync=true),!keyName&&(ecmaVersion>=9||!isAsync)&&this.eat(types$1.star)&&(isGenerator=true),!keyName&&!isAsync&&!isGenerator){var lastValue=this.value;(this.eatContextual("get")||this.eatContextual("set"))&&(this.isClassElementNameStart()?kind=lastValue:keyName=lastValue);}if(keyName?(node.computed=false,node.key=this.startNodeAt(this.lastTokStart,this.lastTokStartLoc),node.key.name=keyName,this.finishNode(node.key,"Identifier")):this.parseClassElementName(node),ecmaVersion<13||this.type===types$1.parenL||"method"!==kind||isGenerator||isAsync){var isConstructor=!node.static&&checkKeyName(node,"constructor"),allowsDirectSuper=isConstructor&&constructorAllowsSuper;isConstructor&&"method"!==kind&&this.raise(node.key.start,"Constructor can't have get/set modifier"),node.kind=isConstructor?"constructor":kind,this.parseClassMethod(node,isGenerator,isAsync,allowsDirectSuper);}else this.parseClassField(node);return node},pp$8.isClassElementNameStart=function(){return this.type===types$1.name||this.type===types$1.privateId||this.type===types$1.num||this.type===types$1.string||this.type===types$1.bracketL||this.type.keyword},pp$8.parseClassElementName=function(element){this.type===types$1.privateId?("constructor"===this.value&&this.raise(this.start,"Classes can't have an element named '#constructor'"),element.computed=false,element.key=this.parsePrivateIdent()):this.parsePropertyName(element);},pp$8.parseClassMethod=function(method,isGenerator,isAsync,allowsDirectSuper){var key=method.key;"constructor"===method.kind?(isGenerator&&this.raise(key.start,"Constructor can't be a generator"),isAsync&&this.raise(key.start,"Constructor can't be an async method")):method.static&&checkKeyName(method,"prototype")&&this.raise(key.start,"Classes may not have a static property named prototype");var value=method.value=this.parseMethod(isGenerator,isAsync,allowsDirectSuper);return "get"===method.kind&&0!==value.params.length&&this.raiseRecoverable(value.start,"getter should have no params"),"set"===method.kind&&1!==value.params.length&&this.raiseRecoverable(value.start,"setter should have exactly one param"),"set"===method.kind&&"RestElement"===value.params[0].type&&this.raiseRecoverable(value.params[0].start,"Setter cannot use rest params"),this.finishNode(method,"MethodDefinition")},pp$8.parseClassField=function(field){if(checkKeyName(field,"constructor")?this.raise(field.key.start,"Classes can't have a field named 'constructor'"):field.static&&checkKeyName(field,"prototype")&&this.raise(field.key.start,"Classes can't have a static field named 'prototype'"),this.eat(types$1.eq)){var scope=this.currentThisScope(),inClassFieldInit=scope.inClassFieldInit;scope.inClassFieldInit=true,field.value=this.parseMaybeAssign(),scope.inClassFieldInit=inClassFieldInit;}else field.value=null;return this.semicolon(),this.finishNode(field,"PropertyDefinition")},pp$8.parseClassStaticBlock=function(node){node.body=[];var oldLabels=this.labels;for(this.labels=[],this.enterScope(320);this.type!==types$1.braceR;){var stmt=this.parseStatement(null);node.body.push(stmt);}return this.next(),this.exitScope(),this.labels=oldLabels,this.finishNode(node,"StaticBlock")},pp$8.parseClassId=function(node,isStatement){this.type===types$1.name?(node.id=this.parseIdent(),isStatement&&this.checkLValSimple(node.id,2,false)):(true===isStatement&&this.unexpected(),node.id=null);},pp$8.parseClassSuper=function(node){node.superClass=this.eat(types$1._extends)?this.parseExprSubscripts(null,false):null;},pp$8.enterClassBody=function(){var element={declared:Object.create(null),used:[]};return this.privateNameStack.push(element),element.declared},pp$8.exitClassBody=function(){var ref=this.privateNameStack.pop(),declared=ref.declared,used=ref.used;if(this.options.checkPrivateFields)for(var len=this.privateNameStack.length,parent=0===len?null:this.privateNameStack[len-1],i=0;i<used.length;++i){var id=used[i];hasOwn(declared,id.name)||(parent?parent.used.push(id):this.raiseRecoverable(id.start,"Private field '#"+id.name+"' must be declared in an enclosing class"));}},pp$8.parseExportAllDeclaration=function(node,exports){return this.options.ecmaVersion>=11&&(this.eatContextual("as")?(node.exported=this.parseModuleExportName(),this.checkExport(exports,node.exported,this.lastTokStart)):node.exported=null),this.expectContextual("from"),this.type!==types$1.string&&this.unexpected(),node.source=this.parseExprAtom(),this.options.ecmaVersion>=16&&(node.attributes=this.parseWithClause()),this.semicolon(),this.finishNode(node,"ExportAllDeclaration")},pp$8.parseExport=function(node,exports){if(this.next(),this.eat(types$1.star))return this.parseExportAllDeclaration(node,exports);if(this.eat(types$1._default))return this.checkExport(exports,"default",this.lastTokStart),node.declaration=this.parseExportDefaultDeclaration(),this.finishNode(node,"ExportDefaultDeclaration");if(this.shouldParseExportStatement())node.declaration=this.parseExportDeclaration(node),"VariableDeclaration"===node.declaration.type?this.checkVariableExport(exports,node.declaration.declarations):this.checkExport(exports,node.declaration.id,node.declaration.id.start),node.specifiers=[],node.source=null;else {if(node.declaration=null,node.specifiers=this.parseExportSpecifiers(exports),this.eatContextual("from"))this.type!==types$1.string&&this.unexpected(),node.source=this.parseExprAtom(),this.options.ecmaVersion>=16&&(node.attributes=this.parseWithClause());else {for(var i=0,list=node.specifiers;i<list.length;i+=1){var spec=list[i];this.checkUnreserved(spec.local),this.checkLocalExport(spec.local),"Literal"===spec.local.type&&this.raise(spec.local.start,"A string literal cannot be used as an exported binding without `from`.");}node.source=null;}this.semicolon();}return this.finishNode(node,"ExportNamedDeclaration")},pp$8.parseExportDeclaration=function(node){return this.parseStatement(null)},pp$8.parseExportDefaultDeclaration=function(){var isAsync;if(this.type===types$1._function||(isAsync=this.isAsyncFunction())){var fNode=this.startNode();return this.next(),isAsync&&this.next(),this.parseFunction(fNode,4|FUNC_STATEMENT,false,isAsync)}if(this.type===types$1._class){var cNode=this.startNode();return this.parseClass(cNode,"nullableID")}var declaration=this.parseMaybeAssign();return this.semicolon(),declaration},pp$8.checkExport=function(exports,name,pos){exports&&("string"!=typeof name&&(name="Identifier"===name.type?name.name:name.value),hasOwn(exports,name)&&this.raiseRecoverable(pos,"Duplicate export '"+name+"'"),exports[name]=true);},pp$8.checkPatternExport=function(exports,pat){var type=pat.type;if("Identifier"===type)this.checkExport(exports,pat,pat.start);else if("ObjectPattern"===type)for(var i=0,list=pat.properties;i<list.length;i+=1){var prop=list[i];this.checkPatternExport(exports,prop);}else if("ArrayPattern"===type)for(var i$1=0,list$1=pat.elements;i$1<list$1.length;i$1+=1){var elt=list$1[i$1];elt&&this.checkPatternExport(exports,elt);}else "Property"===type?this.checkPatternExport(exports,pat.value):"AssignmentPattern"===type?this.checkPatternExport(exports,pat.left):"RestElement"===type&&this.checkPatternExport(exports,pat.argument);},pp$8.checkVariableExport=function(exports,decls){if(exports)for(var i=0,list=decls;i<list.length;i+=1){var decl=list[i];this.checkPatternExport(exports,decl.id);}},pp$8.shouldParseExportStatement=function(){return "var"===this.type.keyword||"const"===this.type.keyword||"class"===this.type.keyword||"function"===this.type.keyword||this.isLet()||this.isAsyncFunction()},pp$8.parseExportSpecifier=function(exports){var node=this.startNode();return node.local=this.parseModuleExportName(),node.exported=this.eatContextual("as")?this.parseModuleExportName():node.local,this.checkExport(exports,node.exported,node.exported.start),this.finishNode(node,"ExportSpecifier")},pp$8.parseExportSpecifiers=function(exports){var nodes=[],first=true;for(this.expect(types$1.braceL);!this.eat(types$1.braceR);){if(first)first=false;else if(this.expect(types$1.comma),this.afterTrailingComma(types$1.braceR))break;nodes.push(this.parseExportSpecifier(exports));}return nodes},pp$8.parseImport=function(node){return this.next(),this.type===types$1.string?(node.specifiers=empty$1,node.source=this.parseExprAtom()):(node.specifiers=this.parseImportSpecifiers(),this.expectContextual("from"),node.source=this.type===types$1.string?this.parseExprAtom():this.unexpected()),this.options.ecmaVersion>=16&&(node.attributes=this.parseWithClause()),this.semicolon(),this.finishNode(node,"ImportDeclaration")},pp$8.parseImportSpecifier=function(){var node=this.startNode();return node.imported=this.parseModuleExportName(),this.eatContextual("as")?node.local=this.parseIdent():(this.checkUnreserved(node.imported),node.local=node.imported),this.checkLValSimple(node.local,2),this.finishNode(node,"ImportSpecifier")},pp$8.parseImportDefaultSpecifier=function(){var node=this.startNode();return node.local=this.parseIdent(),this.checkLValSimple(node.local,2),this.finishNode(node,"ImportDefaultSpecifier")},pp$8.parseImportNamespaceSpecifier=function(){var node=this.startNode();return this.next(),this.expectContextual("as"),node.local=this.parseIdent(),this.checkLValSimple(node.local,2),this.finishNode(node,"ImportNamespaceSpecifier")},pp$8.parseImportSpecifiers=function(){var nodes=[],first=true;if(this.type===types$1.name&&(nodes.push(this.parseImportDefaultSpecifier()),!this.eat(types$1.comma)))return nodes;if(this.type===types$1.star)return nodes.push(this.parseImportNamespaceSpecifier()),nodes;for(this.expect(types$1.braceL);!this.eat(types$1.braceR);){if(first)first=false;else if(this.expect(types$1.comma),this.afterTrailingComma(types$1.braceR))break;nodes.push(this.parseImportSpecifier());}return nodes},pp$8.parseWithClause=function(){var nodes=[];if(!this.eat(types$1._with))return nodes;this.expect(types$1.braceL);for(var attributeKeys={},first=true;!this.eat(types$1.braceR);){if(first)first=false;else if(this.expect(types$1.comma),this.afterTrailingComma(types$1.braceR))break;var attr=this.parseImportAttribute(),keyName="Identifier"===attr.key.type?attr.key.name:attr.key.value;hasOwn(attributeKeys,keyName)&&this.raiseRecoverable(attr.key.start,"Duplicate attribute key '"+keyName+"'"),attributeKeys[keyName]=true,nodes.push(attr);}return nodes},pp$8.parseImportAttribute=function(){var node=this.startNode();return node.key=this.type===types$1.string?this.parseExprAtom():this.parseIdent("never"!==this.options.allowReserved),this.expect(types$1.colon),this.type!==types$1.string&&this.unexpected(),node.value=this.parseExprAtom(),this.finishNode(node,"ImportAttribute")},pp$8.parseModuleExportName=function(){if(this.options.ecmaVersion>=13&&this.type===types$1.string){var stringLiteral=this.parseLiteral(this.value);return loneSurrogate.test(stringLiteral.value)&&this.raise(stringLiteral.start,"An export name cannot include a lone surrogate."),stringLiteral}return this.parseIdent(true)},pp$8.adaptDirectivePrologue=function(statements){for(var i=0;i<statements.length&&this.isDirectiveCandidate(statements[i]);++i)statements[i].directive=statements[i].expression.raw.slice(1,-1);},pp$8.isDirectiveCandidate=function(statement){return this.options.ecmaVersion>=5&&"ExpressionStatement"===statement.type&&"Literal"===statement.expression.type&&"string"==typeof statement.expression.value&&('"'===this.input[statement.start]||"'"===this.input[statement.start])};var pp$7=Parser.prototype;pp$7.toAssignable=function(node,isBinding,refDestructuringErrors){if(this.options.ecmaVersion>=6&&node)switch(node.type){case "Identifier":this.inAsync&&"await"===node.name&&this.raise(node.start,"Cannot use 'await' as identifier inside an async function");break;case "ObjectPattern":case "ArrayPattern":case "AssignmentPattern":case "RestElement":break;case "ObjectExpression":node.type="ObjectPattern",refDestructuringErrors&&this.checkPatternErrors(refDestructuringErrors,true);for(var i=0,list=node.properties;i<list.length;i+=1){var prop=list[i];this.toAssignable(prop,isBinding),"RestElement"!==prop.type||"ArrayPattern"!==prop.argument.type&&"ObjectPattern"!==prop.argument.type||this.raise(prop.argument.start,"Unexpected token");}break;case "Property":"init"!==node.kind&&this.raise(node.key.start,"Object pattern can't contain getter or setter"),this.toAssignable(node.value,isBinding);break;case "ArrayExpression":node.type="ArrayPattern",refDestructuringErrors&&this.checkPatternErrors(refDestructuringErrors,true),this.toAssignableList(node.elements,isBinding);break;case "SpreadElement":node.type="RestElement",this.toAssignable(node.argument,isBinding),"AssignmentPattern"===node.argument.type&&this.raise(node.argument.start,"Rest elements cannot have a default value");break;case "AssignmentExpression":"="!==node.operator&&this.raise(node.left.end,"Only '=' operator can be used for specifying default value."),node.type="AssignmentPattern",delete node.operator,this.toAssignable(node.left,isBinding);break;case "ParenthesizedExpression":this.toAssignable(node.expression,isBinding,refDestructuringErrors);break;case "ChainExpression":this.raiseRecoverable(node.start,"Optional chaining cannot appear in left-hand side");break;case "MemberExpression":if(!isBinding)break;default:this.raise(node.start,"Assigning to rvalue");}else refDestructuringErrors&&this.checkPatternErrors(refDestructuringErrors,true);return node},pp$7.toAssignableList=function(exprList,isBinding){for(var end=exprList.length,i=0;i<end;i++){var elt=exprList[i];elt&&this.toAssignable(elt,isBinding);}if(end){var last=exprList[end-1];6===this.options.ecmaVersion&&isBinding&&last&&"RestElement"===last.type&&"Identifier"!==last.argument.type&&this.unexpected(last.argument.start);}return exprList},pp$7.parseSpread=function(refDestructuringErrors){var node=this.startNode();return this.next(),node.argument=this.parseMaybeAssign(false,refDestructuringErrors),this.finishNode(node,"SpreadElement")},pp$7.parseRestBinding=function(){var node=this.startNode();return this.next(),6===this.options.ecmaVersion&&this.type!==types$1.name&&this.unexpected(),node.argument=this.parseBindingAtom(),this.finishNode(node,"RestElement")},pp$7.parseBindingAtom=function(){if(this.options.ecmaVersion>=6)switch(this.type){case types$1.bracketL:var node=this.startNode();return this.next(),node.elements=this.parseBindingList(types$1.bracketR,true,true),this.finishNode(node,"ArrayPattern");case types$1.braceL:return this.parseObj(true)}return this.parseIdent()},pp$7.parseBindingList=function(close,allowEmpty,allowTrailingComma,allowModifiers){for(var elts=[],first=true;!this.eat(close);)if(first?first=false:this.expect(types$1.comma),allowEmpty&&this.type===types$1.comma)elts.push(null);else {if(allowTrailingComma&&this.afterTrailingComma(close))break;if(this.type===types$1.ellipsis){var rest=this.parseRestBinding();this.parseBindingListItem(rest),elts.push(rest),this.type===types$1.comma&&this.raiseRecoverable(this.start,"Comma is not permitted after the rest element"),this.expect(close);break}elts.push(this.parseAssignableListItem(allowModifiers));}return elts},pp$7.parseAssignableListItem=function(allowModifiers){var elem=this.parseMaybeDefault(this.start,this.startLoc);return this.parseBindingListItem(elem),elem},pp$7.parseBindingListItem=function(param){return param},pp$7.parseMaybeDefault=function(startPos,startLoc,left){if(left=left||this.parseBindingAtom(),this.options.ecmaVersion<6||!this.eat(types$1.eq))return left;var node=this.startNodeAt(startPos,startLoc);return node.left=left,node.right=this.parseMaybeAssign(),this.finishNode(node,"AssignmentPattern")},pp$7.checkLValSimple=function(expr,bindingType,checkClashes){ void 0===bindingType&&(bindingType=0);var isBind=0!==bindingType;switch(expr.type){case "Identifier":this.strict&&this.reservedWordsStrictBind.test(expr.name)&&this.raiseRecoverable(expr.start,(isBind?"Binding ":"Assigning to ")+expr.name+" in strict mode"),isBind&&(2===bindingType&&"let"===expr.name&&this.raiseRecoverable(expr.start,"let is disallowed as a lexically bound name"),checkClashes&&(hasOwn(checkClashes,expr.name)&&this.raiseRecoverable(expr.start,"Argument name clash"),checkClashes[expr.name]=true),5!==bindingType&&this.declareName(expr.name,bindingType,expr.start));break;case "ChainExpression":this.raiseRecoverable(expr.start,"Optional chaining cannot appear in left-hand side");break;case "MemberExpression":isBind&&this.raiseRecoverable(expr.start,"Binding member expression");break;case "ParenthesizedExpression":return isBind&&this.raiseRecoverable(expr.start,"Binding parenthesized expression"),this.checkLValSimple(expr.expression,bindingType,checkClashes);default:this.raise(expr.start,(isBind?"Binding":"Assigning to")+" rvalue");}},pp$7.checkLValPattern=function(expr,bindingType,checkClashes){switch(void 0===bindingType&&(bindingType=0),expr.type){case "ObjectPattern":for(var i=0,list=expr.properties;i<list.length;i+=1){var prop=list[i];this.checkLValInnerPattern(prop,bindingType,checkClashes);}break;case "ArrayPattern":for(var i$1=0,list$1=expr.elements;i$1<list$1.length;i$1+=1){var elem=list$1[i$1];elem&&this.checkLValInnerPattern(elem,bindingType,checkClashes);}break;default:this.checkLValSimple(expr,bindingType,checkClashes);}},pp$7.checkLValInnerPattern=function(expr,bindingType,checkClashes){switch(void 0===bindingType&&(bindingType=0),expr.type){case "Property":this.checkLValInnerPattern(expr.value,bindingType,checkClashes);break;case "AssignmentPattern":this.checkLValPattern(expr.left,bindingType,checkClashes);break;case "RestElement":this.checkLValPattern(expr.argument,bindingType,checkClashes);break;default:this.checkLValPattern(expr,bindingType,checkClashes);}};var TokContext=function(token,isExpr,preserveSpace,override,generator){this.token=token,this.isExpr=!!isExpr,this.preserveSpace=!!preserveSpace,this.override=override,this.generator=!!generator;},types={b_stat:new TokContext("{",false),b_expr:new TokContext("{",true),b_tmpl:new TokContext("${",false),p_stat:new TokContext("(",false),p_expr:new TokContext("(",true),q_tmpl:new TokContext("`",true,true,(function(p){return p.tryReadTemplateToken()})),f_stat:new TokContext("function",false),f_expr:new TokContext("function",true),f_expr_gen:new TokContext("function",true,false,null,true),f_gen:new TokContext("function",false,false,null,true)},pp$6=Parser.prototype;pp$6.initialContext=function(){return [types.b_stat]},pp$6.curContext=function(){return this.context[this.context.length-1]},pp$6.braceIsBlock=function(prevType){var parent=this.curContext();return parent===types.f_expr||parent===types.f_stat||(prevType!==types$1.colon||parent!==types.b_stat&&parent!==types.b_expr?prevType===types$1._return||prevType===types$1.name&&this.exprAllowed?lineBreak.test(this.input.slice(this.lastTokEnd,this.start)):prevType===types$1._else||prevType===types$1.semi||prevType===types$1.eof||prevType===types$1.parenR||prevType===types$1.arrow||(prevType===types$1.braceL?parent===types.b_stat:prevType!==types$1._var&&prevType!==types$1._const&&prevType!==types$1.name&&!this.exprAllowed):!parent.isExpr)},pp$6.inGeneratorContext=function(){for(var i=this.context.length-1;i>=1;i--){var context=this.context[i];if("function"===context.token)return context.generator}return  false},pp$6.updateContext=function(prevType){var update,type=this.type;type.keyword&&prevType===types$1.dot?this.exprAllowed=false:(update=type.updateContext)?update.call(this,prevType):this.exprAllowed=type.beforeExpr;},pp$6.overrideContext=function(tokenCtx){this.curContext()!==tokenCtx&&(this.context[this.context.length-1]=tokenCtx);},types$1.parenR.updateContext=types$1.braceR.updateContext=function(){if(1!==this.context.length){var out=this.context.pop();out===types.b_stat&&"function"===this.curContext().token&&(out=this.context.pop()),this.exprAllowed=!out.isExpr;}else this.exprAllowed=true;},types$1.braceL.updateContext=function(prevType){this.context.push(this.braceIsBlock(prevType)?types.b_stat:types.b_expr),this.exprAllowed=true;},types$1.dollarBraceL.updateContext=function(){this.context.push(types.b_tmpl),this.exprAllowed=true;},types$1.parenL.updateContext=function(prevType){var statementParens=prevType===types$1._if||prevType===types$1._for||prevType===types$1._with||prevType===types$1._while;this.context.push(statementParens?types.p_stat:types.p_expr),this.exprAllowed=true;},types$1.incDec.updateContext=function(){},types$1._function.updateContext=types$1._class.updateContext=function(prevType){!prevType.beforeExpr||prevType===types$1._else||prevType===types$1.semi&&this.curContext()!==types.p_stat||prevType===types$1._return&&lineBreak.test(this.input.slice(this.lastTokEnd,this.start))||(prevType===types$1.colon||prevType===types$1.braceL)&&this.curContext()===types.b_stat?this.context.push(types.f_stat):this.context.push(types.f_expr),this.exprAllowed=false;},types$1.colon.updateContext=function(){"function"===this.curContext().token&&this.context.pop(),this.exprAllowed=true;},types$1.backQuote.updateContext=function(){this.curContext()===types.q_tmpl?this.context.pop():this.context.push(types.q_tmpl),this.exprAllowed=false;},types$1.star.updateContext=function(prevType){if(prevType===types$1._function){var index=this.context.length-1;this.context[index]===types.f_expr?this.context[index]=types.f_expr_gen:this.context[index]=types.f_gen;}this.exprAllowed=true;},types$1.name.updateContext=function(prevType){var allowed=false;this.options.ecmaVersion>=6&&prevType!==types$1.dot&&("of"===this.value&&!this.exprAllowed||"yield"===this.value&&this.inGeneratorContext())&&(allowed=true),this.exprAllowed=allowed;};var pp$5=Parser.prototype;function isLocalVariableAccess(node){return "Identifier"===node.type||"ParenthesizedExpression"===node.type&&isLocalVariableAccess(node.expression)}function isPrivateFieldAccess(node){return "MemberExpression"===node.type&&"PrivateIdentifier"===node.property.type||"ChainExpression"===node.type&&isPrivateFieldAccess(node.expression)||"ParenthesizedExpression"===node.type&&isPrivateFieldAccess(node.expression)}pp$5.checkPropClash=function(prop,propHash,refDestructuringErrors){if(!(this.options.ecmaVersion>=9&&"SpreadElement"===prop.type||this.options.ecmaVersion>=6&&(prop.computed||prop.method||prop.shorthand))){var name,key=prop.key;switch(key.type){case "Identifier":name=key.name;break;case "Literal":name=String(key.value);break;default:return}var kind=prop.kind;if(this.options.ecmaVersion>=6)"__proto__"===name&&"init"===kind&&(propHash.proto&&(refDestructuringErrors?refDestructuringErrors.doubleProto<0&&(refDestructuringErrors.doubleProto=key.start):this.raiseRecoverable(key.start,"Redefinition of __proto__ property")),propHash.proto=true);else {var other=propHash[name="$"+name];if(other)("init"===kind?this.strict&&other.init||other.get||other.set:other.init||other[kind])&&this.raiseRecoverable(key.start,"Redefinition of property");else other=propHash[name]={init:false,get:false,set:false};other[kind]=true;}}},pp$5.parseExpression=function(forInit,refDestructuringErrors){var startPos=this.start,startLoc=this.startLoc,expr=this.parseMaybeAssign(forInit,refDestructuringErrors);if(this.type===types$1.comma){var node=this.startNodeAt(startPos,startLoc);for(node.expressions=[expr];this.eat(types$1.comma);)node.expressions.push(this.parseMaybeAssign(forInit,refDestructuringErrors));return this.finishNode(node,"SequenceExpression")}return expr},pp$5.parseMaybeAssign=function(forInit,refDestructuringErrors,afterLeftParse){if(this.isContextual("yield")){if(this.inGenerator)return this.parseYield(forInit);this.exprAllowed=false;}var ownDestructuringErrors=false,oldParenAssign=-1,oldTrailingComma=-1,oldDoubleProto=-1;refDestructuringErrors?(oldParenAssign=refDestructuringErrors.parenthesizedAssign,oldTrailingComma=refDestructuringErrors.trailingComma,oldDoubleProto=refDestructuringErrors.doubleProto,refDestructuringErrors.parenthesizedAssign=refDestructuringErrors.trailingComma=-1):(refDestructuringErrors=new DestructuringErrors,ownDestructuringErrors=true);var startPos=this.start,startLoc=this.startLoc;this.type!==types$1.parenL&&this.type!==types$1.name||(this.potentialArrowAt=this.start,this.potentialArrowInForAwait="await"===forInit);var left=this.parseMaybeConditional(forInit,refDestructuringErrors);if(afterLeftParse&&(left=afterLeftParse.call(this,left,startPos,startLoc)),this.type.isAssign){var node=this.startNodeAt(startPos,startLoc);return node.operator=this.value,this.type===types$1.eq&&(left=this.toAssignable(left,false,refDestructuringErrors)),ownDestructuringErrors||(refDestructuringErrors.parenthesizedAssign=refDestructuringErrors.trailingComma=refDestructuringErrors.doubleProto=-1),refDestructuringErrors.shorthandAssign>=left.start&&(refDestructuringErrors.shorthandAssign=-1),this.type===types$1.eq?this.checkLValPattern(left):this.checkLValSimple(left),node.left=left,this.next(),node.right=this.parseMaybeAssign(forInit),oldDoubleProto>-1&&(refDestructuringErrors.doubleProto=oldDoubleProto),this.finishNode(node,"AssignmentExpression")}return ownDestructuringErrors&&this.checkExpressionErrors(refDestructuringErrors,true),oldParenAssign>-1&&(refDestructuringErrors.parenthesizedAssign=oldParenAssign),oldTrailingComma>-1&&(refDestructuringErrors.trailingComma=oldTrailingComma),left},pp$5.parseMaybeConditional=function(forInit,refDestructuringErrors){var startPos=this.start,startLoc=this.startLoc,expr=this.parseExprOps(forInit,refDestructuringErrors);if(this.checkExpressionErrors(refDestructuringErrors))return expr;if(this.eat(types$1.question)){var node=this.startNodeAt(startPos,startLoc);return node.test=expr,node.consequent=this.parseMaybeAssign(),this.expect(types$1.colon),node.alternate=this.parseMaybeAssign(forInit),this.finishNode(node,"ConditionalExpression")}return expr},pp$5.parseExprOps=function(forInit,refDestructuringErrors){var startPos=this.start,startLoc=this.startLoc,expr=this.parseMaybeUnary(refDestructuringErrors,false,false,forInit);return this.checkExpressionErrors(refDestructuringErrors)||expr.start===startPos&&"ArrowFunctionExpression"===expr.type?expr:this.parseExprOp(expr,startPos,startLoc,-1,forInit)},pp$5.parseExprOp=function(left,leftStartPos,leftStartLoc,minPrec,forInit){var prec=this.type.binop;if(null!=prec&&(!forInit||this.type!==types$1._in)&&prec>minPrec){var logical=this.type===types$1.logicalOR||this.type===types$1.logicalAND,coalesce=this.type===types$1.coalesce;coalesce&&(prec=types$1.logicalAND.binop);var op=this.value;this.next();var startPos=this.start,startLoc=this.startLoc,right=this.parseExprOp(this.parseMaybeUnary(null,false,false,forInit),startPos,startLoc,prec,forInit),node=this.buildBinary(leftStartPos,leftStartLoc,left,right,op,logical||coalesce);return (logical&&this.type===types$1.coalesce||coalesce&&(this.type===types$1.logicalOR||this.type===types$1.logicalAND))&&this.raiseRecoverable(this.start,"Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses"),this.parseExprOp(node,leftStartPos,leftStartLoc,minPrec,forInit)}return left},pp$5.buildBinary=function(startPos,startLoc,left,right,op,logical){"PrivateIdentifier"===right.type&&this.raise(right.start,"Private identifier can only be left side of binary expression");var node=this.startNodeAt(startPos,startLoc);return node.left=left,node.operator=op,node.right=right,this.finishNode(node,logical?"LogicalExpression":"BinaryExpression")},pp$5.parseMaybeUnary=function(refDestructuringErrors,sawUnary,incDec,forInit){var expr,startPos=this.start,startLoc=this.startLoc;if(this.isContextual("await")&&this.canAwait)expr=this.parseAwait(forInit),sawUnary=true;else if(this.type.prefix){var node=this.startNode(),update=this.type===types$1.incDec;node.operator=this.value,node.prefix=true,this.next(),node.argument=this.parseMaybeUnary(null,true,update,forInit),this.checkExpressionErrors(refDestructuringErrors,true),update?this.checkLValSimple(node.argument):this.strict&&"delete"===node.operator&&isLocalVariableAccess(node.argument)?this.raiseRecoverable(node.start,"Deleting local variable in strict mode"):"delete"===node.operator&&isPrivateFieldAccess(node.argument)?this.raiseRecoverable(node.start,"Private fields can not be deleted"):sawUnary=true,expr=this.finishNode(node,update?"UpdateExpression":"UnaryExpression");}else if(sawUnary||this.type!==types$1.privateId){if(expr=this.parseExprSubscripts(refDestructuringErrors,forInit),this.checkExpressionErrors(refDestructuringErrors))return expr;for(;this.type.postfix&&!this.canInsertSemicolon();){var node$1=this.startNodeAt(startPos,startLoc);node$1.operator=this.value,node$1.prefix=false,node$1.argument=expr,this.checkLValSimple(expr),this.next(),expr=this.finishNode(node$1,"UpdateExpression");}}else (forInit||0===this.privateNameStack.length)&&this.options.checkPrivateFields&&this.unexpected(),expr=this.parsePrivateIdent(),this.type!==types$1._in&&this.unexpected();return incDec||!this.eat(types$1.starstar)?expr:sawUnary?void this.unexpected(this.lastTokStart):this.buildBinary(startPos,startLoc,expr,this.parseMaybeUnary(null,false,false,forInit),"**",false)},pp$5.parseExprSubscripts=function(refDestructuringErrors,forInit){var startPos=this.start,startLoc=this.startLoc,expr=this.parseExprAtom(refDestructuringErrors,forInit);if("ArrowFunctionExpression"===expr.type&&")"!==this.input.slice(this.lastTokStart,this.lastTokEnd))return expr;var result=this.parseSubscripts(expr,startPos,startLoc,false,forInit);return refDestructuringErrors&&"MemberExpression"===result.type&&(refDestructuringErrors.parenthesizedAssign>=result.start&&(refDestructuringErrors.parenthesizedAssign=-1),refDestructuringErrors.parenthesizedBind>=result.start&&(refDestructuringErrors.parenthesizedBind=-1),refDestructuringErrors.trailingComma>=result.start&&(refDestructuringErrors.trailingComma=-1)),result},pp$5.parseSubscripts=function(base,startPos,startLoc,noCalls,forInit){for(var maybeAsyncArrow=this.options.ecmaVersion>=8&&"Identifier"===base.type&&"async"===base.name&&this.lastTokEnd===base.end&&!this.canInsertSemicolon()&&base.end-base.start==5&&this.potentialArrowAt===base.start,optionalChained=false;;){var element=this.parseSubscript(base,startPos,startLoc,noCalls,maybeAsyncArrow,optionalChained,forInit);if(element.optional&&(optionalChained=true),element===base||"ArrowFunctionExpression"===element.type){if(optionalChained){var chainNode=this.startNodeAt(startPos,startLoc);chainNode.expression=element,element=this.finishNode(chainNode,"ChainExpression");}return element}base=element;}},pp$5.shouldParseAsyncArrow=function(){return !this.canInsertSemicolon()&&this.eat(types$1.arrow)},pp$5.parseSubscriptAsyncArrow=function(startPos,startLoc,exprList,forInit){return this.parseArrowExpression(this.startNodeAt(startPos,startLoc),exprList,true,forInit)},pp$5.parseSubscript=function(base,startPos,startLoc,noCalls,maybeAsyncArrow,optionalChained,forInit){var optionalSupported=this.options.ecmaVersion>=11,optional=optionalSupported&&this.eat(types$1.questionDot);noCalls&&optional&&this.raise(this.lastTokStart,"Optional chaining cannot appear in the callee of new expressions");var computed=this.eat(types$1.bracketL);if(computed||optional&&this.type!==types$1.parenL&&this.type!==types$1.backQuote||this.eat(types$1.dot)){var node=this.startNodeAt(startPos,startLoc);node.object=base,computed?(node.property=this.parseExpression(),this.expect(types$1.bracketR)):this.type===types$1.privateId&&"Super"!==base.type?node.property=this.parsePrivateIdent():node.property=this.parseIdent("never"!==this.options.allowReserved),node.computed=!!computed,optionalSupported&&(node.optional=optional),base=this.finishNode(node,"MemberExpression");}else if(!noCalls&&this.eat(types$1.parenL)){var refDestructuringErrors=new DestructuringErrors,oldYieldPos=this.yieldPos,oldAwaitPos=this.awaitPos,oldAwaitIdentPos=this.awaitIdentPos;this.yieldPos=0,this.awaitPos=0,this.awaitIdentPos=0;var exprList=this.parseExprList(types$1.parenR,this.options.ecmaVersion>=8,false,refDestructuringErrors);if(maybeAsyncArrow&&!optional&&this.shouldParseAsyncArrow())return this.checkPatternErrors(refDestructuringErrors,false),this.checkYieldAwaitInDefaultParams(),this.awaitIdentPos>0&&this.raise(this.awaitIdentPos,"Cannot use 'await' as identifier inside an async function"),this.yieldPos=oldYieldPos,this.awaitPos=oldAwaitPos,this.awaitIdentPos=oldAwaitIdentPos,this.parseSubscriptAsyncArrow(startPos,startLoc,exprList,forInit);this.checkExpressionErrors(refDestructuringErrors,true),this.yieldPos=oldYieldPos||this.yieldPos,this.awaitPos=oldAwaitPos||this.awaitPos,this.awaitIdentPos=oldAwaitIdentPos||this.awaitIdentPos;var node$1=this.startNodeAt(startPos,startLoc);node$1.callee=base,node$1.arguments=exprList,optionalSupported&&(node$1.optional=optional),base=this.finishNode(node$1,"CallExpression");}else if(this.type===types$1.backQuote){(optional||optionalChained)&&this.raise(this.start,"Optional chaining cannot appear in the tag of tagged template expressions");var node$2=this.startNodeAt(startPos,startLoc);node$2.tag=base,node$2.quasi=this.parseTemplate({isTagged:true}),base=this.finishNode(node$2,"TaggedTemplateExpression");}return base},pp$5.parseExprAtom=function(refDestructuringErrors,forInit,forNew){this.type===types$1.slash&&this.readRegexp();var node,canBeArrow=this.potentialArrowAt===this.start;switch(this.type){case types$1._super:return this.allowSuper||this.raise(this.start,"'super' keyword outside a method"),node=this.startNode(),this.next(),this.type!==types$1.parenL||this.allowDirectSuper||this.raise(node.start,"super() call outside constructor of a subclass"),this.type!==types$1.dot&&this.type!==types$1.bracketL&&this.type!==types$1.parenL&&this.unexpected(),this.finishNode(node,"Super");case types$1._this:return node=this.startNode(),this.next(),this.finishNode(node,"ThisExpression");case types$1.name:var startPos=this.start,startLoc=this.startLoc,containsEsc=this.containsEsc,id=this.parseIdent(false);if(this.options.ecmaVersion>=8&&!containsEsc&&"async"===id.name&&!this.canInsertSemicolon()&&this.eat(types$1._function))return this.overrideContext(types.f_expr),this.parseFunction(this.startNodeAt(startPos,startLoc),0,false,true,forInit);if(canBeArrow&&!this.canInsertSemicolon()){if(this.eat(types$1.arrow))return this.parseArrowExpression(this.startNodeAt(startPos,startLoc),[id],false,forInit);if(this.options.ecmaVersion>=8&&"async"===id.name&&this.type===types$1.name&&!containsEsc&&(!this.potentialArrowInForAwait||"of"!==this.value||this.containsEsc))return id=this.parseIdent(false),!this.canInsertSemicolon()&&this.eat(types$1.arrow)||this.unexpected(),this.parseArrowExpression(this.startNodeAt(startPos,startLoc),[id],true,forInit)}return id;case types$1.regexp:var value=this.value;return (node=this.parseLiteral(value.value)).regex={pattern:value.pattern,flags:value.flags},node;case types$1.num:case types$1.string:return this.parseLiteral(this.value);case types$1._null:case types$1._true:case types$1._false:return (node=this.startNode()).value=this.type===types$1._null?null:this.type===types$1._true,node.raw=this.type.keyword,this.next(),this.finishNode(node,"Literal");case types$1.parenL:var start=this.start,expr=this.parseParenAndDistinguishExpression(canBeArrow,forInit);return refDestructuringErrors&&(refDestructuringErrors.parenthesizedAssign<0&&!this.isSimpleAssignTarget(expr)&&(refDestructuringErrors.parenthesizedAssign=start),refDestructuringErrors.parenthesizedBind<0&&(refDestructuringErrors.parenthesizedBind=start)),expr;case types$1.bracketL:return node=this.startNode(),this.next(),node.elements=this.parseExprList(types$1.bracketR,true,true,refDestructuringErrors),this.finishNode(node,"ArrayExpression");case types$1.braceL:return this.overrideContext(types.b_expr),this.parseObj(false,refDestructuringErrors);case types$1._function:return node=this.startNode(),this.next(),this.parseFunction(node,0);case types$1._class:return this.parseClass(this.startNode(),false);case types$1._new:return this.parseNew();case types$1.backQuote:return this.parseTemplate();case types$1._import:return this.options.ecmaVersion>=11?this.parseExprImport(forNew):this.unexpected();default:return this.parseExprAtomDefault()}},pp$5.parseExprAtomDefault=function(){this.unexpected();},pp$5.parseExprImport=function(forNew){var node=this.startNode();if(this.containsEsc&&this.raiseRecoverable(this.start,"Escape sequence in keyword import"),this.next(),this.type===types$1.parenL&&!forNew)return this.parseDynamicImport(node);if(this.type===types$1.dot){var meta=this.startNodeAt(node.start,node.loc&&node.loc.start);return meta.name="import",node.meta=this.finishNode(meta,"Identifier"),this.parseImportMeta(node)}this.unexpected();},pp$5.parseDynamicImport=function(node){if(this.next(),node.source=this.parseMaybeAssign(),this.options.ecmaVersion>=16)this.eat(types$1.parenR)?node.options=null:(this.expect(types$1.comma),this.afterTrailingComma(types$1.parenR)?node.options=null:(node.options=this.parseMaybeAssign(),this.eat(types$1.parenR)||(this.expect(types$1.comma),this.afterTrailingComma(types$1.parenR)||this.unexpected())));else if(!this.eat(types$1.parenR)){var errorPos=this.start;this.eat(types$1.comma)&&this.eat(types$1.parenR)?this.raiseRecoverable(errorPos,"Trailing comma is not allowed in import()"):this.unexpected(errorPos);}return this.finishNode(node,"ImportExpression")},pp$5.parseImportMeta=function(node){this.next();var containsEsc=this.containsEsc;return node.property=this.parseIdent(true),"meta"!==node.property.name&&this.raiseRecoverable(node.property.start,"The only valid meta property for import is 'import.meta'"),containsEsc&&this.raiseRecoverable(node.start,"'import.meta' must not contain escaped characters"),"module"===this.options.sourceType||this.options.allowImportExportEverywhere||this.raiseRecoverable(node.start,"Cannot use 'import.meta' outside a module"),this.finishNode(node,"MetaProperty")},pp$5.parseLiteral=function(value){var node=this.startNode();return node.value=value,node.raw=this.input.slice(this.start,this.end),110===node.raw.charCodeAt(node.raw.length-1)&&(node.bigint=node.raw.slice(0,-1).replace(/_/g,"")),this.next(),this.finishNode(node,"Literal")},pp$5.parseParenExpression=function(){this.expect(types$1.parenL);var val=this.parseExpression();return this.expect(types$1.parenR),val},pp$5.shouldParseArrow=function(exprList){return !this.canInsertSemicolon()},pp$5.parseParenAndDistinguishExpression=function(canBeArrow,forInit){var val,startPos=this.start,startLoc=this.startLoc,allowTrailingComma=this.options.ecmaVersion>=8;if(this.options.ecmaVersion>=6){this.next();var spreadStart,innerStartPos=this.start,innerStartLoc=this.startLoc,exprList=[],first=true,lastIsComma=false,refDestructuringErrors=new DestructuringErrors,oldYieldPos=this.yieldPos,oldAwaitPos=this.awaitPos;for(this.yieldPos=0,this.awaitPos=0;this.type!==types$1.parenR;){if(first?first=false:this.expect(types$1.comma),allowTrailingComma&&this.afterTrailingComma(types$1.parenR,true)){lastIsComma=true;break}if(this.type===types$1.ellipsis){spreadStart=this.start,exprList.push(this.parseParenItem(this.parseRestBinding())),this.type===types$1.comma&&this.raiseRecoverable(this.start,"Comma is not permitted after the rest element");break}exprList.push(this.parseMaybeAssign(false,refDestructuringErrors,this.parseParenItem));}var innerEndPos=this.lastTokEnd,innerEndLoc=this.lastTokEndLoc;if(this.expect(types$1.parenR),canBeArrow&&this.shouldParseArrow(exprList)&&this.eat(types$1.arrow))return this.checkPatternErrors(refDestructuringErrors,false),this.checkYieldAwaitInDefaultParams(),this.yieldPos=oldYieldPos,this.awaitPos=oldAwaitPos,this.parseParenArrowList(startPos,startLoc,exprList,forInit);exprList.length&&!lastIsComma||this.unexpected(this.lastTokStart),spreadStart&&this.unexpected(spreadStart),this.checkExpressionErrors(refDestructuringErrors,true),this.yieldPos=oldYieldPos||this.yieldPos,this.awaitPos=oldAwaitPos||this.awaitPos,exprList.length>1?((val=this.startNodeAt(innerStartPos,innerStartLoc)).expressions=exprList,this.finishNodeAt(val,"SequenceExpression",innerEndPos,innerEndLoc)):val=exprList[0];}else val=this.parseParenExpression();if(this.options.preserveParens){var par=this.startNodeAt(startPos,startLoc);return par.expression=val,this.finishNode(par,"ParenthesizedExpression")}return val},pp$5.parseParenItem=function(item){return item},pp$5.parseParenArrowList=function(startPos,startLoc,exprList,forInit){return this.parseArrowExpression(this.startNodeAt(startPos,startLoc),exprList,false,forInit)};var empty=[];pp$5.parseNew=function(){this.containsEsc&&this.raiseRecoverable(this.start,"Escape sequence in keyword new");var node=this.startNode();if(this.next(),this.options.ecmaVersion>=6&&this.type===types$1.dot){var meta=this.startNodeAt(node.start,node.loc&&node.loc.start);meta.name="new",node.meta=this.finishNode(meta,"Identifier"),this.next();var containsEsc=this.containsEsc;return node.property=this.parseIdent(true),"target"!==node.property.name&&this.raiseRecoverable(node.property.start,"The only valid meta property for new is 'new.target'"),containsEsc&&this.raiseRecoverable(node.start,"'new.target' must not contain escaped characters"),this.allowNewDotTarget||this.raiseRecoverable(node.start,"'new.target' can only be used in functions and class static block"),this.finishNode(node,"MetaProperty")}var startPos=this.start,startLoc=this.startLoc;return node.callee=this.parseSubscripts(this.parseExprAtom(null,false,true),startPos,startLoc,true,false),this.eat(types$1.parenL)?node.arguments=this.parseExprList(types$1.parenR,this.options.ecmaVersion>=8,false):node.arguments=empty,this.finishNode(node,"NewExpression")},pp$5.parseTemplateElement=function(ref){var isTagged=ref.isTagged,elem=this.startNode();return this.type===types$1.invalidTemplate?(isTagged||this.raiseRecoverable(this.start,"Bad escape sequence in untagged template literal"),elem.value={raw:this.value.replace(/\r\n?/g,"\n"),cooked:null}):elem.value={raw:this.input.slice(this.start,this.end).replace(/\r\n?/g,"\n"),cooked:this.value},this.next(),elem.tail=this.type===types$1.backQuote,this.finishNode(elem,"TemplateElement")},pp$5.parseTemplate=function(ref){ void 0===ref&&(ref={});var isTagged=ref.isTagged;void 0===isTagged&&(isTagged=false);var node=this.startNode();this.next(),node.expressions=[];var curElt=this.parseTemplateElement({isTagged});for(node.quasis=[curElt];!curElt.tail;)this.type===types$1.eof&&this.raise(this.pos,"Unterminated template literal"),this.expect(types$1.dollarBraceL),node.expressions.push(this.parseExpression()),this.expect(types$1.braceR),node.quasis.push(curElt=this.parseTemplateElement({isTagged}));return this.next(),this.finishNode(node,"TemplateLiteral")},pp$5.isAsyncProp=function(prop){return !prop.computed&&"Identifier"===prop.key.type&&"async"===prop.key.name&&(this.type===types$1.name||this.type===types$1.num||this.type===types$1.string||this.type===types$1.bracketL||this.type.keyword||this.options.ecmaVersion>=9&&this.type===types$1.star)&&!lineBreak.test(this.input.slice(this.lastTokEnd,this.start))},pp$5.parseObj=function(isPattern,refDestructuringErrors){var node=this.startNode(),first=true,propHash={};for(node.properties=[],this.next();!this.eat(types$1.braceR);){if(first)first=false;else if(this.expect(types$1.comma),this.options.ecmaVersion>=5&&this.afterTrailingComma(types$1.braceR))break;var prop=this.parseProperty(isPattern,refDestructuringErrors);isPattern||this.checkPropClash(prop,propHash,refDestructuringErrors),node.properties.push(prop);}return this.finishNode(node,isPattern?"ObjectPattern":"ObjectExpression")},pp$5.parseProperty=function(isPattern,refDestructuringErrors){var isGenerator,isAsync,startPos,startLoc,prop=this.startNode();if(this.options.ecmaVersion>=9&&this.eat(types$1.ellipsis))return isPattern?(prop.argument=this.parseIdent(false),this.type===types$1.comma&&this.raiseRecoverable(this.start,"Comma is not permitted after the rest element"),this.finishNode(prop,"RestElement")):(prop.argument=this.parseMaybeAssign(false,refDestructuringErrors),this.type===types$1.comma&&refDestructuringErrors&&refDestructuringErrors.trailingComma<0&&(refDestructuringErrors.trailingComma=this.start),this.finishNode(prop,"SpreadElement"));this.options.ecmaVersion>=6&&(prop.method=false,prop.shorthand=false,(isPattern||refDestructuringErrors)&&(startPos=this.start,startLoc=this.startLoc),isPattern||(isGenerator=this.eat(types$1.star)));var containsEsc=this.containsEsc;return this.parsePropertyName(prop),!isPattern&&!containsEsc&&this.options.ecmaVersion>=8&&!isGenerator&&this.isAsyncProp(prop)?(isAsync=true,isGenerator=this.options.ecmaVersion>=9&&this.eat(types$1.star),this.parsePropertyName(prop)):isAsync=false,this.parsePropertyValue(prop,isPattern,isGenerator,isAsync,startPos,startLoc,refDestructuringErrors,containsEsc),this.finishNode(prop,"Property")},pp$5.parseGetterSetter=function(prop){prop.kind=prop.key.name,this.parsePropertyName(prop),prop.value=this.parseMethod(false);var paramCount="get"===prop.kind?0:1;if(prop.value.params.length!==paramCount){var start=prop.value.start;"get"===prop.kind?this.raiseRecoverable(start,"getter should have no params"):this.raiseRecoverable(start,"setter should have exactly one param");}else "set"===prop.kind&&"RestElement"===prop.value.params[0].type&&this.raiseRecoverable(prop.value.params[0].start,"Setter cannot use rest params");},pp$5.parsePropertyValue=function(prop,isPattern,isGenerator,isAsync,startPos,startLoc,refDestructuringErrors,containsEsc){(isGenerator||isAsync)&&this.type===types$1.colon&&this.unexpected(),this.eat(types$1.colon)?(prop.value=isPattern?this.parseMaybeDefault(this.start,this.startLoc):this.parseMaybeAssign(false,refDestructuringErrors),prop.kind="init"):this.options.ecmaVersion>=6&&this.type===types$1.parenL?(isPattern&&this.unexpected(),prop.kind="init",prop.method=true,prop.value=this.parseMethod(isGenerator,isAsync)):isPattern||containsEsc||!(this.options.ecmaVersion>=5)||prop.computed||"Identifier"!==prop.key.type||"get"!==prop.key.name&&"set"!==prop.key.name||this.type===types$1.comma||this.type===types$1.braceR||this.type===types$1.eq?this.options.ecmaVersion>=6&&!prop.computed&&"Identifier"===prop.key.type?((isGenerator||isAsync)&&this.unexpected(),this.checkUnreserved(prop.key),"await"!==prop.key.name||this.awaitIdentPos||(this.awaitIdentPos=startPos),prop.kind="init",isPattern?prop.value=this.parseMaybeDefault(startPos,startLoc,this.copyNode(prop.key)):this.type===types$1.eq&&refDestructuringErrors?(refDestructuringErrors.shorthandAssign<0&&(refDestructuringErrors.shorthandAssign=this.start),prop.value=this.parseMaybeDefault(startPos,startLoc,this.copyNode(prop.key))):prop.value=this.copyNode(prop.key),prop.shorthand=true):this.unexpected():((isGenerator||isAsync)&&this.unexpected(),this.parseGetterSetter(prop));},pp$5.parsePropertyName=function(prop){if(this.options.ecmaVersion>=6){if(this.eat(types$1.bracketL))return prop.computed=true,prop.key=this.parseMaybeAssign(),this.expect(types$1.bracketR),prop.key;prop.computed=false;}return prop.key=this.type===types$1.num||this.type===types$1.string?this.parseExprAtom():this.parseIdent("never"!==this.options.allowReserved)},pp$5.initFunction=function(node){node.id=null,this.options.ecmaVersion>=6&&(node.generator=node.expression=false),this.options.ecmaVersion>=8&&(node.async=false);},pp$5.parseMethod=function(isGenerator,isAsync,allowDirectSuper){var node=this.startNode(),oldYieldPos=this.yieldPos,oldAwaitPos=this.awaitPos,oldAwaitIdentPos=this.awaitIdentPos;return this.initFunction(node),this.options.ecmaVersion>=6&&(node.generator=isGenerator),this.options.ecmaVersion>=8&&(node.async=!!isAsync),this.yieldPos=0,this.awaitPos=0,this.awaitIdentPos=0,this.enterScope(64|functionFlags(isAsync,node.generator)|(allowDirectSuper?128:0)),this.expect(types$1.parenL),node.params=this.parseBindingList(types$1.parenR,false,this.options.ecmaVersion>=8),this.checkYieldAwaitInDefaultParams(),this.parseFunctionBody(node,false,true,false),this.yieldPos=oldYieldPos,this.awaitPos=oldAwaitPos,this.awaitIdentPos=oldAwaitIdentPos,this.finishNode(node,"FunctionExpression")},pp$5.parseArrowExpression=function(node,params,isAsync,forInit){var oldYieldPos=this.yieldPos,oldAwaitPos=this.awaitPos,oldAwaitIdentPos=this.awaitIdentPos;return this.enterScope(16|functionFlags(isAsync,false)),this.initFunction(node),this.options.ecmaVersion>=8&&(node.async=!!isAsync),this.yieldPos=0,this.awaitPos=0,this.awaitIdentPos=0,node.params=this.toAssignableList(params,true),this.parseFunctionBody(node,true,false,forInit),this.yieldPos=oldYieldPos,this.awaitPos=oldAwaitPos,this.awaitIdentPos=oldAwaitIdentPos,this.finishNode(node,"ArrowFunctionExpression")},pp$5.parseFunctionBody=function(node,isArrowFunction,isMethod,forInit){var isExpression=isArrowFunction&&this.type!==types$1.braceL,oldStrict=this.strict,useStrict=false;if(isExpression)node.body=this.parseMaybeAssign(forInit),node.expression=true,this.checkParams(node,false);else {var nonSimple=this.options.ecmaVersion>=7&&!this.isSimpleParamList(node.params);oldStrict&&!nonSimple||(useStrict=this.strictDirective(this.end))&&nonSimple&&this.raiseRecoverable(node.start,"Illegal 'use strict' directive in function with non-simple parameter list");var oldLabels=this.labels;this.labels=[],useStrict&&(this.strict=true),this.checkParams(node,!oldStrict&&!useStrict&&!isArrowFunction&&!isMethod&&this.isSimpleParamList(node.params)),this.strict&&node.id&&this.checkLValSimple(node.id,5),node.body=this.parseBlock(false,void 0,useStrict&&!oldStrict),node.expression=false,this.adaptDirectivePrologue(node.body.body),this.labels=oldLabels;}this.exitScope();},pp$5.isSimpleParamList=function(params){for(var i=0,list=params;i<list.length;i+=1){if("Identifier"!==list[i].type)return  false}return  true},pp$5.checkParams=function(node,allowDuplicates){for(var nameHash=Object.create(null),i=0,list=node.params;i<list.length;i+=1){var param=list[i];this.checkLValInnerPattern(param,1,allowDuplicates?null:nameHash);}},pp$5.parseExprList=function(close,allowTrailingComma,allowEmpty,refDestructuringErrors){for(var elts=[],first=true;!this.eat(close);){if(first)first=false;else if(this.expect(types$1.comma),allowTrailingComma&&this.afterTrailingComma(close))break;var elt=void 0;allowEmpty&&this.type===types$1.comma?elt=null:this.type===types$1.ellipsis?(elt=this.parseSpread(refDestructuringErrors),refDestructuringErrors&&this.type===types$1.comma&&refDestructuringErrors.trailingComma<0&&(refDestructuringErrors.trailingComma=this.start)):elt=this.parseMaybeAssign(false,refDestructuringErrors),elts.push(elt);}return elts},pp$5.checkUnreserved=function(ref){var start=ref.start,end=ref.end,name=ref.name;(this.inGenerator&&"yield"===name&&this.raiseRecoverable(start,"Cannot use 'yield' as identifier inside a generator"),this.inAsync&&"await"===name&&this.raiseRecoverable(start,"Cannot use 'await' as identifier inside an async function"),this.currentThisScope().inClassFieldInit&&"arguments"===name&&this.raiseRecoverable(start,"Cannot use 'arguments' in class field initializer"),!this.inClassStaticBlock||"arguments"!==name&&"await"!==name||this.raise(start,"Cannot use "+name+" in class static initialization block"),this.keywords.test(name)&&this.raise(start,"Unexpected keyword '"+name+"'"),this.options.ecmaVersion<6&&-1!==this.input.slice(start,end).indexOf("\\"))||(this.strict?this.reservedWordsStrict:this.reservedWords).test(name)&&(this.inAsync||"await"!==name||this.raiseRecoverable(start,"Cannot use keyword 'await' outside an async function"),this.raiseRecoverable(start,"The keyword '"+name+"' is reserved"));},pp$5.parseIdent=function(liberal){var node=this.parseIdentNode();return this.next(!!liberal),this.finishNode(node,"Identifier"),liberal||(this.checkUnreserved(node),"await"!==node.name||this.awaitIdentPos||(this.awaitIdentPos=node.start)),node},pp$5.parseIdentNode=function(){var node=this.startNode();return this.type===types$1.name?node.name=this.value:this.type.keyword?(node.name=this.type.keyword,"class"!==node.name&&"function"!==node.name||this.lastTokEnd===this.lastTokStart+1&&46===this.input.charCodeAt(this.lastTokStart)||this.context.pop(),this.type=types$1.name):this.unexpected(),node},pp$5.parsePrivateIdent=function(){var node=this.startNode();return this.type===types$1.privateId?node.name=this.value:this.unexpected(),this.next(),this.finishNode(node,"PrivateIdentifier"),this.options.checkPrivateFields&&(0===this.privateNameStack.length?this.raise(node.start,"Private field '#"+node.name+"' must be declared in an enclosing class"):this.privateNameStack[this.privateNameStack.length-1].used.push(node)),node},pp$5.parseYield=function(forInit){this.yieldPos||(this.yieldPos=this.start);var node=this.startNode();return this.next(),this.type===types$1.semi||this.canInsertSemicolon()||this.type!==types$1.star&&!this.type.startsExpr?(node.delegate=false,node.argument=null):(node.delegate=this.eat(types$1.star),node.argument=this.parseMaybeAssign(forInit)),this.finishNode(node,"YieldExpression")},pp$5.parseAwait=function(forInit){this.awaitPos||(this.awaitPos=this.start);var node=this.startNode();return this.next(),node.argument=this.parseMaybeUnary(null,true,false,forInit),this.finishNode(node,"AwaitExpression")};var pp$4=Parser.prototype;pp$4.raise=function(pos,message){var loc=getLineInfo(this.input,pos);message+=" ("+loc.line+":"+loc.column+")";var err=new SyntaxError(message);throw err.pos=pos,err.loc=loc,err.raisedAt=this.pos,err},pp$4.raiseRecoverable=pp$4.raise,pp$4.curPosition=function(){if(this.options.locations)return new Position(this.curLine,this.pos-this.lineStart)};var pp$3=Parser.prototype,Scope=function(flags){this.flags=flags,this.var=[],this.lexical=[],this.functions=[],this.inClassFieldInit=false;};pp$3.enterScope=function(flags){this.scopeStack.push(new Scope(flags));},pp$3.exitScope=function(){this.scopeStack.pop();},pp$3.treatFunctionsAsVarInScope=function(scope){return 2&scope.flags||!this.inModule&&1&scope.flags},pp$3.declareName=function(name,bindingType,pos){var redeclared=false;if(2===bindingType){var scope=this.currentScope();redeclared=scope.lexical.indexOf(name)>-1||scope.functions.indexOf(name)>-1||scope.var.indexOf(name)>-1,scope.lexical.push(name),this.inModule&&1&scope.flags&&delete this.undefinedExports[name];}else if(4===bindingType){this.currentScope().lexical.push(name);}else if(3===bindingType){var scope$2=this.currentScope();redeclared=this.treatFunctionsAsVar?scope$2.lexical.indexOf(name)>-1:scope$2.lexical.indexOf(name)>-1||scope$2.var.indexOf(name)>-1,scope$2.functions.push(name);}else for(var i=this.scopeStack.length-1;i>=0;--i){var scope$3=this.scopeStack[i];if(scope$3.lexical.indexOf(name)>-1&&!(32&scope$3.flags&&scope$3.lexical[0]===name)||!this.treatFunctionsAsVarInScope(scope$3)&&scope$3.functions.indexOf(name)>-1){redeclared=true;break}if(scope$3.var.push(name),this.inModule&&1&scope$3.flags&&delete this.undefinedExports[name],259&scope$3.flags)break}redeclared&&this.raiseRecoverable(pos,"Identifier '"+name+"' has already been declared");},pp$3.checkLocalExport=function(id){ -1===this.scopeStack[0].lexical.indexOf(id.name)&&-1===this.scopeStack[0].var.indexOf(id.name)&&(this.undefinedExports[id.name]=id);},pp$3.currentScope=function(){return this.scopeStack[this.scopeStack.length-1]},pp$3.currentVarScope=function(){for(var i=this.scopeStack.length-1;;i--){var scope=this.scopeStack[i];if(259&scope.flags)return scope}},pp$3.currentThisScope=function(){for(var i=this.scopeStack.length-1;;i--){var scope=this.scopeStack[i];if(259&scope.flags&&!(16&scope.flags))return scope}};var Node=function(parser,pos,loc){this.type="",this.start=pos,this.end=0,parser.options.locations&&(this.loc=new SourceLocation(parser,loc)),parser.options.directSourceFile&&(this.sourceFile=parser.options.directSourceFile),parser.options.ranges&&(this.range=[pos,0]);},pp$2=Parser.prototype;function finishNodeAt(node,type,pos,loc){return node.type=type,node.end=pos,this.options.locations&&(node.loc.end=loc),this.options.ranges&&(node.range[1]=pos),node}pp$2.startNode=function(){return new Node(this,this.start,this.startLoc)},pp$2.startNodeAt=function(pos,loc){return new Node(this,pos,loc)},pp$2.finishNode=function(node,type){return finishNodeAt.call(this,node,type,this.lastTokEnd,this.lastTokEndLoc)},pp$2.finishNodeAt=function(node,type,pos,loc){return finishNodeAt.call(this,node,type,pos,loc)},pp$2.copyNode=function(node){var newNode=new Node(this,node.start,this.startLoc);for(var prop in node)newNode[prop]=node[prop];return newNode};var ecma9BinaryProperties="ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS",ecma10BinaryProperties=ecma9BinaryProperties+" Extended_Pictographic",ecma12BinaryProperties=ecma10BinaryProperties+" EBase EComp EMod EPres ExtPict",unicodeBinaryProperties={9:ecma9BinaryProperties,10:ecma10BinaryProperties,11:ecma10BinaryProperties,12:ecma12BinaryProperties,13:ecma12BinaryProperties,14:ecma12BinaryProperties},unicodeBinaryPropertiesOfStrings={9:"",10:"",11:"",12:"",13:"",14:"Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji"},unicodeGeneralCategoryValues="Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu",ecma9ScriptValues="Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb",ecma10ScriptValues=ecma9ScriptValues+" Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd",ecma11ScriptValues=ecma10ScriptValues+" Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho",ecma12ScriptValues=ecma11ScriptValues+" Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi",ecma13ScriptValues=ecma12ScriptValues+" Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith",unicodeScriptValues={9:ecma9ScriptValues,10:ecma10ScriptValues,11:ecma11ScriptValues,12:ecma12ScriptValues,13:ecma13ScriptValues,14:ecma13ScriptValues+" Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz"},data={};function buildUnicodeData(ecmaVersion){var d=data[ecmaVersion]={binary:wordsRegexp(unicodeBinaryProperties[ecmaVersion]+" "+unicodeGeneralCategoryValues),binaryOfStrings:wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion]),nonBinary:{General_Category:wordsRegexp(unicodeGeneralCategoryValues),Script:wordsRegexp(unicodeScriptValues[ecmaVersion])}};d.nonBinary.Script_Extensions=d.nonBinary.Script,d.nonBinary.gc=d.nonBinary.General_Category,d.nonBinary.sc=d.nonBinary.Script,d.nonBinary.scx=d.nonBinary.Script_Extensions;}for(var i=0,list=[9,10,11,12,13,14];i<list.length;i+=1){buildUnicodeData(list[i]);}var pp$1=Parser.prototype,BranchID=function(parent,base){this.parent=parent,this.base=base||this;};BranchID.prototype.separatedFrom=function(alt){for(var self=this;self;self=self.parent)for(var other=alt;other;other=other.parent)if(self.base===other.base&&self!==other)return  true;return  false},BranchID.prototype.sibling=function(){return new BranchID(this.parent,this.base)};var RegExpValidationState=function(parser){this.parser=parser,this.validFlags="gim"+(parser.options.ecmaVersion>=6?"uy":"")+(parser.options.ecmaVersion>=9?"s":"")+(parser.options.ecmaVersion>=13?"d":"")+(parser.options.ecmaVersion>=15?"v":""),this.unicodeProperties=data[parser.options.ecmaVersion>=14?14:parser.options.ecmaVersion],this.source="",this.flags="",this.start=0,this.switchU=false,this.switchV=false,this.switchN=false,this.pos=0,this.lastIntValue=0,this.lastStringValue="",this.lastAssertionIsQuantifiable=false,this.numCapturingParens=0,this.maxBackReference=0,this.groupNames=Object.create(null),this.backReferenceNames=[],this.branchID=null;};function isRegularExpressionModifier(ch){return 105===ch||109===ch||115===ch}function isSyntaxCharacter(ch){return 36===ch||ch>=40&&ch<=43||46===ch||63===ch||ch>=91&&ch<=94||ch>=123&&ch<=125}function isControlLetter(ch){return ch>=65&&ch<=90||ch>=97&&ch<=122}RegExpValidationState.prototype.reset=function(start,pattern,flags){var unicodeSets=-1!==flags.indexOf("v"),unicode=-1!==flags.indexOf("u");this.start=0|start,this.source=pattern+"",this.flags=flags,unicodeSets&&this.parser.options.ecmaVersion>=15?(this.switchU=true,this.switchV=true,this.switchN=true):(this.switchU=unicode&&this.parser.options.ecmaVersion>=6,this.switchV=false,this.switchN=unicode&&this.parser.options.ecmaVersion>=9);},RegExpValidationState.prototype.raise=function(message){this.parser.raiseRecoverable(this.start,"Invalid regular expression: /"+this.source+"/: "+message);},RegExpValidationState.prototype.at=function(i,forceU){ void 0===forceU&&(forceU=false);var s=this.source,l=s.length;if(i>=l)return  -1;var c=s.charCodeAt(i);if(!forceU&&!this.switchU||c<=55295||c>=57344||i+1>=l)return c;var next=s.charCodeAt(i+1);return next>=56320&&next<=57343?(c<<10)+next-56613888:c},RegExpValidationState.prototype.nextIndex=function(i,forceU){ void 0===forceU&&(forceU=false);var s=this.source,l=s.length;if(i>=l)return l;var next,c=s.charCodeAt(i);return !forceU&&!this.switchU||c<=55295||c>=57344||i+1>=l||(next=s.charCodeAt(i+1))<56320||next>57343?i+1:i+2},RegExpValidationState.prototype.current=function(forceU){return void 0===forceU&&(forceU=false),this.at(this.pos,forceU)},RegExpValidationState.prototype.lookahead=function(forceU){return void 0===forceU&&(forceU=false),this.at(this.nextIndex(this.pos,forceU),forceU)},RegExpValidationState.prototype.advance=function(forceU){ void 0===forceU&&(forceU=false),this.pos=this.nextIndex(this.pos,forceU);},RegExpValidationState.prototype.eat=function(ch,forceU){return void 0===forceU&&(forceU=false),this.current(forceU)===ch&&(this.advance(forceU),true)},RegExpValidationState.prototype.eatChars=function(chs,forceU){ void 0===forceU&&(forceU=false);for(var pos=this.pos,i=0,list=chs;i<list.length;i+=1){var ch=list[i],current=this.at(pos,forceU);if(-1===current||current!==ch)return  false;pos=this.nextIndex(pos,forceU);}return this.pos=pos,true},pp$1.validateRegExpFlags=function(state){for(var validFlags=state.validFlags,flags=state.flags,u=false,v=false,i=0;i<flags.length;i++){var flag=flags.charAt(i);-1===validFlags.indexOf(flag)&&this.raise(state.start,"Invalid regular expression flag"),flags.indexOf(flag,i+1)>-1&&this.raise(state.start,"Duplicate regular expression flag"),"u"===flag&&(u=true),"v"===flag&&(v=true);}this.options.ecmaVersion>=15&&u&&v&&this.raise(state.start,"Invalid regular expression flag");},pp$1.validateRegExpPattern=function(state){this.regexp_pattern(state),!state.switchN&&this.options.ecmaVersion>=9&&function(obj){for(var _ in obj)return  true;return  false}(state.groupNames)&&(state.switchN=true,this.regexp_pattern(state));},pp$1.regexp_pattern=function(state){state.pos=0,state.lastIntValue=0,state.lastStringValue="",state.lastAssertionIsQuantifiable=false,state.numCapturingParens=0,state.maxBackReference=0,state.groupNames=Object.create(null),state.backReferenceNames.length=0,state.branchID=null,this.regexp_disjunction(state),state.pos!==state.source.length&&(state.eat(41)&&state.raise("Unmatched ')'"),(state.eat(93)||state.eat(125))&&state.raise("Lone quantifier brackets")),state.maxBackReference>state.numCapturingParens&&state.raise("Invalid escape");for(var i=0,list=state.backReferenceNames;i<list.length;i+=1){var name=list[i];state.groupNames[name]||state.raise("Invalid named capture referenced");}},pp$1.regexp_disjunction=function(state){var trackDisjunction=this.options.ecmaVersion>=16;for(trackDisjunction&&(state.branchID=new BranchID(state.branchID,null)),this.regexp_alternative(state);state.eat(124);)trackDisjunction&&(state.branchID=state.branchID.sibling()),this.regexp_alternative(state);trackDisjunction&&(state.branchID=state.branchID.parent),this.regexp_eatQuantifier(state,true)&&state.raise("Nothing to repeat"),state.eat(123)&&state.raise("Lone quantifier brackets");},pp$1.regexp_alternative=function(state){for(;state.pos<state.source.length&&this.regexp_eatTerm(state););},pp$1.regexp_eatTerm=function(state){return this.regexp_eatAssertion(state)?(state.lastAssertionIsQuantifiable&&this.regexp_eatQuantifier(state)&&state.switchU&&state.raise("Invalid quantifier"),true):!!(state.switchU?this.regexp_eatAtom(state):this.regexp_eatExtendedAtom(state))&&(this.regexp_eatQuantifier(state),true)},pp$1.regexp_eatAssertion=function(state){var start=state.pos;if(state.lastAssertionIsQuantifiable=false,state.eat(94)||state.eat(36))return  true;if(state.eat(92)){if(state.eat(66)||state.eat(98))return  true;state.pos=start;}if(state.eat(40)&&state.eat(63)){var lookbehind=false;if(this.options.ecmaVersion>=9&&(lookbehind=state.eat(60)),state.eat(61)||state.eat(33))return this.regexp_disjunction(state),state.eat(41)||state.raise("Unterminated group"),state.lastAssertionIsQuantifiable=!lookbehind,true}return state.pos=start,false},pp$1.regexp_eatQuantifier=function(state,noError){return void 0===noError&&(noError=false),!!this.regexp_eatQuantifierPrefix(state,noError)&&(state.eat(63),true)},pp$1.regexp_eatQuantifierPrefix=function(state,noError){return state.eat(42)||state.eat(43)||state.eat(63)||this.regexp_eatBracedQuantifier(state,noError)},pp$1.regexp_eatBracedQuantifier=function(state,noError){var start=state.pos;if(state.eat(123)){var min=0,max=-1;if(this.regexp_eatDecimalDigits(state)&&(min=state.lastIntValue,state.eat(44)&&this.regexp_eatDecimalDigits(state)&&(max=state.lastIntValue),state.eat(125)))return  -1!==max&&max<min&&!noError&&state.raise("numbers out of order in {} quantifier"),true;state.switchU&&!noError&&state.raise("Incomplete quantifier"),state.pos=start;}return  false},pp$1.regexp_eatAtom=function(state){return this.regexp_eatPatternCharacters(state)||state.eat(46)||this.regexp_eatReverseSolidusAtomEscape(state)||this.regexp_eatCharacterClass(state)||this.regexp_eatUncapturingGroup(state)||this.regexp_eatCapturingGroup(state)},pp$1.regexp_eatReverseSolidusAtomEscape=function(state){var start=state.pos;if(state.eat(92)){if(this.regexp_eatAtomEscape(state))return  true;state.pos=start;}return  false},pp$1.regexp_eatUncapturingGroup=function(state){var start=state.pos;if(state.eat(40)){if(state.eat(63)){if(this.options.ecmaVersion>=16){var addModifiers=this.regexp_eatModifiers(state),hasHyphen=state.eat(45);if(addModifiers||hasHyphen){for(var i=0;i<addModifiers.length;i++){var modifier=addModifiers.charAt(i);addModifiers.indexOf(modifier,i+1)>-1&&state.raise("Duplicate regular expression modifiers");}if(hasHyphen){var removeModifiers=this.regexp_eatModifiers(state);addModifiers||removeModifiers||58!==state.current()||state.raise("Invalid regular expression modifiers");for(var i$1=0;i$1<removeModifiers.length;i$1++){var modifier$1=removeModifiers.charAt(i$1);(removeModifiers.indexOf(modifier$1,i$1+1)>-1||addModifiers.indexOf(modifier$1)>-1)&&state.raise("Duplicate regular expression modifiers");}}}}if(state.eat(58)){if(this.regexp_disjunction(state),state.eat(41))return  true;state.raise("Unterminated group");}}state.pos=start;}return  false},pp$1.regexp_eatCapturingGroup=function(state){if(state.eat(40)){if(this.options.ecmaVersion>=9?this.regexp_groupSpecifier(state):63===state.current()&&state.raise("Invalid group"),this.regexp_disjunction(state),state.eat(41))return state.numCapturingParens+=1,true;state.raise("Unterminated group");}return  false},pp$1.regexp_eatModifiers=function(state){for(var modifiers="",ch=0;-1!==(ch=state.current())&&isRegularExpressionModifier(ch);)modifiers+=codePointToString(ch),state.advance();return modifiers},pp$1.regexp_eatExtendedAtom=function(state){return state.eat(46)||this.regexp_eatReverseSolidusAtomEscape(state)||this.regexp_eatCharacterClass(state)||this.regexp_eatUncapturingGroup(state)||this.regexp_eatCapturingGroup(state)||this.regexp_eatInvalidBracedQuantifier(state)||this.regexp_eatExtendedPatternCharacter(state)},pp$1.regexp_eatInvalidBracedQuantifier=function(state){return this.regexp_eatBracedQuantifier(state,true)&&state.raise("Nothing to repeat"),false},pp$1.regexp_eatSyntaxCharacter=function(state){var ch=state.current();return !!isSyntaxCharacter(ch)&&(state.lastIntValue=ch,state.advance(),true)},pp$1.regexp_eatPatternCharacters=function(state){for(var start=state.pos,ch=0;-1!==(ch=state.current())&&!isSyntaxCharacter(ch);)state.advance();return state.pos!==start},pp$1.regexp_eatExtendedPatternCharacter=function(state){var ch=state.current();return !(-1===ch||36===ch||ch>=40&&ch<=43||46===ch||63===ch||91===ch||94===ch||124===ch)&&(state.advance(),true)},pp$1.regexp_groupSpecifier=function(state){if(state.eat(63)){this.regexp_eatGroupName(state)||state.raise("Invalid group");var trackDisjunction=this.options.ecmaVersion>=16,known=state.groupNames[state.lastStringValue];if(known)if(trackDisjunction)for(var i=0,list=known;i<list.length;i+=1){list[i].separatedFrom(state.branchID)||state.raise("Duplicate capture group name");}else state.raise("Duplicate capture group name");trackDisjunction?(known||(state.groupNames[state.lastStringValue]=[])).push(state.branchID):state.groupNames[state.lastStringValue]=true;}},pp$1.regexp_eatGroupName=function(state){if(state.lastStringValue="",state.eat(60)){if(this.regexp_eatRegExpIdentifierName(state)&&state.eat(62))return  true;state.raise("Invalid capture group name");}return  false},pp$1.regexp_eatRegExpIdentifierName=function(state){if(state.lastStringValue="",this.regexp_eatRegExpIdentifierStart(state)){for(state.lastStringValue+=codePointToString(state.lastIntValue);this.regexp_eatRegExpIdentifierPart(state);)state.lastStringValue+=codePointToString(state.lastIntValue);return  true}return  false},pp$1.regexp_eatRegExpIdentifierStart=function(state){var start=state.pos,forceU=this.options.ecmaVersion>=11,ch=state.current(forceU);return state.advance(forceU),92===ch&&this.regexp_eatRegExpUnicodeEscapeSequence(state,forceU)&&(ch=state.lastIntValue),function(ch){return isIdentifierStart(ch,true)||36===ch||95===ch}(ch)?(state.lastIntValue=ch,true):(state.pos=start,false)},pp$1.regexp_eatRegExpIdentifierPart=function(state){var start=state.pos,forceU=this.options.ecmaVersion>=11,ch=state.current(forceU);return state.advance(forceU),92===ch&&this.regexp_eatRegExpUnicodeEscapeSequence(state,forceU)&&(ch=state.lastIntValue),function(ch){return isIdentifierChar(ch,true)||36===ch||95===ch||8204===ch||8205===ch}(ch)?(state.lastIntValue=ch,true):(state.pos=start,false)},pp$1.regexp_eatAtomEscape=function(state){return !!(this.regexp_eatBackReference(state)||this.regexp_eatCharacterClassEscape(state)||this.regexp_eatCharacterEscape(state)||state.switchN&&this.regexp_eatKGroupName(state))||(state.switchU&&(99===state.current()&&state.raise("Invalid unicode escape"),state.raise("Invalid escape")),false)},pp$1.regexp_eatBackReference=function(state){var start=state.pos;if(this.regexp_eatDecimalEscape(state)){var n=state.lastIntValue;if(state.switchU)return n>state.maxBackReference&&(state.maxBackReference=n),true;if(n<=state.numCapturingParens)return  true;state.pos=start;}return  false},pp$1.regexp_eatKGroupName=function(state){if(state.eat(107)){if(this.regexp_eatGroupName(state))return state.backReferenceNames.push(state.lastStringValue),true;state.raise("Invalid named reference");}return  false},pp$1.regexp_eatCharacterEscape=function(state){return this.regexp_eatControlEscape(state)||this.regexp_eatCControlLetter(state)||this.regexp_eatZero(state)||this.regexp_eatHexEscapeSequence(state)||this.regexp_eatRegExpUnicodeEscapeSequence(state,false)||!state.switchU&&this.regexp_eatLegacyOctalEscapeSequence(state)||this.regexp_eatIdentityEscape(state)},pp$1.regexp_eatCControlLetter=function(state){var start=state.pos;if(state.eat(99)){if(this.regexp_eatControlLetter(state))return  true;state.pos=start;}return  false},pp$1.regexp_eatZero=function(state){return 48===state.current()&&!isDecimalDigit(state.lookahead())&&(state.lastIntValue=0,state.advance(),true)},pp$1.regexp_eatControlEscape=function(state){var ch=state.current();return 116===ch?(state.lastIntValue=9,state.advance(),true):110===ch?(state.lastIntValue=10,state.advance(),true):118===ch?(state.lastIntValue=11,state.advance(),true):102===ch?(state.lastIntValue=12,state.advance(),true):114===ch&&(state.lastIntValue=13,state.advance(),true)},pp$1.regexp_eatControlLetter=function(state){var ch=state.current();return !!isControlLetter(ch)&&(state.lastIntValue=ch%32,state.advance(),true)},pp$1.regexp_eatRegExpUnicodeEscapeSequence=function(state,forceU){ void 0===forceU&&(forceU=false);var ch,start=state.pos,switchU=forceU||state.switchU;if(state.eat(117)){if(this.regexp_eatFixedHexDigits(state,4)){var lead=state.lastIntValue;if(switchU&&lead>=55296&&lead<=56319){var leadSurrogateEnd=state.pos;if(state.eat(92)&&state.eat(117)&&this.regexp_eatFixedHexDigits(state,4)){var trail=state.lastIntValue;if(trail>=56320&&trail<=57343)return state.lastIntValue=1024*(lead-55296)+(trail-56320)+65536,true}state.pos=leadSurrogateEnd,state.lastIntValue=lead;}return  true}if(switchU&&state.eat(123)&&this.regexp_eatHexDigits(state)&&state.eat(125)&&((ch=state.lastIntValue)>=0&&ch<=1114111))return  true;switchU&&state.raise("Invalid unicode escape"),state.pos=start;}return  false},pp$1.regexp_eatIdentityEscape=function(state){if(state.switchU)return !!this.regexp_eatSyntaxCharacter(state)||!!state.eat(47)&&(state.lastIntValue=47,true);var ch=state.current();return !(99===ch||state.switchN&&107===ch)&&(state.lastIntValue=ch,state.advance(),true)},pp$1.regexp_eatDecimalEscape=function(state){state.lastIntValue=0;var ch=state.current();if(ch>=49&&ch<=57){do{state.lastIntValue=10*state.lastIntValue+(ch-48),state.advance();}while((ch=state.current())>=48&&ch<=57);return  true}return  false};function isUnicodePropertyNameCharacter(ch){return isControlLetter(ch)||95===ch}function isUnicodePropertyValueCharacter(ch){return isUnicodePropertyNameCharacter(ch)||isDecimalDigit(ch)}function isDecimalDigit(ch){return ch>=48&&ch<=57}function isHexDigit(ch){return ch>=48&&ch<=57||ch>=65&&ch<=70||ch>=97&&ch<=102}function hexToInt(ch){return ch>=65&&ch<=70?ch-65+10:ch>=97&&ch<=102?ch-97+10:ch-48}function isOctalDigit(ch){return ch>=48&&ch<=55}pp$1.regexp_eatCharacterClassEscape=function(state){var ch=state.current();if(function(ch){return 100===ch||68===ch||115===ch||83===ch||119===ch||87===ch}(ch))return state.lastIntValue=-1,state.advance(),1;var negate=false;if(state.switchU&&this.options.ecmaVersion>=9&&((negate=80===ch)||112===ch)){var result;if(state.lastIntValue=-1,state.advance(),state.eat(123)&&(result=this.regexp_eatUnicodePropertyValueExpression(state))&&state.eat(125))return negate&&2===result&&state.raise("Invalid property name"),result;state.raise("Invalid property name");}return 0},pp$1.regexp_eatUnicodePropertyValueExpression=function(state){var start=state.pos;if(this.regexp_eatUnicodePropertyName(state)&&state.eat(61)){var name=state.lastStringValue;if(this.regexp_eatUnicodePropertyValue(state)){var value=state.lastStringValue;return this.regexp_validateUnicodePropertyNameAndValue(state,name,value),1}}if(state.pos=start,this.regexp_eatLoneUnicodePropertyNameOrValue(state)){var nameOrValue=state.lastStringValue;return this.regexp_validateUnicodePropertyNameOrValue(state,nameOrValue)}return 0},pp$1.regexp_validateUnicodePropertyNameAndValue=function(state,name,value){hasOwn(state.unicodeProperties.nonBinary,name)||state.raise("Invalid property name"),state.unicodeProperties.nonBinary[name].test(value)||state.raise("Invalid property value");},pp$1.regexp_validateUnicodePropertyNameOrValue=function(state,nameOrValue){return state.unicodeProperties.binary.test(nameOrValue)?1:state.switchV&&state.unicodeProperties.binaryOfStrings.test(nameOrValue)?2:void state.raise("Invalid property name")},pp$1.regexp_eatUnicodePropertyName=function(state){var ch=0;for(state.lastStringValue="";isUnicodePropertyNameCharacter(ch=state.current());)state.lastStringValue+=codePointToString(ch),state.advance();return ""!==state.lastStringValue},pp$1.regexp_eatUnicodePropertyValue=function(state){var ch=0;for(state.lastStringValue="";isUnicodePropertyValueCharacter(ch=state.current());)state.lastStringValue+=codePointToString(ch),state.advance();return ""!==state.lastStringValue},pp$1.regexp_eatLoneUnicodePropertyNameOrValue=function(state){return this.regexp_eatUnicodePropertyValue(state)},pp$1.regexp_eatCharacterClass=function(state){if(state.eat(91)){var negate=state.eat(94),result=this.regexp_classContents(state);return state.eat(93)||state.raise("Unterminated character class"),negate&&2===result&&state.raise("Negated character class may contain strings"),true}return  false},pp$1.regexp_classContents=function(state){return 93===state.current()?1:state.switchV?this.regexp_classSetExpression(state):(this.regexp_nonEmptyClassRanges(state),1)},pp$1.regexp_nonEmptyClassRanges=function(state){for(;this.regexp_eatClassAtom(state);){var left=state.lastIntValue;if(state.eat(45)&&this.regexp_eatClassAtom(state)){var right=state.lastIntValue;!state.switchU||-1!==left&&-1!==right||state.raise("Invalid character class"),-1!==left&&-1!==right&&left>right&&state.raise("Range out of order in character class");}}},pp$1.regexp_eatClassAtom=function(state){var start=state.pos;if(state.eat(92)){if(this.regexp_eatClassEscape(state))return  true;if(state.switchU){var ch$1=state.current();(99===ch$1||isOctalDigit(ch$1))&&state.raise("Invalid class escape"),state.raise("Invalid escape");}state.pos=start;}var ch=state.current();return 93!==ch&&(state.lastIntValue=ch,state.advance(),true)},pp$1.regexp_eatClassEscape=function(state){var start=state.pos;if(state.eat(98))return state.lastIntValue=8,true;if(state.switchU&&state.eat(45))return state.lastIntValue=45,true;if(!state.switchU&&state.eat(99)){if(this.regexp_eatClassControlLetter(state))return  true;state.pos=start;}return this.regexp_eatCharacterClassEscape(state)||this.regexp_eatCharacterEscape(state)},pp$1.regexp_classSetExpression=function(state){var subResult,result=1;if(this.regexp_eatClassSetRange(state));else if(subResult=this.regexp_eatClassSetOperand(state)){2===subResult&&(result=2);for(var start=state.pos;state.eatChars([38,38]);)38!==state.current()&&(subResult=this.regexp_eatClassSetOperand(state))?2!==subResult&&(result=1):state.raise("Invalid character in character class");if(start!==state.pos)return result;for(;state.eatChars([45,45]);)this.regexp_eatClassSetOperand(state)||state.raise("Invalid character in character class");if(start!==state.pos)return result}else state.raise("Invalid character in character class");for(;;)if(!this.regexp_eatClassSetRange(state)){if(!(subResult=this.regexp_eatClassSetOperand(state)))return result;2===subResult&&(result=2);}},pp$1.regexp_eatClassSetRange=function(state){var start=state.pos;if(this.regexp_eatClassSetCharacter(state)){var left=state.lastIntValue;if(state.eat(45)&&this.regexp_eatClassSetCharacter(state)){var right=state.lastIntValue;return  -1!==left&&-1!==right&&left>right&&state.raise("Range out of order in character class"),true}state.pos=start;}return  false},pp$1.regexp_eatClassSetOperand=function(state){return this.regexp_eatClassSetCharacter(state)?1:this.regexp_eatClassStringDisjunction(state)||this.regexp_eatNestedClass(state)},pp$1.regexp_eatNestedClass=function(state){var start=state.pos;if(state.eat(91)){var negate=state.eat(94),result=this.regexp_classContents(state);if(state.eat(93))return negate&&2===result&&state.raise("Negated character class may contain strings"),result;state.pos=start;}if(state.eat(92)){var result$1=this.regexp_eatCharacterClassEscape(state);if(result$1)return result$1;state.pos=start;}return null},pp$1.regexp_eatClassStringDisjunction=function(state){var start=state.pos;if(state.eatChars([92,113])){if(state.eat(123)){var result=this.regexp_classStringDisjunctionContents(state);if(state.eat(125))return result}else state.raise("Invalid escape");state.pos=start;}return null},pp$1.regexp_classStringDisjunctionContents=function(state){for(var result=this.regexp_classString(state);state.eat(124);)2===this.regexp_classString(state)&&(result=2);return result},pp$1.regexp_classString=function(state){for(var count=0;this.regexp_eatClassSetCharacter(state);)count++;return 1===count?1:2},pp$1.regexp_eatClassSetCharacter=function(state){var start=state.pos;if(state.eat(92))return !(!this.regexp_eatCharacterEscape(state)&&!this.regexp_eatClassSetReservedPunctuator(state))||(state.eat(98)?(state.lastIntValue=8,true):(state.pos=start,false));var ch=state.current();return !(ch<0||ch===state.lookahead()&&function(ch){return 33===ch||ch>=35&&ch<=38||ch>=42&&ch<=44||46===ch||ch>=58&&ch<=64||94===ch||96===ch||126===ch}(ch))&&(!function(ch){return 40===ch||41===ch||45===ch||47===ch||ch>=91&&ch<=93||ch>=123&&ch<=125}(ch)&&(state.advance(),state.lastIntValue=ch,true))},pp$1.regexp_eatClassSetReservedPunctuator=function(state){var ch=state.current();return !!function(ch){return 33===ch||35===ch||37===ch||38===ch||44===ch||45===ch||ch>=58&&ch<=62||64===ch||96===ch||126===ch}(ch)&&(state.lastIntValue=ch,state.advance(),true)},pp$1.regexp_eatClassControlLetter=function(state){var ch=state.current();return !(!isDecimalDigit(ch)&&95!==ch)&&(state.lastIntValue=ch%32,state.advance(),true)},pp$1.regexp_eatHexEscapeSequence=function(state){var start=state.pos;if(state.eat(120)){if(this.regexp_eatFixedHexDigits(state,2))return  true;state.switchU&&state.raise("Invalid escape"),state.pos=start;}return  false},pp$1.regexp_eatDecimalDigits=function(state){var start=state.pos,ch=0;for(state.lastIntValue=0;isDecimalDigit(ch=state.current());)state.lastIntValue=10*state.lastIntValue+(ch-48),state.advance();return state.pos!==start},pp$1.regexp_eatHexDigits=function(state){var start=state.pos,ch=0;for(state.lastIntValue=0;isHexDigit(ch=state.current());)state.lastIntValue=16*state.lastIntValue+hexToInt(ch),state.advance();return state.pos!==start},pp$1.regexp_eatLegacyOctalEscapeSequence=function(state){if(this.regexp_eatOctalDigit(state)){var n1=state.lastIntValue;if(this.regexp_eatOctalDigit(state)){var n2=state.lastIntValue;n1<=3&&this.regexp_eatOctalDigit(state)?state.lastIntValue=64*n1+8*n2+state.lastIntValue:state.lastIntValue=8*n1+n2;}else state.lastIntValue=n1;return  true}return  false},pp$1.regexp_eatOctalDigit=function(state){var ch=state.current();return isOctalDigit(ch)?(state.lastIntValue=ch-48,state.advance(),true):(state.lastIntValue=0,false)},pp$1.regexp_eatFixedHexDigits=function(state,length){var start=state.pos;state.lastIntValue=0;for(var i=0;i<length;++i){var ch=state.current();if(!isHexDigit(ch))return state.pos=start,false;state.lastIntValue=16*state.lastIntValue+hexToInt(ch),state.advance();}return  true};var Token=function(p){this.type=p.type,this.value=p.value,this.start=p.start,this.end=p.end,p.options.locations&&(this.loc=new SourceLocation(p,p.startLoc,p.endLoc)),p.options.ranges&&(this.range=[p.start,p.end]);},pp=Parser.prototype;function stringToBigInt(str){return "function"!=typeof BigInt?null:BigInt(str.replace(/_/g,""))}pp.next=function(ignoreEscapeSequenceInKeyword){!ignoreEscapeSequenceInKeyword&&this.type.keyword&&this.containsEsc&&this.raiseRecoverable(this.start,"Escape sequence in keyword "+this.type.keyword),this.options.onToken&&this.options.onToken(new Token(this)),this.lastTokEnd=this.end,this.lastTokStart=this.start,this.lastTokEndLoc=this.endLoc,this.lastTokStartLoc=this.startLoc,this.nextToken();},pp.getToken=function(){return this.next(),new Token(this)},"undefined"!=typeof Symbol&&(pp[Symbol.iterator]=function(){var this$1$1=this;return {next:function(){var token=this$1$1.getToken();return {done:token.type===types$1.eof,value:token}}}}),pp.nextToken=function(){var curContext=this.curContext();return curContext&&curContext.preserveSpace||this.skipSpace(),this.start=this.pos,this.options.locations&&(this.startLoc=this.curPosition()),this.pos>=this.input.length?this.finishToken(types$1.eof):curContext.override?curContext.override(this):void this.readToken(this.fullCharCodeAtPos())},pp.readToken=function(code){return isIdentifierStart(code,this.options.ecmaVersion>=6)||92===code?this.readWord():this.getTokenFromCode(code)},pp.fullCharCodeAtPos=function(){var code=this.input.charCodeAt(this.pos);if(code<=55295||code>=56320)return code;var next=this.input.charCodeAt(this.pos+1);return next<=56319||next>=57344?code:(code<<10)+next-56613888},pp.skipBlockComment=function(){var startLoc=this.options.onComment&&this.curPosition(),start=this.pos,end=this.input.indexOf("*/",this.pos+=2);if(-1===end&&this.raise(this.pos-2,"Unterminated comment"),this.pos=end+2,this.options.locations)for(var nextBreak=void 0,pos=start;(nextBreak=nextLineBreak(this.input,pos,this.pos))>-1;)++this.curLine,pos=this.lineStart=nextBreak;this.options.onComment&&this.options.onComment(true,this.input.slice(start+2,end),start,this.pos,startLoc,this.curPosition());},pp.skipLineComment=function(startSkip){for(var start=this.pos,startLoc=this.options.onComment&&this.curPosition(),ch=this.input.charCodeAt(this.pos+=startSkip);this.pos<this.input.length&&!isNewLine(ch);)ch=this.input.charCodeAt(++this.pos);this.options.onComment&&this.options.onComment(false,this.input.slice(start+startSkip,this.pos),start,this.pos,startLoc,this.curPosition());},pp.skipSpace=function(){loop:for(;this.pos<this.input.length;){var ch=this.input.charCodeAt(this.pos);switch(ch){case 32:case 160:++this.pos;break;case 13:10===this.input.charCodeAt(this.pos+1)&&++this.pos;case 10:case 8232:case 8233:++this.pos,this.options.locations&&(++this.curLine,this.lineStart=this.pos);break;case 47:switch(this.input.charCodeAt(this.pos+1)){case 42:this.skipBlockComment();break;case 47:this.skipLineComment(2);break;default:break loop}break;default:if(!(ch>8&&ch<14||ch>=5760&&nonASCIIwhitespace.test(String.fromCharCode(ch))))break loop;++this.pos;}}},pp.finishToken=function(type,val){this.end=this.pos,this.options.locations&&(this.endLoc=this.curPosition());var prevType=this.type;this.type=type,this.value=val,this.updateContext(prevType);},pp.readToken_dot=function(){var next=this.input.charCodeAt(this.pos+1);if(next>=48&&next<=57)return this.readNumber(true);var next2=this.input.charCodeAt(this.pos+2);return this.options.ecmaVersion>=6&&46===next&&46===next2?(this.pos+=3,this.finishToken(types$1.ellipsis)):(++this.pos,this.finishToken(types$1.dot))},pp.readToken_slash=function(){var next=this.input.charCodeAt(this.pos+1);return this.exprAllowed?(++this.pos,this.readRegexp()):61===next?this.finishOp(types$1.assign,2):this.finishOp(types$1.slash,1)},pp.readToken_mult_modulo_exp=function(code){var next=this.input.charCodeAt(this.pos+1),size=1,tokentype=42===code?types$1.star:types$1.modulo;return this.options.ecmaVersion>=7&&42===code&&42===next&&(++size,tokentype=types$1.starstar,next=this.input.charCodeAt(this.pos+2)),61===next?this.finishOp(types$1.assign,size+1):this.finishOp(tokentype,size)},pp.readToken_pipe_amp=function(code){var next=this.input.charCodeAt(this.pos+1);if(next===code){if(this.options.ecmaVersion>=12)if(61===this.input.charCodeAt(this.pos+2))return this.finishOp(types$1.assign,3);return this.finishOp(124===code?types$1.logicalOR:types$1.logicalAND,2)}return 61===next?this.finishOp(types$1.assign,2):this.finishOp(124===code?types$1.bitwiseOR:types$1.bitwiseAND,1)},pp.readToken_caret=function(){return 61===this.input.charCodeAt(this.pos+1)?this.finishOp(types$1.assign,2):this.finishOp(types$1.bitwiseXOR,1)},pp.readToken_plus_min=function(code){var next=this.input.charCodeAt(this.pos+1);return next===code?45!==next||this.inModule||62!==this.input.charCodeAt(this.pos+2)||0!==this.lastTokEnd&&!lineBreak.test(this.input.slice(this.lastTokEnd,this.pos))?this.finishOp(types$1.incDec,2):(this.skipLineComment(3),this.skipSpace(),this.nextToken()):61===next?this.finishOp(types$1.assign,2):this.finishOp(types$1.plusMin,1)},pp.readToken_lt_gt=function(code){var next=this.input.charCodeAt(this.pos+1),size=1;return next===code?(size=62===code&&62===this.input.charCodeAt(this.pos+2)?3:2,61===this.input.charCodeAt(this.pos+size)?this.finishOp(types$1.assign,size+1):this.finishOp(types$1.bitShift,size)):33!==next||60!==code||this.inModule||45!==this.input.charCodeAt(this.pos+2)||45!==this.input.charCodeAt(this.pos+3)?(61===next&&(size=2),this.finishOp(types$1.relational,size)):(this.skipLineComment(4),this.skipSpace(),this.nextToken())},pp.readToken_eq_excl=function(code){var next=this.input.charCodeAt(this.pos+1);return 61===next?this.finishOp(types$1.equality,61===this.input.charCodeAt(this.pos+2)?3:2):61===code&&62===next&&this.options.ecmaVersion>=6?(this.pos+=2,this.finishToken(types$1.arrow)):this.finishOp(61===code?types$1.eq:types$1.prefix,1)},pp.readToken_question=function(){var ecmaVersion=this.options.ecmaVersion;if(ecmaVersion>=11){var next=this.input.charCodeAt(this.pos+1);if(46===next){var next2=this.input.charCodeAt(this.pos+2);if(next2<48||next2>57)return this.finishOp(types$1.questionDot,2)}if(63===next){if(ecmaVersion>=12)if(61===this.input.charCodeAt(this.pos+2))return this.finishOp(types$1.assign,3);return this.finishOp(types$1.coalesce,2)}}return this.finishOp(types$1.question,1)},pp.readToken_numberSign=function(){var code=35;if(this.options.ecmaVersion>=13&&(++this.pos,isIdentifierStart(code=this.fullCharCodeAtPos(),true)||92===code))return this.finishToken(types$1.privateId,this.readWord1());this.raise(this.pos,"Unexpected character '"+codePointToString(code)+"'");},pp.getTokenFromCode=function(code){switch(code){case 46:return this.readToken_dot();case 40:return ++this.pos,this.finishToken(types$1.parenL);case 41:return ++this.pos,this.finishToken(types$1.parenR);case 59:return ++this.pos,this.finishToken(types$1.semi);case 44:return ++this.pos,this.finishToken(types$1.comma);case 91:return ++this.pos,this.finishToken(types$1.bracketL);case 93:return ++this.pos,this.finishToken(types$1.bracketR);case 123:return ++this.pos,this.finishToken(types$1.braceL);case 125:return ++this.pos,this.finishToken(types$1.braceR);case 58:return ++this.pos,this.finishToken(types$1.colon);case 96:if(this.options.ecmaVersion<6)break;return ++this.pos,this.finishToken(types$1.backQuote);case 48:var next=this.input.charCodeAt(this.pos+1);if(120===next||88===next)return this.readRadixNumber(16);if(this.options.ecmaVersion>=6){if(111===next||79===next)return this.readRadixNumber(8);if(98===next||66===next)return this.readRadixNumber(2)}case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:return this.readNumber(false);case 34:case 39:return this.readString(code);case 47:return this.readToken_slash();case 37:case 42:return this.readToken_mult_modulo_exp(code);case 124:case 38:return this.readToken_pipe_amp(code);case 94:return this.readToken_caret();case 43:case 45:return this.readToken_plus_min(code);case 60:case 62:return this.readToken_lt_gt(code);case 61:case 33:return this.readToken_eq_excl(code);case 63:return this.readToken_question();case 126:return this.finishOp(types$1.prefix,1);case 35:return this.readToken_numberSign()}this.raise(this.pos,"Unexpected character '"+codePointToString(code)+"'");},pp.finishOp=function(type,size){var str=this.input.slice(this.pos,this.pos+size);return this.pos+=size,this.finishToken(type,str)},pp.readRegexp=function(){for(var escaped,inClass,start=this.pos;;){this.pos>=this.input.length&&this.raise(start,"Unterminated regular expression");var ch=this.input.charAt(this.pos);if(lineBreak.test(ch)&&this.raise(start,"Unterminated regular expression"),escaped)escaped=false;else {if("["===ch)inClass=true;else if("]"===ch&&inClass)inClass=false;else if("/"===ch&&!inClass)break;escaped="\\"===ch;}++this.pos;}var pattern=this.input.slice(start,this.pos);++this.pos;var flagsStart=this.pos,flags=this.readWord1();this.containsEsc&&this.unexpected(flagsStart);var state=this.regexpState||(this.regexpState=new RegExpValidationState(this));state.reset(start,pattern,flags),this.validateRegExpFlags(state),this.validateRegExpPattern(state);var value=null;try{value=new RegExp(pattern,flags);}catch(e){}return this.finishToken(types$1.regexp,{pattern,flags,value})},pp.readInt=function(radix,len,maybeLegacyOctalNumericLiteral){for(var allowSeparators=this.options.ecmaVersion>=12&&void 0===len,isLegacyOctalNumericLiteral=maybeLegacyOctalNumericLiteral&&48===this.input.charCodeAt(this.pos),start=this.pos,total=0,lastCode=0,i=0,e=null==len?1/0:len;i<e;++i,++this.pos){var code=this.input.charCodeAt(this.pos),val=void 0;if(allowSeparators&&95===code)isLegacyOctalNumericLiteral&&this.raiseRecoverable(this.pos,"Numeric separator is not allowed in legacy octal numeric literals"),95===lastCode&&this.raiseRecoverable(this.pos,"Numeric separator must be exactly one underscore"),0===i&&this.raiseRecoverable(this.pos,"Numeric separator is not allowed at the first of digits"),lastCode=code;else {if((val=code>=97?code-97+10:code>=65?code-65+10:code>=48&&code<=57?code-48:1/0)>=radix)break;lastCode=code,total=total*radix+val;}}return allowSeparators&&95===lastCode&&this.raiseRecoverable(this.pos-1,"Numeric separator is not allowed at the last of digits"),this.pos===start||null!=len&&this.pos-start!==len?null:total},pp.readRadixNumber=function(radix){var start=this.pos;this.pos+=2;var val=this.readInt(radix);return null==val&&this.raise(this.start+2,"Expected number in radix "+radix),this.options.ecmaVersion>=11&&110===this.input.charCodeAt(this.pos)?(val=stringToBigInt(this.input.slice(start,this.pos)),++this.pos):isIdentifierStart(this.fullCharCodeAtPos())&&this.raise(this.pos,"Identifier directly after number"),this.finishToken(types$1.num,val)},pp.readNumber=function(startsWithDot){var start=this.pos;startsWithDot||null!==this.readInt(10,void 0,true)||this.raise(start,"Invalid number");var octal=this.pos-start>=2&&48===this.input.charCodeAt(start);octal&&this.strict&&this.raise(start,"Invalid number");var next=this.input.charCodeAt(this.pos);if(!octal&&!startsWithDot&&this.options.ecmaVersion>=11&&110===next){var val$1=stringToBigInt(this.input.slice(start,this.pos));return ++this.pos,isIdentifierStart(this.fullCharCodeAtPos())&&this.raise(this.pos,"Identifier directly after number"),this.finishToken(types$1.num,val$1)}octal&&/[89]/.test(this.input.slice(start,this.pos))&&(octal=false),46!==next||octal||(++this.pos,this.readInt(10),next=this.input.charCodeAt(this.pos)),69!==next&&101!==next||octal||(43!==(next=this.input.charCodeAt(++this.pos))&&45!==next||++this.pos,null===this.readInt(10)&&this.raise(start,"Invalid number")),isIdentifierStart(this.fullCharCodeAtPos())&&this.raise(this.pos,"Identifier directly after number");var str,val=(str=this.input.slice(start,this.pos),octal?parseInt(str,8):parseFloat(str.replace(/_/g,"")));return this.finishToken(types$1.num,val)},pp.readCodePoint=function(){var code;if(123===this.input.charCodeAt(this.pos)){this.options.ecmaVersion<6&&this.unexpected();var codePos=++this.pos;code=this.readHexChar(this.input.indexOf("}",this.pos)-this.pos),++this.pos,code>1114111&&this.invalidStringToken(codePos,"Code point out of bounds");}else code=this.readHexChar(4);return code},pp.readString=function(quote){for(var out="",chunkStart=++this.pos;;){this.pos>=this.input.length&&this.raise(this.start,"Unterminated string constant");var ch=this.input.charCodeAt(this.pos);if(ch===quote)break;92===ch?(out+=this.input.slice(chunkStart,this.pos),out+=this.readEscapedChar(false),chunkStart=this.pos):8232===ch||8233===ch?(this.options.ecmaVersion<10&&this.raise(this.start,"Unterminated string constant"),++this.pos,this.options.locations&&(this.curLine++,this.lineStart=this.pos)):(isNewLine(ch)&&this.raise(this.start,"Unterminated string constant"),++this.pos);}return out+=this.input.slice(chunkStart,this.pos++),this.finishToken(types$1.string,out)};var INVALID_TEMPLATE_ESCAPE_ERROR={};pp.tryReadTemplateToken=function(){this.inTemplateElement=true;try{this.readTmplToken();}catch(err){if(err!==INVALID_TEMPLATE_ESCAPE_ERROR)throw err;this.readInvalidTemplateToken();}this.inTemplateElement=false;},pp.invalidStringToken=function(position,message){if(this.inTemplateElement&&this.options.ecmaVersion>=9)throw INVALID_TEMPLATE_ESCAPE_ERROR;this.raise(position,message);},pp.readTmplToken=function(){for(var out="",chunkStart=this.pos;;){this.pos>=this.input.length&&this.raise(this.start,"Unterminated template");var ch=this.input.charCodeAt(this.pos);if(96===ch||36===ch&&123===this.input.charCodeAt(this.pos+1))return this.pos!==this.start||this.type!==types$1.template&&this.type!==types$1.invalidTemplate?(out+=this.input.slice(chunkStart,this.pos),this.finishToken(types$1.template,out)):36===ch?(this.pos+=2,this.finishToken(types$1.dollarBraceL)):(++this.pos,this.finishToken(types$1.backQuote));if(92===ch)out+=this.input.slice(chunkStart,this.pos),out+=this.readEscapedChar(true),chunkStart=this.pos;else if(isNewLine(ch)){switch(out+=this.input.slice(chunkStart,this.pos),++this.pos,ch){case 13:10===this.input.charCodeAt(this.pos)&&++this.pos;case 10:out+="\n";break;default:out+=String.fromCharCode(ch);}this.options.locations&&(++this.curLine,this.lineStart=this.pos),chunkStart=this.pos;}else ++this.pos;}},pp.readInvalidTemplateToken=function(){for(;this.pos<this.input.length;this.pos++)switch(this.input[this.pos]){case "\\":++this.pos;break;case "$":if("{"!==this.input[this.pos+1])break;case "`":return this.finishToken(types$1.invalidTemplate,this.input.slice(this.start,this.pos));case "\r":"\n"===this.input[this.pos+1]&&++this.pos;case "\n":case "\u2028":case "\u2029":++this.curLine,this.lineStart=this.pos+1;}this.raise(this.start,"Unterminated template");},pp.readEscapedChar=function(inTemplate){var ch=this.input.charCodeAt(++this.pos);switch(++this.pos,ch){case 110:return "\n";case 114:return "\r";case 120:return String.fromCharCode(this.readHexChar(2));case 117:return codePointToString(this.readCodePoint());case 116:return "\t";case 98:return "\b";case 118:return "\v";case 102:return "\f";case 13:10===this.input.charCodeAt(this.pos)&&++this.pos;case 10:return this.options.locations&&(this.lineStart=this.pos,++this.curLine),"";case 56:case 57:if(this.strict&&this.invalidStringToken(this.pos-1,"Invalid escape sequence"),inTemplate){var codePos=this.pos-1;this.invalidStringToken(codePos,"Invalid escape sequence in template string");}default:if(ch>=48&&ch<=55){var octalStr=this.input.substr(this.pos-1,3).match(/^[0-7]+/)[0],octal=parseInt(octalStr,8);return octal>255&&(octalStr=octalStr.slice(0,-1),octal=parseInt(octalStr,8)),this.pos+=octalStr.length-1,ch=this.input.charCodeAt(this.pos),"0"===octalStr&&56!==ch&&57!==ch||!this.strict&&!inTemplate||this.invalidStringToken(this.pos-1-octalStr.length,inTemplate?"Octal literal in template string":"Octal literal in strict mode"),String.fromCharCode(octal)}return isNewLine(ch)?(this.options.locations&&(this.lineStart=this.pos,++this.curLine),""):String.fromCharCode(ch)}},pp.readHexChar=function(len){var codePos=this.pos,n=this.readInt(16,len);return null===n&&this.invalidStringToken(codePos,"Bad character escape sequence"),n},pp.readWord1=function(){this.containsEsc=false;for(var word="",first=true,chunkStart=this.pos,astral=this.options.ecmaVersion>=6;this.pos<this.input.length;){var ch=this.fullCharCodeAtPos();if(isIdentifierChar(ch,astral))this.pos+=ch<=65535?1:2;else {if(92!==ch)break;this.containsEsc=true,word+=this.input.slice(chunkStart,this.pos);var escStart=this.pos;117!==this.input.charCodeAt(++this.pos)&&this.invalidStringToken(this.pos,"Expecting Unicode escape sequence \\uXXXX"),++this.pos;var esc=this.readCodePoint();(first?isIdentifierStart:isIdentifierChar)(esc,astral)||this.invalidStringToken(escStart,"Invalid Unicode escape"),word+=codePointToString(esc),chunkStart=this.pos;}first=false;}return word+this.input.slice(chunkStart,this.pos)},pp.readWord=function(){var word=this.readWord1(),type=types$1.name;return this.keywords.test(word)&&(type=keywords[word]),this.finishToken(type,word)};Parser.acorn={Parser,version:"8.14.0",defaultOptions,Position,SourceLocation,getLineInfo,Node,TokenType,tokTypes:types$1,keywordTypes:keywords,TokContext,tokContexts:types,isIdentifierChar,isIdentifierStart,Token,isNewLine,lineBreak,lineBreakG,nonASCIIwhitespace};const external_node_module_namespaceObject=require$$1$3,external_node_url_namespaceObject=(require$$3$2),external_node_assert_namespaceObject=require$$4$3,external_node_v8_namespaceObject=(require$$7$2),external_node_util_namespaceObject=require$$1$1;new Set(external_node_module_namespaceObject.builtinModules);function normalizeSlash(path){return path.replace(/\\/g,"/")}const own$1={}.hasOwnProperty,classRegExp=/^([A-Z][a-z\d]*)+$/,kTypes=new Set(["string","function","number","object","Function","Object","boolean","bigint","symbol"]);function formatList(array,type="and"){return array.length<3?array.join(` ${type} `):`${array.slice(0,-1).join(", ")}, ${type} ${array[array.length-1]}`}const messages=new Map;let userStackTraceLimit;function createError(sym,value,constructor){return messages.set(sym,value),function(Base,key){return NodeError;function NodeError(...parameters){const limit=Error.stackTraceLimit;isErrorStackTraceLimitWritable()&&(Error.stackTraceLimit=0);const error=new Base;isErrorStackTraceLimitWritable()&&(Error.stackTraceLimit=limit);const message=function(key,parameters,self){const message=messages.get(key);if(external_node_assert_namespaceObject(void 0!==message,"expected `message` to be found"),"function"==typeof message)return external_node_assert_namespaceObject(message.length<=parameters.length,`Code: ${key}; The provided arguments length (${parameters.length}) does not match the required ones (${message.length}).`),Reflect.apply(message,self,parameters);const regex=/%[dfijoOs]/g;let expectedLength=0;for(;null!==regex.exec(message);)expectedLength++;return external_node_assert_namespaceObject(expectedLength===parameters.length,`Code: ${key}; The provided arguments length (${parameters.length}) does not match the required ones (${expectedLength}).`),0===parameters.length?message:(parameters.unshift(message),Reflect.apply(external_node_util_namespaceObject.format,null,parameters))}(key,parameters,error);return Object.defineProperties(error,{message:{value:message,enumerable:false,writable:true,configurable:true},toString:{value(){return `${this.name} [${key}]: ${this.message}`},enumerable:false,writable:true,configurable:true}}),captureLargerStackTrace(error),error.code=key,error}}(constructor,sym)}function isErrorStackTraceLimitWritable(){try{if(external_node_v8_namespaceObject.startupSnapshot.isBuildingSnapshot())return !1}catch{}const desc=Object.getOwnPropertyDescriptor(Error,"stackTraceLimit");return void 0===desc?Object.isExtensible(Error):own$1.call(desc,"writable")&&void 0!==desc.writable?desc.writable:void 0!==desc.set}createError("ERR_INVALID_ARG_TYPE",((name,expected,actual)=>{external_node_assert_namespaceObject("string"==typeof name,"'name' must be a string"),Array.isArray(expected)||(expected=[expected]);let message="The ";if(name.endsWith(" argument"))message+=`${name} `;else {const type=name.includes(".")?"property":"argument";message+=`"${name}" ${type} `;}message+="must be ";const types=[],instances=[],other=[];for(const value of expected)external_node_assert_namespaceObject("string"==typeof value,"All expected entries have to be of type string"),kTypes.has(value)?types.push(value.toLowerCase()):null===classRegExp.exec(value)?(external_node_assert_namespaceObject("object"!==value,'The value "object" should be written as "Object"'),other.push(value)):instances.push(value);if(instances.length>0){const pos=types.indexOf("object");-1!==pos&&(types.slice(pos,1),instances.push("Object"));}return types.length>0&&(message+=`${types.length>1?"one of type":"of type"} ${formatList(types,"or")}`,(instances.length>0||other.length>0)&&(message+=" or ")),instances.length>0&&(message+=`an instance of ${formatList(instances,"or")}`,other.length>0&&(message+=" or ")),other.length>0&&(other.length>1?message+=`one of ${formatList(other,"or")}`:(other[0].toLowerCase()!==other[0]&&(message+="an "),message+=`${other[0]}`)),message+=`. Received ${function(value){if(null==value)return String(value);if("function"==typeof value&&value.name)return `function ${value.name}`;if("object"==typeof value)return value.constructor&&value.constructor.name?`an instance of ${value.constructor.name}`:`${(0, external_node_util_namespaceObject.inspect)(value,{depth:-1})}`;let inspected=(0, external_node_util_namespaceObject.inspect)(value,{colors:false});inspected.length>28&&(inspected=`${inspected.slice(0,25)}...`);return `type ${typeof value} (${inspected})`}(actual)}`,message}),TypeError),createError("ERR_INVALID_MODULE_SPECIFIER",((request,reason,base=void 0)=>`Invalid module "${request}" ${reason}${base?` imported from ${base}`:""}`),TypeError),createError("ERR_INVALID_PACKAGE_CONFIG",((path,base,message)=>`Invalid package config ${path}${base?` while importing ${base}`:""}${message?`. ${message}`:""}`),Error),createError("ERR_INVALID_PACKAGE_TARGET",((packagePath,key,target,isImport=false,base=void 0)=>{const relatedError="string"==typeof target&&!isImport&&target.length>0&&!target.startsWith("./");return "."===key?(external_node_assert_namespaceObject(false===isImport),`Invalid "exports" main target ${JSON.stringify(target)} defined in the package config ${packagePath}package.json${base?` imported from ${base}`:""}${relatedError?'; targets must start with "./"':""}`):`Invalid "${isImport?"imports":"exports"}" target ${JSON.stringify(target)} defined for '${key}' in the package config ${packagePath}package.json${base?` imported from ${base}`:""}${relatedError?'; targets must start with "./"':""}`}),Error),createError("ERR_MODULE_NOT_FOUND",((path,base,exactUrl=false)=>`Cannot find ${exactUrl?"module":"package"} '${path}' imported from ${base}`),Error),createError("ERR_NETWORK_IMPORT_DISALLOWED","import of '%s' by %s is not supported: %s",Error),createError("ERR_PACKAGE_IMPORT_NOT_DEFINED",((specifier,packagePath,base)=>`Package import specifier "${specifier}" is not defined${packagePath?` in package ${packagePath}package.json`:""} imported from ${base}`),TypeError),createError("ERR_PACKAGE_PATH_NOT_EXPORTED",((packagePath,subpath,base=void 0)=>"."===subpath?`No "exports" main defined in ${packagePath}package.json${base?` imported from ${base}`:""}`:`Package subpath '${subpath}' is not defined by "exports" in ${packagePath}package.json${base?` imported from ${base}`:""}`),Error),createError("ERR_UNSUPPORTED_DIR_IMPORT","Directory import '%s' is not supported resolving ES modules imported from %s",Error),createError("ERR_UNSUPPORTED_RESOLVE_REQUEST",'Failed to resolve module specifier "%s" from "%s": Invalid relative URL or base scheme is not hierarchical.',TypeError),createError("ERR_UNKNOWN_FILE_EXTENSION",((extension,path)=>`Unknown file extension "${extension}" for ${path}`),TypeError),createError("ERR_INVALID_ARG_VALUE",((name,value,reason="is invalid")=>{let inspected=(0, external_node_util_namespaceObject.inspect)(value);inspected.length>128&&(inspected=`${inspected.slice(0,128)}...`);return `The ${name.includes(".")?"property":"argument"} '${name}' ${reason}. Received ${inspected}`}),TypeError);const captureLargerStackTrace=function(wrappedFunction){const hidden="__node_internal_"+wrappedFunction.name;return Object.defineProperty(wrappedFunction,"name",{value:hidden}),wrappedFunction}((function(error){const stackTraceLimitIsWritable=isErrorStackTraceLimitWritable();return stackTraceLimitIsWritable&&(userStackTraceLimit=Error.stackTraceLimit,Error.stackTraceLimit=Number.POSITIVE_INFINITY),Error.captureStackTrace(error),stackTraceLimitIsWritable&&(Error.stackTraceLimit=userStackTraceLimit),error}));function fileURLToPath(id){return "string"!=typeof id||id.startsWith("file://")?normalizeSlash((0, external_node_url_namespaceObject.fileURLToPath)(id)):normalizeSlash(id)}function pathToFileURL(id){return (0, external_node_url_namespaceObject.pathToFileURL)(fileURLToPath(id)).toString()}function importMetaPathsPlugin(_ctx,opts){return {name:"import-meta-paths",visitor:{Program(path){const metaUrls=[],metaDirnames=[],metaFilenames=[];path.traverse({MemberExpression(memberExpPath){const{node}=memberExpPath;if("MetaProperty"===node.object.type&&"import"===node.object.meta.name&&"meta"===node.object.property.name&&"Identifier"===node.property.type)switch(node.property.name){case "url":metaUrls.push(memberExpPath);break;case "dirname":metaDirnames.push(memberExpPath);break;case "filename":metaFilenames.push(memberExpPath);}}});for(const meta of metaUrls)meta.replaceWith(template_lib.smart.ast`${opts.filename?JSON.stringify(pathToFileURL(opts.filename)):"require('url').pathToFileURL(__filename).toString()"}`);for(const metaDirname of metaDirnames)metaDirname.replaceWith(template_lib.smart.ast`${opts.filename?JSON.stringify(pathe_ff20891b_dirname(fileURLToPath(pathToFileURL(opts.filename)))):"__dirname"}`);for(const metaFilename of metaFilenames)metaFilename.replaceWith(template_lib.smart.ast`${opts.filename?JSON.stringify(fileURLToPath(pathToFileURL(opts.filename))):"__filename"}`);}}}}var helper_module_imports_lib=__webpack_require__("./node_modules/.pnpm/@babel+helper-module-imports@7.25.9/node_modules/@babel/helper-module-imports/lib/index.js"),helper_module_transforms_lib=__webpack_require__("./node_modules/.pnpm/@babel+helper-module-transforms@7.26.0_@babel+core@7.26.0/node_modules/@babel/helper-module-transforms/lib/index.js"),helper_simple_access_lib=__webpack_require__("./node_modules/.pnpm/@babel+helper-simple-access@7.25.9/node_modules/@babel/helper-simple-access/lib/index.js");function transformDynamicImport(path,noInterop,file){path.replaceWith((0, helper_module_transforms_lib.buildDynamicImport)(path.node,true,false,(specifier=>((source,file,noInterop)=>{const exp=lib.template.expression.ast`jitiImport(${source})`;return noInterop?exp:lib.types.callExpression(lib.types.memberExpression(exp,lib.types.identifier("then")),[lib.types.arrowFunctionExpression([lib.types.identifier("m")],lib.types.callExpression(file.addHelper("interopRequireWildcard"),[lib.types.identifier("m")]))])})(specifier,file,noInterop))));}const commonJSHooksKey="@babel/plugin-transform-modules-commonjs/customWrapperPlugin";function findMap(arr,cb){if(arr)for(const el of arr){const res=cb(el);if(null!=res)return res}}const transform_module=(0, helper_plugin_utils_lib.declare)(((api,options)=>{const{strictNamespace=false,mjsStrictNamespace=strictNamespace,allowTopLevelThis,strict,strictMode,noInterop,importInterop,lazy=false,allowCommonJSExports=true,loose=false,async=false}=options,constantReexports=api.assumption("constantReexports")??loose,enumerableModuleMeta=api.assumption("enumerableModuleMeta")??loose,noIncompleteNsImportDetection=api.assumption("noIncompleteNsImportDetection")??false;if(!("boolean"==typeof lazy||"function"==typeof lazy||Array.isArray(lazy)&&lazy.every((item=>"string"==typeof item))))throw new Error(".lazy must be a boolean, array of strings, or a function");if("boolean"!=typeof strictNamespace)throw new TypeError(".strictNamespace must be a boolean, or undefined");if("boolean"!=typeof mjsStrictNamespace)throw new TypeError(".mjsStrictNamespace must be a boolean, or undefined");const getAssertion=localName=>lib.template.expression.ast`
    (function(){
      throw new Error(
        "The CommonJS '" + "${localName}" + "' variable is not available in ES6 modules." +
        "Consider setting setting sourceType:script or sourceType:unambiguous in your " +
        "Babel config for this file.");
    })()
  `,moduleExportsVisitor={ReferencedIdentifier(path){const localName=path.node.name;if("module"!==localName&&"exports"!==localName)return;const localBinding=path.scope.getBinding(localName);this.scope.getBinding(localName)!==localBinding||path.parentPath.isObjectProperty({value:path.node})&&path.parentPath.parentPath.isObjectPattern()||path.parentPath.isAssignmentExpression({left:path.node})||path.isAssignmentExpression({left:path.node})||path.replaceWith(getAssertion(localName));},UpdateExpression(path){const arg=path.get("argument");if(!arg.isIdentifier())return;const localName=arg.node.name;if("module"!==localName&&"exports"!==localName)return;const localBinding=path.scope.getBinding(localName);this.scope.getBinding(localName)===localBinding&&path.replaceWith(lib.types.assignmentExpression(path.node.operator[0]+"=",arg.node,getAssertion(localName)));},AssignmentExpression(path){const left=path.get("left");if(left.isIdentifier()){const localName=left.node.name;if("module"!==localName&&"exports"!==localName)return;const localBinding=path.scope.getBinding(localName);if(this.scope.getBinding(localName)!==localBinding)return;const right=path.get("right");right.replaceWith(lib.types.sequenceExpression([right.node,getAssertion(localName)]));}else if(left.isPattern()){const ids=left.getOuterBindingIdentifiers(),localName=Object.keys(ids).find((localName=>("module"===localName||"exports"===localName)&&this.scope.getBinding(localName)===path.scope.getBinding(localName)));if(localName){const right=path.get("right");right.replaceWith(lib.types.sequenceExpression([right.node,getAssertion(localName)]));}}}};return {name:"transform-modules-commonjs",pre(){this.file.set("@babel/plugin-transform-modules-*","commonjs"),lazy&&function(file,hook){let hooks=file.get(commonJSHooksKey);hooks||file.set(commonJSHooksKey,hooks=[]),hooks.push(hook);}(this.file,(lazy=>({name:"babel-plugin-transform-modules-commonjs/lazy",version:"7.24.7",getWrapperPayload:(source,metadata)=>(0, helper_module_transforms_lib.isSideEffectImport)(metadata)||metadata.reexportAll?null:true===lazy?source.includes(".")?null:"lazy/function":Array.isArray(lazy)?lazy.includes(source)?"lazy/function":null:"function"==typeof lazy?lazy(source)?"lazy/function":null:void 0,buildRequireWrapper(name,init,payload,referenced){if("lazy/function"===payload)return !!referenced&&lib.template.statement.ast`
        function ${name}() {
          const data = ${init};
          ${name} = function(){ return data; };
          return data;
        }
      `},wrapReference(ref,payload){if("lazy/function"===payload)return lib.types.callExpression(ref,[])}}))(lazy));},visitor:{["CallExpression"+(api.types.importExpression?"|ImportExpression":"")](path){if(path.isCallExpression()&&!lib.types.isImport(path.node.callee))return;let{scope}=path;do{scope.rename("require");}while(scope=scope.parent);transformDynamicImport(path,noInterop,this.file);},Program:{exit(path,state){if(!(0, helper_module_imports_lib.isModule)(path))return;path.scope.rename("exports"),path.scope.rename("module"),path.scope.rename("require"),path.scope.rename("__filename"),path.scope.rename("__dirname"),allowCommonJSExports||(process.env.BABEL_8_BREAKING?(0, helper_simple_access_lib.A)(path,new Set(["module","exports"])):(0, helper_simple_access_lib.A)(path,new Set(["module","exports"]),false),path.traverse(moduleExportsVisitor,{scope:path.scope}));let moduleName=(0, helper_module_transforms_lib.getModuleName)(this.file.opts,options);moduleName&&(moduleName=lib.types.stringLiteral(moduleName));const hooks=function(file){const hooks=file.get(commonJSHooksKey);return {getWrapperPayload:(...args)=>findMap(hooks,(hook=>hook.getWrapperPayload?.(...args))),wrapReference:(...args)=>findMap(hooks,(hook=>hook.wrapReference?.(...args))),buildRequireWrapper:(...args)=>findMap(hooks,(hook=>hook.buildRequireWrapper?.(...args)))}}(this.file),{meta,headers}=(0, helper_module_transforms_lib.rewriteModuleStatementsAndPrepareHeader)(path,{exportName:"exports",constantReexports,enumerableModuleMeta,strict,strictMode,allowTopLevelThis,noInterop,importInterop,wrapReference:hooks.wrapReference,getWrapperPayload:hooks.getWrapperPayload,esNamespaceOnly:"string"==typeof state.filename&&/\.mjs$/.test(state.filename)?mjsStrictNamespace:strictNamespace,noIncompleteNsImportDetection,filename:this.file.opts.filename});for(const[source,metadata]of meta.source){const loadExpr=async?lib.types.awaitExpression(lib.types.callExpression(lib.types.identifier("jitiImport"),[lib.types.stringLiteral(source)])):lib.types.callExpression(lib.types.identifier("require"),[lib.types.stringLiteral(source)]);let header;if((0, helper_module_transforms_lib.isSideEffectImport)(metadata)){if(lazy&&"function"===metadata.wrap)throw new Error("Assertion failure");header=lib.types.expressionStatement(loadExpr);}else {const init=(0, helper_module_transforms_lib.wrapInterop)(path,loadExpr,metadata.interop)||loadExpr;if(metadata.wrap){const res=hooks.buildRequireWrapper(metadata.name,init,metadata.wrap,metadata.referenced);if(false===res)continue;header=res;}header??=lib.template.statement.ast`
                var ${metadata.name} = ${init};
              `;}header.loc=metadata.loc,headers.push(header),headers.push(...(0, helper_module_transforms_lib.buildNamespaceInitStatements)(meta,metadata,constantReexports,hooks.wrapReference));}(0, helper_module_transforms_lib.ensureStatementsHoisted)(headers),path.unshiftContainer("body",headers),path.get("body").forEach((path=>{headers.includes(path.node)&&path.isVariableDeclaration()&&path.scope.registerDeclaration(path);}));}}}}}));function transform(opts){const _opts={babelrc:false,configFile:false,compact:false,retainLines:"boolean"!=typeof opts.retainLines||opts.retainLines,filename:"",cwd:"/",...opts.babel,plugins:[[transform_module,{allowTopLevelThis:true,noInterop:!opts.interopDefault,async:opts.async}],[importMetaPathsPlugin,{filename:opts.filename}],[importMetaEnvPlugin],[importMetaResolvePlugin],[plugin_syntax_class_properties_lib.A],[plugin_transform_export_namespace_from_lib.A]]};opts.jsx&&_opts.plugins.push([plugin_syntax_jsx_lib.default],[plugin_transform_react_jsx_lib.A,Object.assign({},opts.jsx)]),opts.ts&&(_opts.plugins.push([plugin_transform_typescript_lib.default,{allowDeclareFields:true,isTSX:opts.jsx&&/\.[cm]?tsx$/.test(opts.filename||"")}]),_opts.plugins.unshift([babel_plugin_transform_typescript_metadata],[plugin_proposal_decorators_lib.A,{legacy:true}]),_opts.plugins.push(babel_plugin_parameter_decorator_lib_default()),_opts.plugins.push(plugin_syntax_import_assertions_lib.A)),opts.babel&&Array.isArray(opts.babel.plugins)&&_opts.plugins?.push(...opts.babel.plugins);try{return {code:(0,lib.transformSync)(opts.source,_opts)?.code||""}}catch(error){return {error,code:"exports.__JITI_ERROR__ = "+JSON.stringify({filename:opts.filename,line:error.loc?.line||0,column:error.loc?.column||0,code:error.code?.replace("BABEL_","").replace("PARSE_ERROR","ParseError"),message:error.message?.replace("/: ","").replace(/\(.+\)\s*$/,"")})}}}})(),module.exports=__webpack_exports__.default;})(); 
	} (babel));
	return babel.exports;
}

requireBabel();

// Load project .env
mainExports.config();

const INITIAL_CONFIG = loadUserConfig();
const NUXT_HUB_URL = process.env.NUXT_HUB_URL || INITIAL_CONFIG.hub?.url || 'https://admin.hub.nuxt.com';
const MAX_ASSET_SIZE = 25 * 1024 * 1024;
const MAX_UPLOAD_CHUNK_SIZE = 10 * 1024 * 1024; // 10MiB chunk size (in bytes)
const MAX_UPLOAD_ATTEMPTS = 5;
const UPLOAD_RETRY_DELAY = 1000;
const CONCURRENT_UPLOADS = 5;

function loadUserConfig () {
  return readUser('.nuxtrc')
}

function withTilde(path) {
  return path.replace(homedir$1(), '~/').replace(/\/{2,}/, '/')
}

const LogLevels = {
  fatal: 0,
  error: 0,
  warn: 1,
  log: 2,
  info: 3,
  success: 3,
  fail: 3,
  debug: 4,
  trace: 5,
  verbose: Number.POSITIVE_INFINITY
};
const LogTypes = {
  // Silent
  silent: {
    level: -1
  },
  // Level 0
  fatal: {
    level: LogLevels.fatal
  },
  error: {
    level: LogLevels.error
  },
  // Level 1
  warn: {
    level: LogLevels.warn
  },
  // Level 2
  log: {
    level: LogLevels.log
  },
  // Level 3
  info: {
    level: LogLevels.info
  },
  success: {
    level: LogLevels.success
  },
  fail: {
    level: LogLevels.fail
  },
  ready: {
    level: LogLevels.info
  },
  start: {
    level: LogLevels.info
  },
  box: {
    level: LogLevels.info
  },
  // Level 4
  debug: {
    level: LogLevels.debug
  },
  // Level 5
  trace: {
    level: LogLevels.trace
  },
  // Verbose
  verbose: {
    level: LogLevels.verbose
  }
};

function isPlainObject$1(value) {
  if (value === null || typeof value !== "object") {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  if (prototype !== null && prototype !== Object.prototype && Object.getPrototypeOf(prototype) !== null) {
    return false;
  }
  if (Symbol.iterator in value) {
    return false;
  }
  if (Symbol.toStringTag in value) {
    return Object.prototype.toString.call(value) === "[object Module]";
  }
  return true;
}

function _defu(baseObject, defaults, namespace = ".", merger) {
  if (!isPlainObject$1(defaults)) {
    return _defu(baseObject, {}, namespace);
  }
  const object = Object.assign({}, defaults);
  for (const key in baseObject) {
    if (key === "__proto__" || key === "constructor") {
      continue;
    }
    const value = baseObject[key];
    if (value === null || value === void 0) {
      continue;
    }
    if (Array.isArray(value) && Array.isArray(object[key])) {
      object[key] = [...value, ...object[key]];
    } else if (isPlainObject$1(value) && isPlainObject$1(object[key])) {
      object[key] = _defu(
        value,
        object[key],
        (namespace ? `${namespace}.` : "") + key.toString());
    } else {
      object[key] = value;
    }
  }
  return object;
}
function createDefu(merger) {
  return (...arguments_) => (
    // eslint-disable-next-line unicorn/no-array-reduce
    arguments_.reduce((p, c) => _defu(p, c, ""), {})
  );
}
const defu = createDefu();

function isPlainObject$2(obj) {
  return Object.prototype.toString.call(obj) === "[object Object]";
}
function isLogObj(arg) {
  if (!isPlainObject$2(arg)) {
    return false;
  }
  if (!arg.message && !arg.args) {
    return false;
  }
  if (arg.stack) {
    return false;
  }
  return true;
}

let paused = false;
const queue = [];
class Consola {
  options;
  _lastLog;
  _mockFn;
  /**
   * Creates an instance of Consola with specified options or defaults.
   *
   * @param {Partial<ConsolaOptions>} [options={}] - Configuration options for the Consola instance.
   */
  constructor(options = {}) {
    const types = options.types || LogTypes;
    this.options = defu(
      {
        ...options,
        defaults: { ...options.defaults },
        level: _normalizeLogLevel(options.level, types),
        reporters: [...options.reporters || []]
      },
      {
        types: LogTypes,
        throttle: 1e3,
        throttleMin: 5,
        formatOptions: {
          date: true,
          colors: false,
          compact: true
        }
      }
    );
    for (const type in types) {
      const defaults = {
        type,
        ...this.options.defaults,
        ...types[type]
      };
      this[type] = this._wrapLogFn(defaults);
      this[type].raw = this._wrapLogFn(
        defaults,
        true
      );
    }
    if (this.options.mockFn) {
      this.mockTypes();
    }
    this._lastLog = {};
  }
  /**
   * Gets the current log level of the Consola instance.
   *
   * @returns {number} The current log level.
   */
  get level() {
    return this.options.level;
  }
  /**
   * Sets the minimum log level that will be output by the instance.
   *
   * @param {number} level - The new log level to set.
   */
  set level(level) {
    this.options.level = _normalizeLogLevel(
      level,
      this.options.types,
      this.options.level
    );
  }
  /**
   * Displays a prompt to the user and returns the response.
   * Throw an error if `prompt` is not supported by the current configuration.
   *
   * @template T
   * @param {string} message - The message to display in the prompt.
   * @param {T} [opts] - Optional options for the prompt. See {@link PromptOptions}.
   * @returns {promise<T>} A promise that infer with the prompt options. See {@link PromptOptions}.
   */
  prompt(message, opts) {
    if (!this.options.prompt) {
      throw new Error("prompt is not supported!");
    }
    return this.options.prompt(message, opts);
  }
  /**
   * Creates a new instance of Consola, inheriting options from the current instance, with possible overrides.
   *
   * @param {Partial<ConsolaOptions>} options - Optional overrides for the new instance. See {@link ConsolaOptions}.
   * @returns {ConsolaInstance} A new Consola instance. See {@link ConsolaInstance}.
   */
  create(options) {
    const instance = new Consola({
      ...this.options,
      ...options
    });
    if (this._mockFn) {
      instance.mockTypes(this._mockFn);
    }
    return instance;
  }
  /**
   * Creates a new Consola instance with the specified default log object properties.
   *
   * @param {InputLogObject} defaults - Default properties to include in any log from the new instance. See {@link InputLogObject}.
   * @returns {ConsolaInstance} A new Consola instance. See {@link ConsolaInstance}.
   */
  withDefaults(defaults) {
    return this.create({
      ...this.options,
      defaults: {
        ...this.options.defaults,
        ...defaults
      }
    });
  }
  /**
   * Creates a new Consola instance with a specified tag, which will be included in every log.
   *
   * @param {string} tag - The tag to include in each log of the new instance.
   * @returns {ConsolaInstance} A new Consola instance. See {@link ConsolaInstance}.
   */
  withTag(tag) {
    return this.withDefaults({
      tag: this.options.defaults.tag ? this.options.defaults.tag + ":" + tag : tag
    });
  }
  /**
   * Adds a custom reporter to the Consola instance.
   * Reporters will be called for each log message, depending on their implementation and log level.
   *
   * @param {ConsolaReporter} reporter - The reporter to add. See {@link ConsolaReporter}.
   * @returns {Consola} The current Consola instance.
   */
  addReporter(reporter) {
    this.options.reporters.push(reporter);
    return this;
  }
  /**
   * Removes a custom reporter from the Consola instance.
   * If no reporter is specified, all reporters will be removed.
   *
   * @param {ConsolaReporter} reporter - The reporter to remove. See {@link ConsolaReporter}.
   * @returns {Consola} The current Consola instance.
   */
  removeReporter(reporter) {
    if (reporter) {
      const i = this.options.reporters.indexOf(reporter);
      if (i !== -1) {
        return this.options.reporters.splice(i, 1);
      }
    } else {
      this.options.reporters.splice(0);
    }
    return this;
  }
  /**
   * Replaces all reporters of the Consola instance with the specified array of reporters.
   *
   * @param {ConsolaReporter[]} reporters - The new reporters to set. See {@link ConsolaReporter}.
   * @returns {Consola} The current Consola instance.
   */
  setReporters(reporters) {
    this.options.reporters = Array.isArray(reporters) ? reporters : [reporters];
    return this;
  }
  wrapAll() {
    this.wrapConsole();
    this.wrapStd();
  }
  restoreAll() {
    this.restoreConsole();
    this.restoreStd();
  }
  /**
   * Overrides console methods with Consola logging methods for consistent logging.
   */
  wrapConsole() {
    for (const type in this.options.types) {
      if (!console["__" + type]) {
        console["__" + type] = console[type];
      }
      console[type] = this[type].raw;
    }
  }
  /**
   * Restores the original console methods, removing Consola overrides.
   */
  restoreConsole() {
    for (const type in this.options.types) {
      if (console["__" + type]) {
        console[type] = console["__" + type];
        delete console["__" + type];
      }
    }
  }
  /**
   * Overrides standard output and error streams to redirect them through Consola.
   */
  wrapStd() {
    this._wrapStream(this.options.stdout, "log");
    this._wrapStream(this.options.stderr, "log");
  }
  _wrapStream(stream, type) {
    if (!stream) {
      return;
    }
    if (!stream.__write) {
      stream.__write = stream.write;
    }
    stream.write = (data) => {
      this[type].raw(String(data).trim());
    };
  }
  /**
   * Restores the original standard output and error streams, removing the Consola redirection.
   */
  restoreStd() {
    this._restoreStream(this.options.stdout);
    this._restoreStream(this.options.stderr);
  }
  _restoreStream(stream) {
    if (!stream) {
      return;
    }
    if (stream.__write) {
      stream.write = stream.__write;
      delete stream.__write;
    }
  }
  /**
   * Pauses logging, queues incoming logs until resumed.
   */
  pauseLogs() {
    paused = true;
  }
  /**
   * Resumes logging, processing any queued logs.
   */
  resumeLogs() {
    paused = false;
    const _queue = queue.splice(0);
    for (const item of _queue) {
      item[0]._logFn(item[1], item[2]);
    }
  }
  /**
   * Replaces logging methods with mocks if a mock function is provided.
   *
   * @param {ConsolaOptions["mockFn"]} mockFn - The function to use for mocking logging methods. See {@link ConsolaOptions["mockFn"]}.
   */
  mockTypes(mockFn) {
    const _mockFn = mockFn || this.options.mockFn;
    this._mockFn = _mockFn;
    if (typeof _mockFn !== "function") {
      return;
    }
    for (const type in this.options.types) {
      this[type] = _mockFn(type, this.options.types[type]) || this[type];
      this[type].raw = this[type];
    }
  }
  _wrapLogFn(defaults, isRaw) {
    return (...args) => {
      if (paused) {
        queue.push([this, defaults, args, isRaw]);
        return;
      }
      return this._logFn(defaults, args, isRaw);
    };
  }
  _logFn(defaults, args, isRaw) {
    if ((defaults.level || 0) > this.level) {
      return false;
    }
    const logObj = {
      date: /* @__PURE__ */ new Date(),
      args: [],
      ...defaults,
      level: _normalizeLogLevel(defaults.level, this.options.types)
    };
    if (!isRaw && args.length === 1 && isLogObj(args[0])) {
      Object.assign(logObj, args[0]);
    } else {
      logObj.args = [...args];
    }
    if (logObj.message) {
      logObj.args.unshift(logObj.message);
      delete logObj.message;
    }
    if (logObj.additional) {
      if (!Array.isArray(logObj.additional)) {
        logObj.additional = logObj.additional.split("\n");
      }
      logObj.args.push("\n" + logObj.additional.join("\n"));
      delete logObj.additional;
    }
    logObj.type = typeof logObj.type === "string" ? logObj.type.toLowerCase() : "log";
    logObj.tag = typeof logObj.tag === "string" ? logObj.tag : "";
    const resolveLog = (newLog = false) => {
      const repeated = (this._lastLog.count || 0) - this.options.throttleMin;
      if (this._lastLog.object && repeated > 0) {
        const args2 = [...this._lastLog.object.args];
        if (repeated > 1) {
          args2.push(`(repeated ${repeated} times)`);
        }
        this._log({ ...this._lastLog.object, args: args2 });
        this._lastLog.count = 1;
      }
      if (newLog) {
        this._lastLog.object = logObj;
        this._log(logObj);
      }
    };
    clearTimeout(this._lastLog.timeout);
    const diffTime = this._lastLog.time && logObj.date ? logObj.date.getTime() - this._lastLog.time.getTime() : 0;
    this._lastLog.time = logObj.date;
    if (diffTime < this.options.throttle) {
      try {
        const serializedLog = JSON.stringify([
          logObj.type,
          logObj.tag,
          logObj.args
        ]);
        const isSameLog = this._lastLog.serialized === serializedLog;
        this._lastLog.serialized = serializedLog;
        if (isSameLog) {
          this._lastLog.count = (this._lastLog.count || 0) + 1;
          if (this._lastLog.count > this.options.throttleMin) {
            this._lastLog.timeout = setTimeout(
              resolveLog,
              this.options.throttle
            );
            return;
          }
        }
      } catch {
      }
    }
    resolveLog(true);
  }
  _log(logObj) {
    for (const reporter of this.options.reporters) {
      reporter.log(logObj, {
        options: this.options
      });
    }
  }
}
function _normalizeLogLevel(input, types = {}, defaultLevel = 3) {
  if (input === void 0) {
    return defaultLevel;
  }
  if (typeof input === "number") {
    return input;
  }
  if (types[input] && types[input].level !== void 0) {
    return types[input].level;
  }
  return defaultLevel;
}
Consola.prototype.add = Consola.prototype.addReporter;
Consola.prototype.remove = Consola.prototype.removeReporter;
Consola.prototype.clear = Consola.prototype.removeReporter;
Consola.prototype.withScope = Consola.prototype.withTag;
Consola.prototype.mock = Consola.prototype.mockTypes;
Consola.prototype.pause = Consola.prototype.pauseLogs;
Consola.prototype.resume = Consola.prototype.resumeLogs;
function createConsola$1(options = {}) {
  return new Consola(options);
}

function parseStack(stack, message) {
  const cwd = process.cwd() + sep;
  const lines = stack.split("\n").splice(message.split("\n").length).map((l) => l.trim().replace("file://", "").replace(cwd, ""));
  return lines;
}

function writeStream(data, stream) {
  const write = stream.__write || stream.write;
  return write.call(stream, data);
}

const bracket = (x) => x ? `[${x}]` : "";
class BasicReporter {
  formatStack(stack, message, opts) {
    const indent = "  ".repeat((opts?.errorLevel || 0) + 1);
    return indent + parseStack(stack, message).join(`
${indent}`);
  }
  formatError(err, opts) {
    const message = err.message ?? formatWithOptions(opts, err);
    const stack = err.stack ? this.formatStack(err.stack, message, opts) : "";
    const level = opts?.errorLevel || 0;
    const causedPrefix = level > 0 ? `${"  ".repeat(level)}[cause]: ` : "";
    const causedError = err.cause ? "\n\n" + this.formatError(err.cause, { ...opts, errorLevel: level + 1 }) : "";
    return causedPrefix + message + "\n" + stack + causedError;
  }
  formatArgs(args, opts) {
    const _args = args.map((arg) => {
      if (arg && typeof arg.stack === "string") {
        return this.formatError(arg, opts);
      }
      return arg;
    });
    return formatWithOptions(opts, ..._args);
  }
  formatDate(date, opts) {
    return opts.date ? date.toLocaleTimeString() : "";
  }
  filterAndJoin(arr) {
    return arr.filter(Boolean).join(" ");
  }
  formatLogObj(logObj, opts) {
    const message = this.formatArgs(logObj.args, opts);
    if (logObj.type === "box") {
      return "\n" + [
        bracket(logObj.tag),
        logObj.title && logObj.title,
        ...message.split("\n")
      ].filter(Boolean).map((l) => " > " + l).join("\n") + "\n";
    }
    return this.filterAndJoin([
      bracket(logObj.type),
      bracket(logObj.tag),
      message
    ]);
  }
  log(logObj, ctx) {
    const line = this.formatLogObj(logObj, {
      columns: ctx.options.stdout.columns || 0,
      ...ctx.options.formatOptions
    });
    return writeStream(
      line + "\n",
      logObj.level < 2 ? ctx.options.stderr || process.stderr : ctx.options.stdout || process.stdout
    );
  }
}

const {
  env = {},
  argv = [],
  platform = ""
} = typeof process === "undefined" ? {} : process;
const isDisabled = "NO_COLOR" in env || argv.includes("--no-color");
const isForced = "FORCE_COLOR" in env || argv.includes("--color");
const isWindows = platform === "win32";
const isDumbTerminal = env.TERM === "dumb";
const isCompatibleTerminal = tty && tty.isatty && tty.isatty(1) && env.TERM && !isDumbTerminal;
const isCI = "CI" in env && ("GITHUB_ACTIONS" in env || "GITLAB_CI" in env || "CIRCLECI" in env);
const isColorSupported = !isDisabled && (isForced || isWindows && !isDumbTerminal || isCompatibleTerminal || isCI);
function replaceClose(index, string, close, replace, head = string.slice(0, Math.max(0, index)) + replace, tail = string.slice(Math.max(0, index + close.length)), next = tail.indexOf(close)) {
  return head + (next < 0 ? tail : replaceClose(next, tail, close, replace));
}
function clearBleed(index, string, open, close, replace) {
  return index < 0 ? open + string + close : open + replaceClose(index, string, close, replace) + close;
}
function filterEmpty(open, close, replace = open, at = open.length + 1) {
  return (string) => string || !(string === "" || string === void 0) ? clearBleed(
    ("" + string).indexOf(close, at),
    string,
    open,
    close,
    replace
  ) : "";
}
function init(open, close, replace) {
  return filterEmpty(`\x1B[${open}m`, `\x1B[${close}m`, replace);
}
const colorDefs = {
  reset: init(0, 0),
  bold: init(1, 22, "\x1B[22m\x1B[1m"),
  dim: init(2, 22, "\x1B[22m\x1B[2m"),
  italic: init(3, 23),
  underline: init(4, 24),
  inverse: init(7, 27),
  hidden: init(8, 28),
  strikethrough: init(9, 29),
  black: init(30, 39),
  red: init(31, 39),
  green: init(32, 39),
  yellow: init(33, 39),
  blue: init(34, 39),
  magenta: init(35, 39),
  cyan: init(36, 39),
  white: init(37, 39),
  gray: init(90, 39),
  bgBlack: init(40, 49),
  bgRed: init(41, 49),
  bgGreen: init(42, 49),
  bgYellow: init(43, 49),
  bgBlue: init(44, 49),
  bgMagenta: init(45, 49),
  bgCyan: init(46, 49),
  bgWhite: init(47, 49),
  blackBright: init(90, 39),
  redBright: init(91, 39),
  greenBright: init(92, 39),
  yellowBright: init(93, 39),
  blueBright: init(94, 39),
  magentaBright: init(95, 39),
  cyanBright: init(96, 39),
  whiteBright: init(97, 39),
  bgBlackBright: init(100, 49),
  bgRedBright: init(101, 49),
  bgGreenBright: init(102, 49),
  bgYellowBright: init(103, 49),
  bgBlueBright: init(104, 49),
  bgMagentaBright: init(105, 49),
  bgCyanBright: init(106, 49),
  bgWhiteBright: init(107, 49)
};
function createColors(useColor = isColorSupported) {
  return useColor ? colorDefs : Object.fromEntries(Object.keys(colorDefs).map((key) => [key, String]));
}
const colors = createColors();
function getColor$1(color, fallback = "reset") {
  return colors[color] || colors[fallback];
}

const ansiRegex$1 = [
  String.raw`[\u001B\u009B][[\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\d\/#&.:=?%@~_]+)*|[a-zA-Z\d]+(?:;[-a-zA-Z\d\/#&.:=?%@~_]*)*)?\u0007)`,
  String.raw`(?:(?:\d{1,4}(?:;\d{0,4})*)?[\dA-PR-TZcf-nq-uy=><~]))`
].join("|");
function stripAnsi$1(text) {
  return text.replace(new RegExp(ansiRegex$1, "g"), "");
}

const boxStylePresets = {
  solid: {
    tl: "\u250C",
    tr: "\u2510",
    bl: "\u2514",
    br: "\u2518",
    h: "\u2500",
    v: "\u2502"
  },
  double: {
    tl: "\u2554",
    tr: "\u2557",
    bl: "\u255A",
    br: "\u255D",
    h: "\u2550",
    v: "\u2551"
  },
  doubleSingle: {
    tl: "\u2553",
    tr: "\u2556",
    bl: "\u2559",
    br: "\u255C",
    h: "\u2500",
    v: "\u2551"
  },
  doubleSingleRounded: {
    tl: "\u256D",
    tr: "\u256E",
    bl: "\u2570",
    br: "\u256F",
    h: "\u2500",
    v: "\u2551"
  },
  singleThick: {
    tl: "\u250F",
    tr: "\u2513",
    bl: "\u2517",
    br: "\u251B",
    h: "\u2501",
    v: "\u2503"
  },
  singleDouble: {
    tl: "\u2552",
    tr: "\u2555",
    bl: "\u2558",
    br: "\u255B",
    h: "\u2550",
    v: "\u2502"
  },
  singleDoubleRounded: {
    tl: "\u256D",
    tr: "\u256E",
    bl: "\u2570",
    br: "\u256F",
    h: "\u2550",
    v: "\u2502"
  },
  rounded: {
    tl: "\u256D",
    tr: "\u256E",
    bl: "\u2570",
    br: "\u256F",
    h: "\u2500",
    v: "\u2502"
  }
};
const defaultStyle = {
  borderColor: "white",
  borderStyle: "rounded",
  valign: "center",
  padding: 2,
  marginLeft: 1,
  marginTop: 1,
  marginBottom: 1
};
function box(text, _opts = {}) {
  const opts = {
    ..._opts,
    style: {
      ...defaultStyle,
      ..._opts.style
    }
  };
  const textLines = text.split("\n");
  const boxLines = [];
  const _color = getColor$1(opts.style.borderColor);
  const borderStyle = {
    ...typeof opts.style.borderStyle === "string" ? boxStylePresets[opts.style.borderStyle] || boxStylePresets.solid : opts.style.borderStyle
  };
  if (_color) {
    for (const key in borderStyle) {
      borderStyle[key] = _color(
        borderStyle[key]
      );
    }
  }
  const paddingOffset = opts.style.padding % 2 === 0 ? opts.style.padding : opts.style.padding + 1;
  const height = textLines.length + paddingOffset;
  const width = Math.max(
    ...textLines.map((line) => stripAnsi$1(line).length),
    opts.title ? stripAnsi$1(opts.title).length : 0
  ) + paddingOffset;
  const widthOffset = width + paddingOffset;
  const leftSpace = opts.style.marginLeft > 0 ? " ".repeat(opts.style.marginLeft) : "";
  if (opts.style.marginTop > 0) {
    boxLines.push("".repeat(opts.style.marginTop));
  }
  if (opts.title) {
    const title = _color ? _color(opts.title) : opts.title;
    const left = borderStyle.h.repeat(
      Math.floor((width - stripAnsi$1(opts.title).length) / 2)
    );
    const right = borderStyle.h.repeat(
      width - stripAnsi$1(opts.title).length - stripAnsi$1(left).length + paddingOffset
    );
    boxLines.push(
      `${leftSpace}${borderStyle.tl}${left}${title}${right}${borderStyle.tr}`
    );
  } else {
    boxLines.push(
      `${leftSpace}${borderStyle.tl}${borderStyle.h.repeat(widthOffset)}${borderStyle.tr}`
    );
  }
  const valignOffset = opts.style.valign === "center" ? Math.floor((height - textLines.length) / 2) : opts.style.valign === "top" ? height - textLines.length - paddingOffset : height - textLines.length;
  for (let i = 0; i < height; i++) {
    if (i < valignOffset || i >= valignOffset + textLines.length) {
      boxLines.push(
        `${leftSpace}${borderStyle.v}${" ".repeat(widthOffset)}${borderStyle.v}`
      );
    } else {
      const line = textLines[i - valignOffset];
      const left = " ".repeat(paddingOffset);
      const right = " ".repeat(width - stripAnsi$1(line).length);
      boxLines.push(
        `${leftSpace}${borderStyle.v}${left}${line}${right}${borderStyle.v}`
      );
    }
  }
  boxLines.push(
    `${leftSpace}${borderStyle.bl}${borderStyle.h.repeat(widthOffset)}${borderStyle.br}`
  );
  if (opts.style.marginBottom > 0) {
    boxLines.push("".repeat(opts.style.marginBottom));
  }
  return boxLines.join("\n");
}

const r=Object.create(null),i$1=e=>globalThis.process?.env||import.meta.env||globalThis.Deno?.env.toObject()||globalThis.__env__||(e?r:globalThis),o$2=new Proxy(r,{get(e,s){return i$1()[s]??r[s]},has(e,s){const E=i$1();return s in E||s in r},set(e,s,E){const B=i$1(true);return B[s]=E,true},deleteProperty(e,s){if(!s)return  false;const E=i$1(true);return delete E[s],true},ownKeys(){const e=i$1(true);return Object.keys(e)}}),t=typeof process<"u"&&process.env&&process.env.NODE_ENV||"",f=[["APPVEYOR"],["AWS_AMPLIFY","AWS_APP_ID",{ci:true}],["AZURE_PIPELINES","SYSTEM_TEAMFOUNDATIONCOLLECTIONURI"],["AZURE_STATIC","INPUT_AZURE_STATIC_WEB_APPS_API_TOKEN"],["APPCIRCLE","AC_APPCIRCLE"],["BAMBOO","bamboo_planKey"],["BITBUCKET","BITBUCKET_COMMIT"],["BITRISE","BITRISE_IO"],["BUDDY","BUDDY_WORKSPACE_ID"],["BUILDKITE"],["CIRCLE","CIRCLECI"],["CIRRUS","CIRRUS_CI"],["CLOUDFLARE_PAGES","CF_PAGES",{ci:true}],["CODEBUILD","CODEBUILD_BUILD_ARN"],["CODEFRESH","CF_BUILD_ID"],["DRONE"],["DRONE","DRONE_BUILD_EVENT"],["DSARI"],["GITHUB_ACTIONS"],["GITLAB","GITLAB_CI"],["GITLAB","CI_MERGE_REQUEST_ID"],["GOCD","GO_PIPELINE_LABEL"],["LAYERCI"],["HUDSON","HUDSON_URL"],["JENKINS","JENKINS_URL"],["MAGNUM"],["NETLIFY"],["NETLIFY","NETLIFY_LOCAL",{ci:false}],["NEVERCODE"],["RENDER"],["SAIL","SAILCI"],["SEMAPHORE"],["SCREWDRIVER"],["SHIPPABLE"],["SOLANO","TDDIUM"],["STRIDER"],["TEAMCITY","TEAMCITY_VERSION"],["TRAVIS"],["VERCEL","NOW_BUILDER"],["VERCEL","VERCEL",{ci:false}],["VERCEL","VERCEL_ENV",{ci:false}],["APPCENTER","APPCENTER_BUILD_ID"],["CODESANDBOX","CODESANDBOX_SSE",{ci:false}],["CODESANDBOX","CODESANDBOX_HOST",{ci:false}],["STACKBLITZ"],["STORMKIT"],["CLEAVR"],["ZEABUR"],["CODESPHERE","CODESPHERE_APP_ID",{ci:true}],["RAILWAY","RAILWAY_PROJECT_ID"],["RAILWAY","RAILWAY_SERVICE_ID"],["DENO-DEPLOY","DENO_DEPLOYMENT_ID"],["FIREBASE_APP_HOSTING","FIREBASE_APP_HOSTING",{ci:true}]];function b(){if(globalThis.process?.env)for(const e of f){const s=e[1]||e[0];if(globalThis.process?.env[s])return {name:e[0].toLowerCase(),...e[2]}}return globalThis.process?.env?.SHELL==="/bin/jsh"&&globalThis.process?.versions?.webcontainer?{name:"stackblitz",ci:false}:{name:"",ci:false}}const l=b();l.name;function n$1(e){return e?e!=="false":false}const I$1=globalThis.process?.platform||"",T=n$1(o$2.CI)||l.ci!==false,a$1=n$1(globalThis.process?.stdout&&globalThis.process?.stdout.isTTY),g=n$1(o$2.DEBUG),R$1=t==="test"||n$1(o$2.TEST);n$1(o$2.MINIMAL)||T||R$1||!a$1;const A=/^win/i.test(I$1);!n$1(o$2.NO_COLOR)&&(n$1(o$2.FORCE_COLOR)||(a$1||A)&&o$2.TERM!=="dumb"||T);const C$1=(globalThis.process?.versions?.node||"").replace(/^v/,"")||null;Number(C$1?.split(".")[0])||null;const y=globalThis.process||Object.create(null),_={versions:{}};new Proxy(y,{get(e,s){if(s==="env")return o$2;if(s in e)return e[s];if(s in _)return _[s]}});const c$1=globalThis.process?.release?.name==="node",O=!!globalThis.Bun||!!globalThis.process?.versions?.bun,D=!!globalThis.Deno,L$1=!!globalThis.fastly,S=!!globalThis.Netlify,u$2=!!globalThis.EdgeRuntime,N$1=globalThis.navigator?.userAgent==="Cloudflare-Workers",F=[[S,"netlify"],[u$2,"edge-light"],[N$1,"workerd"],[L$1,"fastly"],[D,"deno"],[O,"bun"],[c$1,"node"]];function G(){const e=F.find(s=>s[0]);if(e)return {name:e[1]}}const P=G();P?.name||"";

function ansiRegex({onlyFirst = false} = {}) {
	// Valid string terminator sequences are BEL, ESC\, and 0x9c
	const ST = '(?:\\u0007|\\u001B\\u005C|\\u009C)';
	const pattern = [
		`[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?${ST})`,
		'(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))',
	].join('|');

	return new RegExp(pattern, onlyFirst ? undefined : 'g');
}

const regex = ansiRegex();

function stripAnsi(string) {
	if (typeof string !== 'string') {
		throw new TypeError(`Expected a \`string\`, got \`${typeof string}\``);
	}

	// Even though the regex is global, we don't need to reset the `.lastIndex`
	// because unlike `.exec()` and `.test()`, `.replace()` does it automatically
	// and doing it manually has a performance penalty.
	return string.replace(regex, '');
}

// Generated code.

function isAmbiguous(x) {
	return x === 0xA1
		|| x === 0xA4
		|| x === 0xA7
		|| x === 0xA8
		|| x === 0xAA
		|| x === 0xAD
		|| x === 0xAE
		|| x >= 0xB0 && x <= 0xB4
		|| x >= 0xB6 && x <= 0xBA
		|| x >= 0xBC && x <= 0xBF
		|| x === 0xC6
		|| x === 0xD0
		|| x === 0xD7
		|| x === 0xD8
		|| x >= 0xDE && x <= 0xE1
		|| x === 0xE6
		|| x >= 0xE8 && x <= 0xEA
		|| x === 0xEC
		|| x === 0xED
		|| x === 0xF0
		|| x === 0xF2
		|| x === 0xF3
		|| x >= 0xF7 && x <= 0xFA
		|| x === 0xFC
		|| x === 0xFE
		|| x === 0x101
		|| x === 0x111
		|| x === 0x113
		|| x === 0x11B
		|| x === 0x126
		|| x === 0x127
		|| x === 0x12B
		|| x >= 0x131 && x <= 0x133
		|| x === 0x138
		|| x >= 0x13F && x <= 0x142
		|| x === 0x144
		|| x >= 0x148 && x <= 0x14B
		|| x === 0x14D
		|| x === 0x152
		|| x === 0x153
		|| x === 0x166
		|| x === 0x167
		|| x === 0x16B
		|| x === 0x1CE
		|| x === 0x1D0
		|| x === 0x1D2
		|| x === 0x1D4
		|| x === 0x1D6
		|| x === 0x1D8
		|| x === 0x1DA
		|| x === 0x1DC
		|| x === 0x251
		|| x === 0x261
		|| x === 0x2C4
		|| x === 0x2C7
		|| x >= 0x2C9 && x <= 0x2CB
		|| x === 0x2CD
		|| x === 0x2D0
		|| x >= 0x2D8 && x <= 0x2DB
		|| x === 0x2DD
		|| x === 0x2DF
		|| x >= 0x300 && x <= 0x36F
		|| x >= 0x391 && x <= 0x3A1
		|| x >= 0x3A3 && x <= 0x3A9
		|| x >= 0x3B1 && x <= 0x3C1
		|| x >= 0x3C3 && x <= 0x3C9
		|| x === 0x401
		|| x >= 0x410 && x <= 0x44F
		|| x === 0x451
		|| x === 0x2010
		|| x >= 0x2013 && x <= 0x2016
		|| x === 0x2018
		|| x === 0x2019
		|| x === 0x201C
		|| x === 0x201D
		|| x >= 0x2020 && x <= 0x2022
		|| x >= 0x2024 && x <= 0x2027
		|| x === 0x2030
		|| x === 0x2032
		|| x === 0x2033
		|| x === 0x2035
		|| x === 0x203B
		|| x === 0x203E
		|| x === 0x2074
		|| x === 0x207F
		|| x >= 0x2081 && x <= 0x2084
		|| x === 0x20AC
		|| x === 0x2103
		|| x === 0x2105
		|| x === 0x2109
		|| x === 0x2113
		|| x === 0x2116
		|| x === 0x2121
		|| x === 0x2122
		|| x === 0x2126
		|| x === 0x212B
		|| x === 0x2153
		|| x === 0x2154
		|| x >= 0x215B && x <= 0x215E
		|| x >= 0x2160 && x <= 0x216B
		|| x >= 0x2170 && x <= 0x2179
		|| x === 0x2189
		|| x >= 0x2190 && x <= 0x2199
		|| x === 0x21B8
		|| x === 0x21B9
		|| x === 0x21D2
		|| x === 0x21D4
		|| x === 0x21E7
		|| x === 0x2200
		|| x === 0x2202
		|| x === 0x2203
		|| x === 0x2207
		|| x === 0x2208
		|| x === 0x220B
		|| x === 0x220F
		|| x === 0x2211
		|| x === 0x2215
		|| x === 0x221A
		|| x >= 0x221D && x <= 0x2220
		|| x === 0x2223
		|| x === 0x2225
		|| x >= 0x2227 && x <= 0x222C
		|| x === 0x222E
		|| x >= 0x2234 && x <= 0x2237
		|| x === 0x223C
		|| x === 0x223D
		|| x === 0x2248
		|| x === 0x224C
		|| x === 0x2252
		|| x === 0x2260
		|| x === 0x2261
		|| x >= 0x2264 && x <= 0x2267
		|| x === 0x226A
		|| x === 0x226B
		|| x === 0x226E
		|| x === 0x226F
		|| x === 0x2282
		|| x === 0x2283
		|| x === 0x2286
		|| x === 0x2287
		|| x === 0x2295
		|| x === 0x2299
		|| x === 0x22A5
		|| x === 0x22BF
		|| x === 0x2312
		|| x >= 0x2460 && x <= 0x24E9
		|| x >= 0x24EB && x <= 0x254B
		|| x >= 0x2550 && x <= 0x2573
		|| x >= 0x2580 && x <= 0x258F
		|| x >= 0x2592 && x <= 0x2595
		|| x === 0x25A0
		|| x === 0x25A1
		|| x >= 0x25A3 && x <= 0x25A9
		|| x === 0x25B2
		|| x === 0x25B3
		|| x === 0x25B6
		|| x === 0x25B7
		|| x === 0x25BC
		|| x === 0x25BD
		|| x === 0x25C0
		|| x === 0x25C1
		|| x >= 0x25C6 && x <= 0x25C8
		|| x === 0x25CB
		|| x >= 0x25CE && x <= 0x25D1
		|| x >= 0x25E2 && x <= 0x25E5
		|| x === 0x25EF
		|| x === 0x2605
		|| x === 0x2606
		|| x === 0x2609
		|| x === 0x260E
		|| x === 0x260F
		|| x === 0x261C
		|| x === 0x261E
		|| x === 0x2640
		|| x === 0x2642
		|| x === 0x2660
		|| x === 0x2661
		|| x >= 0x2663 && x <= 0x2665
		|| x >= 0x2667 && x <= 0x266A
		|| x === 0x266C
		|| x === 0x266D
		|| x === 0x266F
		|| x === 0x269E
		|| x === 0x269F
		|| x === 0x26BF
		|| x >= 0x26C6 && x <= 0x26CD
		|| x >= 0x26CF && x <= 0x26D3
		|| x >= 0x26D5 && x <= 0x26E1
		|| x === 0x26E3
		|| x === 0x26E8
		|| x === 0x26E9
		|| x >= 0x26EB && x <= 0x26F1
		|| x === 0x26F4
		|| x >= 0x26F6 && x <= 0x26F9
		|| x === 0x26FB
		|| x === 0x26FC
		|| x === 0x26FE
		|| x === 0x26FF
		|| x === 0x273D
		|| x >= 0x2776 && x <= 0x277F
		|| x >= 0x2B56 && x <= 0x2B59
		|| x >= 0x3248 && x <= 0x324F
		|| x >= 0xE000 && x <= 0xF8FF
		|| x >= 0xFE00 && x <= 0xFE0F
		|| x === 0xFFFD
		|| x >= 0x1F100 && x <= 0x1F10A
		|| x >= 0x1F110 && x <= 0x1F12D
		|| x >= 0x1F130 && x <= 0x1F169
		|| x >= 0x1F170 && x <= 0x1F18D
		|| x === 0x1F18F
		|| x === 0x1F190
		|| x >= 0x1F19B && x <= 0x1F1AC
		|| x >= 0xE0100 && x <= 0xE01EF
		|| x >= 0xF0000 && x <= 0xFFFFD
		|| x >= 0x100000 && x <= 0x10FFFD;
}

function isFullWidth(x) {
	return x === 0x3000
		|| x >= 0xFF01 && x <= 0xFF60
		|| x >= 0xFFE0 && x <= 0xFFE6;
}

function isWide(x) {
	return x >= 0x1100 && x <= 0x115F
		|| x === 0x231A
		|| x === 0x231B
		|| x === 0x2329
		|| x === 0x232A
		|| x >= 0x23E9 && x <= 0x23EC
		|| x === 0x23F0
		|| x === 0x23F3
		|| x === 0x25FD
		|| x === 0x25FE
		|| x === 0x2614
		|| x === 0x2615
		|| x >= 0x2630 && x <= 0x2637
		|| x >= 0x2648 && x <= 0x2653
		|| x === 0x267F
		|| x >= 0x268A && x <= 0x268F
		|| x === 0x2693
		|| x === 0x26A1
		|| x === 0x26AA
		|| x === 0x26AB
		|| x === 0x26BD
		|| x === 0x26BE
		|| x === 0x26C4
		|| x === 0x26C5
		|| x === 0x26CE
		|| x === 0x26D4
		|| x === 0x26EA
		|| x === 0x26F2
		|| x === 0x26F3
		|| x === 0x26F5
		|| x === 0x26FA
		|| x === 0x26FD
		|| x === 0x2705
		|| x === 0x270A
		|| x === 0x270B
		|| x === 0x2728
		|| x === 0x274C
		|| x === 0x274E
		|| x >= 0x2753 && x <= 0x2755
		|| x === 0x2757
		|| x >= 0x2795 && x <= 0x2797
		|| x === 0x27B0
		|| x === 0x27BF
		|| x === 0x2B1B
		|| x === 0x2B1C
		|| x === 0x2B50
		|| x === 0x2B55
		|| x >= 0x2E80 && x <= 0x2E99
		|| x >= 0x2E9B && x <= 0x2EF3
		|| x >= 0x2F00 && x <= 0x2FD5
		|| x >= 0x2FF0 && x <= 0x2FFF
		|| x >= 0x3001 && x <= 0x303E
		|| x >= 0x3041 && x <= 0x3096
		|| x >= 0x3099 && x <= 0x30FF
		|| x >= 0x3105 && x <= 0x312F
		|| x >= 0x3131 && x <= 0x318E
		|| x >= 0x3190 && x <= 0x31E5
		|| x >= 0x31EF && x <= 0x321E
		|| x >= 0x3220 && x <= 0x3247
		|| x >= 0x3250 && x <= 0xA48C
		|| x >= 0xA490 && x <= 0xA4C6
		|| x >= 0xA960 && x <= 0xA97C
		|| x >= 0xAC00 && x <= 0xD7A3
		|| x >= 0xF900 && x <= 0xFAFF
		|| x >= 0xFE10 && x <= 0xFE19
		|| x >= 0xFE30 && x <= 0xFE52
		|| x >= 0xFE54 && x <= 0xFE66
		|| x >= 0xFE68 && x <= 0xFE6B
		|| x >= 0x16FE0 && x <= 0x16FE4
		|| x === 0x16FF0
		|| x === 0x16FF1
		|| x >= 0x17000 && x <= 0x187F7
		|| x >= 0x18800 && x <= 0x18CD5
		|| x >= 0x18CFF && x <= 0x18D08
		|| x >= 0x1AFF0 && x <= 0x1AFF3
		|| x >= 0x1AFF5 && x <= 0x1AFFB
		|| x === 0x1AFFD
		|| x === 0x1AFFE
		|| x >= 0x1B000 && x <= 0x1B122
		|| x === 0x1B132
		|| x >= 0x1B150 && x <= 0x1B152
		|| x === 0x1B155
		|| x >= 0x1B164 && x <= 0x1B167
		|| x >= 0x1B170 && x <= 0x1B2FB
		|| x >= 0x1D300 && x <= 0x1D356
		|| x >= 0x1D360 && x <= 0x1D376
		|| x === 0x1F004
		|| x === 0x1F0CF
		|| x === 0x1F18E
		|| x >= 0x1F191 && x <= 0x1F19A
		|| x >= 0x1F200 && x <= 0x1F202
		|| x >= 0x1F210 && x <= 0x1F23B
		|| x >= 0x1F240 && x <= 0x1F248
		|| x === 0x1F250
		|| x === 0x1F251
		|| x >= 0x1F260 && x <= 0x1F265
		|| x >= 0x1F300 && x <= 0x1F320
		|| x >= 0x1F32D && x <= 0x1F335
		|| x >= 0x1F337 && x <= 0x1F37C
		|| x >= 0x1F37E && x <= 0x1F393
		|| x >= 0x1F3A0 && x <= 0x1F3CA
		|| x >= 0x1F3CF && x <= 0x1F3D3
		|| x >= 0x1F3E0 && x <= 0x1F3F0
		|| x === 0x1F3F4
		|| x >= 0x1F3F8 && x <= 0x1F43E
		|| x === 0x1F440
		|| x >= 0x1F442 && x <= 0x1F4FC
		|| x >= 0x1F4FF && x <= 0x1F53D
		|| x >= 0x1F54B && x <= 0x1F54E
		|| x >= 0x1F550 && x <= 0x1F567
		|| x === 0x1F57A
		|| x === 0x1F595
		|| x === 0x1F596
		|| x === 0x1F5A4
		|| x >= 0x1F5FB && x <= 0x1F64F
		|| x >= 0x1F680 && x <= 0x1F6C5
		|| x === 0x1F6CC
		|| x >= 0x1F6D0 && x <= 0x1F6D2
		|| x >= 0x1F6D5 && x <= 0x1F6D7
		|| x >= 0x1F6DC && x <= 0x1F6DF
		|| x === 0x1F6EB
		|| x === 0x1F6EC
		|| x >= 0x1F6F4 && x <= 0x1F6FC
		|| x >= 0x1F7E0 && x <= 0x1F7EB
		|| x === 0x1F7F0
		|| x >= 0x1F90C && x <= 0x1F93A
		|| x >= 0x1F93C && x <= 0x1F945
		|| x >= 0x1F947 && x <= 0x1F9FF
		|| x >= 0x1FA70 && x <= 0x1FA7C
		|| x >= 0x1FA80 && x <= 0x1FA89
		|| x >= 0x1FA8F && x <= 0x1FAC6
		|| x >= 0x1FACE && x <= 0x1FADC
		|| x >= 0x1FADF && x <= 0x1FAE9
		|| x >= 0x1FAF0 && x <= 0x1FAF8
		|| x >= 0x20000 && x <= 0x2FFFD
		|| x >= 0x30000 && x <= 0x3FFFD;
}

function validate(codePoint) {
	if (!Number.isSafeInteger(codePoint)) {
		throw new TypeError(`Expected a code point, got \`${typeof codePoint}\`.`);
	}
}

function eastAsianWidth(codePoint, {ambiguousAsWide = false} = {}) {
	validate(codePoint);

	if (
		isFullWidth(codePoint)
		|| isWide(codePoint)
		|| (ambiguousAsWide && isAmbiguous(codePoint))
	) {
		return 2;
	}

	return 1;
}

const emojiRegex = () => {
	// https://mths.be/emoji
	return /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE89\uDE8F-\uDEC2\uDEC6\uDECE-\uDEDC\uDEDF-\uDEE9]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
};

const segmenter = globalThis.Intl?.Segmenter ? new Intl.Segmenter() : { segment: (str) => str.split('') };

const defaultIgnorableCodePointRegex = /^\p{Default_Ignorable_Code_Point}$/u;

function stringWidth$1(string, options = {}) {
	if (typeof string !== 'string' || string.length === 0) {
		return 0;
	}

	const {
		ambiguousIsNarrow = true,
		countAnsiEscapeCodes = false,
	} = options;

	if (!countAnsiEscapeCodes) {
		string = stripAnsi(string);
	}

	if (string.length === 0) {
		return 0;
	}

	let width = 0;
	const eastAsianWidthOptions = {ambiguousAsWide: !ambiguousIsNarrow};

	for (const {segment: character} of segmenter.segment(string)) {
		const codePoint = character.codePointAt(0);

		// Ignore control characters
		if (codePoint <= 0x1F || (codePoint >= 0x7F && codePoint <= 0x9F)) {
			continue;
		}

		// Ignore zero-width characters
		if (
			(codePoint >= 0x20_0B && codePoint <= 0x20_0F) // Zero-width space, non-joiner, joiner, left-to-right mark, right-to-left mark
			|| codePoint === 0xFE_FF // Zero-width no-break space
		) {
			continue;
		}

		// Ignore combining characters
		if (
			(codePoint >= 0x3_00 && codePoint <= 0x3_6F) // Combining diacritical marks
			|| (codePoint >= 0x1A_B0 && codePoint <= 0x1A_FF) // Combining diacritical marks extended
			|| (codePoint >= 0x1D_C0 && codePoint <= 0x1D_FF) // Combining diacritical marks supplement
			|| (codePoint >= 0x20_D0 && codePoint <= 0x20_FF) // Combining diacritical marks for symbols
			|| (codePoint >= 0xFE_20 && codePoint <= 0xFE_2F) // Combining half marks
		) {
			continue;
		}

		// Ignore surrogate pairs
		if (codePoint >= 0xD8_00 && codePoint <= 0xDF_FF) {
			continue;
		}

		// Ignore variation selectors
		if (codePoint >= 0xFE_00 && codePoint <= 0xFE_0F) {
			continue;
		}

		// This covers some of the above cases, but we still keep them for performance reasons.
		if (defaultIgnorableCodePointRegex.test(character)) {
			continue;
		}

		// TODO: Use `/\p{RGI_Emoji}/v` when targeting Node.js 20.
		if (emojiRegex().test(character)) {
			width += 2;
			continue;
		}

		width += eastAsianWidth(codePoint, eastAsianWidthOptions);
	}

	return width;
}

function isUnicodeSupported$1() {
	const {env} = process$2;
	const {TERM, TERM_PROGRAM} = env;

	if (process$2.platform !== 'win32') {
		return TERM !== 'linux'; // Linux console (kernel)
	}

	return Boolean(env.WT_SESSION) // Windows Terminal
		|| Boolean(env.TERMINUS_SUBLIME) // Terminus (<0.2.27)
		|| env.ConEmuTask === '{cmd::Cmder}' // ConEmu and cmder
		|| TERM_PROGRAM === 'Terminus-Sublime'
		|| TERM_PROGRAM === 'vscode'
		|| TERM === 'xterm-256color'
		|| TERM === 'alacritty'
		|| TERM === 'rxvt-unicode'
		|| TERM === 'rxvt-unicode-256color'
		|| env.TERMINAL_EMULATOR === 'JetBrains-JediTerm';
}

const TYPE_COLOR_MAP = {
  info: "cyan",
  fail: "red",
  success: "green",
  ready: "green",
  start: "magenta"
};
const LEVEL_COLOR_MAP = {
  0: "red",
  1: "yellow"
};
const unicode = isUnicodeSupported$1();
const s = (c, fallback) => unicode ? c : fallback;
const TYPE_ICONS = {
  error: s("\u2716", "\xD7"),
  fatal: s("\u2716", "\xD7"),
  ready: s("\u2714", "\u221A"),
  warn: s("\u26A0", "\u203C"),
  info: s("\u2139", "i"),
  success: s("\u2714", "\u221A"),
  debug: s("\u2699", "D"),
  trace: s("\u2192", "\u2192"),
  fail: s("\u2716", "\xD7"),
  start: s("\u25D0", "o"),
  log: ""
};
function stringWidth(str) {
  const hasICU = typeof Intl === "object";
  if (!hasICU || !Intl.Segmenter) {
    return stripAnsi$1(str).length;
  }
  return stringWidth$1(str);
}
class FancyReporter extends BasicReporter {
  formatStack(stack, message, opts) {
    const indent = "  ".repeat((opts?.errorLevel || 0) + 1);
    return `
${indent}` + parseStack(stack, message).map(
      (line) => "  " + line.replace(/^at +/, (m) => colors.gray(m)).replace(/\((.+)\)/, (_, m) => `(${colors.cyan(m)})`)
    ).join(`
${indent}`);
  }
  formatType(logObj, isBadge, opts) {
    const typeColor = TYPE_COLOR_MAP[logObj.type] || LEVEL_COLOR_MAP[logObj.level] || "gray";
    if (isBadge) {
      return getBgColor(typeColor)(
        colors.black(` ${logObj.type.toUpperCase()} `)
      );
    }
    const _type = typeof TYPE_ICONS[logObj.type] === "string" ? TYPE_ICONS[logObj.type] : logObj.icon || logObj.type;
    return _type ? getColor(typeColor)(_type) : "";
  }
  formatLogObj(logObj, opts) {
    const [message, ...additional] = this.formatArgs(logObj.args, opts).split(
      "\n"
    );
    if (logObj.type === "box") {
      return box(
        characterFormat(
          message + (additional.length > 0 ? "\n" + additional.join("\n") : "")
        ),
        {
          title: logObj.title ? characterFormat(logObj.title) : void 0,
          style: logObj.style
        }
      );
    }
    const date = this.formatDate(logObj.date, opts);
    const coloredDate = date && colors.gray(date);
    const isBadge = logObj.badge ?? logObj.level < 2;
    const type = this.formatType(logObj, isBadge, opts);
    const tag = logObj.tag ? colors.gray(logObj.tag) : "";
    let line;
    const left = this.filterAndJoin([type, characterFormat(message)]);
    const right = this.filterAndJoin(opts.columns ? [tag, coloredDate] : [tag]);
    const space = (opts.columns || 0) - stringWidth(left) - stringWidth(right) - 2;
    line = space > 0 && (opts.columns || 0) >= 80 ? left + " ".repeat(space) + right : (right ? `${colors.gray(`[${right}]`)} ` : "") + left;
    line += characterFormat(
      additional.length > 0 ? "\n" + additional.join("\n") : ""
    );
    if (logObj.type === "trace") {
      const _err = new Error("Trace: " + logObj.message);
      line += this.formatStack(_err.stack || "", _err.message);
    }
    return isBadge ? "\n" + line + "\n" : line;
  }
}
function characterFormat(str) {
  return str.replace(/`([^`]+)`/gm, (_, m) => colors.cyan(m)).replace(/\s+_([^_]+)_\s+/gm, (_, m) => ` ${colors.underline(m)} `);
}
function getColor(color = "white") {
  return colors[color] || colors.white;
}
function getBgColor(color = "bgWhite") {
  return colors[`bg${color[0].toUpperCase()}${color.slice(1)}`] || colors.bgWhite;
}

function createConsola(options = {}) {
  let level = _getDefaultLogLevel();
  if (process.env.CONSOLA_LEVEL) {
    level = Number.parseInt(process.env.CONSOLA_LEVEL) ?? level;
  }
  const consola2 = createConsola$1({
    level,
    defaults: { level },
    stdout: process.stdout,
    stderr: process.stderr,
    prompt: (...args) => import('./chunks/prompt.mjs').then((m) => m.prompt(...args)),
    reporters: options.reporters || [
      options.fancy ?? !(T || R$1) ? new FancyReporter() : new BasicReporter()
    ],
    ...options
  });
  return consola2;
}
function _getDefaultLogLevel() {
  if (g) {
    return LogLevels.debug;
  }
  if (R$1) {
    return LogLevels.warn;
  }
  return LogLevels.info;
}
const consola = createConsola();

function DD({onlyFirst:e=false}={}){const t=["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?(?:\\u0007|\\u001B\\u005C|\\u009C))","(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))"].join("|");return new RegExp(t,e?void 0:"g")}DD();function L(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var W={exports:{}};(function(e){var u={};e.exports=u,u.eastAsianWidth=function(F){var s=F.charCodeAt(0),i=F.length==2?F.charCodeAt(1):0,D=s;return 55296<=s&&s<=56319&&56320<=i&&i<=57343&&(s&=1023,i&=1023,D=s<<10|i,D+=65536),D==12288||65281<=D&&D<=65376||65504<=D&&D<=65510?"F":D==8361||65377<=D&&D<=65470||65474<=D&&D<=65479||65482<=D&&D<=65487||65490<=D&&D<=65495||65498<=D&&D<=65500||65512<=D&&D<=65518?"H":4352<=D&&D<=4447||4515<=D&&D<=4519||4602<=D&&D<=4607||9001<=D&&D<=9002||11904<=D&&D<=11929||11931<=D&&D<=12019||12032<=D&&D<=12245||12272<=D&&D<=12283||12289<=D&&D<=12350||12353<=D&&D<=12438||12441<=D&&D<=12543||12549<=D&&D<=12589||12593<=D&&D<=12686||12688<=D&&D<=12730||12736<=D&&D<=12771||12784<=D&&D<=12830||12832<=D&&D<=12871||12880<=D&&D<=13054||13056<=D&&D<=19903||19968<=D&&D<=42124||42128<=D&&D<=42182||43360<=D&&D<=43388||44032<=D&&D<=55203||55216<=D&&D<=55238||55243<=D&&D<=55291||63744<=D&&D<=64255||65040<=D&&D<=65049||65072<=D&&D<=65106||65108<=D&&D<=65126||65128<=D&&D<=65131||110592<=D&&D<=110593||127488<=D&&D<=127490||127504<=D&&D<=127546||127552<=D&&D<=127560||127568<=D&&D<=127569||131072<=D&&D<=194367||177984<=D&&D<=196605||196608<=D&&D<=262141?"W":32<=D&&D<=126||162<=D&&D<=163||165<=D&&D<=166||D==172||D==175||10214<=D&&D<=10221||10629<=D&&D<=10630?"Na":D==161||D==164||167<=D&&D<=168||D==170||173<=D&&D<=174||176<=D&&D<=180||182<=D&&D<=186||188<=D&&D<=191||D==198||D==208||215<=D&&D<=216||222<=D&&D<=225||D==230||232<=D&&D<=234||236<=D&&D<=237||D==240||242<=D&&D<=243||247<=D&&D<=250||D==252||D==254||D==257||D==273||D==275||D==283||294<=D&&D<=295||D==299||305<=D&&D<=307||D==312||319<=D&&D<=322||D==324||328<=D&&D<=331||D==333||338<=D&&D<=339||358<=D&&D<=359||D==363||D==462||D==464||D==466||D==468||D==470||D==472||D==474||D==476||D==593||D==609||D==708||D==711||713<=D&&D<=715||D==717||D==720||728<=D&&D<=731||D==733||D==735||768<=D&&D<=879||913<=D&&D<=929||931<=D&&D<=937||945<=D&&D<=961||963<=D&&D<=969||D==1025||1040<=D&&D<=1103||D==1105||D==8208||8211<=D&&D<=8214||8216<=D&&D<=8217||8220<=D&&D<=8221||8224<=D&&D<=8226||8228<=D&&D<=8231||D==8240||8242<=D&&D<=8243||D==8245||D==8251||D==8254||D==8308||D==8319||8321<=D&&D<=8324||D==8364||D==8451||D==8453||D==8457||D==8467||D==8470||8481<=D&&D<=8482||D==8486||D==8491||8531<=D&&D<=8532||8539<=D&&D<=8542||8544<=D&&D<=8555||8560<=D&&D<=8569||D==8585||8592<=D&&D<=8601||8632<=D&&D<=8633||D==8658||D==8660||D==8679||D==8704||8706<=D&&D<=8707||8711<=D&&D<=8712||D==8715||D==8719||D==8721||D==8725||D==8730||8733<=D&&D<=8736||D==8739||D==8741||8743<=D&&D<=8748||D==8750||8756<=D&&D<=8759||8764<=D&&D<=8765||D==8776||D==8780||D==8786||8800<=D&&D<=8801||8804<=D&&D<=8807||8810<=D&&D<=8811||8814<=D&&D<=8815||8834<=D&&D<=8835||8838<=D&&D<=8839||D==8853||D==8857||D==8869||D==8895||D==8978||9312<=D&&D<=9449||9451<=D&&D<=9547||9552<=D&&D<=9587||9600<=D&&D<=9615||9618<=D&&D<=9621||9632<=D&&D<=9633||9635<=D&&D<=9641||9650<=D&&D<=9651||9654<=D&&D<=9655||9660<=D&&D<=9661||9664<=D&&D<=9665||9670<=D&&D<=9672||D==9675||9678<=D&&D<=9681||9698<=D&&D<=9701||D==9711||9733<=D&&D<=9734||D==9737||9742<=D&&D<=9743||9748<=D&&D<=9749||D==9756||D==9758||D==9792||D==9794||9824<=D&&D<=9825||9827<=D&&D<=9829||9831<=D&&D<=9834||9836<=D&&D<=9837||D==9839||9886<=D&&D<=9887||9918<=D&&D<=9919||9924<=D&&D<=9933||9935<=D&&D<=9953||D==9955||9960<=D&&D<=9983||D==10045||D==10071||10102<=D&&D<=10111||11093<=D&&D<=11097||12872<=D&&D<=12879||57344<=D&&D<=63743||65024<=D&&D<=65039||D==65533||127232<=D&&D<=127242||127248<=D&&D<=127277||127280<=D&&D<=127337||127344<=D&&D<=127386||917760<=D&&D<=917999||983040<=D&&D<=1048573||1048576<=D&&D<=1114109?"A":"N"},u.characterLength=function(F){var s=this.eastAsianWidth(F);return s=="F"||s=="W"||s=="A"?2:1};function t(F){return F.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]|[^\uD800-\uDFFF]/g)||[]}u.length=function(F){for(var s=t(F),i=0,D=0;D<s.length;D++)i=i+this.characterLength(s[D]);return i},u.slice=function(F,s,i){textLen=u.length(F),s=s||0,i=i||1,s<0&&(s=textLen+s),i<0&&(i=textLen+i);for(var D="",r=0,n=t(F),E=0;E<n.length;E++){var a=n[E],o=u.length(a);if(r>=s-(o==2?1:0))if(r+o<=i)D+=a;else break;r+=o;}return D};})(W);var tD=W.exports;L(tD);var FD=function(){return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g};L(FD);const w=10,N=(e=0)=>u=>`\x1B[${u+e}m`,I=(e=0)=>u=>`\x1B[${38+e};5;${u}m`,R=(e=0)=>(u,t,F)=>`\x1B[${38+e};2;${u};${t};${F}m`,C={modifier:{reset:[0,0],bold:[1,22],dim:[2,22],italic:[3,23],underline:[4,24],overline:[53,55],inverse:[7,27],hidden:[8,28],strikethrough:[9,29]},color:{black:[30,39],red:[31,39],green:[32,39],yellow:[33,39],blue:[34,39],magenta:[35,39],cyan:[36,39],white:[37,39],blackBright:[90,39],gray:[90,39],grey:[90,39],redBright:[91,39],greenBright:[92,39],yellowBright:[93,39],blueBright:[94,39],magentaBright:[95,39],cyanBright:[96,39],whiteBright:[97,39]},bgColor:{bgBlack:[40,49],bgRed:[41,49],bgGreen:[42,49],bgYellow:[43,49],bgBlue:[44,49],bgMagenta:[45,49],bgCyan:[46,49],bgWhite:[47,49],bgBlackBright:[100,49],bgGray:[100,49],bgGrey:[100,49],bgRedBright:[101,49],bgGreenBright:[102,49],bgYellowBright:[103,49],bgBlueBright:[104,49],bgMagentaBright:[105,49],bgCyanBright:[106,49],bgWhiteBright:[107,49]}};Object.keys(C.modifier);const iD=Object.keys(C.color),rD=Object.keys(C.bgColor);[...iD,...rD];function CD(){const e=new Map;for(const[u,t]of Object.entries(C)){for(const[F,s]of Object.entries(t))C[F]={open:`\x1B[${s[0]}m`,close:`\x1B[${s[1]}m`},t[F]=C[F],e.set(s[0],s[1]);Object.defineProperty(C,u,{value:t,enumerable:false});}return Object.defineProperty(C,"codes",{value:e,enumerable:false}),C.color.close="\x1B[39m",C.bgColor.close="\x1B[49m",C.color.ansi=N(),C.color.ansi256=I(),C.color.ansi16m=R(),C.bgColor.ansi=N(w),C.bgColor.ansi256=I(w),C.bgColor.ansi16m=R(w),Object.defineProperties(C,{rgbToAnsi256:{value:(u,t,F)=>u===t&&t===F?u<8?16:u>248?231:Math.round((u-8)/247*24)+232:16+36*Math.round(u/255*5)+6*Math.round(t/255*5)+Math.round(F/255*5),enumerable:false},hexToRgb:{value:u=>{const t=/[a-f\d]{6}|[a-f\d]{3}/i.exec(u.toString(16));if(!t)return [0,0,0];let[F]=t;F.length===3&&(F=[...F].map(i=>i+i).join(""));const s=Number.parseInt(F,16);return [s>>16&255,s>>8&255,s&255]},enumerable:false},hexToAnsi256:{value:u=>C.rgbToAnsi256(...C.hexToRgb(u)),enumerable:false},ansi256ToAnsi:{value:u=>{if(u<8)return 30+u;if(u<16)return 90+(u-8);let t,F,s;if(u>=232)t=((u-232)*10+8)/255,F=t,s=t;else {u-=16;const r=u%36;t=Math.floor(u/36)/5,F=Math.floor(r/6)/5,s=r%6/5;}const i=Math.max(t,F,s)*2;if(i===0)return 30;let D=30+(Math.round(s)<<2|Math.round(F)<<1|Math.round(t));return i===2&&(D+=60),D},enumerable:false},rgbToAnsi:{value:(u,t,F)=>C.ansi256ToAnsi(C.rgbToAnsi256(u,t,F)),enumerable:false},hexToAnsi:{value:u=>C.ansi256ToAnsi(C.hexToAnsi256(u)),enumerable:false}}),C}CD();const xD=["up","down","left","right","space","enter","cancel"];({actions:new Set(xD)});globalThis.process.platform.startsWith("win");

function ce(){return process$2.platform!=="win32"?process$2.env.TERM!=="linux":!!process$2.env.CI||!!process$2.env.WT_SESSION||!!process$2.env.TERMINUS_SUBLIME||process$2.env.ConEmuTask==="{cmd::Cmder}"||process$2.env.TERM_PROGRAM==="Terminus-Sublime"||process$2.env.TERM_PROGRAM==="vscode"||process$2.env.TERM==="xterm-256color"||process$2.env.TERM==="alacritty"||process$2.env.TERMINAL_EMULATOR==="JetBrains-JediTerm"}const V=ce(),u$1=(t,n)=>V?t:n,o$1=u$1("\u2502","|");`${colors$1.gray(o$1)}  `;

/**
 * This is not the set of all possible signals.
 *
 * It IS, however, the set of all signals that trigger
 * an exit on either Linux or BSD systems.  Linux is a
 * superset of the signal names supported on BSD, and
 * the unknown signals just fail to register, so we can
 * catch that easily enough.
 *
 * Windows signals are a different set, since there are
 * signals that terminate Windows processes, but don't
 * terminate (or don't even exist) on Posix systems.
 *
 * Don't bother with SIGKILL.  It's uncatchable, which
 * means that we can't fire any callbacks anyway.
 *
 * If a user does happen to register a handler on a non-
 * fatal signal like SIGWINCH or something, and then
 * exit, it'll end up firing `process.emit('exit')`, so
 * the handler will be fired anyway.
 *
 * SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised
 * artificially, inherently leave the process in a
 * state from which it is not safe to try and enter JS
 * listeners.
 */
const signals = [];
signals.push('SIGHUP', 'SIGINT', 'SIGTERM');
if (process.platform !== 'win32') {
    signals.push('SIGALRM', 'SIGABRT', 'SIGVTALRM', 'SIGXCPU', 'SIGXFSZ', 'SIGUSR2', 'SIGTRAP', 'SIGSYS', 'SIGQUIT', 'SIGIOT'
    // should detect profiler and enable/disable accordingly.
    // see #21
    // 'SIGPROF'
    );
}
if (process.platform === 'linux') {
    signals.push('SIGIO', 'SIGPOLL', 'SIGPWR', 'SIGSTKFLT');
}

// Note: since nyc uses this module to output coverage, any lines
// that are in the direct sync flow of nyc's outputCoverage are
// ignored, since we can never get coverage for them.
// grab a reference to node's real process object right away
const processOk = (process) => !!process &&
    typeof process === 'object' &&
    typeof process.removeListener === 'function' &&
    typeof process.emit === 'function' &&
    typeof process.reallyExit === 'function' &&
    typeof process.listeners === 'function' &&
    typeof process.kill === 'function' &&
    typeof process.pid === 'number' &&
    typeof process.on === 'function';
const kExitEmitter = Symbol.for('signal-exit emitter');
const global$1 = globalThis;
const ObjectDefineProperty = Object.defineProperty.bind(Object);
// teeny special purpose ee
class Emitter {
    emitted = {
        afterExit: false,
        exit: false,
    };
    listeners = {
        afterExit: [],
        exit: [],
    };
    count = 0;
    id = Math.random();
    constructor() {
        if (global$1[kExitEmitter]) {
            return global$1[kExitEmitter];
        }
        ObjectDefineProperty(global$1, kExitEmitter, {
            value: this,
            writable: false,
            enumerable: false,
            configurable: false,
        });
    }
    on(ev, fn) {
        this.listeners[ev].push(fn);
    }
    removeListener(ev, fn) {
        const list = this.listeners[ev];
        const i = list.indexOf(fn);
        /* c8 ignore start */
        if (i === -1) {
            return;
        }
        /* c8 ignore stop */
        if (i === 0 && list.length === 1) {
            list.length = 0;
        }
        else {
            list.splice(i, 1);
        }
    }
    emit(ev, code, signal) {
        if (this.emitted[ev]) {
            return false;
        }
        this.emitted[ev] = true;
        let ret = false;
        for (const fn of this.listeners[ev]) {
            ret = fn(code, signal) === true || ret;
        }
        if (ev === 'exit') {
            ret = this.emit('afterExit', code, signal) || ret;
        }
        return ret;
    }
}
class SignalExitBase {
}
const signalExitWrap = (handler) => {
    return {
        onExit(cb, opts) {
            return handler.onExit(cb, opts);
        },
        load() {
            return handler.load();
        },
        unload() {
            return handler.unload();
        },
    };
};
class SignalExitFallback extends SignalExitBase {
    onExit() {
        return () => { };
    }
    load() { }
    unload() { }
}
class SignalExit extends SignalExitBase {
    // "SIGHUP" throws an `ENOSYS` error on Windows,
    // so use a supported signal instead
    /* c8 ignore start */
    #hupSig = process$1.platform === 'win32' ? 'SIGINT' : 'SIGHUP';
    /* c8 ignore stop */
    #emitter = new Emitter();
    #process;
    #originalProcessEmit;
    #originalProcessReallyExit;
    #sigListeners = {};
    #loaded = false;
    constructor(process) {
        super();
        this.#process = process;
        // { <signal>: <listener fn>, ... }
        this.#sigListeners = {};
        for (const sig of signals) {
            this.#sigListeners[sig] = () => {
                // If there are no other listeners, an exit is coming!
                // Simplest way: remove us and then re-send the signal.
                // We know that this will kill the process, so we can
                // safely emit now.
                const listeners = this.#process.listeners(sig);
                let { count } = this.#emitter;
                // This is a workaround for the fact that signal-exit v3 and signal
                // exit v4 are not aware of each other, and each will attempt to let
                // the other handle it, so neither of them do. To correct this, we
                // detect if we're the only handler *except* for previous versions
                // of signal-exit, and increment by the count of listeners it has
                // created.
                /* c8 ignore start */
                const p = process;
                if (typeof p.__signal_exit_emitter__ === 'object' &&
                    typeof p.__signal_exit_emitter__.count === 'number') {
                    count += p.__signal_exit_emitter__.count;
                }
                /* c8 ignore stop */
                if (listeners.length === count) {
                    this.unload();
                    const ret = this.#emitter.emit('exit', null, sig);
                    /* c8 ignore start */
                    const s = sig === 'SIGHUP' ? this.#hupSig : sig;
                    if (!ret)
                        process.kill(process.pid, s);
                    /* c8 ignore stop */
                }
            };
        }
        this.#originalProcessReallyExit = process.reallyExit;
        this.#originalProcessEmit = process.emit;
    }
    onExit(cb, opts) {
        /* c8 ignore start */
        if (!processOk(this.#process)) {
            return () => { };
        }
        /* c8 ignore stop */
        if (this.#loaded === false) {
            this.load();
        }
        const ev = opts?.alwaysLast ? 'afterExit' : 'exit';
        this.#emitter.on(ev, cb);
        return () => {
            this.#emitter.removeListener(ev, cb);
            if (this.#emitter.listeners['exit'].length === 0 &&
                this.#emitter.listeners['afterExit'].length === 0) {
                this.unload();
            }
        };
    }
    load() {
        if (this.#loaded) {
            return;
        }
        this.#loaded = true;
        // This is the number of onSignalExit's that are in play.
        // It's important so that we can count the correct number of
        // listeners on signals, and don't wait for the other one to
        // handle it instead of us.
        this.#emitter.count += 1;
        for (const sig of signals) {
            try {
                const fn = this.#sigListeners[sig];
                if (fn)
                    this.#process.on(sig, fn);
            }
            catch (_) { }
        }
        this.#process.emit = (ev, ...a) => {
            return this.#processEmit(ev, ...a);
        };
        this.#process.reallyExit = (code) => {
            return this.#processReallyExit(code);
        };
    }
    unload() {
        if (!this.#loaded) {
            return;
        }
        this.#loaded = false;
        signals.forEach(sig => {
            const listener = this.#sigListeners[sig];
            /* c8 ignore start */
            if (!listener) {
                throw new Error('Listener not defined for signal: ' + sig);
            }
            /* c8 ignore stop */
            try {
                this.#process.removeListener(sig, listener);
                /* c8 ignore start */
            }
            catch (_) { }
            /* c8 ignore stop */
        });
        this.#process.emit = this.#originalProcessEmit;
        this.#process.reallyExit = this.#originalProcessReallyExit;
        this.#emitter.count -= 1;
    }
    #processReallyExit(code) {
        /* c8 ignore start */
        if (!processOk(this.#process)) {
            return 0;
        }
        this.#process.exitCode = code || 0;
        /* c8 ignore stop */
        this.#emitter.emit('exit', this.#process.exitCode, null);
        return this.#originalProcessReallyExit.call(this.#process, this.#process.exitCode);
    }
    #processEmit(ev, ...args) {
        const og = this.#originalProcessEmit;
        if (ev === 'exit' && processOk(this.#process)) {
            if (typeof args[0] === 'number') {
                this.#process.exitCode = args[0];
                /* c8 ignore start */
            }
            /* c8 ignore start */
            const ret = og.call(this.#process, ev, ...args);
            /* c8 ignore start */
            this.#emitter.emit('exit', this.#process.exitCode, null);
            /* c8 ignore stop */
            return ret;
        }
        else {
            return og.call(this.#process, ev, ...args);
        }
    }
}
const process$1 = globalThis.process;
// wrap so that we call the method on the actual handler, without
// exporting it directly.
const { 
/**
 * Called when the process is exiting, whether via signal, explicit
 * exit, or running out of stuff to do.
 *
 * If the global process object is not suitable for instrumentation,
 * then this will be a no-op.
 *
 * Returns a function that may be used to unload signal-exit.
 */
onExit} = signalExitWrap(processOk(process$1) ? new SignalExit(process$1) : new SignalExitFallback());

function isUnicodeSupported() {
	const {env} = process$2;
	const {TERM, TERM_PROGRAM} = env;

	if (process$2.platform !== 'win32') {
		return TERM !== 'linux'; // Linux console (kernel)
	}

	return Boolean(env.WT_SESSION) // Windows Terminal
		|| Boolean(env.TERMINUS_SUBLIME) // Terminus (<0.2.27)
		|| env.ConEmuTask === '{cmd::Cmder}' // ConEmu and cmder
		|| TERM_PROGRAM === 'Terminus-Sublime'
		|| TERM_PROGRAM === 'vscode'
		|| TERM === 'xterm-256color'
		|| TERM === 'alacritty'
		|| TERM === 'rxvt-unicode'
		|| TERM === 'rxvt-unicode-256color'
		|| env.TERMINAL_EMULATOR === 'JetBrains-JediTerm';
}

ofetch.create({
  baseURL: joinURL(NUXT_HUB_URL, '/api'),
  onRequest({ request, options }) {
    if (!options.headers.has('Authorization')) {
      options.headers.set('Authorization', `Bearer ${loadUserConfig().hub?.userToken || process.env.NUXT_HUB_USER_TOKEN || ''}`);
    }
    consola.debug(`Fetching \`${joinURL(options.baseURL, request)}\``);
  },
  onResponseError(ctx) {
    consola.debug(`Error when fetching \`${ctx.request}\``);
    if (ctx.response._data?.message) {
      ctx.error = new Error(`- ${ctx.response._data.message}`);
    }
    if (ctx.response._data?.data) {
      consola.debug(ctx.response._data?.data);
    }
  }
});

var packet = {exports: {}};

var reader;
var hasRequiredReader;

function requireReader () {
	if (hasRequiredReader) return reader;
	hasRequiredReader = 1;
	/**
	 * [Reader description]
	 * @param {[type]} buffer [description]
	 * @param {[type]} offset [description]
	 */
	function BufferReader(buffer, offset) {
	  this.buffer = buffer;
	  this.offset = offset || 0;
	  return this;
	}

	/**
	 * [read description]
	 * @param  {[type]} buffer [description]
	 * @param  {[type]} offset [description]
	 * @param  {[type]} length [description]
	 * @return {[type]}        [description]
	 */
	BufferReader.read = function(buffer, offset, length) {
	  let a = [];
	  let c = Math.ceil(length / 8);
	  let l = Math.floor(offset / 8);
	  const m = offset % 8;
	  function t(n) {
	    const r = [ 0, 0, 0, 0, 0, 0, 0, 0 ];
	    for (let i = 7; i >= 0; i--) {
	      r[7 - i] = n & Math.pow(2, i) ? 1 : 0;
	    }
	    a = a.concat(r);
	  }
	  function p(a) {
	    let n = 0;
	    const f = a.length - 1;
	    for (let i = f; i >= 0; i--) { if (a[f - i]) n += Math.pow(2, i); }
	    return n;
	  }
	  while (c--) t(buffer.readUInt8(l++));
	  return p(a.slice(m, m + length));
	};

	/**
	 * [read description]
	 * @param  {[type]} size [description]
	 * @return {[type]}      [description]
	 */
	BufferReader.prototype.read = function(size) {
	  const val = BufferReader.read(this.buffer, this.offset, size);
	  this.offset += size;
	  return val;
	};

	reader = BufferReader;
	return reader;
}

var writer;
var hasRequiredWriter;

function requireWriter () {
	if (hasRequiredWriter) return writer;
	hasRequiredWriter = 1;
	/**
	 * [Writer description]
	 */
	function BufferWriter() {
	  this.buffer = [];
	}

	/**
	 * [write description]
	 * @param  {[type]} d    [description]
	 * @param  {[type]} size [description]
	 * @return {[type]}      [description]
	 */
	BufferWriter.prototype.write = function(d, size) {
	  for (let i = 0; i < size; i++) {
	    this.buffer.push((d & Math.pow(2, size - i - 1)) ? 1 : 0);
	  }
	};

	/**
	 * [writeBuffer description]
	 * @param {[type]} b [description]
	 */
	BufferWriter.prototype.writeBuffer = function(b) {
	  this.buffer = this.buffer.concat(b.buffer);
	};

	/**
	 * [toBuffer description]
	 * @return {[type]} [description]
	 */
	BufferWriter.prototype.toBuffer = function() {
	  const arr = [];
	  for (let i = 0; i < this.buffer.length; i += 8) {
	    const chunk = this.buffer.slice(i, i + 8);
	    arr.push(parseInt(chunk.join(''), 2));
	  }
	  return Buffer.from(arr);
	};

	writer = BufferWriter;
	return writer;
}

var hasRequiredPacket;

function requirePacket () {
	if (hasRequiredPacket) return packet.exports;
	hasRequiredPacket = 1;
	const { debuglog } = require$$0$2;
	const BufferReader = requireReader();
	const BufferWriter = requireWriter();

	const debug = debuglog('dns2');

	const toIPv6 = buffer => buffer
	  .map(part => (part > 0 ? part.toString(16) : '0'))
	  .join(':')
	  .replace(/\b(?:0+:){1,}/, ':');

	const fromIPv6 = (address) => {
	  const digits = address.split(':');
	  // CAVEAT edge case for :: and IPs starting
	  // or ending by ::
	  if (digits[0] === '') {
	    digits.shift();
	  }
	  if (digits[digits.length - 1] === '') {
	    digits.pop();
	  }
	  // CAVEAT we have to take into account
	  // the extra space used by the empty string
	  const missingFields = 8 - digits.length + 1;
	  return digits.flatMap((digit) => {
	    if (digit === '') {
	      return Array(missingFields).fill('0');
	    }
	    return digit.padStart(4, '0');
	  });
	};

	/**
	 * [Packet description]
	 * @param {[type]} data [description]
	 * @docs https://tools.ietf.org/html/rfc1034
	 * @docs https://tools.ietf.org/html/rfc1035
	 *
	 * <Buffer 29 64 01 00 00 01 00 00 00 00 00 00
	 *       |-ID----------- HEADER ----------->|
	 *
	 *  03 77 77 77 01 7a 02 63 6e 00 00 01 00 01>
	 *   <-W--W--W-----Z-----C--N>|<----------->|
	 */
	function Packet(data) {
	  this.header = {};
	  this.questions = [];
	  this.answers = [];
	  this.authorities = [];
	  this.additionals = [];
	  if (data instanceof Packet) {
	    return data;
	  } else if (data instanceof Packet.Header) {
	    this.header = data;
	  } else if (data instanceof Packet.Question) {
	    this.questions.push(data);
	  } else if (data instanceof Packet.Resource) {
	    this.answers.push(data);
	  } else if (typeof data === 'string') {
	    this.questions.push(data);
	  } else if (typeof data === 'object') {
	    const type = ({}).toString.call(data).match(/\[object (\w+)\]/)[1];
	    if (type === 'Array') {
	      this.questions = data;
	    }
	    if (type === 'Object') {
	      this.header = data;
	    }
	  }
	  return this;
	}

	/**
	 * [QUERY_TYPE description]
	 * @type {Object}
	 * @docs https://tools.ietf.org/html/rfc1035#section-3.2.2
	 */
	Packet.TYPE = {
	  A     : 0x01,
	  NS    : 0x02,
	  MD    : 0x03,
	  MF    : 0x04,
	  CNAME : 0x05,
	  SOA   : 0x06,
	  MB    : 0x07,
	  MG    : 0x08,
	  MR    : 0x09,
	  NULL  : 0x0A,
	  WKS   : 0x0B,
	  PTR   : 0x0C,
	  HINFO : 0x0D,
	  MINFO : 0x0E,
	  MX    : 0x0F,
	  TXT   : 0x10,
	  AAAA  : 0x1C,
	  SRV   : 0x21,
	  EDNS  : 0x29,
	  SPF   : 0x63,
	  AXFR  : 0xFC,
	  MAILB : 0xFD,
	  MAILA : 0xFE,
	  ANY   : 0xFF,
	  CAA   : 0x101,
	};
	/**
	 * [QUERY_CLASS description]
	 * @type {Object}
	 * @docs https://tools.ietf.org/html/rfc1035#section-3.2.4
	 */
	Packet.CLASS = {
	  IN  : 0x01,
	  CS  : 0x02,
	  CH  : 0x03,
	  HS  : 0x04,
	  ANY : 0xFF,
	};
	/**
	 * [EDNS_OPTION_CODE description]
	 * @type {Object}
	 * @docs https://tools.ietf.org/html/rfc6891#section-6.1.2
	 */
	Packet.EDNS_OPTION_CODE = {
	  ECS: 0x08,
	};

	/**
	 * [uuid description]
	 * @return {[type]} [description]
	 */
	Packet.uuid = function() {
	  return Math.floor(Math.random() * 1e5);
	};

	/**
	 * [parse description]
	 * @param  {[type]} buffer [description]
	 * @return {[type]}        [description]
	 */
	Packet.parse = function(buffer) {
	  const packet = new Packet();
	  const reader = new Packet.Reader(buffer);
	  packet.header = Packet.Header.parse(reader);
	  ([ // props             parser              count
	    [ 'questions', Packet.Question, packet.header.qdcount ],
	    [ 'answers', Packet.Resource, packet.header.ancount ],
	    [ 'authorities', Packet.Resource, packet.header.nscount ],
	    [ 'additionals', Packet.Resource, packet.header.arcount ],
	  ]).forEach(function(def) {
	    const section = def[0];
	    const decoder = def[1];
	    let count = def[2];
	    while (count--) {
	      try {
	        packet[section] = packet[section] || [];
	        packet[section].push(decoder.parse(reader));
	      } catch (e) {
	        debug('node-dns > parse %s error:', section, e.message);
	      }
	    }
	  });
	  return packet;
	};

	/**
	 * recursive
	 */
	Object.defineProperty(Packet.prototype, 'recursive', {
	  enumerable   : true,
	  configurable : true,
	  get() {
	    return !!this.header.rd;
	  },
	  set(yn) {
	    this.header.rd = +yn;
	    return this.header.rd;
	  },
	});

	/**
	 * [toBuffer description]
	 * @return {[type]} [description]
	 */
	Packet.prototype.toBuffer = function(writer) {
	  writer = writer || new Packet.Writer();
	  this.header.qdcount = this.questions.length;
	  this.header.ancount = this.answers.length;
	  this.header.nscount = this.authorities.length;
	  this.header.arcount = this.additionals.length;
	  if (!(this instanceof Packet.Header)) { this.header = new Packet.Header(this.header); }
	  this.header.toBuffer(writer);
	  ([ // section          encoder
	    [ 'questions', Packet.Question ],
	    [ 'answers', Packet.Resource ],
	    [ 'authorities', Packet.Resource ],
	    [ 'additionals', Packet.Resource ],
	  ]).forEach(function(def) {
	    const section = def[0];
	    const Encoder = def[1];
	    (this[section] || []).map(function(resource) {
	      return Encoder.encode(resource, writer);
	    });
	  }.bind(this));
	  return writer.toBuffer();
	};

	/**
	 * [Header description]
	 * @param {[type]} options [description]
	 * @docs https://tools.ietf.org/html/rfc1035#section-4.1.1
	 */
	Packet.Header = function(header) {
	  this.id = 0;
	  this.qr = 0;
	  this.opcode = 0;
	  this.aa = 0;
	  this.tc = 0;
	  this.rd = 0;
	  this.ra = 0;
	  this.z = 0;
	  this.rcode = 0;
	  this.qdcount = 0;
	  this.nscount = 0;
	  this.arcount = 0;
	  for (const k in header) {
	    this[k] = header[k];
	  }
	  return this;
	};
	/**
	 * [parse description]
	 * @param  {[type]} buffer [description]
	 * @return {[type]}        [description]
	 * @docs https://tools.ietf.org/html/rfc1035#section-4.1.1
	 */
	Packet.Header.parse = function(reader) {
	  const header = new Packet.Header();
	  if (reader instanceof Buffer) {
	    reader = new Packet.Reader(reader);
	  }
	  header.id = reader.read(16);
	  header.qr = reader.read(1);
	  header.opcode = reader.read(4);
	  header.aa = reader.read(1);
	  header.tc = reader.read(1);
	  header.rd = reader.read(1);
	  header.ra = reader.read(1);
	  header.z = reader.read(3);
	  header.rcode = reader.read(4);
	  header.qdcount = reader.read(16);
	  header.ancount = reader.read(16);
	  header.nscount = reader.read(16);
	  header.arcount = reader.read(16);
	  return header;
	};

	/**
	 * [toBuffer description]
	 * @return {[type]} [description]
	 */
	Packet.Header.prototype.toBuffer = function(writer) {
	  writer = writer || new Packet.Writer();
	  writer.write(this.id, 16);
	  writer.write(this.qr, 1);
	  writer.write(this.opcode, 4);
	  writer.write(this.aa, 1);
	  writer.write(this.tc, 1);
	  writer.write(this.rd, 1);
	  writer.write(this.ra, 1);
	  writer.write(this.z, 3);
	  writer.write(this.rcode, 4);
	  writer.write(this.qdcount, 16);
	  writer.write(this.ancount, 16);
	  writer.write(this.nscount, 16);
	  writer.write(this.arcount, 16);
	  return writer.toBuffer();
	};

	/**
	 * Question section format
	 * @docs https://tools.ietf.org/html/rfc1035#section-4.1.2
	 */
	Packet.Question = function(name, type, cls) {
	  const defaults = {
	    type  : Packet.TYPE.ANY,
	    class : Packet.CLASS.ANY,
	  };
	  if (typeof name === 'object') {
	    for (const k in name) {
	      this[k] = name[k] || defaults[k];
	    }
	  } else {
	    this.name = name;
	    this.type = type || defaults.type;
	    this.class = cls || defaults.class;
	  }
	  return this;
	};

	/**
	 * [toBuffer description]
	 * @param  {[type]} writer [description]
	 * @return {[type]}        [description]
	 */
	Packet.Question.prototype.toBuffer = function(writer) {
	  return Packet.Question.encode(this, writer);
	};

	/**
	 * [parse description]
	 * @param  {[type]} reader [description]
	 * @return {[type]}        [description]
	 */
	Packet.Question.parse =
	Packet.Question.decode = function(reader) {
	  const question = new Packet.Question();
	  if (reader instanceof Buffer) {
	    reader = new Packet.Reader(reader);
	  }
	  question.name = Packet.Name.decode(reader);
	  question.type = reader.read(16);
	  question.class = reader.read(16);
	  return question;
	};

	Packet.Question.encode = function(question, writer) {
	  writer = writer || new Packet.Writer();
	  Packet.Name.encode(question.name, writer);
	  writer.write(question.type, 16);
	  writer.write(question.class, 16);
	  return writer.toBuffer();
	};

	/**
	 * Resource record format
	 * @docs https://tools.ietf.org/html/rfc1035#section-4.1.3
	 */
	Packet.Resource = function(name, type, cls, ttl) {
	  const defaults = {
	    name  : '',
	    ttl   : 300,
	    type  : Packet.TYPE.ANY,
	    class : Packet.CLASS.ANY,
	  };
	  let input;
	  if (typeof name === 'object') {
	    input = name;
	  } else {
	    input = {
	      name, type, class: cls, ttl,
	    };
	  }
	  Object.assign(this, defaults, input);
	  return this;
	};

	/**
	 * [toBuffer description]
	 * @param  {[type]} writer [description]
	 * @return {[type]}        [description]
	 */
	Packet.Resource.prototype.toBuffer = function(writer) {
	  return Packet.Resource.encode(this, writer);
	};

	/**
	 * [encode description]
	 * @param  {[type]} resource [description]
	 * @param  {[type]} writer   [description]
	 * @return {[type]}          [description]
	 */
	Packet.Resource.encode = function(resource, writer) {
	  writer = writer || new Packet.Writer();
	  Packet.Name.encode(resource.name, writer);
	  writer.write(resource.type, 16);
	  writer.write(resource.class, 16);
	  writer.write(resource.ttl, 32);
	  const encoder = Object.keys(Packet.TYPE).filter(function(type) {
	    return resource.type === Packet.TYPE[type];
	  })[0];
	  if (encoder in Packet.Resource && Packet.Resource[encoder].encode) {
	    return Packet.Resource[encoder].encode(resource, writer);
	  } else {
	    debug('node-dns > unknown encoder %s(%j)', encoder, resource.type);
	  }
	};
	/**
	 * [parse description]
	 * @param  {[type]} reader [description]
	 * @return {[type]}        [description]
	 */
	Packet.Resource.parse =
	Packet.Resource.decode = function(reader) {
	  if (reader instanceof Buffer) {
	    reader = new Packet.Reader(reader);
	  }
	  let resource = new Packet.Resource();
	  resource.name = Packet.Name.decode(reader);
	  resource.type = reader.read(16);
	  resource.class = reader.read(16);
	  resource.ttl = reader.read(32);
	  let length = reader.read(16);
	  const parser = Object.keys(Packet.TYPE).filter(function(type) {
	    return resource.type === Packet.TYPE[type];
	  })[0];
	  if (parser in Packet.Resource) {
	    resource = Packet.Resource[parser].decode.call(resource, reader, length);
	  } else {
	    debug('node-dns > unknown parser type: %s(%j)', parser, resource.type);
	    const arr = [];
	    while (length--) arr.push(reader.read(8));
	    resource.data = Buffer.from(arr);
	  }
	  return resource;
	};

	/**
	 * [encode_name description]
	 * @param  {[type]} domain [description]
	 * @return {[type]}        [description]
	 */
	Packet.Name = {
	  COPY   : 0xc0,
	  decode : function(reader) {
	    if (reader instanceof Buffer) {
	      reader = new Packet.Reader(reader);
	    }
	    const name = []; let o; let len = reader.read(8);
	    while (len) {
	      if ((len & Packet.Name.COPY) === Packet.Name.COPY) {
	        len -= Packet.Name.COPY;
	        len = len << 8;
	        const pos = len + reader.read(8);
	        if (!o) o = reader.offset;
	        reader.offset = pos * 8;
	        len = reader.read(8);
	        continue;
	      } else {
	        let part = '';
	        while (len--) part += String.fromCharCode(reader.read(8));
	        name.push(part);
	        len = reader.read(8);
	      }
	    }
	    if (o) reader.offset = o;
	    return name.join('.');
	  },
	  encode: function(domain, writer) {
	    writer = writer || new Packet.Writer();
	    // TODO: domain name compress
	    (domain || '').split('.').filter(function(part) {
	      return !!part;
	    }).forEach(function(part) {
	      writer.write(part.length, 8);
	      part.split('').map(function(c) {
	        writer.write(c.charCodeAt(0), 8);
	        return c.charCodeAt(0);
	      });
	    });
	    writer.write(0, 8);
	    return writer.toBuffer();
	  },
	};

	/**
	 * [A description]
	 * @type {Object}
	 * @docs https://tools.ietf.org/html/rfc1035#section-3.4.1
	 */
	Packet.Resource.A = function(address) {
	  this.type = Packet.TYPE.A;
	  this.class = Packet.CLASS.IN;
	  this.address = address;
	  return this;
	};

	Packet.Resource.A.encode = function(record, writer) {
	  writer = writer || new Packet.Writer();
	  const parts = record.address.split('.');
	  writer.write(parts.length, 16);
	  parts.forEach(function(part) {
	    writer.write(parseInt(part, 10), 8);
	  });
	  return writer.toBuffer();
	};

	Packet.Resource.A.decode = function(reader, length) {
	  const parts = [];
	  while (length--) parts.push(reader.read(8));
	  this.address = parts.join('.');
	  return this;
	};

	/**
	 * [MX description]
	 * @param {[type]} exchange [description]
	 * @param {[type]} priority [description]
	 * @docs https://tools.ietf.org/html/rfc1035#section-3.3.9
	 */
	Packet.Resource.MX = function(exchange, priority) {
	  this.type = Packet.TYPE.MX;
	  this.class = Packet.CLASS.IN;
	  this.exchange = exchange;
	  this.priority = priority;
	  return this;
	};
	/**
	 * [encode description]
	 * @param  {[type]} record [description]
	 * @param  {[type]} writer [description]
	 * @return {[type]}        [description]
	 */
	Packet.Resource.MX.encode = function(record, writer) {
	  writer = writer || new Packet.Writer();
	  const len = Packet.Name.encode(record.exchange).length;
	  writer.write(len + 2, 16);
	  writer.write(record.priority, 16);
	  Packet.Name.encode(record.exchange, writer);
	  return writer.toBuffer();
	};
	/**
	 * [decode description]
	 * @param  {[type]} reader [description]
	 * @param  {[type]} length [description]
	 * @return {[type]}        [description]
	 */
	Packet.Resource.MX.decode = function(reader, length) {
	  this.priority = reader.read(16);
	  this.exchange = Packet.Name.decode(reader);
	  return this;
	};
	/**
	 * [AAAA description]
	 * @type {Object}
	 * @docs https://en.wikipedia.org/wiki/IPv6
	 */
	Packet.Resource.AAAA = {
	  decode: function(reader, length) {
	    const parts = [];
	    while (length) {
	      length -= 2;
	      parts.push(reader.read(16));
	    }
	    this.address = toIPv6(parts);
	    return this;
	  },
	  encode: function(record, writer) {
	    writer = writer || new Packet.Writer();
	    const parts = fromIPv6(record.address);
	    writer.write(parts.length * 2, 16);
	    parts.forEach(function(part) {
	      writer.write(parseInt(part, 16), 16);
	    });
	    return writer.toBuffer();
	  },
	};
	/**
	 * [NS description]
	 * @type {Object}
	 * @docs https://tools.ietf.org/html/rfc1035#section-3.3.11
	 */
	Packet.Resource.NS = {
	  decode: function(reader, length) {
	    this.ns = Packet.Name.decode(reader);
	    return this;
	  },
	  encode: function(record, writer) {
	    writer = writer || new Packet.Writer();
	    writer.write(Packet.Name.encode(record.ns).length, 16);
	    Packet.Name.encode(record.ns, writer);
	    return writer.toBuffer();
	  },
	};
	/**
	 * [CNAME description]
	 * @type {Object}
	 * @docs https://tools.ietf.org/html/rfc1035#section-3.3.1
	 */
	Packet.Resource.PTR =
	Packet.Resource.CNAME = {
	  decode: function(reader, length) {
	    this.domain = Packet.Name.decode(reader);
	    return this;
	  },
	  encode: function(record, writer) {
	    writer = writer || new Packet.Writer();
	    writer.write(Packet.Name.encode(record.domain).length, 16);
	    Packet.Name.encode(record.domain, writer);
	    return writer.toBuffer();
	  },
	};
	/**
	 * [SPF description]
	 * @type {[type]}
	 * @docs https://tools.ietf.org/html/rfc1035#section-3.3.14
	 */
	Packet.Resource.SPF =
	Packet.Resource.TXT = {
	  decode: function(reader, length) {
	    const parts = [];
	    let bytesRead = 0; let chunkLength = 0;

	    while (bytesRead < length) {
	      chunkLength = reader.read(8); // text length
	      bytesRead++;

	      while (chunkLength--) {
	        parts.push(reader.read(8));
	        bytesRead++;
	      }
	    }

	    this.data = Buffer.from(parts).toString('utf8');
	    return this;
	  },
	  encode: function(record, writer) {
	    writer = writer || new Packet.Writer();

	    // make sure that resource data is a an array of strings
	    const characterStrings = Array.isArray(record.data) ? record.data : [ record.data ];
	    // convert array of strings to array of buffers
	    const characterStringBuffers = characterStrings.map(function(characterString) {
	      if (Buffer.isBuffer(characterString)) {
	        return characterString;
	      }
	      if (typeof characterString === 'string') {
	        return Buffer.from(characterString, 'utf8');
	      }
	      return false;
	    }).filter(function(characterString) {
	      // remove invalid values from the array
	      return characterString;
	    });

	    // calculate byte length of resource strings
	    const bufferLength = characterStringBuffers.reduce(function(sum, characterStringBuffer) {
	      return sum + characterStringBuffer.length;
	    }, 0);

	    // write string length to output
	    writer.write(bufferLength + characterStringBuffers.length, 16); // response length

	    // write each string to output
	    characterStringBuffers.forEach(function(buffer) {
	      writer.write(buffer.length, 8); // text length
	      buffer.forEach(function(c) {
	        writer.write(c, 8);
	      });
	    });

	    return writer.toBuffer();
	  },
	};
	/**
	 * [SOA description]
	 * @type {Object}
	 * @docs https://tools.ietf.org/html/rfc1035#section-3.3.13
	 */
	Packet.Resource.SOA = {
	  decode: function(reader, length) {
	    this.primary = Packet.Name.decode(reader);
	    this.admin = Packet.Name.decode(reader);
	    this.serial = reader.read(32);
	    this.refresh = reader.read(32);
	    this.retry = reader.read(32);
	    this.expiration = reader.read(32);
	    this.minimum = reader.read(32);
	    return this;
	  },
	  encode: function(record, writer) {
	    writer = writer || new Packet.Writer();
	    let len = 0;
	    len += Packet.Name.encode(record.primary).length;
	    len += Packet.Name.encode(record.admin).length;
	    len += (32 * 5) / 8;
	    writer.write(len, 16);
	    Packet.Name.encode(record.primary, writer);
	    Packet.Name.encode(record.admin, writer);
	    writer.write(record.serial, 32);
	    writer.write(record.refresh, 32);
	    writer.write(record.retry, 32);
	    writer.write(record.expiration, 32);
	    writer.write(record.minimum, 32);
	    return writer.toBuffer();
	  },
	};
	/**
	 * [SRV description]
	 * @type {Object}
	 * @docs https://tools.ietf.org/html/rfc2782
	 */
	Packet.Resource.SRV = {
	  decode: function(reader, length) {
	    this.priority = reader.read(16);
	    this.weight = reader.read(16);
	    this.port = reader.read(16);
	    this.target = Packet.Name.decode(reader);
	    return this;
	  },
	  encode: function(record, writer) {
	    writer = writer || new Packet.Writer();
	    const { length } = Packet.Name.encode(record.target);
	    writer.write(length + 6, 16);
	    writer.write(record.priority, 16);
	    writer.write(record.weight, 16);
	    writer.write(record.port, 16);
	    Packet.Name.encode(record.target, writer);
	    return writer.toBuffer();
	  },
	};

	Packet.Resource.EDNS = function(rdata) {
	  return {
	    type  : Packet.TYPE.EDNS,
	    class : 512, // Supported UDP Payload size
	    ttl   : 0, // Extended RCODE and flags
	    rdata, // Objects of type Packet.Resource.EDNS.*
	  };
	};

	Packet.Resource.EDNS.decode = function(reader, length) {
	  this.type = Packet.TYPE.EDNS;
	  this.class = 512;
	  this.ttl = 0;
	  this.rdata = [];

	  while (length) {
	    const optionCode = reader.read(16);
	    const optionLength = reader.read(16); // In octet (https://tools.ietf.org/html/rfc6891#page-8)

	    const decoder = Object.keys(Packet.EDNS_OPTION_CODE).filter(function(type) {
	      return optionCode === Packet.EDNS_OPTION_CODE[type];
	    })[0];
	    if (decoder in Packet.Resource.EDNS && Packet.Resource.EDNS[decoder].decode) {
	      const rdata = Packet.Resource.EDNS[decoder].decode(reader, optionLength);
	      this.rdata.push(rdata);
	    } else {
	      reader.read(optionLength); // Ignore data that doesn't understand
	      debug('node-dns > unknown EDNS rdata decoder %s(%j)', decoder, optionCode);
	    }

	    length = length - 4 - optionLength;
	  }
	  return this;
	};

	Packet.Resource.EDNS.encode = function(record, writer) {
	  const rdataWriter = new Packet.Writer();
	  for (const rdata of record.rdata) {
	    const encoder = Object.keys(Packet.EDNS_OPTION_CODE).filter(function(type) {
	      return rdata.ednsCode === Packet.EDNS_OPTION_CODE[type];
	    })[0];
	    if (encoder in Packet.Resource.EDNS && Packet.Resource.EDNS[encoder].encode) {
	      const w = new Packet.Writer();
	      Packet.Resource.EDNS[encoder].encode(rdata, w);
	      rdataWriter.write(rdata.ednsCode, 16);
	      rdataWriter.write(w.buffer.length / 8, 16);
	      rdataWriter.writeBuffer(w);
	    } else {
	      debug('node-dns > unknown EDNS rdata encoder %s(%j)', encoder, rdata.ednsCode);
	    }
	  }
	  writer = writer || new Packet.Writer();
	  writer.write(rdataWriter.buffer.length / 8, 16);
	  writer.writeBuffer(rdataWriter);
	  return writer.toBuffer();
	};

	Packet.Resource.EDNS.ECS = function(clientIp) {
	  const [ ip, prefixLength ] = clientIp.split('/');
	  const numPrefixLength = parseInt(prefixLength) || 32;
	  return {
	    ednsCode           : Packet.EDNS_OPTION_CODE.ECS,
	    family             : 1,
	    sourcePrefixLength : numPrefixLength,
	    scopePrefixLength  : 0,
	    ip,
	  };
	};

	Packet.Resource.EDNS.ECS.decode = function(reader, length) {
	  const rdata = {};
	  rdata.ednsCode = Packet.EDNS_OPTION_CODE.ECS;
	  rdata.family = reader.read(16);
	  rdata.sourcePrefixLength = reader.read(8);
	  rdata.scopePrefixLength = reader.read(8);
	  length -= 4;

	  if (rdata.family !== 1) {
	    debug('node-dns > unimplemented address family');
	    reader.read(length * 8); // Ignore data that doesn't understand
	    return rdata;
	  }

	  const ipv4Octets = [];
	  while (length--) {
	    const octet = reader.read(8);
	    ipv4Octets.push(octet);
	  }
	  while (ipv4Octets.length < 4) {
	    ipv4Octets.push(0);
	  }
	  rdata.ip = ipv4Octets.join('.');
	  return rdata;
	};

	Packet.Resource.EDNS.ECS.encode = function(record, writer) {
	  const ip = record.ip.split('.').map(s => parseInt(s));
	  writer.write(record.family, 16);
	  writer.write(record.sourcePrefixLength, 8);
	  writer.write(record.scopePrefixLength, 8);
	  writer.write(ip[0], 8);
	  writer.write(ip[1], 8);
	  writer.write(ip[2], 8);
	  writer.write(ip[3], 8);
	};

	Packet.Resource.CAA = {
	  encode: function(record, writer) {
	    writer = writer || new Packet.Writer();

	    const buffer = Buffer.from(record.tag + record.value, 'utf8');
	    writer.write(2 + buffer.length, 16);
	    writer.write(record.flags, 8);
	    writer.write(record.tag.length, 8);

	    buffer.forEach(function(c) {
	      writer.write(c, 8);
	    });
	    return writer.toBuffer();
	  },
	};

	Packet.Reader = BufferReader;
	Packet.Writer = BufferWriter;

	Packet.createResponseFromRequest = function(request) {
	  const response = new Packet(request);
	  response.header.qr = 1;
	  response.additionals = [];
	  return response;
	};

	Packet.createResourceFromQuestion = function(base, record) {
	  const resource = new Packet.Resource(base);
	  Object.assign(resource, record);
	  return resource;
	};

	Packet.readStream = socket => {
	  let chunks = [];
	  let chunklen = 0;
	  let received = false;
	  let expected = false;
	  return new Promise((resolve, reject) => {
	    const processMessage = () => {
	      if (received) return;
	      received = true;
	      const buffer = Buffer.concat(chunks, chunklen);
	      resolve(buffer.slice(2));
	    };
	    socket.on('end', processMessage);
	    socket.on('error', reject);
	    socket.on('readable', () => {
	      let chunk;
	      while ((chunk = socket.read()) !== null) {
	        chunks.push(chunk);
	        chunklen += chunk.length;
	      }
	      if (!expected && chunklen >= 2) {
	        if (chunks.length > 1) {
	          chunks = [ Buffer.concat(chunks, chunklen) ];
	        }
	        expected = chunks[0].readUInt16BE(0);
	      }

	      if (chunklen >= 2 + expected) {
	        processMessage();
	      }
	    });
	  });
	};

	/**
	 * DoH
	 * @docs https://tools.ietf.org/html/rfc8484
	 */
	Packet.prototype.toBase64URL = function() {
	  const buffer = this.toBuffer();
	  const base64 = buffer.toString('base64');
	  return base64
	    .replace(/=/g, '')
	    .replace(/\+/g, '-')
	    .replace(/\//g, '_');
	};

	packet.exports = Packet;
	packet.exports.toIPv6 = toIPv6;
	packet.exports.fromIPv6 = fromIPv6;
	return packet.exports;
}

var udp_1$1;
var hasRequiredUdp$1;

function requireUdp$1 () {
	if (hasRequiredUdp$1) return udp_1$1;
	hasRequiredUdp$1 = 1;
	const udp = require$$0$b;
	const Packet = requirePacket();

	/**
	 * [Server description]
	 * @docs https://tools.ietf.org/html/rfc1034
	 * @docs https://tools.ietf.org/html/rfc1035
	 */
	class Server extends udp.Socket {
	  constructor(options) {
	    let type = 'udp4';
	    if (typeof options === 'object') {
	      type = options.type;
	    }
	    super(type);
	    if (typeof options === 'function') {
	      this.on('request', options);
	    }
	    this.on('message', this.handle.bind(this));
	  }

	  handle(data, rinfo) {
	    try {
	      const message = Packet.parse(data);
	      this.emit('request', message, this.response.bind(this, rinfo), rinfo);
	    } catch (e) {
	      this.emit('requestError', e);
	    }
	  }

	  response(rinfo, message) {
	    if (message instanceof Packet) { message = message.toBuffer(); }
	    return new Promise((resolve, reject) => {
	      this.send(message, rinfo.port, rinfo.address, err => {
	        if (err) return reject(err);
	        resolve(message);
	      });
	    });
	  }

	  listen(port, address) {
	    return new Promise(resolve =>
	      this.bind(port, address, resolve));
	  }
	}

	udp_1$1 = Server;
	return udp_1$1;
}

var tcp_1$1;
var hasRequiredTcp$1;

function requireTcp$1 () {
	if (hasRequiredTcp$1) return tcp_1$1;
	hasRequiredTcp$1 = 1;
	const tcp = require$$0$5;
	const Packet = requirePacket();

	class Server extends tcp.Server {
	  constructor(options) {
	    super();
	    if (typeof options === 'function') {
	      this.on('request', options);
	    }
	    this.on('connection', this.handle.bind(this));
	  }

	  async handle(client) {
	    try {
	      const data = await Packet.readStream(client);
	      const message = Packet.parse(data);
	      this.emit('request', message, this.response.bind(this, client), client);
	    } catch (e) {
	      this.emit('requestError', e);
	      client.destroy();
	    }
	  }

	  response(client, message) {
	    if (message instanceof Packet) {
	      message = message.toBuffer();
	    }
	    const len = Buffer.alloc(2);
	    len.writeUInt16BE(message.length);
	    client.end(Buffer.concat([ len, message ]));
	  }
	}

	tcp_1$1 = Server;
	return tcp_1$1;
}

var doh$1;
var hasRequiredDoh$1;

function requireDoh$1 () {
	if (hasRequiredDoh$1) return doh$1;
	hasRequiredDoh$1 = 1;
	const http = require$$2;
	const https = require$$1;
	const { URL } = require$$7$1;
	const Packet = requirePacket();
	const EventEmitter = require$$0$3;
	const { debuglog } = require$$0$2;

	const debug = debuglog('dns2-server');

	const decodeBase64URL = str => {
	  let queryData = str
	    .replace(/-/g, '+')
	    .replace(/_/g, '/');
	  const pad = queryData.length % 4;
	  if (pad === 1) return;
	  if (pad) {
	    queryData += new Array(5 - pad).join('=');
	  }
	  return queryData;
	};

	const readStream = stream => new Promise((resolve, reject) => {
	  let buffer = '';
	  stream
	    .on('error', reject)
	    .on('data', chunk => { buffer += chunk; })
	    .on('end', () => resolve(buffer));
	});

	class Server extends EventEmitter {
	  constructor(options) {
	    super();
	    const { ssl } = Object.assign(this, { cors: true }, options);
	    this.server = (ssl ? https.createServer(options) : http.createServer())
	      .on('request', this.handleRequest.bind(this))
	      .on('listening', () => this.emit('listening', this.address()))
	      .on('error', error => this.emit('error', error))
	      .on('close', () => {
	        this.server.removeAllListeners();
	        this.emit('close');
	      });
	    return this;
	  }

	  async handleRequest(client, res) {
	    try {
	      const { method, url, headers } = client;
	      const { pathname, searchParams: query } = new URL(url, 'http://unused/');
	      const { cors } = this;
	      if (cors === true) {
	        res.setHeader('Access-Control-Allow-Origin', '*');
	      } else if (typeof cors === 'string') {
	        res.setHeader('Access-Control-Allow-Origin', cors);
	        res.setHeader('Vary', 'Origin');
	      } else if (typeof cors === 'function') {
	        const isAllowed = cors(headers.origin);
	        res.setHeader('Access-Control-Allow-Origin', isAllowed ? headers.origin : 'false');
	        res.setHeader('Vary', 'Origin');
	      }
	      // debug
	      debug('request', method, url);
	      // We are only handling get and post as reqired by rfc
	      if ((method !== 'GET' && method !== 'POST')) {
	        res.writeHead(405, { 'Content-Type': 'text/plain' });
	        res.write('405 Method not allowed\n');
	        res.end();
	        return;
	      }
	      // Check so the uri is correct
	      if (pathname !== '/dns-query') {
	        res.writeHead(404, { 'Content-Type': 'text/plain' });
	        res.write('404 Not Found\n');
	        res.end();
	        return;
	      }
	      // Make sure the requestee is requesting the correct content type
	      const contentType = headers.accept;
	      if (contentType !== 'application/dns-message') {
	        res.writeHead(400, { 'Content-Type': 'text/plain' });
	        res.write('400 Bad Request: Illegal content type\n');
	        res.end();
	        return;
	      }
	      let queryData;
	      if (method === 'GET') {
	        // Parse query string for the request data
	        const dns = query.get('dns');
	        if (!dns) {
	          res.writeHead(400, { 'Content-Type': 'text/plain' });
	          res.write('400 Bad Request: No query defined\n');
	          res.end();
	          return;
	        }
	        // Decode from Base64Url Encoding
	        const base64 = decodeBase64URL(dns);
	        if (!base64) {
	          res.writeHead(400, { 'Content-Type': 'text/plain' });
	          res.write('400 Bad Request: Invalid query data\n');
	          res.end();
	          return;
	        }
	        // Decode Base64 to buffer
	        queryData = Buffer.from(base64, 'base64');
	      } else if (method === 'POST') {
	        queryData = await readStream(client);
	      }
	      // Parse DNS query and Raise event.
	      const message = Packet.parse(queryData);
	      this.emit('request', message, this.response.bind(this, res), client);
	    } catch (e) {
	      this.emit('requestError', e);
	      res.destroy();
	    }
	  }

	  /**
	   * Send of the response to the client
	   * @param {*} res
	   * @param {*} message
	   */
	  response(res, message) {
	    debug('response');
	    res.setHeader('Content-Type', 'application/dns-message');
	    res.writeHead(200);
	    res.end(message.toBuffer());
	  }

	  /**
	   * listen
	   * @param {*} port
	   * @returns
	   */
	  listen(port, address) {
	    return this.server.listen(port || this.port, address);
	  }

	  address() {
	    return this.server.address();
	  }

	  close() {
	    return this.server.close();
	  }
	}

	doh$1 = Server;
	return doh$1;
}

var dns;
var hasRequiredDns;

function requireDns () {
	if (hasRequiredDns) return dns;
	hasRequiredDns = 1;
	const EventEmitter = require$$0$3;
	const DOHServer = requireDoh$1();
	const TCPServer = requireTcp$1();
	const UDPServer = requireUdp$1();

	class DNSServer extends EventEmitter {
	  constructor(options = {}) {
	    super();
	    this.servers = {};
	    if (options.doh) {
	      this.servers.doh = (new DOHServer(options.doh))
	        .on('error', error => this.emit('error', error, 'doh'));
	    }
	    if (options.tcp) {
	      this.servers.tcp = (new TCPServer())
	        .on('error', error => this.emit('error', error, 'tcp'));
	    }
	    if (options.udp) {
	      this.servers.udp = (new UDPServer(typeof options.udp === 'object' ? options.udp : undefined))
	        .on('error', error => this.emit('error', error, 'udp'));
	    }
	    const servers = Object.values(this.servers);
	    this.closed = Promise.all(
	      servers.map(server => new Promise(resolve => server.once('close', resolve))),
	    ).then(() => {
	      this.emit('close');
	    });

	    this.listening = Promise.all(
	      servers.map(server => new Promise(resolve => server.once('listening', resolve))),
	    ).then(() => {
	      const addresses = this.addresses();
	      this.emit('listening', addresses);
	      return addresses;
	    });

	    const emitRequest = (request, send, client) => this.emit('request', request, send, client);
	    const emitRequestError = (error) => this.emit('requestError', error);
	    for (const server of servers) {
	      server.on('request', emitRequest);
	      server.on('requestError', emitRequestError);
	    }

	    if (options.handle) {
	      this.on('request', options.handle.bind(options));
	    }
	  }

	  addresses() {
	    const addresses = {};
	    const { udp, tcp, doh } = this.servers;
	    if (udp) {
	      addresses.udp = udp.address();
	    }
	    if (tcp) {
	      addresses.tcp = tcp.address();
	    }
	    if (doh) {
	      addresses.doh = doh.address();
	    }
	    return addresses;
	  }

	  listen(options = {}) {
	    for (const serverType of Object.keys(this.servers)) {
	      const server = this.servers[serverType];
	      const serverOptions = options[serverType]; // Port or { port, address }

	      if (serverOptions && serverOptions.port) {
	        server.listen(serverOptions.port, serverOptions.address);
	      } else {
	        server.listen(serverOptions);
	      }
	    }

	    return this.listening;
	  }

	  close() {
	    const { doh, udp, tcp } = this.servers;
	    if (udp) {
	      udp.close();
	    }
	    if (tcp) {
	      tcp.close();
	    }
	    if (doh) {
	      doh.close();
	    }
	    return this.closed;
	  }
	}

	dns = DNSServer;
	return dns;
}

var server;
var hasRequiredServer;

function requireServer () {
	if (hasRequiredServer) return server;
	hasRequiredServer = 1;
	const UDPServer = requireUdp$1();
	const TCPServer = requireTcp$1();
	const DOHServer = requireDoh$1();
	const DNSServer = requireDns();

	const createUDPServer = options => {
	  return new UDPServer(options);
	};

	const createTCPServer = options => {
	  return new TCPServer(options);
	};

	const createDOHServer = options => {
	  return new DOHServer(options);
	};

	const createServer = options => {
	  return new DNSServer(options);
	};

	server = {
	  UDPServer,
	  TCPServer,
	  DOHServer,
	  DNSServer,
	  createTCPServer,
	  createUDPServer,
	  createDOHServer,
	  createServer,
	};
	return server;
}

var tcp_1;
var hasRequiredTcp;

function requireTcp () {
	if (hasRequiredTcp) return tcp_1;
	hasRequiredTcp = 1;
	const tcp = require$$0$5;
	const Packet = requirePacket();

	tcp_1 = ({ dns = '1.1.1.1', port = 53 } = {}) => {
	  return async(name, type = 'A', cls = Packet.CLASS.IN, { clientIp, recursive = true } = {}) => {
	    const packet = new Packet();

	    // see https://github.com/song940/node-dns/issues/29
	    if (recursive) {
	      packet.header.rd = 1;
	    }
	    if (clientIp) {
	      packet.additionals.push(Packet.Resource.EDNS([
	        Packet.Resource.EDNS.ECS(clientIp),
	      ]));
	    }

	    packet.questions.push({
	      name,
	      class : cls,
	      type  : Packet.TYPE[type],
	    });
	    const message = packet.toBuffer();
	    const len = Buffer.alloc(2);
	    len.writeUInt16BE(message.length);
	    const client = tcp.connect({ host: dns, port });
	    client.end(Buffer.concat([ len, message ]));
	    const data = await Packet.readStream(client);
	    if (!data.length) {
	      throw new Error('Empty TCP response');
	    }
	    return Packet.parse(data);
	  };
	};
	return tcp_1;
}

var doh;
var hasRequiredDoh;

function requireDoh () {
	if (hasRequiredDoh) return doh;
	hasRequiredDoh = 1;
	const Packet = requirePacket();

	const defaultGet = url => new Promise((resolve, reject) => {
	  const headers = {
	    accept: 'application/dns-message',
	  };
	  const base = url.startsWith('https') ? require$$1 : require$$2;
	  const req = base.get(url, { headers }, resolve);
	  req.on('error', reject);
	});

	const readStream = stream => {
	  const buffer = [];
	  return new Promise((resolve, reject) => {
	    stream
	      .on('error', reject)
	      .on('data', chunk => buffer.push(chunk))
	      .on('end', () => resolve(Buffer.concat(buffer)));
	  });
	};

	/**
	 * @docs https://tools.ietf.org/html/rfc8484
	 * @param {*} param0
	 */
	const DOHClient = ({ dns, http, get = defaultGet } = {}) => {
	  return (name, type = 'A', cls = Packet.CLASS.IN, { clientIp, recursive = true } = {}) => {
	    const packet = new Packet();
	    // see https://github.com/song940/node-dns/issues/29
	    if (recursive) {
	      packet.header.rd = 1;
	    }
	    if (clientIp) {
	      packet.additionals.push(Packet.Resource.EDNS([
	        Packet.Resource.EDNS.ECS(clientIp),
	      ]));
	    }
	    packet.questions.push({
	      name,
	      class : cls,
	      type  : Packet.TYPE[type],
	    });
	    const query = packet.toBase64URL();
	    return Promise.resolve(get(`http${http ? '' : 's'}://${dns}/dns-query?dns=${query}`))
	      .then(readStream)
	      .then(Packet.parse);
	  };
	};

	doh = DOHClient;
	return doh;
}

var udp_1;
var hasRequiredUdp;

function requireUdp () {
	if (hasRequiredUdp) return udp_1;
	hasRequiredUdp = 1;
	const udp = require$$0$b;
	const Packet = requirePacket();
	const { equal } = require$$0$4;
	const { debuglog } = require$$0$2;

	const debug = debuglog('dns2');

	udp_1 = ({ dns = '8.8.8.8', port = 53, socketType = 'udp4' } = {}) => {
	  return (name, type = 'A', cls = Packet.CLASS.IN, { clientIp, recursive = true } = {}) => {
	    const query = new Packet();
	    query.header.id = (Math.random() * 1e4) | 0;

	    // see https://github.com/song940/node-dns/issues/29
	    if (recursive) {
	      query.header.rd = 1;
	    }
	    if (clientIp) {
	      query.additionals.push(Packet.Resource.EDNS([
	        Packet.Resource.EDNS.ECS(clientIp),
	      ]));
	    }
	    query.questions.push({
	      name,
	      class : cls,
	      type  : Packet.TYPE[type],
	    });
	    const client = new udp.Socket(socketType);
	    return new Promise((resolve, reject) => {
	      client.once('message', function onMessage(message) {
	        client.close();
	        const response = Packet.parse(message);
	        equal(response.header.id, query.header.id);
	        resolve(response);
	      });
	      debug('send', dns, query.toBuffer());
	      client.send(query.toBuffer(), port, dns, err => err && reject(err));
	    });
	  };
	};
	return udp_1;
}

var google;
var hasRequiredGoogle;

function requireGoogle () {
	if (hasRequiredGoogle) return google;
	hasRequiredGoogle = 1;
	const https = require$$1;

	const get = url => new Promise(resolve =>
	  https.get(url, resolve));

	const readStream = stream => {
	  const buffer = [];
	  return new Promise((resolve, reject) => {
	    stream
	      .on('error', reject)
	      .on('data', chunk => {
	        buffer.push(chunk);
	      })
	      .on('end', () => resolve(Buffer.concat(buffer)));
	  });
	};

	const GoogleClient = () =>
	  (name, type = 'ANY') => {
	    return Promise
	      .resolve()
	      .then(() => get(`https://dns.google.com/resolve?name=${name}&type=${type}`))
	      .then(readStream)
	      .then(JSON.parse);
	  };

	google = GoogleClient;
	return google;
}

var dns2;
var hasRequiredDns2;

function requireDns2 () {
	if (hasRequiredDns2) return dns2;
	hasRequiredDns2 = 1;
	const {
	  TCPServer,
	  UDPServer,
	  DOHServer,
	  createTCPServer,
	  createUDPServer,
	  createDOHServer,
	  createServer,
	} = requireServer();
	const EventEmitter = require$$0$3;

	/**
	 * [DNS description]
	 * @docs https://tools.ietf.org/html/rfc1034
	 * @docs https://tools.ietf.org/html/rfc1035
	 */
	class DNS extends EventEmitter {
	  constructor(options) {
	    super();
	    Object.assign(this, {
	      port             : 53,
	      retries          : 3,
	      timeout          : 3,
	      recursive        : true,
	      resolverProtocol : 'UDP',
	      nameServers      : [
	        '8.8.8.8',
	        '114.114.114.114',
	      ],
	      rootServers: [
	        'a', 'b', 'c', 'd', 'e', 'f',
	        'g', 'h', 'i', 'j', 'k', 'l', 'm',
	      ].map(x => `${x}.root-servers.net`),
	    }, options);
	  }

	  /**
	   * query
	   * @param {*} questions
	   */
	  query(name, type, cls, clientIp) {
	    const { port, nameServers, recursive, resolverProtocol = 'UDP' } = this;
	    const createResolver = DNS[resolverProtocol + 'Client'];
	    return Promise.race(nameServers.map(address => {
	      const resolve = createResolver({ dns: address, port, recursive });
	      return resolve(name, type, cls, clientIp);
	    }));
	  }

	  /**
	   * resolve
	   * @param {*} domain
	   * @param {*} type
	   * @param {*} cls
	   */
	  resolve(domain, type = 'ANY', cls = DNS.Packet.CLASS.IN, clientIp = undefined) {
	    return this.query(domain, type, cls, clientIp);
	  }

	  resolveA(domain, clientIp) {
	    return this.resolve(domain, 'A', undefined, clientIp);
	  }

	  resolveAAAA(domain) {
	    return this.resolve(domain, 'AAAA');
	  }

	  resolveMX(domain) {
	    return this.resolve(domain, 'MX');
	  }

	  resolveCNAME(domain) {
	    return this.resolve(domain, 'CNAME');
	  }

	  resolvePTR(domain) {
	    return this.resolve(domain, 'PTR');
	  }
	}

	DNS.TCPServer = TCPServer;
	DNS.UDPServer = UDPServer;
	DNS.DOHServer = DOHServer;

	DNS.createUDPServer = createUDPServer;
	DNS.createTCPServer = createTCPServer;
	DNS.createDOHServer = createDOHServer;
	DNS.createServer = createServer;

	DNS.TCPClient = requireTcp();
	DNS.DOHClient = requireDoh();
	DNS.UDPClient = requireUdp();
	DNS.GoogleClient = requireGoogle();

	DNS.Packet = requirePacket();

	dns2 = DNS;
	return dns2;
}

requireDns2();

var bufferUtil = {exports: {}};

var constants;
var hasRequiredConstants;

function requireConstants () {
	if (hasRequiredConstants) return constants;
	hasRequiredConstants = 1;

	const BINARY_TYPES = ['nodebuffer', 'arraybuffer', 'fragments'];
	const hasBlob = typeof Blob !== 'undefined';

	if (hasBlob) BINARY_TYPES.push('blob');

	constants = {
	  BINARY_TYPES,
	  EMPTY_BUFFER: Buffer.alloc(0),
	  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',
	  hasBlob,
	  kForOnEventAttribute: Symbol('kIsForOnEventAttribute'),
	  kListener: Symbol('kListener'),
	  kStatusCode: Symbol('status-code'),
	  kWebSocket: Symbol('websocket'),
	  NOOP: () => {}
	};
	return constants;
}

var hasRequiredBufferUtil;

function requireBufferUtil () {
	if (hasRequiredBufferUtil) return bufferUtil.exports;
	hasRequiredBufferUtil = 1;

	const { EMPTY_BUFFER } = requireConstants();

	const FastBuffer = Buffer[Symbol.species];

	/**
	 * Merges an array of buffers into a new buffer.
	 *
	 * @param {Buffer[]} list The array of buffers to concat
	 * @param {Number} totalLength The total length of buffers in the list
	 * @return {Buffer} The resulting buffer
	 * @public
	 */
	function concat(list, totalLength) {
	  if (list.length === 0) return EMPTY_BUFFER;
	  if (list.length === 1) return list[0];

	  const target = Buffer.allocUnsafe(totalLength);
	  let offset = 0;

	  for (let i = 0; i < list.length; i++) {
	    const buf = list[i];
	    target.set(buf, offset);
	    offset += buf.length;
	  }

	  if (offset < totalLength) {
	    return new FastBuffer(target.buffer, target.byteOffset, offset);
	  }

	  return target;
	}

	/**
	 * Masks a buffer using the given mask.
	 *
	 * @param {Buffer} source The buffer to mask
	 * @param {Buffer} mask The mask to use
	 * @param {Buffer} output The buffer where to store the result
	 * @param {Number} offset The offset at which to start writing
	 * @param {Number} length The number of bytes to mask.
	 * @public
	 */
	function _mask(source, mask, output, offset, length) {
	  for (let i = 0; i < length; i++) {
	    output[offset + i] = source[i] ^ mask[i & 3];
	  }
	}

	/**
	 * Unmasks a buffer using the given mask.
	 *
	 * @param {Buffer} buffer The buffer to unmask
	 * @param {Buffer} mask The mask to use
	 * @public
	 */
	function _unmask(buffer, mask) {
	  for (let i = 0; i < buffer.length; i++) {
	    buffer[i] ^= mask[i & 3];
	  }
	}

	/**
	 * Converts a buffer to an `ArrayBuffer`.
	 *
	 * @param {Buffer} buf The buffer to convert
	 * @return {ArrayBuffer} Converted buffer
	 * @public
	 */
	function toArrayBuffer(buf) {
	  if (buf.length === buf.buffer.byteLength) {
	    return buf.buffer;
	  }

	  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
	}

	/**
	 * Converts `data` to a `Buffer`.
	 *
	 * @param {*} data The data to convert
	 * @return {Buffer} The buffer
	 * @throws {TypeError}
	 * @public
	 */
	function toBuffer(data) {
	  toBuffer.readOnly = true;

	  if (Buffer.isBuffer(data)) return data;

	  let buf;

	  if (data instanceof ArrayBuffer) {
	    buf = new FastBuffer(data);
	  } else if (ArrayBuffer.isView(data)) {
	    buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
	  } else {
	    buf = Buffer.from(data);
	    toBuffer.readOnly = false;
	  }

	  return buf;
	}

	bufferUtil.exports = {
	  concat,
	  mask: _mask,
	  toArrayBuffer,
	  toBuffer,
	  unmask: _unmask
	};

	/* istanbul ignore else  */
	if (!process.env.WS_NO_BUFFER_UTIL) {
	  try {
	    const bufferUtil$1 = require('bufferutil');

	    bufferUtil.exports.mask = function (source, mask, output, offset, length) {
	      if (length < 48) _mask(source, mask, output, offset, length);
	      else bufferUtil$1.mask(source, mask, output, offset, length);
	    };

	    bufferUtil.exports.unmask = function (buffer, mask) {
	      if (buffer.length < 32) _unmask(buffer, mask);
	      else bufferUtil$1.unmask(buffer, mask);
	    };
	  } catch (e) {
	    // Continue regardless of the error.
	  }
	}
	return bufferUtil.exports;
}

var limiter;
var hasRequiredLimiter;

function requireLimiter () {
	if (hasRequiredLimiter) return limiter;
	hasRequiredLimiter = 1;

	const kDone = Symbol('kDone');
	const kRun = Symbol('kRun');

	/**
	 * A very simple job queue with adjustable concurrency. Adapted from
	 * https://github.com/STRML/async-limiter
	 */
	class Limiter {
	  /**
	   * Creates a new `Limiter`.
	   *
	   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
	   *     to run concurrently
	   */
	  constructor(concurrency) {
	    this[kDone] = () => {
	      this.pending--;
	      this[kRun]();
	    };
	    this.concurrency = concurrency || Infinity;
	    this.jobs = [];
	    this.pending = 0;
	  }

	  /**
	   * Adds a job to the queue.
	   *
	   * @param {Function} job The job to run
	   * @public
	   */
	  add(job) {
	    this.jobs.push(job);
	    this[kRun]();
	  }

	  /**
	   * Removes a job from the queue and runs it if possible.
	   *
	   * @private
	   */
	  [kRun]() {
	    if (this.pending === this.concurrency) return;

	    if (this.jobs.length) {
	      const job = this.jobs.shift();

	      this.pending++;
	      job(this[kDone]);
	    }
	  }
	}

	limiter = Limiter;
	return limiter;
}

var permessageDeflate;
var hasRequiredPermessageDeflate;

function requirePermessageDeflate () {
	if (hasRequiredPermessageDeflate) return permessageDeflate;
	hasRequiredPermessageDeflate = 1;

	const zlib = require$$3$1;

	const bufferUtil = requireBufferUtil();
	const Limiter = requireLimiter();
	const { kStatusCode } = requireConstants();

	const FastBuffer = Buffer[Symbol.species];
	const TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);
	const kPerMessageDeflate = Symbol('permessage-deflate');
	const kTotalLength = Symbol('total-length');
	const kCallback = Symbol('callback');
	const kBuffers = Symbol('buffers');
	const kError = Symbol('error');

	//
	// We limit zlib concurrency, which prevents severe memory fragmentation
	// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913
	// and https://github.com/websockets/ws/issues/1202
	//
	// Intentionally global; it's the global thread pool that's an issue.
	//
	let zlibLimiter;

	/**
	 * permessage-deflate implementation.
	 */
	class PerMessageDeflate {
	  /**
	   * Creates a PerMessageDeflate instance.
	   *
	   * @param {Object} [options] Configuration options
	   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
	   *     for, or request, a custom client window size
	   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
	   *     acknowledge disabling of client context takeover
	   * @param {Number} [options.concurrencyLimit=10] The number of concurrent
	   *     calls to zlib
	   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
	   *     use of a custom server window size
	   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
	   *     disabling of server context takeover
	   * @param {Number} [options.threshold=1024] Size (in bytes) below which
	   *     messages should not be compressed if context takeover is disabled
	   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
	   *     deflate
	   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
	   *     inflate
	   * @param {Boolean} [isServer=false] Create the instance in either server or
	   *     client mode
	   * @param {Number} [maxPayload=0] The maximum allowed message length
	   */
	  constructor(options, isServer, maxPayload) {
	    this._maxPayload = maxPayload | 0;
	    this._options = options || {};
	    this._threshold =
	      this._options.threshold !== undefined ? this._options.threshold : 1024;
	    this._isServer = !!isServer;
	    this._deflate = null;
	    this._inflate = null;

	    this.params = null;

	    if (!zlibLimiter) {
	      const concurrency =
	        this._options.concurrencyLimit !== undefined
	          ? this._options.concurrencyLimit
	          : 10;
	      zlibLimiter = new Limiter(concurrency);
	    }
	  }

	  /**
	   * @type {String}
	   */
	  static get extensionName() {
	    return 'permessage-deflate';
	  }

	  /**
	   * Create an extension negotiation offer.
	   *
	   * @return {Object} Extension parameters
	   * @public
	   */
	  offer() {
	    const params = {};

	    if (this._options.serverNoContextTakeover) {
	      params.server_no_context_takeover = true;
	    }
	    if (this._options.clientNoContextTakeover) {
	      params.client_no_context_takeover = true;
	    }
	    if (this._options.serverMaxWindowBits) {
	      params.server_max_window_bits = this._options.serverMaxWindowBits;
	    }
	    if (this._options.clientMaxWindowBits) {
	      params.client_max_window_bits = this._options.clientMaxWindowBits;
	    } else if (this._options.clientMaxWindowBits == null) {
	      params.client_max_window_bits = true;
	    }

	    return params;
	  }

	  /**
	   * Accept an extension negotiation offer/response.
	   *
	   * @param {Array} configurations The extension negotiation offers/reponse
	   * @return {Object} Accepted configuration
	   * @public
	   */
	  accept(configurations) {
	    configurations = this.normalizeParams(configurations);

	    this.params = this._isServer
	      ? this.acceptAsServer(configurations)
	      : this.acceptAsClient(configurations);

	    return this.params;
	  }

	  /**
	   * Releases all resources used by the extension.
	   *
	   * @public
	   */
	  cleanup() {
	    if (this._inflate) {
	      this._inflate.close();
	      this._inflate = null;
	    }

	    if (this._deflate) {
	      const callback = this._deflate[kCallback];

	      this._deflate.close();
	      this._deflate = null;

	      if (callback) {
	        callback(
	          new Error(
	            'The deflate stream was closed while data was being processed'
	          )
	        );
	      }
	    }
	  }

	  /**
	   *  Accept an extension negotiation offer.
	   *
	   * @param {Array} offers The extension negotiation offers
	   * @return {Object} Accepted configuration
	   * @private
	   */
	  acceptAsServer(offers) {
	    const opts = this._options;
	    const accepted = offers.find((params) => {
	      if (
	        (opts.serverNoContextTakeover === false &&
	          params.server_no_context_takeover) ||
	        (params.server_max_window_bits &&
	          (opts.serverMaxWindowBits === false ||
	            (typeof opts.serverMaxWindowBits === 'number' &&
	              opts.serverMaxWindowBits > params.server_max_window_bits))) ||
	        (typeof opts.clientMaxWindowBits === 'number' &&
	          !params.client_max_window_bits)
	      ) {
	        return false;
	      }

	      return true;
	    });

	    if (!accepted) {
	      throw new Error('None of the extension offers can be accepted');
	    }

	    if (opts.serverNoContextTakeover) {
	      accepted.server_no_context_takeover = true;
	    }
	    if (opts.clientNoContextTakeover) {
	      accepted.client_no_context_takeover = true;
	    }
	    if (typeof opts.serverMaxWindowBits === 'number') {
	      accepted.server_max_window_bits = opts.serverMaxWindowBits;
	    }
	    if (typeof opts.clientMaxWindowBits === 'number') {
	      accepted.client_max_window_bits = opts.clientMaxWindowBits;
	    } else if (
	      accepted.client_max_window_bits === true ||
	      opts.clientMaxWindowBits === false
	    ) {
	      delete accepted.client_max_window_bits;
	    }

	    return accepted;
	  }

	  /**
	   * Accept the extension negotiation response.
	   *
	   * @param {Array} response The extension negotiation response
	   * @return {Object} Accepted configuration
	   * @private
	   */
	  acceptAsClient(response) {
	    const params = response[0];

	    if (
	      this._options.clientNoContextTakeover === false &&
	      params.client_no_context_takeover
	    ) {
	      throw new Error('Unexpected parameter "client_no_context_takeover"');
	    }

	    if (!params.client_max_window_bits) {
	      if (typeof this._options.clientMaxWindowBits === 'number') {
	        params.client_max_window_bits = this._options.clientMaxWindowBits;
	      }
	    } else if (
	      this._options.clientMaxWindowBits === false ||
	      (typeof this._options.clientMaxWindowBits === 'number' &&
	        params.client_max_window_bits > this._options.clientMaxWindowBits)
	    ) {
	      throw new Error(
	        'Unexpected or invalid parameter "client_max_window_bits"'
	      );
	    }

	    return params;
	  }

	  /**
	   * Normalize parameters.
	   *
	   * @param {Array} configurations The extension negotiation offers/reponse
	   * @return {Array} The offers/response with normalized parameters
	   * @private
	   */
	  normalizeParams(configurations) {
	    configurations.forEach((params) => {
	      Object.keys(params).forEach((key) => {
	        let value = params[key];

	        if (value.length > 1) {
	          throw new Error(`Parameter "${key}" must have only a single value`);
	        }

	        value = value[0];

	        if (key === 'client_max_window_bits') {
	          if (value !== true) {
	            const num = +value;
	            if (!Number.isInteger(num) || num < 8 || num > 15) {
	              throw new TypeError(
	                `Invalid value for parameter "${key}": ${value}`
	              );
	            }
	            value = num;
	          } else if (!this._isServer) {
	            throw new TypeError(
	              `Invalid value for parameter "${key}": ${value}`
	            );
	          }
	        } else if (key === 'server_max_window_bits') {
	          const num = +value;
	          if (!Number.isInteger(num) || num < 8 || num > 15) {
	            throw new TypeError(
	              `Invalid value for parameter "${key}": ${value}`
	            );
	          }
	          value = num;
	        } else if (
	          key === 'client_no_context_takeover' ||
	          key === 'server_no_context_takeover'
	        ) {
	          if (value !== true) {
	            throw new TypeError(
	              `Invalid value for parameter "${key}": ${value}`
	            );
	          }
	        } else {
	          throw new Error(`Unknown parameter "${key}"`);
	        }

	        params[key] = value;
	      });
	    });

	    return configurations;
	  }

	  /**
	   * Decompress data. Concurrency limited.
	   *
	   * @param {Buffer} data Compressed data
	   * @param {Boolean} fin Specifies whether or not this is the last fragment
	   * @param {Function} callback Callback
	   * @public
	   */
	  decompress(data, fin, callback) {
	    zlibLimiter.add((done) => {
	      this._decompress(data, fin, (err, result) => {
	        done();
	        callback(err, result);
	      });
	    });
	  }

	  /**
	   * Compress data. Concurrency limited.
	   *
	   * @param {(Buffer|String)} data Data to compress
	   * @param {Boolean} fin Specifies whether or not this is the last fragment
	   * @param {Function} callback Callback
	   * @public
	   */
	  compress(data, fin, callback) {
	    zlibLimiter.add((done) => {
	      this._compress(data, fin, (err, result) => {
	        done();
	        callback(err, result);
	      });
	    });
	  }

	  /**
	   * Decompress data.
	   *
	   * @param {Buffer} data Compressed data
	   * @param {Boolean} fin Specifies whether or not this is the last fragment
	   * @param {Function} callback Callback
	   * @private
	   */
	  _decompress(data, fin, callback) {
	    const endpoint = this._isServer ? 'client' : 'server';

	    if (!this._inflate) {
	      const key = `${endpoint}_max_window_bits`;
	      const windowBits =
	        typeof this.params[key] !== 'number'
	          ? zlib.Z_DEFAULT_WINDOWBITS
	          : this.params[key];

	      this._inflate = zlib.createInflateRaw({
	        ...this._options.zlibInflateOptions,
	        windowBits
	      });
	      this._inflate[kPerMessageDeflate] = this;
	      this._inflate[kTotalLength] = 0;
	      this._inflate[kBuffers] = [];
	      this._inflate.on('error', inflateOnError);
	      this._inflate.on('data', inflateOnData);
	    }

	    this._inflate[kCallback] = callback;

	    this._inflate.write(data);
	    if (fin) this._inflate.write(TRAILER);

	    this._inflate.flush(() => {
	      const err = this._inflate[kError];

	      if (err) {
	        this._inflate.close();
	        this._inflate = null;
	        callback(err);
	        return;
	      }

	      const data = bufferUtil.concat(
	        this._inflate[kBuffers],
	        this._inflate[kTotalLength]
	      );

	      if (this._inflate._readableState.endEmitted) {
	        this._inflate.close();
	        this._inflate = null;
	      } else {
	        this._inflate[kTotalLength] = 0;
	        this._inflate[kBuffers] = [];

	        if (fin && this.params[`${endpoint}_no_context_takeover`]) {
	          this._inflate.reset();
	        }
	      }

	      callback(null, data);
	    });
	  }

	  /**
	   * Compress data.
	   *
	   * @param {(Buffer|String)} data Data to compress
	   * @param {Boolean} fin Specifies whether or not this is the last fragment
	   * @param {Function} callback Callback
	   * @private
	   */
	  _compress(data, fin, callback) {
	    const endpoint = this._isServer ? 'server' : 'client';

	    if (!this._deflate) {
	      const key = `${endpoint}_max_window_bits`;
	      const windowBits =
	        typeof this.params[key] !== 'number'
	          ? zlib.Z_DEFAULT_WINDOWBITS
	          : this.params[key];

	      this._deflate = zlib.createDeflateRaw({
	        ...this._options.zlibDeflateOptions,
	        windowBits
	      });

	      this._deflate[kTotalLength] = 0;
	      this._deflate[kBuffers] = [];

	      this._deflate.on('data', deflateOnData);
	    }

	    this._deflate[kCallback] = callback;

	    this._deflate.write(data);
	    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
	      if (!this._deflate) {
	        //
	        // The deflate stream was closed while data was being processed.
	        //
	        return;
	      }

	      let data = bufferUtil.concat(
	        this._deflate[kBuffers],
	        this._deflate[kTotalLength]
	      );

	      if (fin) {
	        data = new FastBuffer(data.buffer, data.byteOffset, data.length - 4);
	      }

	      //
	      // Ensure that the callback will not be called again in
	      // `PerMessageDeflate#cleanup()`.
	      //
	      this._deflate[kCallback] = null;

	      this._deflate[kTotalLength] = 0;
	      this._deflate[kBuffers] = [];

	      if (fin && this.params[`${endpoint}_no_context_takeover`]) {
	        this._deflate.reset();
	      }

	      callback(null, data);
	    });
	  }
	}

	permessageDeflate = PerMessageDeflate;

	/**
	 * The listener of the `zlib.DeflateRaw` stream `'data'` event.
	 *
	 * @param {Buffer} chunk A chunk of data
	 * @private
	 */
	function deflateOnData(chunk) {
	  this[kBuffers].push(chunk);
	  this[kTotalLength] += chunk.length;
	}

	/**
	 * The listener of the `zlib.InflateRaw` stream `'data'` event.
	 *
	 * @param {Buffer} chunk A chunk of data
	 * @private
	 */
	function inflateOnData(chunk) {
	  this[kTotalLength] += chunk.length;

	  if (
	    this[kPerMessageDeflate]._maxPayload < 1 ||
	    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload
	  ) {
	    this[kBuffers].push(chunk);
	    return;
	  }

	  this[kError] = new RangeError('Max payload size exceeded');
	  this[kError].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';
	  this[kError][kStatusCode] = 1009;
	  this.removeListener('data', inflateOnData);
	  this.reset();
	}

	/**
	 * The listener of the `zlib.InflateRaw` stream `'error'` event.
	 *
	 * @param {Error} err The emitted error
	 * @private
	 */
	function inflateOnError(err) {
	  //
	  // There is no need to call `Zlib#close()` as the handle is automatically
	  // closed when an error is emitted.
	  //
	  this[kPerMessageDeflate]._inflate = null;
	  err[kStatusCode] = 1007;
	  this[kCallback](err);
	}
	return permessageDeflate;
}

var validation = {exports: {}};

var hasRequiredValidation;

function requireValidation () {
	if (hasRequiredValidation) return validation.exports;
	hasRequiredValidation = 1;

	const { isUtf8 } = require$$7;

	const { hasBlob } = requireConstants();

	//
	// Allowed token characters:
	//
	// '!', '#', '$', '%', '&', ''', '*', '+', '-',
	// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'
	//
	// tokenChars[32] === 0 // ' '
	// tokenChars[33] === 1 // '!'
	// tokenChars[34] === 0 // '"'
	// ...
	//
	// prettier-ignore
	const tokenChars = [
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31
	  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47
	  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63
	  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79
	  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95
	  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111
	  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127
	];

	/**
	 * Checks if a status code is allowed in a close frame.
	 *
	 * @param {Number} code The status code
	 * @return {Boolean} `true` if the status code is valid, else `false`
	 * @public
	 */
	function isValidStatusCode(code) {
	  return (
	    (code >= 1000 &&
	      code <= 1014 &&
	      code !== 1004 &&
	      code !== 1005 &&
	      code !== 1006) ||
	    (code >= 3000 && code <= 4999)
	  );
	}

	/**
	 * Checks if a given buffer contains only correct UTF-8.
	 * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by
	 * Markus Kuhn.
	 *
	 * @param {Buffer} buf The buffer to check
	 * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`
	 * @public
	 */
	function _isValidUTF8(buf) {
	  const len = buf.length;
	  let i = 0;

	  while (i < len) {
	    if ((buf[i] & 0x80) === 0) {
	      // 0xxxxxxx
	      i++;
	    } else if ((buf[i] & 0xe0) === 0xc0) {
	      // 110xxxxx 10xxxxxx
	      if (
	        i + 1 === len ||
	        (buf[i + 1] & 0xc0) !== 0x80 ||
	        (buf[i] & 0xfe) === 0xc0 // Overlong
	      ) {
	        return false;
	      }

	      i += 2;
	    } else if ((buf[i] & 0xf0) === 0xe0) {
	      // 1110xxxx 10xxxxxx 10xxxxxx
	      if (
	        i + 2 >= len ||
	        (buf[i + 1] & 0xc0) !== 0x80 ||
	        (buf[i + 2] & 0xc0) !== 0x80 ||
	        (buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80) || // Overlong
	        (buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0) // Surrogate (U+D800 - U+DFFF)
	      ) {
	        return false;
	      }

	      i += 3;
	    } else if ((buf[i] & 0xf8) === 0xf0) {
	      // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
	      if (
	        i + 3 >= len ||
	        (buf[i + 1] & 0xc0) !== 0x80 ||
	        (buf[i + 2] & 0xc0) !== 0x80 ||
	        (buf[i + 3] & 0xc0) !== 0x80 ||
	        (buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80) || // Overlong
	        (buf[i] === 0xf4 && buf[i + 1] > 0x8f) ||
	        buf[i] > 0xf4 // > U+10FFFF
	      ) {
	        return false;
	      }

	      i += 4;
	    } else {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Determines whether a value is a `Blob`.
	 *
	 * @param {*} value The value to be tested
	 * @return {Boolean} `true` if `value` is a `Blob`, else `false`
	 * @private
	 */
	function isBlob(value) {
	  return (
	    hasBlob &&
	    typeof value === 'object' &&
	    typeof value.arrayBuffer === 'function' &&
	    typeof value.type === 'string' &&
	    typeof value.stream === 'function' &&
	    (value[Symbol.toStringTag] === 'Blob' ||
	      value[Symbol.toStringTag] === 'File')
	  );
	}

	validation.exports = {
	  isBlob,
	  isValidStatusCode,
	  isValidUTF8: _isValidUTF8,
	  tokenChars
	};

	if (isUtf8) {
	  validation.exports.isValidUTF8 = function (buf) {
	    return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
	  };
	} /* istanbul ignore else  */ else if (!process.env.WS_NO_UTF_8_VALIDATE) {
	  try {
	    const isValidUTF8 = require('utf-8-validate');

	    validation.exports.isValidUTF8 = function (buf) {
	      return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
	    };
	  } catch (e) {
	    // Continue regardless of the error.
	  }
	}
	return validation.exports;
}

var receiver;
var hasRequiredReceiver;

function requireReceiver () {
	if (hasRequiredReceiver) return receiver;
	hasRequiredReceiver = 1;

	const { Writable } = require$$0$6;

	const PerMessageDeflate = requirePermessageDeflate();
	const {
	  BINARY_TYPES,
	  EMPTY_BUFFER,
	  kStatusCode,
	  kWebSocket
	} = requireConstants();
	const { concat, toArrayBuffer, unmask } = requireBufferUtil();
	const { isValidStatusCode, isValidUTF8 } = requireValidation();

	const FastBuffer = Buffer[Symbol.species];

	const GET_INFO = 0;
	const GET_PAYLOAD_LENGTH_16 = 1;
	const GET_PAYLOAD_LENGTH_64 = 2;
	const GET_MASK = 3;
	const GET_DATA = 4;
	const INFLATING = 5;
	const DEFER_EVENT = 6;

	/**
	 * HyBi Receiver implementation.
	 *
	 * @extends Writable
	 */
	class Receiver extends Writable {
	  /**
	   * Creates a Receiver instance.
	   *
	   * @param {Object} [options] Options object
	   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
	   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
	   *     multiple times in the same tick
	   * @param {String} [options.binaryType=nodebuffer] The type for binary data
	   * @param {Object} [options.extensions] An object containing the negotiated
	   *     extensions
	   * @param {Boolean} [options.isServer=false] Specifies whether to operate in
	   *     client or server mode
	   * @param {Number} [options.maxPayload=0] The maximum allowed message length
	   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
	   *     not to skip UTF-8 validation for text and close messages
	   */
	  constructor(options = {}) {
	    super();

	    this._allowSynchronousEvents =
	      options.allowSynchronousEvents !== undefined
	        ? options.allowSynchronousEvents
	        : true;
	    this._binaryType = options.binaryType || BINARY_TYPES[0];
	    this._extensions = options.extensions || {};
	    this._isServer = !!options.isServer;
	    this._maxPayload = options.maxPayload | 0;
	    this._skipUTF8Validation = !!options.skipUTF8Validation;
	    this[kWebSocket] = undefined;

	    this._bufferedBytes = 0;
	    this._buffers = [];

	    this._compressed = false;
	    this._payloadLength = 0;
	    this._mask = undefined;
	    this._fragmented = 0;
	    this._masked = false;
	    this._fin = false;
	    this._opcode = 0;

	    this._totalPayloadLength = 0;
	    this._messageLength = 0;
	    this._fragments = [];

	    this._errored = false;
	    this._loop = false;
	    this._state = GET_INFO;
	  }

	  /**
	   * Implements `Writable.prototype._write()`.
	   *
	   * @param {Buffer} chunk The chunk of data to write
	   * @param {String} encoding The character encoding of `chunk`
	   * @param {Function} cb Callback
	   * @private
	   */
	  _write(chunk, encoding, cb) {
	    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();

	    this._bufferedBytes += chunk.length;
	    this._buffers.push(chunk);
	    this.startLoop(cb);
	  }

	  /**
	   * Consumes `n` bytes from the buffered data.
	   *
	   * @param {Number} n The number of bytes to consume
	   * @return {Buffer} The consumed bytes
	   * @private
	   */
	  consume(n) {
	    this._bufferedBytes -= n;

	    if (n === this._buffers[0].length) return this._buffers.shift();

	    if (n < this._buffers[0].length) {
	      const buf = this._buffers[0];
	      this._buffers[0] = new FastBuffer(
	        buf.buffer,
	        buf.byteOffset + n,
	        buf.length - n
	      );

	      return new FastBuffer(buf.buffer, buf.byteOffset, n);
	    }

	    const dst = Buffer.allocUnsafe(n);

	    do {
	      const buf = this._buffers[0];
	      const offset = dst.length - n;

	      if (n >= buf.length) {
	        dst.set(this._buffers.shift(), offset);
	      } else {
	        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
	        this._buffers[0] = new FastBuffer(
	          buf.buffer,
	          buf.byteOffset + n,
	          buf.length - n
	        );
	      }

	      n -= buf.length;
	    } while (n > 0);

	    return dst;
	  }

	  /**
	   * Starts the parsing loop.
	   *
	   * @param {Function} cb Callback
	   * @private
	   */
	  startLoop(cb) {
	    this._loop = true;

	    do {
	      switch (this._state) {
	        case GET_INFO:
	          this.getInfo(cb);
	          break;
	        case GET_PAYLOAD_LENGTH_16:
	          this.getPayloadLength16(cb);
	          break;
	        case GET_PAYLOAD_LENGTH_64:
	          this.getPayloadLength64(cb);
	          break;
	        case GET_MASK:
	          this.getMask();
	          break;
	        case GET_DATA:
	          this.getData(cb);
	          break;
	        case INFLATING:
	        case DEFER_EVENT:
	          this._loop = false;
	          return;
	      }
	    } while (this._loop);

	    if (!this._errored) cb();
	  }

	  /**
	   * Reads the first two bytes of a frame.
	   *
	   * @param {Function} cb Callback
	   * @private
	   */
	  getInfo(cb) {
	    if (this._bufferedBytes < 2) {
	      this._loop = false;
	      return;
	    }

	    const buf = this.consume(2);

	    if ((buf[0] & 0x30) !== 0x00) {
	      const error = this.createError(
	        RangeError,
	        'RSV2 and RSV3 must be clear',
	        true,
	        1002,
	        'WS_ERR_UNEXPECTED_RSV_2_3'
	      );

	      cb(error);
	      return;
	    }

	    const compressed = (buf[0] & 0x40) === 0x40;

	    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
	      const error = this.createError(
	        RangeError,
	        'RSV1 must be clear',
	        true,
	        1002,
	        'WS_ERR_UNEXPECTED_RSV_1'
	      );

	      cb(error);
	      return;
	    }

	    this._fin = (buf[0] & 0x80) === 0x80;
	    this._opcode = buf[0] & 0x0f;
	    this._payloadLength = buf[1] & 0x7f;

	    if (this._opcode === 0x00) {
	      if (compressed) {
	        const error = this.createError(
	          RangeError,
	          'RSV1 must be clear',
	          true,
	          1002,
	          'WS_ERR_UNEXPECTED_RSV_1'
	        );

	        cb(error);
	        return;
	      }

	      if (!this._fragmented) {
	        const error = this.createError(
	          RangeError,
	          'invalid opcode 0',
	          true,
	          1002,
	          'WS_ERR_INVALID_OPCODE'
	        );

	        cb(error);
	        return;
	      }

	      this._opcode = this._fragmented;
	    } else if (this._opcode === 0x01 || this._opcode === 0x02) {
	      if (this._fragmented) {
	        const error = this.createError(
	          RangeError,
	          `invalid opcode ${this._opcode}`,
	          true,
	          1002,
	          'WS_ERR_INVALID_OPCODE'
	        );

	        cb(error);
	        return;
	      }

	      this._compressed = compressed;
	    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {
	      if (!this._fin) {
	        const error = this.createError(
	          RangeError,
	          'FIN must be set',
	          true,
	          1002,
	          'WS_ERR_EXPECTED_FIN'
	        );

	        cb(error);
	        return;
	      }

	      if (compressed) {
	        const error = this.createError(
	          RangeError,
	          'RSV1 must be clear',
	          true,
	          1002,
	          'WS_ERR_UNEXPECTED_RSV_1'
	        );

	        cb(error);
	        return;
	      }

	      if (
	        this._payloadLength > 0x7d ||
	        (this._opcode === 0x08 && this._payloadLength === 1)
	      ) {
	        const error = this.createError(
	          RangeError,
	          `invalid payload length ${this._payloadLength}`,
	          true,
	          1002,
	          'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH'
	        );

	        cb(error);
	        return;
	      }
	    } else {
	      const error = this.createError(
	        RangeError,
	        `invalid opcode ${this._opcode}`,
	        true,
	        1002,
	        'WS_ERR_INVALID_OPCODE'
	      );

	      cb(error);
	      return;
	    }

	    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
	    this._masked = (buf[1] & 0x80) === 0x80;

	    if (this._isServer) {
	      if (!this._masked) {
	        const error = this.createError(
	          RangeError,
	          'MASK must be set',
	          true,
	          1002,
	          'WS_ERR_EXPECTED_MASK'
	        );

	        cb(error);
	        return;
	      }
	    } else if (this._masked) {
	      const error = this.createError(
	        RangeError,
	        'MASK must be clear',
	        true,
	        1002,
	        'WS_ERR_UNEXPECTED_MASK'
	      );

	      cb(error);
	      return;
	    }

	    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
	    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
	    else this.haveLength(cb);
	  }

	  /**
	   * Gets extended payload length (7+16).
	   *
	   * @param {Function} cb Callback
	   * @private
	   */
	  getPayloadLength16(cb) {
	    if (this._bufferedBytes < 2) {
	      this._loop = false;
	      return;
	    }

	    this._payloadLength = this.consume(2).readUInt16BE(0);
	    this.haveLength(cb);
	  }

	  /**
	   * Gets extended payload length (7+64).
	   *
	   * @param {Function} cb Callback
	   * @private
	   */
	  getPayloadLength64(cb) {
	    if (this._bufferedBytes < 8) {
	      this._loop = false;
	      return;
	    }

	    const buf = this.consume(8);
	    const num = buf.readUInt32BE(0);

	    //
	    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned
	    // if payload length is greater than this number.
	    //
	    if (num > Math.pow(2, 53 - 32) - 1) {
	      const error = this.createError(
	        RangeError,
	        'Unsupported WebSocket frame: payload length > 2^53 - 1',
	        false,
	        1009,
	        'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH'
	      );

	      cb(error);
	      return;
	    }

	    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
	    this.haveLength(cb);
	  }

	  /**
	   * Payload length has been read.
	   *
	   * @param {Function} cb Callback
	   * @private
	   */
	  haveLength(cb) {
	    if (this._payloadLength && this._opcode < 0x08) {
	      this._totalPayloadLength += this._payloadLength;
	      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
	        const error = this.createError(
	          RangeError,
	          'Max payload size exceeded',
	          false,
	          1009,
	          'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'
	        );

	        cb(error);
	        return;
	      }
	    }

	    if (this._masked) this._state = GET_MASK;
	    else this._state = GET_DATA;
	  }

	  /**
	   * Reads mask bytes.
	   *
	   * @private
	   */
	  getMask() {
	    if (this._bufferedBytes < 4) {
	      this._loop = false;
	      return;
	    }

	    this._mask = this.consume(4);
	    this._state = GET_DATA;
	  }

	  /**
	   * Reads data bytes.
	   *
	   * @param {Function} cb Callback
	   * @private
	   */
	  getData(cb) {
	    let data = EMPTY_BUFFER;

	    if (this._payloadLength) {
	      if (this._bufferedBytes < this._payloadLength) {
	        this._loop = false;
	        return;
	      }

	      data = this.consume(this._payloadLength);

	      if (
	        this._masked &&
	        (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0
	      ) {
	        unmask(data, this._mask);
	      }
	    }

	    if (this._opcode > 0x07) {
	      this.controlMessage(data, cb);
	      return;
	    }

	    if (this._compressed) {
	      this._state = INFLATING;
	      this.decompress(data, cb);
	      return;
	    }

	    if (data.length) {
	      //
	      // This message is not compressed so its length is the sum of the payload
	      // length of all fragments.
	      //
	      this._messageLength = this._totalPayloadLength;
	      this._fragments.push(data);
	    }

	    this.dataMessage(cb);
	  }

	  /**
	   * Decompresses data.
	   *
	   * @param {Buffer} data Compressed data
	   * @param {Function} cb Callback
	   * @private
	   */
	  decompress(data, cb) {
	    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

	    perMessageDeflate.decompress(data, this._fin, (err, buf) => {
	      if (err) return cb(err);

	      if (buf.length) {
	        this._messageLength += buf.length;
	        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
	          const error = this.createError(
	            RangeError,
	            'Max payload size exceeded',
	            false,
	            1009,
	            'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'
	          );

	          cb(error);
	          return;
	        }

	        this._fragments.push(buf);
	      }

	      this.dataMessage(cb);
	      if (this._state === GET_INFO) this.startLoop(cb);
	    });
	  }

	  /**
	   * Handles a data message.
	   *
	   * @param {Function} cb Callback
	   * @private
	   */
	  dataMessage(cb) {
	    if (!this._fin) {
	      this._state = GET_INFO;
	      return;
	    }

	    const messageLength = this._messageLength;
	    const fragments = this._fragments;

	    this._totalPayloadLength = 0;
	    this._messageLength = 0;
	    this._fragmented = 0;
	    this._fragments = [];

	    if (this._opcode === 2) {
	      let data;

	      if (this._binaryType === 'nodebuffer') {
	        data = concat(fragments, messageLength);
	      } else if (this._binaryType === 'arraybuffer') {
	        data = toArrayBuffer(concat(fragments, messageLength));
	      } else if (this._binaryType === 'blob') {
	        data = new Blob(fragments);
	      } else {
	        data = fragments;
	      }

	      if (this._allowSynchronousEvents) {
	        this.emit('message', data, true);
	        this._state = GET_INFO;
	      } else {
	        this._state = DEFER_EVENT;
	        setImmediate(() => {
	          this.emit('message', data, true);
	          this._state = GET_INFO;
	          this.startLoop(cb);
	        });
	      }
	    } else {
	      const buf = concat(fragments, messageLength);

	      if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
	        const error = this.createError(
	          Error,
	          'invalid UTF-8 sequence',
	          true,
	          1007,
	          'WS_ERR_INVALID_UTF8'
	        );

	        cb(error);
	        return;
	      }

	      if (this._state === INFLATING || this._allowSynchronousEvents) {
	        this.emit('message', buf, false);
	        this._state = GET_INFO;
	      } else {
	        this._state = DEFER_EVENT;
	        setImmediate(() => {
	          this.emit('message', buf, false);
	          this._state = GET_INFO;
	          this.startLoop(cb);
	        });
	      }
	    }
	  }

	  /**
	   * Handles a control message.
	   *
	   * @param {Buffer} data Data to handle
	   * @return {(Error|RangeError|undefined)} A possible error
	   * @private
	   */
	  controlMessage(data, cb) {
	    if (this._opcode === 0x08) {
	      if (data.length === 0) {
	        this._loop = false;
	        this.emit('conclude', 1005, EMPTY_BUFFER);
	        this.end();
	      } else {
	        const code = data.readUInt16BE(0);

	        if (!isValidStatusCode(code)) {
	          const error = this.createError(
	            RangeError,
	            `invalid status code ${code}`,
	            true,
	            1002,
	            'WS_ERR_INVALID_CLOSE_CODE'
	          );

	          cb(error);
	          return;
	        }

	        const buf = new FastBuffer(
	          data.buffer,
	          data.byteOffset + 2,
	          data.length - 2
	        );

	        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
	          const error = this.createError(
	            Error,
	            'invalid UTF-8 sequence',
	            true,
	            1007,
	            'WS_ERR_INVALID_UTF8'
	          );

	          cb(error);
	          return;
	        }

	        this._loop = false;
	        this.emit('conclude', code, buf);
	        this.end();
	      }

	      this._state = GET_INFO;
	      return;
	    }

	    if (this._allowSynchronousEvents) {
	      this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);
	      this._state = GET_INFO;
	    } else {
	      this._state = DEFER_EVENT;
	      setImmediate(() => {
	        this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);
	        this._state = GET_INFO;
	        this.startLoop(cb);
	      });
	    }
	  }

	  /**
	   * Builds an error object.
	   *
	   * @param {function(new:Error|RangeError)} ErrorCtor The error constructor
	   * @param {String} message The error message
	   * @param {Boolean} prefix Specifies whether or not to add a default prefix to
	   *     `message`
	   * @param {Number} statusCode The status code
	   * @param {String} errorCode The exposed error code
	   * @return {(Error|RangeError)} The error
	   * @private
	   */
	  createError(ErrorCtor, message, prefix, statusCode, errorCode) {
	    this._loop = false;
	    this._errored = true;

	    const err = new ErrorCtor(
	      prefix ? `Invalid WebSocket frame: ${message}` : message
	    );

	    Error.captureStackTrace(err, this.createError);
	    err.code = errorCode;
	    err[kStatusCode] = statusCode;
	    return err;
	  }
	}

	receiver = Receiver;
	return receiver;
}

/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex" }] */

var sender;
var hasRequiredSender;

function requireSender () {
	if (hasRequiredSender) return sender;
	hasRequiredSender = 1;

	const { Duplex } = require$$0$6;
	const { randomFillSync } = require$$3;

	const PerMessageDeflate = requirePermessageDeflate();
	const { EMPTY_BUFFER, kWebSocket, NOOP } = requireConstants();
	const { isBlob, isValidStatusCode } = requireValidation();
	const { mask: applyMask, toBuffer } = requireBufferUtil();

	const kByteLength = Symbol('kByteLength');
	const maskBuffer = Buffer.alloc(4);
	const RANDOM_POOL_SIZE = 8 * 1024;
	let randomPool;
	let randomPoolPointer = RANDOM_POOL_SIZE;

	const DEFAULT = 0;
	const DEFLATING = 1;
	const GET_BLOB_DATA = 2;

	/**
	 * HyBi Sender implementation.
	 */
	class Sender {
	  /**
	   * Creates a Sender instance.
	   *
	   * @param {Duplex} socket The connection socket
	   * @param {Object} [extensions] An object containing the negotiated extensions
	   * @param {Function} [generateMask] The function used to generate the masking
	   *     key
	   */
	  constructor(socket, extensions, generateMask) {
	    this._extensions = extensions || {};

	    if (generateMask) {
	      this._generateMask = generateMask;
	      this._maskBuffer = Buffer.alloc(4);
	    }

	    this._socket = socket;

	    this._firstFragment = true;
	    this._compress = false;

	    this._bufferedBytes = 0;
	    this._queue = [];
	    this._state = DEFAULT;
	    this.onerror = NOOP;
	    this[kWebSocket] = undefined;
	  }

	  /**
	   * Frames a piece of data according to the HyBi WebSocket protocol.
	   *
	   * @param {(Buffer|String)} data The data to frame
	   * @param {Object} options Options object
	   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
	   *     FIN bit
	   * @param {Function} [options.generateMask] The function used to generate the
	   *     masking key
	   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
	   *     `data`
	   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
	   *     key
	   * @param {Number} options.opcode The opcode
	   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
	   *     modified
	   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
	   *     RSV1 bit
	   * @return {(Buffer|String)[]} The framed data
	   * @public
	   */
	  static frame(data, options) {
	    let mask;
	    let merge = false;
	    let offset = 2;
	    let skipMasking = false;

	    if (options.mask) {
	      mask = options.maskBuffer || maskBuffer;

	      if (options.generateMask) {
	        options.generateMask(mask);
	      } else {
	        if (randomPoolPointer === RANDOM_POOL_SIZE) {
	          /* istanbul ignore else  */
	          if (randomPool === undefined) {
	            //
	            // This is lazily initialized because server-sent frames must not
	            // be masked so it may never be used.
	            //
	            randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
	          }

	          randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
	          randomPoolPointer = 0;
	        }

	        mask[0] = randomPool[randomPoolPointer++];
	        mask[1] = randomPool[randomPoolPointer++];
	        mask[2] = randomPool[randomPoolPointer++];
	        mask[3] = randomPool[randomPoolPointer++];
	      }

	      skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
	      offset = 6;
	    }

	    let dataLength;

	    if (typeof data === 'string') {
	      if (
	        (!options.mask || skipMasking) &&
	        options[kByteLength] !== undefined
	      ) {
	        dataLength = options[kByteLength];
	      } else {
	        data = Buffer.from(data);
	        dataLength = data.length;
	      }
	    } else {
	      dataLength = data.length;
	      merge = options.mask && options.readOnly && !skipMasking;
	    }

	    let payloadLength = dataLength;

	    if (dataLength >= 65536) {
	      offset += 8;
	      payloadLength = 127;
	    } else if (dataLength > 125) {
	      offset += 2;
	      payloadLength = 126;
	    }

	    const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);

	    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;
	    if (options.rsv1) target[0] |= 0x40;

	    target[1] = payloadLength;

	    if (payloadLength === 126) {
	      target.writeUInt16BE(dataLength, 2);
	    } else if (payloadLength === 127) {
	      target[2] = target[3] = 0;
	      target.writeUIntBE(dataLength, 4, 6);
	    }

	    if (!options.mask) return [target, data];

	    target[1] |= 0x80;
	    target[offset - 4] = mask[0];
	    target[offset - 3] = mask[1];
	    target[offset - 2] = mask[2];
	    target[offset - 1] = mask[3];

	    if (skipMasking) return [target, data];

	    if (merge) {
	      applyMask(data, mask, target, offset, dataLength);
	      return [target];
	    }

	    applyMask(data, mask, data, 0, dataLength);
	    return [target, data];
	  }

	  /**
	   * Sends a close message to the other peer.
	   *
	   * @param {Number} [code] The status code component of the body
	   * @param {(String|Buffer)} [data] The message component of the body
	   * @param {Boolean} [mask=false] Specifies whether or not to mask the message
	   * @param {Function} [cb] Callback
	   * @public
	   */
	  close(code, data, mask, cb) {
	    let buf;

	    if (code === undefined) {
	      buf = EMPTY_BUFFER;
	    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {
	      throw new TypeError('First argument must be a valid error code number');
	    } else if (data === undefined || !data.length) {
	      buf = Buffer.allocUnsafe(2);
	      buf.writeUInt16BE(code, 0);
	    } else {
	      const length = Buffer.byteLength(data);

	      if (length > 123) {
	        throw new RangeError('The message must not be greater than 123 bytes');
	      }

	      buf = Buffer.allocUnsafe(2 + length);
	      buf.writeUInt16BE(code, 0);

	      if (typeof data === 'string') {
	        buf.write(data, 2);
	      } else {
	        buf.set(data, 2);
	      }
	    }

	    const options = {
	      [kByteLength]: buf.length,
	      fin: true,
	      generateMask: this._generateMask,
	      mask,
	      maskBuffer: this._maskBuffer,
	      opcode: 0x08,
	      readOnly: false,
	      rsv1: false
	    };

	    if (this._state !== DEFAULT) {
	      this.enqueue([this.dispatch, buf, false, options, cb]);
	    } else {
	      this.sendFrame(Sender.frame(buf, options), cb);
	    }
	  }

	  /**
	   * Sends a ping message to the other peer.
	   *
	   * @param {*} data The message to send
	   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
	   * @param {Function} [cb] Callback
	   * @public
	   */
	  ping(data, mask, cb) {
	    let byteLength;
	    let readOnly;

	    if (typeof data === 'string') {
	      byteLength = Buffer.byteLength(data);
	      readOnly = false;
	    } else if (isBlob(data)) {
	      byteLength = data.size;
	      readOnly = false;
	    } else {
	      data = toBuffer(data);
	      byteLength = data.length;
	      readOnly = toBuffer.readOnly;
	    }

	    if (byteLength > 125) {
	      throw new RangeError('The data size must not be greater than 125 bytes');
	    }

	    const options = {
	      [kByteLength]: byteLength,
	      fin: true,
	      generateMask: this._generateMask,
	      mask,
	      maskBuffer: this._maskBuffer,
	      opcode: 0x09,
	      readOnly,
	      rsv1: false
	    };

	    if (isBlob(data)) {
	      if (this._state !== DEFAULT) {
	        this.enqueue([this.getBlobData, data, false, options, cb]);
	      } else {
	        this.getBlobData(data, false, options, cb);
	      }
	    } else if (this._state !== DEFAULT) {
	      this.enqueue([this.dispatch, data, false, options, cb]);
	    } else {
	      this.sendFrame(Sender.frame(data, options), cb);
	    }
	  }

	  /**
	   * Sends a pong message to the other peer.
	   *
	   * @param {*} data The message to send
	   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
	   * @param {Function} [cb] Callback
	   * @public
	   */
	  pong(data, mask, cb) {
	    let byteLength;
	    let readOnly;

	    if (typeof data === 'string') {
	      byteLength = Buffer.byteLength(data);
	      readOnly = false;
	    } else if (isBlob(data)) {
	      byteLength = data.size;
	      readOnly = false;
	    } else {
	      data = toBuffer(data);
	      byteLength = data.length;
	      readOnly = toBuffer.readOnly;
	    }

	    if (byteLength > 125) {
	      throw new RangeError('The data size must not be greater than 125 bytes');
	    }

	    const options = {
	      [kByteLength]: byteLength,
	      fin: true,
	      generateMask: this._generateMask,
	      mask,
	      maskBuffer: this._maskBuffer,
	      opcode: 0x0a,
	      readOnly,
	      rsv1: false
	    };

	    if (isBlob(data)) {
	      if (this._state !== DEFAULT) {
	        this.enqueue([this.getBlobData, data, false, options, cb]);
	      } else {
	        this.getBlobData(data, false, options, cb);
	      }
	    } else if (this._state !== DEFAULT) {
	      this.enqueue([this.dispatch, data, false, options, cb]);
	    } else {
	      this.sendFrame(Sender.frame(data, options), cb);
	    }
	  }

	  /**
	   * Sends a data message to the other peer.
	   *
	   * @param {*} data The message to send
	   * @param {Object} options Options object
	   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
	   *     or text
	   * @param {Boolean} [options.compress=false] Specifies whether or not to
	   *     compress `data`
	   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
	   *     last one
	   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
	   *     `data`
	   * @param {Function} [cb] Callback
	   * @public
	   */
	  send(data, options, cb) {
	    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
	    let opcode = options.binary ? 2 : 1;
	    let rsv1 = options.compress;

	    let byteLength;
	    let readOnly;

	    if (typeof data === 'string') {
	      byteLength = Buffer.byteLength(data);
	      readOnly = false;
	    } else if (isBlob(data)) {
	      byteLength = data.size;
	      readOnly = false;
	    } else {
	      data = toBuffer(data);
	      byteLength = data.length;
	      readOnly = toBuffer.readOnly;
	    }

	    if (this._firstFragment) {
	      this._firstFragment = false;
	      if (
	        rsv1 &&
	        perMessageDeflate &&
	        perMessageDeflate.params[
	          perMessageDeflate._isServer
	            ? 'server_no_context_takeover'
	            : 'client_no_context_takeover'
	        ]
	      ) {
	        rsv1 = byteLength >= perMessageDeflate._threshold;
	      }
	      this._compress = rsv1;
	    } else {
	      rsv1 = false;
	      opcode = 0;
	    }

	    if (options.fin) this._firstFragment = true;

	    const opts = {
	      [kByteLength]: byteLength,
	      fin: options.fin,
	      generateMask: this._generateMask,
	      mask: options.mask,
	      maskBuffer: this._maskBuffer,
	      opcode,
	      readOnly,
	      rsv1
	    };

	    if (isBlob(data)) {
	      if (this._state !== DEFAULT) {
	        this.enqueue([this.getBlobData, data, this._compress, opts, cb]);
	      } else {
	        this.getBlobData(data, this._compress, opts, cb);
	      }
	    } else if (this._state !== DEFAULT) {
	      this.enqueue([this.dispatch, data, this._compress, opts, cb]);
	    } else {
	      this.dispatch(data, this._compress, opts, cb);
	    }
	  }

	  /**
	   * Gets the contents of a blob as binary data.
	   *
	   * @param {Blob} blob The blob
	   * @param {Boolean} [compress=false] Specifies whether or not to compress
	   *     the data
	   * @param {Object} options Options object
	   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
	   *     FIN bit
	   * @param {Function} [options.generateMask] The function used to generate the
	   *     masking key
	   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
	   *     `data`
	   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
	   *     key
	   * @param {Number} options.opcode The opcode
	   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
	   *     modified
	   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
	   *     RSV1 bit
	   * @param {Function} [cb] Callback
	   * @private
	   */
	  getBlobData(blob, compress, options, cb) {
	    this._bufferedBytes += options[kByteLength];
	    this._state = GET_BLOB_DATA;

	    blob
	      .arrayBuffer()
	      .then((arrayBuffer) => {
	        if (this._socket.destroyed) {
	          const err = new Error(
	            'The socket was closed while the blob was being read'
	          );

	          //
	          // `callCallbacks` is called in the next tick to ensure that errors
	          // that might be thrown in the callbacks behave like errors thrown
	          // outside the promise chain.
	          //
	          process.nextTick(callCallbacks, this, err, cb);
	          return;
	        }

	        this._bufferedBytes -= options[kByteLength];
	        const data = toBuffer(arrayBuffer);

	        if (!compress) {
	          this._state = DEFAULT;
	          this.sendFrame(Sender.frame(data, options), cb);
	          this.dequeue();
	        } else {
	          this.dispatch(data, compress, options, cb);
	        }
	      })
	      .catch((err) => {
	        //
	        // `onError` is called in the next tick for the same reason that
	        // `callCallbacks` above is.
	        //
	        process.nextTick(onError, this, err, cb);
	      });
	  }

	  /**
	   * Dispatches a message.
	   *
	   * @param {(Buffer|String)} data The message to send
	   * @param {Boolean} [compress=false] Specifies whether or not to compress
	   *     `data`
	   * @param {Object} options Options object
	   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
	   *     FIN bit
	   * @param {Function} [options.generateMask] The function used to generate the
	   *     masking key
	   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
	   *     `data`
	   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
	   *     key
	   * @param {Number} options.opcode The opcode
	   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
	   *     modified
	   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
	   *     RSV1 bit
	   * @param {Function} [cb] Callback
	   * @private
	   */
	  dispatch(data, compress, options, cb) {
	    if (!compress) {
	      this.sendFrame(Sender.frame(data, options), cb);
	      return;
	    }

	    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

	    this._bufferedBytes += options[kByteLength];
	    this._state = DEFLATING;
	    perMessageDeflate.compress(data, options.fin, (_, buf) => {
	      if (this._socket.destroyed) {
	        const err = new Error(
	          'The socket was closed while data was being compressed'
	        );

	        callCallbacks(this, err, cb);
	        return;
	      }

	      this._bufferedBytes -= options[kByteLength];
	      this._state = DEFAULT;
	      options.readOnly = false;
	      this.sendFrame(Sender.frame(buf, options), cb);
	      this.dequeue();
	    });
	  }

	  /**
	   * Executes queued send operations.
	   *
	   * @private
	   */
	  dequeue() {
	    while (this._state === DEFAULT && this._queue.length) {
	      const params = this._queue.shift();

	      this._bufferedBytes -= params[3][kByteLength];
	      Reflect.apply(params[0], this, params.slice(1));
	    }
	  }

	  /**
	   * Enqueues a send operation.
	   *
	   * @param {Array} params Send operation parameters.
	   * @private
	   */
	  enqueue(params) {
	    this._bufferedBytes += params[3][kByteLength];
	    this._queue.push(params);
	  }

	  /**
	   * Sends a frame.
	   *
	   * @param {(Buffer | String)[]} list The frame to send
	   * @param {Function} [cb] Callback
	   * @private
	   */
	  sendFrame(list, cb) {
	    if (list.length === 2) {
	      this._socket.cork();
	      this._socket.write(list[0]);
	      this._socket.write(list[1], cb);
	      this._socket.uncork();
	    } else {
	      this._socket.write(list[0], cb);
	    }
	  }
	}

	sender = Sender;

	/**
	 * Calls queued callbacks with an error.
	 *
	 * @param {Sender} sender The `Sender` instance
	 * @param {Error} err The error to call the callbacks with
	 * @param {Function} [cb] The first callback
	 * @private
	 */
	function callCallbacks(sender, err, cb) {
	  if (typeof cb === 'function') cb(err);

	  for (let i = 0; i < sender._queue.length; i++) {
	    const params = sender._queue[i];
	    const callback = params[params.length - 1];

	    if (typeof callback === 'function') callback(err);
	  }
	}

	/**
	 * Handles a `Sender` error.
	 *
	 * @param {Sender} sender The `Sender` instance
	 * @param {Error} err The error
	 * @param {Function} [cb] The first pending callback
	 * @private
	 */
	function onError(sender, err, cb) {
	  callCallbacks(sender, err, cb);
	  sender.onerror(err);
	}
	return sender;
}

var eventTarget;
var hasRequiredEventTarget;

function requireEventTarget () {
	if (hasRequiredEventTarget) return eventTarget;
	hasRequiredEventTarget = 1;

	const { kForOnEventAttribute, kListener } = requireConstants();

	const kCode = Symbol('kCode');
	const kData = Symbol('kData');
	const kError = Symbol('kError');
	const kMessage = Symbol('kMessage');
	const kReason = Symbol('kReason');
	const kTarget = Symbol('kTarget');
	const kType = Symbol('kType');
	const kWasClean = Symbol('kWasClean');

	/**
	 * Class representing an event.
	 */
	class Event {
	  /**
	   * Create a new `Event`.
	   *
	   * @param {String} type The name of the event
	   * @throws {TypeError} If the `type` argument is not specified
	   */
	  constructor(type) {
	    this[kTarget] = null;
	    this[kType] = type;
	  }

	  /**
	   * @type {*}
	   */
	  get target() {
	    return this[kTarget];
	  }

	  /**
	   * @type {String}
	   */
	  get type() {
	    return this[kType];
	  }
	}

	Object.defineProperty(Event.prototype, 'target', { enumerable: true });
	Object.defineProperty(Event.prototype, 'type', { enumerable: true });

	/**
	 * Class representing a close event.
	 *
	 * @extends Event
	 */
	class CloseEvent extends Event {
	  /**
	   * Create a new `CloseEvent`.
	   *
	   * @param {String} type The name of the event
	   * @param {Object} [options] A dictionary object that allows for setting
	   *     attributes via object members of the same name
	   * @param {Number} [options.code=0] The status code explaining why the
	   *     connection was closed
	   * @param {String} [options.reason=''] A human-readable string explaining why
	   *     the connection was closed
	   * @param {Boolean} [options.wasClean=false] Indicates whether or not the
	   *     connection was cleanly closed
	   */
	  constructor(type, options = {}) {
	    super(type);

	    this[kCode] = options.code === undefined ? 0 : options.code;
	    this[kReason] = options.reason === undefined ? '' : options.reason;
	    this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;
	  }

	  /**
	   * @type {Number}
	   */
	  get code() {
	    return this[kCode];
	  }

	  /**
	   * @type {String}
	   */
	  get reason() {
	    return this[kReason];
	  }

	  /**
	   * @type {Boolean}
	   */
	  get wasClean() {
	    return this[kWasClean];
	  }
	}

	Object.defineProperty(CloseEvent.prototype, 'code', { enumerable: true });
	Object.defineProperty(CloseEvent.prototype, 'reason', { enumerable: true });
	Object.defineProperty(CloseEvent.prototype, 'wasClean', { enumerable: true });

	/**
	 * Class representing an error event.
	 *
	 * @extends Event
	 */
	class ErrorEvent extends Event {
	  /**
	   * Create a new `ErrorEvent`.
	   *
	   * @param {String} type The name of the event
	   * @param {Object} [options] A dictionary object that allows for setting
	   *     attributes via object members of the same name
	   * @param {*} [options.error=null] The error that generated this event
	   * @param {String} [options.message=''] The error message
	   */
	  constructor(type, options = {}) {
	    super(type);

	    this[kError] = options.error === undefined ? null : options.error;
	    this[kMessage] = options.message === undefined ? '' : options.message;
	  }

	  /**
	   * @type {*}
	   */
	  get error() {
	    return this[kError];
	  }

	  /**
	   * @type {String}
	   */
	  get message() {
	    return this[kMessage];
	  }
	}

	Object.defineProperty(ErrorEvent.prototype, 'error', { enumerable: true });
	Object.defineProperty(ErrorEvent.prototype, 'message', { enumerable: true });

	/**
	 * Class representing a message event.
	 *
	 * @extends Event
	 */
	class MessageEvent extends Event {
	  /**
	   * Create a new `MessageEvent`.
	   *
	   * @param {String} type The name of the event
	   * @param {Object} [options] A dictionary object that allows for setting
	   *     attributes via object members of the same name
	   * @param {*} [options.data=null] The message content
	   */
	  constructor(type, options = {}) {
	    super(type);

	    this[kData] = options.data === undefined ? null : options.data;
	  }

	  /**
	   * @type {*}
	   */
	  get data() {
	    return this[kData];
	  }
	}

	Object.defineProperty(MessageEvent.prototype, 'data', { enumerable: true });

	/**
	 * This provides methods for emulating the `EventTarget` interface. It's not
	 * meant to be used directly.
	 *
	 * @mixin
	 */
	const EventTarget = {
	  /**
	   * Register an event listener.
	   *
	   * @param {String} type A string representing the event type to listen for
	   * @param {(Function|Object)} handler The listener to add
	   * @param {Object} [options] An options object specifies characteristics about
	   *     the event listener
	   * @param {Boolean} [options.once=false] A `Boolean` indicating that the
	   *     listener should be invoked at most once after being added. If `true`,
	   *     the listener would be automatically removed when invoked.
	   * @public
	   */
	  addEventListener(type, handler, options = {}) {
	    for (const listener of this.listeners(type)) {
	      if (
	        !options[kForOnEventAttribute] &&
	        listener[kListener] === handler &&
	        !listener[kForOnEventAttribute]
	      ) {
	        return;
	      }
	    }

	    let wrapper;

	    if (type === 'message') {
	      wrapper = function onMessage(data, isBinary) {
	        const event = new MessageEvent('message', {
	          data: isBinary ? data : data.toString()
	        });

	        event[kTarget] = this;
	        callListener(handler, this, event);
	      };
	    } else if (type === 'close') {
	      wrapper = function onClose(code, message) {
	        const event = new CloseEvent('close', {
	          code,
	          reason: message.toString(),
	          wasClean: this._closeFrameReceived && this._closeFrameSent
	        });

	        event[kTarget] = this;
	        callListener(handler, this, event);
	      };
	    } else if (type === 'error') {
	      wrapper = function onError(error) {
	        const event = new ErrorEvent('error', {
	          error,
	          message: error.message
	        });

	        event[kTarget] = this;
	        callListener(handler, this, event);
	      };
	    } else if (type === 'open') {
	      wrapper = function onOpen() {
	        const event = new Event('open');

	        event[kTarget] = this;
	        callListener(handler, this, event);
	      };
	    } else {
	      return;
	    }

	    wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
	    wrapper[kListener] = handler;

	    if (options.once) {
	      this.once(type, wrapper);
	    } else {
	      this.on(type, wrapper);
	    }
	  },

	  /**
	   * Remove an event listener.
	   *
	   * @param {String} type A string representing the event type to remove
	   * @param {(Function|Object)} handler The listener to remove
	   * @public
	   */
	  removeEventListener(type, handler) {
	    for (const listener of this.listeners(type)) {
	      if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
	        this.removeListener(type, listener);
	        break;
	      }
	    }
	  }
	};

	eventTarget = {
	  CloseEvent,
	  ErrorEvent,
	  Event,
	  EventTarget,
	  MessageEvent
	};

	/**
	 * Call an event listener
	 *
	 * @param {(Function|Object)} listener The listener to call
	 * @param {*} thisArg The value to use as `this`` when calling the listener
	 * @param {Event} event The event to pass to the listener
	 * @private
	 */
	function callListener(listener, thisArg, event) {
	  if (typeof listener === 'object' && listener.handleEvent) {
	    listener.handleEvent.call(listener, event);
	  } else {
	    listener.call(thisArg, event);
	  }
	}
	return eventTarget;
}

var extension;
var hasRequiredExtension;

function requireExtension () {
	if (hasRequiredExtension) return extension;
	hasRequiredExtension = 1;

	const { tokenChars } = requireValidation();

	/**
	 * Adds an offer to the map of extension offers or a parameter to the map of
	 * parameters.
	 *
	 * @param {Object} dest The map of extension offers or parameters
	 * @param {String} name The extension or parameter name
	 * @param {(Object|Boolean|String)} elem The extension parameters or the
	 *     parameter value
	 * @private
	 */
	function push(dest, name, elem) {
	  if (dest[name] === undefined) dest[name] = [elem];
	  else dest[name].push(elem);
	}

	/**
	 * Parses the `Sec-WebSocket-Extensions` header into an object.
	 *
	 * @param {String} header The field value of the header
	 * @return {Object} The parsed object
	 * @public
	 */
	function parse(header) {
	  const offers = Object.create(null);
	  let params = Object.create(null);
	  let mustUnescape = false;
	  let isEscaping = false;
	  let inQuotes = false;
	  let extensionName;
	  let paramName;
	  let start = -1;
	  let code = -1;
	  let end = -1;
	  let i = 0;

	  for (; i < header.length; i++) {
	    code = header.charCodeAt(i);

	    if (extensionName === undefined) {
	      if (end === -1 && tokenChars[code] === 1) {
	        if (start === -1) start = i;
	      } else if (
	        i !== 0 &&
	        (code === 0x20 /* ' ' */ || code === 0x09) /* '\t' */
	      ) {
	        if (end === -1 && start !== -1) end = i;
	      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {
	        if (start === -1) {
	          throw new SyntaxError(`Unexpected character at index ${i}`);
	        }

	        if (end === -1) end = i;
	        const name = header.slice(start, end);
	        if (code === 0x2c) {
	          push(offers, name, params);
	          params = Object.create(null);
	        } else {
	          extensionName = name;
	        }

	        start = end = -1;
	      } else {
	        throw new SyntaxError(`Unexpected character at index ${i}`);
	      }
	    } else if (paramName === undefined) {
	      if (end === -1 && tokenChars[code] === 1) {
	        if (start === -1) start = i;
	      } else if (code === 0x20 || code === 0x09) {
	        if (end === -1 && start !== -1) end = i;
	      } else if (code === 0x3b || code === 0x2c) {
	        if (start === -1) {
	          throw new SyntaxError(`Unexpected character at index ${i}`);
	        }

	        if (end === -1) end = i;
	        push(params, header.slice(start, end), true);
	        if (code === 0x2c) {
	          push(offers, extensionName, params);
	          params = Object.create(null);
	          extensionName = undefined;
	        }

	        start = end = -1;
	      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {
	        paramName = header.slice(start, i);
	        start = end = -1;
	      } else {
	        throw new SyntaxError(`Unexpected character at index ${i}`);
	      }
	    } else {
	      //
	      // The value of a quoted-string after unescaping must conform to the
	      // token ABNF, so only token characters are valid.
	      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1
	      //
	      if (isEscaping) {
	        if (tokenChars[code] !== 1) {
	          throw new SyntaxError(`Unexpected character at index ${i}`);
	        }
	        if (start === -1) start = i;
	        else if (!mustUnescape) mustUnescape = true;
	        isEscaping = false;
	      } else if (inQuotes) {
	        if (tokenChars[code] === 1) {
	          if (start === -1) start = i;
	        } else if (code === 0x22 /* '"' */ && start !== -1) {
	          inQuotes = false;
	          end = i;
	        } else if (code === 0x5c /* '\' */) {
	          isEscaping = true;
	        } else {
	          throw new SyntaxError(`Unexpected character at index ${i}`);
	        }
	      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {
	        inQuotes = true;
	      } else if (end === -1 && tokenChars[code] === 1) {
	        if (start === -1) start = i;
	      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {
	        if (end === -1) end = i;
	      } else if (code === 0x3b || code === 0x2c) {
	        if (start === -1) {
	          throw new SyntaxError(`Unexpected character at index ${i}`);
	        }

	        if (end === -1) end = i;
	        let value = header.slice(start, end);
	        if (mustUnescape) {
	          value = value.replace(/\\/g, '');
	          mustUnescape = false;
	        }
	        push(params, paramName, value);
	        if (code === 0x2c) {
	          push(offers, extensionName, params);
	          params = Object.create(null);
	          extensionName = undefined;
	        }

	        paramName = undefined;
	        start = end = -1;
	      } else {
	        throw new SyntaxError(`Unexpected character at index ${i}`);
	      }
	    }
	  }

	  if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {
	    throw new SyntaxError('Unexpected end of input');
	  }

	  if (end === -1) end = i;
	  const token = header.slice(start, end);
	  if (extensionName === undefined) {
	    push(offers, token, params);
	  } else {
	    if (paramName === undefined) {
	      push(params, token, true);
	    } else if (mustUnescape) {
	      push(params, paramName, token.replace(/\\/g, ''));
	    } else {
	      push(params, paramName, token);
	    }
	    push(offers, extensionName, params);
	  }

	  return offers;
	}

	/**
	 * Builds the `Sec-WebSocket-Extensions` header field value.
	 *
	 * @param {Object} extensions The map of extensions and parameters to format
	 * @return {String} A string representing the given object
	 * @public
	 */
	function format(extensions) {
	  return Object.keys(extensions)
	    .map((extension) => {
	      let configurations = extensions[extension];
	      if (!Array.isArray(configurations)) configurations = [configurations];
	      return configurations
	        .map((params) => {
	          return [extension]
	            .concat(
	              Object.keys(params).map((k) => {
	                let values = params[k];
	                if (!Array.isArray(values)) values = [values];
	                return values
	                  .map((v) => (v === true ? k : `${k}=${v}`))
	                  .join('; ');
	              })
	            )
	            .join('; ');
	        })
	        .join(', ');
	    })
	    .join(', ');
	}

	extension = { format, parse };
	return extension;
}

/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex|Readable$", "caughtErrors": "none" }] */

var websocket;
var hasRequiredWebsocket;

function requireWebsocket () {
	if (hasRequiredWebsocket) return websocket;
	hasRequiredWebsocket = 1;

	const EventEmitter = require$$0$3;
	const https = require$$1;
	const http = require$$2;
	const net = require$$0$5;
	const tls = require$$4$1;
	const { randomBytes, createHash } = require$$3;
	const { Duplex, Readable } = require$$0$6;
	const { URL } = require$$7$1;

	const PerMessageDeflate = requirePermessageDeflate();
	const Receiver = requireReceiver();
	const Sender = requireSender();
	const { isBlob } = requireValidation();

	const {
	  BINARY_TYPES,
	  EMPTY_BUFFER,
	  GUID,
	  kForOnEventAttribute,
	  kListener,
	  kStatusCode,
	  kWebSocket,
	  NOOP
	} = requireConstants();
	const {
	  EventTarget: { addEventListener, removeEventListener }
	} = requireEventTarget();
	const { format, parse } = requireExtension();
	const { toBuffer } = requireBufferUtil();

	const closeTimeout = 30 * 1000;
	const kAborted = Symbol('kAborted');
	const protocolVersions = [8, 13];
	const readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
	const subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;

	/**
	 * Class representing a WebSocket.
	 *
	 * @extends EventEmitter
	 */
	class WebSocket extends EventEmitter {
	  /**
	   * Create a new `WebSocket`.
	   *
	   * @param {(String|URL)} address The URL to which to connect
	   * @param {(String|String[])} [protocols] The subprotocols
	   * @param {Object} [options] Connection options
	   */
	  constructor(address, protocols, options) {
	    super();

	    this._binaryType = BINARY_TYPES[0];
	    this._closeCode = 1006;
	    this._closeFrameReceived = false;
	    this._closeFrameSent = false;
	    this._closeMessage = EMPTY_BUFFER;
	    this._closeTimer = null;
	    this._errorEmitted = false;
	    this._extensions = {};
	    this._paused = false;
	    this._protocol = '';
	    this._readyState = WebSocket.CONNECTING;
	    this._receiver = null;
	    this._sender = null;
	    this._socket = null;

	    if (address !== null) {
	      this._bufferedAmount = 0;
	      this._isServer = false;
	      this._redirects = 0;

	      if (protocols === undefined) {
	        protocols = [];
	      } else if (!Array.isArray(protocols)) {
	        if (typeof protocols === 'object' && protocols !== null) {
	          options = protocols;
	          protocols = [];
	        } else {
	          protocols = [protocols];
	        }
	      }

	      initAsClient(this, address, protocols, options);
	    } else {
	      this._autoPong = options.autoPong;
	      this._isServer = true;
	    }
	  }

	  /**
	   * For historical reasons, the custom "nodebuffer" type is used by the default
	   * instead of "blob".
	   *
	   * @type {String}
	   */
	  get binaryType() {
	    return this._binaryType;
	  }

	  set binaryType(type) {
	    if (!BINARY_TYPES.includes(type)) return;

	    this._binaryType = type;

	    //
	    // Allow to change `binaryType` on the fly.
	    //
	    if (this._receiver) this._receiver._binaryType = type;
	  }

	  /**
	   * @type {Number}
	   */
	  get bufferedAmount() {
	    if (!this._socket) return this._bufferedAmount;

	    return this._socket._writableState.length + this._sender._bufferedBytes;
	  }

	  /**
	   * @type {String}
	   */
	  get extensions() {
	    return Object.keys(this._extensions).join();
	  }

	  /**
	   * @type {Boolean}
	   */
	  get isPaused() {
	    return this._paused;
	  }

	  /**
	   * @type {Function}
	   */
	  /* istanbul ignore next */
	  get onclose() {
	    return null;
	  }

	  /**
	   * @type {Function}
	   */
	  /* istanbul ignore next */
	  get onerror() {
	    return null;
	  }

	  /**
	   * @type {Function}
	   */
	  /* istanbul ignore next */
	  get onopen() {
	    return null;
	  }

	  /**
	   * @type {Function}
	   */
	  /* istanbul ignore next */
	  get onmessage() {
	    return null;
	  }

	  /**
	   * @type {String}
	   */
	  get protocol() {
	    return this._protocol;
	  }

	  /**
	   * @type {Number}
	   */
	  get readyState() {
	    return this._readyState;
	  }

	  /**
	   * @type {String}
	   */
	  get url() {
	    return this._url;
	  }

	  /**
	   * Set up the socket and the internal resources.
	   *
	   * @param {Duplex} socket The network socket between the server and client
	   * @param {Buffer} head The first packet of the upgraded stream
	   * @param {Object} options Options object
	   * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether
	   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
	   *     multiple times in the same tick
	   * @param {Function} [options.generateMask] The function used to generate the
	   *     masking key
	   * @param {Number} [options.maxPayload=0] The maximum allowed message size
	   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
	   *     not to skip UTF-8 validation for text and close messages
	   * @private
	   */
	  setSocket(socket, head, options) {
	    const receiver = new Receiver({
	      allowSynchronousEvents: options.allowSynchronousEvents,
	      binaryType: this.binaryType,
	      extensions: this._extensions,
	      isServer: this._isServer,
	      maxPayload: options.maxPayload,
	      skipUTF8Validation: options.skipUTF8Validation
	    });

	    const sender = new Sender(socket, this._extensions, options.generateMask);

	    this._receiver = receiver;
	    this._sender = sender;
	    this._socket = socket;

	    receiver[kWebSocket] = this;
	    sender[kWebSocket] = this;
	    socket[kWebSocket] = this;

	    receiver.on('conclude', receiverOnConclude);
	    receiver.on('drain', receiverOnDrain);
	    receiver.on('error', receiverOnError);
	    receiver.on('message', receiverOnMessage);
	    receiver.on('ping', receiverOnPing);
	    receiver.on('pong', receiverOnPong);

	    sender.onerror = senderOnError;

	    //
	    // These methods may not be available if `socket` is just a `Duplex`.
	    //
	    if (socket.setTimeout) socket.setTimeout(0);
	    if (socket.setNoDelay) socket.setNoDelay();

	    if (head.length > 0) socket.unshift(head);

	    socket.on('close', socketOnClose);
	    socket.on('data', socketOnData);
	    socket.on('end', socketOnEnd);
	    socket.on('error', socketOnError);

	    this._readyState = WebSocket.OPEN;
	    this.emit('open');
	  }

	  /**
	   * Emit the `'close'` event.
	   *
	   * @private
	   */
	  emitClose() {
	    if (!this._socket) {
	      this._readyState = WebSocket.CLOSED;
	      this.emit('close', this._closeCode, this._closeMessage);
	      return;
	    }

	    if (this._extensions[PerMessageDeflate.extensionName]) {
	      this._extensions[PerMessageDeflate.extensionName].cleanup();
	    }

	    this._receiver.removeAllListeners();
	    this._readyState = WebSocket.CLOSED;
	    this.emit('close', this._closeCode, this._closeMessage);
	  }

	  /**
	   * Start a closing handshake.
	   *
	   *          +----------+   +-----------+   +----------+
	   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
	   *    |     +----------+   +-----------+   +----------+     |
	   *          +----------+   +-----------+         |
	   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
	   *          +----------+   +-----------+   |
	   *    |           |                        |   +---+        |
	   *                +------------------------+-->|fin| - - - -
	   *    |         +---+                      |   +---+
	   *     - - - - -|fin|<---------------------+
	   *              +---+
	   *
	   * @param {Number} [code] Status code explaining why the connection is closing
	   * @param {(String|Buffer)} [data] The reason why the connection is
	   *     closing
	   * @public
	   */
	  close(code, data) {
	    if (this.readyState === WebSocket.CLOSED) return;
	    if (this.readyState === WebSocket.CONNECTING) {
	      const msg = 'WebSocket was closed before the connection was established';
	      abortHandshake(this, this._req, msg);
	      return;
	    }

	    if (this.readyState === WebSocket.CLOSING) {
	      if (
	        this._closeFrameSent &&
	        (this._closeFrameReceived || this._receiver._writableState.errorEmitted)
	      ) {
	        this._socket.end();
	      }

	      return;
	    }

	    this._readyState = WebSocket.CLOSING;
	    this._sender.close(code, data, !this._isServer, (err) => {
	      //
	      // This error is handled by the `'error'` listener on the socket. We only
	      // want to know if the close frame has been sent here.
	      //
	      if (err) return;

	      this._closeFrameSent = true;

	      if (
	        this._closeFrameReceived ||
	        this._receiver._writableState.errorEmitted
	      ) {
	        this._socket.end();
	      }
	    });

	    setCloseTimer(this);
	  }

	  /**
	   * Pause the socket.
	   *
	   * @public
	   */
	  pause() {
	    if (
	      this.readyState === WebSocket.CONNECTING ||
	      this.readyState === WebSocket.CLOSED
	    ) {
	      return;
	    }

	    this._paused = true;
	    this._socket.pause();
	  }

	  /**
	   * Send a ping.
	   *
	   * @param {*} [data] The data to send
	   * @param {Boolean} [mask] Indicates whether or not to mask `data`
	   * @param {Function} [cb] Callback which is executed when the ping is sent
	   * @public
	   */
	  ping(data, mask, cb) {
	    if (this.readyState === WebSocket.CONNECTING) {
	      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
	    }

	    if (typeof data === 'function') {
	      cb = data;
	      data = mask = undefined;
	    } else if (typeof mask === 'function') {
	      cb = mask;
	      mask = undefined;
	    }

	    if (typeof data === 'number') data = data.toString();

	    if (this.readyState !== WebSocket.OPEN) {
	      sendAfterClose(this, data, cb);
	      return;
	    }

	    if (mask === undefined) mask = !this._isServer;
	    this._sender.ping(data || EMPTY_BUFFER, mask, cb);
	  }

	  /**
	   * Send a pong.
	   *
	   * @param {*} [data] The data to send
	   * @param {Boolean} [mask] Indicates whether or not to mask `data`
	   * @param {Function} [cb] Callback which is executed when the pong is sent
	   * @public
	   */
	  pong(data, mask, cb) {
	    if (this.readyState === WebSocket.CONNECTING) {
	      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
	    }

	    if (typeof data === 'function') {
	      cb = data;
	      data = mask = undefined;
	    } else if (typeof mask === 'function') {
	      cb = mask;
	      mask = undefined;
	    }

	    if (typeof data === 'number') data = data.toString();

	    if (this.readyState !== WebSocket.OPEN) {
	      sendAfterClose(this, data, cb);
	      return;
	    }

	    if (mask === undefined) mask = !this._isServer;
	    this._sender.pong(data || EMPTY_BUFFER, mask, cb);
	  }

	  /**
	   * Resume the socket.
	   *
	   * @public
	   */
	  resume() {
	    if (
	      this.readyState === WebSocket.CONNECTING ||
	      this.readyState === WebSocket.CLOSED
	    ) {
	      return;
	    }

	    this._paused = false;
	    if (!this._receiver._writableState.needDrain) this._socket.resume();
	  }

	  /**
	   * Send a data message.
	   *
	   * @param {*} data The message to send
	   * @param {Object} [options] Options object
	   * @param {Boolean} [options.binary] Specifies whether `data` is binary or
	   *     text
	   * @param {Boolean} [options.compress] Specifies whether or not to compress
	   *     `data`
	   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
	   *     last one
	   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
	   * @param {Function} [cb] Callback which is executed when data is written out
	   * @public
	   */
	  send(data, options, cb) {
	    if (this.readyState === WebSocket.CONNECTING) {
	      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
	    }

	    if (typeof options === 'function') {
	      cb = options;
	      options = {};
	    }

	    if (typeof data === 'number') data = data.toString();

	    if (this.readyState !== WebSocket.OPEN) {
	      sendAfterClose(this, data, cb);
	      return;
	    }

	    const opts = {
	      binary: typeof data !== 'string',
	      mask: !this._isServer,
	      compress: true,
	      fin: true,
	      ...options
	    };

	    if (!this._extensions[PerMessageDeflate.extensionName]) {
	      opts.compress = false;
	    }

	    this._sender.send(data || EMPTY_BUFFER, opts, cb);
	  }

	  /**
	   * Forcibly close the connection.
	   *
	   * @public
	   */
	  terminate() {
	    if (this.readyState === WebSocket.CLOSED) return;
	    if (this.readyState === WebSocket.CONNECTING) {
	      const msg = 'WebSocket was closed before the connection was established';
	      abortHandshake(this, this._req, msg);
	      return;
	    }

	    if (this._socket) {
	      this._readyState = WebSocket.CLOSING;
	      this._socket.destroy();
	    }
	  }
	}

	/**
	 * @constant {Number} CONNECTING
	 * @memberof WebSocket
	 */
	Object.defineProperty(WebSocket, 'CONNECTING', {
	  enumerable: true,
	  value: readyStates.indexOf('CONNECTING')
	});

	/**
	 * @constant {Number} CONNECTING
	 * @memberof WebSocket.prototype
	 */
	Object.defineProperty(WebSocket.prototype, 'CONNECTING', {
	  enumerable: true,
	  value: readyStates.indexOf('CONNECTING')
	});

	/**
	 * @constant {Number} OPEN
	 * @memberof WebSocket
	 */
	Object.defineProperty(WebSocket, 'OPEN', {
	  enumerable: true,
	  value: readyStates.indexOf('OPEN')
	});

	/**
	 * @constant {Number} OPEN
	 * @memberof WebSocket.prototype
	 */
	Object.defineProperty(WebSocket.prototype, 'OPEN', {
	  enumerable: true,
	  value: readyStates.indexOf('OPEN')
	});

	/**
	 * @constant {Number} CLOSING
	 * @memberof WebSocket
	 */
	Object.defineProperty(WebSocket, 'CLOSING', {
	  enumerable: true,
	  value: readyStates.indexOf('CLOSING')
	});

	/**
	 * @constant {Number} CLOSING
	 * @memberof WebSocket.prototype
	 */
	Object.defineProperty(WebSocket.prototype, 'CLOSING', {
	  enumerable: true,
	  value: readyStates.indexOf('CLOSING')
	});

	/**
	 * @constant {Number} CLOSED
	 * @memberof WebSocket
	 */
	Object.defineProperty(WebSocket, 'CLOSED', {
	  enumerable: true,
	  value: readyStates.indexOf('CLOSED')
	});

	/**
	 * @constant {Number} CLOSED
	 * @memberof WebSocket.prototype
	 */
	Object.defineProperty(WebSocket.prototype, 'CLOSED', {
	  enumerable: true,
	  value: readyStates.indexOf('CLOSED')
	});

	[
	  'binaryType',
	  'bufferedAmount',
	  'extensions',
	  'isPaused',
	  'protocol',
	  'readyState',
	  'url'
	].forEach((property) => {
	  Object.defineProperty(WebSocket.prototype, property, { enumerable: true });
	});

	//
	// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.
	// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface
	//
	['open', 'error', 'close', 'message'].forEach((method) => {
	  Object.defineProperty(WebSocket.prototype, `on${method}`, {
	    enumerable: true,
	    get() {
	      for (const listener of this.listeners(method)) {
	        if (listener[kForOnEventAttribute]) return listener[kListener];
	      }

	      return null;
	    },
	    set(handler) {
	      for (const listener of this.listeners(method)) {
	        if (listener[kForOnEventAttribute]) {
	          this.removeListener(method, listener);
	          break;
	        }
	      }

	      if (typeof handler !== 'function') return;

	      this.addEventListener(method, handler, {
	        [kForOnEventAttribute]: true
	      });
	    }
	  });
	});

	WebSocket.prototype.addEventListener = addEventListener;
	WebSocket.prototype.removeEventListener = removeEventListener;

	websocket = WebSocket;

	/**
	 * Initialize a WebSocket client.
	 *
	 * @param {WebSocket} websocket The client to initialize
	 * @param {(String|URL)} address The URL to which to connect
	 * @param {Array} protocols The subprotocols
	 * @param {Object} [options] Connection options
	 * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether any
	 *     of the `'message'`, `'ping'`, and `'pong'` events can be emitted multiple
	 *     times in the same tick
	 * @param {Boolean} [options.autoPong=true] Specifies whether or not to
	 *     automatically send a pong in response to a ping
	 * @param {Function} [options.finishRequest] A function which can be used to
	 *     customize the headers of each http request before it is sent
	 * @param {Boolean} [options.followRedirects=false] Whether or not to follow
	 *     redirects
	 * @param {Function} [options.generateMask] The function used to generate the
	 *     masking key
	 * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the
	 *     handshake request
	 * @param {Number} [options.maxPayload=104857600] The maximum allowed message
	 *     size
	 * @param {Number} [options.maxRedirects=10] The maximum number of redirects
	 *     allowed
	 * @param {String} [options.origin] Value of the `Origin` or
	 *     `Sec-WebSocket-Origin` header
	 * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable
	 *     permessage-deflate
	 * @param {Number} [options.protocolVersion=13] Value of the
	 *     `Sec-WebSocket-Version` header
	 * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
	 *     not to skip UTF-8 validation for text and close messages
	 * @private
	 */
	function initAsClient(websocket, address, protocols, options) {
	  const opts = {
	    allowSynchronousEvents: true,
	    autoPong: true,
	    protocolVersion: protocolVersions[1],
	    maxPayload: 100 * 1024 * 1024,
	    skipUTF8Validation: false,
	    perMessageDeflate: true,
	    followRedirects: false,
	    maxRedirects: 10,
	    ...options,
	    socketPath: undefined,
	    hostname: undefined,
	    protocol: undefined,
	    timeout: undefined,
	    method: 'GET',
	    host: undefined,
	    path: undefined,
	    port: undefined
	  };

	  websocket._autoPong = opts.autoPong;

	  if (!protocolVersions.includes(opts.protocolVersion)) {
	    throw new RangeError(
	      `Unsupported protocol version: ${opts.protocolVersion} ` +
	        `(supported versions: ${protocolVersions.join(', ')})`
	    );
	  }

	  let parsedUrl;

	  if (address instanceof URL) {
	    parsedUrl = address;
	  } else {
	    try {
	      parsedUrl = new URL(address);
	    } catch (e) {
	      throw new SyntaxError(`Invalid URL: ${address}`);
	    }
	  }

	  if (parsedUrl.protocol === 'http:') {
	    parsedUrl.protocol = 'ws:';
	  } else if (parsedUrl.protocol === 'https:') {
	    parsedUrl.protocol = 'wss:';
	  }

	  websocket._url = parsedUrl.href;

	  const isSecure = parsedUrl.protocol === 'wss:';
	  const isIpcUrl = parsedUrl.protocol === 'ws+unix:';
	  let invalidUrlMessage;

	  if (parsedUrl.protocol !== 'ws:' && !isSecure && !isIpcUrl) {
	    invalidUrlMessage =
	      'The URL\'s protocol must be one of "ws:", "wss:", ' +
	      '"http:", "https", or "ws+unix:"';
	  } else if (isIpcUrl && !parsedUrl.pathname) {
	    invalidUrlMessage = "The URL's pathname is empty";
	  } else if (parsedUrl.hash) {
	    invalidUrlMessage = 'The URL contains a fragment identifier';
	  }

	  if (invalidUrlMessage) {
	    const err = new SyntaxError(invalidUrlMessage);

	    if (websocket._redirects === 0) {
	      throw err;
	    } else {
	      emitErrorAndClose(websocket, err);
	      return;
	    }
	  }

	  const defaultPort = isSecure ? 443 : 80;
	  const key = randomBytes(16).toString('base64');
	  const request = isSecure ? https.request : http.request;
	  const protocolSet = new Set();
	  let perMessageDeflate;

	  opts.createConnection =
	    opts.createConnection || (isSecure ? tlsConnect : netConnect);
	  opts.defaultPort = opts.defaultPort || defaultPort;
	  opts.port = parsedUrl.port || defaultPort;
	  opts.host = parsedUrl.hostname.startsWith('[')
	    ? parsedUrl.hostname.slice(1, -1)
	    : parsedUrl.hostname;
	  opts.headers = {
	    ...opts.headers,
	    'Sec-WebSocket-Version': opts.protocolVersion,
	    'Sec-WebSocket-Key': key,
	    Connection: 'Upgrade',
	    Upgrade: 'websocket'
	  };
	  opts.path = parsedUrl.pathname + parsedUrl.search;
	  opts.timeout = opts.handshakeTimeout;

	  if (opts.perMessageDeflate) {
	    perMessageDeflate = new PerMessageDeflate(
	      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
	      false,
	      opts.maxPayload
	    );
	    opts.headers['Sec-WebSocket-Extensions'] = format({
	      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
	    });
	  }
	  if (protocols.length) {
	    for (const protocol of protocols) {
	      if (
	        typeof protocol !== 'string' ||
	        !subprotocolRegex.test(protocol) ||
	        protocolSet.has(protocol)
	      ) {
	        throw new SyntaxError(
	          'An invalid or duplicated subprotocol was specified'
	        );
	      }

	      protocolSet.add(protocol);
	    }

	    opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');
	  }
	  if (opts.origin) {
	    if (opts.protocolVersion < 13) {
	      opts.headers['Sec-WebSocket-Origin'] = opts.origin;
	    } else {
	      opts.headers.Origin = opts.origin;
	    }
	  }
	  if (parsedUrl.username || parsedUrl.password) {
	    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
	  }

	  if (isIpcUrl) {
	    const parts = opts.path.split(':');

	    opts.socketPath = parts[0];
	    opts.path = parts[1];
	  }

	  let req;

	  if (opts.followRedirects) {
	    if (websocket._redirects === 0) {
	      websocket._originalIpc = isIpcUrl;
	      websocket._originalSecure = isSecure;
	      websocket._originalHostOrSocketPath = isIpcUrl
	        ? opts.socketPath
	        : parsedUrl.host;

	      const headers = options && options.headers;

	      //
	      // Shallow copy the user provided options so that headers can be changed
	      // without mutating the original object.
	      //
	      options = { ...options, headers: {} };

	      if (headers) {
	        for (const [key, value] of Object.entries(headers)) {
	          options.headers[key.toLowerCase()] = value;
	        }
	      }
	    } else if (websocket.listenerCount('redirect') === 0) {
	      const isSameHost = isIpcUrl
	        ? websocket._originalIpc
	          ? opts.socketPath === websocket._originalHostOrSocketPath
	          : false
	        : websocket._originalIpc
	          ? false
	          : parsedUrl.host === websocket._originalHostOrSocketPath;

	      if (!isSameHost || (websocket._originalSecure && !isSecure)) {
	        //
	        // Match curl 7.77.0 behavior and drop the following headers. These
	        // headers are also dropped when following a redirect to a subdomain.
	        //
	        delete opts.headers.authorization;
	        delete opts.headers.cookie;

	        if (!isSameHost) delete opts.headers.host;

	        opts.auth = undefined;
	      }
	    }

	    //
	    // Match curl 7.77.0 behavior and make the first `Authorization` header win.
	    // If the `Authorization` header is set, then there is nothing to do as it
	    // will take precedence.
	    //
	    if (opts.auth && !options.headers.authorization) {
	      options.headers.authorization =
	        'Basic ' + Buffer.from(opts.auth).toString('base64');
	    }

	    req = websocket._req = request(opts);

	    if (websocket._redirects) {
	      //
	      // Unlike what is done for the `'upgrade'` event, no early exit is
	      // triggered here if the user calls `websocket.close()` or
	      // `websocket.terminate()` from a listener of the `'redirect'` event. This
	      // is because the user can also call `request.destroy()` with an error
	      // before calling `websocket.close()` or `websocket.terminate()` and this
	      // would result in an error being emitted on the `request` object with no
	      // `'error'` event listeners attached.
	      //
	      websocket.emit('redirect', websocket.url, req);
	    }
	  } else {
	    req = websocket._req = request(opts);
	  }

	  if (opts.timeout) {
	    req.on('timeout', () => {
	      abortHandshake(websocket, req, 'Opening handshake has timed out');
	    });
	  }

	  req.on('error', (err) => {
	    if (req === null || req[kAborted]) return;

	    req = websocket._req = null;
	    emitErrorAndClose(websocket, err);
	  });

	  req.on('response', (res) => {
	    const location = res.headers.location;
	    const statusCode = res.statusCode;

	    if (
	      location &&
	      opts.followRedirects &&
	      statusCode >= 300 &&
	      statusCode < 400
	    ) {
	      if (++websocket._redirects > opts.maxRedirects) {
	        abortHandshake(websocket, req, 'Maximum redirects exceeded');
	        return;
	      }

	      req.abort();

	      let addr;

	      try {
	        addr = new URL(location, address);
	      } catch (e) {
	        const err = new SyntaxError(`Invalid URL: ${location}`);
	        emitErrorAndClose(websocket, err);
	        return;
	      }

	      initAsClient(websocket, addr, protocols, options);
	    } else if (!websocket.emit('unexpected-response', req, res)) {
	      abortHandshake(
	        websocket,
	        req,
	        `Unexpected server response: ${res.statusCode}`
	      );
	    }
	  });

	  req.on('upgrade', (res, socket, head) => {
	    websocket.emit('upgrade', res);

	    //
	    // The user may have closed the connection from a listener of the
	    // `'upgrade'` event.
	    //
	    if (websocket.readyState !== WebSocket.CONNECTING) return;

	    req = websocket._req = null;

	    const upgrade = res.headers.upgrade;

	    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {
	      abortHandshake(websocket, socket, 'Invalid Upgrade header');
	      return;
	    }

	    const digest = createHash('sha1')
	      .update(key + GUID)
	      .digest('base64');

	    if (res.headers['sec-websocket-accept'] !== digest) {
	      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');
	      return;
	    }

	    const serverProt = res.headers['sec-websocket-protocol'];
	    let protError;

	    if (serverProt !== undefined) {
	      if (!protocolSet.size) {
	        protError = 'Server sent a subprotocol but none was requested';
	      } else if (!protocolSet.has(serverProt)) {
	        protError = 'Server sent an invalid subprotocol';
	      }
	    } else if (protocolSet.size) {
	      protError = 'Server sent no subprotocol';
	    }

	    if (protError) {
	      abortHandshake(websocket, socket, protError);
	      return;
	    }

	    if (serverProt) websocket._protocol = serverProt;

	    const secWebSocketExtensions = res.headers['sec-websocket-extensions'];

	    if (secWebSocketExtensions !== undefined) {
	      if (!perMessageDeflate) {
	        const message =
	          'Server sent a Sec-WebSocket-Extensions header but no extension ' +
	          'was requested';
	        abortHandshake(websocket, socket, message);
	        return;
	      }

	      let extensions;

	      try {
	        extensions = parse(secWebSocketExtensions);
	      } catch (err) {
	        const message = 'Invalid Sec-WebSocket-Extensions header';
	        abortHandshake(websocket, socket, message);
	        return;
	      }

	      const extensionNames = Object.keys(extensions);

	      if (
	        extensionNames.length !== 1 ||
	        extensionNames[0] !== PerMessageDeflate.extensionName
	      ) {
	        const message = 'Server indicated an extension that was not requested';
	        abortHandshake(websocket, socket, message);
	        return;
	      }

	      try {
	        perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
	      } catch (err) {
	        const message = 'Invalid Sec-WebSocket-Extensions header';
	        abortHandshake(websocket, socket, message);
	        return;
	      }

	      websocket._extensions[PerMessageDeflate.extensionName] =
	        perMessageDeflate;
	    }

	    websocket.setSocket(socket, head, {
	      allowSynchronousEvents: opts.allowSynchronousEvents,
	      generateMask: opts.generateMask,
	      maxPayload: opts.maxPayload,
	      skipUTF8Validation: opts.skipUTF8Validation
	    });
	  });

	  if (opts.finishRequest) {
	    opts.finishRequest(req, websocket);
	  } else {
	    req.end();
	  }
	}

	/**
	 * Emit the `'error'` and `'close'` events.
	 *
	 * @param {WebSocket} websocket The WebSocket instance
	 * @param {Error} The error to emit
	 * @private
	 */
	function emitErrorAndClose(websocket, err) {
	  websocket._readyState = WebSocket.CLOSING;
	  //
	  // The following assignment is practically useless and is done only for
	  // consistency.
	  //
	  websocket._errorEmitted = true;
	  websocket.emit('error', err);
	  websocket.emitClose();
	}

	/**
	 * Create a `net.Socket` and initiate a connection.
	 *
	 * @param {Object} options Connection options
	 * @return {net.Socket} The newly created socket used to start the connection
	 * @private
	 */
	function netConnect(options) {
	  options.path = options.socketPath;
	  return net.connect(options);
	}

	/**
	 * Create a `tls.TLSSocket` and initiate a connection.
	 *
	 * @param {Object} options Connection options
	 * @return {tls.TLSSocket} The newly created socket used to start the connection
	 * @private
	 */
	function tlsConnect(options) {
	  options.path = undefined;

	  if (!options.servername && options.servername !== '') {
	    options.servername = net.isIP(options.host) ? '' : options.host;
	  }

	  return tls.connect(options);
	}

	/**
	 * Abort the handshake and emit an error.
	 *
	 * @param {WebSocket} websocket The WebSocket instance
	 * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to
	 *     abort or the socket to destroy
	 * @param {String} message The error message
	 * @private
	 */
	function abortHandshake(websocket, stream, message) {
	  websocket._readyState = WebSocket.CLOSING;

	  const err = new Error(message);
	  Error.captureStackTrace(err, abortHandshake);

	  if (stream.setHeader) {
	    stream[kAborted] = true;
	    stream.abort();

	    if (stream.socket && !stream.socket.destroyed) {
	      //
	      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if
	      // called after the request completed. See
	      // https://github.com/websockets/ws/issues/1869.
	      //
	      stream.socket.destroy();
	    }

	    process.nextTick(emitErrorAndClose, websocket, err);
	  } else {
	    stream.destroy(err);
	    stream.once('error', websocket.emit.bind(websocket, 'error'));
	    stream.once('close', websocket.emitClose.bind(websocket));
	  }
	}

	/**
	 * Handle cases where the `ping()`, `pong()`, or `send()` methods are called
	 * when the `readyState` attribute is `CLOSING` or `CLOSED`.
	 *
	 * @param {WebSocket} websocket The WebSocket instance
	 * @param {*} [data] The data to send
	 * @param {Function} [cb] Callback
	 * @private
	 */
	function sendAfterClose(websocket, data, cb) {
	  if (data) {
	    const length = isBlob(data) ? data.size : toBuffer(data).length;

	    //
	    // The `_bufferedAmount` property is used only when the peer is a client and
	    // the opening handshake fails. Under these circumstances, in fact, the
	    // `setSocket()` method is not called, so the `_socket` and `_sender`
	    // properties are set to `null`.
	    //
	    if (websocket._socket) websocket._sender._bufferedBytes += length;
	    else websocket._bufferedAmount += length;
	  }

	  if (cb) {
	    const err = new Error(
	      `WebSocket is not open: readyState ${websocket.readyState} ` +
	        `(${readyStates[websocket.readyState]})`
	    );
	    process.nextTick(cb, err);
	  }
	}

	/**
	 * The listener of the `Receiver` `'conclude'` event.
	 *
	 * @param {Number} code The status code
	 * @param {Buffer} reason The reason for closing
	 * @private
	 */
	function receiverOnConclude(code, reason) {
	  const websocket = this[kWebSocket];

	  websocket._closeFrameReceived = true;
	  websocket._closeMessage = reason;
	  websocket._closeCode = code;

	  if (websocket._socket[kWebSocket] === undefined) return;

	  websocket._socket.removeListener('data', socketOnData);
	  process.nextTick(resume, websocket._socket);

	  if (code === 1005) websocket.close();
	  else websocket.close(code, reason);
	}

	/**
	 * The listener of the `Receiver` `'drain'` event.
	 *
	 * @private
	 */
	function receiverOnDrain() {
	  const websocket = this[kWebSocket];

	  if (!websocket.isPaused) websocket._socket.resume();
	}

	/**
	 * The listener of the `Receiver` `'error'` event.
	 *
	 * @param {(RangeError|Error)} err The emitted error
	 * @private
	 */
	function receiverOnError(err) {
	  const websocket = this[kWebSocket];

	  if (websocket._socket[kWebSocket] !== undefined) {
	    websocket._socket.removeListener('data', socketOnData);

	    //
	    // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See
	    // https://github.com/websockets/ws/issues/1940.
	    //
	    process.nextTick(resume, websocket._socket);

	    websocket.close(err[kStatusCode]);
	  }

	  if (!websocket._errorEmitted) {
	    websocket._errorEmitted = true;
	    websocket.emit('error', err);
	  }
	}

	/**
	 * The listener of the `Receiver` `'finish'` event.
	 *
	 * @private
	 */
	function receiverOnFinish() {
	  this[kWebSocket].emitClose();
	}

	/**
	 * The listener of the `Receiver` `'message'` event.
	 *
	 * @param {Buffer|ArrayBuffer|Buffer[])} data The message
	 * @param {Boolean} isBinary Specifies whether the message is binary or not
	 * @private
	 */
	function receiverOnMessage(data, isBinary) {
	  this[kWebSocket].emit('message', data, isBinary);
	}

	/**
	 * The listener of the `Receiver` `'ping'` event.
	 *
	 * @param {Buffer} data The data included in the ping frame
	 * @private
	 */
	function receiverOnPing(data) {
	  const websocket = this[kWebSocket];

	  if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);
	  websocket.emit('ping', data);
	}

	/**
	 * The listener of the `Receiver` `'pong'` event.
	 *
	 * @param {Buffer} data The data included in the pong frame
	 * @private
	 */
	function receiverOnPong(data) {
	  this[kWebSocket].emit('pong', data);
	}

	/**
	 * Resume a readable stream
	 *
	 * @param {Readable} stream The readable stream
	 * @private
	 */
	function resume(stream) {
	  stream.resume();
	}

	/**
	 * The `Sender` error event handler.
	 *
	 * @param {Error} The error
	 * @private
	 */
	function senderOnError(err) {
	  const websocket = this[kWebSocket];

	  if (websocket.readyState === WebSocket.CLOSED) return;
	  if (websocket.readyState === WebSocket.OPEN) {
	    websocket._readyState = WebSocket.CLOSING;
	    setCloseTimer(websocket);
	  }

	  //
	  // `socket.end()` is used instead of `socket.destroy()` to allow the other
	  // peer to finish sending queued data. There is no need to set a timer here
	  // because `CLOSING` means that it is already set or not needed.
	  //
	  this._socket.end();

	  if (!websocket._errorEmitted) {
	    websocket._errorEmitted = true;
	    websocket.emit('error', err);
	  }
	}

	/**
	 * Set a timer to destroy the underlying raw socket of a WebSocket.
	 *
	 * @param {WebSocket} websocket The WebSocket instance
	 * @private
	 */
	function setCloseTimer(websocket) {
	  websocket._closeTimer = setTimeout(
	    websocket._socket.destroy.bind(websocket._socket),
	    closeTimeout
	  );
	}

	/**
	 * The listener of the socket `'close'` event.
	 *
	 * @private
	 */
	function socketOnClose() {
	  const websocket = this[kWebSocket];

	  this.removeListener('close', socketOnClose);
	  this.removeListener('data', socketOnData);
	  this.removeListener('end', socketOnEnd);

	  websocket._readyState = WebSocket.CLOSING;

	  let chunk;

	  //
	  // The close frame might not have been received or the `'end'` event emitted,
	  // for example, if the socket was destroyed due to an error. Ensure that the
	  // `receiver` stream is closed after writing any remaining buffered data to
	  // it. If the readable side of the socket is in flowing mode then there is no
	  // buffered data as everything has been already written and `readable.read()`
	  // will return `null`. If instead, the socket is paused, any possible buffered
	  // data will be read as a single chunk.
	  //
	  if (
	    !this._readableState.endEmitted &&
	    !websocket._closeFrameReceived &&
	    !websocket._receiver._writableState.errorEmitted &&
	    (chunk = websocket._socket.read()) !== null
	  ) {
	    websocket._receiver.write(chunk);
	  }

	  websocket._receiver.end();

	  this[kWebSocket] = undefined;

	  clearTimeout(websocket._closeTimer);

	  if (
	    websocket._receiver._writableState.finished ||
	    websocket._receiver._writableState.errorEmitted
	  ) {
	    websocket.emitClose();
	  } else {
	    websocket._receiver.on('error', receiverOnFinish);
	    websocket._receiver.on('finish', receiverOnFinish);
	  }
	}

	/**
	 * The listener of the socket `'data'` event.
	 *
	 * @param {Buffer} chunk A chunk of data
	 * @private
	 */
	function socketOnData(chunk) {
	  if (!this[kWebSocket]._receiver.write(chunk)) {
	    this.pause();
	  }
	}

	/**
	 * The listener of the socket `'end'` event.
	 *
	 * @private
	 */
	function socketOnEnd() {
	  const websocket = this[kWebSocket];

	  websocket._readyState = WebSocket.CLOSING;
	  websocket._receiver.end();
	  this.end();
	}

	/**
	 * The listener of the socket `'error'` event.
	 *
	 * @private
	 */
	function socketOnError() {
	  const websocket = this[kWebSocket];

	  this.removeListener('error', socketOnError);
	  this.on('error', NOOP);

	  if (websocket) {
	    websocket._readyState = WebSocket.CLOSING;
	    this.destroy();
	  }
	}
	return websocket;
}

/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^WebSocket$" }] */

var stream;
var hasRequiredStream;

function requireStream () {
	if (hasRequiredStream) return stream;
	hasRequiredStream = 1;

	requireWebsocket();
	const { Duplex } = require$$0$6;

	/**
	 * Emits the `'close'` event on a stream.
	 *
	 * @param {Duplex} stream The stream.
	 * @private
	 */
	function emitClose(stream) {
	  stream.emit('close');
	}

	/**
	 * The listener of the `'end'` event.
	 *
	 * @private
	 */
	function duplexOnEnd() {
	  if (!this.destroyed && this._writableState.finished) {
	    this.destroy();
	  }
	}

	/**
	 * The listener of the `'error'` event.
	 *
	 * @param {Error} err The error
	 * @private
	 */
	function duplexOnError(err) {
	  this.removeListener('error', duplexOnError);
	  this.destroy();
	  if (this.listenerCount('error') === 0) {
	    // Do not suppress the throwing behavior.
	    this.emit('error', err);
	  }
	}

	/**
	 * Wraps a `WebSocket` in a duplex stream.
	 *
	 * @param {WebSocket} ws The `WebSocket` to wrap
	 * @param {Object} [options] The options for the `Duplex` constructor
	 * @return {Duplex} The duplex stream
	 * @public
	 */
	function createWebSocketStream(ws, options) {
	  let terminateOnDestroy = true;

	  const duplex = new Duplex({
	    ...options,
	    autoDestroy: false,
	    emitClose: false,
	    objectMode: false,
	    writableObjectMode: false
	  });

	  ws.on('message', function message(msg, isBinary) {
	    const data =
	      !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;

	    if (!duplex.push(data)) ws.pause();
	  });

	  ws.once('error', function error(err) {
	    if (duplex.destroyed) return;

	    // Prevent `ws.terminate()` from being called by `duplex._destroy()`.
	    //
	    // - If the `'error'` event is emitted before the `'open'` event, then
	    //   `ws.terminate()` is a noop as no socket is assigned.
	    // - Otherwise, the error is re-emitted by the listener of the `'error'`
	    //   event of the `Receiver` object. The listener already closes the
	    //   connection by calling `ws.close()`. This allows a close frame to be
	    //   sent to the other peer. If `ws.terminate()` is called right after this,
	    //   then the close frame might not be sent.
	    terminateOnDestroy = false;
	    duplex.destroy(err);
	  });

	  ws.once('close', function close() {
	    if (duplex.destroyed) return;

	    duplex.push(null);
	  });

	  duplex._destroy = function (err, callback) {
	    if (ws.readyState === ws.CLOSED) {
	      callback(err);
	      process.nextTick(emitClose, duplex);
	      return;
	    }

	    let called = false;

	    ws.once('error', function error(err) {
	      called = true;
	      callback(err);
	    });

	    ws.once('close', function close() {
	      if (!called) callback(err);
	      process.nextTick(emitClose, duplex);
	    });

	    if (terminateOnDestroy) ws.terminate();
	  };

	  duplex._final = function (callback) {
	    if (ws.readyState === ws.CONNECTING) {
	      ws.once('open', function open() {
	        duplex._final(callback);
	      });
	      return;
	    }

	    // If the value of the `_socket` property is `null` it means that `ws` is a
	    // client websocket and the handshake failed. In fact, when this happens, a
	    // socket is never assigned to the websocket. Wait for the `'error'` event
	    // that will be emitted by the websocket.
	    if (ws._socket === null) return;

	    if (ws._socket._writableState.finished) {
	      callback();
	      if (duplex._readableState.endEmitted) duplex.destroy();
	    } else {
	      ws._socket.once('finish', function finish() {
	        // `duplex` is not destroyed here because the `'end'` event will be
	        // emitted on `duplex` after this `'finish'` event. The EOF signaling
	        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.
	        callback();
	      });
	      ws.close();
	    }
	  };

	  duplex._read = function () {
	    if (ws.isPaused) ws.resume();
	  };

	  duplex._write = function (chunk, encoding, callback) {
	    if (ws.readyState === ws.CONNECTING) {
	      ws.once('open', function open() {
	        duplex._write(chunk, encoding, callback);
	      });
	      return;
	    }

	    ws.send(chunk, callback);
	  };

	  duplex.on('end', duplexOnEnd);
	  duplex.on('error', duplexOnError);
	  return duplex;
	}

	stream = createWebSocketStream;
	return stream;
}

requireStream();

requireReceiver();

requireSender();

requireWebsocket();

var subprotocol;
var hasRequiredSubprotocol;

function requireSubprotocol () {
	if (hasRequiredSubprotocol) return subprotocol;
	hasRequiredSubprotocol = 1;

	const { tokenChars } = requireValidation();

	/**
	 * Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.
	 *
	 * @param {String} header The field value of the header
	 * @return {Set} The subprotocol names
	 * @public
	 */
	function parse(header) {
	  const protocols = new Set();
	  let start = -1;
	  let end = -1;
	  let i = 0;

	  for (i; i < header.length; i++) {
	    const code = header.charCodeAt(i);

	    if (end === -1 && tokenChars[code] === 1) {
	      if (start === -1) start = i;
	    } else if (
	      i !== 0 &&
	      (code === 0x20 /* ' ' */ || code === 0x09) /* '\t' */
	    ) {
	      if (end === -1 && start !== -1) end = i;
	    } else if (code === 0x2c /* ',' */) {
	      if (start === -1) {
	        throw new SyntaxError(`Unexpected character at index ${i}`);
	      }

	      if (end === -1) end = i;

	      const protocol = header.slice(start, end);

	      if (protocols.has(protocol)) {
	        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
	      }

	      protocols.add(protocol);
	      start = end = -1;
	    } else {
	      throw new SyntaxError(`Unexpected character at index ${i}`);
	    }
	  }

	  if (start === -1 || end !== -1) {
	    throw new SyntaxError('Unexpected end of input');
	  }

	  const protocol = header.slice(start, i);

	  if (protocols.has(protocol)) {
	    throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
	  }

	  protocols.add(protocol);
	  return protocols;
	}

	subprotocol = { parse };
	return subprotocol;
}

/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex$", "caughtErrors": "none" }] */

var websocketServer;
var hasRequiredWebsocketServer;

function requireWebsocketServer () {
	if (hasRequiredWebsocketServer) return websocketServer;
	hasRequiredWebsocketServer = 1;

	const EventEmitter = require$$0$3;
	const http = require$$2;
	const { Duplex } = require$$0$6;
	const { createHash } = require$$3;

	const extension = requireExtension();
	const PerMessageDeflate = requirePermessageDeflate();
	const subprotocol = requireSubprotocol();
	const WebSocket = requireWebsocket();
	const { GUID, kWebSocket } = requireConstants();

	const keyRegex = /^[+/0-9A-Za-z]{22}==$/;

	const RUNNING = 0;
	const CLOSING = 1;
	const CLOSED = 2;

	/**
	 * Class representing a WebSocket server.
	 *
	 * @extends EventEmitter
	 */
	class WebSocketServer extends EventEmitter {
	  /**
	   * Create a `WebSocketServer` instance.
	   *
	   * @param {Object} options Configuration options
	   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
	   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
	   *     multiple times in the same tick
	   * @param {Boolean} [options.autoPong=true] Specifies whether or not to
	   *     automatically send a pong in response to a ping
	   * @param {Number} [options.backlog=511] The maximum length of the queue of
	   *     pending connections
	   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
	   *     track clients
	   * @param {Function} [options.handleProtocols] A hook to handle protocols
	   * @param {String} [options.host] The hostname where to bind the server
	   * @param {Number} [options.maxPayload=104857600] The maximum allowed message
	   *     size
	   * @param {Boolean} [options.noServer=false] Enable no server mode
	   * @param {String} [options.path] Accept only connections matching this path
	   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
	   *     permessage-deflate
	   * @param {Number} [options.port] The port where to bind the server
	   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
	   *     server to use
	   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
	   *     not to skip UTF-8 validation for text and close messages
	   * @param {Function} [options.verifyClient] A hook to reject connections
	   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
	   *     class to use. It must be the `WebSocket` class or class that extends it
	   * @param {Function} [callback] A listener for the `listening` event
	   */
	  constructor(options, callback) {
	    super();

	    options = {
	      allowSynchronousEvents: true,
	      autoPong: true,
	      maxPayload: 100 * 1024 * 1024,
	      skipUTF8Validation: false,
	      perMessageDeflate: false,
	      handleProtocols: null,
	      clientTracking: true,
	      verifyClient: null,
	      noServer: false,
	      backlog: null, // use default (511 as implemented in net.js)
	      server: null,
	      host: null,
	      path: null,
	      port: null,
	      WebSocket,
	      ...options
	    };

	    if (
	      (options.port == null && !options.server && !options.noServer) ||
	      (options.port != null && (options.server || options.noServer)) ||
	      (options.server && options.noServer)
	    ) {
	      throw new TypeError(
	        'One and only one of the "port", "server", or "noServer" options ' +
	          'must be specified'
	      );
	    }

	    if (options.port != null) {
	      this._server = http.createServer((req, res) => {
	        const body = http.STATUS_CODES[426];

	        res.writeHead(426, {
	          'Content-Length': body.length,
	          'Content-Type': 'text/plain'
	        });
	        res.end(body);
	      });
	      this._server.listen(
	        options.port,
	        options.host,
	        options.backlog,
	        callback
	      );
	    } else if (options.server) {
	      this._server = options.server;
	    }

	    if (this._server) {
	      const emitConnection = this.emit.bind(this, 'connection');

	      this._removeListeners = addListeners(this._server, {
	        listening: this.emit.bind(this, 'listening'),
	        error: this.emit.bind(this, 'error'),
	        upgrade: (req, socket, head) => {
	          this.handleUpgrade(req, socket, head, emitConnection);
	        }
	      });
	    }

	    if (options.perMessageDeflate === true) options.perMessageDeflate = {};
	    if (options.clientTracking) {
	      this.clients = new Set();
	      this._shouldEmitClose = false;
	    }

	    this.options = options;
	    this._state = RUNNING;
	  }

	  /**
	   * Returns the bound address, the address family name, and port of the server
	   * as reported by the operating system if listening on an IP socket.
	   * If the server is listening on a pipe or UNIX domain socket, the name is
	   * returned as a string.
	   *
	   * @return {(Object|String|null)} The address of the server
	   * @public
	   */
	  address() {
	    if (this.options.noServer) {
	      throw new Error('The server is operating in "noServer" mode');
	    }

	    if (!this._server) return null;
	    return this._server.address();
	  }

	  /**
	   * Stop the server from accepting new connections and emit the `'close'` event
	   * when all existing connections are closed.
	   *
	   * @param {Function} [cb] A one-time listener for the `'close'` event
	   * @public
	   */
	  close(cb) {
	    if (this._state === CLOSED) {
	      if (cb) {
	        this.once('close', () => {
	          cb(new Error('The server is not running'));
	        });
	      }

	      process.nextTick(emitClose, this);
	      return;
	    }

	    if (cb) this.once('close', cb);

	    if (this._state === CLOSING) return;
	    this._state = CLOSING;

	    if (this.options.noServer || this.options.server) {
	      if (this._server) {
	        this._removeListeners();
	        this._removeListeners = this._server = null;
	      }

	      if (this.clients) {
	        if (!this.clients.size) {
	          process.nextTick(emitClose, this);
	        } else {
	          this._shouldEmitClose = true;
	        }
	      } else {
	        process.nextTick(emitClose, this);
	      }
	    } else {
	      const server = this._server;

	      this._removeListeners();
	      this._removeListeners = this._server = null;

	      //
	      // The HTTP/S server was created internally. Close it, and rely on its
	      // `'close'` event.
	      //
	      server.close(() => {
	        emitClose(this);
	      });
	    }
	  }

	  /**
	   * See if a given request should be handled by this server instance.
	   *
	   * @param {http.IncomingMessage} req Request object to inspect
	   * @return {Boolean} `true` if the request is valid, else `false`
	   * @public
	   */
	  shouldHandle(req) {
	    if (this.options.path) {
	      const index = req.url.indexOf('?');
	      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;

	      if (pathname !== this.options.path) return false;
	    }

	    return true;
	  }

	  /**
	   * Handle a HTTP Upgrade request.
	   *
	   * @param {http.IncomingMessage} req The request object
	   * @param {Duplex} socket The network socket between the server and client
	   * @param {Buffer} head The first packet of the upgraded stream
	   * @param {Function} cb Callback
	   * @public
	   */
	  handleUpgrade(req, socket, head, cb) {
	    socket.on('error', socketOnError);

	    const key = req.headers['sec-websocket-key'];
	    const upgrade = req.headers.upgrade;
	    const version = +req.headers['sec-websocket-version'];

	    if (req.method !== 'GET') {
	      const message = 'Invalid HTTP method';
	      abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
	      return;
	    }

	    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {
	      const message = 'Invalid Upgrade header';
	      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
	      return;
	    }

	    if (key === undefined || !keyRegex.test(key)) {
	      const message = 'Missing or invalid Sec-WebSocket-Key header';
	      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
	      return;
	    }

	    if (version !== 8 && version !== 13) {
	      const message = 'Missing or invalid Sec-WebSocket-Version header';
	      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
	      return;
	    }

	    if (!this.shouldHandle(req)) {
	      abortHandshake(socket, 400);
	      return;
	    }

	    const secWebSocketProtocol = req.headers['sec-websocket-protocol'];
	    let protocols = new Set();

	    if (secWebSocketProtocol !== undefined) {
	      try {
	        protocols = subprotocol.parse(secWebSocketProtocol);
	      } catch (err) {
	        const message = 'Invalid Sec-WebSocket-Protocol header';
	        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
	        return;
	      }
	    }

	    const secWebSocketExtensions = req.headers['sec-websocket-extensions'];
	    const extensions = {};

	    if (
	      this.options.perMessageDeflate &&
	      secWebSocketExtensions !== undefined
	    ) {
	      const perMessageDeflate = new PerMessageDeflate(
	        this.options.perMessageDeflate,
	        true,
	        this.options.maxPayload
	      );

	      try {
	        const offers = extension.parse(secWebSocketExtensions);

	        if (offers[PerMessageDeflate.extensionName]) {
	          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
	          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
	        }
	      } catch (err) {
	        const message =
	          'Invalid or unacceptable Sec-WebSocket-Extensions header';
	        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
	        return;
	      }
	    }

	    //
	    // Optionally call external client verification handler.
	    //
	    if (this.options.verifyClient) {
	      const info = {
	        origin:
	          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],
	        secure: !!(req.socket.authorized || req.socket.encrypted),
	        req
	      };

	      if (this.options.verifyClient.length === 2) {
	        this.options.verifyClient(info, (verified, code, message, headers) => {
	          if (!verified) {
	            return abortHandshake(socket, code || 401, message, headers);
	          }

	          this.completeUpgrade(
	            extensions,
	            key,
	            protocols,
	            req,
	            socket,
	            head,
	            cb
	          );
	        });
	        return;
	      }

	      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
	    }

	    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
	  }

	  /**
	   * Upgrade the connection to WebSocket.
	   *
	   * @param {Object} extensions The accepted extensions
	   * @param {String} key The value of the `Sec-WebSocket-Key` header
	   * @param {Set} protocols The subprotocols
	   * @param {http.IncomingMessage} req The request object
	   * @param {Duplex} socket The network socket between the server and client
	   * @param {Buffer} head The first packet of the upgraded stream
	   * @param {Function} cb Callback
	   * @throws {Error} If called more than once with the same socket
	   * @private
	   */
	  completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
	    //
	    // Destroy the socket if the client has already sent a FIN packet.
	    //
	    if (!socket.readable || !socket.writable) return socket.destroy();

	    if (socket[kWebSocket]) {
	      throw new Error(
	        'server.handleUpgrade() was called more than once with the same ' +
	          'socket, possibly due to a misconfiguration'
	      );
	    }

	    if (this._state > RUNNING) return abortHandshake(socket, 503);

	    const digest = createHash('sha1')
	      .update(key + GUID)
	      .digest('base64');

	    const headers = [
	      'HTTP/1.1 101 Switching Protocols',
	      'Upgrade: websocket',
	      'Connection: Upgrade',
	      `Sec-WebSocket-Accept: ${digest}`
	    ];

	    const ws = new this.options.WebSocket(null, undefined, this.options);

	    if (protocols.size) {
	      //
	      // Optionally call external protocol selection handler.
	      //
	      const protocol = this.options.handleProtocols
	        ? this.options.handleProtocols(protocols, req)
	        : protocols.values().next().value;

	      if (protocol) {
	        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
	        ws._protocol = protocol;
	      }
	    }

	    if (extensions[PerMessageDeflate.extensionName]) {
	      const params = extensions[PerMessageDeflate.extensionName].params;
	      const value = extension.format({
	        [PerMessageDeflate.extensionName]: [params]
	      });
	      headers.push(`Sec-WebSocket-Extensions: ${value}`);
	      ws._extensions = extensions;
	    }

	    //
	    // Allow external modification/inspection of handshake headers.
	    //
	    this.emit('headers', headers, req);

	    socket.write(headers.concat('\r\n').join('\r\n'));
	    socket.removeListener('error', socketOnError);

	    ws.setSocket(socket, head, {
	      allowSynchronousEvents: this.options.allowSynchronousEvents,
	      maxPayload: this.options.maxPayload,
	      skipUTF8Validation: this.options.skipUTF8Validation
	    });

	    if (this.clients) {
	      this.clients.add(ws);
	      ws.on('close', () => {
	        this.clients.delete(ws);

	        if (this._shouldEmitClose && !this.clients.size) {
	          process.nextTick(emitClose, this);
	        }
	      });
	    }

	    cb(ws, req);
	  }
	}

	websocketServer = WebSocketServer;

	/**
	 * Add event listeners on an `EventEmitter` using a map of <event, listener>
	 * pairs.
	 *
	 * @param {EventEmitter} server The event emitter
	 * @param {Object.<String, Function>} map The listeners to add
	 * @return {Function} A function that will remove the added listeners when
	 *     called
	 * @private
	 */
	function addListeners(server, map) {
	  for (const event of Object.keys(map)) server.on(event, map[event]);

	  return function removeListeners() {
	    for (const event of Object.keys(map)) {
	      server.removeListener(event, map[event]);
	    }
	  };
	}

	/**
	 * Emit a `'close'` event on an `EventEmitter`.
	 *
	 * @param {EventEmitter} server The event emitter
	 * @private
	 */
	function emitClose(server) {
	  server._state = CLOSED;
	  server.emit('close');
	}

	/**
	 * Handle socket errors.
	 *
	 * @private
	 */
	function socketOnError() {
	  this.destroy();
	}

	/**
	 * Close the connection when preconditions are not fulfilled.
	 *
	 * @param {Duplex} socket The socket of the upgrade request
	 * @param {Number} code The HTTP response status code
	 * @param {String} [message] The HTTP response body
	 * @param {Object} [headers] Additional HTTP response headers
	 * @private
	 */
	function abortHandshake(socket, code, message, headers) {
	  //
	  // The socket is writable unless the user destroyed or ended it before calling
	  // `server.handleUpgrade()` or in the `verifyClient` function, which is a user
	  // error. Handling this does not make much sense as the worst that can happen
	  // is that some of the data written by the user might be discarded due to the
	  // call to `socket.end()` below, which triggers an `'error'` event that in
	  // turn causes the socket to be destroyed.
	  //
	  message = message || http.STATUS_CODES[code];
	  headers = {
	    Connection: 'close',
	    'Content-Type': 'text/html',
	    'Content-Length': Buffer.byteLength(message),
	    ...headers
	  };

	  socket.once('finish', socket.destroy);

	  socket.end(
	    `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r\n` +
	      Object.keys(headers)
	        .map((h) => `${h}: ${headers[h]}`)
	        .join('\r\n') +
	      '\r\n\r\n' +
	      message
	  );
	}

	/**
	 * Emit a `'wsClientError'` event on a `WebSocketServer` if there is at least
	 * one listener for it, otherwise call `abortHandshake()`.
	 *
	 * @param {WebSocketServer} server The WebSocket server
	 * @param {http.IncomingMessage} req The request object
	 * @param {Duplex} socket The socket of the upgrade request
	 * @param {Number} code The HTTP response status code
	 * @param {String} message The HTTP response body
	 * @private
	 */
	function abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {
	  if (server.listenerCount('wsClientError')) {
	    const err = new Error(message);
	    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);

	    server.emit('wsClientError', err, socket, req);
	  } else {
	    abortHandshake(socket, code, message);
	  }
	}
	return websocketServer;
}

requireWebsocketServer();

const CreateDatabaseMigrationsTableQuery = `CREATE TABLE IF NOT EXISTS _hub_migrations (
    id         INTEGER PRIMARY KEY AUTOINCREMENT,
    name       TEXT UNIQUE,
    applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);`;
const ListDatabaseMigrationsQuery = 'select "id", "name", "applied_at" from "_hub_migrations" order by "_hub_migrations"."id"';

const BYTE_UNITS = [
	'B',
	'kB',
	'MB',
	'GB',
	'TB',
	'PB',
	'EB',
	'ZB',
	'YB',
];

const BIBYTE_UNITS = [
	'B',
	'KiB',
	'MiB',
	'GiB',
	'TiB',
	'PiB',
	'EiB',
	'ZiB',
	'YiB',
];

const BIT_UNITS = [
	'b',
	'kbit',
	'Mbit',
	'Gbit',
	'Tbit',
	'Pbit',
	'Ebit',
	'Zbit',
	'Ybit',
];

const BIBIT_UNITS = [
	'b',
	'kibit',
	'Mibit',
	'Gibit',
	'Tibit',
	'Pibit',
	'Eibit',
	'Zibit',
	'Yibit',
];

/*
Formats the given number using `Number#toLocaleString`.
- If locale is a string, the value is expected to be a locale-key (for example: `de`).
- If locale is true, the system default locale is used for translation.
- If no value for locale is specified, the number is returned unmodified.
*/
const toLocaleString = (number, locale, options) => {
	let result = number;
	if (typeof locale === 'string' || Array.isArray(locale)) {
		result = number.toLocaleString(locale, options);
	} else if (locale === true || options !== undefined) {
		result = number.toLocaleString(undefined, options);
	}

	return result;
};

function prettyBytes(number, options) {
	if (!Number.isFinite(number)) {
		throw new TypeError(`Expected a finite number, got ${typeof number}: ${number}`);
	}

	options = {
		bits: false,
		binary: false,
		space: true,
		...options,
	};

	const UNITS = options.bits
		? (options.binary ? BIBIT_UNITS : BIT_UNITS)
		: (options.binary ? BIBYTE_UNITS : BYTE_UNITS);

	const separator = options.space ? ' ' : '';

	if (options.signed && number === 0) {
		return ` 0${separator}${UNITS[0]}`;
	}

	const isNegative = number < 0;
	const prefix = isNegative ? '-' : (options.signed ? '+' : '');

	if (isNegative) {
		number = -number;
	}

	let localeOptions;

	if (options.minimumFractionDigits !== undefined) {
		localeOptions = {minimumFractionDigits: options.minimumFractionDigits};
	}

	if (options.maximumFractionDigits !== undefined) {
		localeOptions = {maximumFractionDigits: options.maximumFractionDigits, ...localeOptions};
	}

	if (number < 1) {
		const numberString = toLocaleString(number, options.locale, localeOptions);
		return prefix + numberString + separator + UNITS[0];
	}

	const exponent = Math.min(Math.floor(options.binary ? Math.log(number) / Math.log(1024) : Math.log10(number) / 3), UNITS.length - 1);
	number /= (options.binary ? 1024 : 1000) ** exponent;

	if (!localeOptions) {
		number = number.toPrecision(3);
	}

	const numberString = toLocaleString(Number(number), options.locale, localeOptions);

	const unit = UNITS[exponent];

	return prefix + numberString + separator + unit;
}

const getOptions = options => ({level: 9, ...options});
const gzip = promisify(Ye.gzip);

async function gzipSize(input, options) {
	if (!input) {
		return 0;
	}

	const data = await gzip(input, getOptions(options));
	return data.length;
}

function hashFile(filePath, data) {
  const extension = extname(filePath).substring(1);
  return createHash('sha256')
    .update(data + extension)
    .digest('hex')
    .slice(0, 32) // required by Cloudflare
}

/**
 * Create chunks based on base64 size
 */
async function createChunks(files) {
  const chunks = [];
  let currentChunk = [];
  let currentSize = 0;

  for (const file of files) {
    // If single file is bigger than chunk size, it gets its own chunk
    if (file.size > MAX_UPLOAD_CHUNK_SIZE) {
      // If we have accumulated files, push them as a chunk first
      if (currentChunk.length > 0) {
        chunks.push(currentChunk);
        currentChunk = [];
        currentSize = 0;
      }
      // Push large file as its own chunk
      chunks.push([file]);
      continue
    }

    if (currentSize + file.size > MAX_UPLOAD_CHUNK_SIZE && currentChunk.length > 0) {
      chunks.push(currentChunk);
      currentChunk = [];
      currentSize = 0;
    }

    currentChunk.push(file);
    currentSize += file.size;
  }

  if (currentChunk.length > 0) {
    chunks.push(currentChunk);
  }

  return chunks
}

/**
 * Create a storage instance for the dist directory
 * @param {string} dir - Nuxt build output directory
 * @returns {Promise<import('unstorage').Storage>}
 * @throws {Error} If dist directory doesn't exist
 */
async function getStorage(dir) {
  await access(dir).catch(() => {
    throw new Error(`${withTilde(dir)} directory not found`)
  });
  return createStorage({
    driver: fsDriver({
      base: dir,
      ignore: ['.DS_Store']
    })
  })
}

/**
 * Get all files to deploy
 * @param {string[]} fileKeys - Array of file paths from storage
 * @returns {string[]} Array of paths to deploy
 */
function getPathsToDeploy(fileKeys) {
  const fileKeyToPath = (fileKey) => joinURL('/', fileKey.replace(/:/g, '/'));
  return fileKeys.map(fileKeyToPath).filter(path => {
    if (path.startsWith('/.wrangler/')) return false
    if (path.startsWith('/node_modules/')) return false
    if (path === '/wrangler.toml') return false
    if (path === '/.dev.vars') return false
    if (path.startsWith('/database/migrations/')) return false
    return true
  })
}

/**
 * Get file data with metadata
 * @param {import('unstorage').Storage} storage - Storage instance
 * @param {string} path - File path
 * @param {BufferEncoding} [encoding='utf-8'] - File encoding
 * @returns {Promise<{ path: string, data: string, size: number, encoding: string, hash: string, contentType: string }>}
 * @throws {Error} If file size exceeds MAX_ASSET_SIZE
 */
async function getFile(storage, path, encoding = 'utf-8') {
  const dataAsBuffer = await storage.getItemRaw(path);
  if (dataAsBuffer.length > MAX_ASSET_SIZE) {
    throw new Error(`NuxtHub deploy only supports files up to ${prettyBytes(MAX_ASSET_SIZE, { binary: true })} in size\n${withTilde(path)} is ${prettyBytes(dataAsBuffer.length, { binary: true })} in size`)
  }
  const gzipSize$1 = await gzipSize(dataAsBuffer);
  const data = dataAsBuffer.toString(encoding);

  return {
    path,
    data,
    size: dataAsBuffer.length,
    gzipSize: gzipSize$1,
    encoding,
    hash: hashFile(path, data),
    contentType: mime.getType(path) || 'application/octet-stream'
  }
}

const META_PATHS = [
  '/_redirects',
  '/_headers',
  '/_routes.json',
  '/nitro.json',
  '/hub.config.json',
  '/wrangler.toml',
  '/package-lock.json',
  '/package.json'
];

const isMetaPath = (path) => META_PATHS.includes(path);
const isServerPath = (path) => path.startsWith('/_worker.js/');
const isPublicPath = (path) => !isMetaPath(path) && !isServerPath(path);

const isWorkerMetaPath = (path) => META_PATHS.includes(path);
const isWorkerPublicPath = (path) => path.startsWith('/public/');
const isWorkerServerPath = (path) => path.startsWith('/server/');

/**
 * Get all public files with their metadata
 * @param {import('unstorage').Storage} storage - Storage instance
 * @param {string[]} paths - Array of paths to filter and process
 * @returns {Promise<Array<{ path: string, data: string, size: number, encoding: string, hash: string, contentType: string }>>}
 */
async function getPublicFiles(storage, paths) {
  return Promise.all(
    paths.filter(isPublicPath).map(p => getFile(storage, p, 'base64'))
  )
}
async function getWorkerPublicFiles(storage, paths) {
  const files = await Promise.all(
    paths.filter(isWorkerPublicPath).map(p => getFile(storage, p, 'base64'))
  );
  return files.map((file) => ({
    ...file,
    path: file.path.replace('/public/', '/')
  }))
}

/**
 * Upload assets to Cloudflare Pages with concurrent uploads
 * @param {Array<{ path: string, data: string, hash: string, contentType: string }>} files - Files to upload
 * @param {string} cloudflareUploadJwt - Cloudflare upload JWT
 * @param {Function} onProgress - Callback function to update progress
 */
async function uploadAssetsToCloudflare(files, cloudflareUploadJwt, onProgress) {
  const chunks = await createChunks(files);
  if (!chunks.length) {
    return
  }

  let filesUploaded = 0;
  let progressSize = 0;
  const totalSize = files.reduce((acc, file) => acc + file.size, 0);
  for (let i = 0; i < chunks.length; i += CONCURRENT_UPLOADS) {
    const chunkGroup = chunks.slice(i, i + CONCURRENT_UPLOADS);

    await Promise.all(chunkGroup.map(async (filesInChunk) => {
      return ofetch('/pages/assets/upload', {
        baseURL: 'https://api.cloudflare.com/client/v4/',
        method: 'POST',
        headers: {
          Authorization: `Bearer ${cloudflareUploadJwt}`
        },
        retry: MAX_UPLOAD_ATTEMPTS,
        retryDelay: UPLOAD_RETRY_DELAY,
        body: filesInChunk.map(file => ({
          path: file.path,
          key: file.hash,
          value: file.data,
          base64: true,
          metadata: {
            contentType: file.contentType
          }
        }))
      })
      .then(() => {
        if (typeof onProgress === 'function') {
          filesUploaded += filesInChunk.length;
          progressSize += filesInChunk.reduce((acc, file) => acc + file.size, 0);
          onProgress({ progress: filesUploaded, progressSize, total: files.length, totalSize });
        }
      })
      .catch((err) => {
        if (err.data) {
          throw new Error(`Error while uploading assets to Cloudflare: ${JSON.stringify(err.data)} - ${err.message}`)
        }
        else {
          throw new Error(`Error while uploading assets to Cloudflare: ${err.message.split(' - ')[1] || err.message}`)
        }
      })
    }));
  }
}


/**
 * Upload assets to Cloudflare Workers with concurrent uploads
 * @param {Array<string<string>} buckets - Buckets of hashes to upload
 * @param {Array<{ path: string, data: string, hash: string, contentType: string }>} files - Files to upload
 * @param {string} cloudflareUploadJwt - Cloudflare upload JWT
 * @param {Function} onProgress - Callback function to update progress
 */
async function uploadWorkersAssetsToCloudflare(accountId, files, cloudflareUploadJwt, onProgress) {
  const chunks = await createChunks(files);
  if (!chunks.length) {
    return
  }

  let filesUploaded = 0;
  let progressSize = 0;
  let completionToken;
  const totalSize = files.reduce((acc, file) => acc + file.size, 0);
  for (let i = 0; i < chunks.length; i += CONCURRENT_UPLOADS) {
    const chunkGroup = chunks.slice(i, i + CONCURRENT_UPLOADS);

    await Promise.all(chunkGroup.map(async (filesInChunk) => {
      const form = new FormData();
      for (const file of filesInChunk) {
        form.append(file.hash, new File([file.data], file.hash, { type: file.contentType}), file.hash);
      }
      return ofetch(`/accounts/${accountId}/workers/assets/upload?base64=true`, {
        baseURL: 'https://api.cloudflare.com/client/v4/',
        method: 'POST',
        headers: {
          Authorization: `Bearer ${cloudflareUploadJwt}`
        },
        retry: MAX_UPLOAD_ATTEMPTS,
        retryDelay: UPLOAD_RETRY_DELAY,
        body: form
      })
      .then((data) => {
        if (data && data.result?.jwt) {
          completionToken = data.result.jwt;
        }
        if (typeof onProgress === 'function') {
          filesUploaded += filesInChunk.length;
          progressSize += filesInChunk.reduce((acc, file) => acc + file.size, 0);
          onProgress({ progress: filesUploaded, progressSize, total: files.length, totalSize });
        }
      })
      .catch((err) => {
        if (err.data) {
          throw new Error(`Error while uploading assets to Cloudflare: ${JSON.stringify(err.data)} - ${err.message}`)
        }
        else {
          throw new Error(`Error while uploading assets to Cloudflare: ${err.message.split(' - ')[1] || err.message}`)
        }
      })
    }));
  }
  return completionToken
}

async function queryDatabase(options) {
  return await ofetch(`${options.hubUrl}/api/projects/${options.projectKey}/database/${options.env}/query`, {
    method: "POST",
    headers: {
      authorization: `Bearer ${options.token}`
    },
    body: {
      query: options.query
    }
  }).catch((error) => {
    throw new Error(`Failed to query database: ${error.data?.message || error.message}`);
  });
}
async function createMigrationsTable(options) {
  await queryDatabase({ ...options, query: CreateDatabaseMigrationsTableQuery });
}
async function fetchRemoteMigrations(options) {
  try {
    const res = await queryDatabase({ ...options, query: ListDatabaseMigrationsQuery });
    return res[0]?.results ?? [];
  } catch (error) {
    if (error?.response?._data?.message?.includes("no such table")) {
      return [];
    }
    throw error;
  }
}

function isPlainObject(value) {
	if (typeof value !== 'object' || value === null) {
		return false;
	}

	const prototype = Object.getPrototypeOf(value);
	return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}

// Allow some arguments/options to be either a file path string or a file URL
const safeNormalizeFileUrl = (file, name) => {
	const fileString = normalizeFileUrl(normalizeDenoExecPath(file));

	if (typeof fileString !== 'string') {
		throw new TypeError(`${name} must be a string or a file URL: ${fileString}.`);
	}

	return fileString;
};

// In Deno node:process execPath is a special object, not just a string:
// https://github.com/denoland/deno/blob/f460188e583f00144000aa0d8ade08218d47c3c1/ext/node/polyfills/process.ts#L344
const normalizeDenoExecPath = file => isDenoExecPath(file)
	? file.toString()
	: file;

const isDenoExecPath = file => typeof file !== 'string'
	&& file
	&& Object.getPrototypeOf(file) === String.prototype;

// Same but also allows other values, e.g. `boolean` for the `shell` option
const normalizeFileUrl = file => file instanceof URL ? fileURLToPath(file) : file;

// The command `arguments` and `options` are both optional.
// This also does basic validation on them and on the command file.
const normalizeParameters = (rawFile, rawArguments = [], rawOptions = {}) => {
	const filePath = safeNormalizeFileUrl(rawFile, 'First argument');
	const [commandArguments, options] = isPlainObject(rawArguments)
		? [[], rawArguments]
		: [rawArguments, rawOptions];

	if (!Array.isArray(commandArguments)) {
		throw new TypeError(`Second argument must be either an array of arguments or an options object: ${commandArguments}`);
	}

	if (commandArguments.some(commandArgument => typeof commandArgument === 'object' && commandArgument !== null)) {
		throw new TypeError(`Second argument must be an array of strings: ${commandArguments}`);
	}

	const normalizedArguments = commandArguments.map(String);
	const nullByteArgument = normalizedArguments.find(normalizedArgument => normalizedArgument.includes('\0'));
	if (nullByteArgument !== undefined) {
		throw new TypeError(`Arguments cannot contain null bytes ("\\0"): ${nullByteArgument}`);
	}

	if (!isPlainObject(options)) {
		throw new TypeError(`Last argument must be an options object: ${options}`);
	}

	return [filePath, normalizedArguments, options];
};

const {toString: objectToString$1} = Object.prototype;

const isArrayBuffer = value => objectToString$1.call(value) === '[object ArrayBuffer]';

// Is either Uint8Array or Buffer
const isUint8Array = value => objectToString$1.call(value) === '[object Uint8Array]';

const bufferToUint8Array = buffer => new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);

const textEncoder$1 = new TextEncoder();
const stringToUint8Array = string => textEncoder$1.encode(string);

const textDecoder = new TextDecoder();
const uint8ArrayToString = uint8Array => textDecoder.decode(uint8Array);

const joinToString = (uint8ArraysOrStrings, encoding) => {
	const strings = uint8ArraysToStrings(uint8ArraysOrStrings, encoding);
	return strings.join('');
};

const uint8ArraysToStrings = (uint8ArraysOrStrings, encoding) => {
	if (encoding === 'utf8' && uint8ArraysOrStrings.every(uint8ArrayOrString => typeof uint8ArrayOrString === 'string')) {
		return uint8ArraysOrStrings;
	}

	const decoder = new StringDecoder(encoding);
	const strings = uint8ArraysOrStrings
		.map(uint8ArrayOrString => typeof uint8ArrayOrString === 'string'
			? stringToUint8Array(uint8ArrayOrString)
			: uint8ArrayOrString)
		.map(uint8Array => decoder.write(uint8Array));
	const finalString = decoder.end();
	return finalString === '' ? strings : [...strings, finalString];
};

const joinToUint8Array = uint8ArraysOrStrings => {
	if (uint8ArraysOrStrings.length === 1 && isUint8Array(uint8ArraysOrStrings[0])) {
		return uint8ArraysOrStrings[0];
	}

	return concatUint8Arrays(stringsToUint8Arrays(uint8ArraysOrStrings));
};

const stringsToUint8Arrays = uint8ArraysOrStrings => uint8ArraysOrStrings.map(uint8ArrayOrString => typeof uint8ArrayOrString === 'string'
	? stringToUint8Array(uint8ArrayOrString)
	: uint8ArrayOrString);

const concatUint8Arrays = uint8Arrays => {
	const result = new Uint8Array(getJoinLength(uint8Arrays));

	let index = 0;
	for (const uint8Array of uint8Arrays) {
		result.set(uint8Array, index);
		index += uint8Array.length;
	}

	return result;
};

const getJoinLength = uint8Arrays => {
	let joinLength = 0;
	for (const uint8Array of uint8Arrays) {
		joinLength += uint8Array.length;
	}

	return joinLength;
};

// Check whether the template string syntax is being used
const isTemplateString = templates => Array.isArray(templates) && Array.isArray(templates.raw);

// Convert execa`file ...commandArguments` to execa(file, commandArguments)
const parseTemplates = (templates, expressions) => {
	let tokens = [];

	for (const [index, template] of templates.entries()) {
		tokens = parseTemplate({
			templates,
			expressions,
			tokens,
			index,
			template,
		});
	}

	if (tokens.length === 0) {
		throw new TypeError('Template script must not be empty');
	}

	const [file, ...commandArguments] = tokens;
	return [file, commandArguments, {}];
};

const parseTemplate = ({templates, expressions, tokens, index, template}) => {
	if (template === undefined) {
		throw new TypeError(`Invalid backslash sequence: ${templates.raw[index]}`);
	}

	const {nextTokens, leadingWhitespaces, trailingWhitespaces} = splitByWhitespaces(template, templates.raw[index]);
	const newTokens = concatTokens(tokens, nextTokens, leadingWhitespaces);

	if (index === expressions.length) {
		return newTokens;
	}

	const expression = expressions[index];
	const expressionTokens = Array.isArray(expression)
		? expression.map(expression => parseExpression(expression))
		: [parseExpression(expression)];
	return concatTokens(newTokens, expressionTokens, trailingWhitespaces);
};

// Like `string.split(/[ \t\r\n]+/)` except newlines and tabs are:
//  - ignored when input as a backslash sequence like: `echo foo\n bar`
//  - not ignored when input directly
// The only way to distinguish those in JavaScript is to use a tagged template and compare:
//  - the first array argument, which does not escape backslash sequences
//  - its `raw` property, which escapes them
const splitByWhitespaces = (template, rawTemplate) => {
	if (rawTemplate.length === 0) {
		return {nextTokens: [], leadingWhitespaces: false, trailingWhitespaces: false};
	}

	const nextTokens = [];
	let templateStart = 0;
	const leadingWhitespaces = DELIMITERS.has(rawTemplate[0]);

	for (
		let templateIndex = 0, rawIndex = 0;
		templateIndex < template.length;
		templateIndex += 1, rawIndex += 1
	) {
		const rawCharacter = rawTemplate[rawIndex];
		if (DELIMITERS.has(rawCharacter)) {
			if (templateStart !== templateIndex) {
				nextTokens.push(template.slice(templateStart, templateIndex));
			}

			templateStart = templateIndex + 1;
		} else if (rawCharacter === '\\') {
			const nextRawCharacter = rawTemplate[rawIndex + 1];
			if (nextRawCharacter === '\n') {
				// Handles escaped newlines in templates
				templateIndex -= 1;
				rawIndex += 1;
			} else if (nextRawCharacter === 'u' && rawTemplate[rawIndex + 2] === '{') {
				rawIndex = rawTemplate.indexOf('}', rawIndex + 3);
			} else {
				rawIndex += ESCAPE_LENGTH[nextRawCharacter] ?? 1;
			}
		}
	}

	const trailingWhitespaces = templateStart === template.length;
	if (!trailingWhitespaces) {
		nextTokens.push(template.slice(templateStart));
	}

	return {nextTokens, leadingWhitespaces, trailingWhitespaces};
};

const DELIMITERS = new Set([' ', '\t', '\r', '\n']);

// Number of characters in backslash escape sequences: \0 \xXX or \uXXXX
// \cX is allowed in RegExps but not in strings
// Octal sequences are not allowed in strict mode
const ESCAPE_LENGTH = {x: 3, u: 5};

const concatTokens = (tokens, nextTokens, isSeparated) => isSeparated
	|| tokens.length === 0
	|| nextTokens.length === 0
	? [...tokens, ...nextTokens]
	: [
		...tokens.slice(0, -1),
		`${tokens.at(-1)}${nextTokens[0]}`,
		...nextTokens.slice(1),
	];

// Handle `${expression}` inside the template string syntax
const parseExpression = expression => {
	const typeOfExpression = typeof expression;

	if (typeOfExpression === 'string') {
		return expression;
	}

	if (typeOfExpression === 'number') {
		return String(expression);
	}

	if (isPlainObject(expression) && ('stdout' in expression || 'isMaxBuffer' in expression)) {
		return getSubprocessResult(expression);
	}

	if (expression instanceof ChildProcess || Object.prototype.toString.call(expression) === '[object Promise]') {
		// eslint-disable-next-line no-template-curly-in-string
		throw new TypeError('Unexpected subprocess in template expression. Please use ${await subprocess} instead of ${subprocess}.');
	}

	throw new TypeError(`Unexpected "${typeOfExpression}" in template expression`);
};

const getSubprocessResult = ({stdout}) => {
	if (typeof stdout === 'string') {
		return stdout;
	}

	if (isUint8Array(stdout)) {
		return uint8ArrayToString(stdout);
	}

	if (stdout === undefined) {
		throw new TypeError('Missing result.stdout in template expression. This is probably due to the previous subprocess\' "stdout" option.');
	}

	throw new TypeError(`Unexpected "${typeof stdout}" stdout in template expression`);
};

const isStandardStream = stream => STANDARD_STREAMS.includes(stream);
const STANDARD_STREAMS = [process$2.stdin, process$2.stdout, process$2.stderr];
const STANDARD_STREAMS_ALIASES = ['stdin', 'stdout', 'stderr'];
const getStreamName = fdNumber => STANDARD_STREAMS_ALIASES[fdNumber] ?? `stdio[${fdNumber}]`;

// Some options can have different values for `stdout`/`stderr`/`fd3`.
// This normalizes those to array of values.
// For example, `{verbose: {stdout: 'none', stderr: 'full'}}` becomes `{verbose: ['none', 'none', 'full']}`
const normalizeFdSpecificOptions = options => {
	const optionsCopy = {...options};

	for (const optionName of FD_SPECIFIC_OPTIONS) {
		optionsCopy[optionName] = normalizeFdSpecificOption(options, optionName);
	}

	return optionsCopy;
};

const normalizeFdSpecificOption = (options, optionName) => {
	const optionBaseArray = Array.from({length: getStdioLength(options) + 1});
	const optionArray = normalizeFdSpecificValue(options[optionName], optionBaseArray, optionName);
	return addDefaultValue$1(optionArray, optionName);
};

const getStdioLength = ({stdio}) => Array.isArray(stdio)
	? Math.max(stdio.length, STANDARD_STREAMS_ALIASES.length)
	: STANDARD_STREAMS_ALIASES.length;

const normalizeFdSpecificValue = (optionValue, optionArray, optionName) => isPlainObject(optionValue)
	? normalizeOptionObject(optionValue, optionArray, optionName)
	: optionArray.fill(optionValue);

const normalizeOptionObject = (optionValue, optionArray, optionName) => {
	for (const fdName of Object.keys(optionValue).sort(compareFdName)) {
		for (const fdNumber of parseFdName(fdName, optionName, optionArray)) {
			optionArray[fdNumber] = optionValue[fdName];
		}
	}

	return optionArray;
};

// Ensure priority order when setting both `stdout`/`stderr`, `fd1`/`fd2`, and `all`
const compareFdName = (fdNameA, fdNameB) => getFdNameOrder(fdNameA) < getFdNameOrder(fdNameB) ? 1 : -1;

const getFdNameOrder = fdName => {
	if (fdName === 'stdout' || fdName === 'stderr') {
		return 0;
	}

	return fdName === 'all' ? 2 : 1;
};

const parseFdName = (fdName, optionName, optionArray) => {
	if (fdName === 'ipc') {
		return [optionArray.length - 1];
	}

	const fdNumber = parseFd(fdName);
	if (fdNumber === undefined || fdNumber === 0) {
		throw new TypeError(`"${optionName}.${fdName}" is invalid.
It must be "${optionName}.stdout", "${optionName}.stderr", "${optionName}.all", "${optionName}.ipc", or "${optionName}.fd3", "${optionName}.fd4" (and so on).`);
	}

	if (fdNumber >= optionArray.length) {
		throw new TypeError(`"${optionName}.${fdName}" is invalid: that file descriptor does not exist.
Please set the "stdio" option to ensure that file descriptor exists.`);
	}

	return fdNumber === 'all' ? [1, 2] : [fdNumber];
};

// Use the same syntax for fd-specific options and the `from`/`to` options
const parseFd = fdName => {
	if (fdName === 'all') {
		return fdName;
	}

	if (STANDARD_STREAMS_ALIASES.includes(fdName)) {
		return STANDARD_STREAMS_ALIASES.indexOf(fdName);
	}

	const regexpResult = FD_REGEXP.exec(fdName);
	if (regexpResult !== null) {
		return Number(regexpResult[1]);
	}
};

const FD_REGEXP = /^fd(\d+)$/;

const addDefaultValue$1 = (optionArray, optionName) => optionArray.map(optionValue => optionValue === undefined
	? DEFAULT_OPTIONS[optionName]
	: optionValue);

// Default value for the `verbose` option
const verboseDefault = debuglog('execa').enabled ? 'full' : 'none';

const DEFAULT_OPTIONS = {
	lines: false,
	buffer: true,
	maxBuffer: 1000 * 1000 * 100,
	verbose: verboseDefault,
	stripFinalNewline: true,
};

// List of options which can have different values for `stdout`/`stderr`
const FD_SPECIFIC_OPTIONS = ['lines', 'buffer', 'maxBuffer', 'verbose', 'stripFinalNewline'];

// Retrieve fd-specific option
const getFdSpecificValue = (optionArray, fdNumber) => fdNumber === 'ipc'
	? optionArray.at(-1)
	: optionArray[fdNumber];

// The `verbose` option can have different values for `stdout`/`stderr`
const isVerbose = ({verbose}, fdNumber) => getFdVerbose(verbose, fdNumber) !== 'none';

// Whether IPC and output and logged
const isFullVerbose = ({verbose}, fdNumber) => !['none', 'short'].includes(getFdVerbose(verbose, fdNumber));

// The `verbose` option can be a function to customize logging
const getVerboseFunction = ({verbose}, fdNumber) => {
	const fdVerbose = getFdVerbose(verbose, fdNumber);
	return isVerboseFunction(fdVerbose) ? fdVerbose : undefined;
};

// When using `verbose: {stdout, stderr, fd3, ipc}`:
//  - `verbose.stdout|stderr|fd3` is used for 'output'
//  - `verbose.ipc` is only used for 'ipc'
//  - highest `verbose.*` value is used for 'command', 'error' and 'duration'
const getFdVerbose = (verbose, fdNumber) => fdNumber === undefined
	? getFdGenericVerbose(verbose)
	: getFdSpecificValue(verbose, fdNumber);

// When using `verbose: {stdout, stderr, fd3, ipc}` and logging is not specific to a file descriptor.
// We then use the highest `verbose.*` value, using the following order:
//  - function > 'full' > 'short' > 'none'
//  - if several functions are defined: stdout > stderr > fd3 > ipc
const getFdGenericVerbose = verbose => verbose.find(fdVerbose => isVerboseFunction(fdVerbose))
	?? VERBOSE_VALUES.findLast(fdVerbose => verbose.includes(fdVerbose));

// Whether the `verbose` option is customized using a function
const isVerboseFunction = fdVerbose => typeof fdVerbose === 'function';

const VERBOSE_VALUES = ['none', 'short', 'full'];

// Compute `result.command` and `result.escapedCommand`
const joinCommand = (filePath, rawArguments) => {
	const fileAndArguments = [filePath, ...rawArguments];
	const command = fileAndArguments.join(' ');
	const escapedCommand = fileAndArguments
		.map(fileAndArgument => quoteString(escapeControlCharacters(fileAndArgument)))
		.join(' ');
	return {command, escapedCommand};
};

// Remove ANSI sequences and escape control characters and newlines
const escapeLines = lines => stripVTControlCharacters(lines)
	.split('\n')
	.map(line => escapeControlCharacters(line))
	.join('\n');

const escapeControlCharacters = line => line.replaceAll(SPECIAL_CHAR_REGEXP, character => escapeControlCharacter(character));

const escapeControlCharacter = character => {
	const commonEscape = COMMON_ESCAPES[character];
	if (commonEscape !== undefined) {
		return commonEscape;
	}

	const codepoint = character.codePointAt(0);
	const codepointHex = codepoint.toString(16);
	return codepoint <= ASTRAL_START
		? `\\u${codepointHex.padStart(4, '0')}`
		: `\\U${codepointHex}`;
};

// Characters that would create issues when printed are escaped using the \u or \U notation.
// Those include control characters and newlines.
// The \u and \U notation is Bash specific, but there is no way to do this in a shell-agnostic way.
// Some shells do not even have a way to print those characters in an escaped fashion.
// Therefore, we prioritize printing those safely, instead of allowing those to be copy-pasted.
// List of Unicode character categories: https://www.fileformat.info/info/unicode/category/index.htm
const getSpecialCharRegExp = () => {
	try {
		// This throws when using Node.js without ICU support.
		// When using a RegExp literal, this would throw at parsing-time, instead of runtime.
		// eslint-disable-next-line prefer-regex-literals
		return new RegExp('\\p{Separator}|\\p{Other}', 'gu');
	} catch {
		// Similar to the above RegExp, but works even when Node.js has been built without ICU support.
		// Unlike the above RegExp, it only covers whitespaces and C0/C1 control characters.
		// It does not cover some edge cases, such as Unicode reserved characters.
		// See https://github.com/sindresorhus/execa/issues/1143
		// eslint-disable-next-line no-control-regex
		return /[\s\u0000-\u001F\u007F-\u009F\u00AD]/g;
	}
};

const SPECIAL_CHAR_REGEXP = getSpecialCharRegExp();

// Accepted by $'...' in Bash.
// Exclude \a \e \v which are accepted in Bash but not in JavaScript (except \v) and JSON.
const COMMON_ESCAPES = {
	' ': ' ',
	'\b': '\\b',
	'\f': '\\f',
	'\n': '\\n',
	'\r': '\\r',
	'\t': '\\t',
};

// Up until that codepoint, \u notation can be used instead of \U
const ASTRAL_START = 65_535;

// Some characters are shell-specific, i.e. need to be escaped when the command is copy-pasted then run.
// Escaping is shell-specific. We cannot know which shell is used: `process.platform` detection is not enough.
// For example, Windows users could be using `cmd.exe`, Powershell or Bash for Windows which all use different escaping.
// We use '...' on Unix, which is POSIX shell compliant and escape all characters but ' so this is fairly safe.
// On Windows, we assume cmd.exe is used and escape with "...", which also works with Powershell.
const quoteString = escapedArgument => {
	if (NO_ESCAPE_REGEXP.test(escapedArgument)) {
		return escapedArgument;
	}

	return platform$2 === 'win32'
		? `"${escapedArgument.replaceAll('"', '""')}"`
		: `'${escapedArgument.replaceAll('\'', '\'\\\'\'')}'`;
};

const NO_ESCAPE_REGEXP = /^[\w./-]+$/;

const common = {
	circleQuestionMark: '(?)',
	questionMarkPrefix: '(?)',
	square: '',
	squareDarkShade: '',
	squareMediumShade: '',
	squareLightShade: '',
	squareTop: '',
	squareBottom: '',
	squareLeft: '',
	squareRight: '',
	squareCenter: '',
	bullet: '',
	dot: '',
	ellipsis: '',
	pointerSmall: '',
	triangleUp: '',
	triangleUpSmall: '',
	triangleDown: '',
	triangleDownSmall: '',
	triangleLeftSmall: '',
	triangleRightSmall: '',
	home: '',
	heart: '',
	musicNote: '',
	musicNoteBeamed: '',
	arrowUp: '',
	arrowDown: '',
	arrowLeft: '',
	arrowRight: '',
	arrowLeftRight: '',
	arrowUpDown: '',
	almostEqual: '',
	notEqual: '',
	lessOrEqual: '',
	greaterOrEqual: '',
	identical: '',
	infinity: '',
	subscriptZero: '',
	subscriptOne: '',
	subscriptTwo: '',
	subscriptThree: '',
	subscriptFour: '',
	subscriptFive: '',
	subscriptSix: '',
	subscriptSeven: '',
	subscriptEight: '',
	subscriptNine: '',
	oneHalf: '',
	oneThird: '',
	oneQuarter: '',
	oneFifth: '',
	oneSixth: '',
	oneEighth: '',
	twoThirds: '',
	twoFifths: '',
	threeQuarters: '',
	threeFifths: '',
	threeEighths: '',
	fourFifths: '',
	fiveSixths: '',
	fiveEighths: '',
	sevenEighths: '',
	line: '',
	lineBold: '',
	lineDouble: '',
	lineDashed0: '',
	lineDashed1: '',
	lineDashed2: '',
	lineDashed3: '',
	lineDashed4: '',
	lineDashed5: '',
	lineDashed6: '',
	lineDashed7: '',
	lineDashed8: '',
	lineDashed9: '',
	lineDashed10: '',
	lineDashed11: '',
	lineDashed12: '',
	lineDashed13: '',
	lineDashed14: '',
	lineDashed15: '',
	lineVertical: '',
	lineVerticalBold: '',
	lineVerticalDouble: '',
	lineVerticalDashed0: '',
	lineVerticalDashed1: '',
	lineVerticalDashed2: '',
	lineVerticalDashed3: '',
	lineVerticalDashed4: '',
	lineVerticalDashed5: '',
	lineVerticalDashed6: '',
	lineVerticalDashed7: '',
	lineVerticalDashed8: '',
	lineVerticalDashed9: '',
	lineVerticalDashed10: '',
	lineVerticalDashed11: '',
	lineDownLeft: '',
	lineDownLeftArc: '',
	lineDownBoldLeftBold: '',
	lineDownBoldLeft: '',
	lineDownLeftBold: '',
	lineDownDoubleLeftDouble: '',
	lineDownDoubleLeft: '',
	lineDownLeftDouble: '',
	lineDownRight: '',
	lineDownRightArc: '',
	lineDownBoldRightBold: '',
	lineDownBoldRight: '',
	lineDownRightBold: '',
	lineDownDoubleRightDouble: '',
	lineDownDoubleRight: '',
	lineDownRightDouble: '',
	lineUpLeft: '',
	lineUpLeftArc: '',
	lineUpBoldLeftBold: '',
	lineUpBoldLeft: '',
	lineUpLeftBold: '',
	lineUpDoubleLeftDouble: '',
	lineUpDoubleLeft: '',
	lineUpLeftDouble: '',
	lineUpRight: '',
	lineUpRightArc: '',
	lineUpBoldRightBold: '',
	lineUpBoldRight: '',
	lineUpRightBold: '',
	lineUpDoubleRightDouble: '',
	lineUpDoubleRight: '',
	lineUpRightDouble: '',
	lineUpDownLeft: '',
	lineUpBoldDownBoldLeftBold: '',
	lineUpBoldDownBoldLeft: '',
	lineUpDownLeftBold: '',
	lineUpBoldDownLeftBold: '',
	lineUpDownBoldLeftBold: '',
	lineUpDownBoldLeft: '',
	lineUpBoldDownLeft: '',
	lineUpDoubleDownDoubleLeftDouble: '',
	lineUpDoubleDownDoubleLeft: '',
	lineUpDownLeftDouble: '',
	lineUpDownRight: '',
	lineUpBoldDownBoldRightBold: '',
	lineUpBoldDownBoldRight: '',
	lineUpDownRightBold: '',
	lineUpBoldDownRightBold: '',
	lineUpDownBoldRightBold: '',
	lineUpDownBoldRight: '',
	lineUpBoldDownRight: '',
	lineUpDoubleDownDoubleRightDouble: '',
	lineUpDoubleDownDoubleRight: '',
	lineUpDownRightDouble: '',
	lineDownLeftRight: '',
	lineDownBoldLeftBoldRightBold: '',
	lineDownLeftBoldRightBold: '',
	lineDownBoldLeftRight: '',
	lineDownBoldLeftBoldRight: '',
	lineDownBoldLeftRightBold: '',
	lineDownLeftRightBold: '',
	lineDownLeftBoldRight: '',
	lineDownDoubleLeftDoubleRightDouble: '',
	lineDownDoubleLeftRight: '',
	lineDownLeftDoubleRightDouble: '',
	lineUpLeftRight: '',
	lineUpBoldLeftBoldRightBold: '',
	lineUpLeftBoldRightBold: '',
	lineUpBoldLeftRight: '',
	lineUpBoldLeftBoldRight: '',
	lineUpBoldLeftRightBold: '',
	lineUpLeftRightBold: '',
	lineUpLeftBoldRight: '',
	lineUpDoubleLeftDoubleRightDouble: '',
	lineUpDoubleLeftRight: '',
	lineUpLeftDoubleRightDouble: '',
	lineUpDownLeftRight: '',
	lineUpBoldDownBoldLeftBoldRightBold: '',
	lineUpDownBoldLeftBoldRightBold: '',
	lineUpBoldDownLeftBoldRightBold: '',
	lineUpBoldDownBoldLeftRightBold: '',
	lineUpBoldDownBoldLeftBoldRight: '',
	lineUpBoldDownLeftRight: '',
	lineUpDownBoldLeftRight: '',
	lineUpDownLeftBoldRight: '',
	lineUpDownLeftRightBold: '',
	lineUpBoldDownBoldLeftRight: '',
	lineUpDownLeftBoldRightBold: '',
	lineUpBoldDownLeftBoldRight: '',
	lineUpBoldDownLeftRightBold: '',
	lineUpDownBoldLeftBoldRight: '',
	lineUpDownBoldLeftRightBold: '',
	lineUpDoubleDownDoubleLeftDoubleRightDouble: '',
	lineUpDoubleDownDoubleLeftRight: '',
	lineUpDownLeftDoubleRightDouble: '',
	lineCross: '',
	lineBackslash: '',
	lineSlash: '',
};

const specialMainSymbols = {
	tick: '',
	info: '',
	warning: '',
	cross: '',
	squareSmall: '',
	squareSmallFilled: '',
	circle: '',
	circleFilled: '',
	circleDotted: '',
	circleDouble: '',
	circleCircle: '',
	circleCross: '',
	circlePipe: '',
	radioOn: '',
	radioOff: '',
	checkboxOn: '',
	checkboxOff: '',
	checkboxCircleOn: '',
	checkboxCircleOff: '',
	pointer: '',
	triangleUpOutline: '',
	triangleLeft: '',
	triangleRight: '',
	lozenge: '',
	lozengeOutline: '',
	hamburger: '',
	smiley: '',
	mustache: '',
	star: '',
	play: '',
	nodejs: '',
	oneSeventh: '',
	oneNinth: '',
	oneTenth: '',
};

const specialFallbackSymbols = {
	tick: '',
	info: 'i',
	warning: '',
	cross: '',
	squareSmall: '',
	squareSmallFilled: '',
	circle: '( )',
	circleFilled: '(*)',
	circleDotted: '( )',
	circleDouble: '( )',
	circleCircle: '()',
	circleCross: '()',
	circlePipe: '()',
	radioOn: '(*)',
	radioOff: '( )',
	checkboxOn: '[]',
	checkboxOff: '[ ]',
	checkboxCircleOn: '()',
	checkboxCircleOff: '( )',
	pointer: '>',
	triangleUpOutline: '',
	triangleLeft: '',
	triangleRight: '',
	lozenge: '',
	lozengeOutline: '',
	hamburger: '',
	smiley: '',
	mustache: '',
	star: '',
	play: '',
	nodejs: '',
	oneSeventh: '1/7',
	oneNinth: '1/9',
	oneTenth: '1/10',
};

const mainSymbols = {...common, ...specialMainSymbols};
const fallbackSymbols = {...common, ...specialFallbackSymbols};

const shouldUseMain = isUnicodeSupported();
const figures = shouldUseMain ? mainSymbols : fallbackSymbols;

// eslint-disable-next-line no-warning-comments
// TODO: Use a better method when it's added to Node.js (https://github.com/nodejs/node/pull/40240)
// Lots of optionals here to support Deno.
const hasColors = tty__default?.WriteStream?.prototype?.hasColors?.() ?? false;

const format = (open, close) => {
	if (!hasColors) {
		return input => input;
	}

	const openCode = `\u001B[${open}m`;
	const closeCode = `\u001B[${close}m`;

	return input => {
		const string = input + ''; // eslint-disable-line no-implicit-coercion -- This is faster.
		let index = string.indexOf(closeCode);

		if (index === -1) {
			// Note: Intentionally not using string interpolation for performance reasons.
			return openCode + string + closeCode;
		}

		// Handle nested colors.

		// We could have done this, but it's too slow (as of Node.js 22).
		// return openCode + string.replaceAll(closeCode, openCode) + closeCode;

		let result = openCode;
		let lastIndex = 0;

		while (index !== -1) {
			result += string.slice(lastIndex, index) + openCode;
			lastIndex = index + closeCode.length;
			index = string.indexOf(closeCode, lastIndex);
		}

		result += string.slice(lastIndex) + closeCode;

		return result;
	};
};
const bold = format(1, 22);
const gray = format(90, 39);

const redBright = format(91, 39);
const yellowBright = format(93, 39);

// Default when `verbose` is not a function
const defaultVerboseFunction = ({
	type,
	message,
	timestamp,
	piped,
	commandId,
	result: {failed = false} = {},
	options: {reject = true},
}) => {
	const timestampString = serializeTimestamp(timestamp);
	const icon = ICONS[type]({failed, reject, piped});
	const color = COLORS[type]({reject});
	return `${gray(`[${timestampString}]`)} ${gray(`[${commandId}]`)} ${color(icon)} ${color(message)}`;
};

// Prepending the timestamp allows debugging the slow paths of a subprocess
const serializeTimestamp = timestamp => `${padField(timestamp.getHours(), 2)}:${padField(timestamp.getMinutes(), 2)}:${padField(timestamp.getSeconds(), 2)}.${padField(timestamp.getMilliseconds(), 3)}`;

const padField = (field, padding) => String(field).padStart(padding, '0');

const getFinalIcon = ({failed, reject}) => {
	if (!failed) {
		return figures.tick;
	}

	return reject ? figures.cross : figures.warning;
};

const ICONS = {
	command: ({piped}) => piped ? '|' : '$',
	output: () => ' ',
	ipc: () => '*',
	error: getFinalIcon,
	duration: getFinalIcon,
};

const identity$1 = string => string;

const COLORS = {
	command: () => bold,
	output: () => identity$1,
	ipc: () => identity$1,
	error: ({reject}) => reject ? redBright : yellowBright,
	duration: () => gray,
};

// Apply the `verbose` function on each line
const applyVerboseOnLines = (printedLines, verboseInfo, fdNumber) => {
	const verboseFunction = getVerboseFunction(verboseInfo, fdNumber);
	return printedLines
		.map(({verboseLine, verboseObject}) => applyVerboseFunction(verboseLine, verboseObject, verboseFunction))
		.filter(printedLine => printedLine !== undefined)
		.map(printedLine => appendNewline(printedLine))
		.join('');
};

const applyVerboseFunction = (verboseLine, verboseObject, verboseFunction) => {
	if (verboseFunction === undefined) {
		return verboseLine;
	}

	const printedLine = verboseFunction(verboseLine, verboseObject);
	if (typeof printedLine === 'string') {
		return printedLine;
	}
};

const appendNewline = printedLine => printedLine.endsWith('\n')
	? printedLine
	: `${printedLine}\n`;

// This prints on stderr.
// If the subprocess prints on stdout and is using `stdout: 'inherit'`,
// there is a chance both writes will compete (introducing a race condition).
// This means their respective order is not deterministic.
// In particular, this means the verbose command lines might be after the start of the subprocess output.
// Using synchronous I/O does not solve this problem.
// However, this only seems to happen when the stdout/stderr target
// (e.g. a terminal) is being written to by many subprocesses at once, which is unlikely in real scenarios.
const verboseLog = ({type, verboseMessage, fdNumber, verboseInfo, result}) => {
	const verboseObject = getVerboseObject({type, result, verboseInfo});
	const printedLines = getPrintedLines(verboseMessage, verboseObject);
	const finalLines = applyVerboseOnLines(printedLines, verboseInfo, fdNumber);
	if (finalLines !== '') {
		console.warn(finalLines.slice(0, -1));
	}
};

const getVerboseObject = ({
	type,
	result,
	verboseInfo: {escapedCommand, commandId, rawOptions: {piped = false, ...options}},
}) => ({
	type,
	escapedCommand,
	commandId: `${commandId}`,
	timestamp: new Date(),
	piped,
	result,
	options,
});

const getPrintedLines = (verboseMessage, verboseObject) => verboseMessage
	.split('\n')
	.map(message => getPrintedLine({...verboseObject, message}));

const getPrintedLine = verboseObject => {
	const verboseLine = defaultVerboseFunction(verboseObject);
	return {verboseLine, verboseObject};
};

// Serialize any type to a line string, for logging
const serializeVerboseMessage = message => {
	const messageString = typeof message === 'string' ? message : inspect(message);
	const escapedMessage = escapeLines(messageString);
	return escapedMessage.replaceAll('\t', ' '.repeat(TAB_SIZE));
};

// Same as `util.inspect()`
const TAB_SIZE = 2;

// When `verbose` is `short|full|custom`, print each command
const logCommand = (escapedCommand, verboseInfo) => {
	if (!isVerbose(verboseInfo)) {
		return;
	}

	verboseLog({
		type: 'command',
		verboseMessage: escapedCommand,
		verboseInfo,
	});
};

// Information computed before spawning, used by the `verbose` option
const getVerboseInfo = (verbose, escapedCommand, rawOptions) => {
	validateVerbose(verbose);
	const commandId = getCommandId(verbose);
	return {
		verbose,
		escapedCommand,
		commandId,
		rawOptions,
	};
};

const getCommandId = verbose => isVerbose({verbose}) ? COMMAND_ID++ : undefined;

// Prepending the `pid` is useful when multiple commands print their output at the same time.
// However, we cannot use the real PID since this is not available with `child_process.spawnSync()`.
// Also, we cannot use the real PID if we want to print it before `child_process.spawn()` is run.
// As a pro, it is shorter than a normal PID and never re-uses the same id.
// As a con, it cannot be used to send signals.
let COMMAND_ID = 0n;

const validateVerbose = verbose => {
	for (const fdVerbose of verbose) {
		if (fdVerbose === false) {
			throw new TypeError('The "verbose: false" option was renamed to "verbose: \'none\'".');
		}

		if (fdVerbose === true) {
			throw new TypeError('The "verbose: true" option was renamed to "verbose: \'short\'".');
		}

		if (!VERBOSE_VALUES.includes(fdVerbose) && !isVerboseFunction(fdVerbose)) {
			const allowedValues = VERBOSE_VALUES.map(allowedValue => `'${allowedValue}'`).join(', ');
			throw new TypeError(`The "verbose" option must not be ${fdVerbose}. Allowed values are: ${allowedValues} or a function.`);
		}
	}
};

// Start counting time before spawning the subprocess
const getStartTime = () => hrtime.bigint();

// Compute duration after the subprocess ended.
// Printed by the `verbose` option.
const getDurationMs = startTime => Number(hrtime.bigint() - startTime) / 1e6;

// Compute `result.command`, `result.escapedCommand` and `verbose`-related information
const handleCommand = (filePath, rawArguments, rawOptions) => {
	const startTime = getStartTime();
	const {command, escapedCommand} = joinCommand(filePath, rawArguments);
	const verbose = normalizeFdSpecificOption(rawOptions, 'verbose');
	const verboseInfo = getVerboseInfo(verbose, escapedCommand, {...rawOptions});
	logCommand(escapedCommand, verboseInfo);
	return {
		command,
		escapedCommand,
		startTime,
		verboseInfo,
	};
};

var crossSpawn$1 = {exports: {}};

var windows;
var hasRequiredWindows;

function requireWindows () {
	if (hasRequiredWindows) return windows;
	hasRequiredWindows = 1;
	windows = isexe;
	isexe.sync = sync;

	var fs = require$$0$1;

	function checkPathExt (path, options) {
	  var pathext = options.pathExt !== undefined ?
	    options.pathExt : process.env.PATHEXT;

	  if (!pathext) {
	    return true
	  }

	  pathext = pathext.split(';');
	  if (pathext.indexOf('') !== -1) {
	    return true
	  }
	  for (var i = 0; i < pathext.length; i++) {
	    var p = pathext[i].toLowerCase();
	    if (p && path.substr(-p.length).toLowerCase() === p) {
	      return true
	    }
	  }
	  return false
	}

	function checkStat (stat, path, options) {
	  if (!stat.isSymbolicLink() && !stat.isFile()) {
	    return false
	  }
	  return checkPathExt(path, options)
	}

	function isexe (path, options, cb) {
	  fs.stat(path, function (er, stat) {
	    cb(er, er ? false : checkStat(stat, path, options));
	  });
	}

	function sync (path, options) {
	  return checkStat(fs.statSync(path), path, options)
	}
	return windows;
}

var mode;
var hasRequiredMode;

function requireMode () {
	if (hasRequiredMode) return mode;
	hasRequiredMode = 1;
	mode = isexe;
	isexe.sync = sync;

	var fs = require$$0$1;

	function isexe (path, options, cb) {
	  fs.stat(path, function (er, stat) {
	    cb(er, er ? false : checkStat(stat, options));
	  });
	}

	function sync (path, options) {
	  return checkStat(fs.statSync(path), options)
	}

	function checkStat (stat, options) {
	  return stat.isFile() && checkMode(stat, options)
	}

	function checkMode (stat, options) {
	  var mod = stat.mode;
	  var uid = stat.uid;
	  var gid = stat.gid;

	  var myUid = options.uid !== undefined ?
	    options.uid : process.getuid && process.getuid();
	  var myGid = options.gid !== undefined ?
	    options.gid : process.getgid && process.getgid();

	  var u = parseInt('100', 8);
	  var g = parseInt('010', 8);
	  var o = parseInt('001', 8);
	  var ug = u | g;

	  var ret = (mod & o) ||
	    (mod & g) && gid === myGid ||
	    (mod & u) && uid === myUid ||
	    (mod & ug) && myUid === 0;

	  return ret
	}
	return mode;
}

var isexe_1;
var hasRequiredIsexe;

function requireIsexe () {
	if (hasRequiredIsexe) return isexe_1;
	hasRequiredIsexe = 1;
	var core;
	if (process.platform === 'win32' || commonjsGlobal.TESTING_WINDOWS) {
	  core = requireWindows();
	} else {
	  core = requireMode();
	}

	isexe_1 = isexe;
	isexe.sync = sync;

	function isexe (path, options, cb) {
	  if (typeof options === 'function') {
	    cb = options;
	    options = {};
	  }

	  if (!cb) {
	    if (typeof Promise !== 'function') {
	      throw new TypeError('callback not provided')
	    }

	    return new Promise(function (resolve, reject) {
	      isexe(path, options || {}, function (er, is) {
	        if (er) {
	          reject(er);
	        } else {
	          resolve(is);
	        }
	      });
	    })
	  }

	  core(path, options || {}, function (er, is) {
	    // ignore EACCES because that just means we aren't allowed to run it
	    if (er) {
	      if (er.code === 'EACCES' || options && options.ignoreErrors) {
	        er = null;
	        is = false;
	      }
	    }
	    cb(er, is);
	  });
	}

	function sync (path, options) {
	  // my kingdom for a filtered catch
	  try {
	    return core.sync(path, options || {})
	  } catch (er) {
	    if (options && options.ignoreErrors || er.code === 'EACCES') {
	      return false
	    } else {
	      throw er
	    }
	  }
	}
	return isexe_1;
}

var which_1;
var hasRequiredWhich;

function requireWhich () {
	if (hasRequiredWhich) return which_1;
	hasRequiredWhich = 1;
	const isWindows = process.platform === 'win32' ||
	    process.env.OSTYPE === 'cygwin' ||
	    process.env.OSTYPE === 'msys';

	const path = sysPath__default;
	const COLON = isWindows ? ';' : ':';
	const isexe = requireIsexe();

	const getNotFoundError = (cmd) =>
	  Object.assign(new Error(`not found: ${cmd}`), { code: 'ENOENT' });

	const getPathInfo = (cmd, opt) => {
	  const colon = opt.colon || COLON;

	  // If it has a slash, then we don't bother searching the pathenv.
	  // just check the file itself, and that's it.
	  const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? ['']
	    : (
	      [
	        // windows always checks the cwd first
	        ...(isWindows ? [process.cwd()] : []),
	        ...(opt.path || process.env.PATH ||
	          /* istanbul ignore next: very unusual */ '').split(colon),
	      ]
	    );
	  const pathExtExe = isWindows
	    ? opt.pathExt || process.env.PATHEXT || '.EXE;.CMD;.BAT;.COM'
	    : '';
	  const pathExt = isWindows ? pathExtExe.split(colon) : [''];

	  if (isWindows) {
	    if (cmd.indexOf('.') !== -1 && pathExt[0] !== '')
	      pathExt.unshift('');
	  }

	  return {
	    pathEnv,
	    pathExt,
	    pathExtExe,
	  }
	};

	const which = (cmd, opt, cb) => {
	  if (typeof opt === 'function') {
	    cb = opt;
	    opt = {};
	  }
	  if (!opt)
	    opt = {};

	  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
	  const found = [];

	  const step = i => new Promise((resolve, reject) => {
	    if (i === pathEnv.length)
	      return opt.all && found.length ? resolve(found)
	        : reject(getNotFoundError(cmd))

	    const ppRaw = pathEnv[i];
	    const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;

	    const pCmd = path.join(pathPart, cmd);
	    const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd
	      : pCmd;

	    resolve(subStep(p, i, 0));
	  });

	  const subStep = (p, i, ii) => new Promise((resolve, reject) => {
	    if (ii === pathExt.length)
	      return resolve(step(i + 1))
	    const ext = pathExt[ii];
	    isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {
	      if (!er && is) {
	        if (opt.all)
	          found.push(p + ext);
	        else
	          return resolve(p + ext)
	      }
	      return resolve(subStep(p, i, ii + 1))
	    });
	  });

	  return cb ? step(0).then(res => cb(null, res), cb) : step(0)
	};

	const whichSync = (cmd, opt) => {
	  opt = opt || {};

	  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
	  const found = [];

	  for (let i = 0; i < pathEnv.length; i ++) {
	    const ppRaw = pathEnv[i];
	    const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;

	    const pCmd = path.join(pathPart, cmd);
	    const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd
	      : pCmd;

	    for (let j = 0; j < pathExt.length; j ++) {
	      const cur = p + pathExt[j];
	      try {
	        const is = isexe.sync(cur, { pathExt: pathExtExe });
	        if (is) {
	          if (opt.all)
	            found.push(cur);
	          else
	            return cur
	        }
	      } catch (ex) {}
	    }
	  }

	  if (opt.all && found.length)
	    return found

	  if (opt.nothrow)
	    return null

	  throw getNotFoundError(cmd)
	};

	which_1 = which;
	which.sync = whichSync;
	return which_1;
}

var pathKey$1 = {exports: {}};

var hasRequiredPathKey;

function requirePathKey () {
	if (hasRequiredPathKey) return pathKey$1.exports;
	hasRequiredPathKey = 1;

	const pathKey = (options = {}) => {
		const environment = options.env || process.env;
		const platform = options.platform || process.platform;

		if (platform !== 'win32') {
			return 'PATH';
		}

		return Object.keys(environment).reverse().find(key => key.toUpperCase() === 'PATH') || 'Path';
	};

	pathKey$1.exports = pathKey;
	// TODO: Remove this for the next major release
	pathKey$1.exports.default = pathKey;
	return pathKey$1.exports;
}

var resolveCommand_1;
var hasRequiredResolveCommand;

function requireResolveCommand () {
	if (hasRequiredResolveCommand) return resolveCommand_1;
	hasRequiredResolveCommand = 1;

	const path = sysPath__default;
	const which = requireWhich();
	const getPathKey = requirePathKey();

	function resolveCommandAttempt(parsed, withoutPathExt) {
	    const env = parsed.options.env || process.env;
	    const cwd = process.cwd();
	    const hasCustomCwd = parsed.options.cwd != null;
	    // Worker threads do not have process.chdir()
	    const shouldSwitchCwd = hasCustomCwd && process.chdir !== undefined && !process.chdir.disabled;

	    // If a custom `cwd` was specified, we need to change the process cwd
	    // because `which` will do stat calls but does not support a custom cwd
	    if (shouldSwitchCwd) {
	        try {
	            process.chdir(parsed.options.cwd);
	        } catch (err) {
	            /* Empty */
	        }
	    }

	    let resolved;

	    try {
	        resolved = which.sync(parsed.command, {
	            path: env[getPathKey({ env })],
	            pathExt: withoutPathExt ? path.delimiter : undefined,
	        });
	    } catch (e) {
	        /* Empty */
	    } finally {
	        if (shouldSwitchCwd) {
	            process.chdir(cwd);
	        }
	    }

	    // If we successfully resolved, ensure that an absolute path is returned
	    // Note that when a custom `cwd` was used, we need to resolve to an absolute path based on it
	    if (resolved) {
	        resolved = path.resolve(hasCustomCwd ? parsed.options.cwd : '', resolved);
	    }

	    return resolved;
	}

	function resolveCommand(parsed) {
	    return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
	}

	resolveCommand_1 = resolveCommand;
	return resolveCommand_1;
}

var _escape = {};

var hasRequired_escape;

function require_escape () {
	if (hasRequired_escape) return _escape;
	hasRequired_escape = 1;

	// See http://www.robvanderwoude.com/escapechars.php
	const metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;

	function escapeCommand(arg) {
	    // Escape meta chars
	    arg = arg.replace(metaCharsRegExp, '^$1');

	    return arg;
	}

	function escapeArgument(arg, doubleEscapeMetaChars) {
	    // Convert to string
	    arg = `${arg}`;

	    // Algorithm below is based on https://qntm.org/cmd
	    // It's slightly altered to disable JS backtracking to avoid hanging on specially crafted input
	    // Please see https://github.com/moxystudio/node-cross-spawn/pull/160 for more information

	    // Sequence of backslashes followed by a double quote:
	    // double up all the backslashes and escape the double quote
	    arg = arg.replace(/(?=(\\+?)?)\1"/g, '$1$1\\"');

	    // Sequence of backslashes followed by the end of the string
	    // (which will become a double quote later):
	    // double up all the backslashes
	    arg = arg.replace(/(?=(\\+?)?)\1$/, '$1$1');

	    // All other backslashes occur literally

	    // Quote the whole thing:
	    arg = `"${arg}"`;

	    // Escape meta chars
	    arg = arg.replace(metaCharsRegExp, '^$1');

	    // Double escape meta chars if necessary
	    if (doubleEscapeMetaChars) {
	        arg = arg.replace(metaCharsRegExp, '^$1');
	    }

	    return arg;
	}

	_escape.command = escapeCommand;
	_escape.argument = escapeArgument;
	return _escape;
}

var shebangRegex;
var hasRequiredShebangRegex;

function requireShebangRegex () {
	if (hasRequiredShebangRegex) return shebangRegex;
	hasRequiredShebangRegex = 1;
	shebangRegex = /^#!(.*)/;
	return shebangRegex;
}

var shebangCommand;
var hasRequiredShebangCommand;

function requireShebangCommand () {
	if (hasRequiredShebangCommand) return shebangCommand;
	hasRequiredShebangCommand = 1;
	const shebangRegex = requireShebangRegex();

	shebangCommand = (string = '') => {
		const match = string.match(shebangRegex);

		if (!match) {
			return null;
		}

		const [path, argument] = match[0].replace(/#! ?/, '').split(' ');
		const binary = path.split('/').pop();

		if (binary === 'env') {
			return argument;
		}

		return argument ? `${binary} ${argument}` : binary;
	};
	return shebangCommand;
}

var readShebang_1;
var hasRequiredReadShebang;

function requireReadShebang () {
	if (hasRequiredReadShebang) return readShebang_1;
	hasRequiredReadShebang = 1;

	const fs = require$$0$1;
	const shebangCommand = requireShebangCommand();

	function readShebang(command) {
	    // Read the first 150 bytes from the file
	    const size = 150;
	    const buffer = Buffer.alloc(size);

	    let fd;

	    try {
	        fd = fs.openSync(command, 'r');
	        fs.readSync(fd, buffer, 0, size, 0);
	        fs.closeSync(fd);
	    } catch (e) { /* Empty */ }

	    // Attempt to extract shebang (null is returned if not a shebang)
	    return shebangCommand(buffer.toString());
	}

	readShebang_1 = readShebang;
	return readShebang_1;
}

var parse_1;
var hasRequiredParse;

function requireParse () {
	if (hasRequiredParse) return parse_1;
	hasRequiredParse = 1;

	const path = sysPath__default;
	const resolveCommand = requireResolveCommand();
	const escape = require_escape();
	const readShebang = requireReadShebang();

	const isWin = process.platform === 'win32';
	const isExecutableRegExp = /\.(?:com|exe)$/i;
	const isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;

	function detectShebang(parsed) {
	    parsed.file = resolveCommand(parsed);

	    const shebang = parsed.file && readShebang(parsed.file);

	    if (shebang) {
	        parsed.args.unshift(parsed.file);
	        parsed.command = shebang;

	        return resolveCommand(parsed);
	    }

	    return parsed.file;
	}

	function parseNonShell(parsed) {
	    if (!isWin) {
	        return parsed;
	    }

	    // Detect & add support for shebangs
	    const commandFile = detectShebang(parsed);

	    // We don't need a shell if the command filename is an executable
	    const needsShell = !isExecutableRegExp.test(commandFile);

	    // If a shell is required, use cmd.exe and take care of escaping everything correctly
	    // Note that `forceShell` is an hidden option used only in tests
	    if (parsed.options.forceShell || needsShell) {
	        // Need to double escape meta chars if the command is a cmd-shim located in `node_modules/.bin/`
	        // The cmd-shim simply calls execute the package bin file with NodeJS, proxying any argument
	        // Because the escape of metachars with ^ gets interpreted when the cmd.exe is first called,
	        // we need to double escape them
	        const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);

	        // Normalize posix paths into OS compatible paths (e.g.: foo/bar -> foo\bar)
	        // This is necessary otherwise it will always fail with ENOENT in those cases
	        parsed.command = path.normalize(parsed.command);

	        // Escape command & arguments
	        parsed.command = escape.command(parsed.command);
	        parsed.args = parsed.args.map((arg) => escape.argument(arg, needsDoubleEscapeMetaChars));

	        const shellCommand = [parsed.command].concat(parsed.args).join(' ');

	        parsed.args = ['/d', '/s', '/c', `"${shellCommand}"`];
	        parsed.command = process.env.comspec || 'cmd.exe';
	        parsed.options.windowsVerbatimArguments = true; // Tell node's spawn that the arguments are already escaped
	    }

	    return parsed;
	}

	function parse(command, args, options) {
	    // Normalize arguments, similar to nodejs
	    if (args && !Array.isArray(args)) {
	        options = args;
	        args = null;
	    }

	    args = args ? args.slice(0) : []; // Clone array to avoid changing the original
	    options = Object.assign({}, options); // Clone object to avoid changing the original

	    // Build our parsed object
	    const parsed = {
	        command,
	        args,
	        options,
	        file: undefined,
	        original: {
	            command,
	            args,
	        },
	    };

	    // Delegate further parsing to shell or non-shell
	    return options.shell ? parsed : parseNonShell(parsed);
	}

	parse_1 = parse;
	return parse_1;
}

var enoent;
var hasRequiredEnoent;

function requireEnoent () {
	if (hasRequiredEnoent) return enoent;
	hasRequiredEnoent = 1;

	const isWin = process.platform === 'win32';

	function notFoundError(original, syscall) {
	    return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
	        code: 'ENOENT',
	        errno: 'ENOENT',
	        syscall: `${syscall} ${original.command}`,
	        path: original.command,
	        spawnargs: original.args,
	    });
	}

	function hookChildProcess(cp, parsed) {
	    if (!isWin) {
	        return;
	    }

	    const originalEmit = cp.emit;

	    cp.emit = function (name, arg1) {
	        // If emitting "exit" event and exit code is 1, we need to check if
	        // the command exists and emit an "error" instead
	        // See https://github.com/IndigoUnited/node-cross-spawn/issues/16
	        if (name === 'exit') {
	            const err = verifyENOENT(arg1, parsed);

	            if (err) {
	                return originalEmit.call(cp, 'error', err);
	            }
	        }

	        return originalEmit.apply(cp, arguments); // eslint-disable-line prefer-rest-params
	    };
	}

	function verifyENOENT(status, parsed) {
	    if (isWin && status === 1 && !parsed.file) {
	        return notFoundError(parsed.original, 'spawn');
	    }

	    return null;
	}

	function verifyENOENTSync(status, parsed) {
	    if (isWin && status === 1 && !parsed.file) {
	        return notFoundError(parsed.original, 'spawnSync');
	    }

	    return null;
	}

	enoent = {
	    hookChildProcess,
	    verifyENOENT,
	    verifyENOENTSync,
	    notFoundError,
	};
	return enoent;
}

var hasRequiredCrossSpawn;

function requireCrossSpawn () {
	if (hasRequiredCrossSpawn) return crossSpawn$1.exports;
	hasRequiredCrossSpawn = 1;

	const cp = require$$2$2;
	const parse = requireParse();
	const enoent = requireEnoent();

	function spawn(command, args, options) {
	    // Parse the arguments
	    const parsed = parse(command, args, options);

	    // Spawn the child process
	    const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);

	    // Hook into child process "exit" event to emit an error if the command
	    // does not exists, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16
	    enoent.hookChildProcess(spawned, parsed);

	    return spawned;
	}

	function spawnSync(command, args, options) {
	    // Parse the arguments
	    const parsed = parse(command, args, options);

	    // Spawn the child process
	    const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);

	    // Analyze if the command does not exist, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16
	    result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);

	    return result;
	}

	crossSpawn$1.exports = spawn;
	crossSpawn$1.exports.spawn = spawn;
	crossSpawn$1.exports.sync = spawnSync;

	crossSpawn$1.exports._parse = parse;
	crossSpawn$1.exports._enoent = enoent;
	return crossSpawn$1.exports;
}

var crossSpawnExports = requireCrossSpawn();
const crossSpawn = /*@__PURE__*/getDefaultExportFromCjs(crossSpawnExports);

function pathKey(options = {}) {
	const {
		env = process.env,
		platform = process.platform
	} = options;

	if (platform !== 'win32') {
		return 'PATH';
	}

	return Object.keys(env).reverse().find(key => key.toUpperCase() === 'PATH') || 'Path';
}

promisify(execFile);

function toPath(urlOrPath) {
	return urlOrPath instanceof URL ? fileURLToPath(urlOrPath) : urlOrPath;
}

function traversePathUp(startPath) {
	return {
		* [Symbol.iterator]() {
			let currentPath = path.resolve(toPath(startPath));
			let previousPath;

			while (previousPath !== currentPath) {
				yield currentPath;
				previousPath = currentPath;
				currentPath = path.resolve(currentPath, '..');
			}
		},
	};
}

const npmRunPath = ({
	cwd = process$2.cwd(),
	path: pathOption = process$2.env[pathKey()],
	preferLocal = true,
	execPath = process$2.execPath,
	addExecPath = true,
} = {}) => {
	const cwdPath = path.resolve(toPath(cwd));
	const result = [];
	const pathParts = pathOption.split(path.delimiter);

	if (preferLocal) {
		applyPreferLocal(result, pathParts, cwdPath);
	}

	if (addExecPath) {
		applyExecPath(result, pathParts, execPath, cwdPath);
	}

	return pathOption === '' || pathOption === path.delimiter
		? `${result.join(path.delimiter)}${pathOption}`
		: [...result, pathOption].join(path.delimiter);
};

const applyPreferLocal = (result, pathParts, cwdPath) => {
	for (const directory of traversePathUp(cwdPath)) {
		const pathPart = path.join(directory, 'node_modules/.bin');
		if (!pathParts.includes(pathPart)) {
			result.push(pathPart);
		}
	}
};

// Ensure the running `node` binary is used
const applyExecPath = (result, pathParts, execPath, cwdPath) => {
	const pathPart = path.resolve(cwdPath, toPath(execPath), '..');
	if (!pathParts.includes(pathPart)) {
		result.push(pathPart);
	}
};

const npmRunPathEnv = ({env = process$2.env, ...options} = {}) => {
	env = {...env};

	const pathName = pathKey({env});
	options.path = env[pathName];
	env[pathName] = npmRunPath(options);

	return env;
};

// When the subprocess fails, this is the error instance being returned.
// If another error instance is being thrown, it is kept as `error.cause`.
const getFinalError = (originalError, message, isSync) => {
	const ErrorClass = isSync ? ExecaSyncError : ExecaError;
	const options = originalError instanceof DiscardedError ? {} : {cause: originalError};
	return new ErrorClass(message, options);
};

// Indicates that the error is used only to interrupt control flow, but not in the return value
class DiscardedError extends Error {}

// Proper way to set `error.name`: it should be inherited and non-enumerable
const setErrorName = (ErrorClass, value) => {
	Object.defineProperty(ErrorClass.prototype, 'name', {
		value,
		writable: true,
		enumerable: false,
		configurable: true,
	});
	Object.defineProperty(ErrorClass.prototype, execaErrorSymbol, {
		value: true,
		writable: false,
		enumerable: false,
		configurable: false,
	});
};

// Unlike `instanceof`, this works across realms
const isExecaError = error => isErrorInstance(error) && execaErrorSymbol in error;

const execaErrorSymbol = Symbol('isExecaError');

const isErrorInstance = value => Object.prototype.toString.call(value) === '[object Error]';

// We use two different Error classes for async/sync methods since they have slightly different shape and types
class ExecaError extends Error {}
setErrorName(ExecaError, ExecaError.name);

class ExecaSyncError extends Error {}
setErrorName(ExecaSyncError, ExecaSyncError.name);

const getRealtimeSignals=()=>{
const length=SIGRTMAX-SIGRTMIN+1;
return Array.from({length},getRealtimeSignal)
};

const getRealtimeSignal=(value,index)=>({
name:`SIGRT${index+1}`,
number:SIGRTMIN+index,
action:"terminate",
description:"Application-specific signal (realtime)",
standard:"posix"
});

const SIGRTMIN=34;
const SIGRTMAX=64;

const SIGNALS=[
{
name:"SIGHUP",
number:1,
action:"terminate",
description:"Terminal closed",
standard:"posix"
},
{
name:"SIGINT",
number:2,
action:"terminate",
description:"User interruption with CTRL-C",
standard:"ansi"
},
{
name:"SIGQUIT",
number:3,
action:"core",
description:"User interruption with CTRL-\\",
standard:"posix"
},
{
name:"SIGILL",
number:4,
action:"core",
description:"Invalid machine instruction",
standard:"ansi"
},
{
name:"SIGTRAP",
number:5,
action:"core",
description:"Debugger breakpoint",
standard:"posix"
},
{
name:"SIGABRT",
number:6,
action:"core",
description:"Aborted",
standard:"ansi"
},
{
name:"SIGIOT",
number:6,
action:"core",
description:"Aborted",
standard:"bsd"
},
{
name:"SIGBUS",
number:7,
action:"core",
description:
"Bus error due to misaligned, non-existing address or paging error",
standard:"bsd"
},
{
name:"SIGEMT",
number:7,
action:"terminate",
description:"Command should be emulated but is not implemented",
standard:"other"
},
{
name:"SIGFPE",
number:8,
action:"core",
description:"Floating point arithmetic error",
standard:"ansi"
},
{
name:"SIGKILL",
number:9,
action:"terminate",
description:"Forced termination",
standard:"posix",
forced:true
},
{
name:"SIGUSR1",
number:10,
action:"terminate",
description:"Application-specific signal",
standard:"posix"
},
{
name:"SIGSEGV",
number:11,
action:"core",
description:"Segmentation fault",
standard:"ansi"
},
{
name:"SIGUSR2",
number:12,
action:"terminate",
description:"Application-specific signal",
standard:"posix"
},
{
name:"SIGPIPE",
number:13,
action:"terminate",
description:"Broken pipe or socket",
standard:"posix"
},
{
name:"SIGALRM",
number:14,
action:"terminate",
description:"Timeout or timer",
standard:"posix"
},
{
name:"SIGTERM",
number:15,
action:"terminate",
description:"Termination",
standard:"ansi"
},
{
name:"SIGSTKFLT",
number:16,
action:"terminate",
description:"Stack is empty or overflowed",
standard:"other"
},
{
name:"SIGCHLD",
number:17,
action:"ignore",
description:"Child process terminated, paused or unpaused",
standard:"posix"
},
{
name:"SIGCLD",
number:17,
action:"ignore",
description:"Child process terminated, paused or unpaused",
standard:"other"
},
{
name:"SIGCONT",
number:18,
action:"unpause",
description:"Unpaused",
standard:"posix",
forced:true
},
{
name:"SIGSTOP",
number:19,
action:"pause",
description:"Paused",
standard:"posix",
forced:true
},
{
name:"SIGTSTP",
number:20,
action:"pause",
description:"Paused using CTRL-Z or \"suspend\"",
standard:"posix"
},
{
name:"SIGTTIN",
number:21,
action:"pause",
description:"Background process cannot read terminal input",
standard:"posix"
},
{
name:"SIGBREAK",
number:21,
action:"terminate",
description:"User interruption with CTRL-BREAK",
standard:"other"
},
{
name:"SIGTTOU",
number:22,
action:"pause",
description:"Background process cannot write to terminal output",
standard:"posix"
},
{
name:"SIGURG",
number:23,
action:"ignore",
description:"Socket received out-of-band data",
standard:"bsd"
},
{
name:"SIGXCPU",
number:24,
action:"core",
description:"Process timed out",
standard:"bsd"
},
{
name:"SIGXFSZ",
number:25,
action:"core",
description:"File too big",
standard:"bsd"
},
{
name:"SIGVTALRM",
number:26,
action:"terminate",
description:"Timeout or timer",
standard:"bsd"
},
{
name:"SIGPROF",
number:27,
action:"terminate",
description:"Timeout or timer",
standard:"bsd"
},
{
name:"SIGWINCH",
number:28,
action:"ignore",
description:"Terminal window size changed",
standard:"bsd"
},
{
name:"SIGIO",
number:29,
action:"terminate",
description:"I/O is available",
standard:"other"
},
{
name:"SIGPOLL",
number:29,
action:"terminate",
description:"Watched event",
standard:"other"
},
{
name:"SIGINFO",
number:29,
action:"ignore",
description:"Request for process information",
standard:"other"
},
{
name:"SIGPWR",
number:30,
action:"terminate",
description:"Device running out of power",
standard:"systemv"
},
{
name:"SIGSYS",
number:31,
action:"core",
description:"Invalid system call",
standard:"other"
},
{
name:"SIGUNUSED",
number:31,
action:"terminate",
description:"Invalid system call",
standard:"other"
}];

const getSignals=()=>{
const realtimeSignals=getRealtimeSignals();
const signals=[...SIGNALS,...realtimeSignals].map(normalizeSignal$1);
return signals
};







const normalizeSignal$1=({
name,
number:defaultNumber,
description,
action,
forced=false,
standard
})=>{
const{
signals:{[name]:constantSignal}
}=constants$7;
const supported=constantSignal!==undefined;
const number=supported?constantSignal:defaultNumber;
return {name,number,description,supported,action,forced,standard}
};

const getSignalsByName=()=>{
const signals=getSignals();
return Object.fromEntries(signals.map(getSignalByName))
};

const getSignalByName=({
name,
number,
description,
supported,
action,
forced,
standard
})=>[name,{name,number,description,supported,action,forced,standard}];

const signalsByName=getSignalsByName();




const getSignalsByNumber=()=>{
const signals=getSignals();
const length=SIGRTMAX+1;
const signalsA=Array.from({length},(value,number)=>
getSignalByNumber(number,signals)
);
return Object.assign({},...signalsA)
};

const getSignalByNumber=(number,signals)=>{
const signal=findSignalByNumber(number,signals);

if(signal===undefined){
return {}
}

const{name,description,supported,action,forced,standard}=signal;
return {
[number]:{
name,
number,
description,
supported,
action,
forced,
standard
}
}
};



const findSignalByNumber=(number,signals)=>{
const signal=signals.find(({name})=>constants$7.signals[name]===number);

if(signal!==undefined){
return signal
}

return signals.find((signalA)=>signalA.number===number)
};

getSignalsByNumber();

// Normalize signals for comparison purpose.
// Also validate the signal exists.
const normalizeKillSignal = killSignal => {
	const optionName = 'option `killSignal`';
	if (killSignal === 0) {
		throw new TypeError(`Invalid ${optionName}: 0 cannot be used.`);
	}

	return normalizeSignal(killSignal, optionName);
};

const normalizeSignalArgument = signal => signal === 0
	? signal
	: normalizeSignal(signal, '`subprocess.kill()`\'s argument');

const normalizeSignal = (signalNameOrInteger, optionName) => {
	if (Number.isInteger(signalNameOrInteger)) {
		return normalizeSignalInteger(signalNameOrInteger, optionName);
	}

	if (typeof signalNameOrInteger === 'string') {
		return normalizeSignalName(signalNameOrInteger, optionName);
	}

	throw new TypeError(`Invalid ${optionName} ${String(signalNameOrInteger)}: it must be a string or an integer.\n${getAvailableSignals()}`);
};

const normalizeSignalInteger = (signalInteger, optionName) => {
	if (signalsIntegerToName.has(signalInteger)) {
		return signalsIntegerToName.get(signalInteger);
	}

	throw new TypeError(`Invalid ${optionName} ${signalInteger}: this signal integer does not exist.\n${getAvailableSignals()}`);
};

const getSignalsIntegerToName = () => new Map(Object.entries(constants$7.signals)
	.reverse()
	.map(([signalName, signalInteger]) => [signalInteger, signalName]));

const signalsIntegerToName = getSignalsIntegerToName();

const normalizeSignalName = (signalName, optionName) => {
	if (signalName in constants$7.signals) {
		return signalName;
	}

	if (signalName.toUpperCase() in constants$7.signals) {
		throw new TypeError(`Invalid ${optionName} '${signalName}': please rename it to '${signalName.toUpperCase()}'.`);
	}

	throw new TypeError(`Invalid ${optionName} '${signalName}': this signal name does not exist.\n${getAvailableSignals()}`);
};

const getAvailableSignals = () => `Available signal names: ${getAvailableSignalNames()}.
Available signal numbers: ${getAvailableSignalIntegers()}.`;

const getAvailableSignalNames = () => Object.keys(constants$7.signals)
	.sort()
	.map(signalName => `'${signalName}'`)
	.join(', ');

const getAvailableSignalIntegers = () => [...new Set(Object.values(constants$7.signals)
	.sort((signalInteger, signalIntegerTwo) => signalInteger - signalIntegerTwo))]
	.join(', ');

// Human-friendly description of a signal
const getSignalDescription = signal => signalsByName[signal].description;

// Normalize the `forceKillAfterDelay` option
const normalizeForceKillAfterDelay = forceKillAfterDelay => {
	if (forceKillAfterDelay === false) {
		return forceKillAfterDelay;
	}

	if (forceKillAfterDelay === true) {
		return DEFAULT_FORCE_KILL_TIMEOUT;
	}

	if (!Number.isFinite(forceKillAfterDelay) || forceKillAfterDelay < 0) {
		throw new TypeError(`Expected the \`forceKillAfterDelay\` option to be a non-negative integer, got \`${forceKillAfterDelay}\` (${typeof forceKillAfterDelay})`);
	}

	return forceKillAfterDelay;
};

const DEFAULT_FORCE_KILL_TIMEOUT = 1000 * 5;

// Monkey-patches `subprocess.kill()` to add `forceKillAfterDelay` behavior and `.kill(error)`
const subprocessKill = (
	{kill, options: {forceKillAfterDelay, killSignal}, onInternalError, context, controller},
	signalOrError,
	errorArgument,
) => {
	const {signal, error} = parseKillArguments(signalOrError, errorArgument, killSignal);
	emitKillError(error, onInternalError);
	const killResult = kill(signal);
	setKillTimeout({
		kill,
		signal,
		forceKillAfterDelay,
		killSignal,
		killResult,
		context,
		controller,
	});
	return killResult;
};

const parseKillArguments = (signalOrError, errorArgument, killSignal) => {
	const [signal = killSignal, error] = isErrorInstance(signalOrError)
		? [undefined, signalOrError]
		: [signalOrError, errorArgument];

	if (typeof signal !== 'string' && !Number.isInteger(signal)) {
		throw new TypeError(`The first argument must be an error instance or a signal name string/integer: ${String(signal)}`);
	}

	if (error !== undefined && !isErrorInstance(error)) {
		throw new TypeError(`The second argument is optional. If specified, it must be an error instance: ${error}`);
	}

	return {signal: normalizeSignalArgument(signal), error};
};

// Fails right away when calling `subprocess.kill(error)`.
// Does not wait for actual signal termination.
// Uses a deferred promise instead of the `error` event on the subprocess, as this is less intrusive.
const emitKillError = (error, onInternalError) => {
	if (error !== undefined) {
		onInternalError.reject(error);
	}
};

const setKillTimeout = async ({kill, signal, forceKillAfterDelay, killSignal, killResult, context, controller}) => {
	if (signal === killSignal && killResult) {
		killOnTimeout({
			kill,
			forceKillAfterDelay,
			context,
			controllerSignal: controller.signal,
		});
	}
};

// Forcefully terminate a subprocess after a timeout
const killOnTimeout = async ({kill, forceKillAfterDelay, context, controllerSignal}) => {
	if (forceKillAfterDelay === false) {
		return;
	}

	try {
		await setTimeout$1(forceKillAfterDelay, undefined, {signal: controllerSignal});
		if (kill('SIGKILL')) {
			context.isForcefullyTerminated ??= true;
		}
	} catch {}
};

// Combines `util.aborted()` and `events.addAbortListener()`: promise-based and cleaned up with a stop signal
const onAbortedSignal = async (mainSignal, stopSignal) => {
	if (!mainSignal.aborted) {
		await once(mainSignal, 'abort', {signal: stopSignal});
	}
};

// Validate the `cancelSignal` option
const validateCancelSignal = ({cancelSignal}) => {
	if (cancelSignal !== undefined && Object.prototype.toString.call(cancelSignal) !== '[object AbortSignal]') {
		throw new Error(`The \`cancelSignal\` option must be an AbortSignal: ${String(cancelSignal)}`);
	}
};

// Terminate the subprocess when aborting the `cancelSignal` option and `gracefulSignal` is `false`
const throwOnCancel = ({subprocess, cancelSignal, gracefulCancel, context, controller}) => cancelSignal === undefined || gracefulCancel
	? []
	: [terminateOnCancel(subprocess, cancelSignal, context, controller)];

const terminateOnCancel = async (subprocess, cancelSignal, context, {signal}) => {
	await onAbortedSignal(cancelSignal, signal);
	context.terminationReason ??= 'cancel';
	subprocess.kill();
	throw cancelSignal.reason;
};

// Validate the IPC channel is connected before receiving/sending messages
const validateIpcMethod = ({methodName, isSubprocess, ipc, isConnected}) => {
	validateIpcOption(methodName, isSubprocess, ipc);
	validateConnection(methodName, isSubprocess, isConnected);
};

// Better error message when forgetting to set `ipc: true` and using the IPC methods
const validateIpcOption = (methodName, isSubprocess, ipc) => {
	if (!ipc) {
		throw new Error(`${getMethodName(methodName, isSubprocess)} can only be used if the \`ipc\` option is \`true\`.`);
	}
};

// Better error message when one process does not send/receive messages once the other process has disconnected.
// This also makes it clear that any buffered messages are lost once either process has disconnected.
// Also when aborting `cancelSignal` after disconnecting the IPC.
const validateConnection = (methodName, isSubprocess, isConnected) => {
	if (!isConnected) {
		throw new Error(`${getMethodName(methodName, isSubprocess)} cannot be used: the ${getOtherProcessName(isSubprocess)} has already exited or disconnected.`);
	}
};

// When `getOneMessage()` could not complete due to an early disconnection
const throwOnEarlyDisconnect = isSubprocess => {
	throw new Error(`${getMethodName('getOneMessage', isSubprocess)} could not complete: the ${getOtherProcessName(isSubprocess)} exited or disconnected.`);
};

// When both processes use `sendMessage()` with `strict` at the same time
const throwOnStrictDeadlockError = isSubprocess => {
	throw new Error(`${getMethodName('sendMessage', isSubprocess)} failed: the ${getOtherProcessName(isSubprocess)} is sending a message too, instead of listening to incoming messages.
This can be fixed by both sending a message and listening to incoming messages at the same time:

const [receivedMessage] = await Promise.all([
	${getMethodName('getOneMessage', isSubprocess)},
	${getMethodName('sendMessage', isSubprocess, 'message, {strict: true}')},
]);`);
};

// When the other process used `strict` but the current process had I/O error calling `sendMessage()` for the response
const getStrictResponseError = (error, isSubprocess) => new Error(`${getMethodName('sendMessage', isSubprocess)} failed when sending an acknowledgment response to the ${getOtherProcessName(isSubprocess)}.`, {cause: error});

// When using `strict` but the other process was not listening for messages
const throwOnMissingStrict = isSubprocess => {
	throw new Error(`${getMethodName('sendMessage', isSubprocess)} failed: the ${getOtherProcessName(isSubprocess)} is not listening to incoming messages.`);
};

// When using `strict` but the other process disconnected before receiving the message
const throwOnStrictDisconnect = isSubprocess => {
	throw new Error(`${getMethodName('sendMessage', isSubprocess)} failed: the ${getOtherProcessName(isSubprocess)} exited without listening to incoming messages.`);
};

// When the current process disconnects while the subprocess is listening to `cancelSignal`
const getAbortDisconnectError = () => new Error(`\`cancelSignal\` aborted: the ${getOtherProcessName(true)} disconnected.`);

// When the subprocess uses `cancelSignal` but not the current process
const throwOnMissingParent = () => {
	throw new Error('`getCancelSignal()` cannot be used without setting the `cancelSignal` subprocess option.');
};

// EPIPE can happen when sending a message to a subprocess that is closing but has not disconnected yet
const handleEpipeError = ({error, methodName, isSubprocess}) => {
	if (error.code === 'EPIPE') {
		throw new Error(`${getMethodName(methodName, isSubprocess)} cannot be used: the ${getOtherProcessName(isSubprocess)} is disconnecting.`, {cause: error});
	}
};

// Better error message when sending messages which cannot be serialized.
// Works with both `serialization: 'advanced'` and `serialization: 'json'`.
const handleSerializationError = ({error, methodName, isSubprocess, message}) => {
	if (isSerializationError(error)) {
		throw new Error(`${getMethodName(methodName, isSubprocess)}'s argument type is invalid: the message cannot be serialized: ${String(message)}.`, {cause: error});
	}
};

const isSerializationError = ({code, message}) => SERIALIZATION_ERROR_CODES.has(code)
	|| SERIALIZATION_ERROR_MESSAGES.some(serializationErrorMessage => message.includes(serializationErrorMessage));

// `error.code` set by Node.js when it failed to serialize the message
const SERIALIZATION_ERROR_CODES = new Set([
	// Message is `undefined`
	'ERR_MISSING_ARGS',
	// Message is a function, a bigint, a symbol
	'ERR_INVALID_ARG_TYPE',
]);

// `error.message` set by Node.js when it failed to serialize the message
const SERIALIZATION_ERROR_MESSAGES = [
	// Message is a promise or a proxy, with `serialization: 'advanced'`
	'could not be cloned',
	// Message has cycles, with `serialization: 'json'`
	'circular structure',
	// Message has cycles inside toJSON(), with `serialization: 'json'`
	'call stack size exceeded',
];

const getMethodName = (methodName, isSubprocess, parameters = '') => methodName === 'cancelSignal'
	? '`cancelSignal`\'s `controller.abort()`'
	: `${getNamespaceName(isSubprocess)}${methodName}(${parameters})`;

const getNamespaceName = isSubprocess => isSubprocess ? '' : 'subprocess.';

const getOtherProcessName = isSubprocess => isSubprocess ? 'parent process' : 'subprocess';

// When any error arises, we disconnect the IPC.
// Otherwise, it is likely that one of the processes will stop sending/receiving messages.
// This would leave the other process hanging.
const disconnect = anyProcess => {
	if (anyProcess.connected) {
		anyProcess.disconnect();
	}
};

const createDeferred = () => {
	const methods = {};
	const promise = new Promise((resolve, reject) => {
		Object.assign(methods, {resolve, reject});
	});
	return Object.assign(promise, methods);
};

// Retrieve stream targeted by the `to` option
const getToStream = (destination, to = 'stdin') => {
	const isWritable = true;
	const {options, fileDescriptors} = SUBPROCESS_OPTIONS.get(destination);
	const fdNumber = getFdNumber(fileDescriptors, to, isWritable);
	const destinationStream = destination.stdio[fdNumber];

	if (destinationStream === null) {
		throw new TypeError(getInvalidStdioOptionMessage(fdNumber, to, options, isWritable));
	}

	return destinationStream;
};

// Retrieve stream targeted by the `from` option
const getFromStream = (source, from = 'stdout') => {
	const isWritable = false;
	const {options, fileDescriptors} = SUBPROCESS_OPTIONS.get(source);
	const fdNumber = getFdNumber(fileDescriptors, from, isWritable);
	const sourceStream = fdNumber === 'all' ? source.all : source.stdio[fdNumber];

	if (sourceStream === null || sourceStream === undefined) {
		throw new TypeError(getInvalidStdioOptionMessage(fdNumber, from, options, isWritable));
	}

	return sourceStream;
};

// Keeps track of the options passed to each Execa call
const SUBPROCESS_OPTIONS = new WeakMap();

const getFdNumber = (fileDescriptors, fdName, isWritable) => {
	const fdNumber = parseFdNumber(fdName, isWritable);
	validateFdNumber(fdNumber, fdName, isWritable, fileDescriptors);
	return fdNumber;
};

const parseFdNumber = (fdName, isWritable) => {
	const fdNumber = parseFd(fdName);
	if (fdNumber !== undefined) {
		return fdNumber;
	}

	const {validOptions, defaultValue} = isWritable
		? {validOptions: '"stdin"', defaultValue: 'stdin'}
		: {validOptions: '"stdout", "stderr", "all"', defaultValue: 'stdout'};
	throw new TypeError(`"${getOptionName(isWritable)}" must not be "${fdName}".
It must be ${validOptions} or "fd3", "fd4" (and so on).
It is optional and defaults to "${defaultValue}".`);
};

const validateFdNumber = (fdNumber, fdName, isWritable, fileDescriptors) => {
	const fileDescriptor = fileDescriptors[getUsedDescriptor(fdNumber)];
	if (fileDescriptor === undefined) {
		throw new TypeError(`"${getOptionName(isWritable)}" must not be ${fdName}. That file descriptor does not exist.
Please set the "stdio" option to ensure that file descriptor exists.`);
	}

	if (fileDescriptor.direction === 'input' && !isWritable) {
		throw new TypeError(`"${getOptionName(isWritable)}" must not be ${fdName}. It must be a readable stream, not writable.`);
	}

	if (fileDescriptor.direction !== 'input' && isWritable) {
		throw new TypeError(`"${getOptionName(isWritable)}" must not be ${fdName}. It must be a writable stream, not readable.`);
	}
};

const getInvalidStdioOptionMessage = (fdNumber, fdName, options, isWritable) => {
	if (fdNumber === 'all' && !options.all) {
		return 'The "all" option must be true to use "from: \'all\'".';
	}

	const {optionName, optionValue} = getInvalidStdioOption(fdNumber, options);
	return `The "${optionName}: ${serializeOptionValue(optionValue)}" option is incompatible with using "${getOptionName(isWritable)}: ${serializeOptionValue(fdName)}".
Please set this option with "pipe" instead.`;
};

const getInvalidStdioOption = (fdNumber, {stdin, stdout, stderr, stdio}) => {
	const usedDescriptor = getUsedDescriptor(fdNumber);

	if (usedDescriptor === 0 && stdin !== undefined) {
		return {optionName: 'stdin', optionValue: stdin};
	}

	if (usedDescriptor === 1 && stdout !== undefined) {
		return {optionName: 'stdout', optionValue: stdout};
	}

	if (usedDescriptor === 2 && stderr !== undefined) {
		return {optionName: 'stderr', optionValue: stderr};
	}

	return {optionName: `stdio[${usedDescriptor}]`, optionValue: stdio[usedDescriptor]};
};

const getUsedDescriptor = fdNumber => fdNumber === 'all' ? 1 : fdNumber;

const getOptionName = isWritable => isWritable ? 'to' : 'from';

const serializeOptionValue = value => {
	if (typeof value === 'string') {
		return `'${value}'`;
	}

	return typeof value === 'number' ? `${value}` : 'Stream';
};

// Temporarily increase the maximum number of listeners on an eventEmitter
const incrementMaxListeners = (eventEmitter, maxListenersIncrement, signal) => {
	const maxListeners = eventEmitter.getMaxListeners();
	if (maxListeners === 0 || maxListeners === Number.POSITIVE_INFINITY) {
		return;
	}

	eventEmitter.setMaxListeners(maxListeners + maxListenersIncrement);
	addAbortListener(signal, () => {
		eventEmitter.setMaxListeners(eventEmitter.getMaxListeners() - maxListenersIncrement);
	});
};

// By default, Node.js keeps the subprocess alive while it has a `message` or `disconnect` listener.
// We replicate the same logic for the events that we proxy.
// This ensures the subprocess is kept alive while `getOneMessage()` and `getEachMessage()` are ongoing.
// This is not a problem with `sendMessage()` since Node.js handles that method automatically.
// We do not use `anyProcess.channel.ref()` since this would prevent the automatic `.channel.refCounted()` Node.js is doing.
// We keep a reference to `anyProcess.channel` since it might be `null` while `getOneMessage()` or `getEachMessage()` is still processing debounced messages.
// See https://github.com/nodejs/node/blob/2aaeaa863c35befa2ebaa98fb7737ec84df4d8e9/lib/internal/child_process.js#L547
const addReference = (channel, reference) => {
	if (reference) {
		addReferenceCount(channel);
	}
};

const addReferenceCount = channel => {
	channel.refCounted();
};

const removeReference = (channel, reference) => {
	if (reference) {
		removeReferenceCount(channel);
	}
};

const removeReferenceCount = channel => {
	channel.unrefCounted();
};

// To proxy events, we setup some global listeners on the `message` and `disconnect` events.
// Those should not keep the subprocess alive, so we remove the automatic counting that Node.js is doing.
// See https://github.com/nodejs/node/blob/1b965270a9c273d4cf70e8808e9d28b9ada7844f/lib/child_process.js#L180
const undoAddedReferences = (channel, isSubprocess) => {
	if (isSubprocess) {
		removeReferenceCount(channel);
		removeReferenceCount(channel);
	}
};

// Reverse it during `disconnect`
const redoAddedReferences = (channel, isSubprocess) => {
	if (isSubprocess) {
		addReferenceCount(channel);
		addReferenceCount(channel);
	}
};

// By default, Node.js buffers `message` events.
//  - Buffering happens when there is a `message` event is emitted but there is no handler.
//  - As soon as a `message` event handler is set, all buffered `message` events are emitted, emptying the buffer.
//  - This happens both in the current process and the subprocess.
//  - See https://github.com/nodejs/node/blob/501546e8f37059cd577041e23941b640d0d4d406/lib/internal/child_process.js#L719
// This is helpful. Notably, this allows sending messages to a subprocess that's still initializing.
// However, it has several problems.
//  - This works with `events.on()` but not `events.once()` since all buffered messages are emitted at once.
//    For example, users cannot call `await getOneMessage()`/`getEachMessage()` multiple times in a row.
//  - When a user intentionally starts listening to `message` at a specific point in time, past `message` events are replayed, which might be unexpected.
//  - Buffering is unlimited, which might lead to an out-of-memory crash.
//  - This does not work well with multiple consumers.
//    For example, Execa consumes events with both `result.ipcOutput` and manual IPC calls like `getOneMessage()`.
//    Since `result.ipcOutput` reads all incoming messages, no buffering happens for manual IPC calls.
//  - Forgetting to setup a `message` listener, or setting it up too late, is a programming mistake.
//    The default behavior does not allow users to realize they made that mistake.
// To solve those problems, instead of buffering messages, we debounce them.
// The `message` event so it is emitted at most once per macrotask.
const onMessage = async ({anyProcess, channel, isSubprocess, ipcEmitter}, wrappedMessage) => {
	if (handleStrictResponse(wrappedMessage) || handleAbort(wrappedMessage)) {
		return;
	}

	if (!INCOMING_MESSAGES.has(anyProcess)) {
		INCOMING_MESSAGES.set(anyProcess, []);
	}

	const incomingMessages = INCOMING_MESSAGES.get(anyProcess);
	incomingMessages.push(wrappedMessage);

	if (incomingMessages.length > 1) {
		return;
	}

	while (incomingMessages.length > 0) {
		// eslint-disable-next-line no-await-in-loop
		await waitForOutgoingMessages(anyProcess, ipcEmitter, wrappedMessage);
		// eslint-disable-next-line no-await-in-loop
		await scheduler.yield();

		// eslint-disable-next-line no-await-in-loop
		const message = await handleStrictRequest({
			wrappedMessage: incomingMessages[0],
			anyProcess,
			channel,
			isSubprocess,
			ipcEmitter,
		});

		incomingMessages.shift();
		ipcEmitter.emit('message', message);
		ipcEmitter.emit('message:done');
	}
};

// If the `message` event is currently debounced, the `disconnect` event must wait for it
const onDisconnect = async ({anyProcess, channel, isSubprocess, ipcEmitter, boundOnMessage}) => {
	abortOnDisconnect();

	const incomingMessages = INCOMING_MESSAGES.get(anyProcess);
	while (incomingMessages?.length > 0) {
		// eslint-disable-next-line no-await-in-loop
		await once(ipcEmitter, 'message:done');
	}

	anyProcess.removeListener('message', boundOnMessage);
	redoAddedReferences(channel, isSubprocess);
	ipcEmitter.connected = false;
	ipcEmitter.emit('disconnect');
};

const INCOMING_MESSAGES = new WeakMap();

// Forward the `message` and `disconnect` events from the process and subprocess to a proxy emitter.
// This prevents the `error` event from stopping IPC.
// This also allows debouncing the `message` event.
const getIpcEmitter = (anyProcess, channel, isSubprocess) => {
	if (IPC_EMITTERS.has(anyProcess)) {
		return IPC_EMITTERS.get(anyProcess);
	}

	// Use an `EventEmitter`, like the `process` that is being proxied
	// eslint-disable-next-line unicorn/prefer-event-target
	const ipcEmitter = new EventEmitter$1();
	ipcEmitter.connected = true;
	IPC_EMITTERS.set(anyProcess, ipcEmitter);
	forwardEvents({
		ipcEmitter,
		anyProcess,
		channel,
		isSubprocess,
	});
	return ipcEmitter;
};

const IPC_EMITTERS = new WeakMap();

// The `message` and `disconnect` events are buffered in the subprocess until the first listener is setup.
// However, unbuffering happens after one tick, so this give enough time for the caller to setup the listener on the proxy emitter first.
// See https://github.com/nodejs/node/blob/2aaeaa863c35befa2ebaa98fb7737ec84df4d8e9/lib/internal/child_process.js#L721
const forwardEvents = ({ipcEmitter, anyProcess, channel, isSubprocess}) => {
	const boundOnMessage = onMessage.bind(undefined, {
		anyProcess,
		channel,
		isSubprocess,
		ipcEmitter,
	});
	anyProcess.on('message', boundOnMessage);
	anyProcess.once('disconnect', onDisconnect.bind(undefined, {
		anyProcess,
		channel,
		isSubprocess,
		ipcEmitter,
		boundOnMessage,
	}));
	undoAddedReferences(channel, isSubprocess);
};

// Check whether there might still be some `message` events to receive
const isConnected = anyProcess => {
	const ipcEmitter = IPC_EMITTERS.get(anyProcess);
	return ipcEmitter === undefined
		? anyProcess.channel !== null
		: ipcEmitter.connected;
};

// When using the `strict` option, wrap the message with metadata during `sendMessage()`
const handleSendStrict = ({anyProcess, channel, isSubprocess, message, strict}) => {
	if (!strict) {
		return message;
	}

	const ipcEmitter = getIpcEmitter(anyProcess, channel, isSubprocess);
	const hasListeners = hasMessageListeners(anyProcess, ipcEmitter);
	return {
		id: count++,
		type: REQUEST_TYPE,
		message,
		hasListeners,
	};
};

let count = 0n;

// Handles when both processes are calling `sendMessage()` with `strict` at the same time.
// If neither process is listening, this would create a deadlock. We detect it and throw.
const validateStrictDeadlock = (outgoingMessages, wrappedMessage) => {
	if (wrappedMessage?.type !== REQUEST_TYPE || wrappedMessage.hasListeners) {
		return;
	}

	for (const {id} of outgoingMessages) {
		if (id !== undefined) {
			STRICT_RESPONSES[id].resolve({isDeadlock: true, hasListeners: false});
		}
	}
};

// The other process then sends the acknowledgment back as a response
const handleStrictRequest = async ({wrappedMessage, anyProcess, channel, isSubprocess, ipcEmitter}) => {
	if (wrappedMessage?.type !== REQUEST_TYPE || !anyProcess.connected) {
		return wrappedMessage;
	}

	const {id, message} = wrappedMessage;
	const response = {id, type: RESPONSE_TYPE, message: hasMessageListeners(anyProcess, ipcEmitter)};

	try {
		await sendMessage({
			anyProcess,
			channel,
			isSubprocess,
			ipc: true,
		}, response);
	} catch (error) {
		ipcEmitter.emit('strict:error', error);
	}

	return message;
};

// Reception of the acknowledgment response
const handleStrictResponse = wrappedMessage => {
	if (wrappedMessage?.type !== RESPONSE_TYPE) {
		return false;
	}

	const {id, message: hasListeners} = wrappedMessage;
	STRICT_RESPONSES[id]?.resolve({isDeadlock: false, hasListeners});
	return true;
};

// Wait for the other process to receive the message from `sendMessage()`
const waitForStrictResponse = async (wrappedMessage, anyProcess, isSubprocess) => {
	if (wrappedMessage?.type !== REQUEST_TYPE) {
		return;
	}

	const deferred = createDeferred();
	STRICT_RESPONSES[wrappedMessage.id] = deferred;
	const controller = new AbortController();

	try {
		const {isDeadlock, hasListeners} = await Promise.race([
			deferred,
			throwOnDisconnect$1(anyProcess, isSubprocess, controller),
		]);

		if (isDeadlock) {
			throwOnStrictDeadlockError(isSubprocess);
		}

		if (!hasListeners) {
			throwOnMissingStrict(isSubprocess);
		}
	} finally {
		controller.abort();
		delete STRICT_RESPONSES[wrappedMessage.id];
	}
};

const STRICT_RESPONSES = {};

const throwOnDisconnect$1 = async (anyProcess, isSubprocess, {signal}) => {
	incrementMaxListeners(anyProcess, 1, signal);
	await once(anyProcess, 'disconnect', {signal});
	throwOnStrictDisconnect(isSubprocess);
};

const REQUEST_TYPE = 'execa:ipc:request';
const RESPONSE_TYPE = 'execa:ipc:response';

// When `sendMessage()` is ongoing, any `message` being received waits before being emitted.
// This allows calling one or multiple `await sendMessage()` followed by `await getOneMessage()`/`await getEachMessage()`.
// Without running into a race condition when the other process sends a response too fast, before the current process set up a listener.
const startSendMessage = (anyProcess, wrappedMessage, strict) => {
	if (!OUTGOING_MESSAGES.has(anyProcess)) {
		OUTGOING_MESSAGES.set(anyProcess, new Set());
	}

	const outgoingMessages = OUTGOING_MESSAGES.get(anyProcess);
	const onMessageSent = createDeferred();
	const id = strict ? wrappedMessage.id : undefined;
	const outgoingMessage = {onMessageSent, id};
	outgoingMessages.add(outgoingMessage);
	return {outgoingMessages, outgoingMessage};
};

const endSendMessage = ({outgoingMessages, outgoingMessage}) => {
	outgoingMessages.delete(outgoingMessage);
	outgoingMessage.onMessageSent.resolve();
};

// Await while `sendMessage()` is ongoing, unless there is already a `message` listener
const waitForOutgoingMessages = async (anyProcess, ipcEmitter, wrappedMessage) => {
	while (!hasMessageListeners(anyProcess, ipcEmitter) && OUTGOING_MESSAGES.get(anyProcess)?.size > 0) {
		const outgoingMessages = [...OUTGOING_MESSAGES.get(anyProcess)];
		validateStrictDeadlock(outgoingMessages, wrappedMessage);
		// eslint-disable-next-line no-await-in-loop
		await Promise.all(outgoingMessages.map(({onMessageSent}) => onMessageSent));
	}
};

const OUTGOING_MESSAGES = new WeakMap();

// Whether any `message` listener is setup
const hasMessageListeners = (anyProcess, ipcEmitter) => ipcEmitter.listenerCount('message') > getMinListenerCount(anyProcess);

// When `buffer` is `false`, we set up a `message` listener that should be ignored.
// That listener is only meant to intercept `strict` acknowledgement responses.
const getMinListenerCount = anyProcess => SUBPROCESS_OPTIONS.has(anyProcess)
	&& !getFdSpecificValue(SUBPROCESS_OPTIONS.get(anyProcess).options.buffer, 'ipc')
	? 1
	: 0;

// Like `[sub]process.send()` but promise-based.
// We do not `await subprocess` during `.sendMessage()` nor `.getOneMessage()` since those methods are transient.
// Users would still need to `await subprocess` after the method is done.
// Also, this would prevent `unhandledRejection` event from being emitted, making it silent.
const sendMessage = ({anyProcess, channel, isSubprocess, ipc}, message, {strict = false} = {}) => {
	const methodName = 'sendMessage';
	validateIpcMethod({
		methodName,
		isSubprocess,
		ipc,
		isConnected: anyProcess.connected,
	});

	return sendMessageAsync({
		anyProcess,
		channel,
		methodName,
		isSubprocess,
		message,
		strict,
	});
};

const sendMessageAsync = async ({anyProcess, channel, methodName, isSubprocess, message, strict}) => {
	const wrappedMessage = handleSendStrict({
		anyProcess,
		channel,
		isSubprocess,
		message,
		strict,
	});
	const outgoingMessagesState = startSendMessage(anyProcess, wrappedMessage, strict);
	try {
		await sendOneMessage({
			anyProcess,
			methodName,
			isSubprocess,
			wrappedMessage,
			message,
		});
	} catch (error) {
		disconnect(anyProcess);
		throw error;
	} finally {
		endSendMessage(outgoingMessagesState);
	}
};

// Used internally by `cancelSignal`
const sendOneMessage = async ({anyProcess, methodName, isSubprocess, wrappedMessage, message}) => {
	const sendMethod = getSendMethod(anyProcess);

	try {
		await Promise.all([
			waitForStrictResponse(wrappedMessage, anyProcess, isSubprocess),
			sendMethod(wrappedMessage),
		]);
	} catch (error) {
		handleEpipeError({error, methodName, isSubprocess});
		handleSerializationError({
			error,
			methodName,
			isSubprocess,
			message,
		});
		throw error;
	}
};

// [sub]process.send() promisified, memoized
const getSendMethod = anyProcess => {
	if (PROCESS_SEND_METHODS.has(anyProcess)) {
		return PROCESS_SEND_METHODS.get(anyProcess);
	}

	const sendMethod = promisify(anyProcess.send.bind(anyProcess));
	PROCESS_SEND_METHODS.set(anyProcess, sendMethod);
	return sendMethod;
};

const PROCESS_SEND_METHODS = new WeakMap();

// Send an IPC message so the subprocess performs a graceful termination
const sendAbort = (subprocess, message) => {
	const methodName = 'cancelSignal';
	validateConnection(methodName, false, subprocess.connected);
	return sendOneMessage({
		anyProcess: subprocess,
		methodName,
		isSubprocess: false,
		wrappedMessage: {type: GRACEFUL_CANCEL_TYPE, message},
		message,
	});
};

// When the signal is being used, start listening for incoming messages.
// Unbuffering messages takes one microtask to complete, so this must be async.
const getCancelSignal = async ({anyProcess, channel, isSubprocess, ipc}) => {
	await startIpc({
		anyProcess,
		channel,
		isSubprocess,
		ipc,
	});
	return cancelController.signal;
};

const startIpc = async ({anyProcess, channel, isSubprocess, ipc}) => {
	if (cancelListening) {
		return;
	}

	cancelListening = true;

	if (!ipc) {
		throwOnMissingParent();
		return;
	}

	if (channel === null) {
		abortOnDisconnect();
		return;
	}

	getIpcEmitter(anyProcess, channel, isSubprocess);
	await scheduler.yield();
};

let cancelListening = false;

// Reception of IPC message to perform a graceful termination
const handleAbort = wrappedMessage => {
	if (wrappedMessage?.type !== GRACEFUL_CANCEL_TYPE) {
		return false;
	}

	cancelController.abort(wrappedMessage.message);
	return true;
};

const GRACEFUL_CANCEL_TYPE = 'execa:ipc:cancel';

// When the current process disconnects early, the subprocess `cancelSignal` is aborted.
// Otherwise, the signal would never be able to be aborted later on.
const abortOnDisconnect = () => {
	cancelController.abort(getAbortDisconnectError());
};

const cancelController = new AbortController();

// Validate the `gracefulCancel` option
const validateGracefulCancel = ({gracefulCancel, cancelSignal, ipc, serialization}) => {
	if (!gracefulCancel) {
		return;
	}

	if (cancelSignal === undefined) {
		throw new Error('The `cancelSignal` option must be defined when setting the `gracefulCancel` option.');
	}

	if (!ipc) {
		throw new Error('The `ipc` option cannot be false when setting the `gracefulCancel` option.');
	}

	if (serialization === 'json') {
		throw new Error('The `serialization` option cannot be \'json\' when setting the `gracefulCancel` option.');
	}
};

// Send abort reason to the subprocess when aborting the `cancelSignal` option and `gracefulCancel` is `true`
const throwOnGracefulCancel = ({
	subprocess,
	cancelSignal,
	gracefulCancel,
	forceKillAfterDelay,
	context,
	controller,
}) => gracefulCancel
	? [sendOnAbort({
		subprocess,
		cancelSignal,
		forceKillAfterDelay,
		context,
		controller,
	})]
	: [];

const sendOnAbort = async ({subprocess, cancelSignal, forceKillAfterDelay, context, controller: {signal}}) => {
	await onAbortedSignal(cancelSignal, signal);
	const reason = getReason(cancelSignal);
	await sendAbort(subprocess, reason);
	killOnTimeout({
		kill: subprocess.kill,
		forceKillAfterDelay,
		context,
		controllerSignal: signal,
	});
	context.terminationReason ??= 'gracefulCancel';
	throw cancelSignal.reason;
};

// The default `reason` is a DOMException, which is not serializable with V8
// See https://github.com/nodejs/node/issues/53225
const getReason = ({reason}) => {
	if (!(reason instanceof DOMException)) {
		return reason;
	}

	const error = new Error(reason.message);
	Object.defineProperty(error, 'stack', {
		value: reason.stack,
		enumerable: false,
		configurable: true,
		writable: true,
	});
	return error;
};

// Validate `timeout` option
const validateTimeout = ({timeout}) => {
	if (timeout !== undefined && (!Number.isFinite(timeout) || timeout < 0)) {
		throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${timeout}\` (${typeof timeout})`);
	}
};

// Fails when the `timeout` option is exceeded
const throwOnTimeout = (subprocess, timeout, context, controller) => timeout === 0 || timeout === undefined
	? []
	: [killAfterTimeout(subprocess, timeout, context, controller)];

const killAfterTimeout = async (subprocess, timeout, context, {signal}) => {
	await setTimeout$1(timeout, undefined, {signal});
	context.terminationReason ??= 'timeout';
	subprocess.kill();
	throw new DiscardedError();
};

// `execaNode()` is a shortcut for `execa(..., {node: true})`
const mapNode = ({options}) => {
	if (options.node === false) {
		throw new TypeError('The "node" option cannot be false with `execaNode()`.');
	}

	return {options: {...options, node: true}};
};

// Applies the `node: true` option, and the related `nodePath`/`nodeOptions` options.
// Modifies the file commands/arguments to ensure the same Node binary and flags are re-used.
// Also adds `ipc: true` and `shell: false`.
const handleNodeOption = (file, commandArguments, {
	node: shouldHandleNode = false,
	nodePath = execPath,
	nodeOptions = execArgv.filter(nodeOption => !nodeOption.startsWith('--inspect')),
	cwd,
	execPath: formerNodePath,
	...options
}) => {
	if (formerNodePath !== undefined) {
		throw new TypeError('The "execPath" option has been removed. Please use the "nodePath" option instead.');
	}

	const normalizedNodePath = safeNormalizeFileUrl(nodePath, 'The "nodePath" option');
	const resolvedNodePath = path.resolve(cwd, normalizedNodePath);
	const newOptions = {
		...options,
		nodePath: resolvedNodePath,
		node: shouldHandleNode,
		cwd,
	};

	if (!shouldHandleNode) {
		return [file, commandArguments, newOptions];
	}

	if (path.basename(file, '.exe') === 'node') {
		throw new TypeError('When the "node" option is true, the first argument does not need to be "node".');
	}

	return [
		resolvedNodePath,
		[...nodeOptions, file, ...commandArguments],
		{ipc: true, ...newOptions, shell: false},
	];
};

// Validate the `ipcInput` option
const validateIpcInputOption = ({ipcInput, ipc, serialization}) => {
	if (ipcInput === undefined) {
		return;
	}

	if (!ipc) {
		throw new Error('The `ipcInput` option cannot be set unless the `ipc` option is `true`.');
	}

	validateIpcInput[serialization](ipcInput);
};

const validateAdvancedInput = ipcInput => {
	try {
		serialize(ipcInput);
	} catch (error) {
		throw new Error('The `ipcInput` option is not serializable with a structured clone.', {cause: error});
	}
};

const validateJsonInput = ipcInput => {
	try {
		JSON.stringify(ipcInput);
	} catch (error) {
		throw new Error('The `ipcInput` option is not serializable with JSON.', {cause: error});
	}
};

const validateIpcInput = {
	advanced: validateAdvancedInput,
	json: validateJsonInput,
};

// When the `ipcInput` option is set, it is sent as an initial IPC message to the subprocess
const sendIpcInput = async (subprocess, ipcInput) => {
	if (ipcInput === undefined) {
		return;
	}

	await subprocess.sendMessage(ipcInput);
};

// Validate `encoding` option
const validateEncoding = ({encoding}) => {
	if (ENCODINGS.has(encoding)) {
		return;
	}

	const correctEncoding = getCorrectEncoding(encoding);
	if (correctEncoding !== undefined) {
		throw new TypeError(`Invalid option \`encoding: ${serializeEncoding(encoding)}\`.
Please rename it to ${serializeEncoding(correctEncoding)}.`);
	}

	const correctEncodings = [...ENCODINGS].map(correctEncoding => serializeEncoding(correctEncoding)).join(', ');
	throw new TypeError(`Invalid option \`encoding: ${serializeEncoding(encoding)}\`.
Please rename it to one of: ${correctEncodings}.`);
};

const TEXT_ENCODINGS = new Set(['utf8', 'utf16le']);
const BINARY_ENCODINGS = new Set(['buffer', 'hex', 'base64', 'base64url', 'latin1', 'ascii']);
const ENCODINGS = new Set([...TEXT_ENCODINGS, ...BINARY_ENCODINGS]);

const getCorrectEncoding = encoding => {
	if (encoding === null) {
		return 'buffer';
	}

	if (typeof encoding !== 'string') {
		return;
	}

	const lowerEncoding = encoding.toLowerCase();
	if (lowerEncoding in ENCODING_ALIASES) {
		return ENCODING_ALIASES[lowerEncoding];
	}

	if (ENCODINGS.has(lowerEncoding)) {
		return lowerEncoding;
	}
};

const ENCODING_ALIASES = {
	// eslint-disable-next-line unicorn/text-encoding-identifier-case
	'utf-8': 'utf8',
	'utf-16le': 'utf16le',
	'ucs-2': 'utf16le',
	ucs2: 'utf16le',
	binary: 'latin1',
};

const serializeEncoding = encoding => typeof encoding === 'string' ? `"${encoding}"` : String(encoding);

// Normalize `cwd` option
const normalizeCwd = (cwd = getDefaultCwd()) => {
	const cwdString = safeNormalizeFileUrl(cwd, 'The "cwd" option');
	return path.resolve(cwdString);
};

const getDefaultCwd = () => {
	try {
		return process$2.cwd();
	} catch (error) {
		error.message = `The current directory does not exist.\n${error.message}`;
		throw error;
	}
};

// When `cwd` option has an invalid value, provide with a better error message
const fixCwdError = (originalMessage, cwd) => {
	if (cwd === getDefaultCwd()) {
		return originalMessage;
	}

	let cwdStat;
	try {
		cwdStat = statSync(cwd);
	} catch (error) {
		return `The "cwd" option is invalid: ${cwd}.\n${error.message}\n${originalMessage}`;
	}

	if (!cwdStat.isDirectory()) {
		return `The "cwd" option is not a directory: ${cwd}.\n${originalMessage}`;
	}

	return originalMessage;
};

// Normalize the options object, and sometimes also the file paths and arguments.
// Applies default values, validate allowed options, normalize them.
const normalizeOptions = (filePath, rawArguments, rawOptions) => {
	rawOptions.cwd = normalizeCwd(rawOptions.cwd);
	const [processedFile, processedArguments, processedOptions] = handleNodeOption(filePath, rawArguments, rawOptions);

	const {command: file, args: commandArguments, options: initialOptions} = crossSpawn._parse(processedFile, processedArguments, processedOptions);

	const fdOptions = normalizeFdSpecificOptions(initialOptions);
	const options = addDefaultOptions(fdOptions);
	validateTimeout(options);
	validateEncoding(options);
	validateIpcInputOption(options);
	validateCancelSignal(options);
	validateGracefulCancel(options);
	options.shell = normalizeFileUrl(options.shell);
	options.env = getEnv(options);
	options.killSignal = normalizeKillSignal(options.killSignal);
	options.forceKillAfterDelay = normalizeForceKillAfterDelay(options.forceKillAfterDelay);
	options.lines = options.lines.map((lines, fdNumber) => lines && !BINARY_ENCODINGS.has(options.encoding) && options.buffer[fdNumber]);

	if (process$2.platform === 'win32' && path.basename(file, '.exe') === 'cmd') {
		// #116
		commandArguments.unshift('/q');
	}

	return {file, commandArguments, options};
};

const addDefaultOptions = ({
	extendEnv = true,
	preferLocal = false,
	cwd,
	localDir: localDirectory = cwd,
	encoding = 'utf8',
	reject = true,
	cleanup = true,
	all = false,
	windowsHide = true,
	killSignal = 'SIGTERM',
	forceKillAfterDelay = true,
	gracefulCancel = false,
	ipcInput,
	ipc = ipcInput !== undefined || gracefulCancel,
	serialization = 'advanced',
	...options
}) => ({
	...options,
	extendEnv,
	preferLocal,
	cwd,
	localDirectory,
	encoding,
	reject,
	cleanup,
	all,
	windowsHide,
	killSignal,
	forceKillAfterDelay,
	gracefulCancel,
	ipcInput,
	ipc,
	serialization,
});

const getEnv = ({env: envOption, extendEnv, preferLocal, node, localDirectory, nodePath}) => {
	const env = extendEnv ? {...process$2.env, ...envOption} : envOption;

	if (preferLocal || node) {
		return npmRunPathEnv({
			env,
			cwd: localDirectory,
			execPath: nodePath,
			preferLocal,
			addExecPath: node,
		});
	}

	return env;
};

// When the `shell` option is set, any command argument is concatenated as a single string by Node.js:
// https://github.com/nodejs/node/blob/e38ce27f3ca0a65f68a31cedd984cddb927d4002/lib/child_process.js#L614-L624
// However, since Node 24, it also prints a deprecation warning.
// To avoid this warning, we perform that same operation before calling `node:child_process`.
// Shells only understand strings, which is why Node.js performs that concatenation.
// However, we rely on users splitting command arguments as an array.
// For example, this allows us to easily detect which arguments are passed.
// So we do want users to pass array of arguments even with `shell: true`, but we also want to avoid any warning.
const concatenateShell = (file, commandArguments, options) => options.shell && commandArguments.length > 0
	? [[file, ...commandArguments].join(' '), [], options]
	: [file, commandArguments, options];

function stripFinalNewline(input) {
	if (typeof input === 'string') {
		return stripFinalNewlineString(input);
	}

	if (!(ArrayBuffer.isView(input) && input.BYTES_PER_ELEMENT === 1)) {
		throw new Error('Input must be a string or a Uint8Array');
	}

	return stripFinalNewlineBinary(input);
}

const stripFinalNewlineString = input =>
	input.at(-1) === LF
		? input.slice(0, input.at(-2) === CR ? -2 : -1)
		: input;

const stripFinalNewlineBinary = input =>
	input.at(-1) === LF_BINARY
		? input.subarray(0, input.at(-2) === CR_BINARY ? -2 : -1)
		: input;

const LF = '\n';
const LF_BINARY = LF.codePointAt(0);
const CR = '\r';
const CR_BINARY = CR.codePointAt(0);

function isStream(stream, {checkOpen = true} = {}) {
	return stream !== null
		&& typeof stream === 'object'
		&& (stream.writable || stream.readable || !checkOpen || (stream.writable === undefined && stream.readable === undefined))
		&& typeof stream.pipe === 'function';
}

function isWritableStream$1(stream, {checkOpen = true} = {}) {
	return isStream(stream, {checkOpen})
		&& (stream.writable || !checkOpen)
		&& typeof stream.write === 'function'
		&& typeof stream.end === 'function'
		&& typeof stream.writable === 'boolean'
		&& typeof stream.writableObjectMode === 'boolean'
		&& typeof stream.destroy === 'function'
		&& typeof stream.destroyed === 'boolean';
}

function isReadableStream$1(stream, {checkOpen = true} = {}) {
	return isStream(stream, {checkOpen})
		&& (stream.readable || !checkOpen)
		&& typeof stream.read === 'function'
		&& typeof stream.readable === 'boolean'
		&& typeof stream.readableObjectMode === 'boolean'
		&& typeof stream.destroy === 'function'
		&& typeof stream.destroyed === 'boolean';
}

function isDuplexStream(stream, options) {
	return isWritableStream$1(stream, options)
		&& isReadableStream$1(stream, options);
}

const a = Object.getPrototypeOf(
  Object.getPrototypeOf(
    /* istanbul ignore next */
    async function* () {
    }
  ).prototype
);
class c {
  #t;
  #n;
  #r = false;
  #e = void 0;
  constructor(e, t) {
    this.#t = e, this.#n = t;
  }
  next() {
    const e = () => this.#s();
    return this.#e = this.#e ? this.#e.then(e, e) : e(), this.#e;
  }
  return(e) {
    const t = () => this.#i(e);
    return this.#e ? this.#e.then(t, t) : t();
  }
  async #s() {
    if (this.#r)
      return {
        done: true,
        value: void 0
      };
    let e;
    try {
      e = await this.#t.read();
    } catch (t) {
      throw this.#e = void 0, this.#r = true, this.#t.releaseLock(), t;
    }
    return e.done && (this.#e = void 0, this.#r = true, this.#t.releaseLock()), e;
  }
  async #i(e) {
    if (this.#r)
      return {
        done: true,
        value: e
      };
    if (this.#r = true, !this.#n) {
      const t = this.#t.cancel(e);
      return this.#t.releaseLock(), await t, {
        done: true,
        value: e
      };
    }
    return this.#t.releaseLock(), {
      done: true,
      value: e
    };
  }
}
const n = Symbol();
function i() {
  return this[n].next();
}
Object.defineProperty(i, "name", { value: "next" });
function o(r) {
  return this[n].return(r);
}
Object.defineProperty(o, "name", { value: "return" });
const u = Object.create(a, {
  next: {
    enumerable: true,
    configurable: true,
    writable: true,
    value: i
  },
  return: {
    enumerable: true,
    configurable: true,
    writable: true,
    value: o
  }
});
function h({ preventCancel: r = false } = {}) {
  const e = this.getReader(), t = new c(
    e,
    r
  ), s = Object.create(u);
  return s[n] = t, s;
}

const getAsyncIterable = stream => {
	if (isReadableStream$1(stream, {checkOpen: false}) && nodeImports.on !== undefined) {
		return getStreamIterable(stream);
	}

	if (typeof stream?.[Symbol.asyncIterator] === 'function') {
		return stream;
	}

	// `ReadableStream[Symbol.asyncIterator]` support is missing in multiple browsers, so we ponyfill it
	if (toString.call(stream) === '[object ReadableStream]') {
		return h.call(stream);
	}

	throw new TypeError('The first argument must be a Readable, a ReadableStream, or an async iterable.');
};

const {toString} = Object.prototype;

// The default iterable for Node.js streams does not allow for multiple readers at once, so we re-implement it
const getStreamIterable = async function * (stream) {
	const controller = new AbortController();
	const state = {};
	handleStreamEnd(stream, controller, state);

	try {
		for await (const [chunk] of nodeImports.on(stream, 'data', {signal: controller.signal})) {
			yield chunk;
		}
	} catch (error) {
		// Stream failure, for example due to `stream.destroy(error)`
		if (state.error !== undefined) {
			throw state.error;
		// `error` event directly emitted on stream
		} else if (!controller.signal.aborted) {
			throw error;
		// Otherwise, stream completed successfully
		}
		// The `finally` block also runs when the caller throws, for example due to the `maxBuffer` option
	} finally {
		stream.destroy();
	}
};

const handleStreamEnd = async (stream, controller, state) => {
	try {
		await nodeImports.finished(stream, {
			cleanup: true,
			readable: true,
			writable: false,
			error: false,
		});
	} catch (error) {
		state.error = error;
	} finally {
		controller.abort();
	}
};

// Loaded by the Node entrypoint, but not by the browser one.
// This prevents using dynamic imports.
const nodeImports = {};

const getStreamContents$1 = async (stream, {init, convertChunk, getSize, truncateChunk, addChunk, getFinalChunk, finalize}, {maxBuffer = Number.POSITIVE_INFINITY} = {}) => {
	const asyncIterable = getAsyncIterable(stream);

	const state = init();
	state.length = 0;

	try {
		for await (const chunk of asyncIterable) {
			const chunkType = getChunkType(chunk);
			const convertedChunk = convertChunk[chunkType](chunk, state);
			appendChunk({
				convertedChunk,
				state,
				getSize,
				truncateChunk,
				addChunk,
				maxBuffer,
			});
		}

		appendFinalChunk({
			state,
			convertChunk,
			getSize,
			truncateChunk,
			addChunk,
			getFinalChunk,
			maxBuffer,
		});
		return finalize(state);
	} catch (error) {
		const normalizedError = typeof error === 'object' && error !== null ? error : new Error(error);
		normalizedError.bufferedData = finalize(state);
		throw normalizedError;
	}
};

const appendFinalChunk = ({state, getSize, truncateChunk, addChunk, getFinalChunk, maxBuffer}) => {
	const convertedChunk = getFinalChunk(state);
	if (convertedChunk !== undefined) {
		appendChunk({
			convertedChunk,
			state,
			getSize,
			truncateChunk,
			addChunk,
			maxBuffer,
		});
	}
};

const appendChunk = ({convertedChunk, state, getSize, truncateChunk, addChunk, maxBuffer}) => {
	const chunkSize = getSize(convertedChunk);
	const newLength = state.length + chunkSize;

	if (newLength <= maxBuffer) {
		addNewChunk(convertedChunk, state, addChunk, newLength);
		return;
	}

	const truncatedChunk = truncateChunk(convertedChunk, maxBuffer - state.length);

	if (truncatedChunk !== undefined) {
		addNewChunk(truncatedChunk, state, addChunk, maxBuffer);
	}

	throw new MaxBufferError();
};

const addNewChunk = (convertedChunk, state, addChunk, newLength) => {
	state.contents = addChunk(convertedChunk, state, newLength);
	state.length = newLength;
};

const getChunkType = chunk => {
	const typeOfChunk = typeof chunk;

	if (typeOfChunk === 'string') {
		return 'string';
	}

	if (typeOfChunk !== 'object' || chunk === null) {
		return 'others';
	}

	if (globalThis.Buffer?.isBuffer(chunk)) {
		return 'buffer';
	}

	const prototypeName = objectToString.call(chunk);

	if (prototypeName === '[object ArrayBuffer]') {
		return 'arrayBuffer';
	}

	if (prototypeName === '[object DataView]') {
		return 'dataView';
	}

	if (
		Number.isInteger(chunk.byteLength)
		&& Number.isInteger(chunk.byteOffset)
		&& objectToString.call(chunk.buffer) === '[object ArrayBuffer]'
	) {
		return 'typedArray';
	}

	return 'others';
};

const {toString: objectToString} = Object.prototype;

class MaxBufferError extends Error {
	name = 'MaxBufferError';

	constructor() {
		super('maxBuffer exceeded');
	}
}

const identity = value => value;

const noop$1 = () => undefined;

const getContentsProperty = ({contents}) => contents;

const throwObjectStream = chunk => {
	throw new Error(`Streams in object mode are not supported: ${String(chunk)}`);
};

const getLengthProperty = convertedChunk => convertedChunk.length;

async function getStreamAsArray(stream, options) {
	return getStreamContents$1(stream, arrayMethods, options);
}

const initArray = () => ({contents: []});

const increment = () => 1;

const addArrayChunk = (convertedChunk, {contents}) => {
	contents.push(convertedChunk);
	return contents;
};

const arrayMethods = {
	init: initArray,
	convertChunk: {
		string: identity,
		buffer: identity,
		arrayBuffer: identity,
		dataView: identity,
		typedArray: identity,
		others: identity,
	},
	getSize: increment,
	truncateChunk: noop$1,
	addChunk: addArrayChunk,
	getFinalChunk: noop$1,
	finalize: getContentsProperty,
};

async function getStreamAsArrayBuffer(stream, options) {
	return getStreamContents$1(stream, arrayBufferMethods, options);
}

const initArrayBuffer = () => ({contents: new ArrayBuffer(0)});

const useTextEncoder = chunk => textEncoder.encode(chunk);
const textEncoder = new TextEncoder();

const useUint8Array = chunk => new Uint8Array(chunk);

const useUint8ArrayWithOffset = chunk => new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);

const truncateArrayBufferChunk = (convertedChunk, chunkSize) => convertedChunk.slice(0, chunkSize);

// `contents` is an increasingly growing `Uint8Array`.
const addArrayBufferChunk = (convertedChunk, {contents, length: previousLength}, length) => {
	const newContents = hasArrayBufferResize() ? resizeArrayBuffer(contents, length) : resizeArrayBufferSlow(contents, length);
	new Uint8Array(newContents).set(convertedChunk, previousLength);
	return newContents;
};

// Without `ArrayBuffer.resize()`, `contents` size is always a power of 2.
// This means its last bytes are zeroes (not stream data), which need to be
// trimmed at the end with `ArrayBuffer.slice()`.
const resizeArrayBufferSlow = (contents, length) => {
	if (length <= contents.byteLength) {
		return contents;
	}

	const arrayBuffer = new ArrayBuffer(getNewContentsLength(length));
	new Uint8Array(arrayBuffer).set(new Uint8Array(contents), 0);
	return arrayBuffer;
};

// With `ArrayBuffer.resize()`, `contents` size matches exactly the size of
// the stream data. It does not include extraneous zeroes to trim at the end.
// The underlying `ArrayBuffer` does allocate a number of bytes that is a power
// of 2, but those bytes are only visible after calling `ArrayBuffer.resize()`.
const resizeArrayBuffer = (contents, length) => {
	if (length <= contents.maxByteLength) {
		contents.resize(length);
		return contents;
	}

	const arrayBuffer = new ArrayBuffer(length, {maxByteLength: getNewContentsLength(length)});
	new Uint8Array(arrayBuffer).set(new Uint8Array(contents), 0);
	return arrayBuffer;
};

// Retrieve the closest `length` that is both >= and a power of 2
const getNewContentsLength = length => SCALE_FACTOR ** Math.ceil(Math.log(length) / Math.log(SCALE_FACTOR));

const SCALE_FACTOR = 2;

const finalizeArrayBuffer = ({contents, length}) => hasArrayBufferResize() ? contents : contents.slice(0, length);

// `ArrayBuffer.slice()` is slow. When `ArrayBuffer.resize()` is available
// (Node >=20.0.0, Safari >=16.4 and Chrome), we can use it instead.
// eslint-disable-next-line no-warning-comments
// TODO: remove after dropping support for Node 20.
// eslint-disable-next-line no-warning-comments
// TODO: use `ArrayBuffer.transferToFixedLength()` instead once it is available
const hasArrayBufferResize = () => 'resize' in ArrayBuffer.prototype;

const arrayBufferMethods = {
	init: initArrayBuffer,
	convertChunk: {
		string: useTextEncoder,
		buffer: useUint8Array,
		arrayBuffer: useUint8Array,
		dataView: useUint8ArrayWithOffset,
		typedArray: useUint8ArrayWithOffset,
		others: throwObjectStream,
	},
	getSize: getLengthProperty,
	truncateChunk: truncateArrayBufferChunk,
	addChunk: addArrayBufferChunk,
	getFinalChunk: noop$1,
	finalize: finalizeArrayBuffer,
};

async function getStreamAsString(stream, options) {
	return getStreamContents$1(stream, stringMethods, options);
}

const initString = () => ({contents: '', textDecoder: new TextDecoder()});

const useTextDecoder = (chunk, {textDecoder}) => textDecoder.decode(chunk, {stream: true});

const addStringChunk = (convertedChunk, {contents}) => contents + convertedChunk;

const truncateStringChunk = (convertedChunk, chunkSize) => convertedChunk.slice(0, chunkSize);

const getFinalStringChunk = ({textDecoder}) => {
	const finalChunk = textDecoder.decode();
	return finalChunk === '' ? undefined : finalChunk;
};

const stringMethods = {
	init: initString,
	convertChunk: {
		string: identity,
		buffer: useTextDecoder,
		arrayBuffer: useTextDecoder,
		dataView: useTextDecoder,
		typedArray: useTextDecoder,
		others: throwObjectStream,
	},
	getSize: getLengthProperty,
	truncateChunk: truncateStringChunk,
	addChunk: addStringChunk,
	getFinalChunk: getFinalStringChunk,
	finalize: getContentsProperty,
};

// When the `maxBuffer` option is hit, a MaxBufferError is thrown.
// The stream is aborted, then specific information is kept for the error message.
const handleMaxBuffer = ({error, stream, readableObjectMode, lines, encoding, fdNumber}) => {
	if (!(error instanceof MaxBufferError)) {
		throw error;
	}

	if (fdNumber === 'all') {
		return error;
	}

	const unit = getMaxBufferUnit(readableObjectMode, lines, encoding);
	error.maxBufferInfo = {fdNumber, unit};
	stream.destroy();
	throw error;
};

const getMaxBufferUnit = (readableObjectMode, lines, encoding) => {
	if (readableObjectMode) {
		return 'objects';
	}

	if (lines) {
		return 'lines';
	}

	if (encoding === 'buffer') {
		return 'bytes';
	}

	return 'characters';
};

// Check the `maxBuffer` option with `result.ipcOutput`
const checkIpcMaxBuffer = (subprocess, ipcOutput, maxBuffer) => {
	if (ipcOutput.length !== maxBuffer) {
		return;
	}

	const error = new MaxBufferError();
	error.maxBufferInfo = {fdNumber: 'ipc'};
	throw error;
};

// Error message when `maxBuffer` is hit
const getMaxBufferMessage = (error, maxBuffer) => {
	const {streamName, threshold, unit} = getMaxBufferInfo(error, maxBuffer);
	return `Command's ${streamName} was larger than ${threshold} ${unit}`;
};

const getMaxBufferInfo = (error, maxBuffer) => {
	if (error?.maxBufferInfo === undefined) {
		return {streamName: 'output', threshold: maxBuffer[1], unit: 'bytes'};
	}

	const {maxBufferInfo: {fdNumber, unit}} = error;
	delete error.maxBufferInfo;

	const threshold = getFdSpecificValue(maxBuffer, fdNumber);
	if (fdNumber === 'ipc') {
		return {streamName: 'IPC output', threshold, unit: 'messages'};
	}

	return {streamName: getStreamName(fdNumber), threshold, unit};
};

// The only way to apply `maxBuffer` with `spawnSync()` is to use the native `maxBuffer` option Node.js provides.
// However, this has multiple limitations, and cannot behave the exact same way as the async behavior.
// When the `maxBuffer` is hit, a `ENOBUFS` error is thrown.
const isMaxBufferSync = (resultError, output, maxBuffer) => resultError?.code === 'ENOBUFS'
	&& output !== null
	&& output.some(result => result !== null && result.length > getMaxBufferSync(maxBuffer));

// When `maxBuffer` is hit, ensure the result is truncated
const truncateMaxBufferSync = (result, isMaxBuffer, maxBuffer) => {
	if (!isMaxBuffer) {
		return result;
	}

	const maxBufferValue = getMaxBufferSync(maxBuffer);
	return result.length > maxBufferValue ? result.slice(0, maxBufferValue) : result;
};

// `spawnSync()` does not allow differentiating `maxBuffer` per file descriptor, so we always use `stdout`
const getMaxBufferSync = ([, stdoutMaxBuffer]) => stdoutMaxBuffer;

// Computes `error.message`, `error.shortMessage` and `error.originalMessage`
const createMessages = ({
	stdio,
	all,
	ipcOutput,
	originalError,
	signal,
	signalDescription,
	exitCode,
	escapedCommand,
	timedOut,
	isCanceled,
	isGracefullyCanceled,
	isMaxBuffer,
	isForcefullyTerminated,
	forceKillAfterDelay,
	killSignal,
	maxBuffer,
	timeout,
	cwd,
}) => {
	const errorCode = originalError?.code;
	const prefix = getErrorPrefix({
		originalError,
		timedOut,
		timeout,
		isMaxBuffer,
		maxBuffer,
		errorCode,
		signal,
		signalDescription,
		exitCode,
		isCanceled,
		isGracefullyCanceled,
		isForcefullyTerminated,
		forceKillAfterDelay,
		killSignal,
	});
	const originalMessage = getOriginalMessage(originalError, cwd);
	const suffix = originalMessage === undefined ? '' : `\n${originalMessage}`;
	const shortMessage = `${prefix}: ${escapedCommand}${suffix}`;
	const messageStdio = all === undefined ? [stdio[2], stdio[1]] : [all];
	const message = [
		shortMessage,
		...messageStdio,
		...stdio.slice(3),
		ipcOutput.map(ipcMessage => serializeIpcMessage(ipcMessage)).join('\n'),
	]
		.map(messagePart => escapeLines(stripFinalNewline(serializeMessagePart(messagePart))))
		.filter(Boolean)
		.join('\n\n');
	return {originalMessage, shortMessage, message};
};

const getErrorPrefix = ({
	originalError,
	timedOut,
	timeout,
	isMaxBuffer,
	maxBuffer,
	errorCode,
	signal,
	signalDescription,
	exitCode,
	isCanceled,
	isGracefullyCanceled,
	isForcefullyTerminated,
	forceKillAfterDelay,
	killSignal,
}) => {
	const forcefulSuffix = getForcefulSuffix(isForcefullyTerminated, forceKillAfterDelay);

	if (timedOut) {
		return `Command timed out after ${timeout} milliseconds${forcefulSuffix}`;
	}

	if (isGracefullyCanceled) {
		if (signal === undefined) {
			return `Command was gracefully canceled with exit code ${exitCode}`;
		}

		return isForcefullyTerminated
			? `Command was gracefully canceled${forcefulSuffix}`
			: `Command was gracefully canceled with ${signal} (${signalDescription})`;
	}

	if (isCanceled) {
		return `Command was canceled${forcefulSuffix}`;
	}

	if (isMaxBuffer) {
		return `${getMaxBufferMessage(originalError, maxBuffer)}${forcefulSuffix}`;
	}

	if (errorCode !== undefined) {
		return `Command failed with ${errorCode}${forcefulSuffix}`;
	}

	if (isForcefullyTerminated) {
		return `Command was killed with ${killSignal} (${getSignalDescription(killSignal)})${forcefulSuffix}`;
	}

	if (signal !== undefined) {
		return `Command was killed with ${signal} (${signalDescription})`;
	}

	if (exitCode !== undefined) {
		return `Command failed with exit code ${exitCode}`;
	}

	return 'Command failed';
};

const getForcefulSuffix = (isForcefullyTerminated, forceKillAfterDelay) => isForcefullyTerminated
	? ` and was forcefully terminated after ${forceKillAfterDelay} milliseconds`
	: '';

const getOriginalMessage = (originalError, cwd) => {
	if (originalError instanceof DiscardedError) {
		return;
	}

	const originalMessage = isExecaError(originalError)
		? originalError.originalMessage
		: String(originalError?.message ?? originalError);
	const escapedOriginalMessage = escapeLines(fixCwdError(originalMessage, cwd));
	return escapedOriginalMessage === '' ? undefined : escapedOriginalMessage;
};

const serializeIpcMessage = ipcMessage => typeof ipcMessage === 'string'
	? ipcMessage
	: inspect(ipcMessage);

const serializeMessagePart = messagePart => Array.isArray(messagePart)
	? messagePart.map(messageItem => stripFinalNewline(serializeMessageItem(messageItem))).filter(Boolean).join('\n')
	: serializeMessageItem(messagePart);

const serializeMessageItem = messageItem => {
	if (typeof messageItem === 'string') {
		return messageItem;
	}

	if (isUint8Array(messageItem)) {
		return uint8ArrayToString(messageItem);
	}

	return '';
};

// Object returned on subprocess success
const makeSuccessResult = ({
	command,
	escapedCommand,
	stdio,
	all,
	ipcOutput,
	options: {cwd},
	startTime,
}) => omitUndefinedProperties({
	command,
	escapedCommand,
	cwd,
	durationMs: getDurationMs(startTime),
	failed: false,
	timedOut: false,
	isCanceled: false,
	isGracefullyCanceled: false,
	isTerminated: false,
	isMaxBuffer: false,
	isForcefullyTerminated: false,
	exitCode: 0,
	stdout: stdio[1],
	stderr: stdio[2],
	all,
	stdio,
	ipcOutput,
	pipedFrom: [],
});

// Object returned on subprocess failure before spawning
const makeEarlyError = ({
	error,
	command,
	escapedCommand,
	fileDescriptors,
	options,
	startTime,
	isSync,
}) => makeError({
	error,
	command,
	escapedCommand,
	startTime,
	timedOut: false,
	isCanceled: false,
	isGracefullyCanceled: false,
	isMaxBuffer: false,
	isForcefullyTerminated: false,
	stdio: Array.from({length: fileDescriptors.length}),
	ipcOutput: [],
	options,
	isSync,
});

// Object returned on subprocess failure
const makeError = ({
	error: originalError,
	command,
	escapedCommand,
	startTime,
	timedOut,
	isCanceled,
	isGracefullyCanceled,
	isMaxBuffer,
	isForcefullyTerminated,
	exitCode: rawExitCode,
	signal: rawSignal,
	stdio,
	all,
	ipcOutput,
	options: {
		timeoutDuration,
		timeout = timeoutDuration,
		forceKillAfterDelay,
		killSignal,
		cwd,
		maxBuffer,
	},
	isSync,
}) => {
	const {exitCode, signal, signalDescription} = normalizeExitPayload(rawExitCode, rawSignal);
	const {originalMessage, shortMessage, message} = createMessages({
		stdio,
		all,
		ipcOutput,
		originalError,
		signal,
		signalDescription,
		exitCode,
		escapedCommand,
		timedOut,
		isCanceled,
		isGracefullyCanceled,
		isMaxBuffer,
		isForcefullyTerminated,
		forceKillAfterDelay,
		killSignal,
		maxBuffer,
		timeout,
		cwd,
	});
	const error = getFinalError(originalError, message, isSync);
	Object.assign(error, getErrorProperties({
		error,
		command,
		escapedCommand,
		startTime,
		timedOut,
		isCanceled,
		isGracefullyCanceled,
		isMaxBuffer,
		isForcefullyTerminated,
		exitCode,
		signal,
		signalDescription,
		stdio,
		all,
		ipcOutput,
		cwd,
		originalMessage,
		shortMessage,
	}));
	return error;
};

const getErrorProperties = ({
	error,
	command,
	escapedCommand,
	startTime,
	timedOut,
	isCanceled,
	isGracefullyCanceled,
	isMaxBuffer,
	isForcefullyTerminated,
	exitCode,
	signal,
	signalDescription,
	stdio,
	all,
	ipcOutput,
	cwd,
	originalMessage,
	shortMessage,
}) => omitUndefinedProperties({
	shortMessage,
	originalMessage,
	command,
	escapedCommand,
	cwd,
	durationMs: getDurationMs(startTime),
	failed: true,
	timedOut,
	isCanceled,
	isGracefullyCanceled,
	isTerminated: signal !== undefined,
	isMaxBuffer,
	isForcefullyTerminated,
	exitCode,
	signal,
	signalDescription,
	code: error.cause?.code,
	stdout: stdio[1],
	stderr: stdio[2],
	all,
	stdio,
	ipcOutput,
	pipedFrom: [],
});

const omitUndefinedProperties = result => Object.fromEntries(Object.entries(result).filter(([, value]) => value !== undefined));

// `signal` and `exitCode` emitted on `subprocess.on('exit')` event can be `null`.
// We normalize them to `undefined`
const normalizeExitPayload = (rawExitCode, rawSignal) => {
	const exitCode = rawExitCode === null ? undefined : rawExitCode;
	const signal = rawSignal === null ? undefined : rawSignal;
	const signalDescription = signal === undefined ? undefined : getSignalDescription(rawSignal);
	return {exitCode, signal, signalDescription};
};

const toZeroIfInfinity = value => Number.isFinite(value) ? value : 0;

function parseNumber(milliseconds) {
	return {
		days: Math.trunc(milliseconds / 86_400_000),
		hours: Math.trunc(milliseconds / 3_600_000 % 24),
		minutes: Math.trunc(milliseconds / 60_000 % 60),
		seconds: Math.trunc(milliseconds / 1000 % 60),
		milliseconds: Math.trunc(milliseconds % 1000),
		microseconds: Math.trunc(toZeroIfInfinity(milliseconds * 1000) % 1000),
		nanoseconds: Math.trunc(toZeroIfInfinity(milliseconds * 1e6) % 1000),
	};
}

function parseBigint(milliseconds) {
	return {
		days: milliseconds / 86_400_000n,
		hours: milliseconds / 3_600_000n % 24n,
		minutes: milliseconds / 60_000n % 60n,
		seconds: milliseconds / 1000n % 60n,
		milliseconds: milliseconds % 1000n,
		microseconds: 0n,
		nanoseconds: 0n,
	};
}

function parseMilliseconds(milliseconds) {
	switch (typeof milliseconds) {
		case 'number': {
			if (Number.isFinite(milliseconds)) {
				return parseNumber(milliseconds);
			}

			break;
		}

		case 'bigint': {
			return parseBigint(milliseconds);
		}

		// No default
	}

	throw new TypeError('Expected a finite number or bigint');
}

const isZero = value => value === 0 || value === 0n;
const pluralize = (word, count) => (count === 1 || count === 1n) ? word : `${word}s`;

const SECOND_ROUNDING_EPSILON = 0.000_000_1;
const ONE_DAY_IN_MILLISECONDS = 24n * 60n * 60n * 1000n;

function prettyMilliseconds(milliseconds, options) {
	const isBigInt = typeof milliseconds === 'bigint';
	if (!isBigInt && !Number.isFinite(milliseconds)) {
		throw new TypeError('Expected a finite number or bigint');
	}

	options = {...options};

	const sign = milliseconds < 0 ? '-' : '';
	milliseconds = milliseconds < 0 ? -milliseconds : milliseconds; // Cannot use `Math.abs()` because of BigInt support.

	if (options.colonNotation) {
		options.compact = false;
		options.formatSubMilliseconds = false;
		options.separateMilliseconds = false;
		options.verbose = false;
	}

	if (options.compact) {
		options.unitCount = 1;
		options.secondsDecimalDigits = 0;
		options.millisecondsDecimalDigits = 0;
	}

	let result = [];

	const floorDecimals = (value, decimalDigits) => {
		const flooredInterimValue = Math.floor((value * (10 ** decimalDigits)) + SECOND_ROUNDING_EPSILON);
		const flooredValue = Math.round(flooredInterimValue) / (10 ** decimalDigits);
		return flooredValue.toFixed(decimalDigits);
	};

	const add = (value, long, short, valueString) => {
		if (
			(result.length === 0 || !options.colonNotation)
			&& isZero(value)
			&& !(options.colonNotation && short === 'm')) {
			return;
		}

		valueString ??= String(value);
		if (options.colonNotation) {
			const wholeDigits = valueString.includes('.') ? valueString.split('.')[0].length : valueString.length;
			const minLength = result.length > 0 ? 2 : 1;
			valueString = '0'.repeat(Math.max(0, minLength - wholeDigits)) + valueString;
		} else {
			valueString += options.verbose ? ' ' + pluralize(long, value) : short;
		}

		result.push(valueString);
	};

	const parsed = parseMilliseconds(milliseconds);
	const days = BigInt(parsed.days);

	if (options.hideYearAndDays) {
		add((BigInt(days) * 24n) + BigInt(parsed.hours), 'hour', 'h');
	} else {
		if (options.hideYear) {
			add(days, 'day', 'd');
		} else {
			add(days / 365n, 'year', 'y');
			add(days % 365n, 'day', 'd');
		}

		add(Number(parsed.hours), 'hour', 'h');
	}

	add(Number(parsed.minutes), 'minute', 'm');

	if (!options.hideSeconds) {
		if (
			options.separateMilliseconds
			|| options.formatSubMilliseconds
			|| (!options.colonNotation && milliseconds < 1000)
		) {
			const seconds = Number(parsed.seconds);
			const milliseconds = Number(parsed.milliseconds);
			const microseconds = Number(parsed.microseconds);
			const nanoseconds = Number(parsed.nanoseconds);

			add(seconds, 'second', 's');

			if (options.formatSubMilliseconds) {
				add(milliseconds, 'millisecond', 'ms');
				add(microseconds, 'microsecond', 's');
				add(nanoseconds, 'nanosecond', 'ns');
			} else {
				const millisecondsAndBelow
					= milliseconds
					+ (microseconds / 1000)
					+ (nanoseconds / 1e6);

				const millisecondsDecimalDigits
					= typeof options.millisecondsDecimalDigits === 'number'
						? options.millisecondsDecimalDigits
						: 0;

				const roundedMilliseconds = millisecondsAndBelow >= 1
					? Math.round(millisecondsAndBelow)
					: Math.ceil(millisecondsAndBelow);

				const millisecondsString = millisecondsDecimalDigits
					? millisecondsAndBelow.toFixed(millisecondsDecimalDigits)
					: roundedMilliseconds;

				add(
					Number.parseFloat(millisecondsString),
					'millisecond',
					'ms',
					millisecondsString,
				);
			}
		} else {
			const seconds = (
				(isBigInt ? Number(milliseconds % ONE_DAY_IN_MILLISECONDS) : milliseconds)
				/ 1000
			) % 60;
			const secondsDecimalDigits
				= typeof options.secondsDecimalDigits === 'number'
					? options.secondsDecimalDigits
					: 1;
			const secondsFixed = floorDecimals(seconds, secondsDecimalDigits);
			const secondsString = options.keepDecimalsOnWholeSeconds
				? secondsFixed
				: secondsFixed.replace(/\.0+$/, '');
			add(Number.parseFloat(secondsString), 'second', 's', secondsString);
		}
	}

	if (result.length === 0) {
		return sign + '0' + (options.verbose ? ' milliseconds' : 'ms');
	}

	const separator = options.colonNotation ? ':' : ' ';
	if (typeof options.unitCount === 'number') {
		result = result.slice(0, Math.max(options.unitCount, 1));
	}

	return sign + result.join(separator);
}

// When `verbose` is `short|full|custom`, print each command's error when it fails
const logError = (result, verboseInfo) => {
	if (result.failed) {
		verboseLog({
			type: 'error',
			verboseMessage: result.shortMessage,
			verboseInfo,
			result,
		});
	}
};

// When `verbose` is `short|full|custom`, print each command's completion, duration and error
const logResult = (result, verboseInfo) => {
	if (!isVerbose(verboseInfo)) {
		return;
	}

	logError(result, verboseInfo);
	logDuration(result, verboseInfo);
};

const logDuration = (result, verboseInfo) => {
	const verboseMessage = `(done in ${prettyMilliseconds(result.durationMs)})`;
	verboseLog({
		type: 'duration',
		verboseMessage,
		verboseInfo,
		result,
	});
};

// Applies the `reject` option.
// Also print the final log line with `verbose`.
const handleResult = (result, verboseInfo, {reject}) => {
	logResult(result, verboseInfo);

	if (result.failed && reject) {
		throw result;
	}

	return result;
};

// The `stdin`/`stdout`/`stderr` option can be of many types. This detects it.
const getStdioItemType = (value, optionName) => {
	if (isAsyncGenerator(value)) {
		return 'asyncGenerator';
	}

	if (isSyncGenerator(value)) {
		return 'generator';
	}

	if (isUrl(value)) {
		return 'fileUrl';
	}

	if (isFilePathObject(value)) {
		return 'filePath';
	}

	if (isWebStream(value)) {
		return 'webStream';
	}

	if (isStream(value, {checkOpen: false})) {
		return 'native';
	}

	if (isUint8Array(value)) {
		return 'uint8Array';
	}

	if (isAsyncIterableObject(value)) {
		return 'asyncIterable';
	}

	if (isIterableObject(value)) {
		return 'iterable';
	}

	if (isTransformStream(value)) {
		return getTransformStreamType({}, optionName);
	}

	if (isTransformOptions(value)) {
		return getTransformObjectType(value, optionName);
	}

	return 'native';
};

const getTransformObjectType = (value, optionName) => {
	if (isDuplexStream(value.transform, {checkOpen: false})) {
		return getDuplexType(value, optionName);
	}

	if (isTransformStream(value.transform)) {
		return getTransformStreamType(value, optionName);
	}

	return getGeneratorObjectType(value, optionName);
};

const getDuplexType = (value, optionName) => {
	validateNonGeneratorType(value, optionName, 'Duplex stream');
	return 'duplex';
};

const getTransformStreamType = (value, optionName) => {
	validateNonGeneratorType(value, optionName, 'web TransformStream');
	return 'webTransform';
};

const validateNonGeneratorType = ({final, binary, objectMode}, optionName, typeName) => {
	checkUndefinedOption(final, `${optionName}.final`, typeName);
	checkUndefinedOption(binary, `${optionName}.binary`, typeName);
	checkBooleanOption(objectMode, `${optionName}.objectMode`);
};

const checkUndefinedOption = (value, optionName, typeName) => {
	if (value !== undefined) {
		throw new TypeError(`The \`${optionName}\` option can only be defined when using a generator, not a ${typeName}.`);
	}
};

const getGeneratorObjectType = ({transform, final, binary, objectMode}, optionName) => {
	if (transform !== undefined && !isGenerator(transform)) {
		throw new TypeError(`The \`${optionName}.transform\` option must be a generator, a Duplex stream or a web TransformStream.`);
	}

	if (isDuplexStream(final, {checkOpen: false})) {
		throw new TypeError(`The \`${optionName}.final\` option must not be a Duplex stream.`);
	}

	if (isTransformStream(final)) {
		throw new TypeError(`The \`${optionName}.final\` option must not be a web TransformStream.`);
	}

	if (final !== undefined && !isGenerator(final)) {
		throw new TypeError(`The \`${optionName}.final\` option must be a generator.`);
	}

	checkBooleanOption(binary, `${optionName}.binary`);
	checkBooleanOption(objectMode, `${optionName}.objectMode`);

	return isAsyncGenerator(transform) || isAsyncGenerator(final) ? 'asyncGenerator' : 'generator';
};

const checkBooleanOption = (value, optionName) => {
	if (value !== undefined && typeof value !== 'boolean') {
		throw new TypeError(`The \`${optionName}\` option must use a boolean.`);
	}
};

const isGenerator = value => isAsyncGenerator(value) || isSyncGenerator(value);
const isAsyncGenerator = value => Object.prototype.toString.call(value) === '[object AsyncGeneratorFunction]';
const isSyncGenerator = value => Object.prototype.toString.call(value) === '[object GeneratorFunction]';
const isTransformOptions = value => isPlainObject(value)
	&& (value.transform !== undefined || value.final !== undefined);

const isUrl = value => Object.prototype.toString.call(value) === '[object URL]';
const isRegularUrl = value => isUrl(value) && value.protocol !== 'file:';

const isFilePathObject = value => isPlainObject(value)
	&& Object.keys(value).length > 0
	&& Object.keys(value).every(key => FILE_PATH_KEYS.has(key))
	&& isFilePathString(value.file);
const FILE_PATH_KEYS = new Set(['file', 'append']);
const isFilePathString = file => typeof file === 'string';

const isUnknownStdioString = (type, value) => type === 'native'
	&& typeof value === 'string'
	&& !KNOWN_STDIO_STRINGS.has(value);
const KNOWN_STDIO_STRINGS = new Set(['ipc', 'ignore', 'inherit', 'overlapped', 'pipe']);

const isReadableStream = value => Object.prototype.toString.call(value) === '[object ReadableStream]';
const isWritableStream = value => Object.prototype.toString.call(value) === '[object WritableStream]';
const isWebStream = value => isReadableStream(value) || isWritableStream(value);
const isTransformStream = value => isReadableStream(value?.readable) && isWritableStream(value?.writable);

const isAsyncIterableObject = value => isObject(value) && typeof value[Symbol.asyncIterator] === 'function';
const isIterableObject = value => isObject(value) && typeof value[Symbol.iterator] === 'function';
const isObject = value => typeof value === 'object' && value !== null;

// Types which modify `subprocess.std*`
const TRANSFORM_TYPES = new Set(['generator', 'asyncGenerator', 'duplex', 'webTransform']);
// Types which write to a file or a file descriptor
const FILE_TYPES = new Set(['fileUrl', 'filePath', 'fileNumber']);
// When two file descriptors of this type share the same target, we need to do some special logic
const SPECIAL_DUPLICATE_TYPES_SYNC = new Set(['fileUrl', 'filePath']);
const SPECIAL_DUPLICATE_TYPES = new Set([...SPECIAL_DUPLICATE_TYPES_SYNC, 'webStream', 'nodeStream']);
// Do not allow two file descriptors of this type sharing the same target
const FORBID_DUPLICATE_TYPES = new Set(['webTransform', 'duplex']);

// Convert types to human-friendly strings for error messages
const TYPE_TO_MESSAGE = {
	generator: 'a generator',
	asyncGenerator: 'an async generator',
	fileUrl: 'a file URL',
	filePath: 'a file path string',
	fileNumber: 'a file descriptor number',
	webStream: 'a web stream',
	nodeStream: 'a Node.js stream',
	webTransform: 'a web TransformStream',
	duplex: 'a Duplex stream',
	native: 'any value',
	iterable: 'an iterable',
	asyncIterable: 'an async iterable',
	string: 'a string',
	uint8Array: 'a Uint8Array',
};

/*
Retrieve the `objectMode`s of a single transform.
`objectMode` determines the return value's type, i.e. the `readableObjectMode`.
The chunk argument's type is based on the previous generator's return value, i.e. the `writableObjectMode` is based on the previous `readableObjectMode`.
The last input's generator is read by `subprocess.stdin` which:
- should not be in `objectMode` for performance reasons.
- can only be strings, Buffers and Uint8Arrays.
Therefore its `readableObjectMode` must be `false`.
The same applies to the first output's generator's `writableObjectMode`.
*/
const getTransformObjectModes = (objectMode, index, newTransforms, direction) => direction === 'output'
	? getOutputObjectModes(objectMode, index, newTransforms)
	: getInputObjectModes(objectMode, index, newTransforms);

const getOutputObjectModes = (objectMode, index, newTransforms) => {
	const writableObjectMode = index !== 0 && newTransforms[index - 1].value.readableObjectMode;
	const readableObjectMode = objectMode ?? writableObjectMode;
	return {writableObjectMode, readableObjectMode};
};

const getInputObjectModes = (objectMode, index, newTransforms) => {
	const writableObjectMode = index === 0
		? objectMode === true
		: newTransforms[index - 1].value.readableObjectMode;
	const readableObjectMode = index !== newTransforms.length - 1 && (objectMode ?? writableObjectMode);
	return {writableObjectMode, readableObjectMode};
};

// Retrieve the `objectMode` of a file descriptor, e.g. `stdout` or `stderr`
const getFdObjectMode = (stdioItems, direction) => {
	const lastTransform = stdioItems.findLast(({type}) => TRANSFORM_TYPES.has(type));
	if (lastTransform === undefined) {
		return false;
	}

	return direction === 'input'
		? lastTransform.value.writableObjectMode
		: lastTransform.value.readableObjectMode;
};

// Transforms generators/duplex/TransformStream can have multiple shapes.
// This normalizes it and applies default values.
const normalizeTransforms = (stdioItems, optionName, direction, options) => [
	...stdioItems.filter(({type}) => !TRANSFORM_TYPES.has(type)),
	...getTransforms(stdioItems, optionName, direction, options),
];

const getTransforms = (stdioItems, optionName, direction, {encoding}) => {
	const transforms = stdioItems.filter(({type}) => TRANSFORM_TYPES.has(type));
	const newTransforms = Array.from({length: transforms.length});

	for (const [index, stdioItem] of Object.entries(transforms)) {
		newTransforms[index] = normalizeTransform({
			stdioItem,
			index: Number(index),
			newTransforms,
			optionName,
			direction,
			encoding,
		});
	}

	return sortTransforms(newTransforms, direction);
};

const normalizeTransform = ({stdioItem, stdioItem: {type}, index, newTransforms, optionName, direction, encoding}) => {
	if (type === 'duplex') {
		return normalizeDuplex({stdioItem, optionName});
	}

	if (type === 'webTransform') {
		return normalizeTransformStream({
			stdioItem,
			index,
			newTransforms,
			direction,
		});
	}

	return normalizeGenerator({
		stdioItem,
		index,
		newTransforms,
		direction,
		encoding,
	});
};

const normalizeDuplex = ({
	stdioItem,
	stdioItem: {
		value: {
			transform,
			transform: {writableObjectMode, readableObjectMode},
			objectMode = readableObjectMode,
		},
	},
	optionName,
}) => {
	if (objectMode && !readableObjectMode) {
		throw new TypeError(`The \`${optionName}.objectMode\` option can only be \`true\` if \`new Duplex({objectMode: true})\` is used.`);
	}

	if (!objectMode && readableObjectMode) {
		throw new TypeError(`The \`${optionName}.objectMode\` option cannot be \`false\` if \`new Duplex({objectMode: true})\` is used.`);
	}

	return {
		...stdioItem,
		value: {transform, writableObjectMode, readableObjectMode},
	};
};

const normalizeTransformStream = ({stdioItem, stdioItem: {value}, index, newTransforms, direction}) => {
	const {transform, objectMode} = isPlainObject(value) ? value : {transform: value};
	const {writableObjectMode, readableObjectMode} = getTransformObjectModes(objectMode, index, newTransforms, direction);
	return ({
		...stdioItem,
		value: {transform, writableObjectMode, readableObjectMode},
	});
};

const normalizeGenerator = ({stdioItem, stdioItem: {value}, index, newTransforms, direction, encoding}) => {
	const {
		transform,
		final,
		binary: binaryOption = false,
		preserveNewlines = false,
		objectMode,
	} = isPlainObject(value) ? value : {transform: value};
	const binary = binaryOption || BINARY_ENCODINGS.has(encoding);
	const {writableObjectMode, readableObjectMode} = getTransformObjectModes(objectMode, index, newTransforms, direction);
	return {
		...stdioItem,
		value: {
			transform,
			final,
			binary,
			preserveNewlines,
			writableObjectMode,
			readableObjectMode,
		},
	};
};

const sortTransforms = (newTransforms, direction) => direction === 'input' ? newTransforms.reverse() : newTransforms;

// For `stdio[fdNumber]` beyond stdin/stdout/stderr, we need to guess whether the value passed is intended for inputs or outputs.
// This allows us to know whether to pipe _into_ or _from_ the stream.
// When `stdio[fdNumber]` is a single value, this guess is fairly straightforward.
// However, when it is an array instead, we also need to make sure the different values are not incompatible with each other.
const getStreamDirection = (stdioItems, fdNumber, optionName) => {
	const directions = stdioItems.map(stdioItem => getStdioItemDirection(stdioItem, fdNumber));

	if (directions.includes('input') && directions.includes('output')) {
		throw new TypeError(`The \`${optionName}\` option must not be an array of both readable and writable values.`);
	}

	return directions.find(Boolean) ?? DEFAULT_DIRECTION;
};

const getStdioItemDirection = ({type, value}, fdNumber) => KNOWN_DIRECTIONS[fdNumber] ?? guessStreamDirection[type](value);

// `stdin`/`stdout`/`stderr` have a known direction
const KNOWN_DIRECTIONS = ['input', 'output', 'output'];

const anyDirection = () => undefined;
const alwaysInput = () => 'input';

// `string` can only be added through the `input` option, i.e. does not need to be handled here
const guessStreamDirection = {
	generator: anyDirection,
	asyncGenerator: anyDirection,
	fileUrl: anyDirection,
	filePath: anyDirection,
	iterable: alwaysInput,
	asyncIterable: alwaysInput,
	uint8Array: alwaysInput,
	webStream: value => isWritableStream(value) ? 'output' : 'input',
	nodeStream(value) {
		if (!isReadableStream$1(value, {checkOpen: false})) {
			return 'output';
		}

		return isWritableStream$1(value, {checkOpen: false}) ? undefined : 'input';
	},
	webTransform: anyDirection,
	duplex: anyDirection,
	native(value) {
		const standardStreamDirection = getStandardStreamDirection(value);
		if (standardStreamDirection !== undefined) {
			return standardStreamDirection;
		}

		if (isStream(value, {checkOpen: false})) {
			return guessStreamDirection.nodeStream(value);
		}
	},
};

const getStandardStreamDirection = value => {
	if ([0, process$2.stdin].includes(value)) {
		return 'input';
	}

	if ([1, 2, process$2.stdout, process$2.stderr].includes(value)) {
		return 'output';
	}
};

// When ambiguous, we initially keep the direction as `undefined`.
// This allows arrays of `stdio` values to resolve the ambiguity.
// For example, `stdio[3]: DuplexStream` is ambiguous, but `stdio[3]: [DuplexStream, WritableStream]` is not.
// When the ambiguity remains, we default to `output` since it is the most common use case for additional file descriptors.
const DEFAULT_DIRECTION = 'output';

// The `ipc` option adds an `ipc` item to the `stdio` option
const normalizeIpcStdioArray = (stdioArray, ipc) => ipc && !stdioArray.includes('ipc')
	? [...stdioArray, 'ipc']
	: stdioArray;

// Add support for `stdin`/`stdout`/`stderr` as an alias for `stdio`.
// Also normalize the `stdio` option.
const normalizeStdioOption = ({stdio, ipc, buffer, ...options}, verboseInfo, isSync) => {
	const stdioArray = getStdioArray(stdio, options).map((stdioOption, fdNumber) => addDefaultValue(stdioOption, fdNumber));
	return isSync
		? normalizeStdioSync(stdioArray, buffer, verboseInfo)
		: normalizeIpcStdioArray(stdioArray, ipc);
};

const getStdioArray = (stdio, options) => {
	if (stdio === undefined) {
		return STANDARD_STREAMS_ALIASES.map(alias => options[alias]);
	}

	if (hasAlias(options)) {
		throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${STANDARD_STREAMS_ALIASES.map(alias => `\`${alias}\``).join(', ')}`);
	}

	if (typeof stdio === 'string') {
		return [stdio, stdio, stdio];
	}

	if (!Array.isArray(stdio)) {
		throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof stdio}\``);
	}

	const length = Math.max(stdio.length, STANDARD_STREAMS_ALIASES.length);
	return Array.from({length}, (_, fdNumber) => stdio[fdNumber]);
};

const hasAlias = options => STANDARD_STREAMS_ALIASES.some(alias => options[alias] !== undefined);

const addDefaultValue = (stdioOption, fdNumber) => {
	if (Array.isArray(stdioOption)) {
		return stdioOption.map(item => addDefaultValue(item, fdNumber));
	}

	if (stdioOption === null || stdioOption === undefined) {
		return fdNumber >= STANDARD_STREAMS_ALIASES.length ? 'ignore' : 'pipe';
	}

	return stdioOption;
};

// Using `buffer: false` with synchronous methods implies `stdout`/`stderr`: `ignore`.
// Unless the output is needed, e.g. due to `verbose: 'full'` or to redirecting to a file.
const normalizeStdioSync = (stdioArray, buffer, verboseInfo) => stdioArray.map((stdioOption, fdNumber) =>
	!buffer[fdNumber]
	&& fdNumber !== 0
	&& !isFullVerbose(verboseInfo, fdNumber)
	&& isOutputPipeOnly(stdioOption)
		? 'ignore'
		: stdioOption);

const isOutputPipeOnly = stdioOption => stdioOption === 'pipe'
	|| (Array.isArray(stdioOption) && stdioOption.every(item => item === 'pipe'));

// When we use multiple `stdio` values for the same streams, we pass 'pipe' to `child_process.spawn()`.
// We then emulate the piping done by core Node.js.
// To do so, we transform the following values:
//  - Node.js streams are marked as `type: nodeStream`
//  - 'inherit' becomes `process.stdin|stdout|stderr`
//  - any file descriptor integer becomes `process.stdio[fdNumber]`
// All of the above transformations tell Execa to perform manual piping.
const handleNativeStream = ({stdioItem, stdioItem: {type}, isStdioArray, fdNumber, direction, isSync}) => {
	if (!isStdioArray || type !== 'native') {
		return stdioItem;
	}

	return isSync
		? handleNativeStreamSync({stdioItem, fdNumber, direction})
		: handleNativeStreamAsync({stdioItem, fdNumber});
};

// Synchronous methods use a different logic.
// 'inherit', file descriptors and process.std* are handled by readFileSync()/writeFileSync().
const handleNativeStreamSync = ({stdioItem, stdioItem: {value, optionName}, fdNumber, direction}) => {
	const targetFd = getTargetFd({
		value,
		optionName,
		fdNumber,
		direction,
	});
	if (targetFd !== undefined) {
		return targetFd;
	}

	if (isStream(value, {checkOpen: false})) {
		throw new TypeError(`The \`${optionName}: Stream\` option cannot both be an array and include a stream with synchronous methods.`);
	}

	return stdioItem;
};

const getTargetFd = ({value, optionName, fdNumber, direction}) => {
	const targetFdNumber = getTargetFdNumber(value, fdNumber);
	if (targetFdNumber === undefined) {
		return;
	}

	if (direction === 'output') {
		return {type: 'fileNumber', value: targetFdNumber, optionName};
	}

	if (tty__default.isatty(targetFdNumber)) {
		throw new TypeError(`The \`${optionName}: ${serializeOptionValue(value)}\` option is invalid: it cannot be a TTY with synchronous methods.`);
	}

	return {type: 'uint8Array', value: bufferToUint8Array(readFileSync(targetFdNumber)), optionName};
};

const getTargetFdNumber = (value, fdNumber) => {
	if (value === 'inherit') {
		return fdNumber;
	}

	if (typeof value === 'number') {
		return value;
	}

	const standardStreamIndex = STANDARD_STREAMS.indexOf(value);
	if (standardStreamIndex !== -1) {
		return standardStreamIndex;
	}
};

const handleNativeStreamAsync = ({stdioItem, stdioItem: {value, optionName}, fdNumber}) => {
	if (value === 'inherit') {
		return {type: 'nodeStream', value: getStandardStream(fdNumber, value, optionName), optionName};
	}

	if (typeof value === 'number') {
		return {type: 'nodeStream', value: getStandardStream(value, value, optionName), optionName};
	}

	if (isStream(value, {checkOpen: false})) {
		return {type: 'nodeStream', value, optionName};
	}

	return stdioItem;
};

// Node.js does not allow to easily retrieve file descriptors beyond stdin/stdout/stderr as streams.
//  - `fs.createReadStream()`/`fs.createWriteStream()` with the `fd` option do not work with character devices that use blocking reads/writes (such as interactive TTYs).
//  - Using a TCP `Socket` would work but be rather complex to implement.
// Since this is an edge case, we simply throw an error message.
// See https://github.com/sindresorhus/execa/pull/643#discussion_r1435905707
const getStandardStream = (fdNumber, value, optionName) => {
	const standardStream = STANDARD_STREAMS[fdNumber];

	if (standardStream === undefined) {
		throw new TypeError(`The \`${optionName}: ${value}\` option is invalid: no such standard stream.`);
	}

	return standardStream;
};

// Append the `stdin` option with the `input` and `inputFile` options
const handleInputOptions = ({input, inputFile}, fdNumber) => fdNumber === 0
	? [
		...handleInputOption(input),
		...handleInputFileOption(inputFile),
	]
	: [];

const handleInputOption = input => input === undefined ? [] : [{
	type: getInputType(input),
	value: input,
	optionName: 'input',
}];

const getInputType = input => {
	if (isReadableStream$1(input, {checkOpen: false})) {
		return 'nodeStream';
	}

	if (typeof input === 'string') {
		return 'string';
	}

	if (isUint8Array(input)) {
		return 'uint8Array';
	}

	throw new Error('The `input` option must be a string, a Uint8Array or a Node.js Readable stream.');
};

const handleInputFileOption = inputFile => inputFile === undefined ? [] : [{
	...getInputFileType(inputFile),
	optionName: 'inputFile',
}];

const getInputFileType = inputFile => {
	if (isUrl(inputFile)) {
		return {type: 'fileUrl', value: inputFile};
	}

	if (isFilePathString(inputFile)) {
		return {type: 'filePath', value: {file: inputFile}};
	}

	throw new Error('The `inputFile` option must be a file path string or a file URL.');
};

// Duplicates in the same file descriptor is most likely an error.
// However, this can be useful with generators.
const filterDuplicates = stdioItems => stdioItems.filter((stdioItemOne, indexOne) =>
	stdioItems.every((stdioItemTwo, indexTwo) => stdioItemOne.value !== stdioItemTwo.value
		|| indexOne >= indexTwo
		|| stdioItemOne.type === 'generator'
		|| stdioItemOne.type === 'asyncGenerator'));

// Check if two file descriptors are sharing the same target.
// For example `{stdout: {file: './output.txt'}, stderr: {file: './output.txt'}}`.
const getDuplicateStream = ({stdioItem: {type, value, optionName}, direction, fileDescriptors, isSync}) => {
	const otherStdioItems = getOtherStdioItems(fileDescriptors, type);
	if (otherStdioItems.length === 0) {
		return;
	}

	if (isSync) {
		validateDuplicateStreamSync({
			otherStdioItems,
			type,
			value,
			optionName,
			direction,
		});
		return;
	}

	if (SPECIAL_DUPLICATE_TYPES.has(type)) {
		return getDuplicateStreamInstance({
			otherStdioItems,
			type,
			value,
			optionName,
			direction,
		});
	}

	if (FORBID_DUPLICATE_TYPES.has(type)) {
		validateDuplicateTransform({
			otherStdioItems,
			type,
			value,
			optionName,
		});
	}
};

// Values shared by multiple file descriptors
const getOtherStdioItems = (fileDescriptors, type) => fileDescriptors
	.flatMap(({direction, stdioItems}) => stdioItems
		.filter(stdioItem => stdioItem.type === type)
		.map((stdioItem => ({...stdioItem, direction}))));

// With `execaSync()`, do not allow setting a file path both in input and output
const validateDuplicateStreamSync = ({otherStdioItems, type, value, optionName, direction}) => {
	if (SPECIAL_DUPLICATE_TYPES_SYNC.has(type)) {
		getDuplicateStreamInstance({
			otherStdioItems,
			type,
			value,
			optionName,
			direction,
		});
	}
};

// When two file descriptors share the file or stream, we need to re-use the same underlying stream.
// Otherwise, the stream would be closed twice when piping ends.
// This is only an issue with output file descriptors.
// This is not a problem with generator functions since those create a new instance for each file descriptor.
// We also forbid input and output file descriptors sharing the same file or stream, since that does not make sense.
const getDuplicateStreamInstance = ({otherStdioItems, type, value, optionName, direction}) => {
	const duplicateStdioItems = otherStdioItems.filter(stdioItem => hasSameValue(stdioItem, value));
	if (duplicateStdioItems.length === 0) {
		return;
	}

	const differentStdioItem = duplicateStdioItems.find(stdioItem => stdioItem.direction !== direction);
	throwOnDuplicateStream(differentStdioItem, optionName, type);

	return direction === 'output' ? duplicateStdioItems[0].stream : undefined;
};

const hasSameValue = ({type, value}, secondValue) => {
	if (type === 'filePath') {
		return value.file === secondValue.file;
	}

	if (type === 'fileUrl') {
		return value.href === secondValue.href;
	}

	return value === secondValue;
};

// We do not allow two file descriptors to share the same Duplex or TransformStream.
// This is because those are set directly to `subprocess.std*`.
// For example, this could result in `subprocess.stdout` and `subprocess.stderr` being the same value.
// This means reading from either would get data from both stdout and stderr.
const validateDuplicateTransform = ({otherStdioItems, type, value, optionName}) => {
	const duplicateStdioItem = otherStdioItems.find(({value: {transform}}) => transform === value.transform);
	throwOnDuplicateStream(duplicateStdioItem, optionName, type);
};

const throwOnDuplicateStream = (stdioItem, optionName, type) => {
	if (stdioItem !== undefined) {
		throw new TypeError(`The \`${stdioItem.optionName}\` and \`${optionName}\` options must not target ${TYPE_TO_MESSAGE[type]} that is the same.`);
	}
};

// Handle `input`, `inputFile`, `stdin`, `stdout` and `stderr` options, before spawning, in async/sync mode
// They are converted into an array of `fileDescriptors`.
// Each `fileDescriptor` is normalized, validated and contains all information necessary for further handling.
const handleStdio = (addProperties, options, verboseInfo, isSync) => {
	const stdio = normalizeStdioOption(options, verboseInfo, isSync);
	const initialFileDescriptors = stdio.map((stdioOption, fdNumber) => getFileDescriptor({
		stdioOption,
		fdNumber,
		options,
		isSync,
	}));
	const fileDescriptors = getFinalFileDescriptors({
		initialFileDescriptors,
		addProperties,
		options,
		isSync,
	});
	options.stdio = fileDescriptors.map(({stdioItems}) => forwardStdio(stdioItems));
	return fileDescriptors;
};

const getFileDescriptor = ({stdioOption, fdNumber, options, isSync}) => {
	const optionName = getStreamName(fdNumber);
	const {stdioItems: initialStdioItems, isStdioArray} = initializeStdioItems({
		stdioOption,
		fdNumber,
		options,
		optionName,
	});
	const direction = getStreamDirection(initialStdioItems, fdNumber, optionName);
	const stdioItems = initialStdioItems.map(stdioItem => handleNativeStream({
		stdioItem,
		isStdioArray,
		fdNumber,
		direction,
		isSync,
	}));
	const normalizedStdioItems = normalizeTransforms(stdioItems, optionName, direction, options);
	const objectMode = getFdObjectMode(normalizedStdioItems, direction);
	validateFileObjectMode(normalizedStdioItems, objectMode);
	return {direction, objectMode, stdioItems: normalizedStdioItems};
};

// We make sure passing an array with a single item behaves the same as passing that item without an array.
// This is what users would expect.
// For example, `stdout: ['ignore']` behaves the same as `stdout: 'ignore'`.
const initializeStdioItems = ({stdioOption, fdNumber, options, optionName}) => {
	const values = Array.isArray(stdioOption) ? stdioOption : [stdioOption];
	const initialStdioItems = [
		...values.map(value => initializeStdioItem(value, optionName)),
		...handleInputOptions(options, fdNumber),
	];

	const stdioItems = filterDuplicates(initialStdioItems);
	const isStdioArray = stdioItems.length > 1;
	validateStdioArray(stdioItems, isStdioArray, optionName);
	validateStreams(stdioItems);
	return {stdioItems, isStdioArray};
};

const initializeStdioItem = (value, optionName) => ({
	type: getStdioItemType(value, optionName),
	value,
	optionName,
});

const validateStdioArray = (stdioItems, isStdioArray, optionName) => {
	if (stdioItems.length === 0) {
		throw new TypeError(`The \`${optionName}\` option must not be an empty array.`);
	}

	if (!isStdioArray) {
		return;
	}

	for (const {value, optionName} of stdioItems) {
		if (INVALID_STDIO_ARRAY_OPTIONS.has(value)) {
			throw new Error(`The \`${optionName}\` option must not include \`${value}\`.`);
		}
	}
};

// Using those `stdio` values together with others for the same stream does not make sense, so we make it fail.
// However, we do allow it if the array has a single item.
const INVALID_STDIO_ARRAY_OPTIONS = new Set(['ignore', 'ipc']);

const validateStreams = stdioItems => {
	for (const stdioItem of stdioItems) {
		validateFileStdio(stdioItem);
	}
};

const validateFileStdio = ({type, value, optionName}) => {
	if (isRegularUrl(value)) {
		throw new TypeError(`The \`${optionName}: URL\` option must use the \`file:\` scheme.
For example, you can use the \`pathToFileURL()\` method of the \`url\` core module.`);
	}

	if (isUnknownStdioString(type, value)) {
		throw new TypeError(`The \`${optionName}: { file: '...' }\` option must be used instead of \`${optionName}: '...'\`.`);
	}
};

const validateFileObjectMode = (stdioItems, objectMode) => {
	if (!objectMode) {
		return;
	}

	const fileStdioItem = stdioItems.find(({type}) => FILE_TYPES.has(type));
	if (fileStdioItem !== undefined) {
		throw new TypeError(`The \`${fileStdioItem.optionName}\` option cannot use both files and transforms in objectMode.`);
	}
};

// Some `stdio` values require Execa to create streams.
// For example, file paths create file read/write streams.
// Those transformations are specified in `addProperties`, which is both direction-specific and type-specific.
const getFinalFileDescriptors = ({initialFileDescriptors, addProperties, options, isSync}) => {
	const fileDescriptors = [];

	try {
		for (const fileDescriptor of initialFileDescriptors) {
			fileDescriptors.push(getFinalFileDescriptor({
				fileDescriptor,
				fileDescriptors,
				addProperties,
				options,
				isSync,
			}));
		}

		return fileDescriptors;
	} catch (error) {
		cleanupCustomStreams(fileDescriptors);
		throw error;
	}
};

const getFinalFileDescriptor = ({
	fileDescriptor: {direction, objectMode, stdioItems},
	fileDescriptors,
	addProperties,
	options,
	isSync,
}) => {
	const finalStdioItems = stdioItems.map(stdioItem => addStreamProperties({
		stdioItem,
		addProperties,
		direction,
		options,
		fileDescriptors,
		isSync,
	}));
	return {direction, objectMode, stdioItems: finalStdioItems};
};

const addStreamProperties = ({stdioItem, addProperties, direction, options, fileDescriptors, isSync}) => {
	const duplicateStream = getDuplicateStream({
		stdioItem,
		direction,
		fileDescriptors,
		isSync,
	});

	if (duplicateStream !== undefined) {
		return {...stdioItem, stream: duplicateStream};
	}

	return {
		...stdioItem,
		...addProperties[direction][stdioItem.type](stdioItem, options),
	};
};

// The stream error handling is performed by the piping logic above, which cannot be performed before subprocess spawning.
// If the subprocess spawning fails (e.g. due to an invalid command), the streams need to be manually destroyed.
// We need to create those streams before subprocess spawning, in case their creation fails, e.g. when passing an invalid generator as argument.
// Like this, an exception would be thrown, which would prevent spawning a subprocess.
const cleanupCustomStreams = fileDescriptors => {
	for (const {stdioItems} of fileDescriptors) {
		for (const {stream} of stdioItems) {
			if (stream !== undefined && !isStandardStream(stream)) {
				stream.destroy();
			}
		}
	}
};

// When the `std*: Iterable | WebStream | URL | filePath`, `input` or `inputFile` option is used, we pipe to `subprocess.std*`.
// When the `std*: Array` option is used, we emulate some of the native values ('inherit', Node.js stream and file descriptor integer). To do so, we also need to pipe to `subprocess.std*`.
// Therefore the `std*` options must be either `pipe` or `overlapped`. Other values do not set `subprocess.std*`.
const forwardStdio = stdioItems => {
	if (stdioItems.length > 1) {
		return stdioItems.some(({value}) => value === 'overlapped') ? 'overlapped' : 'pipe';
	}

	const [{type, value}] = stdioItems;
	return type === 'native' ? value : 'pipe';
};

// Normalize `input`, `inputFile`, `stdin`, `stdout` and `stderr` options, before spawning, in sync mode
const handleStdioSync = (options, verboseInfo) => handleStdio(addPropertiesSync, options, verboseInfo, true);

const forbiddenIfSync = ({type, optionName}) => {
	throwInvalidSyncValue(optionName, TYPE_TO_MESSAGE[type]);
};

const forbiddenNativeIfSync = ({optionName, value}) => {
	if (value === 'ipc' || value === 'overlapped') {
		throwInvalidSyncValue(optionName, `"${value}"`);
	}

	return {};
};

const throwInvalidSyncValue = (optionName, value) => {
	throw new TypeError(`The \`${optionName}\` option cannot be ${value} with synchronous methods.`);
};

// Create streams used internally for redirecting when using specific values for the `std*` options, in sync mode.
// For example, `stdin: {file}` reads the file synchronously, then passes it as the `input` option.
const addProperties$1 = {
	generator() {},
	asyncGenerator: forbiddenIfSync,
	webStream: forbiddenIfSync,
	nodeStream: forbiddenIfSync,
	webTransform: forbiddenIfSync,
	duplex: forbiddenIfSync,
	asyncIterable: forbiddenIfSync,
	native: forbiddenNativeIfSync,
};

const addPropertiesSync = {
	input: {
		...addProperties$1,
		fileUrl: ({value}) => ({contents: [bufferToUint8Array(readFileSync(value))]}),
		filePath: ({value: {file}}) => ({contents: [bufferToUint8Array(readFileSync(file))]}),
		fileNumber: forbiddenIfSync,
		iterable: ({value}) => ({contents: [...value]}),
		string: ({value}) => ({contents: [value]}),
		uint8Array: ({value}) => ({contents: [value]}),
	},
	output: {
		...addProperties$1,
		fileUrl: ({value}) => ({path: value}),
		filePath: ({value: {file, append}}) => ({path: file, append}),
		fileNumber: ({value}) => ({path: value}),
		iterable: forbiddenIfSync,
		string: forbiddenIfSync,
		uint8Array: forbiddenIfSync,
	},
};

// Apply `stripFinalNewline` option, which applies to `result.stdout|stderr|all|stdio[*]`.
// If the `lines` option is used, it is applied on each line, but using a different function.
const stripNewline = (value, {stripFinalNewline: stripFinalNewline$1}, fdNumber) => getStripFinalNewline(stripFinalNewline$1, fdNumber) && value !== undefined && !Array.isArray(value)
	? stripFinalNewline(value)
	: value;

// Retrieve `stripFinalNewline` option value, including with `subprocess.all`
const getStripFinalNewline = (stripFinalNewline, fdNumber) => fdNumber === 'all'
	? stripFinalNewline[1] || stripFinalNewline[2]
	: stripFinalNewline[fdNumber];

// Split chunks line-wise for generators passed to the `std*` options
const getSplitLinesGenerator = (binary, preserveNewlines, skipped, state) => binary || skipped
	? undefined
	: initializeSplitLines(preserveNewlines, state);

// Same but for synchronous methods
const splitLinesSync = (chunk, preserveNewlines, objectMode) => objectMode
	? chunk.flatMap(item => splitLinesItemSync(item, preserveNewlines))
	: splitLinesItemSync(chunk, preserveNewlines);

const splitLinesItemSync = (chunk, preserveNewlines) => {
	const {transform, final} = initializeSplitLines(preserveNewlines, {});
	return [...transform(chunk), ...final()];
};

const initializeSplitLines = (preserveNewlines, state) => {
	state.previousChunks = '';
	return {
		transform: splitGenerator.bind(undefined, state, preserveNewlines),
		final: linesFinal.bind(undefined, state),
	};
};

// This imperative logic is much faster than using `String.split()` and uses very low memory.
const splitGenerator = function * (state, preserveNewlines, chunk) {
	if (typeof chunk !== 'string') {
		yield chunk;
		return;
	}

	let {previousChunks} = state;
	let start = -1;

	for (let end = 0; end < chunk.length; end += 1) {
		if (chunk[end] === '\n') {
			const newlineLength = getNewlineLength(chunk, end, preserveNewlines, state);
			let line = chunk.slice(start + 1, end + 1 - newlineLength);

			if (previousChunks.length > 0) {
				line = concatString(previousChunks, line);
				previousChunks = '';
			}

			yield line;
			start = end;
		}
	}

	if (start !== chunk.length - 1) {
		previousChunks = concatString(previousChunks, chunk.slice(start + 1));
	}

	state.previousChunks = previousChunks;
};

const getNewlineLength = (chunk, end, preserveNewlines, state) => {
	if (preserveNewlines) {
		return 0;
	}

	state.isWindowsNewline = end !== 0 && chunk[end - 1] === '\r';
	return state.isWindowsNewline ? 2 : 1;
};

const linesFinal = function * ({previousChunks}) {
	if (previousChunks.length > 0) {
		yield previousChunks;
	}
};

// Unless `preserveNewlines: true` is used, we strip the newline of each line.
// This re-adds them after the user `transform` code has run.
const getAppendNewlineGenerator = ({binary, preserveNewlines, readableObjectMode, state}) => binary || preserveNewlines || readableObjectMode
	? undefined
	: {transform: appendNewlineGenerator.bind(undefined, state)};

const appendNewlineGenerator = function * ({isWindowsNewline = false}, chunk) {
	const {unixNewline, windowsNewline, LF, concatBytes} = typeof chunk === 'string' ? linesStringInfo : linesUint8ArrayInfo;

	if (chunk.at(-1) === LF) {
		yield chunk;
		return;
	}

	const newline = isWindowsNewline ? windowsNewline : unixNewline;
	yield concatBytes(chunk, newline);
};

const concatString = (firstChunk, secondChunk) => `${firstChunk}${secondChunk}`;

const linesStringInfo = {
	windowsNewline: '\r\n',
	unixNewline: '\n',
	LF: '\n',
	concatBytes: concatString,
};

const concatUint8Array = (firstChunk, secondChunk) => {
	const chunk = new Uint8Array(firstChunk.length + secondChunk.length);
	chunk.set(firstChunk, 0);
	chunk.set(secondChunk, firstChunk.length);
	return chunk;
};

const linesUint8ArrayInfo = {
	windowsNewline: new Uint8Array([0x0D, 0x0A]),
	unixNewline: new Uint8Array([0x0A]),
	LF: 0x0A,
	concatBytes: concatUint8Array,
};

// Validate the type of chunk argument passed to transform generators
const getValidateTransformInput = (writableObjectMode, optionName) => writableObjectMode
	? undefined
	: validateStringTransformInput.bind(undefined, optionName);

const validateStringTransformInput = function * (optionName, chunk) {
	if (typeof chunk !== 'string' && !isUint8Array(chunk) && !Buffer$1.isBuffer(chunk)) {
		throw new TypeError(`The \`${optionName}\` option's transform must use "objectMode: true" to receive as input: ${typeof chunk}.`);
	}

	yield chunk;
};

// Validate the type of the value returned by transform generators
const getValidateTransformReturn = (readableObjectMode, optionName) => readableObjectMode
	? validateObjectTransformReturn.bind(undefined, optionName)
	: validateStringTransformReturn.bind(undefined, optionName);

const validateObjectTransformReturn = function * (optionName, chunk) {
	validateEmptyReturn(optionName, chunk);
	yield chunk;
};

const validateStringTransformReturn = function * (optionName, chunk) {
	validateEmptyReturn(optionName, chunk);

	if (typeof chunk !== 'string' && !isUint8Array(chunk)) {
		throw new TypeError(`The \`${optionName}\` option's function must yield a string or an Uint8Array, not ${typeof chunk}.`);
	}

	yield chunk;
};

const validateEmptyReturn = (optionName, chunk) => {
	if (chunk === null || chunk === undefined) {
		throw new TypeError(`The \`${optionName}\` option's function must not call \`yield ${chunk}\`.
Instead, \`yield\` should either be called with a value, or not be called at all. For example:
  if (condition) { yield value; }`);
	}
};

/*
When using binary encodings, add an internal generator that converts chunks from `Buffer` to `string` or `Uint8Array`.
Chunks might be Buffer, Uint8Array or strings since:
- `subprocess.stdout|stderr` emits Buffers
- `subprocess.stdin.write()` accepts Buffer, Uint8Array or string
- Previous generators might return Uint8Array or string

However, those are converted to Buffer:
- on writes: `Duplex.writable` `decodeStrings: true` default option
- on reads: `Duplex.readable` `readableEncoding: null` default option
*/
const getEncodingTransformGenerator = (binary, encoding, skipped) => {
	if (skipped) {
		return;
	}

	if (binary) {
		return {transform: encodingUint8ArrayGenerator.bind(undefined, new TextEncoder())};
	}

	const stringDecoder = new StringDecoder(encoding);
	return {
		transform: encodingStringGenerator.bind(undefined, stringDecoder),
		final: encodingStringFinal.bind(undefined, stringDecoder),
	};
};

const encodingUint8ArrayGenerator = function * (textEncoder, chunk) {
	if (Buffer$1.isBuffer(chunk)) {
		yield bufferToUint8Array(chunk);
	} else if (typeof chunk === 'string') {
		yield textEncoder.encode(chunk);
	} else {
		yield chunk;
	}
};

const encodingStringGenerator = function * (stringDecoder, chunk) {
	yield isUint8Array(chunk) ? stringDecoder.write(chunk) : chunk;
};

const encodingStringFinal = function * (stringDecoder) {
	const lastChunk = stringDecoder.end();
	if (lastChunk !== '') {
		yield lastChunk;
	}
};

// Applies a series of generator functions asynchronously
const pushChunks = callbackify(async (getChunks, state, getChunksArguments, transformStream) => {
	state.currentIterable = getChunks(...getChunksArguments);

	try {
		for await (const chunk of state.currentIterable) {
			transformStream.push(chunk);
		}
	} finally {
		delete state.currentIterable;
	}
});

// For each new chunk, apply each `transform()` method
const transformChunk = async function * (chunk, generators, index) {
	if (index === generators.length) {
		yield chunk;
		return;
	}

	const {transform = identityGenerator$1} = generators[index];
	for await (const transformedChunk of transform(chunk)) {
		yield * transformChunk(transformedChunk, generators, index + 1);
	}
};

// At the end, apply each `final()` method, followed by the `transform()` method of the next transforms
const finalChunks = async function * (generators) {
	for (const [index, {final}] of Object.entries(generators)) {
		yield * generatorFinalChunks(final, Number(index), generators);
	}
};

const generatorFinalChunks = async function * (final, index, generators) {
	if (final === undefined) {
		return;
	}

	for await (const finalChunk of final()) {
		yield * transformChunk(finalChunk, generators, index + 1);
	}
};

// Cancel any ongoing async generator when the Transform is destroyed, e.g. when the subprocess errors
const destroyTransform = callbackify(async ({currentIterable}, error) => {
	if (currentIterable !== undefined) {
		await (error ? currentIterable.throw(error) : currentIterable.return());
		return;
	}

	if (error) {
		throw error;
	}
});

const identityGenerator$1 = function * (chunk) {
	yield chunk;
};

// Duplicate the code from `run-async.js` but as synchronous functions
const pushChunksSync = (getChunksSync, getChunksArguments, transformStream, done) => {
	try {
		for (const chunk of getChunksSync(...getChunksArguments)) {
			transformStream.push(chunk);
		}

		done();
	} catch (error) {
		done(error);
	}
};

// Run synchronous generators with `execaSync()`
const runTransformSync = (generators, chunks) => [
	...chunks.flatMap(chunk => [...transformChunkSync(chunk, generators, 0)]),
	...finalChunksSync(generators),
];

const transformChunkSync = function * (chunk, generators, index) {
	if (index === generators.length) {
		yield chunk;
		return;
	}

	const {transform = identityGenerator} = generators[index];
	for (const transformedChunk of transform(chunk)) {
		yield * transformChunkSync(transformedChunk, generators, index + 1);
	}
};

const finalChunksSync = function * (generators) {
	for (const [index, {final}] of Object.entries(generators)) {
		yield * generatorFinalChunksSync(final, Number(index), generators);
	}
};

const generatorFinalChunksSync = function * (final, index, generators) {
	if (final === undefined) {
		return;
	}

	for (const finalChunk of final()) {
		yield * transformChunkSync(finalChunk, generators, index + 1);
	}
};

const identityGenerator = function * (chunk) {
	yield chunk;
};

/*
Generators can be used to transform/filter standard streams.

Generators have a simple syntax, yet allows all of the following:
- Sharing `state` between chunks
- Flushing logic, by using a `final` function
- Asynchronous logic
- Emitting multiple chunks from a single source chunk, even if spaced in time, by using multiple `yield`
- Filtering, by using no `yield`

Therefore, there is no need to allow Node.js or web transform streams.

The `highWaterMark` is kept as the default value, since this is what `subprocess.std*` uses.

Chunks are currently processed serially. We could add a `concurrency` option to parallelize in the future.

Transform an array of generator functions into a `Transform` stream.
`Duplex.from(generator)` cannot be used because it does not allow setting the `objectMode` and `highWaterMark`.
*/
const generatorToStream = ({
	value,
	value: {transform, final, writableObjectMode, readableObjectMode},
	optionName,
}, {encoding}) => {
	const state = {};
	const generators = addInternalGenerators(value, encoding, optionName);

	const transformAsync = isAsyncGenerator(transform);
	const finalAsync = isAsyncGenerator(final);
	const transformMethod = transformAsync
		? pushChunks.bind(undefined, transformChunk, state)
		: pushChunksSync.bind(undefined, transformChunkSync);
	const finalMethod = transformAsync || finalAsync
		? pushChunks.bind(undefined, finalChunks, state)
		: pushChunksSync.bind(undefined, finalChunksSync);
	const destroyMethod = transformAsync || finalAsync
		? destroyTransform.bind(undefined, state)
		: undefined;

	const stream = new Transform({
		writableObjectMode,
		writableHighWaterMark: getDefaultHighWaterMark(writableObjectMode),
		readableObjectMode,
		readableHighWaterMark: getDefaultHighWaterMark(readableObjectMode),
		transform(chunk, encoding, done) {
			transformMethod([chunk, generators, 0], this, done);
		},
		flush(done) {
			finalMethod([generators], this, done);
		},
		destroy: destroyMethod,
	});
	return {stream};
};

// Applies transform generators in sync mode
const runGeneratorsSync = (chunks, stdioItems, encoding, isInput) => {
	const generators = stdioItems.filter(({type}) => type === 'generator');
	const reversedGenerators = isInput ? generators.reverse() : generators;

	for (const {value, optionName} of reversedGenerators) {
		const generators = addInternalGenerators(value, encoding, optionName);
		chunks = runTransformSync(generators, chunks);
	}

	return chunks;
};

// Generators used internally to convert the chunk type, validate it, and split into lines
const addInternalGenerators = (
	{transform, final, binary, writableObjectMode, readableObjectMode, preserveNewlines},
	encoding,
	optionName,
) => {
	const state = {};
	return [
		{transform: getValidateTransformInput(writableObjectMode, optionName)},
		getEncodingTransformGenerator(binary, encoding, writableObjectMode),
		getSplitLinesGenerator(binary, preserveNewlines, writableObjectMode, state),
		{transform, final},
		{transform: getValidateTransformReturn(readableObjectMode, optionName)},
		getAppendNewlineGenerator({
			binary,
			preserveNewlines,
			readableObjectMode,
			state,
		}),
	].filter(Boolean);
};

// Apply `stdin`/`input`/`inputFile` options, before spawning, in sync mode, by converting it to the `input` option
const addInputOptionsSync = (fileDescriptors, options) => {
	for (const fdNumber of getInputFdNumbers(fileDescriptors)) {
		addInputOptionSync(fileDescriptors, fdNumber, options);
	}
};

const getInputFdNumbers = fileDescriptors => new Set(Object.entries(fileDescriptors)
	.filter(([, {direction}]) => direction === 'input')
	.map(([fdNumber]) => Number(fdNumber)));

const addInputOptionSync = (fileDescriptors, fdNumber, options) => {
	const {stdioItems} = fileDescriptors[fdNumber];
	const allStdioItems = stdioItems.filter(({contents}) => contents !== undefined);
	if (allStdioItems.length === 0) {
		return;
	}

	if (fdNumber !== 0) {
		const [{type, optionName}] = allStdioItems;
		throw new TypeError(`Only the \`stdin\` option, not \`${optionName}\`, can be ${TYPE_TO_MESSAGE[type]} with synchronous methods.`);
	}

	const allContents = allStdioItems.map(({contents}) => contents);
	const transformedContents = allContents.map(contents => applySingleInputGeneratorsSync(contents, stdioItems));
	options.input = joinToUint8Array(transformedContents);
};

const applySingleInputGeneratorsSync = (contents, stdioItems) => {
	const newContents = runGeneratorsSync(contents, stdioItems, 'utf8', true);
	validateSerializable(newContents);
	return joinToUint8Array(newContents);
};

const validateSerializable = newContents => {
	const invalidItem = newContents.find(item => typeof item !== 'string' && !isUint8Array(item));
	if (invalidItem !== undefined) {
		throw new TypeError(`The \`stdin\` option is invalid: when passing objects as input, a transform must be used to serialize them to strings or Uint8Arrays: ${invalidItem}.`);
	}
};

// `ignore` opts-out of `verbose` for a specific stream.
// `ipc` cannot use piping.
// `inherit` would result in double printing.
// They can also lead to double printing when passing file descriptor integers or `process.std*`.
// This only leaves with `pipe` and `overlapped`.
const shouldLogOutput = ({stdioItems, encoding, verboseInfo, fdNumber}) => fdNumber !== 'all'
	&& isFullVerbose(verboseInfo, fdNumber)
	&& !BINARY_ENCODINGS.has(encoding)
	&& fdUsesVerbose(fdNumber)
	&& (stdioItems.some(({type, value}) => type === 'native' && PIPED_STDIO_VALUES.has(value))
	|| stdioItems.every(({type}) => TRANSFORM_TYPES.has(type)));

// Printing input streams would be confusing.
// Files and streams can produce big outputs, which we don't want to print.
// We could print `stdio[3+]` but it often is redirected to files and streams, with the same issue.
// So we only print stdout and stderr.
const fdUsesVerbose = fdNumber => fdNumber === 1 || fdNumber === 2;

const PIPED_STDIO_VALUES = new Set(['pipe', 'overlapped']);

// `verbose: 'full'` printing logic with async methods
const logLines = async (linesIterable, stream, fdNumber, verboseInfo) => {
	for await (const line of linesIterable) {
		if (!isPipingStream(stream)) {
			logLine(line, fdNumber, verboseInfo);
		}
	}
};

// `verbose: 'full'` printing logic with sync methods
const logLinesSync = (linesArray, fdNumber, verboseInfo) => {
	for (const line of linesArray) {
		logLine(line, fdNumber, verboseInfo);
	}
};

// When `subprocess.stdout|stderr.pipe()` is called, `verbose` becomes a noop.
// This prevents the following problems:
//  - `.pipe()` achieves the same result as using `stdout: 'inherit'`, `stdout: stream`, etc. which also make `verbose` a noop.
//    For example, `subprocess.stdout.pipe(process.stdin)` would print each line twice.
//  - When chaining subprocesses with `subprocess.pipe(otherSubprocess)`, only the last one should print its output.
// Detecting whether `.pipe()` is impossible without monkey-patching it, so we use the following undocumented property.
// This is not a critical behavior since changes of the following property would only make `verbose` more verbose.
const isPipingStream = stream => stream._readableState.pipes.length > 0;

// When `verbose` is `full`, print stdout|stderr
const logLine = (line, fdNumber, verboseInfo) => {
	const verboseMessage = serializeVerboseMessage(line);
	verboseLog({
		type: 'output',
		verboseMessage,
		fdNumber,
		verboseInfo,
	});
};

// Apply `stdout`/`stderr` options, after spawning, in sync mode
const transformOutputSync = ({fileDescriptors, syncResult: {output}, options, isMaxBuffer, verboseInfo}) => {
	if (output === null) {
		return {output: Array.from({length: 3})};
	}

	const state = {};
	const outputFiles = new Set([]);
	const transformedOutput = output.map((result, fdNumber) =>
		transformOutputResultSync({
			result,
			fileDescriptors,
			fdNumber,
			state,
			outputFiles,
			isMaxBuffer,
			verboseInfo,
		}, options));
	return {output: transformedOutput, ...state};
};

const transformOutputResultSync = (
	{result, fileDescriptors, fdNumber, state, outputFiles, isMaxBuffer, verboseInfo},
	{buffer, encoding, lines, stripFinalNewline, maxBuffer},
) => {
	if (result === null) {
		return;
	}

	const truncatedResult = truncateMaxBufferSync(result, isMaxBuffer, maxBuffer);
	const uint8ArrayResult = bufferToUint8Array(truncatedResult);
	const {stdioItems, objectMode} = fileDescriptors[fdNumber];
	const chunks = runOutputGeneratorsSync([uint8ArrayResult], stdioItems, encoding, state);
	const {serializedResult, finalResult = serializedResult} = serializeChunks({
		chunks,
		objectMode,
		encoding,
		lines,
		stripFinalNewline,
		fdNumber,
	});

	logOutputSync({
		serializedResult,
		fdNumber,
		state,
		verboseInfo,
		encoding,
		stdioItems,
		objectMode,
	});

	const returnedResult = buffer[fdNumber] ? finalResult : undefined;

	try {
		if (state.error === undefined) {
			writeToFiles(serializedResult, stdioItems, outputFiles);
		}

		return returnedResult;
	} catch (error) {
		state.error = error;
		return returnedResult;
	}
};

// Applies transform generators to `stdout`/`stderr`
const runOutputGeneratorsSync = (chunks, stdioItems, encoding, state) => {
	try {
		return runGeneratorsSync(chunks, stdioItems, encoding, false);
	} catch (error) {
		state.error = error;
		return chunks;
	}
};

// The contents is converted to three stages:
//  - serializedResult: used when the target is a file path/URL or a file descriptor (including 'inherit')
//  - finalResult/returnedResult: returned as `result.std*`
const serializeChunks = ({chunks, objectMode, encoding, lines, stripFinalNewline, fdNumber}) => {
	if (objectMode) {
		return {serializedResult: chunks};
	}

	if (encoding === 'buffer') {
		return {serializedResult: joinToUint8Array(chunks)};
	}

	const serializedResult = joinToString(chunks, encoding);
	if (lines[fdNumber]) {
		return {serializedResult, finalResult: splitLinesSync(serializedResult, !stripFinalNewline[fdNumber], objectMode)};
	}

	return {serializedResult};
};

const logOutputSync = ({serializedResult, fdNumber, state, verboseInfo, encoding, stdioItems, objectMode}) => {
	if (!shouldLogOutput({
		stdioItems,
		encoding,
		verboseInfo,
		fdNumber,
	})) {
		return;
	}

	const linesArray = splitLinesSync(serializedResult, false, objectMode);

	try {
		logLinesSync(linesArray, fdNumber, verboseInfo);
	} catch (error) {
		state.error ??= error;
	}
};

// When the `std*` target is a file path/URL or a file descriptor
const writeToFiles = (serializedResult, stdioItems, outputFiles) => {
	for (const {path, append} of stdioItems.filter(({type}) => FILE_TYPES.has(type))) {
		const pathString = typeof path === 'string' ? path : path.toString();
		if (append || outputFiles.has(pathString)) {
			appendFileSync(path, serializedResult);
		} else {
			outputFiles.add(pathString);
			writeFileSync(path, serializedResult);
		}
	}
};

// Retrieve `result.all` with synchronous methods
const getAllSync = ([, stdout, stderr], options) => {
	if (!options.all) {
		return;
	}

	if (stdout === undefined) {
		return stderr;
	}

	if (stderr === undefined) {
		return stdout;
	}

	if (Array.isArray(stdout)) {
		return Array.isArray(stderr)
			? [...stdout, ...stderr]
			: [...stdout, stripNewline(stderr, options, 'all')];
	}

	if (Array.isArray(stderr)) {
		return [stripNewline(stdout, options, 'all'), ...stderr];
	}

	if (isUint8Array(stdout) && isUint8Array(stderr)) {
		return concatUint8Arrays([stdout, stderr]);
	}

	return `${stdout}${stderr}`;
};

// If `error` is emitted before `spawn`, `exit` will never be emitted.
// However, `error` might be emitted after `spawn`.
// In that case, `exit` will still be emitted.
// Since the `exit` event contains the signal name, we want to make sure we are listening for it.
// This function also takes into account the following unlikely cases:
//  - `exit` being emitted in the same microtask as `spawn`
//  - `error` being emitted multiple times
const waitForExit = async (subprocess, context) => {
	const [exitCode, signal] = await waitForExitOrError(subprocess);
	context.isForcefullyTerminated ??= false;
	return [exitCode, signal];
};

const waitForExitOrError = async subprocess => {
	const [spawnPayload, exitPayload] = await Promise.allSettled([
		once(subprocess, 'spawn'),
		once(subprocess, 'exit'),
	]);

	if (spawnPayload.status === 'rejected') {
		return [];
	}

	return exitPayload.status === 'rejected'
		? waitForSubprocessExit(subprocess)
		: exitPayload.value;
};

const waitForSubprocessExit = async subprocess => {
	try {
		return await once(subprocess, 'exit');
	} catch {
		return waitForSubprocessExit(subprocess);
	}
};

// Retrieve the final exit code and|or signal name
const waitForSuccessfulExit = async exitPromise => {
	const [exitCode, signal] = await exitPromise;

	if (!isSubprocessErrorExit(exitCode, signal) && isFailedExit(exitCode, signal)) {
		throw new DiscardedError();
	}

	return [exitCode, signal];
};

// When the subprocess fails due to an `error` event
const isSubprocessErrorExit = (exitCode, signal) => exitCode === undefined && signal === undefined;
// When the subprocess fails due to a non-0 exit code or to a signal termination
const isFailedExit = (exitCode, signal) => exitCode !== 0 || signal !== null;

// Retrieve exit code, signal name and error information, with synchronous methods
const getExitResultSync = ({error, status: exitCode, signal, output}, {maxBuffer}) => {
	const resultError = getResultError(error, exitCode, signal);
	const timedOut = resultError?.code === 'ETIMEDOUT';
	const isMaxBuffer = isMaxBufferSync(resultError, output, maxBuffer);
	return {
		resultError,
		exitCode,
		signal,
		timedOut,
		isMaxBuffer,
	};
};

const getResultError = (error, exitCode, signal) => {
	if (error !== undefined) {
		return error;
	}

	return isFailedExit(exitCode, signal) ? new DiscardedError() : undefined;
};

// Main shared logic for all sync methods: `execaSync()`, `$.sync()`
const execaCoreSync = (rawFile, rawArguments, rawOptions) => {
	const {file, commandArguments, command, escapedCommand, startTime, verboseInfo, options, fileDescriptors} = handleSyncArguments(rawFile, rawArguments, rawOptions);
	const result = spawnSubprocessSync({
		file,
		commandArguments,
		options,
		command,
		escapedCommand,
		verboseInfo,
		fileDescriptors,
		startTime,
	});
	return handleResult(result, verboseInfo, options);
};

// Compute arguments to pass to `child_process.spawnSync()`
const handleSyncArguments = (rawFile, rawArguments, rawOptions) => {
	const {command, escapedCommand, startTime, verboseInfo} = handleCommand(rawFile, rawArguments, rawOptions);
	const syncOptions = normalizeSyncOptions(rawOptions);
	const {file, commandArguments, options} = normalizeOptions(rawFile, rawArguments, syncOptions);
	validateSyncOptions(options);
	const fileDescriptors = handleStdioSync(options, verboseInfo);
	return {
		file,
		commandArguments,
		command,
		escapedCommand,
		startTime,
		verboseInfo,
		options,
		fileDescriptors,
	};
};

// Options normalization logic specific to sync methods
const normalizeSyncOptions = options => options.node && !options.ipc ? {...options, ipc: false} : options;

// Options validation logic specific to sync methods
const validateSyncOptions = ({ipc, ipcInput, detached, cancelSignal}) => {
	if (ipcInput) {
		throwInvalidSyncOption('ipcInput');
	}

	if (ipc) {
		throwInvalidSyncOption('ipc: true');
	}

	if (detached) {
		throwInvalidSyncOption('detached: true');
	}

	if (cancelSignal) {
		throwInvalidSyncOption('cancelSignal');
	}
};

const throwInvalidSyncOption = value => {
	throw new TypeError(`The "${value}" option cannot be used with synchronous methods.`);
};

const spawnSubprocessSync = ({file, commandArguments, options, command, escapedCommand, verboseInfo, fileDescriptors, startTime}) => {
	const syncResult = runSubprocessSync({
		file,
		commandArguments,
		options,
		command,
		escapedCommand,
		fileDescriptors,
		startTime,
	});
	if (syncResult.failed) {
		return syncResult;
	}

	const {resultError, exitCode, signal, timedOut, isMaxBuffer} = getExitResultSync(syncResult, options);
	const {output, error = resultError} = transformOutputSync({
		fileDescriptors,
		syncResult,
		options,
		isMaxBuffer,
		verboseInfo,
	});
	const stdio = output.map((stdioOutput, fdNumber) => stripNewline(stdioOutput, options, fdNumber));
	const all = stripNewline(getAllSync(output, options), options, 'all');
	return getSyncResult({
		error,
		exitCode,
		signal,
		timedOut,
		isMaxBuffer,
		stdio,
		all,
		options,
		command,
		escapedCommand,
		startTime,
	});
};

const runSubprocessSync = ({file, commandArguments, options, command, escapedCommand, fileDescriptors, startTime}) => {
	try {
		addInputOptionsSync(fileDescriptors, options);
		const normalizedOptions = normalizeSpawnSyncOptions(options);
		return spawnSync(...concatenateShell(file, commandArguments, normalizedOptions));
	} catch (error) {
		return makeEarlyError({
			error,
			command,
			escapedCommand,
			fileDescriptors,
			options,
			startTime,
			isSync: true,
		});
	}
};

// The `encoding` option is handled by Execa, not by `child_process.spawnSync()`
const normalizeSpawnSyncOptions = ({encoding, maxBuffer, ...options}) => ({...options, encoding: 'buffer', maxBuffer: getMaxBufferSync(maxBuffer)});

const getSyncResult = ({error, exitCode, signal, timedOut, isMaxBuffer, stdio, all, options, command, escapedCommand, startTime}) => error === undefined
	? makeSuccessResult({
		command,
		escapedCommand,
		stdio,
		all,
		ipcOutput: [],
		options,
		startTime,
	})
	: makeError({
		error,
		command,
		escapedCommand,
		timedOut,
		isCanceled: false,
		isGracefullyCanceled: false,
		isMaxBuffer,
		isForcefullyTerminated: false,
		exitCode,
		signal,
		stdio,
		all,
		ipcOutput: [],
		options,
		startTime,
		isSync: true,
	});

// Like `[sub]process.once('message')` but promise-based
const getOneMessage = ({anyProcess, channel, isSubprocess, ipc}, {reference = true, filter} = {}) => {
	validateIpcMethod({
		methodName: 'getOneMessage',
		isSubprocess,
		ipc,
		isConnected: isConnected(anyProcess),
	});

	return getOneMessageAsync({
		anyProcess,
		channel,
		isSubprocess,
		filter,
		reference,
	});
};

const getOneMessageAsync = async ({anyProcess, channel, isSubprocess, filter, reference}) => {
	addReference(channel, reference);
	const ipcEmitter = getIpcEmitter(anyProcess, channel, isSubprocess);
	const controller = new AbortController();
	try {
		return await Promise.race([
			getMessage(ipcEmitter, filter, controller),
			throwOnDisconnect(ipcEmitter, isSubprocess, controller),
			throwOnStrictError(ipcEmitter, isSubprocess, controller),
		]);
	} catch (error) {
		disconnect(anyProcess);
		throw error;
	} finally {
		controller.abort();
		removeReference(channel, reference);
	}
};

const getMessage = async (ipcEmitter, filter, {signal}) => {
	if (filter === undefined) {
		const [message] = await once(ipcEmitter, 'message', {signal});
		return message;
	}

	for await (const [message] of on(ipcEmitter, 'message', {signal})) {
		if (filter(message)) {
			return message;
		}
	}
};

const throwOnDisconnect = async (ipcEmitter, isSubprocess, {signal}) => {
	await once(ipcEmitter, 'disconnect', {signal});
	throwOnEarlyDisconnect(isSubprocess);
};

const throwOnStrictError = async (ipcEmitter, isSubprocess, {signal}) => {
	const [error] = await once(ipcEmitter, 'strict:error', {signal});
	throw getStrictResponseError(error, isSubprocess);
};

// Like `[sub]process.on('message')` but promise-based
const getEachMessage = ({anyProcess, channel, isSubprocess, ipc}, {reference = true} = {}) => loopOnMessages({
	anyProcess,
	channel,
	isSubprocess,
	ipc,
	shouldAwait: !isSubprocess,
	reference,
});

// Same but used internally
const loopOnMessages = ({anyProcess, channel, isSubprocess, ipc, shouldAwait, reference}) => {
	validateIpcMethod({
		methodName: 'getEachMessage',
		isSubprocess,
		ipc,
		isConnected: isConnected(anyProcess),
	});

	addReference(channel, reference);
	const ipcEmitter = getIpcEmitter(anyProcess, channel, isSubprocess);
	const controller = new AbortController();
	const state = {};
	stopOnDisconnect(anyProcess, ipcEmitter, controller);
	abortOnStrictError({
		ipcEmitter,
		isSubprocess,
		controller,
		state,
	});
	return iterateOnMessages({
		anyProcess,
		channel,
		ipcEmitter,
		isSubprocess,
		shouldAwait,
		controller,
		state,
		reference,
	});
};

const stopOnDisconnect = async (anyProcess, ipcEmitter, controller) => {
	try {
		await once(ipcEmitter, 'disconnect', {signal: controller.signal});
		controller.abort();
	} catch {}
};

const abortOnStrictError = async ({ipcEmitter, isSubprocess, controller, state}) => {
	try {
		const [error] = await once(ipcEmitter, 'strict:error', {signal: controller.signal});
		state.error = getStrictResponseError(error, isSubprocess);
		controller.abort();
	} catch {}
};

const iterateOnMessages = async function * ({anyProcess, channel, ipcEmitter, isSubprocess, shouldAwait, controller, state, reference}) {
	try {
		for await (const [message] of on(ipcEmitter, 'message', {signal: controller.signal})) {
			throwIfStrictError(state);
			yield message;
		}
	} catch {
		throwIfStrictError(state);
	} finally {
		controller.abort();
		removeReference(channel, reference);

		if (!isSubprocess) {
			disconnect(anyProcess);
		}

		if (shouldAwait) {
			await anyProcess;
		}
	}
};

const throwIfStrictError = ({error}) => {
	if (error) {
		throw error;
	}
};

// Add promise-based IPC methods in current process
const addIpcMethods = (subprocess, {ipc}) => {
	Object.assign(subprocess, getIpcMethods(subprocess, false, ipc));
};

// Get promise-based IPC in the subprocess
const getIpcExport = () => {
	const anyProcess = process$2;
	const isSubprocess = true;
	const ipc = process$2.channel !== undefined;

	return {
		...getIpcMethods(anyProcess, isSubprocess, ipc),
		getCancelSignal: getCancelSignal.bind(undefined, {
			anyProcess,
			channel: anyProcess.channel,
			isSubprocess,
			ipc,
		}),
	};
};

// Retrieve the `ipc` shared by both the current process and the subprocess
const getIpcMethods = (anyProcess, isSubprocess, ipc) => ({
	sendMessage: sendMessage.bind(undefined, {
		anyProcess,
		channel: anyProcess.channel,
		isSubprocess,
		ipc,
	}),
	getOneMessage: getOneMessage.bind(undefined, {
		anyProcess,
		channel: anyProcess.channel,
		isSubprocess,
		ipc,
	}),
	getEachMessage: getEachMessage.bind(undefined, {
		anyProcess,
		channel: anyProcess.channel,
		isSubprocess,
		ipc,
	}),
});

// When the subprocess fails to spawn.
// We ensure the returned error is always both a promise and a subprocess.
const handleEarlyError = ({error, command, escapedCommand, fileDescriptors, options, startTime, verboseInfo}) => {
	cleanupCustomStreams(fileDescriptors);

	const subprocess = new ChildProcess();
	createDummyStreams(subprocess, fileDescriptors);
	Object.assign(subprocess, {readable, writable, duplex});

	const earlyError = makeEarlyError({
		error,
		command,
		escapedCommand,
		fileDescriptors,
		options,
		startTime,
		isSync: false,
	});
	const promise = handleDummyPromise(earlyError, verboseInfo, options);
	return {subprocess, promise};
};

const createDummyStreams = (subprocess, fileDescriptors) => {
	const stdin = createDummyStream();
	const stdout = createDummyStream();
	const stderr = createDummyStream();
	const extraStdio = Array.from({length: fileDescriptors.length - 3}, createDummyStream);
	const all = createDummyStream();
	const stdio = [stdin, stdout, stderr, ...extraStdio];
	Object.assign(subprocess, {
		stdin,
		stdout,
		stderr,
		all,
		stdio,
	});
};

const createDummyStream = () => {
	const stream = new PassThrough();
	stream.end();
	return stream;
};

const readable = () => new Readable({read() {}});
const writable = () => new Writable({write() {}});
const duplex = () => new Duplex({read() {}, write() {}});

const handleDummyPromise = async (error, verboseInfo, options) => handleResult(error, verboseInfo, options);

// Handle `input`, `inputFile`, `stdin`, `stdout` and `stderr` options, before spawning, in async mode
const handleStdioAsync = (options, verboseInfo) => handleStdio(addPropertiesAsync, options, verboseInfo, false);

const forbiddenIfAsync = ({type, optionName}) => {
	throw new TypeError(`The \`${optionName}\` option cannot be ${TYPE_TO_MESSAGE[type]}.`);
};

// Create streams used internally for piping when using specific values for the `std*` options, in async mode.
// For example, `stdout: {file}` creates a file stream, which is piped from/to.
const addProperties = {
	fileNumber: forbiddenIfAsync,
	generator: generatorToStream,
	asyncGenerator: generatorToStream,
	nodeStream: ({value}) => ({stream: value}),
	webTransform({value: {transform, writableObjectMode, readableObjectMode}}) {
		const objectMode = writableObjectMode || readableObjectMode;
		const stream = Duplex.fromWeb(transform, {objectMode});
		return {stream};
	},
	duplex: ({value: {transform}}) => ({stream: transform}),
	native() {},
};

const addPropertiesAsync = {
	input: {
		...addProperties,
		fileUrl: ({value}) => ({stream: createReadStream(value)}),
		filePath: ({value: {file}}) => ({stream: createReadStream(file)}),
		webStream: ({value}) => ({stream: Readable.fromWeb(value)}),
		iterable: ({value}) => ({stream: Readable.from(value)}),
		asyncIterable: ({value}) => ({stream: Readable.from(value)}),
		string: ({value}) => ({stream: Readable.from(value)}),
		uint8Array: ({value}) => ({stream: Readable.from(Buffer$1.from(value))}),
	},
	output: {
		...addProperties,
		fileUrl: ({value}) => ({stream: createWriteStream(value)}),
		filePath: ({value: {file, append}}) => ({stream: createWriteStream(file, append ? {flags: 'a'} : {})}),
		webStream: ({value}) => ({stream: Writable.fromWeb(value)}),
		iterable: forbiddenIfAsync,
		asyncIterable: forbiddenIfAsync,
		string: forbiddenIfAsync,
		uint8Array: forbiddenIfAsync,
	},
};

function mergeStreams(streams) {
	if (!Array.isArray(streams)) {
		throw new TypeError(`Expected an array, got \`${typeof streams}\`.`);
	}

	for (const stream of streams) {
		validateStream(stream);
	}

	const objectMode = streams.some(({readableObjectMode}) => readableObjectMode);
	const highWaterMark = getHighWaterMark(streams, objectMode);
	const passThroughStream = new MergedStream({
		objectMode,
		writableHighWaterMark: highWaterMark,
		readableHighWaterMark: highWaterMark,
	});

	for (const stream of streams) {
		passThroughStream.add(stream);
	}

	return passThroughStream;
}

const getHighWaterMark = (streams, objectMode) => {
	if (streams.length === 0) {
		return getDefaultHighWaterMark(objectMode);
	}

	const highWaterMarks = streams
		.filter(({readableObjectMode}) => readableObjectMode === objectMode)
		.map(({readableHighWaterMark}) => readableHighWaterMark);
	return Math.max(...highWaterMarks);
};

class MergedStream extends PassThrough {
	#streams = new Set([]);
	#ended = new Set([]);
	#aborted = new Set([]);
	#onFinished;
	#unpipeEvent = Symbol('unpipe');
	#streamPromises = new WeakMap();

	add(stream) {
		validateStream(stream);

		if (this.#streams.has(stream)) {
			return;
		}

		this.#streams.add(stream);

		this.#onFinished ??= onMergedStreamFinished(this, this.#streams, this.#unpipeEvent);
		const streamPromise = endWhenStreamsDone({
			passThroughStream: this,
			stream,
			streams: this.#streams,
			ended: this.#ended,
			aborted: this.#aborted,
			onFinished: this.#onFinished,
			unpipeEvent: this.#unpipeEvent,
		});
		this.#streamPromises.set(stream, streamPromise);

		stream.pipe(this, {end: false});
	}

	async remove(stream) {
		validateStream(stream);

		if (!this.#streams.has(stream)) {
			return false;
		}

		const streamPromise = this.#streamPromises.get(stream);
		if (streamPromise === undefined) {
			return false;
		}

		this.#streamPromises.delete(stream);

		stream.unpipe(this);
		await streamPromise;
		return true;
	}
}

const onMergedStreamFinished = async (passThroughStream, streams, unpipeEvent) => {
	updateMaxListeners(passThroughStream, PASSTHROUGH_LISTENERS_COUNT);
	const controller = new AbortController();

	try {
		await Promise.race([
			onMergedStreamEnd(passThroughStream, controller),
			onInputStreamsUnpipe(passThroughStream, streams, unpipeEvent, controller),
		]);
	} finally {
		controller.abort();
		updateMaxListeners(passThroughStream, -2);
	}
};

const onMergedStreamEnd = async (passThroughStream, {signal}) => {
	try {
		await finished(passThroughStream, {signal, cleanup: true});
	} catch (error) {
		errorOrAbortStream(passThroughStream, error);
		throw error;
	}
};

const onInputStreamsUnpipe = async (passThroughStream, streams, unpipeEvent, {signal}) => {
	for await (const [unpipedStream] of on(passThroughStream, 'unpipe', {signal})) {
		if (streams.has(unpipedStream)) {
			unpipedStream.emit(unpipeEvent);
		}
	}
};

const validateStream = stream => {
	if (typeof stream?.pipe !== 'function') {
		throw new TypeError(`Expected a readable stream, got: \`${typeof stream}\`.`);
	}
};

const endWhenStreamsDone = async ({passThroughStream, stream, streams, ended, aborted, onFinished, unpipeEvent}) => {
	updateMaxListeners(passThroughStream, PASSTHROUGH_LISTENERS_PER_STREAM);
	const controller = new AbortController();

	try {
		await Promise.race([
			afterMergedStreamFinished(onFinished, stream, controller),
			onInputStreamEnd({
				passThroughStream,
				stream,
				streams,
				ended,
				aborted,
				controller,
			}),
			onInputStreamUnpipe({
				stream,
				streams,
				ended,
				aborted,
				unpipeEvent,
				controller,
			}),
		]);
	} finally {
		controller.abort();
		updateMaxListeners(passThroughStream, -1);
	}

	if (streams.size > 0 && streams.size === ended.size + aborted.size) {
		if (ended.size === 0 && aborted.size > 0) {
			abortStream(passThroughStream);
		} else {
			endStream(passThroughStream);
		}
	}
};

const afterMergedStreamFinished = async (onFinished, stream, {signal}) => {
	try {
		await onFinished;
		if (!signal.aborted) {
			abortStream(stream);
		}
	} catch (error) {
		if (!signal.aborted) {
			errorOrAbortStream(stream, error);
		}
	}
};

const onInputStreamEnd = async ({passThroughStream, stream, streams, ended, aborted, controller: {signal}}) => {
	try {
		await finished(stream, {
			signal,
			cleanup: true,
			readable: true,
			writable: false,
		});
		if (streams.has(stream)) {
			ended.add(stream);
		}
	} catch (error) {
		if (signal.aborted || !streams.has(stream)) {
			return;
		}

		if (isAbortError(error)) {
			aborted.add(stream);
		} else {
			errorStream(passThroughStream, error);
		}
	}
};

const onInputStreamUnpipe = async ({stream, streams, ended, aborted, unpipeEvent, controller: {signal}}) => {
	await once(stream, unpipeEvent, {signal});

	if (!stream.readable) {
		return once(signal, 'abort', {signal});
	}

	streams.delete(stream);
	ended.delete(stream);
	aborted.delete(stream);
};

const endStream = stream => {
	if (stream.writable) {
		stream.end();
	}
};

const errorOrAbortStream = (stream, error) => {
	if (isAbortError(error)) {
		abortStream(stream);
	} else {
		errorStream(stream, error);
	}
};

// This is the error thrown by `finished()` on `stream.destroy()`
const isAbortError = error => error?.code === 'ERR_STREAM_PREMATURE_CLOSE';

const abortStream = stream => {
	if (stream.readable || stream.writable) {
		stream.destroy();
	}
};

// `stream.destroy(error)` crashes the process with `uncaughtException` if no `error` event listener exists on `stream`.
// We take care of error handling on user behalf, so we do not want this to happen.
const errorStream = (stream, error) => {
	if (!stream.destroyed) {
		stream.once('error', noop);
		stream.destroy(error);
	}
};

const noop = () => {};

const updateMaxListeners = (passThroughStream, increment) => {
	const maxListeners = passThroughStream.getMaxListeners();
	if (maxListeners !== 0 && maxListeners !== Number.POSITIVE_INFINITY) {
		passThroughStream.setMaxListeners(maxListeners + increment);
	}
};

// Number of times `passThroughStream.on()` is called regardless of streams:
//  - once due to `finished(passThroughStream)`
//  - once due to `on(passThroughStream)`
const PASSTHROUGH_LISTENERS_COUNT = 2;

// Number of times `passThroughStream.on()` is called per stream:
//  - once due to `stream.pipe(passThroughStream)`
const PASSTHROUGH_LISTENERS_PER_STREAM = 1;

// Similar to `Stream.pipeline(source, destination)`, but does not destroy standard streams
const pipeStreams = (source, destination) => {
	source.pipe(destination);
	onSourceFinish(source, destination);
	onDestinationFinish(source, destination);
};

// `source.pipe(destination)` makes `destination` end when `source` ends.
// But it does not propagate aborts or errors. This function does it.
const onSourceFinish = async (source, destination) => {
	if (isStandardStream(source) || isStandardStream(destination)) {
		return;
	}

	try {
		await finished(source, {cleanup: true, readable: true, writable: false});
	} catch {}

	endDestinationStream(destination);
};

const endDestinationStream = destination => {
	if (destination.writable) {
		destination.end();
	}
};

// We do the same thing in the other direction as well.
const onDestinationFinish = async (source, destination) => {
	if (isStandardStream(source) || isStandardStream(destination)) {
		return;
	}

	try {
		await finished(destination, {cleanup: true, readable: false, writable: true});
	} catch {}

	abortSourceStream(source);
};

const abortSourceStream = source => {
	if (source.readable) {
		source.destroy();
	}
};

// Handle `input`, `inputFile`, `stdin`, `stdout` and `stderr` options, after spawning, in async mode
// When multiple input streams are used, we merge them to ensure the output stream ends only once each input stream has ended
const pipeOutputAsync = (subprocess, fileDescriptors, controller) => {
	const pipeGroups = new Map();

	for (const [fdNumber, {stdioItems, direction}] of Object.entries(fileDescriptors)) {
		for (const {stream} of stdioItems.filter(({type}) => TRANSFORM_TYPES.has(type))) {
			pipeTransform(subprocess, stream, direction, fdNumber);
		}

		for (const {stream} of stdioItems.filter(({type}) => !TRANSFORM_TYPES.has(type))) {
			pipeStdioItem({
				subprocess,
				stream,
				direction,
				fdNumber,
				pipeGroups,
				controller,
			});
		}
	}

	for (const [outputStream, inputStreams] of pipeGroups.entries()) {
		const inputStream = inputStreams.length === 1 ? inputStreams[0] : mergeStreams(inputStreams);
		pipeStreams(inputStream, outputStream);
	}
};

// When using transforms, `subprocess.stdin|stdout|stderr|stdio` is directly mutated
const pipeTransform = (subprocess, stream, direction, fdNumber) => {
	if (direction === 'output') {
		pipeStreams(subprocess.stdio[fdNumber], stream);
	} else {
		pipeStreams(stream, subprocess.stdio[fdNumber]);
	}

	const streamProperty = SUBPROCESS_STREAM_PROPERTIES[fdNumber];
	if (streamProperty !== undefined) {
		subprocess[streamProperty] = stream;
	}

	subprocess.stdio[fdNumber] = stream;
};

const SUBPROCESS_STREAM_PROPERTIES = ['stdin', 'stdout', 'stderr'];

// Most `std*` option values involve piping `subprocess.std*` to a stream.
// The stream is either passed by the user or created internally.
const pipeStdioItem = ({subprocess, stream, direction, fdNumber, pipeGroups, controller}) => {
	if (stream === undefined) {
		return;
	}

	setStandardStreamMaxListeners(stream, controller);

	const [inputStream, outputStream] = direction === 'output'
		? [stream, subprocess.stdio[fdNumber]]
		: [subprocess.stdio[fdNumber], stream];
	const outputStreams = pipeGroups.get(inputStream) ?? [];
	pipeGroups.set(inputStream, [...outputStreams, outputStream]);
};

// Multiple subprocesses might be piping from/to `process.std*` at the same time.
// This is not necessarily an error and should not print a `maxListeners` warning.
const setStandardStreamMaxListeners = (stream, {signal}) => {
	if (isStandardStream(stream)) {
		incrementMaxListeners(stream, MAX_LISTENERS_INCREMENT, signal);
	}
};

// `source.pipe(destination)` adds at most 1 listener for each event.
// If `stdin` option is an array, the values might be combined with `merge-streams`.
// That library also listens for `source` end, which adds 1 more listener.
const MAX_LISTENERS_INCREMENT = 2;

// If the `cleanup` option is used, call `subprocess.kill()` when the parent process exits
const cleanupOnExit = (subprocess, {cleanup, detached}, {signal}) => {
	if (!cleanup || detached) {
		return;
	}

	const removeExitHandler = onExit(() => {
		subprocess.kill();
	});
	addAbortListener(signal, () => {
		removeExitHandler();
	});
};

// Normalize and validate arguments passed to `source.pipe(destination)`
const normalizePipeArguments = ({source, sourcePromise, boundOptions, createNested}, ...pipeArguments) => {
	const startTime = getStartTime();
	const {
		destination,
		destinationStream,
		destinationError,
		from,
		unpipeSignal,
	} = getDestinationStream(boundOptions, createNested, pipeArguments);
	const {sourceStream, sourceError} = getSourceStream(source, from);
	const {options: sourceOptions, fileDescriptors} = SUBPROCESS_OPTIONS.get(source);
	return {
		sourcePromise,
		sourceStream,
		sourceOptions,
		sourceError,
		destination,
		destinationStream,
		destinationError,
		unpipeSignal,
		fileDescriptors,
		startTime,
	};
};

const getDestinationStream = (boundOptions, createNested, pipeArguments) => {
	try {
		const {
			destination,
			pipeOptions: {from, to, unpipeSignal} = {},
		} = getDestination(boundOptions, createNested, ...pipeArguments);
		const destinationStream = getToStream(destination, to);
		return {
			destination,
			destinationStream,
			from,
			unpipeSignal,
		};
	} catch (error) {
		return {destinationError: error};
	}
};

// Piping subprocesses can use three syntaxes:
//  - source.pipe('command', commandArguments, pipeOptionsOrDestinationOptions)
//  - source.pipe`command commandArgument` or source.pipe(pipeOptionsOrDestinationOptions)`command commandArgument`
//  - source.pipe(execa(...), pipeOptions)
const getDestination = (boundOptions, createNested, firstArgument, ...pipeArguments) => {
	if (Array.isArray(firstArgument)) {
		const destination = createNested(mapDestinationArguments, boundOptions)(firstArgument, ...pipeArguments);
		return {destination, pipeOptions: boundOptions};
	}

	if (typeof firstArgument === 'string' || firstArgument instanceof URL || isDenoExecPath(firstArgument)) {
		if (Object.keys(boundOptions).length > 0) {
			throw new TypeError('Please use .pipe("file", ..., options) or .pipe(execa("file", ..., options)) instead of .pipe(options)("file", ...).');
		}

		const [rawFile, rawArguments, rawOptions] = normalizeParameters(firstArgument, ...pipeArguments);
		const destination = createNested(mapDestinationArguments)(rawFile, rawArguments, rawOptions);
		return {destination, pipeOptions: rawOptions};
	}

	if (SUBPROCESS_OPTIONS.has(firstArgument)) {
		if (Object.keys(boundOptions).length > 0) {
			throw new TypeError('Please use .pipe(options)`command` or .pipe($(options)`command`) instead of .pipe(options)($`command`).');
		}

		return {destination: firstArgument, pipeOptions: pipeArguments[0]};
	}

	throw new TypeError(`The first argument must be a template string, an options object, or an Execa subprocess: ${firstArgument}`);
};

// Force `stdin: 'pipe'` with the destination subprocess
const mapDestinationArguments = ({options}) => ({options: {...options, stdin: 'pipe', piped: true}});

const getSourceStream = (source, from) => {
	try {
		const sourceStream = getFromStream(source, from);
		return {sourceStream};
	} catch (error) {
		return {sourceError: error};
	}
};

// When passing invalid arguments to `source.pipe()`, throw asynchronously.
// We also abort both subprocesses.
const handlePipeArgumentsError = ({
	sourceStream,
	sourceError,
	destinationStream,
	destinationError,
	fileDescriptors,
	sourceOptions,
	startTime,
}) => {
	const error = getPipeArgumentsError({
		sourceStream,
		sourceError,
		destinationStream,
		destinationError,
	});
	if (error !== undefined) {
		throw createNonCommandError({
			error,
			fileDescriptors,
			sourceOptions,
			startTime,
		});
	}
};

const getPipeArgumentsError = ({sourceStream, sourceError, destinationStream, destinationError}) => {
	if (sourceError !== undefined && destinationError !== undefined) {
		return destinationError;
	}

	if (destinationError !== undefined) {
		abortSourceStream(sourceStream);
		return destinationError;
	}

	if (sourceError !== undefined) {
		endDestinationStream(destinationStream);
		return sourceError;
	}
};

// Specific error return value when passing invalid arguments to `subprocess.pipe()` or when using `unpipeSignal`
const createNonCommandError = ({error, fileDescriptors, sourceOptions, startTime}) => makeEarlyError({
	error,
	command: PIPE_COMMAND_MESSAGE,
	escapedCommand: PIPE_COMMAND_MESSAGE,
	fileDescriptors,
	options: sourceOptions,
	startTime,
	isSync: false,
});

const PIPE_COMMAND_MESSAGE = 'source.pipe(destination)';

// Like Bash, we await both subprocesses. This is unlike some other shells which only await the destination subprocess.
// Like Bash with the `pipefail` option, if either subprocess fails, the whole pipe fails.
// Like Bash, if both subprocesses fail, we return the failure of the destination.
// This ensures both subprocesses' errors are present, using `error.pipedFrom`.
const waitForBothSubprocesses = async subprocessPromises => {
	const [
		{status: sourceStatus, reason: sourceReason, value: sourceResult = sourceReason},
		{status: destinationStatus, reason: destinationReason, value: destinationResult = destinationReason},
	] = await subprocessPromises;

	if (!destinationResult.pipedFrom.includes(sourceResult)) {
		destinationResult.pipedFrom.push(sourceResult);
	}

	if (destinationStatus === 'rejected') {
		throw destinationResult;
	}

	if (sourceStatus === 'rejected') {
		throw sourceResult;
	}

	return destinationResult;
};

// The piping behavior is like Bash.
// In particular, when one subprocess exits, the other is not terminated by a signal.
// Instead, its stdout (for the source) or stdin (for the destination) closes.
// If the subprocess uses it, it will make it error with SIGPIPE or EPIPE (for the source) or end (for the destination).
// If it does not use it, it will continue running.
// This allows for subprocesses to gracefully exit and lower the coupling between subprocesses.
const pipeSubprocessStream = (sourceStream, destinationStream, maxListenersController) => {
	const mergedStream = MERGED_STREAMS.has(destinationStream)
		? pipeMoreSubprocessStream(sourceStream, destinationStream)
		: pipeFirstSubprocessStream(sourceStream, destinationStream);
	incrementMaxListeners(sourceStream, SOURCE_LISTENERS_PER_PIPE, maxListenersController.signal);
	incrementMaxListeners(destinationStream, DESTINATION_LISTENERS_PER_PIPE, maxListenersController.signal);
	cleanupMergedStreamsMap(destinationStream);
	return mergedStream;
};

// We use `merge-streams` to allow for multiple sources to pipe to the same destination.
const pipeFirstSubprocessStream = (sourceStream, destinationStream) => {
	const mergedStream = mergeStreams([sourceStream]);
	pipeStreams(mergedStream, destinationStream);
	MERGED_STREAMS.set(destinationStream, mergedStream);
	return mergedStream;
};

const pipeMoreSubprocessStream = (sourceStream, destinationStream) => {
	const mergedStream = MERGED_STREAMS.get(destinationStream);
	mergedStream.add(sourceStream);
	return mergedStream;
};

const cleanupMergedStreamsMap = async destinationStream => {
	try {
		await finished(destinationStream, {cleanup: true, readable: false, writable: true});
	} catch {}

	MERGED_STREAMS.delete(destinationStream);
};

const MERGED_STREAMS = new WeakMap();

// Number of listeners set up on `sourceStream` by each `sourceStream.pipe(destinationStream)`
// Those are added by `merge-streams`
const SOURCE_LISTENERS_PER_PIPE = 2;
// Number of listeners set up on `destinationStream` by each `sourceStream.pipe(destinationStream)`
// Those are added by `finished()` in `cleanupMergedStreamsMap()`
const DESTINATION_LISTENERS_PER_PIPE = 1;

// When passing an `unpipeSignal` option, abort piping when the signal is aborted.
// However, do not terminate the subprocesses.
const unpipeOnAbort = (unpipeSignal, unpipeContext) => unpipeSignal === undefined
	? []
	: [unpipeOnSignalAbort(unpipeSignal, unpipeContext)];

const unpipeOnSignalAbort = async (unpipeSignal, {sourceStream, mergedStream, fileDescriptors, sourceOptions, startTime}) => {
	await aborted(unpipeSignal, sourceStream);
	await mergedStream.remove(sourceStream);
	const error = new Error('Pipe canceled by `unpipeSignal` option.');
	throw createNonCommandError({
		error,
		fileDescriptors,
		sourceOptions,
		startTime,
	});
};

// Pipe a subprocess' `stdout`/`stderr`/`stdio` into another subprocess' `stdin`
const pipeToSubprocess = (sourceInfo, ...pipeArguments) => {
	if (isPlainObject(pipeArguments[0])) {
		return pipeToSubprocess.bind(undefined, {
			...sourceInfo,
			boundOptions: {...sourceInfo.boundOptions, ...pipeArguments[0]},
		});
	}

	const {destination, ...normalizedInfo} = normalizePipeArguments(sourceInfo, ...pipeArguments);
	const promise = handlePipePromise({...normalizedInfo, destination});
	promise.pipe = pipeToSubprocess.bind(undefined, {
		...sourceInfo,
		source: destination,
		sourcePromise: promise,
		boundOptions: {},
	});
	return promise;
};

// Asynchronous logic when piping subprocesses
const handlePipePromise = async ({
	sourcePromise,
	sourceStream,
	sourceOptions,
	sourceError,
	destination,
	destinationStream,
	destinationError,
	unpipeSignal,
	fileDescriptors,
	startTime,
}) => {
	const subprocessPromises = getSubprocessPromises(sourcePromise, destination);
	handlePipeArgumentsError({
		sourceStream,
		sourceError,
		destinationStream,
		destinationError,
		fileDescriptors,
		sourceOptions,
		startTime,
	});
	const maxListenersController = new AbortController();
	try {
		const mergedStream = pipeSubprocessStream(sourceStream, destinationStream, maxListenersController);
		return await Promise.race([
			waitForBothSubprocesses(subprocessPromises),
			...unpipeOnAbort(unpipeSignal, {
				sourceStream,
				mergedStream,
				sourceOptions,
				fileDescriptors,
				startTime,
			}),
		]);
	} finally {
		maxListenersController.abort();
	}
};

// `.pipe()` awaits the subprocess promises.
// When invalid arguments are passed to `.pipe()`, we throw an error, which prevents awaiting them.
// We need to ensure this does not create unhandled rejections.
const getSubprocessPromises = (sourcePromise, destination) => Promise.allSettled([sourcePromise, destination]);

// Iterate over lines of `subprocess.stdout`, used by `subprocess.readable|duplex|iterable()`
const iterateOnSubprocessStream = ({subprocessStdout, subprocess, binary, shouldEncode, encoding, preserveNewlines}) => {
	const controller = new AbortController();
	stopReadingOnExit(subprocess, controller);
	return iterateOnStream({
		stream: subprocessStdout,
		controller,
		binary,
		shouldEncode: !subprocessStdout.readableObjectMode && shouldEncode,
		encoding,
		shouldSplit: !subprocessStdout.readableObjectMode,
		preserveNewlines,
	});
};

const stopReadingOnExit = async (subprocess, controller) => {
	try {
		await subprocess;
	} catch {} finally {
		controller.abort();
	}
};

// Iterate over lines of `subprocess.stdout`, used by `result.stdout` and the `verbose: 'full'` option.
// Applies the `lines` and `encoding` options.
const iterateForResult = ({stream, onStreamEnd, lines, encoding, stripFinalNewline, allMixed}) => {
	const controller = new AbortController();
	stopReadingOnStreamEnd(onStreamEnd, controller, stream);
	const objectMode = stream.readableObjectMode && !allMixed;
	return iterateOnStream({
		stream,
		controller,
		binary: encoding === 'buffer',
		shouldEncode: !objectMode,
		encoding,
		shouldSplit: !objectMode && lines,
		preserveNewlines: !stripFinalNewline,
	});
};

const stopReadingOnStreamEnd = async (onStreamEnd, controller, stream) => {
	try {
		await onStreamEnd;
	} catch {
		stream.destroy();
	} finally {
		controller.abort();
	}
};

const iterateOnStream = ({stream, controller, binary, shouldEncode, encoding, shouldSplit, preserveNewlines}) => {
	const onStdoutChunk = on(stream, 'data', {
		signal: controller.signal,
		highWaterMark: HIGH_WATER_MARK,
		// Backward compatibility with older name for this option
		// See https://github.com/nodejs/node/pull/52080#discussion_r1525227861
		// @todo Remove after removing support for Node 21
		highWatermark: HIGH_WATER_MARK,
	});
	return iterateOnData({
		onStdoutChunk,
		controller,
		binary,
		shouldEncode,
		encoding,
		shouldSplit,
		preserveNewlines,
	});
};

const DEFAULT_OBJECT_HIGH_WATER_MARK = getDefaultHighWaterMark(true);

// The `highWaterMark` of `events.on()` is measured in number of events, not in bytes.
// Not knowing the average amount of bytes per `data` event, we use the same heuristic as streams in objectMode, since they have the same issue.
// Therefore, we use the value of `getDefaultHighWaterMark(true)`.
// Note: this option does not exist on Node 18, but this is ok since the logic works without it. It just consumes more memory.
const HIGH_WATER_MARK = DEFAULT_OBJECT_HIGH_WATER_MARK;

const iterateOnData = async function * ({onStdoutChunk, controller, binary, shouldEncode, encoding, shouldSplit, preserveNewlines}) {
	const generators = getGenerators({
		binary,
		shouldEncode,
		encoding,
		shouldSplit,
		preserveNewlines,
	});

	try {
		for await (const [chunk] of onStdoutChunk) {
			yield * transformChunkSync(chunk, generators, 0);
		}
	} catch (error) {
		if (!controller.signal.aborted) {
			throw error;
		}
	} finally {
		yield * finalChunksSync(generators);
	}
};

const getGenerators = ({binary, shouldEncode, encoding, shouldSplit, preserveNewlines}) => [
	getEncodingTransformGenerator(binary, encoding, !shouldEncode),
	getSplitLinesGenerator(binary, preserveNewlines, !shouldSplit, {}),
].filter(Boolean);

// Retrieve `result.stdout|stderr|all|stdio[*]`
const getStreamOutput = async ({stream, onStreamEnd, fdNumber, encoding, buffer, maxBuffer, lines, allMixed, stripFinalNewline, verboseInfo, streamInfo}) => {
	const logPromise = logOutputAsync({
		stream,
		onStreamEnd,
		fdNumber,
		encoding,
		allMixed,
		verboseInfo,
		streamInfo,
	});

	if (!buffer) {
		await Promise.all([resumeStream(stream), logPromise]);
		return;
	}

	const stripFinalNewlineValue = getStripFinalNewline(stripFinalNewline, fdNumber);
	const iterable = iterateForResult({
		stream,
		onStreamEnd,
		lines,
		encoding,
		stripFinalNewline: stripFinalNewlineValue,
		allMixed,
	});
	const [output] = await Promise.all([
		getStreamContents({
			stream,
			iterable,
			fdNumber,
			encoding,
			maxBuffer,
			lines,
		}),
		logPromise,
	]);
	return output;
};

const logOutputAsync = async ({stream, onStreamEnd, fdNumber, encoding, allMixed, verboseInfo, streamInfo: {fileDescriptors}}) => {
	if (!shouldLogOutput({
		stdioItems: fileDescriptors[fdNumber]?.stdioItems,
		encoding,
		verboseInfo,
		fdNumber,
	})) {
		return;
	}

	const linesIterable = iterateForResult({
		stream,
		onStreamEnd,
		lines: true,
		encoding,
		stripFinalNewline: true,
		allMixed,
	});
	await logLines(linesIterable, stream, fdNumber, verboseInfo);
};

// When using `buffer: false`, users need to read `subprocess.stdout|stderr|all` right away
// See https://github.com/sindresorhus/execa/issues/730 and https://github.com/sindresorhus/execa/pull/729#discussion_r1465496310
const resumeStream = async stream => {
	await setImmediate$1();
	if (stream.readableFlowing === null) {
		stream.resume();
	}
};

const getStreamContents = async ({stream, stream: {readableObjectMode}, iterable, fdNumber, encoding, maxBuffer, lines}) => {
	try {
		if (readableObjectMode || lines) {
			return await getStreamAsArray(iterable, {maxBuffer});
		}

		if (encoding === 'buffer') {
			return new Uint8Array(await getStreamAsArrayBuffer(iterable, {maxBuffer}));
		}

		return await getStreamAsString(iterable, {maxBuffer});
	} catch (error) {
		return handleBufferedData(handleMaxBuffer({
			error,
			stream,
			readableObjectMode,
			lines,
			encoding,
			fdNumber,
		}));
	}
};

// On failure, `result.stdout|stderr|all` should contain the currently buffered stream
// They are automatically closed and flushed by Node.js when the subprocess exits
// When `buffer` is `false`, `streamPromise` is `undefined` and there is no buffered data to retrieve
const getBufferedData = async streamPromise => {
	try {
		return await streamPromise;
	} catch (error) {
		return handleBufferedData(error);
	}
};

// Ensure we are returning Uint8Arrays when using `encoding: 'buffer'`
const handleBufferedData = ({bufferedData}) => isArrayBuffer(bufferedData)
	? new Uint8Array(bufferedData)
	: bufferedData;

// Wraps `finished(stream)` to handle the following case:
//  - When the subprocess exits, Node.js automatically calls `subprocess.stdin.destroy()`, which we need to ignore.
//  - However, we still need to throw if `subprocess.stdin.destroy()` is called before subprocess exit.
const waitForStream = async (stream, fdNumber, streamInfo, {isSameDirection, stopOnExit = false} = {}) => {
	const state = handleStdinDestroy(stream, streamInfo);
	const abortController = new AbortController();
	try {
		await Promise.race([
			...(stopOnExit ? [streamInfo.exitPromise] : []),
			finished(stream, {cleanup: true, signal: abortController.signal}),
		]);
	} catch (error) {
		if (!state.stdinCleanedUp) {
			handleStreamError(error, fdNumber, streamInfo, isSameDirection);
		}
	} finally {
		abortController.abort();
	}
};

// If `subprocess.stdin` is destroyed before being fully written to, it is considered aborted and should throw an error.
// This can happen for example when user called `subprocess.stdin.destroy()` before `subprocess.stdin.end()`.
// However, Node.js calls `subprocess.stdin.destroy()` on exit for cleanup purposes.
// https://github.com/nodejs/node/blob/0b4cdb4b42956cbd7019058e409e06700a199e11/lib/internal/child_process.js#L278
// This is normal and should not throw an error.
// Therefore, we need to differentiate between both situations to know whether to throw an error.
// Unfortunately, events (`close`, `error`, `end`, `exit`) cannot be used because `.destroy()` can take an arbitrary amount of time.
// For example, `stdin: 'pipe'` is implemented as a TCP socket, and its `.destroy()` method waits for TCP disconnection.
// Therefore `.destroy()` might end before or after subprocess exit, based on OS speed and load.
// The only way to detect this is to spy on `subprocess.stdin._destroy()` by wrapping it.
// If `subprocess.exitCode` or `subprocess.signalCode` is set, it means `.destroy()` is being called by Node.js itself.
const handleStdinDestroy = (stream, {originalStreams: [originalStdin], subprocess}) => {
	const state = {stdinCleanedUp: false};
	if (stream === originalStdin) {
		spyOnStdinDestroy(stream, subprocess, state);
	}

	return state;
};

const spyOnStdinDestroy = (subprocessStdin, subprocess, state) => {
	const {_destroy} = subprocessStdin;
	subprocessStdin._destroy = (...destroyArguments) => {
		setStdinCleanedUp(subprocess, state);
		_destroy.call(subprocessStdin, ...destroyArguments);
	};
};

const setStdinCleanedUp = ({exitCode, signalCode}, state) => {
	if (exitCode !== null || signalCode !== null) {
		state.stdinCleanedUp = true;
	}
};

// We ignore EPIPEs on writable streams and aborts on readable streams since those can happen normally.
// When one stream errors, the error is propagated to the other streams on the same file descriptor.
// Those other streams might have a different direction due to the above.
// When this happens, the direction of both the initial stream and the others should then be taken into account.
// Therefore, we keep track of whether a stream error is currently propagating.
const handleStreamError = (error, fdNumber, streamInfo, isSameDirection) => {
	if (!shouldIgnoreStreamError(error, fdNumber, streamInfo, isSameDirection)) {
		throw error;
	}
};

const shouldIgnoreStreamError = (error, fdNumber, streamInfo, isSameDirection = true) => {
	if (streamInfo.propagating) {
		return isStreamEpipe(error) || isStreamAbort(error);
	}

	streamInfo.propagating = true;
	return isInputFileDescriptor(streamInfo, fdNumber) === isSameDirection
		? isStreamEpipe(error)
		: isStreamAbort(error);
};

// Unfortunately, we cannot use the stream's class or properties to know whether it is readable or writable.
// For example, `subprocess.stdin` is technically a Duplex, but can only be used as a writable.
// Therefore, we need to use the file descriptor's direction (`stdin` is input, `stdout` is output, etc.).
// However, while `subprocess.std*` and transforms follow that direction, any stream passed the `std*` option has the opposite direction.
// For example, `subprocess.stdin` is a writable, but the `stdin` option is a readable.
const isInputFileDescriptor = ({fileDescriptors}, fdNumber) => fdNumber !== 'all' && fileDescriptors[fdNumber].direction === 'input';

// When `stream.destroy()` is called without an `error` argument, stream is aborted.
// This is the only way to abort a readable stream, which can be useful in some instances.
// Therefore, we ignore this error on readable streams.
const isStreamAbort = error => error?.code === 'ERR_STREAM_PREMATURE_CLOSE';

// When `stream.write()` is called but the underlying source has been closed, `EPIPE` is emitted.
// When piping subprocesses, the source subprocess usually decides when to stop piping.
// However, there are some instances when the destination does instead, such as `... | head -n1`.
// It notifies the source by using `EPIPE`.
// Therefore, we ignore this error on writable streams.
const isStreamEpipe = error => error?.code === 'EPIPE';

// Read the contents of `subprocess.std*` and|or wait for its completion
const waitForStdioStreams = ({subprocess, encoding, buffer, maxBuffer, lines, stripFinalNewline, verboseInfo, streamInfo}) => subprocess.stdio.map((stream, fdNumber) => waitForSubprocessStream({
	stream,
	fdNumber,
	encoding,
	buffer: buffer[fdNumber],
	maxBuffer: maxBuffer[fdNumber],
	lines: lines[fdNumber],
	allMixed: false,
	stripFinalNewline,
	verboseInfo,
	streamInfo,
}));

// Read the contents of `subprocess.std*` or `subprocess.all` and|or wait for its completion
const waitForSubprocessStream = async ({stream, fdNumber, encoding, buffer, maxBuffer, lines, allMixed, stripFinalNewline, verboseInfo, streamInfo}) => {
	if (!stream) {
		return;
	}

	const onStreamEnd = waitForStream(stream, fdNumber, streamInfo);
	if (isInputFileDescriptor(streamInfo, fdNumber)) {
		await onStreamEnd;
		return;
	}

	const [output] = await Promise.all([
		getStreamOutput({
			stream,
			onStreamEnd,
			fdNumber,
			encoding,
			buffer,
			maxBuffer,
			lines,
			allMixed,
			stripFinalNewline,
			verboseInfo,
			streamInfo,
		}),
		onStreamEnd,
	]);
	return output;
};

// `all` interleaves `stdout` and `stderr`
const makeAllStream = ({stdout, stderr}, {all}) => all && (stdout || stderr)
	? mergeStreams([stdout, stderr].filter(Boolean))
	: undefined;

// Read the contents of `subprocess.all` and|or wait for its completion
const waitForAllStream = ({subprocess, encoding, buffer, maxBuffer, lines, stripFinalNewline, verboseInfo, streamInfo}) => waitForSubprocessStream({
	...getAllStream(subprocess, buffer),
	fdNumber: 'all',
	encoding,
	maxBuffer: maxBuffer[1] + maxBuffer[2],
	lines: lines[1] || lines[2],
	allMixed: getAllMixed(subprocess),
	stripFinalNewline,
	verboseInfo,
	streamInfo,
});

const getAllStream = ({stdout, stderr, all}, [, bufferStdout, bufferStderr]) => {
	const buffer = bufferStdout || bufferStderr;
	if (!buffer) {
		return {stream: all, buffer};
	}

	if (!bufferStdout) {
		return {stream: stderr, buffer};
	}

	if (!bufferStderr) {
		return {stream: stdout, buffer};
	}

	return {stream: all, buffer};
};

// When `subprocess.stdout` is in objectMode but not `subprocess.stderr` (or the opposite), we need to use both:
//  - `getStreamAsArray()` for the chunks in objectMode, to return as an array without changing each chunk
//  - `getStreamAsArrayBuffer()` or `getStream()` for the chunks not in objectMode, to convert them from Buffers to string or Uint8Array
// We do this by emulating the Buffer -> string|Uint8Array conversion performed by `get-stream` with our own, which is identical.
const getAllMixed = ({all, stdout, stderr}) => all
	&& stdout
	&& stderr
	&& stdout.readableObjectMode !== stderr.readableObjectMode;

// When `verbose` is `'full'`, print IPC messages from the subprocess
const shouldLogIpc = verboseInfo => isFullVerbose(verboseInfo, 'ipc');

const logIpcOutput = (message, verboseInfo) => {
	const verboseMessage = serializeVerboseMessage(message);
	verboseLog({
		type: 'ipc',
		verboseMessage,
		fdNumber: 'ipc',
		verboseInfo,
	});
};

// Iterate through IPC messages sent by the subprocess
const waitForIpcOutput = async ({
	subprocess,
	buffer: bufferArray,
	maxBuffer: maxBufferArray,
	ipc,
	ipcOutput,
	verboseInfo,
}) => {
	if (!ipc) {
		return ipcOutput;
	}

	const isVerbose = shouldLogIpc(verboseInfo);
	const buffer = getFdSpecificValue(bufferArray, 'ipc');
	const maxBuffer = getFdSpecificValue(maxBufferArray, 'ipc');

	for await (const message of loopOnMessages({
		anyProcess: subprocess,
		channel: subprocess.channel,
		isSubprocess: false,
		ipc,
		shouldAwait: false,
		reference: true,
	})) {
		if (buffer) {
			checkIpcMaxBuffer(subprocess, ipcOutput, maxBuffer);
			ipcOutput.push(message);
		}

		if (isVerbose) {
			logIpcOutput(message, verboseInfo);
		}
	}

	return ipcOutput;
};

const getBufferedIpcOutput = async (ipcOutputPromise, ipcOutput) => {
	await Promise.allSettled([ipcOutputPromise]);
	return ipcOutput;
};

// Retrieve result of subprocess: exit code, signal, error, streams (stdout/stderr/all)
const waitForSubprocessResult = async ({
	subprocess,
	options: {
		encoding,
		buffer,
		maxBuffer,
		lines,
		timeoutDuration: timeout,
		cancelSignal,
		gracefulCancel,
		forceKillAfterDelay,
		stripFinalNewline,
		ipc,
		ipcInput,
	},
	context,
	verboseInfo,
	fileDescriptors,
	originalStreams,
	onInternalError,
	controller,
}) => {
	const exitPromise = waitForExit(subprocess, context);
	const streamInfo = {
		originalStreams,
		fileDescriptors,
		subprocess,
		exitPromise,
		propagating: false,
	};

	const stdioPromises = waitForStdioStreams({
		subprocess,
		encoding,
		buffer,
		maxBuffer,
		lines,
		stripFinalNewline,
		verboseInfo,
		streamInfo,
	});
	const allPromise = waitForAllStream({
		subprocess,
		encoding,
		buffer,
		maxBuffer,
		lines,
		stripFinalNewline,
		verboseInfo,
		streamInfo,
	});
	const ipcOutput = [];
	const ipcOutputPromise = waitForIpcOutput({
		subprocess,
		buffer,
		maxBuffer,
		ipc,
		ipcOutput,
		verboseInfo,
	});
	const originalPromises = waitForOriginalStreams(originalStreams, subprocess, streamInfo);
	const customStreamsEndPromises = waitForCustomStreamsEnd(fileDescriptors, streamInfo);

	try {
		return await Promise.race([
			Promise.all([
				{},
				waitForSuccessfulExit(exitPromise),
				Promise.all(stdioPromises),
				allPromise,
				ipcOutputPromise,
				sendIpcInput(subprocess, ipcInput),
				...originalPromises,
				...customStreamsEndPromises,
			]),
			onInternalError,
			throwOnSubprocessError(subprocess, controller),
			...throwOnTimeout(subprocess, timeout, context, controller),
			...throwOnCancel({
				subprocess,
				cancelSignal,
				gracefulCancel,
				context,
				controller,
			}),
			...throwOnGracefulCancel({
				subprocess,
				cancelSignal,
				gracefulCancel,
				forceKillAfterDelay,
				context,
				controller,
			}),
		]);
	} catch (error) {
		context.terminationReason ??= 'other';
		return Promise.all([
			{error},
			exitPromise,
			Promise.all(stdioPromises.map(stdioPromise => getBufferedData(stdioPromise))),
			getBufferedData(allPromise),
			getBufferedIpcOutput(ipcOutputPromise, ipcOutput),
			Promise.allSettled(originalPromises),
			Promise.allSettled(customStreamsEndPromises),
		]);
	}
};

// Transforms replace `subprocess.std*`, which means they are not exposed to users.
// However, we still want to wait for their completion.
const waitForOriginalStreams = (originalStreams, subprocess, streamInfo) =>
	originalStreams.map((stream, fdNumber) => stream === subprocess.stdio[fdNumber]
		? undefined
		: waitForStream(stream, fdNumber, streamInfo));

// Some `stdin`/`stdout`/`stderr` options create a stream, e.g. when passing a file path.
// The `.pipe()` method automatically ends that stream when `subprocess` ends.
// This makes sure we wait for the completion of those streams, in order to catch any error.
const waitForCustomStreamsEnd = (fileDescriptors, streamInfo) => fileDescriptors.flatMap(({stdioItems}, fdNumber) => stdioItems
	.filter(({value, stream = value}) => isStream(stream, {checkOpen: false}) && !isStandardStream(stream))
	.map(({type, value, stream = value}) => waitForStream(stream, fdNumber, streamInfo, {
		isSameDirection: TRANSFORM_TYPES.has(type),
		stopOnExit: type === 'native',
	})));

// Fails when the subprocess emits an `error` event
const throwOnSubprocessError = async (subprocess, {signal}) => {
	const [error] = await once(subprocess, 'error', {signal});
	throw error;
};

// When using multiple `.readable()`/`.writable()`/`.duplex()`, `final` and `destroy` should wait for other streams
const initializeConcurrentStreams = () => ({
	readableDestroy: new WeakMap(),
	writableFinal: new WeakMap(),
	writableDestroy: new WeakMap(),
});

// Each file descriptor + `waitName` has its own array of promises.
// Each promise is a single `.readable()`/`.writable()`/`.duplex()` call.
const addConcurrentStream = (concurrentStreams, stream, waitName) => {
	const weakMap = concurrentStreams[waitName];
	if (!weakMap.has(stream)) {
		weakMap.set(stream, []);
	}

	const promises = weakMap.get(stream);
	const promise = createDeferred();
	promises.push(promise);
	const resolve = promise.resolve.bind(promise);
	return {resolve, promises};
};

// Wait for other streams, but stop waiting when subprocess ends
const waitForConcurrentStreams = async ({resolve, promises}, subprocess) => {
	resolve();
	const [isSubprocessExit] = await Promise.race([
		Promise.allSettled([true, subprocess]),
		Promise.all([false, ...promises]),
	]);
	return !isSubprocessExit;
};

const safeWaitForSubprocessStdin = async subprocessStdin => {
	if (subprocessStdin === undefined) {
		return;
	}

	try {
		await waitForSubprocessStdin(subprocessStdin);
	} catch {}
};

const safeWaitForSubprocessStdout = async subprocessStdout => {
	if (subprocessStdout === undefined) {
		return;
	}

	try {
		await waitForSubprocessStdout(subprocessStdout);
	} catch {}
};

const waitForSubprocessStdin = async subprocessStdin => {
	await finished(subprocessStdin, {cleanup: true, readable: false, writable: true});
};

const waitForSubprocessStdout = async subprocessStdout => {
	await finished(subprocessStdout, {cleanup: true, readable: true, writable: false});
};

// When `readable` or `writable` aborts/errors, awaits the subprocess, for the reason mentioned above
const waitForSubprocess = async (subprocess, error) => {
	await subprocess;
	if (error) {
		throw error;
	}
};

const destroyOtherStream = (stream, isOpen, error) => {
	if (error && !isStreamAbort(error)) {
		stream.destroy(error);
	} else if (isOpen) {
		stream.destroy();
	}
};

// Create a `Readable` stream that forwards from `stdout` and awaits the subprocess
const createReadable = ({subprocess, concurrentStreams, encoding}, {from, binary: binaryOption = true, preserveNewlines = true} = {}) => {
	const binary = binaryOption || BINARY_ENCODINGS.has(encoding);
	const {subprocessStdout, waitReadableDestroy} = getSubprocessStdout(subprocess, from, concurrentStreams);
	const {readableEncoding, readableObjectMode, readableHighWaterMark} = getReadableOptions(subprocessStdout, binary);
	const {read, onStdoutDataDone} = getReadableMethods({
		subprocessStdout,
		subprocess,
		binary,
		encoding,
		preserveNewlines,
	});
	const readable = new Readable({
		read,
		destroy: callbackify(onReadableDestroy.bind(undefined, {subprocessStdout, subprocess, waitReadableDestroy})),
		highWaterMark: readableHighWaterMark,
		objectMode: readableObjectMode,
		encoding: readableEncoding,
	});
	onStdoutFinished({
		subprocessStdout,
		onStdoutDataDone,
		readable,
		subprocess,
	});
	return readable;
};

// Retrieve `stdout` (or other stream depending on `from`)
const getSubprocessStdout = (subprocess, from, concurrentStreams) => {
	const subprocessStdout = getFromStream(subprocess, from);
	const waitReadableDestroy = addConcurrentStream(concurrentStreams, subprocessStdout, 'readableDestroy');
	return {subprocessStdout, waitReadableDestroy};
};

const getReadableOptions = ({readableEncoding, readableObjectMode, readableHighWaterMark}, binary) => binary
	? {readableEncoding, readableObjectMode, readableHighWaterMark}
	: {readableEncoding, readableObjectMode: true, readableHighWaterMark: DEFAULT_OBJECT_HIGH_WATER_MARK};

const getReadableMethods = ({subprocessStdout, subprocess, binary, encoding, preserveNewlines}) => {
	const onStdoutDataDone = createDeferred();
	const onStdoutData = iterateOnSubprocessStream({
		subprocessStdout,
		subprocess,
		binary,
		shouldEncode: !binary,
		encoding,
		preserveNewlines,
	});

	return {
		read() {
			onRead(this, onStdoutData, onStdoutDataDone);
		},
		onStdoutDataDone,
	};
};

// Forwards data from `stdout` to `readable`
const onRead = async (readable, onStdoutData, onStdoutDataDone) => {
	try {
		const {value, done} = await onStdoutData.next();
		if (done) {
			onStdoutDataDone.resolve();
		} else {
			readable.push(value);
		}
	} catch {}
};

// When `subprocess.stdout` ends/aborts/errors, do the same on `readable`.
// Await the subprocess, for the same reason as above.
const onStdoutFinished = async ({subprocessStdout, onStdoutDataDone, readable, subprocess, subprocessStdin}) => {
	try {
		await waitForSubprocessStdout(subprocessStdout);
		await subprocess;
		await safeWaitForSubprocessStdin(subprocessStdin);
		await onStdoutDataDone;

		if (readable.readable) {
			readable.push(null);
		}
	} catch (error) {
		await safeWaitForSubprocessStdin(subprocessStdin);
		destroyOtherReadable(readable, error);
	}
};

// When `readable` aborts/errors, do the same on `subprocess.stdout`
const onReadableDestroy = async ({subprocessStdout, subprocess, waitReadableDestroy}, error) => {
	if (await waitForConcurrentStreams(waitReadableDestroy, subprocess)) {
		destroyOtherReadable(subprocessStdout, error);
		await waitForSubprocess(subprocess, error);
	}
};

const destroyOtherReadable = (stream, error) => {
	destroyOtherStream(stream, stream.readable, error);
};

// Create a `Writable` stream that forwards to `stdin` and awaits the subprocess
const createWritable = ({subprocess, concurrentStreams}, {to} = {}) => {
	const {subprocessStdin, waitWritableFinal, waitWritableDestroy} = getSubprocessStdin(subprocess, to, concurrentStreams);
	const writable = new Writable({
		...getWritableMethods(subprocessStdin, subprocess, waitWritableFinal),
		destroy: callbackify(onWritableDestroy.bind(undefined, {
			subprocessStdin,
			subprocess,
			waitWritableFinal,
			waitWritableDestroy,
		})),
		highWaterMark: subprocessStdin.writableHighWaterMark,
		objectMode: subprocessStdin.writableObjectMode,
	});
	onStdinFinished(subprocessStdin, writable);
	return writable;
};

// Retrieve `stdin` (or other stream depending on `to`)
const getSubprocessStdin = (subprocess, to, concurrentStreams) => {
	const subprocessStdin = getToStream(subprocess, to);
	const waitWritableFinal = addConcurrentStream(concurrentStreams, subprocessStdin, 'writableFinal');
	const waitWritableDestroy = addConcurrentStream(concurrentStreams, subprocessStdin, 'writableDestroy');
	return {subprocessStdin, waitWritableFinal, waitWritableDestroy};
};

const getWritableMethods = (subprocessStdin, subprocess, waitWritableFinal) => ({
	write: onWrite.bind(undefined, subprocessStdin),
	final: callbackify(onWritableFinal.bind(undefined, subprocessStdin, subprocess, waitWritableFinal)),
});

// Forwards data from `writable` to `stdin`
const onWrite = (subprocessStdin, chunk, encoding, done) => {
	if (subprocessStdin.write(chunk, encoding)) {
		done();
	} else {
		subprocessStdin.once('drain', done);
	}
};

// Ensures that the writable `final` and readable `end` events awaits the subprocess.
// Like this, any subprocess failure is propagated as a stream `error` event, instead of being lost.
// The user does not need to `await` the subprocess anymore, but now needs to await the stream completion or error.
// When multiple writables are targeting the same stream, they wait for each other, unless the subprocess ends first.
const onWritableFinal = async (subprocessStdin, subprocess, waitWritableFinal) => {
	if (await waitForConcurrentStreams(waitWritableFinal, subprocess)) {
		if (subprocessStdin.writable) {
			subprocessStdin.end();
		}

		await subprocess;
	}
};

// When `subprocess.stdin` ends/aborts/errors, do the same on `writable`.
const onStdinFinished = async (subprocessStdin, writable, subprocessStdout) => {
	try {
		await waitForSubprocessStdin(subprocessStdin);
		if (writable.writable) {
			writable.end();
		}
	} catch (error) {
		await safeWaitForSubprocessStdout(subprocessStdout);
		destroyOtherWritable(writable, error);
	}
};

// When `writable` aborts/errors, do the same on `subprocess.stdin`
const onWritableDestroy = async ({subprocessStdin, subprocess, waitWritableFinal, waitWritableDestroy}, error) => {
	await waitForConcurrentStreams(waitWritableFinal, subprocess);
	if (await waitForConcurrentStreams(waitWritableDestroy, subprocess)) {
		destroyOtherWritable(subprocessStdin, error);
		await waitForSubprocess(subprocess, error);
	}
};

const destroyOtherWritable = (stream, error) => {
	destroyOtherStream(stream, stream.writable, error);
};

// Create a `Duplex` stream combining both `subprocess.readable()` and `subprocess.writable()`
const createDuplex = ({subprocess, concurrentStreams, encoding}, {from, to, binary: binaryOption = true, preserveNewlines = true} = {}) => {
	const binary = binaryOption || BINARY_ENCODINGS.has(encoding);
	const {subprocessStdout, waitReadableDestroy} = getSubprocessStdout(subprocess, from, concurrentStreams);
	const {subprocessStdin, waitWritableFinal, waitWritableDestroy} = getSubprocessStdin(subprocess, to, concurrentStreams);
	const {readableEncoding, readableObjectMode, readableHighWaterMark} = getReadableOptions(subprocessStdout, binary);
	const {read, onStdoutDataDone} = getReadableMethods({
		subprocessStdout,
		subprocess,
		binary,
		encoding,
		preserveNewlines,
	});
	const duplex = new Duplex({
		read,
		...getWritableMethods(subprocessStdin, subprocess, waitWritableFinal),
		destroy: callbackify(onDuplexDestroy.bind(undefined, {
			subprocessStdout,
			subprocessStdin,
			subprocess,
			waitReadableDestroy,
			waitWritableFinal,
			waitWritableDestroy,
		})),
		readableHighWaterMark,
		writableHighWaterMark: subprocessStdin.writableHighWaterMark,
		readableObjectMode,
		writableObjectMode: subprocessStdin.writableObjectMode,
		encoding: readableEncoding,
	});
	onStdoutFinished({
		subprocessStdout,
		onStdoutDataDone,
		readable: duplex,
		subprocess,
		subprocessStdin,
	});
	onStdinFinished(subprocessStdin, duplex, subprocessStdout);
	return duplex;
};

const onDuplexDestroy = async ({subprocessStdout, subprocessStdin, subprocess, waitReadableDestroy, waitWritableFinal, waitWritableDestroy}, error) => {
	await Promise.all([
		onReadableDestroy({subprocessStdout, subprocess, waitReadableDestroy}, error),
		onWritableDestroy({
			subprocessStdin,
			subprocess,
			waitWritableFinal,
			waitWritableDestroy,
		}, error),
	]);
};

// Convert the subprocess to an async iterable
const createIterable = (subprocess, encoding, {
	from,
	binary: binaryOption = false,
	preserveNewlines = false,
} = {}) => {
	const binary = binaryOption || BINARY_ENCODINGS.has(encoding);
	const subprocessStdout = getFromStream(subprocess, from);
	const onStdoutData = iterateOnSubprocessStream({
		subprocessStdout,
		subprocess,
		binary,
		shouldEncode: true,
		encoding,
		preserveNewlines,
	});
	return iterateOnStdoutData(onStdoutData, subprocessStdout, subprocess);
};

const iterateOnStdoutData = async function * (onStdoutData, subprocessStdout, subprocess) {
	try {
		yield * onStdoutData;
	} finally {
		if (subprocessStdout.readable) {
			subprocessStdout.destroy();
		}

		await subprocess;
	}
};

// Add methods to convert the subprocess to a stream or iterable
const addConvertedStreams = (subprocess, {encoding}) => {
	const concurrentStreams = initializeConcurrentStreams();
	subprocess.readable = createReadable.bind(undefined, {subprocess, concurrentStreams, encoding});
	subprocess.writable = createWritable.bind(undefined, {subprocess, concurrentStreams});
	subprocess.duplex = createDuplex.bind(undefined, {subprocess, concurrentStreams, encoding});
	subprocess.iterable = createIterable.bind(undefined, subprocess, encoding);
	subprocess[Symbol.asyncIterator] = createIterable.bind(undefined, subprocess, encoding, {});
};

// The return value is a mixin of `subprocess` and `Promise`
const mergePromise = (subprocess, promise) => {
	for (const [property, descriptor] of descriptors) {
		const value = descriptor.value.bind(promise);
		Reflect.defineProperty(subprocess, property, {...descriptor, value});
	}
};

// eslint-disable-next-line unicorn/prefer-top-level-await
const nativePromisePrototype = (async () => {})().constructor.prototype;

const descriptors = ['then', 'catch', 'finally'].map(property => [
	property,
	Reflect.getOwnPropertyDescriptor(nativePromisePrototype, property),
]);

// Main shared logic for all async methods: `execa()`, `$`, `execaNode()`
const execaCoreAsync = (rawFile, rawArguments, rawOptions, createNested) => {
	const {file, commandArguments, command, escapedCommand, startTime, verboseInfo, options, fileDescriptors} = handleAsyncArguments(rawFile, rawArguments, rawOptions);
	const {subprocess, promise} = spawnSubprocessAsync({
		file,
		commandArguments,
		options,
		startTime,
		verboseInfo,
		command,
		escapedCommand,
		fileDescriptors,
	});
	subprocess.pipe = pipeToSubprocess.bind(undefined, {
		source: subprocess,
		sourcePromise: promise,
		boundOptions: {},
		createNested,
	});
	mergePromise(subprocess, promise);
	SUBPROCESS_OPTIONS.set(subprocess, {options, fileDescriptors});
	return subprocess;
};

// Compute arguments to pass to `child_process.spawn()`
const handleAsyncArguments = (rawFile, rawArguments, rawOptions) => {
	const {command, escapedCommand, startTime, verboseInfo} = handleCommand(rawFile, rawArguments, rawOptions);
	const {file, commandArguments, options: normalizedOptions} = normalizeOptions(rawFile, rawArguments, rawOptions);
	const options = handleAsyncOptions(normalizedOptions);
	const fileDescriptors = handleStdioAsync(options, verboseInfo);
	return {
		file,
		commandArguments,
		command,
		escapedCommand,
		startTime,
		verboseInfo,
		options,
		fileDescriptors,
	};
};

// Options normalization logic specific to async methods.
// Prevent passing the `timeout` option directly to `child_process.spawn()`.
const handleAsyncOptions = ({timeout, signal, ...options}) => {
	if (signal !== undefined) {
		throw new TypeError('The "signal" option has been renamed to "cancelSignal" instead.');
	}

	return {...options, timeoutDuration: timeout};
};

const spawnSubprocessAsync = ({file, commandArguments, options, startTime, verboseInfo, command, escapedCommand, fileDescriptors}) => {
	let subprocess;
	try {
		subprocess = spawn(...concatenateShell(file, commandArguments, options));
	} catch (error) {
		return handleEarlyError({
			error,
			command,
			escapedCommand,
			fileDescriptors,
			options,
			startTime,
			verboseInfo,
		});
	}

	const controller = new AbortController();
	setMaxListeners(Number.POSITIVE_INFINITY, controller.signal);

	const originalStreams = [...subprocess.stdio];
	pipeOutputAsync(subprocess, fileDescriptors, controller);
	cleanupOnExit(subprocess, options, controller);

	const context = {};
	const onInternalError = createDeferred();
	subprocess.kill = subprocessKill.bind(undefined, {
		kill: subprocess.kill.bind(subprocess),
		options,
		onInternalError,
		context,
		controller,
	});
	subprocess.all = makeAllStream(subprocess, options);
	addConvertedStreams(subprocess, options);
	addIpcMethods(subprocess, options);

	const promise = handlePromise({
		subprocess,
		options,
		startTime,
		verboseInfo,
		fileDescriptors,
		originalStreams,
		command,
		escapedCommand,
		context,
		onInternalError,
		controller,
	});
	return {subprocess, promise};
};

// Asynchronous logic, as opposed to the previous logic which can be run synchronously, i.e. can be returned to user right away
const handlePromise = async ({subprocess, options, startTime, verboseInfo, fileDescriptors, originalStreams, command, escapedCommand, context, onInternalError, controller}) => {
	const [
		errorInfo,
		[exitCode, signal],
		stdioResults,
		allResult,
		ipcOutput,
	] = await waitForSubprocessResult({
		subprocess,
		options,
		context,
		verboseInfo,
		fileDescriptors,
		originalStreams,
		onInternalError,
		controller,
	});
	controller.abort();
	onInternalError.resolve();

	const stdio = stdioResults.map((stdioResult, fdNumber) => stripNewline(stdioResult, options, fdNumber));
	const all = stripNewline(allResult, options, 'all');
	const result = getAsyncResult({
		errorInfo,
		exitCode,
		signal,
		stdio,
		all,
		ipcOutput,
		context,
		options,
		command,
		escapedCommand,
		startTime,
	});
	return handleResult(result, verboseInfo, options);
};

const getAsyncResult = ({errorInfo, exitCode, signal, stdio, all, ipcOutput, context, options, command, escapedCommand, startTime}) => 'error' in errorInfo
	? makeError({
		error: errorInfo.error,
		command,
		escapedCommand,
		timedOut: context.terminationReason === 'timeout',
		isCanceled: context.terminationReason === 'cancel' || context.terminationReason === 'gracefulCancel',
		isGracefullyCanceled: context.terminationReason === 'gracefulCancel',
		isMaxBuffer: errorInfo.error instanceof MaxBufferError,
		isForcefullyTerminated: context.isForcefullyTerminated,
		exitCode,
		signal,
		stdio,
		all,
		ipcOutput,
		options,
		startTime,
		isSync: false,
	})
	: makeSuccessResult({
		command,
		escapedCommand,
		stdio,
		all,
		ipcOutput,
		options,
		startTime,
	});

// Deep merge specific options like `env`. Shallow merge the other ones.
const mergeOptions = (boundOptions, options) => {
	const newOptions = Object.fromEntries(
		Object.entries(options).map(([optionName, optionValue]) => [
			optionName,
			mergeOption(optionName, boundOptions[optionName], optionValue),
		]),
	);
	return {...boundOptions, ...newOptions};
};

const mergeOption = (optionName, boundOptionValue, optionValue) => {
	if (DEEP_OPTIONS.has(optionName) && isPlainObject(boundOptionValue) && isPlainObject(optionValue)) {
		return {...boundOptionValue, ...optionValue};
	}

	return optionValue;
};

const DEEP_OPTIONS = new Set(['env', ...FD_SPECIFIC_OPTIONS]);

// Wraps every exported methods to provide the following features:
//  - template string syntax: execa`command argument`
//  - options binding: boundExeca = execa(options)
//  - optional argument/options: execa(file), execa(file, args), execa(file, options), execa(file, args, options)
// `mapArguments()` and `setBoundExeca()` allows for method-specific logic.
const createExeca = (mapArguments, boundOptions, deepOptions, setBoundExeca) => {
	const createNested = (mapArguments, boundOptions, setBoundExeca) => createExeca(mapArguments, boundOptions, deepOptions, setBoundExeca);
	const boundExeca = (...execaArguments) => callBoundExeca({
		mapArguments,
		deepOptions,
		boundOptions,
		setBoundExeca,
		createNested,
	}, ...execaArguments);

	if (setBoundExeca !== undefined) {
		setBoundExeca(boundExeca, createNested, boundOptions);
	}

	return boundExeca;
};

const callBoundExeca = ({mapArguments, deepOptions = {}, boundOptions = {}, setBoundExeca, createNested}, firstArgument, ...nextArguments) => {
	if (isPlainObject(firstArgument)) {
		return createNested(mapArguments, mergeOptions(boundOptions, firstArgument), setBoundExeca);
	}

	const {file, commandArguments, options, isSync} = parseArguments({
		mapArguments,
		firstArgument,
		nextArguments,
		deepOptions,
		boundOptions,
	});
	return isSync
		? execaCoreSync(file, commandArguments, options)
		: execaCoreAsync(file, commandArguments, options, createNested);
};

const parseArguments = ({mapArguments, firstArgument, nextArguments, deepOptions, boundOptions}) => {
	const callArguments = isTemplateString(firstArgument)
		? parseTemplates(firstArgument, nextArguments)
		: [firstArgument, ...nextArguments];
	const [initialFile, initialArguments, initialOptions] = normalizeParameters(...callArguments);
	const mergedOptions = mergeOptions(mergeOptions(deepOptions, boundOptions), initialOptions);
	const {
		file = initialFile,
		commandArguments = initialArguments,
		options = mergedOptions,
		isSync = false,
	} = mapArguments({file: initialFile, commandArguments: initialArguments, options: mergedOptions});
	return {
		file,
		commandArguments,
		options,
		isSync,
	};
};

// Main logic for `execaCommand()`
const mapCommandAsync = ({file, commandArguments}) => parseCommand(file, commandArguments);

// Main logic for `execaCommandSync()`
const mapCommandSync = ({file, commandArguments}) => ({...parseCommand(file, commandArguments), isSync: true});

// Convert `execaCommand(command)` into `execa(file, ...commandArguments)`
const parseCommand = (command, unusedArguments) => {
	if (unusedArguments.length > 0) {
		throw new TypeError(`The command and its arguments must be passed as a single string: ${command} ${unusedArguments}.`);
	}

	const [file, ...commandArguments] = parseCommandString(command);
	return {file, commandArguments};
};

// Convert `command` string into an array of file or arguments to pass to $`${...fileOrCommandArguments}`
const parseCommandString = command => {
	if (typeof command !== 'string') {
		throw new TypeError(`The command must be a string: ${String(command)}.`);
	}

	const trimmedCommand = command.trim();
	if (trimmedCommand === '') {
		return [];
	}

	const tokens = [];
	for (const token of trimmedCommand.split(SPACES_REGEXP)) {
		// Allow spaces to be escaped by a backslash if not meant as a delimiter
		const previousToken = tokens.at(-1);
		if (previousToken && previousToken.endsWith('\\')) {
			// Merge previous token with current one
			tokens[tokens.length - 1] = `${previousToken.slice(0, -1)} ${token}`;
		} else {
			tokens.push(token);
		}
	}

	return tokens;
};

const SPACES_REGEXP = / +/g;

// Sets `$.sync` and `$.s`
const setScriptSync = (boundExeca, createNested, boundOptions) => {
	boundExeca.sync = createNested(mapScriptSync, boundOptions);
	boundExeca.s = boundExeca.sync;
};

// Main logic for `$`
const mapScriptAsync = ({options}) => getScriptOptions(options);

// Main logic for `$.sync`
const mapScriptSync = ({options}) => ({...getScriptOptions(options), isSync: true});

// `$` is like `execa` but with script-friendly options: `{stdin: 'inherit', preferLocal: true}`
const getScriptOptions = options => ({options: {...getScriptStdinOption(options), ...options}});

const getScriptStdinOption = ({input, inputFile, stdio}) => input === undefined && inputFile === undefined && stdio === undefined
	? {stdin: 'inherit'}
	: {};

// When using $(...).pipe(...), most script-friendly options should apply to both commands.
// However, some options (like `stdin: 'inherit'`) would create issues with piping, i.e. cannot be deep.
const deepScriptOptions = {preferLocal: true};

const execa = createExeca(() => ({}));
createExeca(() => ({isSync: true}));
createExeca(mapCommandAsync);
createExeca(mapCommandSync);
createExeca(mapNode);
createExeca(mapScriptAsync, {}, deepScriptOptions, setScriptSync);

getIpcExport();

async function run() {
  try {
    const projectKeyInput = coreExports.getInput("project-key");
    const directory = coreExports.getInput("directory");
    const hubUrl = coreExports.getInput("hub-url");
    if (projectKeyInput !== void 0) coreExports.debug(`Linked with: \`${projectKeyInput}\``);
    coreExports.debug(`Nuxt output directory: ${directory}`);
    coreExports.debug(`NuxtHub URL: ${hubUrl}`);
    let accessToken = "";
    const $api = ofetch.create({
      baseURL: joinURL(hubUrl, "/api"),
      onRequest({ options }) {
        if (!options.headers.has("Authorization")) {
          options.headers.set("Authorization", `Bearer ${accessToken}`);
        }
      }
    });
    const audience = projectKeyInput ? new URL(`${hubUrl}/projects/${projectKeyInput}`).toString() : void 0;
    const idToken = await coreExports.getIDToken(audience);
    coreExports.debug(`Got ID token`);
    coreExports.debug("Retrieving project information...");
    const projectInfo = await $api(`/ci-cd/token`, {
      headers: {
        Authorization: `Bearer ${idToken}`
      }
    }).catch((err) => {
      if (err.data?.statusCode === 404) throw new Error("Project not found");
      coreExports.debug(`Error: ${err.data?.message || err.message}`);
      throw err;
    });
    accessToken = projectInfo.accessToken;
    const projectKey = projectInfo.projectKey;
    coreExports.setSecret(projectInfo.accessToken);
    coreExports.debug(`Retrieved project info ${JSON.stringify(projectInfo)}`);
    const shouldBuild = coreExports.getInput("build") === "true";
    const buildCommand = coreExports.getInput("build-command") || "npm run build";
    if (shouldBuild) {
      coreExports.info(`Building ${colors$1.blueBright(projectInfo.projectSlug)} for ${colors$1.blueBright(projectInfo.environment)} environment...`);
      const envVars = await $api(
        `/teams/${projectInfo.teamSlug}/projects/${projectInfo.projectSlug}/${projectInfo.environment}/variables`
      );
      const buildEnv = {};
      for (const { key, value, encrypted } of envVars) {
        if (!value) continue;
        const isNuxtPublicEnv = key.startsWith("NUXT_PUBLIC_");
        if (encrypted && !isNuxtPublicEnv) coreExports.setSecret(value);
        buildEnv[key] = value;
      }
      const buildDirectory = join(directory, "..");
      console.log(`directory: ${directory}`);
      console.log(`buildDirectory: ${buildDirectory}`);
      console.log(`buildCommand: ${buildCommand}`);
      coreExports.info(`C.`);
      await execa({
        cwd: buildDirectory,
        stdio: "inherit",
        env: buildEnv
      })`npm run build`;
    }
    coreExports.info(`Deploying ${colors$1.blueBright(projectInfo.projectSlug)} to ${colors$1.blueBright(projectInfo.environment)} environment...`);
    coreExports.debug(`Processing files in ${directory}...`);
    const storage = await getStorage(directory);
    const fileKeys = await storage.getKeys();
    const pathsToDeploy = getPathsToDeploy(fileKeys);
    const config = await storage.getItem("hub.config.json");
    if (!config.nitroPreset && projectInfo.type === "worker") {
      throw new Error("Please upgrade `@nuxthub/core` to the latest version to deploy to a worker project.");
    }
    const isWorkerPreset = ["cloudflare_module", "cloudflare_durable", "cloudflare-module", "cloudflare-durable"].includes(config.nitroPreset);
    const { format: formatNumber } = new Intl.NumberFormat("en-US");
    const publicFiles = await getPublicFiles(storage, pathsToDeploy);
    coreExports.debug("Preparing deployment...");
    let deploymentInfo;
    try {
      let prepareUrl = `/teams/${projectInfo.teamSlug}/projects/${projectInfo.projectSlug}/${projectInfo.environment}/deploy/prepare`;
      let publicFiles2, publicManifest;
      if (isWorkerPreset) {
        prepareUrl = `/teams/${projectInfo.teamSlug}/projects/${projectInfo.projectSlug}/${projectInfo.environment}/deploy/worker/prepare`;
        publicFiles2 = await getWorkerPublicFiles(storage, pathsToDeploy);
        publicManifest = publicFiles2.reduce((acc, file) => {
          acc[file.path] = {
            hash: file.hash,
            size: file.size
          };
          return acc;
        }, {});
      } else {
        publicFiles2 = await getPublicFiles(storage, pathsToDeploy);
        publicManifest = publicFiles2.reduce((acc, file) => {
          acc[file.path] = file.hash;
          return acc;
        }, {});
      }
      deploymentInfo = await $api(prepareUrl, {
        method: "POST",
        body: {
          config,
          publicManifest
        }
      });
    } catch (err) {
      if (err.data) {
        coreExports.debug(JSON.stringify(err.data));
        throw new Error(`Error while preparing deployment: ${JSON.stringify(err.data.data?.issues || err.data.message || err.data.statusMessage || err.data)} - ${err.message}`);
      } else {
        throw new Error(`Error while preparing deployment: ${err.message.split(" - ")[1] || err.message}`);
      }
    }
    const { deploymentKey, buckets, cloudflareUploadJwt, accountId } = deploymentInfo;
    let missingPublicHashes = deploymentInfo.missingPublicHashes || buckets.flat();
    const publicFilesToUpload = publicFiles.filter((file) => missingPublicHashes.includes(file.hash));
    coreExports.debug("Uploading assets to Cloudflare...");
    let completionToken;
    if (publicFilesToUpload.length) {
      const totalSizeToUpload = publicFilesToUpload.reduce((acc, file) => acc + file.size, 0);
      coreExports.info(`Uploading ${colors$1.blueBright(formatNumber(publicFilesToUpload.length))} new static assets (${colors$1.blueBright(prettyBytes$1(totalSizeToUpload))})...`);
      if (projectInfo.type === "pages") {
        await uploadAssetsToCloudflare(publicFilesToUpload, cloudflareUploadJwt, ({ progressSize, totalSize }) => {
          const percentage = Math.round(progressSize / totalSize * 100);
          coreExports.info(`${percentage}% uploaded (${prettyBytes$1(progressSize)}/${prettyBytes$1(totalSize)})`);
        });
      } else {
        completionToken = await uploadWorkersAssetsToCloudflare(accountId, publicFilesToUpload, cloudflareUploadJwt, ({ progressSize, totalSize }) => {
          const percentage = Math.round(progressSize / totalSize * 100);
          coreExports.info(`${percentage}% uploaded (${prettyBytes$1(progressSize)}/${prettyBytes$1(totalSize)})`);
        });
      }
      coreExports.info(`${colors$1.blueBright(formatNumber(publicFilesToUpload.length))} new static assets uploaded (${colors$1.blueBright(prettyBytes$1(totalSizeToUpload))})`);
    }
    if (publicFiles.length) {
      const totalSize = publicFiles.reduce((acc, file) => acc + file.size, 0);
      const totalGzipSize = publicFiles.reduce((acc, file) => acc + file.gzipSize, 0);
      coreExports.info(`${colors$1.blueBright(formatNumber(publicFiles.length))} static assets (${colors$1.blueBright(prettyBytes$1(totalSize))} / ${colors$1.blueBright(prettyBytes$1(totalGzipSize))} gzip)`);
    }
    const metaFiles = await Promise.all(pathsToDeploy.filter(isWorkerPreset ? isWorkerMetaPath : isMetaPath).map((p) => getFile(storage, p, "base64")));
    let serverFiles = await Promise.all(pathsToDeploy.filter(isWorkerPreset ? isWorkerServerPath : isServerPath).map((p) => getFile(storage, p, "base64")));
    if (isWorkerPreset) {
      serverFiles = serverFiles.map((file) => ({
        ...file,
        path: file.path.replace("/server/", "/")
      }));
    }
    const serverFilesSize = serverFiles.reduce((acc, file) => acc + file.size, 0);
    const serverFilesGzipSize = serverFiles.reduce((acc, file) => acc + file.gzipSize, 0);
    coreExports.info(`${colors$1.blueBright(formatNumber(serverFiles.length))} server files (${colors$1.blueBright(prettyBytes$1(serverFilesSize))} / ${colors$1.blueBright(prettyBytes$1(serverFilesGzipSize))} gzip)`);
    if (!config.database) {
      coreExports.info("Skipping database migrations and queries - database not enabled in config");
    }
    if (config.database) {
      coreExports.info("Processing database migrations...");
      const localMigrations = fileKeys.filter((fileKey) => fileKey.startsWith("database:migrations:") && fileKey.endsWith(".sql")).map((fileKey) => fileKey.replace("database:migrations:", "").replace(".sql", ""));
      if (!localMigrations.length) {
        coreExports.info(`Skipping database migrations - no database migrations found in ${colors$1.blueBright(`${directory}/database/migrations`)}`);
        coreExports.info("No pending migrations to apply");
      }
      if (localMigrations.length) {
        coreExports.debug("Creating migrations table if non-existent...");
        await createMigrationsTable({
          hubUrl,
          projectKey,
          token: projectInfo.accessToken,
          env: projectInfo.environment
        });
        coreExports.debug("Fetching remote migrations...");
        const remoteMigrations = await fetchRemoteMigrations({
          hubUrl,
          projectKey,
          token: projectInfo.accessToken,
          env: projectInfo.environment
        });
        coreExports.info(`Found ${colors$1.blueBright(remoteMigrations.length)} applied database migration${remoteMigrations.length === 1 ? "" : "s"}`);
        const pendingMigrations = localMigrations.filter((localName) => !remoteMigrations.find(({ name }) => name === localName));
        if (!pendingMigrations.length) coreExports.info("No pending migrations to apply");
        for (const queryName of pendingMigrations) {
          let query = await storage.getItem(`database/migrations/${queryName}.sql`);
          if (query.at(-1) !== ";") query += ";";
          query += `INSERT INTO _hub_migrations (name) values ('${queryName}');`;
          coreExports.info(`Applying database migration ${colors$1.blueBright(queryName)}...`);
          coreExports.debug(query);
          try {
            await queryDatabase({
              hubUrl,
              projectKey,
              token: projectInfo.accessToken,
              env: projectInfo.environment,
              query
            });
            coreExports.info(`Applied database migration ${colors$1.blueBright(queryName)}`);
          } catch (error) {
            const errorMessage = error?.response?._data?.message || error?.message;
            coreExports.error(errorMessage, {
              file: join("server/database/migrations", `${queryName}.sql`),
              title: "Database migration failed"
            });
            throw new Error(`Failed to apply database migration ${queryName}: ${errorMessage}`);
          }
        }
        if (pendingMigrations.length) coreExports.info(`${colors$1.blueBright(formatNumber(localMigrations.length))} database migrations applied`);
      }
      const localQueries = fileKeys.filter((fileKey) => fileKey.startsWith("database:queries:") && fileKey.endsWith(".sql")).map((fileKey) => fileKey.replace("database:queries:", "").replace(".sql", ""));
      if (!localQueries.length) {
        coreExports.info(`Skipping database queries - no database queries found in ${colors$1.blueBright(`${directory}/database/queries`)}`);
      }
      if (localQueries.length) {
        coreExports.info(`Applying ${colors$1.blueBright(formatNumber(localQueries.length))} database ${localQueries.length === 1 ? "query" : "queries"}...`);
        for (const queryName of localQueries) {
          const query = await storage.getItem(`database/queries/${queryName}.sql`);
          coreExports.info(`Applying database query ${colors$1.blueBright(queryName)}...`);
          coreExports.debug(query);
          try {
            await queryDatabase({
              hubUrl,
              projectKey,
              token: projectInfo.accessToken,
              env: projectInfo.environment,
              query
            });
            coreExports.info(`Applied database query ${colors$1.blueBright(queryName)}`);
          } catch (error) {
            const errorMessage = error?.response?._data?.message || error?.message;
            coreExports.error(errorMessage, {
              file: join("server/database/queries", `${queryName}.sql`),
              title: "Database query failed"
            });
            throw new Error(`Failed to apply database query ${queryName}: ${errorMessage}`);
          }
        }
        coreExports.info(`${colors$1.blueBright(formatNumber(localQueries.length))} database ${localQueries.length === 1 ? "query" : "queries"} applied`);
      }
    }
    coreExports.info(`Publishing deployment...`);
    const deployment = await $api(`/teams/${projectInfo.teamSlug}/projects/${projectInfo.projectSlug}/${projectInfo.environment}/deploy/${isWorkerPreset ? "worker/complete" : "complete"}`, {
      method: "POST",
      body: {
        deploymentKey,
        serverFiles,
        metaFiles,
        completionToken
      }
    }).catch((err) => {
      if (err.data) {
        coreExports.debug(JSON.stringify(err.data));
        throw new Error(`Error while publishing deployment: ${JSON.stringify(err.data.data?.issues || err.data.message || err.data.statusMessage || err.data)} - ${err.message}`);
      } else {
        throw new Error(`Error while publishing deployment: ${err.message.split(" - ")[1] || err.message}`);
      }
    });
    coreExports.debug(`Deployment details ${JSON.stringify(deployment)}`);
    coreExports.setOutput("deployment-url", deployment.primaryUrl || deployment.url);
    coreExports.setOutput("environment-url", projectInfo.environmentUrl);
    coreExports.setOutput("branch-url", deployment.branchUrl);
    coreExports.setOutput("environment", projectInfo.environment);
    coreExports.info(`Deployed to ${projectInfo.environment}: ${deployment.url ?? deployment.primaryUrl}`);
  } catch (error) {
    if (error instanceof Error) coreExports.setFailed(error.message);
  }
}

run();

export { Yr as Y, Zt as Z };
